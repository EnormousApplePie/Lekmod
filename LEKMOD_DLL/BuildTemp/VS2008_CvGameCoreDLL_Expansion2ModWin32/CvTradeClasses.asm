; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTradeClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG220350 DB	'land', 00H
$SG222724 DB	00H
	ORG $+2
$SG220352 DB	'sea', 00H
$SG220359 DB	'food', 00H
	ORG $+3
$SG220361 DB	'production', 00H
	ORG $+1
$SG220363 DB	'international', 00H
	ORG $+2
$SG220366 DB	'%s, New Trade Route, %s, %s, %s, %i, %s', 00H
$SG221030 DB	'TradeRouteLog.csv', 00H
	ORG $+2
$SG221040 DB	'%03d,', 00H
	ORG $+2
$SG222009 DB	'CIVILIZATION_ARABIA', 00H
$SG222012 DB	'CIVILIZATION_PERSIA', 00H
$SG222015 DB	'CIVILIZATION_MONGOL', 00H
$SG222018 DB	'CIVILIZATION_CHINA', 00H
	ORG $+1
$SG222021 DB	'CIVILIZATION_INDIA', 00H
	ORG $+1
$SG222282 DB	'[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]', 00H
	ORG $+1
$SG222294 DB	'TXT_KEY_UNIT_CARAVAN', 00H
	ORG $+3
$SG222295 DB	'TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP', 00H
	ORG $+3
$SG222305 DB	'TXT_KEY_UNIT_CARGO_SHIP', 00H
$SG222306 DB	'TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP', 00H
	ORG $+3
$SG222320 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_SUMMARY'
	DB	00H
	ORG $+3
$SG222323 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_BARBARI'
	DB	'AN', 00H
	ORG $+1
$SG222334 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_KNOWN', 00H
	ORG $+1
$SG222343 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_UNKNOWN'
	DB	00H
	ORG $+3
$SG222351 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_SUMMARY'
	DB	00H
	ORG $+3
$SG222354 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_BARBARI'
	DB	'ANS', 00H
$SG222364 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_KNOWN', 00H
	ORG $+1
$SG222377 DB	'TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_UNKNOWN'
	DB	00H
	ORG $+3
$SG222599 DB	'UNIT_CARAVAN', 00H
	ORG $+3
$SG222603 DB	'UNIT_CARGO_SHIP', 00H
$SG222650 DB	'TXT_KEY_TRADE_ROUTE_TT_PLOT_CARAVAN', 00H
$SG222657 DB	'TXT_KEY_TRADE_ROUTE_TT_PLOT_CARGO_SHIP', 00H
	ORG $+1
$SG222663 DB	'TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJOR_MINOR', 00H
$SG222665 DB	'NULL Origin City', 00H
	ORG $+3
$SG222668 DB	'NULL Dest City', 00H
	ORG $+1
$SG222671 DB	'TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJOR_MAJOR', 00H
$SG222673 DB	'NULL Origin City', 00H
	ORG $+3
$SG222676 DB	'NULL Dest City', 00H
	ORG $+1
$SG222726 DB	'TXT_KEY_MULTIPLAYER_UNIT_TT', 00H
$SG222732 DB	'TXT_KEY_PLOTROLL_UNIT_DESCRIPTION_CIV', 00H
	ORG $+2
$SG222738 DB	'[COLOR_WHITE]{1_InnerStr}[ENDCOLOR]', 00H
$SG222746 DB	'[COLOR_NEGATIVE_TEXT]{1_InnerStr}[ENDCOLOR]', 00H
$SG222748 DB	'[COLOR_POSITIVE_TEXT]{1_InnerStr}[ENDCOLOR]', 00H
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z ; CvGameTrade::GetDomainModifierTimes100
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_eDomain$ = 8						; size = 4
?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z PROC ; CvGameTrade::GetDomainModifierTimes100, COMDAT
; _this$ = ecx

; 727  : 	if (eDomain == DOMAIN_SEA)

	mov	eax, DWORD PTR _eDomain$[esp-4]
	neg	eax
	sbb	eax, eax
	and	eax, -100				; ffffff9cH
	add	eax, 100				; 00000064H

; 728  : 	{
; 729  : 		return 100;
; 730  : 	}
; 731  : 	else
; 732  : 	{
; 733  : 		return 0;
; 734  : 	}
; 735  : }

	ret	4
?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z ENDP ; CvGameTrade::GetDomainModifierTimes100
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?ResetTechDifference@CvGameTrade@@QAEXXZ	; CvGameTrade::ResetTechDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?ResetTechDifference@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
?ResetTechDifference@CvGameTrade@@QAEXXZ PROC		; CvGameTrade::ResetTechDifference, COMDAT
; _this$ = ecx

; 1590 : {

	push	edi

; 1591 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	lea	edi, DWORD PTR [ecx+74612]

; 1592 : 	{
; 1593 : 		for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)
; 1594 : 		{
; 1595 : 			m_aaiTechDifference[ui][ui2] = -1; // undefined

	mov	ecx, 484				; 000001e4H
	or	eax, -1
	rep stosd
	pop	edi

; 1596 : #endif
; 1597 : 		}
; 1598 : 	}
; 1599 : }

	ret	0
?ResetTechDifference@CvGameTrade@@QAEXXZ ENDP		; CvGameTrade::ResetTechDifference
_TEXT	ENDS
PUBLIC	_ceilf
EXTRN	__imp__ceil:PROC
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv71 = 8						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 397  :         {return ((float)ceil((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv71[esp+4]
	add	esp, 8
	fld	DWORD PTR tv71[esp-4]
	ret	0
_ceilf	ENDP
_TEXT	ENDS
PUBLIC	?ceil@@YAMM@Z					; ceil
; Function compile flags: /Ogtpy
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
$T228568 = 8						; size = 4
__X$ = 8						; size = 4
?ceil@@YAMM@Z PROC					; ceil, COMDAT

; 502  :         {return (ceilf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv73[esp+4]
	add	esp, 8
	fld	DWORD PTR tv73[esp-4]
	fstp	DWORD PTR $T228568[esp-4]
	fld	DWORD PTR $T228568[esp-4]
	ret	0
?ceil@@YAMM@Z ENDP					; ceil
_TEXT	ENDS
PUBLIC	?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z ; CvPlayerTrade::GetTradeRouteSpeed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_eDomain$ = 8						; size = 4
?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z PROC ; CvPlayerTrade::GetTradeRouteSpeed, COMDAT
; _this$ = ecx

; 4141 : 	switch (eDomain)

	mov	eax, DWORD PTR _eDomain$[esp-4]
	sub	eax, 0
	je	SHORT $LN2@GetTradeRo
	sub	eax, 2
	je	SHORT $LN1@GetTradeRo

; 4148 : 		break;
; 4149 : 	}
; 4150 : 
; 4151 : 	CvAssertMsg(false, "Undefined domain for trade route speed");
; 4152 : 	return -1;

	or	eax, -1

; 4153 : }

	ret	4
$LN1@GetTradeRo:

; 4145 : 		break;
; 4146 : 	case DOMAIN_LAND:
; 4147 : 		return 2;

	mov	eax, 2

; 4153 : }

	ret	4
$LN2@GetTradeRo:

; 4142 : 	{
; 4143 : 	case DOMAIN_SEA:
; 4144 : 		return 4;

	mov	eax, 4

; 4153 : }

	ret	4
?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z ENDP ; CvPlayerTrade::GetTradeRouteSpeed
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z	; CvPlayerTrade::GetNumTradeRoutesUsed
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?getNumTrainUnitAI@CvCity@@QBEHW4UnitAITypes@@@Z:PROC ; CvCity::getNumTrainUnitAI
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_bContinueTraining$ = 8					; size = 1
?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z PROC	; CvPlayerTrade::GetNumTradeRoutesUsed, COMDAT
; _this$ = ecx

; 4254 : {

	push	ecx
	push	esi
	push	edi

; 4255 : 	int iReturnValue = 0;

	xor	edi, edi
	mov	esi, ecx

; 4256 : 	int iLoop;
; 4257 : 
; 4258 : 	// look for units on the map
; 4259 : 	CvUnit* pLoopUnit;
; 4260 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [esi+79104]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN6@GetNumTrad
	npad	4
$LL8@GetNumTrad:

; 4261 : 	{
; 4262 : 		if (pLoopUnit->isTrade())

	mov	ecx, eax
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	test	al, al
	je	SHORT $LN7@GetNumTrad

; 4263 : 		{
; 4264 : 			iReturnValue++;

	inc	edi
$LN7@GetNumTrad:

; 4256 : 	int iLoop;
; 4257 : 
; 4258 : 	// look for units on the map
; 4259 : 	CvUnit* pLoopUnit;
; 4260 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+79104]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL8@GetNumTrad
$LN6@GetNumTrad:

; 4265 : 		}
; 4266 : 	}
; 4267 : 
; 4268 : 	// look inside cities
; 4269 : 	if (!bContinueTraining)

	cmp	BYTE PTR _bContinueTraining$[esp+8], 0
	jne	SHORT $LN16@GetNumTrad

; 4270 : 	{
; 4271 : 		CvCity* pLoopCity;
; 4272 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+79104]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+16]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN16@GetNumTrad
	npad	1
$LL3@GetNumTrad:

; 4273 : 		{
; 4274 : 			iReturnValue += pLoopCity->getNumTrainUnitAI(UNITAI_TRADE_UNIT);

	push	38					; 00000026H
	mov	ecx, eax
	call	?getNumTrainUnitAI@CvCity@@QBEHW4UnitAITypes@@@Z ; CvCity::getNumTrainUnitAI
	mov	ecx, DWORD PTR [esi+79104]
	add	edi, eax
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetNumTrad
$LN16@GetNumTrad:

; 4275 : 		}
; 4276 : 	}
; 4277 : 
; 4278 : 	return iReturnValue;

	mov	eax, edi
	pop	edi
	pop	esi

; 4279 : }

	pop	ecx
	ret	4
?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ENDP	; CvPlayerTrade::GetNumTradeRoutesUsed
_TEXT	ENDS
PUBLIC	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_eDomain$ = 8						; size = 4
?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z PROC ; CvPlayerTrade::GetTradeUnit, COMDAT

; 4487 : 	UnitTypes eUnitType = NO_UNIT;
; 4488 : 	if (eDomain == DOMAIN_LAND)

	mov	ecx, DWORD PTR _eDomain$[esp-4]
	or	eax, -1
	cmp	ecx, 2
	jne	SHORT $LN3@GetTradeUn

; 4489 : 	{
; 4490 : 		eUnitType = (UnitTypes)GC.getInfoTypeForString("UNIT_CARAVAN");

	push	0
	push	OFFSET $SG222599

; 4493 : 	{
; 4494 : 		eUnitType = (UnitTypes)GC.getInfoTypeForString("UNIT_CARGO_SHIP");

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4495 : 	}
; 4496 : 
; 4497 : 	return eUnitType;
; 4498 : }

	ret	0
$LN3@GetTradeUn:

; 4491 : 	}
; 4492 : 	else if (eDomain == DOMAIN_SEA)

	test	ecx, ecx
	jne	SHORT $LN1@GetTradeUn

; 4493 : 	{
; 4494 : 		eUnitType = (UnitTypes)GC.getInfoTypeForString("UNIT_CARGO_SHIP");

	push	ecx
	push	OFFSET $SG222603
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
$LN1@GetTradeUn:

; 4495 : 	}
; 4496 : 
; 4497 : 	return eUnitType;
; 4498 : }

	ret	0
?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ENDP ; CvPlayerTrade::GetTradeUnit
_TEXT	ENDS
PUBLIC	??0CvTradeAI@@QAE@XZ				; CvTradeAI::CvTradeAI
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTradeAI@@QAE@XZ
_TEXT	SEGMENT
??0CvTradeAI@@QAE@XZ PROC				; CvTradeAI::CvTradeAI, COMDAT
; _this$ = ecx

; 4926 : {

	mov	eax, ecx
	mov	DWORD PTR [eax+4], 0

; 4927 : }

	ret	0
??0CvTradeAI@@QAE@XZ ENDP				; CvTradeAI::CvTradeAI
_TEXT	ENDS
PUBLIC	?Reset@CvTradeAI@@QAEXXZ			; CvTradeAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvTradeAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvTradeAI@@QAEXXZ PROC				; CvTradeAI::Reset, COMDAT
; _this$ = ecx

; 4952 : 	m_pPlayer = NULL;

	mov	DWORD PTR [ecx+4], 0

; 4953 : }

	ret	0
?Reset@CvTradeAI@@QAEXXZ ENDP				; CvTradeAI::Reset
_TEXT	ENDS
PUBLIC	?DoTurn@CvTradeAI@@QAEXXZ			; CvTradeAI::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvTradeAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvTradeAI@@QAEXXZ PROC				; CvTradeAI::DoTurn, COMDAT
; _this$ = ecx

; 4958 : 
; 4959 : }

	ret	0
?DoTurn@CvTradeAI@@QAEXXZ ENDP				; CvTradeAI::DoTurn
_TEXT	ENDS
PUBLIC	??RSortTR@@QBE_NABUTRSortElement@@0@Z		; SortTR::operator()
; Function compile flags: /Ogtpy
;	COMDAT ??RSortTR@@QBE_NABUTRSortElement@@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??RSortTR@@QBE_NABUTRSortElement@@0@Z PROC		; SortTR::operator(), COMDAT
; _this$ = ecx

; 5339 : 		return a.m_iScore < b.m_iScore;

	mov	eax, DWORD PTR _a$[esp-4]
	mov	ecx, DWORD PTR [eax+444]
	mov	edx, DWORD PTR _b$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+444]
	setl	al

; 5340 : 	}

	ret	8
??RSortTR@@QBE_NABUTRSortElement@@0@Z ENDP		; SortTR::operator()
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEAAUTradeConnectionPlot@@I@Z ; BaseVector<TradeConnectionPlot,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEAAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEAAUTradeConnectionPlot@@I@Z PROC ; BaseVector<TradeConnectionPlot,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEAAUTradeConnectionPlot@@I@Z ENDP ; BaseVector<TradeConnectionPlot,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEABUTradeConnectionPlot@@I@Z ; BaseVector<TradeConnectionPlot,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEABUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEABUTradeConnectionPlot@@I@Z PROC ; BaseVector<TradeConnectionPlot,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEABUTradeConnectionPlot@@I@Z ENDP ; BaseVector<TradeConnectionPlot,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEIXZ ; BaseVector<TradeConnectionPlot,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEIXZ PROC ; BaseVector<TradeConnectionPlot,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UTradeConnectionPlot@@$0A@@@QBEIXZ ENDP ; BaseVector<TradeConnectionPlot,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z PROC ; BaseVector<TradeConnection,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@UTradeConnection@@$0A@@@QAEAAUTradeConnection@@I@Z ENDP ; BaseVector<TradeConnection,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnection@@$0A@@@QBEABUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UTradeConnection@@$0A@@@QBEABUTradeConnection@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnection@@$0A@@@QBEABUTradeConnection@@I@Z PROC ; BaseVector<TradeConnection,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR [ecx]

; 137  : 	};

	ret	4
??A?$BaseVector@UTradeConnection@@$0A@@@QBEABUTradeConnection@@I@Z ENDP ; BaseVector<TradeConnection,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ ; BaseVector<TradeConnection,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ PROC	; BaseVector<TradeConnection,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UTradeConnection@@$0A@@@QBEIXZ ENDP	; BaseVector<TradeConnection,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEAAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEAAUTradeConnectionWasPlundered@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEAAUTradeConnectionWasPlundered@@I@Z PROC ; BaseVector<TradeConnectionWasPlundered,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEAAUTradeConnectionWasPlundered@@I@Z ENDP ; BaseVector<TradeConnectionWasPlundered,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEABUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEABUTradeConnectionWasPlundered@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEABUTradeConnectionWasPlundered@@I@Z PROC ; BaseVector<TradeConnectionWasPlundered,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR [ecx]

; 137  : 	};

	ret	4
??A?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEABUTradeConnectionWasPlundered@@I@Z ENDP ; BaseVector<TradeConnectionWasPlundered,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEIXZ ; BaseVector<TradeConnectionWasPlundered,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEIXZ PROC ; BaseVector<TradeConnectionWasPlundered,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QBEIXZ ENDP ; BaseVector<TradeConnectionWasPlundered,0>::size
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
_TEXT	ENDS
PUBLIC	?size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAUTRSortElement@@I@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAUTRSortElement@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAUTRSortElement@@I@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR [ecx+4]

; 786  : 		}

	ret	4
??A?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAUTRSortElement@@I@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@XZ		; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvString@@@std@@QAE@XZ PROC		; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvString@@@std@@QAE@XZ ENDP		; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z	; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionPlot@@I@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionPlot@@I@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 40					; 00000028H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 40			; 00000028H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionPlot@@I@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UTradeConnectionPlot@@$0A@@@IAE@XZ ; BaseVector<TradeConnectionPlot,0>::BaseVector<TradeConnectionPlot,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UTradeConnectionPlot@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UTradeConnectionPlot@@$0A@@@IAE@XZ PROC	; BaseVector<TradeConnectionPlot,0>::BaseVector<TradeConnectionPlot,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UTradeConnectionPlot@@$0A@@@IAE@XZ ENDP	; BaseVector<TradeConnectionPlot,0>::BaseVector<TradeConnectionPlot,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ; BaseVector<TradeConnectionPlot,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z PROC ; BaseVector<TradeConnectionPlot,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ENDP ; BaseVector<TradeConnectionPlot,0>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z PROC ; BaseVector<TradeConnectionPlot,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebx, DWORD PTR _RHS$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	edi

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	edi, edi
	mov	DWORD PTR [ecx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy
	push	ebp
	push	esi
$LL3@Copy:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edi*8]
	add	eax, edx

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	je	SHORT $LN2@Copy
	mov	esi, DWORD PTR [ebx]
	mov	ebp, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax], ebp
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [eax+4], edx
$LN2@Copy:
	inc	edi
	cmp	edi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@Copy
	pop	esi
	pop	ebp
$LN1@Copy:
	pop	edi
	pop	ebx

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ENDP ; BaseVector<TradeConnectionPlot,0>::Copy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 168				; 000000a8H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, edi
	imul	eax, 444				; 000001bcH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 168			; 000000a8H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ	; BaseVector<TradeConnection,0>::BaseVector<TradeConnection,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ PROC	; BaseVector<TradeConnection,0>::BaseVector<TradeConnection,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ ENDP	; BaseVector<TradeConnection,0>::BaseVector<TradeConnection,0>
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionWasPlundered@@I@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionWasPlundered@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionWasPlundered@@I@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 10					; 0000000aH
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, edi
	imul	eax, 448				; 000001c0H
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 10			; 0000000aH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEPAUTradeConnectionWasPlundered@@I@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ PROC ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ENDP ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAE@XZ ; BaseVector<TradeConnectionWasPlundered,0>::BaseVector<TradeConnectionWasPlundered,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAE@XZ PROC ; BaseVector<TradeConnectionWasPlundered,0>::BaseVector<TradeConnectionWasPlundered,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAE@XZ ENDP ; BaseVector<TradeConnectionWasPlundered,0>::BaseVector<TradeConnectionWasPlundered,0>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@XZ		; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCity@@@std@@QAE@XZ PROC		; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCity@@@std@@QAE@XZ ENDP		; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z	; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@3

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >::~_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >::~_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >::~_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UTRSortElement@@@std@@QAE@XZ	; std::allocator<TRSortElement>::allocator<TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UTRSortElement@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UTRSortElement@@@std@@QAE@XZ PROC	; std::allocator<TRSortElement>::allocator<TRSortElement>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UTRSortElement@@@std@@QAE@XZ ENDP	; std::allocator<TRSortElement>::allocator<TRSortElement>
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228744 = -80						; size = 28
$T228743 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228744[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T228743[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T228744[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T228743[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T228743[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228743[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T228743[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228744[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228743[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ; std::allocator<CvString>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z PROC ; std::allocator<CvString>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ENDP ; std::allocator<CvString>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228787 = -80						; size = 28
$T228786 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228787[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T228786[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T228787[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T228786[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T228786[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228786[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T228786[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228787[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228786[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::deallocate
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228821 = -80						; size = 28
$T228820 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228821[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T228820[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T228821[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T228820[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T228820[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228820[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T228820[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228821[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228820[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >::_Container_base_aux_alloc_empty<std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UTRSortElement@@@std@@QAE@ABV01@@Z ; std::allocator<TRSortElement>::allocator<TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UTRSortElement@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UTRSortElement@@@std@@QAE@ABV01@@Z PROC	; std::allocator<TRSortElement>::allocator<TRSortElement>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UTRSortElement@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<TRSortElement>::allocator<TRSortElement>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@I@Z ; std::allocator<TRSortElement>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@I@Z PROC ; std::allocator<TRSortElement>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@I@Z ENDP ; std::allocator<TRSortElement>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvString@@@std@@QBEIXZ	; std::allocator<CvString>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvString@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvString@@@std@@QBEIXZ PROC	; std::allocator<CvString>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvString@@@std@@QBEIXZ ENDP	; std::allocator<CvString>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ	; std::allocator<CvCity *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ PROC	; std::allocator<CvCity *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ ENDP	; std::allocator<CvCity *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTRSortElement@@@std@@QBEIXZ ; std::allocator<TRSortElement>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UTRSortElement@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UTRSortElement@@@std@@QBEIXZ PROC	; std::allocator<TRSortElement>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 9586980				; 00924924H

; 167  : 		}

	ret	0
?max_size@?$allocator@UTRSortElement@@@std@@QBEIXZ ENDP	; std::allocator<TRSortElement>::max_size
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator==
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	imul	ecx, 448				; 000001c0H
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	256					; 00000100H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NABV12@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z PROC ; operator<<<Localization::String>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NABV12@@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ENDP ; operator<<<Localization::String>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z
_TEXT	SEGMENT
$T228920 = -12						; size = 12
$T228924 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z PROC ; std::_Allocate<CvString>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T228924[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T228920[esp+16]
	mov	DWORD PTR $T228924[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T228920[esp+16]
	push	ecx
	mov	DWORD PTR $T228920[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ENDP ; std::_Allocate<CvString>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T228930 = -12						; size = 12
$T228934 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T228934[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T228930[esp+16]
	mov	DWORD PTR $T228934[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T228930[esp+16]
	push	ecx
	mov	DWORD PTR $T228930[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
_TEXT	ENDS
PUBLIC	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z
_TEXT	SEGMENT
$T228940 = -12						; size = 12
$T228944 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z PROC ; std::_Allocate<TRSortElement>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	imul	ecx, 448				; 000001c0H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 448				; 000001c0H
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T228944[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T228940[esp+16]
	mov	DWORD PTR $T228944[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T228940[esp+16]
	push	ecx
	mov	DWORD PTR $T228940[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ENDP ; std::_Allocate<TRSortElement>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z ; operator<<<21>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBDI@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z PROC ; operator<<<21>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	20					; 00000014H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z ENDP ; operator<<<21>
_TEXT	ENDS
PUBLIC	??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z ; operator<<<24>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z PROC ; operator<<<24>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	23					; 00000017H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z ENDP ; operator<<<24>
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAPAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ; std::_Ptr_cat<CvString *,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z PROC ; std::_Ptr_cat<CvString *,CvString *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ENDP ; std::_Ptr_cat<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ; std::_Ptr_cat<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z PROC ; std::_Ptr_cat<CvCity * *,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ENDP ; std::_Ptr_cat<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUTRSortElement@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0@Z ; std::_Iter_random<TRSortElement *,TRSortElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUTRSortElement@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUTRSortElement@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0@Z PROC ; std::_Iter_random<TRSortElement *,TRSortElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUTRSortElement@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0@Z ENDP ; std::_Iter_random<TRSortElement *,TRSortElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTRSortElement@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@0@Z ; std::_Ptr_cat<TRSortElement *,TRSortElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUTRSortElement@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTRSortElement@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@0@Z PROC ; std::_Ptr_cat<TRSortElement *,TRSortElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUTRSortElement@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@0@Z ENDP ; std::_Ptr_cat<TRSortElement *,TRSortElement *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ; std::_Iter_random<CvString *,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z PROC ; std::_Iter_random<CvString *,CvString *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ENDP ; std::_Iter_random<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ; std::_Move_cat<CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z PROC ; std::_Move_cat<CvString *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ENDP ; std::_Move_cat<CvString *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::_Fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::_Fill<CvCity * *,CvCity *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::_Fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ; std::_Iter_random<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z PROC ; std::_Iter_random<CvCity * *,CvCity * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ENDP ; std::_Iter_random<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ; std::_Move_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Move_cat<CvCity * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Move_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUTRSortElement@@@std@@YA?AU_Undefined_move_tag@0@ABQAUTRSortElement@@@Z ; std::_Move_cat<TRSortElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUTRSortElement@@@std@@YA?AU_Undefined_move_tag@0@ABQAUTRSortElement@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUTRSortElement@@@std@@YA?AU_Undefined_move_tag@0@ABQAUTRSortElement@@@Z PROC ; std::_Move_cat<TRSortElement *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUTRSortElement@@@std@@YA?AU_Undefined_move_tag@0@ABQAUTRSortElement@@@Z ENDP ; std::_Move_cat<TRSortElement *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@H@Z ; std::_Temp_iterator<TRSortElement>::_Temp_iterator<TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<TRSortElement>::_Temp_iterator<TRSortElement>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<TRSortElement>::_Temp_iterator<TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@AAPAVCvString@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@AAPAVCvString@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@AAPAVCvString@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@AAPAVCvString@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ; std::return_temporary_buffer<TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z PROC ; std::return_temporary_buffer<TRSortElement>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ENDP ; std::return_temporary_buffer<TRSortElement>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@XZ ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@XZ PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@XZ ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 28			; 0000001cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator++
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ; std::_Iter_cat<CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Iter_cat<CvCity * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Iter_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??$_Construct@HH@std@@YAXPAHABH@Z		; std::_Construct<int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@HH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HH@std@@YAXPAHABH@Z PROC			; std::_Construct<int,int>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@HH@std@@YAXPAHABH@Z ENDP			; std::_Construct<int,int>
_TEXT	ENDS
PUBLIC	??$_Destroy@H@std@@YAXPAH@Z			; std::_Destroy<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@H@std@@YAXPAH@Z PROC			; std::_Destroy<int>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@H@std@@YAXPAH@Z ENDP			; std::_Destroy<int>
_TEXT	ENDS
PUBLIC	??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z ; std::_Construct<CvCity *,CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z PROC ; std::_Construct<CvCity *,CvCity *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z ENDP ; std::_Construct<CvCity *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z	; std::_Destroy<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z PROC	; std::_Destroy<CvCity *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z ENDP	; std::_Destroy<CvCity *>
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??G?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@1@@Z ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@1@@Z PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 399  : 		}

	ret	4
??G?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@1@@Z ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator-
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<TRSortElement>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<TRSortElement>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<TRSortElement>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ ; std::_Temp_iterator<TRSortElement>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ PROC ; std::_Temp_iterator<TRSortElement>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ ENDP ; std::_Temp_iterator<TRSortElement>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ ; std::_Temp_iterator<TRSortElement>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ PROC ; std::_Temp_iterator<TRSortElement>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@UTRSortElement@@@std@@QBEPAUTRSortElement@@XZ ENDP ; std::_Temp_iterator<TRSortElement>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAUTRSortElement@@H@std@@QAE@ABQAUTRSortElement@@ABH@Z ; std::pair<TRSortElement *,int>::pair<TRSortElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUTRSortElement@@H@std@@QAE@ABQAUTRSortElement@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUTRSortElement@@H@std@@QAE@ABQAUTRSortElement@@ABH@Z PROC ; std::pair<TRSortElement *,int>::pair<TRSortElement *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUTRSortElement@@H@std@@QAE@ABQAUTRSortElement@@ABH@Z ENDP ; std::pair<TRSortElement *,int>::pair<TRSortElement *,int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEABUTRSortElement@@XZ ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEABUTRSortElement@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEABUTRSortElement@@XZ PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEABUTRSortElement@@XZ ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<TRSortElement>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<TRSortElement>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<TRSortElement>::operator=
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 448			; 000001c0H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -448			; fffffe40H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator--
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@ABV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@ABV?$_Temp_iterator@UTRSortElement@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@ABV?$_Temp_iterator@UTRSortElement@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@ABV?$_Temp_iterator@UTRSortElement@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@AAV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@AAV?$_Temp_iterator@UTRSortElement@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@AAV?$_Temp_iterator@UTRSortElement@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@AAV?$_Temp_iterator@UTRSortElement@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@1@Z ; std::_Iter_random<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@1@Z PROC ; std::_Iter_random<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@1@Z ENDP ; std::_Iter_random<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator@2

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator@2:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<TRSortElement>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<TRSortElement>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<TRSortElement>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<TRSortElement>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<TRSortElement>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<TRSortElement>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ; std::_Iter_random<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z PROC ; std::_Iter_random<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ENDP ; std::_Iter_random<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ; std::_Ptr_cat<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z PROC ; std::_Ptr_cat<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTRSortElement@@AAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ENDP ; std::_Ptr_cat<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0ABV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0ABV?$_Temp_iterator@UTRSortElement@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0ABV?$_Temp_iterator@UTRSortElement@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0ABV?$_Temp_iterator@UTRSortElement@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAUTRSortElement@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@@Z ; std::_Iter_cat<TRSortElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAUTRSortElement@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAUTRSortElement@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@@Z PROC ; std::_Iter_cat<TRSortElement *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAUTRSortElement@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@@Z ENDP ; std::_Iter_cat<TRSortElement *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<TRSortElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<TRSortElement *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	imul	ecx, 448				; 000001c0H
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<TRSortElement *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ; std::_Iter_random<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z PROC ; std::_Iter_random<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTRSortElement@@0ABV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@@Z ENDP ; std::_Iter_random<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ	; CvGlobals::getEVENT_MESSAGE_TIME
; Function compile flags: /Ogtpy
;	COMDAT ?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ PROC		; CvGlobals::getEVENT_MESSAGE_TIME, COMDAT
; _this$ = ecx

; 5252 : 		return m_iEVENT_MESSAGE_TIME;

	mov	eax, DWORD PTR [ecx+6176]

; 5253 : 	}

	ret	0
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getEVENT_MESSAGE_TIME
_TEXT	ENDS
PUBLIC	?getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER, COMDAT
; _this$ = ecx

; 7399 : 		return m_iRELIGION_MISSIONARY_PRESSURE_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+7900]

; 7400 : 	}

	ret	0
?getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getINTERNATIONAL_TRADE_BASE@CvGlobals@@QAEHXZ	; CvGlobals::getINTERNATIONAL_TRADE_BASE
; Function compile flags: /Ogtpy
;	COMDAT ?getINTERNATIONAL_TRADE_BASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINTERNATIONAL_TRADE_BASE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getINTERNATIONAL_TRADE_BASE, COMDAT
; _this$ = ecx

; 7483 : 		return m_iINTERNATIONAL_TRADE_BASE;

	mov	eax, DWORD PTR [ecx+7956]

; 7484 : 	}

	ret	0
?getINTERNATIONAL_TRADE_BASE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getINTERNATIONAL_TRADE_BASE
_TEXT	ENDS
PUBLIC	?getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION@CvGlobals@@QAEHXZ ; CvGlobals::getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION
; Function compile flags: /Ogtpy
;	COMDAT ?getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION, COMDAT
; _this$ = ecx

; 7487 : 		return m_iINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION;

	mov	eax, DWORD PTR [ecx+7960]

; 7488 : 	}

	ret	0
?getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION
_TEXT	ENDS
PUBLIC	?getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR, COMDAT
; _this$ = ecx

; 7491 : 		return m_iINTERNATIONAL_TRADE_CITY_GPT_DIVISOR;

	mov	eax, DWORD PTR [ecx+7964]

; 7492 : 	}

	ret	0
?getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_FREEDOM
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_FREEDOM, COMDAT
; _this$ = ecx

; 7599 : 		return m_iPOLICY_BRANCH_FREEDOM;

	mov	eax, DWORD PTR [ecx+8376]

; 7600 : 	}

	ret	0
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_FREEDOM
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY, COMDAT
; _this$ = ecx

; 7603 : 		return m_iPOLICY_BRANCH_AUTOCRACY;

	mov	eax, DWORD PTR [ecx+8380]

; 7604 : 	}

	ret	0
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_ORDER
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPOLICY_BRANCH_ORDER, COMDAT
; _this$ = ecx

; 7607 : 		return m_iPOLICY_BRANCH_ORDER;

	mov	eax, DWORD PTR [ecx+8384]

; 7608 : 	}

	ret	0
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPOLICY_BRANCH_ORDER
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7738 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8596]

; 7739 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7748 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8600]

; 7749 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetNumTradeRoutesModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetNumTradeRoutesModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetNumTradeRoutesModifier@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetNumTradeRoutesModifier, COMDAT
; _this$ = ecx

; 712  : 		return m_iNumTradeRoutesModifier;

	mov	eax, DWORD PTR [ecx+292]

; 713  : 	}

	ret	0
?GetNumTradeRoutesModifier@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetNumTradeRoutesModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteResourceModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetTradeRouteResourceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteResourceModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteResourceModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetTradeRouteResourceModifier, COMDAT
; _this$ = ecx

; 716  : 		return m_iTradeRouteResourceModifier;

	mov	eax, DWORD PTR [ecx+296]

; 717  : 	}

	ret	0
?GetTradeRouteResourceModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetTradeRouteResourceModifier
_TEXT	ENDS
PUBLIC	?GetLandTradeRouteRangeBonus@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetLandTradeRouteRangeBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandTradeRouteRangeBonus@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetLandTradeRouteRangeBonus@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetLandTradeRouteRangeBonus, COMDAT
; _this$ = ecx

; 736  : 		return m_iLandTradeRouteRangeBonus;

	mov	eax, DWORD PTR [ecx+320]

; 737  : 	}

	ret	0
?GetLandTradeRouteRangeBonus@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetLandTradeRouteRangeBonus
_TEXT	ENDS
PUBLIC	?GetTradeBuildingModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetTradeBuildingModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeBuildingModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetTradeBuildingModifier@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetTradeBuildingModifier, COMDAT
; _this$ = ecx

; 744  : 		return m_iTradeBuildingModifier;

	mov	eax, DWORD PTR [ecx+328]

; 745  : 	}

	ret	0
?GetTradeBuildingModifier@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetTradeBuildingModifier
_TEXT	ENDS
PUBLIC	?GetYieldChangeIncomingTradeRoute@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ; CvPlayerTraits::GetYieldChangeIncomingTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeIncomingTradeRoute@CvPlayerTraits@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldChangeIncomingTradeRoute@CvPlayerTraits@@QBEHW4YieldTypes@@@Z PROC ; CvPlayerTraits::GetYieldChangeIncomingTradeRoute, COMDAT
; _this$ = ecx

; 894  : 		return m_iYieldChangeIncomingTradeRoute[(int)eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+528]

; 895  : 	};

	ret	4
?GetYieldChangeIncomingTradeRoute@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetYieldChangeIncomingTradeRoute
_TEXT	ENDS
PUBLIC	?GetExtraTradeRoutes@CvReligionBeliefs@@QBEHXZ	; CvReligionBeliefs::GetExtraTradeRoutes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.h
;	COMDAT ?GetExtraTradeRoutes@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
?GetExtraTradeRoutes@CvReligionBeliefs@@QBEHXZ PROC	; CvReligionBeliefs::GetExtraTradeRoutes, COMDAT
; _this$ = ecx

; 412  : 		return m_iExtraTradeRoutes;

	mov	eax, DWORD PTR [ecx+72]

; 413  : 	};

	ret	0
?GetExtraTradeRoutes@CvReligionBeliefs@@QBEHXZ ENDP	; CvReligionBeliefs::GetExtraTradeRoutes
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229339 = -80						; size = 28
$T229338 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229339[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229338[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229339[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229338[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229338[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229338[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229338[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229339[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229338[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T229404 = -12						; size = 12
$T229408 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229408[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229404[esp+16]
	mov	DWORD PTR $T229408[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229404[esp+16]
	push	ecx
	mov	DWORD PTR $T229404[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ; std::vector<bool,std::allocator<bool> >::_Nw
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z PROC	; std::vector<bool,std::allocator<bool> >::_Nw, COMDAT

; 2331 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[esp-4]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2332 : 		}

	ret	0
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ENDP	; std::vector<bool,std::allocator<bool> >::_Nw
_TEXT	ENDS
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T229437 = -80						; size = 28
$T229436 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229437[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229436[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229437[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229436[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229436[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229436[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229436[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T229437[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T229436[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229468 = -80						; size = 28
$T229467 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229468[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229467[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229468[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229467[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229467[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229467[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229467[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229468[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229467[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	mov	eax, ecx

; 1603 : 		if (_Off == 0)

	mov	ecx, DWORD PTR __Off$[esp-4]
	test	ecx, ecx

; 1604 : 			return (*this); // early out

	je	SHORT $LN6@operator@3
	push	esi

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jge	SHORT $LN2@operator@3
	mov	edx, DWORD PTR [eax+4]
	mov	esi, ecx
	neg	esi
	cmp	edx, esi
	jae	SHORT $LN2@operator@3

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	add	ecx, edx

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	edx, -1
	sub	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	esi, -4					; fffffffcH
	sub	esi, edx
	add	DWORD PTR [eax], esi

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
$LN2@operator@3:

; 1618 : 			this->_Myoff %= _VBITS;
; 1619 : 			}
; 1620 : 		else
; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR [eax+4]
	add	ecx, edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi
$LN6@operator@3:

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1649 : 
; 1650 :  #if _HAS_ITERATOR_DEBUGGING
; 1651 : 		_Compat(_Right);
; 1652 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1653 : 
; 1654 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)
; 1655 : 			+ (difference_type)this->_Myoff
; 1656 : 			- (difference_type)_Right._Myoff);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1657 : 		}

	ret	4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z PROC ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1403 : 		{	// construct with offset and pointer

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1404 : 		}

	ret	8
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ENDP ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T229549 = -12						; size = 12
$T229553 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229553[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229549[esp+16]
	mov	DWORD PTR $T229553[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229549[esp+16]
	push	ecx
	mov	DWORD PTR $T229549[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx]

; 2049 : 		}

	ret	0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==, COMDAT
; _this$ = ecx

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@4
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@4
	mov	eax, 1

; 1673 : 		}

	ret	4
$LN3@operator@4:

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	xor	eax, eax

; 1673 : 		}

	ret	4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
_TEXT	ENDS
PUBLIC	?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc, COMDAT
; _this$ = ecx

; 1734 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1735 : 		_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1736 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN2@Inc

; 1737 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 1740 : 		}

	ret	0
$LN2@Inc:

; 1738 : 		else
; 1739 : 			this->_Myoff = 0, ++this->_Myptr;

	add	DWORD PTR [ecx], 4
	mov	DWORD PTR [ecx+4], 0

; 1740 : 		}

	ret	0
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1466 : 		}

	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr, COMDAT
; _this$ = ecx

; 1500 : 
; 1501 :  #if _HAS_ITERATOR_DEBUGGING
; 1502 : 		if (this->_Mycont == 0 || this->_Myptr == 0)
; 1503 : 			{
; 1504 : 			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 1505 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1506 : 			}
; 1507 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1508 :  		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1509 : 		_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() < ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1510 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1511 : 
; 1512 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [ecx]

; 1513 : 		}

	ret	0
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
_TEXT	ENDS
PUBLIC	?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
; Function compile flags: /Ogtpy
;	COMDAT ?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask, COMDAT
; _this$ = ecx

; 1518 : 		return ((_Vbase)(1 << this->_Myoff));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl

; 1519 : 		}

	ret	0
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z PROC ; std::_Iter_random<unsigned int *,unsigned int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ENDP ; std::_Iter_random<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z PROC ; std::_Ptr_cat<unsigned int *,unsigned int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ENDP ; std::_Ptr_cat<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1791 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1792 : 		}

	ret	4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1475 : 		{	// assign _Val to bit

	mov	eax, ecx

; 1476 : 		if (_Val)
; 1477 : 			*_Getptr() |= _Mask();

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR __Val$[esp], 0
	je	SHORT $LN2@operator@5
	or	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
$LN2@operator@5:

; 1478 : 		else
; 1479 : 			*_Getptr() &= ~_Mask();

	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@5
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAII@std@@YAXPAI0ABI@Z			; std::_Fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::_Fill<unsigned int *,unsigned int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::_Fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec, COMDAT
; _this$ = ecx

; 1719 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@Dec

; 1720 : 			{
; 1721 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 1729 : 			}
; 1730 : 		}

	ret	0
$LN2@Dec:

; 1722 : 			}
; 1723 : 		else
; 1724 : 			{
; 1725 : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1726 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Myptr > this->_My_cont_begin());
; 1727 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 1728 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 1729 : 			}
; 1730 : 		}

	ret	0
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@2:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@3:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@3:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@3
	pop	esi
$LN1@Fill_n@3:

; 3199 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T229828 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T229828[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T229828[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T229828[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T229828[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T229828[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z	; GetPlayerUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z PROC		; GetPlayerUnit, COMDAT

; 407  : 	if((unit.eOwner >= 0) && unit.eOwner < MAX_PLAYERS)

	mov	edx, DWORD PTR _unit$[esp-4]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN1@GetPlayerU
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@GetPlayerU

; 408  : 	{
; 409  : 		return (GET_PLAYER((PlayerTypes)unit.eOwner).m_units.GetAt(unit.iID));

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax

; 413  : }

	ret	0
$LN1@GetPlayerU:

; 410  : 	}
; 411  : 
; 412  : 	return NULL;

	xor	eax, eax

; 413  : }

	ret	0
?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z ENDP		; GetPlayerUnit
_TEXT	ENDS
PUBLIC	?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsDestinationExclusive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z PROC ; CvGameTrade::IsDestinationExclusive, COMDAT
; _this$ = ecx

; 565  : {

	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4]

; 566  : 	TradeConnection* pConnection = NULL;
; 567  : #endif
; 568  : #ifdef AUI_ITERATORIZE
; 569  : 	for (pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 570  : 	{
; 571  : #else
; 572  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edx, edx
	push	edi
	test	esi, esi
	jbe	SHORT $LN4@IsDestinat
	mov	edi, DWORD PTR _kTradeConnection$[esp+8]
	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [edi+12]
	add	eax, 16					; 00000010H
$LL6@IsDestinat:

; 573  : 	{
; 574  : 		pConnection = &(m_aTradeConnections[ui]);
; 575  : #endif
; 576  : 		if (pConnection->m_iDestX == kTradeConnection.m_iDestX && pConnection->m_iDestY == kTradeConnection.m_iDestY)

	cmp	DWORD PTR [eax-4], ebx
	jne	SHORT $LN5@IsDestinat
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edi+16]
	jne	SHORT $LN5@IsDestinat

; 577  : 		{
; 578  : 			// if we're double counting the same route, ignore
; 579  : 			if (pConnection->m_iOriginX == kTradeConnection.m_iOriginX && pConnection->m_iOriginY == kTradeConnection.m_iOriginY)

	mov	ecx, DWORD PTR [eax-12]
	cmp	ecx, DWORD PTR [edi+4]
	jne	SHORT $LN2@IsDestinat
	mov	ecx, DWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [edi+8]
	jne	SHORT $LN2@IsDestinat
$LN5@IsDestinat:

; 566  : 	TradeConnection* pConnection = NULL;
; 567  : #endif
; 568  : #ifdef AUI_ITERATORIZE
; 569  : 	for (pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 570  : 	{
; 571  : #else
; 572  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	inc	edx
	add	eax, 444				; 000001bcH
	cmp	edx, esi
	jb	SHORT $LL6@IsDestinat
$LN4@IsDestinat:
	pop	edi
	pop	esi

; 586  : 			}
; 587  : 		}
; 588  : 	}
; 589  : 
; 590  : 	return true;

	mov	al, 1
	pop	ebx

; 591  : }

	ret	4
$LN2@IsDestinat:
	pop	edi
	pop	esi

; 580  : 			{
; 581  : 				continue;
; 582  : 			}
; 583  : 			else
; 584  : 			{
; 585  : 				return false;

	xor	al, al
	pop	ebx

; 591  : }

	ret	4
?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z ENDP ; CvGameTrade::IsDestinationExclusive
_TEXT	ENDS
PUBLIC	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z	; CvGameTrade::IsTradeRouteIndexEmpty
; Function compile flags: /Ogtpy
;	COMDAT ?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z PROC	; CvGameTrade::IsTradeRouteIndexEmpty, COMDAT
; _this$ = ecx

; 1024 : 	if (m_aTradeConnections[iIndex].m_iOriginX == -1 && m_aTradeConnections[iIndex].m_iOriginY == -1 && m_aTradeConnections[iIndex].m_iDestX == -1 && m_aTradeConnections[iIndex].m_iDestY == -1)

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 444				; 000001bcH
	add	eax, ecx
	or	ecx, -1
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN2@IsTradeRou
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN2@IsTradeRou
	cmp	DWORD PTR [eax+12], ecx
	jne	SHORT $LN2@IsTradeRou
	cmp	DWORD PTR [eax+16], ecx
	jne	SHORT $LN2@IsTradeRou

; 1025 : 	{
; 1026 : 		return true;

	mov	al, 1

; 1031 : 	}
; 1032 : }

	ret	4
$LN2@IsTradeRou:

; 1027 : 	}
; 1028 : 	else
; 1029 : 	{
; 1030 : 		return false;

	xor	al, al

; 1031 : 	}
; 1032 : }

	ret	4
?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ENDP	; CvGameTrade::IsTradeRouteIndexEmpty
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z ; CvGameTrade::GetNumTradeRoutesInPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z PROC ; CvGameTrade::GetNumTradeRoutesInPlot, COMDAT
; _this$ = ecx

; 1400 : 	int iResult = 0;
; 1401 : 	int iX = pPlot->getX();

	mov	edx, DWORD PTR _pPlot$[esp-4]
	push	ebx
	movsx	ebx, WORD PTR [edx]
	push	ebp

; 1402 : 	int iY = pPlot->getY();

	movsx	ebp, WORD PTR [edx+2]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	xor	eax, eax

; 1403 : #ifdef AUI_ITERATORIZE
; 1404 : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 1405 : 	{
; 1406 : 		if (IsTradeRouteIndexEmpty(pConnection))
; 1407 : #else
; 1408 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	test	esi, esi
	jbe	SHORT $LN6@GetNumTrad@2
	mov	edx, DWORD PTR [ecx]
	push	edi
	add	edx, 8
	mov	edi, esi
	npad	1
$LL8@GetNumTrad@2:

; 1409 : 	{
; 1410 : 		if (IsTradeRouteIndexEmpty(ui))

	or	ecx, -1
	cmp	DWORD PTR [edx-4], ecx
	jne	SHORT $LN18@GetNumTrad@2
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN18@GetNumTrad@2
	cmp	DWORD PTR [edx+4], ecx
	jne	SHORT $LN18@GetNumTrad@2
	cmp	DWORD PTR [edx+8], ecx
	je	SHORT $LN7@GetNumTrad@2
$LN18@GetNumTrad@2:
	mov	esi, DWORD PTR [edx+40]

; 1411 : #endif
; 1412 : 		{
; 1413 : 			continue;
; 1414 : 		}
; 1415 : 
; 1416 : #ifdef AUI_ITERATORIZE
; 1417 : 		for (TradeConnectionPlotList::const_iterator it = pConnection->m_aPlotList.begin(); it != pConnection->m_aPlotList.end(); ++it)
; 1418 : 		{
; 1419 : 			if (it->m_iX == iX && it->m_iY == iY)
; 1420 : #else
; 1421 : 		for (uint uiPlot = 0; uiPlot < m_aTradeConnections[ui].m_aPlotList.size(); uiPlot++)

	test	esi, esi
	jbe	SHORT $LN7@GetNumTrad@2
	mov	ecx, DWORD PTR [edx+36]
$LL4@GetNumTrad@2:

; 1422 : 		{
; 1423 : 			if (m_aTradeConnections[ui].m_aPlotList[uiPlot].m_iX == iX && m_aTradeConnections[ui].m_aPlotList[uiPlot].m_iY == iY)

	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN3@GetNumTrad@2
	cmp	DWORD PTR [ecx+4], ebp
	jne	SHORT $LN3@GetNumTrad@2

; 1424 : #endif
; 1425 : 			{
; 1426 : 				iResult++;

	inc	eax
$LN3@GetNumTrad@2:

; 1411 : #endif
; 1412 : 		{
; 1413 : 			continue;
; 1414 : 		}
; 1415 : 
; 1416 : #ifdef AUI_ITERATORIZE
; 1417 : 		for (TradeConnectionPlotList::const_iterator it = pConnection->m_aPlotList.begin(); it != pConnection->m_aPlotList.end(); ++it)
; 1418 : 		{
; 1419 : 			if (it->m_iX == iX && it->m_iY == iY)
; 1420 : #else
; 1421 : 		for (uint uiPlot = 0; uiPlot < m_aTradeConnections[ui].m_aPlotList.size(); uiPlot++)

	add	ecx, 8
	sub	esi, 1
	jne	SHORT $LL4@GetNumTrad@2
$LN7@GetNumTrad@2:

; 1403 : #ifdef AUI_ITERATORIZE
; 1404 : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 1405 : 	{
; 1406 : 		if (IsTradeRouteIndexEmpty(pConnection))
; 1407 : #else
; 1408 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	add	edx, 444				; 000001bcH
	sub	edi, 1
	jne	SHORT $LL8@GetNumTrad@2
	pop	edi
$LN6@GetNumTrad@2:
	pop	esi
	pop	ebp
	pop	ebx

; 1427 : 			}
; 1428 : 		}
; 1429 : 	}
; 1430 : 
; 1431 : 	return iResult;
; 1432 : }

	ret	4
?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z ENDP ; CvGameTrade::GetNumTradeRoutesInPlot
_TEXT	ENDS
PUBLIC	?GetIndexFromID@CvGameTrade@@QAEHH@Z		; CvGameTrade::GetIndexFromID
; Function compile flags: /Ogtpy
;	COMDAT ?GetIndexFromID@CvGameTrade@@QAEHH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetIndexFromID@CvGameTrade@@QAEHH@Z PROC		; CvGameTrade::GetIndexFromID, COMDAT
; _this$ = ecx

; 1441 : {

	mov	edx, DWORD PTR [ecx+4]

; 1442 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	eax, eax
	push	esi
	test	edx, edx
	jbe	SHORT $LN2@GetIndexFr
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _iID$[esp]
$LL4@GetIndexFr:

; 1443 : 	{
; 1444 : 		if (m_aTradeConnections[ui].m_iID == iID)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN5@GetIndexFr
	inc	eax
	add	ecx, 444				; 000001bcH
	cmp	eax, edx
	jb	SHORT $LL4@GetIndexFr
$LN2@GetIndexFr:

; 1445 : 		{
; 1446 : 			return ui;
; 1447 : 		}
; 1448 : 	}
; 1449 : 
; 1450 : 	return -1;

	or	eax, -1
$LN5@GetIndexFr:
	pop	esi

; 1451 : }

	ret	4
?GetIndexFromID@CvGameTrade@@QAEHH@Z ENDP		; CvGameTrade::GetIndexFromID
_TEXT	ENDS
PUBLIC	?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ; CvGameTrade::GetOwnerFromID
; Function compile flags: /Ogtpy
;	COMDAT ?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z PROC ; CvGameTrade::GetOwnerFromID, COMDAT
; _this$ = ecx

; 1460 : {

	push	esi
	mov	esi, DWORD PTR [ecx+4]

; 1461 : 	int iIndex = GetIndexFromID(iID);

	xor	eax, eax
	push	edi
	test	esi, esi
	jbe	SHORT $LN5@GetOwnerFr
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR _iID$[esp+4]
$LL7@GetOwnerFr:
	cmp	DWORD PTR [edx], edi
	je	SHORT $LN8@GetOwnerFr
	inc	eax
	add	edx, 444				; 000001bcH
	cmp	eax, esi
	jb	SHORT $LL7@GetOwnerFr
$LN5@GetOwnerFr:
	or	eax, -1
$LN1@GetOwnerFr:

; 1465 : 	}
; 1466 : 
; 1467 : 	return m_aTradeConnections[iIndex].m_eOriginOwner;

	mov	ecx, DWORD PTR [ecx]
	imul	eax, 444				; 000001bcH
	mov	eax, DWORD PTR [eax+ecx+20]
	pop	edi
	pop	esi

; 1468 : }

	ret	4

; 1461 : 	int iIndex = GetIndexFromID(iID);

$LN8@GetOwnerFr:

; 1462 : 	if (iIndex < -1)

	cmp	eax, -1
	jge	SHORT $LN1@GetOwnerFr
	pop	edi

; 1463 : 	{
; 1464 : 		return NO_PLAYER;

	or	eax, -1
	pop	esi

; 1468 : }

	ret	4
?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ENDP ; CvGameTrade::GetOwnerFromID
_TEXT	ENDS
PUBLIC	?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ; CvGameTrade::GetDestFromID
; Function compile flags: /Ogtpy
;	COMDAT ?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z PROC ; CvGameTrade::GetDestFromID, COMDAT
; _this$ = ecx

; 1477 : {

	push	esi
	mov	esi, DWORD PTR [ecx+4]

; 1478 : 	int iIndex = GetIndexFromID(iID);

	xor	eax, eax
	push	edi
	test	esi, esi
	jbe	SHORT $LN5@GetDestFro
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR _iID$[esp+4]
$LL7@GetDestFro:
	cmp	DWORD PTR [edx], edi
	je	SHORT $LN8@GetDestFro
	inc	eax
	add	edx, 444				; 000001bcH
	cmp	eax, esi
	jb	SHORT $LL7@GetDestFro
$LN5@GetDestFro:
	or	eax, -1
$LN1@GetDestFro:

; 1482 : 	}
; 1483 : 
; 1484 : 	return m_aTradeConnections[iIndex].m_eDestOwner;

	mov	ecx, DWORD PTR [ecx]
	imul	eax, 444				; 000001bcH
	mov	eax, DWORD PTR [eax+ecx+24]
	pop	edi
	pop	esi

; 1485 : }

	ret	4

; 1478 : 	int iIndex = GetIndexFromID(iID);

$LN8@GetDestFro:

; 1479 : 	if (iIndex < -1)

	cmp	eax, -1
	jge	SHORT $LN1@GetDestFro
	pop	edi

; 1480 : 	{
; 1481 : 		return NO_PLAYER;

	or	eax, -1
	pop	esi

; 1485 : }

	ret	4
?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ENDP ; CvGameTrade::GetDestFromID
_TEXT	ENDS
PUBLIC	?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z ; CvGameTrade::GetDomainFromID
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z PROC ; CvGameTrade::GetDomainFromID, COMDAT
; _this$ = ecx

; 1491 : {

	push	esi
	mov	esi, DWORD PTR [ecx+4]

; 1492 : 	int iIndex = GetIndexFromID(iID);

	xor	eax, eax
	push	edi
	test	esi, esi
	jbe	SHORT $LN5@GetDomainF
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR _iID$[esp+4]
$LL7@GetDomainF:
	cmp	DWORD PTR [edx], edi
	je	SHORT $LN8@GetDomainF
	inc	eax
	add	edx, 444				; 000001bcH
	cmp	eax, esi
	jb	SHORT $LL7@GetDomainF
$LN5@GetDomainF:
	or	eax, -1
$LN1@GetDomainF:

; 1496 : 	}
; 1497 : 
; 1498 : 	return m_aTradeConnections[iIndex].m_eDomain;

	mov	ecx, DWORD PTR [ecx]
	imul	eax, 444				; 000001bcH
	mov	eax, DWORD PTR [eax+ecx+28]
	pop	edi
	pop	esi

; 1499 : }

	ret	4

; 1492 : 	int iIndex = GetIndexFromID(iID);

$LN8@GetDomainF:

; 1493 : 	if (iIndex < -1)

	cmp	eax, -1
	jge	SHORT $LN1@GetDomainF
	pop	edi

; 1494 : 	{
; 1495 : 		return NO_DOMAIN;

	or	eax, -1
	pop	esi

; 1499 : }

	ret	4
?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z ENDP ; CvGameTrade::GetDomainFromID
_TEXT	ENDS
PUBLIC	?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z ; CvGameTrade::GetIndexFromUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iUnitID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z PROC ; CvGameTrade::GetIndexFromUnitID, COMDAT
; _this$ = ecx

; 1509 : {

	mov	edx, DWORD PTR [ecx+4]
	push	esi

; 1510 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	eax, eax
	push	edi
	test	edx, edx
	jbe	SHORT $LN2@GetIndexFr@2
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _eOwner$[esp+4]
	mov	edi, DWORD PTR _iUnitID$[esp+4]
	add	ecx, 20					; 00000014H
$LL4@GetIndexFr@2:

; 1511 : 		if (m_aTradeConnections[ui].m_unitID == iUnitID && m_aTradeConnections[ui].m_eOriginOwner == eOwner)

	cmp	DWORD PTR [ecx+360], edi
	jne	SHORT $LN3@GetIndexFr@2
	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN5@GetIndexFr@2
$LN3@GetIndexFr@2:

; 1510 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	inc	eax
	add	ecx, 444				; 000001bcH
	cmp	eax, edx
	jb	SHORT $LL4@GetIndexFr@2
$LN2@GetIndexFr@2:

; 1512 : 			return ui;
; 1513 : 	return -1;

	or	eax, -1
$LN5@GetIndexFr@2:
	pop	edi
	pop	esi

; 1514 : }

	ret	8
?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z ENDP ; CvGameTrade::GetIndexFromUnitID
_TEXT	ENDS
PUBLIC	?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z		; CvGameTrade::IsUnitIDUsed
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
_iUnitID$ = 8						; size = 4
?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z PROC		; CvGameTrade::IsUnitIDUsed, COMDAT
; _this$ = ecx

; 1523 : {

	mov	edx, DWORD PTR [ecx+4]

; 1524 : #ifdef AUI_ITERATORIZE
; 1525 : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 1526 : 	{
; 1527 : 		if (pConnection->m_unitID == iUnitID)
; 1528 : #else
; 1529 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	eax, eax
	push	esi
	test	edx, edx
	jbe	SHORT $LN2@IsUnitIDUs
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _iUnitID$[esp]
	add	ecx, 380				; 0000017cH
$LL4@IsUnitIDUs:

; 1530 : 	{
; 1531 : 		if (m_aTradeConnections[ui].m_unitID == iUnitID)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN12@IsUnitIDUs
	inc	eax
	add	ecx, 444				; 000001bcH
	cmp	eax, edx
	jb	SHORT $LL4@IsUnitIDUs
$LN2@IsUnitIDUs:

; 1535 : 		}
; 1536 : 	}
; 1537 : 
; 1538 : 	return false;

	xor	al, al
	pop	esi

; 1539 : }

	ret	4
$LN12@IsUnitIDUs:

; 1532 : #endif
; 1533 : 		{
; 1534 : 			return true;

	mov	al, 1
	pop	esi

; 1539 : }

	ret	4
?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z ENDP		; CvGameTrade::IsUnitIDUsed
_TEXT	ENDS
PUBLIC	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_ePlayer2$ = 12						; size = 4
?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z PROC ; CvGameTrade::GetTechDifference, COMDAT
; _this$ = ecx

; 1745 : {

	push	ebp
	mov	ebp, ecx

; 1746 : 	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	17					; 00000011H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN5@GetTechDif

; 1747 : 	{
; 1748 : 		return 0;

	xor	eax, eax
	pop	ebp

; 1762 : }

	ret	8
$LN5@GetTechDif:

; 1749 : 	}
; 1750 : 
; 1751 : 	if (GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+8]
	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN3@GetTechDif
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN3@GetTechDif

; 1754 : 	}
; 1755 : 
; 1756 : 	if (GET_PLAYER(ePlayer2).isMinorCiv() || GET_PLAYER(ePlayer2).isBarbarian())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, DWORD PTR _ePlayer2$[esp+12]
	mov	esi, ebx
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN1@GetTechDif
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN1@GetTechDif

; 1759 : 	}
; 1760 : 
; 1761 : 	return m_aaiTechDifference[ePlayer][ePlayer2];

	imul	edi, 22					; 00000016H
	add	edi, ebx
	mov	eax, DWORD PTR [ebp+edi*4+74612]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 1762 : }

	ret	8
$LN1@GetTechDif:
	pop	ebx
	pop	edi
	pop	esi

; 1757 : 	{
; 1758 : 		return 0;

	xor	eax, eax
	pop	ebp

; 1762 : }

	ret	8
$LN3@GetTechDif:
	pop	edi
	pop	esi

; 1752 : 	{
; 1753 : 		return 0;

	xor	eax, eax
	pop	ebp

; 1762 : }

	ret	8
?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ENDP ; CvGameTrade::GetTechDifference
_TEXT	ENDS
PUBLIC	?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z		; CvGameTrade::GetVis
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z PROC		; CvGameTrade::GetVis, COMDAT
; _this$ = ecx

; 1902 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1903 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN2@GetVis
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $LN2@GetVis

; 1907 : 	}
; 1908 : 
; 1909 : #ifdef AUI_WARNING_FIXES
; 1910 : 	const TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];
; 1911 : #else
; 1912 : 	TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];

	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR [ecx]

; 1913 : #endif
; 1914 : 	if (kTradeConnection.m_unitID != -1)

	mov	edx, DWORD PTR [eax+380]
	cmp	edx, -1
	je	SHORT $LN2@GetVis

; 1915 : 	{
; 1916 : #ifdef AUI_WARNING_FIXES
; 1917 : 		return GET_PLAYER(kTradeConnection.m_eOriginOwner).getUnit(kTradeConnection.m_unitID);
; 1918 : #else
; 1919 : 		CvPlayer& kPlayer = GET_PLAYER(kTradeConnection.m_eOriginOwner);

	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1920 : 		return kPlayer.getUnit(kTradeConnection.m_unitID);

	mov	DWORD PTR _iIndex$[esp-4], edx
	jmp	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
$LN2@GetVis:

; 1904 : #endif
; 1905 : 	{
; 1906 : 		return NULL;

	xor	eax, eax

; 1921 : #endif
; 1922 : 	}
; 1923 : 
; 1924 : 	return NULL;
; 1925 : }

	ret	4
?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z ENDP		; CvGameTrade::GetVis
_TEXT	ENDS
PUBLIC	?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z ; CvGameTrade::HideTemporaryPopupTradeRoute
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
; Function compile flags: /Ogtpy
;	COMDAT ?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z
_TEXT	SEGMENT
_iPlotX$ = 8						; size = 4
_iPlotY$ = 12						; size = 4
_type$ = 16						; size = 4
?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z PROC ; CvGameTrade::HideTemporaryPopupTradeRoute, COMDAT
; _this$ = ecx

; 2009 : 	if (iPlotX == m_CurrentTemporaryPopupRoute.iPlotX &&
; 2010 : 		iPlotY == m_CurrentTemporaryPopupRoute.iPlotY &&
; 2011 : 		type == m_CurrentTemporaryPopupRoute.type) 

	mov	eax, DWORD PTR _iPlotX$[esp-4]
	cmp	eax, DWORD PTR [ecx+76548]
	jne	SHORT $LN1@HideTempor
	mov	edx, DWORD PTR _iPlotY$[esp-4]
	cmp	edx, DWORD PTR [ecx+76552]
	jne	SHORT $LN1@HideTempor
	mov	eax, DWORD PTR _type$[esp-4]
	cmp	eax, DWORD PTR [ecx+76556]
	jne	SHORT $LN1@HideTempor

; 2012 : 	{
; 2013 : 		gDLL->TradeVisuals_DeactivatePopupRoute();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+988]
	push	esi
	push	edi
	call	eax

; 2014 : 		gDLL->TradeVisuals_DestroyRoute(TEMPORARY_POPUPROUTE_ID,GC.getGame().getActivePlayer());

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [esi]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	edx, DWORD PTR [edi+980]
	push	eax
	push	-1
	mov	ecx, esi
	call	edx
	pop	edi
	pop	esi
$LN1@HideTempor:

; 2015 : 	}
; 2016 : }

	ret	12					; 0000000cH
?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z ENDP ; CvGameTrade::HideTemporaryPopupTradeRoute
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ	; CvGameTrade::GetLogFileName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T230222 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ PROC	; CvGameTrade::GetLogFileName, COMDAT
; _this$ = ecx

; 2020 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T230222[esp+20], 0

; 2021 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2022 : 	strLogName = "TradeRouteLog.csv";
; 2023 : 	return strLogName;

	push	OFFSET $SG221030
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR $T230222[esp+24], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 2024 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T230222[ebp]
	and	eax, 1
	je	$LN4@GetLogFile
	and	DWORD PTR $T230222[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ ENDP	; CvGameTrade::GetLogFileName
PUBLIC	?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z	; CvGameTrade::LogTradeMsg
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$3
__ehfuncinfo$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
_TEXT	SEGMENT
_strBaseString$221037 = -124				; size = 28
_strOutBuf$221036 = -96					; size = 28
$T230242 = -68						; size = 28
$T230243 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z PROC	; CvGameTrade::LogTradeMsg, COMDAT
; _this$ = ecx

; 2028 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	edi
	mov	edi, ecx

; 2029 : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogTradeMs
	push	esi

; 2030 : 	{
; 2031 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$221036[esp+132]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2032 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$221037[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+140], 1

; 2033 : 		FILogFile* pLog;
; 2034 : 
; 2035 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR $T230242[esp+132]
	push	eax
	mov	ecx, edi
	call	?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ ; CvGameTrade::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T230242[esp+132]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2036 : 
; 2037 : 		// Get the leading info for this line
; 2038 : 		strBaseString.Format("%03d,", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$221037[esp+136]
	push	OFFSET $SG221040
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2039 : 		strOutBuf = strBaseString + strMsg;

	mov	edx, DWORD PTR _strMsg$[esp+140]
	push	edx
	lea	eax, DWORD PTR _strBaseString$221037[esp+148]
	push	eax
	lea	ecx, DWORD PTR $T230243[esp+152]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$221036[esp+136]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T230243[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2040 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$221036[esp+132]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 2041 : 	}

	lea	ecx, DWORD PTR _strBaseString$221037[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$221036[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
$LN1@LogTradeMs:

; 2042 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$221036[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$221037[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$2:
	lea	ecx, DWORD PTR $T230242[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T230243[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z ENDP	; CvGameTrade::LogTradeMsg
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z	; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z
_TEXT	SEGMENT
_uiVersion$ = -16					; size = 4
$T230295 = -12						; size = 4
$T230296 = -8						; size = 4
$T230297 = -4						; size = 4
tv421 = 8						; size = 4
tv223 = 8						; size = 4
$T230294 = 8						; size = 4
_saveTo$ = 8						; size = 4
_ui$221101 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z PROC	; operator<<, COMDAT

; 2160 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2161 : 	uint uiVersion = 3;
; 2162 : 	saveTo << uiVersion;

	mov	edi, DWORD PTR _saveTo$[esp+28]
	lea	eax, DWORD PTR _uiVersion$[esp+32]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+36], 3
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2163 : 
; 2164 : 	saveTo << readFrom.m_aTradeConnections.size();

	mov	esi, DWORD PTR _readFrom$[esp+28]
	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T230294[esp+28]
	mov	DWORD PTR $T230294[esp+28], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2165 : #ifdef AUI_ITERATORIZE
; 2166 : 	for (TradeConnectionList::const_iterator it = readFrom.m_aTradeConnections.begin(); it != readFrom.m_aTradeConnections.end(); ++it)
; 2167 : 	{
; 2168 : 		saveTo << it->m_iID;
; 2169 : 
; 2170 : 		saveTo << it->m_iOriginX;
; 2171 : 		saveTo << it->m_iOriginY;
; 2172 : 		saveTo << it->m_iDestX;
; 2173 : 		saveTo << it->m_iDestY;
; 2174 : 		saveTo << it->m_eOriginOwner;
; 2175 : 		saveTo << it->m_eDestOwner;
; 2176 : 		saveTo << (int)it->m_eDomain;
; 2177 : 		saveTo << (int)it->m_eConnectionType;
; 2178 : 		saveTo << it->m_iTradeUnitLocationIndex;
; 2179 : 		saveTo << it->m_bTradeUnitMovingForward;
; 2180 : 		saveTo << it->m_unitID;
; 2181 : 		saveTo << it->m_iCircuitsCompleted;
; 2182 : 		saveTo << it->m_iCircuitsToComplete;
; 2183 : 		saveTo << it->m_iTurnRouteComplete;
; 2184 : 
; 2185 : 		saveTo << it->m_aPlotList.size();
; 2186 : 		for (TradeConnectionPlotList::const_iterator it2 = it->m_aPlotList.begin(); it2 != it->m_aPlotList.end(); ++it2)
; 2187 : 		{
; 2188 : 			saveTo << it2->m_iX;
; 2189 : 			saveTo << it2->m_iY;
; 2190 : 		}
; 2191 : 
; 2192 : 		for (uint ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 2193 : 		{
; 2194 : 			saveTo << it->m_aiOriginYields[ui];
; 2195 : 			saveTo << it->m_aiDestYields[ui];
; 2196 : #else
; 2197 : 	for (uint ui = 0; ui < readFrom.m_aTradeConnections.size(); ui++)

	xor	ebx, ebx
	mov	DWORD PTR _ui$221101[esp+28], ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	$LN13@operator@6
$LL126@operator@6:

; 2198 : 	{
; 2199 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iID;

	mov	eax, DWORD PTR [esi]
	add	eax, ebx
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2200 : 
; 2201 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iOriginX;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+4]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2202 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iOriginY;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+8]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2203 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iDestX;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+12]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2204 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iDestY;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+16]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2205 : 		saveTo << readFrom.m_aTradeConnections[ui].m_eOriginOwner;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+20]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 2206 : 		saveTo << readFrom.m_aTradeConnections[ui].m_eDestOwner;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+24]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 2207 : 		saveTo << (int)readFrom.m_aTradeConnections[ui].m_eDomain;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+ecx+28]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR $T230295[esp+32]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T230295[esp+36], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2208 : 		saveTo << (int)readFrom.m_aTradeConnections[ui].m_eConnectionType;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+ecx+32]
	lea	eax, DWORD PTR $T230296[esp+32]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T230296[esp+36], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2209 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+36]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2210 : 		saveTo << readFrom.m_aTradeConnections[ui].m_bTradeUnitMovingForward;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+40]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2211 : 		saveTo << readFrom.m_aTradeConnections[ui].m_unitID;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+380]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2212 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iCircuitsCompleted;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+384]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2213 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iCircuitsToComplete;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+388]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2214 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iTurnRouteComplete;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+392]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2215 : 
; 2216 : 		saveTo << readFrom.m_aTradeConnections[ui].m_aPlotList.size();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+ecx+48]
	lea	eax, DWORD PTR $T230297[esp+32]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T230297[esp+36], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2217 : 		for (uint ui2 = 0; ui2 < readFrom.m_aTradeConnections[ui].m_aPlotList.size(); ui2++)

	mov	ecx, DWORD PTR [esi]
	xor	ebp, ebp
	cmp	DWORD PTR [ebx+ecx+48], ebp
	lea	eax, DWORD PTR [ebx+ecx]
	jbe	SHORT $LN10@operator@6
	npad	11
$LL12@operator@6:
	mov	edx, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR [ebp*8]
	add	edx, ecx

; 2218 : 		{
; 2219 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aPlotList[ui2].m_iX;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2220 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aPlotList[ui2].m_iY;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx+eax+44]
	lea	edx, DWORD PTR [ecx+ebp*8+4]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi]
	inc	ebp
	add	eax, ebx
	cmp	ebp, DWORD PTR [eax+48]
	jb	SHORT $LL12@operator@6
$LN10@operator@6:

; 2221 : 		}
; 2222 : 
; 2223 : 		for (uint ui2 = 0; ui2 < NUM_YIELD_TYPES; ui2++)

	lea	ebp, DWORD PTR [ebx+420]
	mov	DWORD PTR tv223[esp+28], 6
	npad	2
$LL9@operator@6:

; 2224 : 		{
; 2225 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aiOriginYields[ui2];

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ecx+ebp-24]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi]
	add	eax, ebp

; 2226 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aiDestYields[ui2];

	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebp, 4
	sub	DWORD PTR tv223[esp+28], 1
	jne	SHORT $LL9@operator@6
	mov	eax, DWORD PTR _ui$221101[esp+28]
	inc	eax
	add	ebx, 444				; 000001bcH
	mov	DWORD PTR _ui$221101[esp+28], eax
	cmp	eax, DWORD PTR [esi+4]
	jb	$LL126@operator@6
$LN13@operator@6:

; 2227 : #endif
; 2228 : 		}
; 2229 : 	}
; 2230 : 
; 2231 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	lea	ebx, DWORD PTR [esi+74612]
	mov	DWORD PTR tv421[esp+28], 22		; 00000016H
	npad	6
$LL127@operator@6:

; 2232 : 	{
; 2233 : 		for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)

	mov	ebp, 22					; 00000016H
$LL3@operator@6:

; 2234 : 		{
; 2235 : 			saveTo << readFrom.m_aaiTechDifference[ui][ui2];

	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL3@operator@6

; 2227 : #endif
; 2228 : 		}
; 2229 : 	}
; 2230 : 
; 2231 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	sub	DWORD PTR tv421[esp+28], 1
	jne	SHORT $LL127@operator@6

; 2236 : 		}
; 2237 : 	}
; 2238 : 
; 2239 : 	saveTo << readFrom.m_iNextID;

	add	esi, 74608				; 00012370H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2240 : 
; 2241 : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2242 : }

	add	esp, 16					; 00000010H
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100, COMDAT
; _this$ = ecx

; 2669 : 	// unnecessary code to make it compile for now
; 2670 : 	if (eYield != NO_YIELD)
; 2671 : 	{
; 2672 : 		eYield = eYield;
; 2673 : 	}
; 2674 : 
; 2675 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 2676 : 	if (pTrade->IsDestinationExclusive(kTradeConnection))

	mov	ecx, DWORD PTR _kTradeConnection$[esp-4]
	push	ecx
	mov	ecx, eax
	call	?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsDestinationExclusive
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7960

; 2677 : 	{
; 2678 : 		return GC.getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION();
; 2679 : 	}
; 2680 : 	else
; 2681 : 	{
; 2682 : 		return 0;
; 2683 : 	}
; 2684 : }

	ret	8
?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_bBothOrder$221328 = -14				; size = 1
_bBothFreedom$221329 = -13				; size = 1
_iValue$ = -12						; size = 4
_pDestPlayerPolicies$221320 = -8			; size = 4
_eFreedom$221321 = -4					; size = 4
_bBothAutocracy$221327 = 8				; size = 1
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100, COMDAT
; _this$ = ecx

; 2692 : {

	sub	esp, 16					; 00000010H
	push	edi

; 2693 : 	// unnecessary code to make it compile for now
; 2694 : 	if (eYield != NO_YIELD)
; 2695 : 	{
; 2696 : 		eYield = eYield;
; 2697 : 	}
; 2698 : 
; 2699 : 	int iValue = 0;
; 2700 : 	if (kTradeConnection.m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	edi, DWORD PTR _kTradeConnection$[esp+16]
	xor	eax, eax
	mov	DWORD PTR _iValue$[esp+20], eax
	cmp	DWORD PTR [edi+32], eax
	jne	$LN1@GetTradeCo

; 2701 : 	{
; 2702 : 		// domain type bonuses
; 2703 : 		if (kTradeConnection.m_eDomain == DOMAIN_LAND 
; 2704 : 			&& eYield == YIELD_GOLD) // NQMP GJS - Merchant Confederacy

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, 2
	cmp	eax, ecx
	jne	SHORT $LN42@GetTradeCo
	cmp	DWORD PTR _eYield$[esp+16], ecx
	jne	SHORT $LN42@GetTradeCo

; 2705 : 		{
; 2706 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_LAND_TRADE_GOLD_CHANGE);

	push	32					; 00000020H

; 2707 : 		}
; 2708 : 		else if (kTradeConnection.m_eDomain == DOMAIN_SEA

	jmp	SHORT $LN45@GetTradeCo
$LN42@GetTradeCo:

; 2709 : 			&& eYield == YIELD_GOLD) // NQMP GJS - Merchant Confederacy

	test	eax, eax
	jne	SHORT $LN7@GetTradeCo
	cmp	DWORD PTR _eYield$[esp+16], ecx
	jne	SHORT $LN7@GetTradeCo

; 2710 : 		{
; 2711 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_SEA_TRADE_GOLD_CHANGE);

	push	33					; 00000021H
$LN45@GetTradeCo:
	mov	ecx, DWORD PTR [edi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	DWORD PTR _iValue$[esp+20], eax
$LN7@GetTradeCo:

; 2712 : 		}
; 2713 : 
; 2714 : 		// policy tree bonuses
; 2715 : 		CvPlayerPolicies* pOwnerPlayerPolicies = GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies();

	mov	ecx, DWORD PTR [edi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies

; 2716 : 		CvPlayerPolicies* pDestPlayerPolicies = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies();

	mov	ecx, DWORD PTR [edi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies

; 2717 : 
; 2718 : 		PolicyBranchTypes eFreedom = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();
; 2719 : 		PolicyBranchTypes eAutocracy = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380

; 2720 : 		PolicyBranchTypes eOrder = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR _pDestPlayerPolicies$221320[esp+32], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	mov	DWORD PTR _eFreedom$221321[esp+32], eax

; 2721 : 
; 2722 : 		bool bBothAutocracy = false;

	mov	BYTE PTR _bBothAutocracy$221327[esp+28], 0

; 2723 : 		bool bBothOrder = false;

	mov	BYTE PTR _bBothOrder$221328[esp+32], 0

; 2724 : 		bool bBothFreedom = false;

	mov	BYTE PTR _bBothFreedom$221329[esp+32], 0

; 2725 : 		if (eAutocracy != NO_POLICY_BRANCH_TYPE)

	cmp	esi, -1
	je	SHORT $LN15@GetTradeCo

; 2726 : 		{
; 2727 : 			bBothAutocracy = pOwnerPlayerPolicies->IsPolicyBranchUnlocked(eAutocracy) && pDestPlayerPolicies->IsPolicyBranchUnlocked(eAutocracy);

	push	esi
	mov	ecx, ebx
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	je	SHORT $LN14@GetTradeCo
	mov	ecx, DWORD PTR _pDestPlayerPolicies$221320[esp+32]
	push	esi
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	mov	BYTE PTR _bBothAutocracy$221327[esp+28], 1
	test	al, al
	jne	SHORT $LN15@GetTradeCo
$LN14@GetTradeCo:
	mov	BYTE PTR _bBothAutocracy$221327[esp+28], 0
$LN15@GetTradeCo:

; 2728 : 		}
; 2729 : 		if (eOrder != NO_POLICY_BRANCH_TYPE)

	cmp	ebp, -1
	je	SHORT $LN17@GetTradeCo

; 2730 : 		{
; 2731 : 			bBothOrder = pOwnerPlayerPolicies->IsPolicyBranchUnlocked(eOrder) && pDestPlayerPolicies->IsPolicyBranchUnlocked(eOrder);

	push	ebp
	mov	ecx, ebx
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	je	SHORT $LN16@GetTradeCo
	mov	ecx, DWORD PTR _pDestPlayerPolicies$221320[esp+32]
	push	ebp
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	mov	BYTE PTR _bBothOrder$221328[esp+32], 1
	test	al, al
	jne	SHORT $LN17@GetTradeCo
$LN16@GetTradeCo:
	mov	BYTE PTR _bBothOrder$221328[esp+32], 0
$LN17@GetTradeCo:

; 2732 : 		}
; 2733 : 		if (eFreedom != NO_POLICY_BRANCH_TYPE)

	mov	eax, DWORD PTR _eFreedom$221321[esp+32]
	cmp	eax, -1
	je	SHORT $LN19@GetTradeCo

; 2734 : 		{
; 2735 : 			bBothFreedom = pOwnerPlayerPolicies->IsPolicyBranchUnlocked(eFreedom) && pDestPlayerPolicies->IsPolicyBranchUnlocked(eFreedom);

	push	eax
	mov	ecx, ebx
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	je	SHORT $LN18@GetTradeCo
	mov	ecx, DWORD PTR _eFreedom$221321[esp+32]
	push	ecx
	mov	ecx, DWORD PTR _pDestPlayerPolicies$221320[esp+36]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	mov	BYTE PTR _bBothFreedom$221329[esp+32], 1
	test	al, al
	jne	SHORT $LN19@GetTradeCo
$LN18@GetTradeCo:
	mov	BYTE PTR _bBothFreedom$221329[esp+32], 0
$LN19@GetTradeCo:

; 2736 : 		}
; 2737 : 	
; 2738 : 		if ((bBothAutocracy || bBothOrder || bBothFreedom)
; 2739 : 			&& eYield == YIELD_GOLD) // NQMP GJS - Merchant Confederacy

	cmp	BYTE PTR _bBothAutocracy$221327[esp+28], 0
	jne	SHORT $LN2@GetTradeCo
	cmp	BYTE PTR _bBothOrder$221328[esp+32], 0
	jne	SHORT $LN2@GetTradeCo
	cmp	BYTE PTR _bBothFreedom$221329[esp+32], 0
	je	SHORT $LN43@GetTradeCo
$LN2@GetTradeCo:
	cmp	DWORD PTR _eYield$[esp+28], 2
	jne	SHORT $LN43@GetTradeCo

; 2740 : 		{
; 2741 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_SHARED_IDEOLOGY_TRADE_CHANGE) * 100;

	mov	ecx, DWORD PTR [edi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	34					; 00000022H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	imul	eax, 100				; 00000064H
	mov	esi, DWORD PTR _iValue$[esp+32]
	add	esi, eax
	jmp	SHORT $LN3@GetTradeCo
$LN43@GetTradeCo:
	mov	esi, DWORD PTR _iValue$[esp+32]
$LN3@GetTradeCo:

; 2742 : 		}
; 2743 : 
; 2744 : 		// city state bonus
; 2745 : 		if (GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv())

	mov	ecx, DWORD PTR [edi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN40@GetTradeCo

; 2746 : 		{
; 2747 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_TRADE_CHANGE);

	mov	ecx, DWORD PTR [edi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	42					; 0000002aH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	esi, eax
$LN40@GetTradeCo:

; 2748 : 		}
; 2749 : 	}
; 2750 : 
; 2751 : 	return iValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
$LN1@GetTradeCo:
	pop	edi

; 2752 : }

	add	esp, 16					; 00000010H
	ret	8
?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100, COMDAT
; _this$ = ecx

; 2761 : 	int iValue = 0;
; 2762 : 	if (kTradeConnection.m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	ecx, DWORD PTR _kTradeConnection$[esp-4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+32], eax
	jne	SHORT $LN1@GetTradeCo@2

; 2763 : 	{
; 2764 : 		if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp-4], al
	je	SHORT $LN1@GetTradeCo@2

; 2765 : 		{
; 2766 : 			iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerTraits()->GetYieldChangeIncomingTradeRoute(eYield) * 100;

	mov	ecx, DWORD PTR [ecx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4+528]
	imul	eax, 100				; 00000064H
$LN1@GetTradeCo@2:

; 2767 : 		}
; 2768 : 	}
; 2769 : 
; 2770 : 	return iValue;
; 2771 : }

	ret	12					; 0000000cH
?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100, COMDAT
; _this$ = ecx

; 2780 : 	// unnecessary code to make it compile for now
; 2781 : 	if (eYield != NO_YIELD)
; 2782 : 	{
; 2783 : 		eYield = eYield;
; 2784 : 	}
; 2785 : 
; 2786 : 	return GC.getGame().GetGameTrade()->GetDomainModifierTimes100(kTradeConnection.m_eDomain);

	mov	eax, DWORD PTR _kTradeConnection$[esp-4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR [eax+28]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	neg	esi
	sbb	esi, esi
	and	esi, -100				; ffffff9cH
	add	esi, 100				; 00000064H
	mov	eax, esi
	pop	esi

; 2787 : }

	ret	8
?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
_TEXT	ENDS
PUBLIC	?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z ; CvPlayerTrade::GetNumForeignTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z PROC ; CvPlayerTrade::GetNumForeignTradeRoutes, COMDAT
; _this$ = ecx

; 4296 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx+4]

; 4297 : 	int iResult = 0;

	xor	eax, eax

; 4298 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN3@GetNumFore
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	mov	ebx, DWORD PTR _ePlayer$[esp]
	push	esi
	push	edi
	add	ecx, 8
	mov	esi, edx
	or	edi, -1
$LL5@GetNumFore:

; 4299 : 	{
; 4300 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	cmp	DWORD PTR [ecx-4], edi
	jne	SHORT $LN13@GetNumFore
	cmp	DWORD PTR [ecx], edi
	jne	SHORT $LN13@GetNumFore
	cmp	DWORD PTR [ecx+4], edi
	jne	SHORT $LN13@GetNumFore
	cmp	DWORD PTR [ecx+8], edi
	je	SHORT $LN4@GetNumFore
$LN13@GetNumFore:

; 4301 : 		{
; 4302 : 			continue;
; 4303 : 		}
; 4304 : 		TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);
; 4305 : 		if (pTradeConnection->m_eOriginOwner == ePlayer && pTradeConnection->m_eOriginOwner != pTradeConnection->m_eDestOwner)

	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, ebx
	jne	SHORT $LN4@GetNumFore
	cmp	edx, DWORD PTR [ecx+16]
	je	SHORT $LN4@GetNumFore

; 4306 : 		{
; 4307 : 			iResult++;

	inc	eax
$LN4@GetNumFore:

; 4298 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	add	ecx, 444				; 000001bcH
	sub	esi, 1
	jne	SHORT $LL5@GetNumFore
	pop	edi
	pop	esi
	pop	ebx
$LN3@GetNumFore:

; 4308 : 		}
; 4309 : 	}
; 4310 : 	return iResult;
; 4311 : }

	ret	4
?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z ENDP ; CvPlayerTrade::GetNumForeignTradeRoutes
_TEXT	ENDS
PUBLIC	?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionWasPlundered
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ PROC ; CvPlayerTrade::UpdateTradeConnectionWasPlundered, COMDAT
; _this$ = ecx

; 4381 : {

	push	ebp
	push	edi
	mov	edi, ecx

; 4382 : 	int iTurnsUntilForget = 30;
; 4383 : #ifdef AUI_ITERATORIZE
; 4384 : 	for (TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4385 : 	{
; 4386 : 		if ((it->m_iTurnPlundered + iTurnsUntilForget) <= GC.getGame().getGameTurn())
; 4387 : 		{
; 4388 : 			// erasing entry to make sure vector doesn't get bigger than it should
; 4389 : 			m_aTradeConnectionWasPlundered.erase(it);
; 4390 : 			--it;
; 4391 : #else
; 4392 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+74612], ebp
	jbe	SHORT $LN2@UpdateTrad
	push	ebx
	push	esi
	xor	ebx, ebx
$LL4@UpdateTrad:

; 4393 : 	{
; 4394 : 		if ((m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered + iTurnsUntilForget) <= GC.getGame().getGameTurn())

	mov	esi, DWORD PTR [edi+74608]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esi, ebx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+444]
	add	ecx, 30					; 0000001eH
	cmp	ecx, eax
	jg	SHORT $LN3@UpdateTrad

; 4395 : 		{
; 4396 : 			// setting turn plundered to -1 to flag it as not counting
; 4397 : 			m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered = -1;

	mov	edx, DWORD PTR [edi+74608]
	mov	DWORD PTR [ebx+edx+444], -1
$LN3@UpdateTrad:
	inc	ebp
	add	ebx, 448				; 000001c0H
	cmp	ebp, DWORD PTR [edi+74612]
	jb	SHORT $LL4@UpdateTrad
	pop	esi
	pop	ebx
$LN2@UpdateTrad:
	pop	edi
	pop	ebp

; 4398 : #endif
; 4399 : 		}
; 4400 : 	}
; 4401 : }

	ret	0
?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ ENDP ; CvPlayerTrade::UpdateTradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
; Function compile flags: /Ogtpy
;	COMDAT ?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z PROC ; CvPlayerTrade::CheckTradeConnectionWasPlundered, COMDAT
; _this$ = ecx

; 4458 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+74612]

; 4459 : #ifdef AUI_ITERATORIZE
; 4460 : 	for (TradeConnectionWasPlunderedList::const_iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4461 : 	{
; 4462 : 		if (it->m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4463 : 			it->m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4464 : 			it->m_kTradeConnection.m_iDestX == kTradeConnection.m_iDestX &&
; 4465 : 			it->m_kTradeConnection.m_iDestY == kTradeConnection.m_iDestY &&
; 4466 : 			it->m_iTurnPlundered != -1)
; 4467 : #else
; 4468 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	xor	edx, edx
	test	edi, edi
	jbe	SHORT $LN2@CheckTrade
	mov	eax, DWORD PTR [ecx+74608]
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
	mov	ebx, DWORD PTR [esi+4]
	add	eax, 8
	or	ecx, -1
$LL4@CheckTrade:

; 4469 : 	{
; 4470 : 		if (m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4471 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4472 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestX   == kTradeConnection.m_iDestX &&
; 4473 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestY   == kTradeConnection.m_iDestY &&
; 4474 : 			m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered != -1)

	cmp	DWORD PTR [eax-4], ebx
	jne	SHORT $LN3@CheckTrade
	mov	ebp, DWORD PTR [eax]
	cmp	ebp, DWORD PTR [esi+8]
	jne	SHORT $LN3@CheckTrade
	mov	ebp, DWORD PTR [eax+4]
	cmp	ebp, DWORD PTR [esi+12]
	jne	SHORT $LN3@CheckTrade
	mov	ebp, DWORD PTR [eax+8]
	cmp	ebp, DWORD PTR [esi+16]
	jne	SHORT $LN3@CheckTrade
	cmp	DWORD PTR [eax+436], ecx
	jne	SHORT $LN20@CheckTrade
$LN3@CheckTrade:

; 4459 : #ifdef AUI_ITERATORIZE
; 4460 : 	for (TradeConnectionWasPlunderedList::const_iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4461 : 	{
; 4462 : 		if (it->m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4463 : 			it->m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4464 : 			it->m_kTradeConnection.m_iDestX == kTradeConnection.m_iDestX &&
; 4465 : 			it->m_kTradeConnection.m_iDestY == kTradeConnection.m_iDestY &&
; 4466 : 			it->m_iTurnPlundered != -1)
; 4467 : #else
; 4468 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	inc	edx
	add	eax, 448				; 000001c0H
	cmp	edx, edi
	jb	SHORT $LL4@CheckTrade
$LN2@CheckTrade:
	pop	edi
	pop	esi
	pop	ebp

; 4478 : 		}
; 4479 : 	}
; 4480 : 
; 4481 : 	return false;

	xor	al, al
	pop	ebx

; 4482 : }

	ret	4
$LN20@CheckTrade:
	pop	edi
	pop	esi
	pop	ebp

; 4475 : #endif
; 4476 : 		{
; 4477 : 			return true;

	mov	al, 1
	pop	ebx

; 4482 : }

	ret	4
?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ENDP ; CvPlayerTrade::CheckTradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T230666 = 8						; size = 4
$T230665 = 8						; size = 4
$T230663 = 8						; size = 4
$T230662 = 8						; size = 4
_saveTo$ = 8						; size = 4
$T230667 = 12						; size = 4
$T230664 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z PROC	; operator<<, COMDAT

; 4826 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4828 : 	saveTo << uiVersion;

	mov	edi, DWORD PTR _saveTo$[esp+16]
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+24], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4829 : 
; 4830 : 	saveTo << readFrom.m_aRecentlyExpiredConnections.size();

	mov	esi, DWORD PTR _readFrom$[esp+16]
	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T230662[esp+16]
	mov	DWORD PTR $T230662[esp+16], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4831 : #ifdef AUI_ITERATORIZE
; 4832 : 	for (TradeConnectionList::const_iterator it = readFrom.m_aRecentlyExpiredConnections.begin(); it != readFrom.m_aRecentlyExpiredConnections.end(); ++it)
; 4833 : 	{
; 4834 : 		saveTo << it->m_iID;
; 4835 : 
; 4836 : 		saveTo << it->m_iOriginX;
; 4837 : 		saveTo << it->m_iOriginY;
; 4838 : 		saveTo << it->m_iDestX;
; 4839 : 		saveTo << it->m_iDestY;
; 4840 : 		saveTo << it->m_eOriginOwner;
; 4841 : 		saveTo << it->m_eDestOwner;
; 4842 : 		saveTo << (int)it->m_eDomain;
; 4843 : 		saveTo << (int)it->m_eConnectionType;
; 4844 : 		saveTo << it->m_iTradeUnitLocationIndex;
; 4845 : 		saveTo << it->m_bTradeUnitMovingForward;
; 4846 : 		saveTo << it->m_unitID;
; 4847 : 		saveTo << it->m_iCircuitsCompleted;
; 4848 : 		saveTo << it->m_iCircuitsToComplete;
; 4849 : 		saveTo << it->m_iTurnRouteComplete;
; 4850 : #else
; 4851 : 	for (uint ui = 0; ui < readFrom.m_aRecentlyExpiredConnections.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+4], ebp
	jbe	$LN4@operator@7

; 4827 : 	uint uiVersion = 2;

	xor	ebx, ebx
$LL6@operator@7:

; 4852 : 	{
; 4853 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iID;

	mov	eax, DWORD PTR [esi]
	add	eax, ebx
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4854 : 
; 4855 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iOriginX;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+4]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4856 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iOriginY;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+8]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4857 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iDestX;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+12]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4858 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iDestY;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+16]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4859 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_eOriginOwner;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+20]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 4860 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_eDestOwner;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+24]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 4861 : 		saveTo << (int)readFrom.m_aRecentlyExpiredConnections[ui].m_eDomain;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+ecx+28]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR $T230663[esp+16]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T230663[esp+20], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4862 : 		saveTo << (int)readFrom.m_aRecentlyExpiredConnections[ui].m_eConnectionType;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+ecx+32]
	lea	eax, DWORD PTR $T230664[esp+16]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T230664[esp+20], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4863 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+36]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4864 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_bTradeUnitMovingForward;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+40]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 4865 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_unitID;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+380]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4866 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iCircuitsCompleted;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+ecx+384]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4867 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iCircuitsToComplete;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+eax+388]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4868 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iTurnRouteComplete;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+edx+392]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebp
	add	ebx, 444				; 000001bcH
	cmp	ebp, DWORD PTR [esi+4]
	jb	$LL6@operator@7
$LN4@operator@7:

; 4869 : #endif
; 4870 : 	}
; 4871 : 
; 4872 : 	saveTo << readFrom.m_aTradeConnectionWasPlundered.size();

	mov	ecx, DWORD PTR [esi+74612]
	lea	edx, DWORD PTR $T230665[esp+16]
	mov	DWORD PTR $T230665[esp+16], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4873 : #ifdef AUI_ITERATORIZE
; 4874 : 	for (TradeConnectionWasPlunderedList::const_iterator it = readFrom.m_aTradeConnectionWasPlundered.begin(); it != readFrom.m_aTradeConnectionWasPlundered.end(); ++it)
; 4875 : 	{
; 4876 : 		saveTo << it->m_iTurnPlundered;
; 4877 : 
; 4878 : 		saveTo << it->m_kTradeConnection.m_iOriginX;
; 4879 : 		saveTo << it->m_kTradeConnection.m_iOriginY;
; 4880 : 		saveTo << it->m_kTradeConnection.m_iDestX;
; 4881 : 		saveTo << it->m_kTradeConnection.m_iDestY;
; 4882 : 		saveTo << it->m_kTradeConnection.m_eOriginOwner;
; 4883 : 		saveTo << it->m_kTradeConnection.m_eDestOwner;
; 4884 : 		saveTo << (int)it->m_kTradeConnection.m_eDomain;
; 4885 : 		saveTo << (int)it->m_kTradeConnection.m_eConnectionType;
; 4886 : 		saveTo << it->m_kTradeConnection.m_iTradeUnitLocationIndex;
; 4887 : 		saveTo << it->m_kTradeConnection.m_bTradeUnitMovingForward;
; 4888 : 		saveTo << it->m_kTradeConnection.m_unitID;
; 4889 : 		saveTo << it->m_kTradeConnection.m_iCircuitsCompleted;
; 4890 : 		saveTo << it->m_kTradeConnection.m_iCircuitsToComplete;
; 4891 : 		saveTo << it->m_kTradeConnection.m_iTurnRouteComplete;
; 4892 : #else
; 4893 : 	for (uint ui = 0; ui < readFrom.m_aTradeConnectionWasPlundered.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+74612], ebp
	jbe	$LN139@operator@7

; 4869 : #endif
; 4870 : 	}
; 4871 : 
; 4872 : 	saveTo << readFrom.m_aTradeConnectionWasPlundered.size();

	xor	ebx, ebx
	npad	12
$LL3@operator@7:

; 4894 : 	{
; 4895 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered;

	mov	eax, DWORD PTR [esi+74608]
	lea	ecx, DWORD PTR [ebx+eax+444]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4896 : 
; 4897 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginX;

	mov	edx, DWORD PTR [esi+74608]
	lea	eax, DWORD PTR [ebx+edx+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4898 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginY;

	mov	ecx, DWORD PTR [esi+74608]
	lea	edx, DWORD PTR [ebx+ecx+8]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4899 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestX;

	mov	eax, DWORD PTR [esi+74608]
	lea	ecx, DWORD PTR [ebx+eax+12]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4900 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestY;

	mov	edx, DWORD PTR [esi+74608]
	lea	eax, DWORD PTR [ebx+edx+16]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4901 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eOriginOwner;

	mov	ecx, DWORD PTR [esi+74608]
	lea	edx, DWORD PTR [ebx+ecx+20]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 4902 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eDestOwner;

	mov	eax, DWORD PTR [esi+74608]
	lea	ecx, DWORD PTR [ebx+eax+24]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 4903 : 		saveTo << (int)readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eDomain;

	mov	edx, DWORD PTR [esi+74608]
	mov	eax, DWORD PTR [ebx+edx+28]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T230666[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T230666[esp+20], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4904 : 		saveTo << (int)readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eConnectionType;

	mov	edx, DWORD PTR [esi+74608]
	mov	eax, DWORD PTR [ebx+edx+32]
	lea	ecx, DWORD PTR $T230667[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T230667[esp+20], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4905 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iTradeUnitLocationIndex;

	mov	edx, DWORD PTR [esi+74608]
	lea	eax, DWORD PTR [ebx+edx+36]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4906 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_bTradeUnitMovingForward;

	mov	ecx, DWORD PTR [esi+74608]
	lea	edx, DWORD PTR [ebx+ecx+40]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 4907 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_unitID;

	mov	eax, DWORD PTR [esi+74608]
	lea	ecx, DWORD PTR [ebx+eax+380]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4908 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iCircuitsCompleted;

	mov	edx, DWORD PTR [esi+74608]
	lea	eax, DWORD PTR [ebx+edx+384]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4909 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iCircuitsToComplete;

	mov	ecx, DWORD PTR [esi+74608]
	lea	edx, DWORD PTR [ebx+ecx+388]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4910 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iTurnRouteComplete;

	mov	eax, DWORD PTR [esi+74608]
	lea	ecx, DWORD PTR [ebx+eax+392]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebp
	add	ebx, 448				; 000001c0H
	cmp	ebp, DWORD PTR [esi+74612]
	jb	$LL3@operator@7
$LN139@operator@7:

; 4911 : #endif
; 4912 : 	}
; 4913 : 
; 4914 : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4915 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z		; CvTradeAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z PROC		; CvTradeAI::Init, COMDAT
; _this$ = ecx

; 4938 : 	Reset();
; 4939 : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 4940 : 	m_iRemovableValue = 0;

	mov	DWORD PTR [ecx], 0

; 4941 : }

	ret	4
?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvTradeAI::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvTradeAI@@QAEXXZ			; CvTradeAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvTradeAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvTradeAI@@QAEXXZ PROC				; CvTradeAI::Uninit, COMDAT
; _this$ = ecx

; 4946 : 	Reset();

	mov	DWORD PTR [ecx+4], 0

; 4947 : }

	ret	0
?Uninit@CvTradeAI@@QAEXXZ ENDP				; CvTradeAI::Uninit
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z PROC	; operator>>, COMDAT

; 5643 : {

	push	esi

; 5644 : 	uint uiVersion;
; 5645 : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5646 : 
; 5647 : 	loadFrom >> writeTo.m_iRemovableValue;

	mov	ecx, DWORD PTR _writeTo$[esp]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5648 : 
; 5649 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 5650 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z PROC	; operator<<, COMDAT

; 5654 : {

	push	ecx
	push	esi

; 5655 : 	uint uiVersion = 0;
; 5656 : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	lea	eax, DWORD PTR _uiVersion$[esp+8]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+12], 0
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5657 : 
; 5658 : 	saveTo << readFrom.m_iRemovableValue;

	mov	ecx, DWORD PTR _readFrom$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5659 : 
; 5660 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 5661 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 591  : 	FStaticVector(const THIS_TYPE& RHS)

	push	ebx

; 592  : 	{
; 593  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebx, DWORD PTR _RHS$[esp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax

; 594  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR [esi+8], ecx

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebx+8]
	cmp	edi, 40					; 00000028H
	jbe	SHORT $LN6@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	edx, DWORD PTR [edi*8]
	push	4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

$LN6@FStaticVec:
	lea	eax, DWORD PTR [esi+12]

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 40			; 00000028H
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 40			; 00000028H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEXXZ ; BaseVector<TradeConnectionPlot,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEXXZ PROC ; BaseVector<TradeConnectionPlot,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UTradeConnectionPlot@@$0A@@@QAEXXZ ENDP ; BaseVector<TradeConnectionPlot,0>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 168			; 000000a8H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 10			; 0000000aH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::~_Vector_val<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::~_Vector_val<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::~_Vector_val<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::_Vector_val<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z PROC ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::_Vector_val<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE@V?$allocator@UTRSortElement@@@1@@Z ENDP ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::_Vector_val<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@PAUTRSortElement@@@Z ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ; std::allocator<CvString>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z PROC ; std::allocator<CvString>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ENDP ; std::allocator<CvString>::allocate
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 9586980				; 00924924H

; 732  : 		}

	ret	0
?max_size@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEIXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTRSortElement@@@std@@QAEPAUTRSortElement@@I@Z ; std::allocator<TRSortElement>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UTRSortElement@@@std@@QAEPAUTRSortElement@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UTRSortElement@@@std@@QAEPAUTRSortElement@@I@Z PROC ; std::allocator<TRSortElement>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UTRSortElement@@@std@@QAEPAUTRSortElement@@I@Z ENDP ; std::allocator<TRSortElement>::allocate
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<TRSortElement,std::allocator<TRSortElement> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	imul	ecx, 448				; 000001c0H
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z ; GetLocalizedText<int,char const [21]>
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$0
__ehfuncinfo$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T231238 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z PROC ; GetLocalizedText<int,char const [21]>, COMDAT

; 539  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 540  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T231238[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 541  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	ecx, DWORD PTR _arg2$[esp+108]
	push	20					; 00000014H
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 542  : 
; 543  : 	size_t bytes = 0;
; 544  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 545  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 546  : 	str.assign(szComposedString, bytes);
; 547  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T231238[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 548  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$1:
	mov	eax, DWORD PTR $T231238[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T231238[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z ENDP ; GetLocalizedText<int,char const [21]>
PUBLIC	??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z ; GetLocalizedText<int,char const [24]>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$0
__ehfuncinfo$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T231261 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z PROC ; GetLocalizedText<int,char const [24]>, COMDAT

; 539  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 540  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T231261[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 541  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	ecx, DWORD PTR _arg2$[esp+108]
	push	23					; 00000017H
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 542  : 
; 543  : 	size_t bytes = 0;
; 544  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 545  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 546  : 	str.assign(szComposedString, bytes);
; 547  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T231261[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 548  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$1:
	mov	eax, DWORD PTR $T231261[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T231261[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z ENDP ; GetLocalizedText<int,char const [24]>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::fill<CvCity * *,CvCity *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::_Fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::_Fill<CvString *,CvString>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill@4
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Fill@4
	pop	ebx
$LN1@Fill@4:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::_Fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN9@Copy_backw@4
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@4

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN9@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ; std::_Construct<CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
_TEXT	SEGMENT
$T231342 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z PROC ; std::_Construct<CvString,CvString>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T231342[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@3
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN3@Construct@3:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T231342[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ENDP ; std::_Construct<CvString,CvString>
PUBLIC	??_GCvString@@QAEPAXI@Z				; CvString::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvString@@QAEPAXI@Z PROC				; CvString::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvString@@QAEPAXI@Z ENDP				; CvString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@H@std@@QAEXPAH@Z		; std::allocator<int>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@H@std@@QAEXPAH@Z PROC		; std::allocator<int>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z ; std::allocator<CvCity *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z PROC ; std::allocator<CvCity *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z ENDP ; std::allocator<CvCity *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z ; std::allocator<CvCity *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z PROC ; std::allocator<CvCity *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z ENDP ; std::allocator<CvCity *>::destroy
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	add	edx, ecx
	sar	edx, 8
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@4
	pop	esi
$LN3@Fill_n@4:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z ; std::get_temporary_buffer<TRSortElement>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z
_TEXT	SEGMENT
$T231469 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T231473 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z PROC ; std::get_temporary_buffer<TRSortElement>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	mov	edx, esi
	imul	edx, 448				; 000001c0H
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 448				; 000001c0H
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231473[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T231469[esp+20]
	mov	DWORD PTR $T231473[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231469[esp+20]
	push	ecx
	mov	DWORD PTR $T231469[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z ENDP ; std::get_temporary_buffer<TRSortElement>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEAAUTRSortElement@@XZ ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEAAUTRSortElement@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEAAUTRSortElement@@XZ PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBEAAUTRSortElement@@XZ ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<TRSortElement>::_Temp_iterator<TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<TRSortElement>::_Temp_iterator<TRSortElement>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@UTRSortElement@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<TRSortElement>::_Temp_iterator<TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	imul	ecx, 448				; 000001c0H
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 448			; 000001c0H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -448			; fffffe40H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator--
_TEXT	ENDS
PUBLIC	??$advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@H@Z ; std::advance<TRSortElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@H@Z PROC ; std::advance<TRSortElement *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	imul	ecx, 448				; 000001c0H
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAUTRSortElement@@H@std@@YAXAAPAUTRSortElement@@H@Z ENDP ; std::advance<TRSortElement *,int>
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1096 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1097 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1177 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1178 : 	}

	ret	0

; 1177 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1178 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isRevealed
EXTRN	?isDebugMode@CvGame@@QBE_NXZ:PROC		; CvGame::isDebugMode
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 612  : 		if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN1@isRevealed
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN1@isRevealed

; 613  : 			return true;

	mov	al, 1
	pop	esi

; 617  : 	}

	ret	8
$LN1@isRevealed:

; 614  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 615  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 616  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp]
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	pop	esi
	setne	al

; 617  : 	}

	ret	8
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1822 : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=

; 1823 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1824 : 		}

	ret	4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+, COMDAT
; _this$ = ecx

; 1827 : 		{	// return this + integer

	sub	esp, 8

; 1828 : 		_Mytype _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1829 : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR __Tmp$[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$[esp+8]
	mov	edx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1830 : 		}

	add	esp, 8
	ret	8
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1845 : 		return (*(_Mybase *)this - _Right);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1846 : 		}

	ret	4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1567 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1568 : 		}

	ret	4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1576 : 		{	// preincrement

	mov	eax, ecx

; 1577 : 		_Inc();

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN4@operator@8
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0

; 1577 : 		_Inc();

$LN4@operator@8:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=, COMDAT
; _this$ = ecx

; 1677 : 		return (!(*this == _Right));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@operator@9
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN5@operator@9
	mov	eax, 1
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4

; 1677 : 		return (!(*this == _Right));

$LN5@operator@9:
	xor	eax, eax
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
_TEXT	ENDS
PUBLIC	??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if bit is set

	mov	edx, ecx

; 1495 : 		return ((*_Getptr() & _Mask()) != 0);

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [edx]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1496 : 		}

	ret	0
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
_TEXT	ENDS
PUBLIC	??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1795 : 		{	// preincrement

	mov	eax, ecx

; 1796 : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN6@operator@10
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0

; 1796 : 		++*(_Mybase *)this;

$LN6@operator@10:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1471 : 		return (*this = bool(_Right));

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	esi
	mov	esi, 1
	shl	esi, cl
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	test	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, 1
	je	SHORT $LN10@operator@11
	shl	esi, cl
	or	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4

; 1471 : 		return (*this = bool(_Right));

$LN10@operator@11:
	shl	esi, cl
	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$fill@PAII@std@@YAXPAI0ABI@Z			; std::fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::fill<unsigned int *,unsigned int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
	npad	3

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LL10@Fill@5:
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LN18@Fill@5
	cmp	ecx, DWORD PTR __Last$[esp+4]
	je	SHORT $LN40@Fill@5
$LN18@Fill@5:

; 3159 : 		*_First = _Val;

	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR [edx], 0
	je	SHORT $LN27@Fill@5
	or	DWORD PTR [eax], esi
	jmp	SHORT $LN2@Fill@5
$LN27@Fill@5:
	not	esi
	and	DWORD PTR [eax], esi
$LN2@Fill@5:
	mov	ecx, DWORD PTR __First$[esp+4]
	mov	eax, DWORD PTR __First$[esp]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN11@Fill@5
	inc	ecx
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LL10@Fill@5

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LN11@Fill@5:
	xor	ecx, ecx
	add	eax, 4
	mov	DWORD PTR __First$[esp+4], ecx
	mov	DWORD PTR __First$[esp], eax
	jmp	SHORT $LL10@Fill@5
$LN40@Fill@5:
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@3
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@3:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1589 : 		{	// predecrement

	mov	eax, ecx

; 1590 : 		_Dec();

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN4@operator@12
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0

; 1590 : 		_Dec();

$LN4@operator@12:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@5
	pop	esi
$LN3@Fill_n@5:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@6
	pop	esi
$LN3@Fill_n@6:

; 3243 : 	}

	ret	0
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 219  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 220  : 	{
; 221  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
$LN2@plotDirect:

; 222  : 	}
; 223  : 	else
; 224  : 	{
; 225  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 226  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 227  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 228  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 229  : 
; 230  : 		// convert from hex-space coordinates to the storage array
; 231  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z ; CvGameTrade::GetPlotAdjacentToWater
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z
_TEXT	SEGMENT
_pCoastalPlot$ = -4					; size = 4
_pTargetLandPlot$ = 8					; size = 4
_pFromLandPlot$ = 12					; size = 4
?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z PROC ; CvGameTrade::GetPlotAdjacentToWater, COMDAT
; _this$ = ecx

; 536  : {

	push	ecx
	push	ebx

; 537  : 	CvPlot* pCoastalPlot = NULL;
; 538  : 	int iBestDistance = MAX_INT;
; 539  : 
; 540  : 	// Find a coastal water tile adjacent to enemy city
; 541  : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	ebx, DWORD PTR _pTargetLandPlot$[esp+4]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR _pCoastalPlot$[esp+20], edi
	mov	ebp, 2147483647				; 7fffffffH
$LL5@GetPlotAdj:

; 542  : 	{
; 543  : 		CvPlot* pAdjacentPlot = plotDirection(pFromLandPlot->getX(), pFromLandPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	eax, DWORD PTR _pFromLandPlot$[esp+16]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	edi
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 544  : 		if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	test	esi, esi
	je	SHORT $LN4@GetPlotAdj
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN4@GetPlotAdj
	mov	ecx, esi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	je	SHORT $LN4@GetPlotAdj

; 545  : 		{
; 546  : 			int iDistance = plotDistance(pAdjacentPlot->getX(), pAdjacentPlot->getY(), pTargetLandPlot->getX(), pTargetLandPlot->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	movsx	edx, WORD PTR [esi+2]
	push	eax
	movsx	eax, WORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 547  : 			if (iDistance < iBestDistance)

	cmp	eax, ebp
	jge	SHORT $LN4@GetPlotAdj

; 548  : 			{
; 549  : 				iBestDistance = iDistance;

	mov	ebp, eax

; 550  : 				pCoastalPlot = pAdjacentPlot;

	mov	DWORD PTR _pCoastalPlot$[esp+20], esi
$LN4@GetPlotAdj:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL5@GetPlotAdj

; 551  : 			}
; 552  : 		}
; 553  : 	}
; 554  : 
; 555  : 	return pCoastalPlot;

	mov	eax, DWORD PTR _pCoastalPlot$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 556  : }

	pop	ecx
	ret	8
?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z ENDP ; CvGameTrade::GetPlotAdjacentToWater
_TEXT	ENDS
PUBLIC	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
; Function compile flags: /Ogtpy
;	COMDAT ?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z
_TEXT	SEGMENT
_kConnection$ = 8					; size = 4
?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z PROC ; CvGameTrade::IsConnectionInternational, COMDAT
; _this$ = ecx

; 600  : 	TeamTypes eOriginTeam = NO_TEAM;
; 601  : 	TeamTypes eDestTeam = NO_TEAM;
; 602  : 
; 603  : 	if (kConnection.m_eOriginOwner != NO_PLAYER)

	mov	ecx, DWORD PTR _kConnection$[esp-4]
	mov	eax, DWORD PTR [ecx+20]
	push	ebx
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	esi
	or	esi, -1
	or	edx, esi
	push	edi
	mov	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	eax, esi
	je	SHORT $LN2@IsConnecti

; 604  : 	{
; 605  : 		eOriginTeam = GET_PLAYER(kConnection.m_eOriginOwner).getTeam();

	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN11@IsConnecti
	mov	esi, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN12@IsConnecti
$LN11@IsConnecti:
	or	eax, -1
$LN12@IsConnecti:
	mov	esi, eax
$LN2@IsConnecti:

; 606  : 	}
; 607  : 
; 608  : 	if (kConnection.m_eDestOwner != NO_PLAYER)

	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, -1
	je	SHORT $LN1@IsConnecti

; 609  : 	{
; 610  : 		eDestTeam = GET_PLAYER(kConnection.m_eDestOwner).getTeam();

	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN22@IsConnecti
	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, eax

; 611  : 	}
; 612  : 
; 613  : 	return (eOriginTeam != eDestTeam);

	xor	eax, eax
	pop	edi
	cmp	esi, edx
	pop	esi
	setne	al
	pop	ebx

; 614  : }

	ret	4

; 609  : 	{
; 610  : 		eDestTeam = GET_PLAYER(kConnection.m_eDestOwner).getTeam();

$LN22@IsConnecti:
	or	eax, -1
	mov	edx, eax
$LN1@IsConnecti:

; 611  : 	}
; 612  : 
; 613  : 	return (eOriginTeam != eDestTeam);

	xor	eax, eax
	pop	edi
	cmp	esi, edx
	pop	esi
	setne	al
	pop	ebx

; 614  : }

	ret	4
?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ENDP ; CvGameTrade::IsConnectionInternational
_TEXT	ENDS
PUBLIC	?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z ; CvGameTrade::IsCityConnectedToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_iCityY$ = -4						; size = 4
_iCityX$ = 8						; size = 4
_pCity$ = 8						; size = 4
_eOtherPlayer$ = 12					; size = 4
_bOnlyOwnedByCityOwner$ = 16				; size = 1
?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z PROC ; CvGameTrade::IsCityConnectedToPlayer, COMDAT
; _this$ = ecx

; 622  : {

	push	ecx

; 623  : 	PlayerTypes eCityOwnerPlayer = pCity->getOwner();

	mov	eax, DWORD PTR _pCity$[esp]

; 624  : 	int iCityX = pCity->getX();

	mov	edx, DWORD PTR [eax+96]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax+84]

; 625  : 	int iCityY = pCity->getY();

	mov	eax, DWORD PTR [eax+108]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+4]

; 626  : 
; 627  : #ifdef AUI_ITERATORIZE
; 628  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 629  : 	{
; 630  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 631  : #else
; 632  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	esi, esi
	mov	DWORD PTR _iCityX$[esp+16], edx
	mov	DWORD PTR _iCityY$[esp+20], eax
	test	edi, edi
	jbe	SHORT $LN7@IsCityConn
	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR _eOtherPlayer$[esp+16]
	add	eax, 8
	npad	4
$LL9@IsCityConn:

; 633  : 	{
; 634  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR [eax-4]
	or	ecx, -1
	cmp	edx, ecx
	jne	SHORT $LN27@IsCityConn
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN27@IsCityConn
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN27@IsCityConn
	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN8@IsCityConn
$LN27@IsCityConn:

; 635  : #endif
; 636  : 		{
; 637  : 			continue;
; 638  : 		}
; 639  : 		
; 640  : #ifndef AUI_ITERATORIZE
; 641  : #ifdef AUI_CONSTIFY
; 642  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 643  : #else
; 644  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 645  : #endif
; 646  : #endif
; 647  : 
; 648  : 		if (pConnection->m_eOriginOwner == eCityOwnerPlayer && pConnection->m_eDestOwner == eOtherPlayer)

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, ebp
	jne	SHORT $LN45@IsCityConn
	cmp	DWORD PTR [eax+16], ebx
	jne	SHORT $LN45@IsCityConn

; 649  : 		{
; 650  : 			if (pConnection->m_iOriginX == iCityX && pConnection->m_iOriginY == iCityY)

	cmp	edx, DWORD PTR _iCityX$[esp+16]
	jne	SHORT $LN8@IsCityConn
	mov	ecx, DWORD PTR _iCityY$[esp+20]
	cmp	DWORD PTR [eax], ecx

; 653  : 			}
; 654  : 		}

	jmp	SHORT $LN47@IsCityConn
$LN45@IsCityConn:

; 655  : 		else if (!bOnlyOwnedByCityOwner && pConnection->m_eOriginOwner == eOtherPlayer && pConnection->m_eDestOwner == eCityOwnerPlayer)

	cmp	BYTE PTR _bOnlyOwnedByCityOwner$[esp+16], 0
	jne	SHORT $LN8@IsCityConn
	cmp	ecx, ebx
	jne	SHORT $LN8@IsCityConn
	cmp	DWORD PTR [eax+16], ebp
	jne	SHORT $LN8@IsCityConn

; 656  : 		{
; 657  : 			if (pConnection->m_iDestX == iCityX && pConnection->m_iDestY == iCityY)

	mov	edx, DWORD PTR _iCityX$[esp+16]
	cmp	DWORD PTR [eax+4], edx
	jne	SHORT $LN8@IsCityConn
	mov	ecx, DWORD PTR _iCityY$[esp+20]
	cmp	DWORD PTR [eax+8], ecx
$LN47@IsCityConn:
	je	SHORT $LN41@IsCityConn
$LN8@IsCityConn:

; 626  : 
; 627  : #ifdef AUI_ITERATORIZE
; 628  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 629  : 	{
; 630  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 631  : #else
; 632  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	inc	esi
	add	eax, 444				; 000001bcH
	cmp	esi, edi
	jb	SHORT $LL9@IsCityConn
$LN7@IsCityConn:
	pop	edi
	pop	esi
	pop	ebp

; 658  : 			{
; 659  : 				return true;
; 660  : 			}
; 661  : 		}
; 662  : 	}
; 663  : 
; 664  : 	return false;

	xor	al, al
	pop	ebx

; 665  : }

	pop	ecx
	ret	12					; 0000000cH
$LN41@IsCityConn:
	pop	edi
	pop	esi
	pop	ebp

; 651  : 			{
; 652  : 				return true;

	mov	al, 1
	pop	ebx

; 665  : }

	pop	ecx
	ret	12					; 0000000cH
?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z ENDP ; CvGameTrade::IsCityConnectedToPlayer
_TEXT	ENDS
PUBLIC	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eFirstPlayer$ = 8					; size = 4
_eSecondPlayer$ = 12					; size = 4
?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z PROC ; CvGameTrade::IsPlayerConnectedToPlayer, COMDAT
; _this$ = ecx

; 743  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+4]

; 744  : #ifdef AUI_ITERATORIZE
; 745  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 746  : 	{
; 747  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 748  : #else
; 749  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edx, edx
	push	edi
	test	esi, esi
	jbe	SHORT $LN5@IsPlayerCo
	mov	eax, DWORD PTR [ecx]
	mov	ebp, DWORD PTR _eSecondPlayer$[esp+12]
	mov	edi, DWORD PTR _eFirstPlayer$[esp+12]
	add	eax, 8
	or	ebx, -1
	npad	3
$LL7@IsPlayerCo:

; 750  : 	{
; 751  : #ifdef AUI_CONSTIFY
; 752  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 753  : #else
; 754  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 755  : #endif
; 756  : 
; 757  : 		if (IsTradeRouteIndexEmpty(ui))

	cmp	DWORD PTR [eax-4], ebx
	jne	SHORT $LN15@IsPlayerCo
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN15@IsPlayerCo
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN15@IsPlayerCo
	cmp	DWORD PTR [eax+8], ebx
	je	SHORT $LN6@IsPlayerCo
$LN15@IsPlayerCo:

; 758  : #endif
; 759  : 		{
; 760  : 			continue;
; 761  : 		}
; 762  : 
; 763  : 		if (pConnection->m_eOriginOwner == eFirstPlayer && pConnection->m_eDestOwner == eSecondPlayer)

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edi
	jne	SHORT $LN3@IsPlayerCo
	cmp	DWORD PTR [eax+16], ebp
	je	SHORT $LN27@IsPlayerCo
$LN3@IsPlayerCo:

; 766  : 		}
; 767  : 		else if (pConnection->m_eOriginOwner == eSecondPlayer && pConnection->m_eDestOwner == eFirstPlayer)

	cmp	ecx, ebp
	jne	SHORT $LN6@IsPlayerCo
	cmp	DWORD PTR [eax+16], edi
	je	SHORT $LN27@IsPlayerCo
$LN6@IsPlayerCo:

; 744  : #ifdef AUI_ITERATORIZE
; 745  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 746  : 	{
; 747  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 748  : #else
; 749  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	inc	edx
	add	eax, 444				; 000001bcH
	cmp	edx, esi
	jb	SHORT $LL7@IsPlayerCo
$LN5@IsPlayerCo:
	pop	edi
	pop	esi
	pop	ebp

; 768  : 		{
; 769  : 			return true;
; 770  : 		}
; 771  : 	}
; 772  : 
; 773  : 	return false;

	xor	al, al
	pop	ebx

; 774  : }

	ret	8
$LN27@IsPlayerCo:
	pop	edi
	pop	esi
	pop	ebp

; 764  : 		{
; 765  : 			return true;

	mov	al, 1
	pop	ebx

; 774  : }

	ret	8
?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ENDP ; CvGameTrade::IsPlayerConnectedToPlayer
_TEXT	ENDS
PUBLIC	?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::CountNumPlayerConnectionsToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eFirstPlayer$ = 8					; size = 4
_eSecondPlayer$ = 12					; size = 4
?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z PROC ; CvGameTrade::CountNumPlayerConnectionsToPlayer, COMDAT
; _this$ = ecx

; 782  : {

	mov	edx, DWORD PTR [ecx+4]

; 783  : 	int iCount = 0;

	xor	eax, eax

; 784  : 
; 785  : #ifdef AUI_ITERATORIZE
; 786  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 787  : 	{
; 788  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 789  : #else
; 790  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN5@CountNumPl
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _eSecondPlayer$[esp+4]
	push	esi
	mov	esi, DWORD PTR _eFirstPlayer$[esp+8]
	push	edi
	add	ecx, 8
	mov	ebx, edx
	or	edi, -1
	npad	1
$LL7@CountNumPl:

; 791  : 	{
; 792  : #ifdef AUI_CONSTIFY
; 793  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 794  : #else
; 795  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 796  : #endif
; 797  : 
; 798  : 		if (IsTradeRouteIndexEmpty(ui))

	cmp	DWORD PTR [ecx-4], edi
	jne	SHORT $LN15@CountNumPl
	cmp	DWORD PTR [ecx], edi
	jne	SHORT $LN15@CountNumPl
	cmp	DWORD PTR [ecx+4], edi
	jne	SHORT $LN15@CountNumPl
	cmp	DWORD PTR [ecx+8], edi
	je	SHORT $LN6@CountNumPl
$LN15@CountNumPl:

; 799  : #endif
; 800  : 		{
; 801  : 			continue;
; 802  : 		}
; 803  : 
; 804  : 		if (pConnection->m_eOriginOwner == eFirstPlayer && pConnection->m_eDestOwner == eSecondPlayer)

	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, esi
	jne	SHORT $LN3@CountNumPl
	cmp	DWORD PTR [ecx+16], ebp

; 805  : 		{
; 806  : 			iCount++;

	je	SHORT $LN31@CountNumPl
$LN3@CountNumPl:

; 807  : 		}
; 808  : 		else if (pConnection->m_eOriginOwner == eSecondPlayer && pConnection->m_eDestOwner == eFirstPlayer)

	cmp	edx, ebp
	jne	SHORT $LN6@CountNumPl
	cmp	DWORD PTR [ecx+16], esi
	jne	SHORT $LN6@CountNumPl
$LN31@CountNumPl:

; 809  : 		{
; 810  : 			iCount++;

	inc	eax
$LN6@CountNumPl:

; 784  : 
; 785  : #ifdef AUI_ITERATORIZE
; 786  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 787  : 	{
; 788  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 789  : #else
; 790  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	add	ecx, 444				; 000001bcH
	sub	ebx, 1
	jne	SHORT $LL7@CountNumPl
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN5@CountNumPl:

; 811  : 		}
; 812  : 	}
; 813  : 
; 814  : 	return iCount;
; 815  : }

	ret	8
?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ENDP ; CvGameTrade::CountNumPlayerConnectionsToPlayer
_TEXT	ENDS
PUBLIC	?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ; CvGameTrade::IsCityConnectedToCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z
_TEXT	SEGMENT
_iSecondCityX$ = 8					; size = 4
_pFirstCity$ = 8					; size = 4
_iSecondCityY$ = 12					; size = 4
_pSecondCity$ = 12					; size = 4
?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z PROC ; CvGameTrade::IsCityConnectedToCity, COMDAT
; _this$ = ecx

; 824  : 	int iFirstCityX = pFirstCity->getX();

	mov	eax, DWORD PTR _pFirstCity$[esp-4]
	push	ebx

; 825  : 	int iFirstCityY = pFirstCity->getY();

	mov	ebx, DWORD PTR [eax+108]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	push	edi
	mov	edi, DWORD PTR [eax+96]

; 826  : 	int iSecondCityX = pSecondCity->getX();

	mov	eax, DWORD PTR _pSecondCity$[esp+12]
	mov	edx, DWORD PTR [eax+96]

; 827  : 	int iSecondCityY = pSecondCity->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR _iSecondCityX$[esp+12], edx

; 828  : 
; 829  : #ifdef AUI_ITERATORIZE
; 830  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 831  : 	{
; 832  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 833  : #else
; 834  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edx, edx
	mov	DWORD PTR _iSecondCityY$[esp+12], eax
	test	esi, esi
	jbe	SHORT $LN5@IsCityConn@2
	mov	eax, DWORD PTR [ecx]
	add	eax, 8
	or	ebp, -1
$LL7@IsCityConn@2:

; 835  : 	{
; 836  : #ifdef AUI_CONSTIFY
; 837  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 838  : #else
; 839  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 840  : #endif
; 841  : 
; 842  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, ebp
	jne	SHORT $LN31@IsCityConn@2
	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN31@IsCityConn@2
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN31@IsCityConn@2
	cmp	DWORD PTR [eax+8], ebp
	je	SHORT $LN6@IsCityConn@2
$LN31@IsCityConn@2:

; 843  : #endif
; 844  : 		{
; 845  : 			continue;
; 846  : 		}
; 847  : 
; 848  : 		if (pConnection->m_iOriginX == iFirstCityX && pConnection->m_iOriginY == iFirstCityY && pConnection->m_iDestX == iSecondCityX && pConnection->m_iDestY == iSecondCityY)

	cmp	ecx, edi
	jne	SHORT $LN48@IsCityConn@2
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN48@IsCityConn@2
	mov	ebp, DWORD PTR [eax+4]
	cmp	ebp, DWORD PTR _iSecondCityX$[esp+12]
	jne	SHORT $LN48@IsCityConn@2
	mov	ebp, DWORD PTR _iSecondCityY$[esp+12]
	cmp	DWORD PTR [eax+8], ebp
	je	SHORT $LN43@IsCityConn@2
$LN48@IsCityConn@2:

; 851  : 		}
; 852  : 		else if (pConnection->m_iOriginX == iSecondCityX && pConnection->m_iOriginY == iSecondCityY && pConnection->m_iDestX == iFirstCityX && pConnection->m_iDestY == iFirstCityY)

	cmp	ecx, DWORD PTR _iSecondCityX$[esp+12]
	jne	SHORT $LN47@IsCityConn@2
	mov	ecx, DWORD PTR _iSecondCityY$[esp+12]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN47@IsCityConn@2
	cmp	DWORD PTR [eax+4], edi
	jne	SHORT $LN47@IsCityConn@2
	cmp	DWORD PTR [eax+8], ebx
	je	SHORT $LN43@IsCityConn@2
$LN47@IsCityConn@2:
	or	ebp, -1
$LN6@IsCityConn@2:

; 828  : 
; 829  : #ifdef AUI_ITERATORIZE
; 830  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 831  : 	{
; 832  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 833  : #else
; 834  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	inc	edx
	add	eax, 444				; 000001bcH
	cmp	edx, esi
	jb	SHORT $LL7@IsCityConn@2
$LN5@IsCityConn@2:
	pop	edi
	pop	esi
	pop	ebp

; 853  : 		{
; 854  : 			return true;
; 855  : 		}
; 856  : 	}
; 857  : 
; 858  : 	return false;	

	xor	al, al
	pop	ebx

; 859  : }

	ret	8
$LN43@IsCityConn@2:
	pop	edi
	pop	esi
	pop	ebp

; 849  : 		{
; 850  : 			return true;

	mov	al, 1
	pop	ebx

; 859  : }

	ret	8
?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ENDP ; CvGameTrade::IsCityConnectedToCity
_TEXT	ENDS
PUBLIC	?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ; CvGameTrade::IsCityConnectedFromCityToCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z
_TEXT	SEGMENT
_iSecondCityY$ = 8					; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z PROC ; CvGameTrade::IsCityConnectedFromCityToCity, COMDAT
; _this$ = ecx

; 868  : 	int iFirstCityX = pOriginCity->getX();

	mov	eax, DWORD PTR _pOriginCity$[esp-4]
	push	ebx

; 869  : 	int iFirstCityY = pOriginCity->getY();

	mov	ebx, DWORD PTR [eax+108]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	push	edi
	mov	edi, DWORD PTR [eax+96]

; 870  : 	int iSecondCityX = pDestCity->getX();

	mov	eax, DWORD PTR _pDestCity$[esp+12]
	mov	ebp, DWORD PTR [eax+96]

; 871  : 	int iSecondCityY = pDestCity->getY();

	mov	eax, DWORD PTR [eax+108]

; 872  : 
; 873  : #ifdef AUI_ITERATORIZE
; 874  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 875  : 	{
; 876  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 877  : #else
; 878  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edx, edx
	mov	DWORD PTR _iSecondCityY$[esp+12], eax
	test	esi, esi
	jbe	SHORT $LN3@IsCityConn@3
	mov	eax, DWORD PTR [ecx]
	add	eax, 8
	npad	6
$LL5@IsCityConn@3:

; 879  : 	{
; 880  : #ifdef AUI_CONSTIFY
; 881  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 882  : #else
; 883  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 884  : #endif
; 885  : 
; 886  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, -1
	jne	SHORT $LN29@IsCityConn@3
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN29@IsCityConn@3
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN29@IsCityConn@3
	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN4@IsCityConn@3
$LN29@IsCityConn@3:

; 887  : #endif
; 888  : 		{
; 889  : 			continue;
; 890  : 		}
; 891  : 
; 892  : 		if (pConnection->m_iOriginX == iFirstCityX && pConnection->m_iOriginY == iFirstCityY && pConnection->m_iDestX == iSecondCityX && pConnection->m_iDestY == iSecondCityY)

	cmp	ecx, edi
	jne	SHORT $LN4@IsCityConn@3
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN4@IsCityConn@3
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN4@IsCityConn@3
	mov	ecx, DWORD PTR _iSecondCityY$[esp+12]
	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN41@IsCityConn@3
$LN4@IsCityConn@3:

; 872  : 
; 873  : #ifdef AUI_ITERATORIZE
; 874  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 875  : 	{
; 876  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 877  : #else
; 878  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	inc	edx
	add	eax, 444				; 000001bcH
	cmp	edx, esi
	jb	SHORT $LL5@IsCityConn@3
$LN3@IsCityConn@3:
	pop	edi
	pop	esi
	pop	ebp

; 895  : 		}
; 896  : 	}
; 897  : 
; 898  : 	return false;

	xor	al, al
	pop	ebx

; 899  : }

	ret	8
$LN41@IsCityConn@3:
	pop	edi
	pop	esi
	pop	ebp

; 893  : 		{
; 894  : 			return true;

	mov	al, 1
	pop	ebx

; 899  : }

	ret	8
?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ENDP ; CvGameTrade::IsCityConnectedFromCityToCity
_TEXT	ENDS
PUBLIC	?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesOriginCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z
_TEXT	SEGMENT
_iCityY$ = 8						; size = 4
_pCity$ = 8						; size = 4
_bOnlyInternational$ = 12				; size = 1
?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z PROC ; CvGameTrade::GetNumTimesOriginCity, COMDAT
; _this$ = ecx

; 908  : 	int iCount = 0;
; 909  : 	int iCityX = pCity->getX();

	mov	edx, DWORD PTR _pCity$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [edx+96]

; 910  : 	int iCityY = pCity->getY();

	mov	edx, DWORD PTR [edx+108]
	mov	DWORD PTR _iCityY$[esp], edx
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax

; 911  : 
; 912  : #ifdef AUI_ITERATORIZE
; 913  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 914  : 	{
; 915  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 916  : #else
; 917  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN6@GetNumTime
	mov	ecx, DWORD PTR [ecx]
	push	ebp
	push	esi
	push	edi
	add	ecx, 4
	mov	ebp, edx
	mov	dl, BYTE PTR _bOnlyInternational$[esp+12]
	or	edi, -1
	npad	7
$LL8@GetNumTime:

; 918  : 	{
; 919  : #ifdef AUI_CONSTIFY
; 920  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 921  : #else
; 922  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 923  : #endif
; 924  : 
; 925  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	esi, DWORD PTR [ecx]
	cmp	esi, edi
	jne	SHORT $LN24@GetNumTime
	cmp	DWORD PTR [ecx+4], edi
	jne	SHORT $LN24@GetNumTime
	cmp	DWORD PTR [ecx+8], edi
	jne	SHORT $LN24@GetNumTime
	cmp	DWORD PTR [ecx+12], edi
	je	SHORT $LN7@GetNumTime
$LN24@GetNumTime:

; 926  : #endif
; 927  : 		{
; 928  : 			continue;
; 929  : 		}
; 930  : 
; 931  : 		if (pConnection->m_iOriginX == iCityX && pConnection->m_iOriginY == iCityY)

	cmp	esi, ebx
	jne	SHORT $LN7@GetNumTime
	mov	esi, DWORD PTR _iCityY$[esp+12]
	cmp	DWORD PTR [ecx+4], esi
	jne	SHORT $LN7@GetNumTime

; 932  : 		{
; 933  : 			if (bOnlyInternational)

	test	dl, dl
	je	SHORT $LN3@GetNumTime

; 934  : 			{
; 935  : 				if (pConnection->m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN7@GetNumTime
$LN3@GetNumTime:

; 936  : 				{
; 937  : 					iCount++;
; 938  : 				}
; 939  : 			}
; 940  : 			else
; 941  : 			{
; 942  : 				iCount++;

	inc	eax
$LN7@GetNumTime:

; 911  : 
; 912  : #ifdef AUI_ITERATORIZE
; 913  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 914  : 	{
; 915  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 916  : #else
; 917  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	add	ecx, 444				; 000001bcH
	sub	ebp, 1
	jne	SHORT $LL8@GetNumTime
	pop	edi
	pop	esi
	pop	ebp
$LN6@GetNumTime:
	pop	ebx

; 943  : 			}
; 944  : 		}
; 945  : 	}
; 946  : 
; 947  : 	return iCount;	
; 948  : }

	ret	8
?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ENDP ; CvGameTrade::GetNumTimesOriginCity
_TEXT	ENDS
PUBLIC	?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesDestinationCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_bOnlyInternational$ = 12				; size = 1
?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z PROC ; CvGameTrade::GetNumTimesDestinationCity, COMDAT
; _this$ = ecx

; 957  : 	int iCount = 0;
; 958  : 	int iCityX = pCity->getX();

	mov	edx, DWORD PTR _pCity$[esp-4]
	push	ebx

; 959  : 	int iCityY = pCity->getY();

	mov	ebx, DWORD PTR [edx+108]
	push	ebp
	mov	ebp, DWORD PTR [edx+96]
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax

; 960  : 
; 961  : #ifdef AUI_ITERATORIZE
; 962  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 963  : 	{
; 964  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 965  : #else
; 966  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN6@GetNumTime@2
	mov	ecx, DWORD PTR [ecx]
	push	esi
	push	edi
	add	ecx, 12					; 0000000cH
	mov	esi, edx
	mov	dl, BYTE PTR _bOnlyInternational$[esp+12]
	or	edi, -1
$LL8@GetNumTime@2:

; 967  : 	{
; 968  : #ifdef AUI_CONSTIFY
; 969  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 970  : #else
; 971  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 972  : #endif
; 973  : 
; 974  : 		if (IsTradeRouteIndexEmpty(ui))

	cmp	DWORD PTR [ecx-8], edi
	jne	SHORT $LN24@GetNumTime@2
	cmp	DWORD PTR [ecx-4], edi
	jne	SHORT $LN24@GetNumTime@2
	cmp	DWORD PTR [ecx], edi
	jne	SHORT $LN24@GetNumTime@2
	cmp	DWORD PTR [ecx+4], edi
	je	SHORT $LN7@GetNumTime@2
$LN24@GetNumTime@2:

; 975  : #endif
; 976  : 		{
; 977  : 			continue;
; 978  : 		}
; 979  : 
; 980  : 		if (pConnection->m_iDestX == iCityX && pConnection->m_iDestY == iCityY)

	cmp	DWORD PTR [ecx], ebp
	jne	SHORT $LN7@GetNumTime@2
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN7@GetNumTime@2

; 981  : 		{
; 982  : 			if (bOnlyInternational)

	test	dl, dl
	je	SHORT $LN3@GetNumTime@2

; 983  : 			{
; 984  : 				if (pConnection->m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN7@GetNumTime@2
$LN3@GetNumTime@2:

; 985  : 				{
; 986  : 					iCount++;
; 987  : 				}
; 988  : 			}
; 989  : 			else
; 990  : 			{
; 991  : 				iCount++;

	inc	eax
$LN7@GetNumTime@2:

; 960  : 
; 961  : #ifdef AUI_ITERATORIZE
; 962  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 963  : 	{
; 964  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 965  : #else
; 966  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	add	ecx, 444				; 000001bcH
	sub	esi, 1
	jne	SHORT $LL8@GetNumTime@2
	pop	edi
	pop	esi
$LN6@GetNumTime@2:
	pop	ebp
	pop	ebx

; 992  : 			}
; 993  : 		}
; 994  : 	}
; 995  : 
; 996  : 	return iCount;	
; 997  : }

	ret	8
?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ENDP ; CvGameTrade::GetNumTimesDestinationCity
_TEXT	ENDS
PUBLIC	?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ	; CvGameTrade::GetEmptyTradeRouteIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ
_TEXT	SEGMENT
?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ PROC	; CvGameTrade::GetEmptyTradeRouteIndex, COMDAT
; _this$ = ecx

; 1005 : {

	mov	edx, DWORD PTR [ecx+4]
	push	esi

; 1006 : 	for (uint i = 0; i < m_aTradeConnections.size(); i++)

	xor	eax, eax
	or	esi, -1
	test	edx, edx
	jbe	SHORT $LN2@GetEmptyTr
	mov	ecx, DWORD PTR [ecx]
	add	ecx, 8
$LL4@GetEmptyTr:

; 1007 : 	{
; 1008 : 		if (IsTradeRouteIndexEmpty(i))

	cmp	DWORD PTR [ecx-4], esi
	jne	SHORT $LN10@GetEmptyTr
	cmp	DWORD PTR [ecx], esi
	jne	SHORT $LN10@GetEmptyTr
	cmp	DWORD PTR [ecx+4], esi
	jne	SHORT $LN10@GetEmptyTr
	cmp	DWORD PTR [ecx+8], esi
	je	SHORT $LN5@GetEmptyTr
$LN10@GetEmptyTr:
	inc	eax
	add	ecx, 444				; 000001bcH
	cmp	eax, edx
	jb	SHORT $LL4@GetEmptyTr
$LN2@GetEmptyTr:

; 1009 : 		{
; 1010 : 			return i;
; 1011 : 		}
; 1012 : 	}
; 1013 : 
; 1014 : 	return -1;

	mov	eax, esi
$LN5@GetEmptyTr:
	pop	esi

; 1015 : }

	ret	0
?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ ENDP	; CvGameTrade::GetEmptyTradeRouteIndex
_TEXT	ENDS
PUBLIC	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z PROC ; CvGameTrade::GetOriginCity, COMDAT

; 1544 : 	CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR _kTradeConnection$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN44@GetOriginC
	cmp	ebx, -2147483647			; 80000001H
	je	$LN44@GetOriginC
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN51@GetOriginC
	test	eax, eax
	jge	SHORT $LN18@GetOriginC
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN20@GetOriginC
$LN18@GetOriginC:
	cmp	eax, ecx
	jl	SHORT $LN51@GetOriginC
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN20@GetOriginC
$LN51@GetOriginC:
	mov	esi, eax
$LN20@GetOriginC:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN52@GetOriginC
	test	ebx, ebx
	jge	SHORT $LN28@GetOriginC
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN30@GetOriginC
$LN28@GetOriginC:
	cmp	ebx, edi
	jl	SHORT $LN52@GetOriginC
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN30@GetOriginC
$LN52@GetOriginC:
	mov	edx, ebx
$LN30@GetOriginC:
	test	esi, esi
	jl	SHORT $LN44@GetOriginC
	cmp	esi, ecx
	jge	SHORT $LN44@GetOriginC
	test	edx, edx
	jl	SHORT $LN44@GetOriginC
	cmp	edx, edi
	jge	SHORT $LN44@GetOriginC
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 1545 : 
; 1546 : 	CvAssertMsg(pPlot, "CvPlayerTrade - plot is null");
; 1547 : 	if (!pPlot)

	test	ecx, ecx

; 1548 : 	{
; 1549 : 		return NULL;

	je	SHORT $LN44@GetOriginC

; 1550 : 	}
; 1551 : 
; 1552 : 	return pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN44@GetOriginC
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN44@GetOriginC
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1553 : }

	ret	0

; 1550 : 	}
; 1551 : 
; 1552 : 	return pPlot->getPlotCity();

$LN44@GetOriginC:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 1553 : }

	ret	0
?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ENDP ; CvGameTrade::GetOriginCity
_TEXT	ENDS
PUBLIC	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z PROC ; CvGameTrade::GetDestCity, COMDAT

; 1558 : 	CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	eax, DWORD PTR _kTradeConnection$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+12]
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN44@GetDestCit
	cmp	ebx, -2147483647			; 80000001H
	je	$LN44@GetDestCit
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN51@GetDestCit
	test	eax, eax
	jge	SHORT $LN18@GetDestCit
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN20@GetDestCit
$LN18@GetDestCit:
	cmp	eax, ecx
	jl	SHORT $LN51@GetDestCit
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN20@GetDestCit
$LN51@GetDestCit:
	mov	esi, eax
$LN20@GetDestCit:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN52@GetDestCit
	test	ebx, ebx
	jge	SHORT $LN28@GetDestCit
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN30@GetDestCit
$LN28@GetDestCit:
	cmp	ebx, edi
	jl	SHORT $LN52@GetDestCit
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN30@GetDestCit
$LN52@GetDestCit:
	mov	edx, ebx
$LN30@GetDestCit:
	test	esi, esi
	jl	SHORT $LN44@GetDestCit
	cmp	esi, ecx
	jge	SHORT $LN44@GetDestCit
	test	edx, edx
	jl	SHORT $LN44@GetDestCit
	cmp	edx, edi
	jge	SHORT $LN44@GetDestCit
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 1559 : 
; 1560 : 	CvAssertMsg(pPlot, "CvPlayerTrade - plot is null");
; 1561 : 	if (!pPlot)

	test	ecx, ecx

; 1562 : 	{
; 1563 : 		return NULL;

	je	SHORT $LN44@GetDestCit

; 1564 : 	}
; 1565 : 
; 1566 : 	return pPlot->getPlotCity();	

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN44@GetDestCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN44@GetDestCit
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1567 : }

	ret	0

; 1564 : 	}
; 1565 : 
; 1566 : 	return pPlot->getPlotCity();	

$LN44@GetDestCit:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 1567 : }

	ret	0
?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ENDP ; CvGameTrade::GetDestCity
_TEXT	ENDS
PUBLIC	?BuildTechDifference@CvGameTrade@@QAEXXZ	; CvGameTrade::BuildTechDifference
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetNumTechs@CvTechXMLEntries@@QAEHXZ:PROC	; CvTechXMLEntries::GetNumTechs
EXTRN	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvPlayerTechs::GetTechs
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
; Function compile flags: /Ogtpy
;	COMDAT ?BuildTechDifference@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
$T233333 = -24						; size = 4
_iTechDifference$220844 = -20				; size = 4
tv483 = -16						; size = 4
tv448 = -12						; size = 4
tv504 = -8						; size = 4
_pPlayerTechs$220845 = -4				; size = 4
?BuildTechDifference@CvGameTrade@@QAEXXZ PROC		; CvGameTrade::BuildTechDifference, COMDAT
; _this$ = ecx

; 1607 : {

	sub	esp, 24					; 00000018H
	push	esi
	mov	esi, ecx

; 1608 : 	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	17					; 00000011H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	$LN13@BuildTechD
	push	ebx
	push	ebp

; 1609 : 	{
; 1610 : 		return;
; 1611 : 	}
; 1612 : 
; 1613 : 	// for each major civ
; 1614 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1615 : 	if (eForPlayer == NO_PLAYER)
; 1616 : 	{
; 1617 : 		for (uint uiPlayer1 = 0; uiPlayer1 < MAX_MAJOR_CIVS; uiPlayer1++)
; 1618 : 		{
; 1619 : 			PlayerTypes ePlayer1 = (PlayerTypes)uiPlayer1;
; 1620 : 			TeamTypes eTeam1 = GET_PLAYER(ePlayer1).getTeam();
; 1621 : 
; 1622 : 			for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)
; 1623 : 			{
; 1624 : 				PlayerTypes ePlayer2 = (PlayerTypes)uiPlayer2;
; 1625 : 				TeamTypes eTeam2 = GET_PLAYER(ePlayer2).getTeam();
; 1626 : 
; 1627 : 				if (eTeam1 == eTeam2)
; 1628 : 				{
; 1629 : 					m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;
; 1630 : 				}
; 1631 : 				else if (!GET_PLAYER(ePlayer1).isAlive() || !GET_PLAYER(ePlayer2).isAlive())
; 1632 : 				{
; 1633 : 					m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;
; 1634 : 				}
; 1635 : 				else
; 1636 : 				{
; 1637 : 					int iTechDifference = 0;
; 1638 : 
; 1639 : 					CvPlayerTechs* pPlayerTechs = GET_PLAYER(ePlayer1).GetPlayerTechs();
; 1640 : 					for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1641 : 					{
; 1642 : 						TechTypes eTech = (TechTypes)iTechLoop;
; 1643 : 						bool bPlayer1Knows = GET_TEAM(eTeam1).GetTeamTechs()->HasTech(eTech);
; 1644 : 						bool bPlayer2Knows = GET_TEAM(eTeam2).GetTeamTechs()->HasTech(eTech);
; 1645 : 						if (bPlayer2Knows && !bPlayer1Knows)
; 1646 : 						{
; 1647 : 							iTechDifference++;
; 1648 : 						}
; 1649 : 					}
; 1650 : 
; 1651 : 					m_aaiTechDifference[uiPlayer1][uiPlayer2] = iTechDifference;
; 1652 : 				}
; 1653 : 			}
; 1654 : 		}
; 1655 : 	}
; 1656 : 	else
; 1657 : 	{
; 1658 : 		TeamTypes eTeam1 = GET_PLAYER(eForPlayer).getTeam();
; 1659 : 
; 1660 : 		for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)
; 1661 : 		{
; 1662 : 			PlayerTypes ePlayer2 = (PlayerTypes)uiPlayer2;
; 1663 : 			TeamTypes eTeam2 = GET_PLAYER(ePlayer2).getTeam();
; 1664 : 
; 1665 : 			if (eTeam1 == eTeam2)
; 1666 : 			{
; 1667 : 				m_aaiTechDifference[eForPlayer][uiPlayer2] = 0;
; 1668 : 			}
; 1669 : 			else if (!GET_PLAYER(eForPlayer).isAlive() || !GET_PLAYER(ePlayer2).isAlive())
; 1670 : 			{
; 1671 : 				m_aaiTechDifference[eForPlayer][uiPlayer2] = 0;
; 1672 : 			}
; 1673 : 			else
; 1674 : 			{
; 1675 : 				int iTechDifference = 0;
; 1676 : 
; 1677 : 				CvPlayerTechs* pPlayerTechs = GET_PLAYER(eForPlayer).GetPlayerTechs();
; 1678 : 				for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1679 : 				{
; 1680 : 					TechTypes eTech = (TechTypes)iTechLoop;
; 1681 : 					bool bPlayer1Knows = GET_TEAM(eTeam1).GetTeamTechs()->HasTech(eTech);
; 1682 : 					bool bPlayer2Knows = GET_TEAM(eTeam2).GetTeamTechs()->HasTech(eTech);
; 1683 : 					if (bPlayer2Knows && !bPlayer1Knows)
; 1684 : 					{
; 1685 : 						iTechDifference++;
; 1686 : 					}
; 1687 : 				}
; 1688 : 
; 1689 : 				m_aaiTechDifference[eForPlayer][uiPlayer2] = iTechDifference;
; 1690 : 			}
; 1691 : 		}
; 1692 : 	}
; 1693 : #else
; 1694 : 	for (uint uiPlayer1 = 0; uiPlayer1 < MAX_MAJOR_CIVS; uiPlayer1++)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR tv504[esp+40], ebx
	lea	edx, DWORD PTR [esi+74612]
	npad	6
$LL69@BuildTechD:

; 1695 : 	{
; 1696 : 		PlayerTypes ePlayer1 = (PlayerTypes)uiPlayer1;
; 1697 : 		TeamTypes eTeam1 = GET_PLAYER(ePlayer1).getTeam();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR [ebx+eax+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN27@BuildTechD
	mov	esi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+ecx*4]

; 1698 : 
; 1699 : 		for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)

	xor	edi, edi
	mov	DWORD PTR $T233333[esp+40], ecx
	mov	DWORD PTR tv448[esp+40], edi
	mov	DWORD PTR tv483[esp+40], edx
	jmp	SHORT $LN12@BuildTechD

; 1695 : 	{
; 1696 : 		PlayerTypes ePlayer1 = (PlayerTypes)uiPlayer1;
; 1697 : 		TeamTypes eTeam1 = GET_PLAYER(ePlayer1).getTeam();

$LN27@BuildTechD:

; 1698 : 
; 1699 : 		for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)

	xor	edi, edi
	mov	DWORD PTR $T233333[esp+40], -1
	mov	DWORD PTR tv448[esp+40], edi
	mov	DWORD PTR tv483[esp+40], edx
	jmp	SHORT $LN12@BuildTechD
	npad	2
$LL67@BuildTechD:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN12@BuildTechD:

; 1700 : 		{	
; 1701 : 			PlayerTypes ePlayer2 = (PlayerTypes)uiPlayer2;
; 1702 : 			TeamTypes eTeam2 = GET_PLAYER(ePlayer2).getTeam();

	mov	ecx, DWORD PTR [edi+eax+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN38@BuildTechD
	mov	esi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	esi, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+ecx*4]
	jmp	SHORT $LN39@BuildTechD
$LN38@BuildTechD:
	or	ebp, -1
$LN39@BuildTechD:

; 1703 : 
; 1704 : 			if (eTeam1 == eTeam2) 

	cmp	DWORD PTR $T233333[esp+40], ebp

; 1705 : 			{
; 1706 : 				m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;

	je	$LN6@BuildTechD

; 1707 : 			}
; 1708 : 			else if (!GET_PLAYER(ePlayer1).isAlive() || !GET_PLAYER(ePlayer2).isAlive())

	cmp	BYTE PTR [ebx+eax+2256], 0
	je	$LN6@BuildTechD
	cmp	BYTE PTR [edi+eax+2256], 0
	je	$LN6@BuildTechD

; 1711 : 			}
; 1712 : 			else
; 1713 : 			{
; 1714 : 				int iTechDifference = 0;

	xor	esi, esi

; 1715 : 				
; 1716 : 				CvPlayerTechs* pPlayerTechs = GET_PLAYER(ePlayer1).GetPlayerTechs();

	lea	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR _iTechDifference$220844[esp+40], esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs

; 1717 : #ifdef AUI_WARNING_FIXES
; 1718 : 				for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1719 : #else
; 1720 : 				for(int iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, eax
	mov	DWORD PTR _pPlayerTechs$220845[esp+40], eax
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN2@BuildTechD
	mov	edi, DWORD PTR $T233333[esp+40]
	imul	edi, 2984				; 00000ba8H
	imul	ebp, 2984				; 00000ba8H
	npad	7
$LL4@BuildTechD:

; 1721 : #endif
; 1722 : 				{
; 1723 : 					TechTypes eTech = (TechTypes)iTechLoop;
; 1724 : 					bool bPlayer1Knows = GET_TEAM(eTeam1).GetTeamTechs()->HasTech(eTech);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [edi+edx]
	push	esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	mov	bl, al

; 1725 : 					bool bPlayer2Knows = GET_TEAM(eTeam2).GetTeamTechs()->HasTech(eTech);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [eax+ebp]
	push	esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech

; 1726 : 					if (bPlayer2Knows && !bPlayer1Knows)

	test	al, al
	je	SHORT $LN3@BuildTechD
	test	bl, bl
	jne	SHORT $LN3@BuildTechD

; 1727 : 					{
; 1728 : 						iTechDifference++;

	inc	DWORD PTR _iTechDifference$220844[esp+40]
$LN3@BuildTechD:

; 1717 : #ifdef AUI_WARNING_FIXES
; 1718 : 				for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1719 : #else
; 1720 : 				for(int iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR _pPlayerTechs$220845[esp+40]
	inc	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL4@BuildTechD
	mov	edi, DWORD PTR tv448[esp+40]
	mov	ebx, DWORD PTR tv504[esp+40]
$LN2@BuildTechD:

; 1729 : 					}
; 1730 : 				}
; 1731 : 
; 1732 : 				m_aaiTechDifference[uiPlayer1][uiPlayer2] = iTechDifference;

	mov	ecx, DWORD PTR _iTechDifference$220844[esp+40]
	mov	edx, DWORD PTR tv483[esp+40]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN11@BuildTechD
$LN6@BuildTechD:

; 1709 : 			{
; 1710 : 				m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;

	mov	DWORD PTR [edx], 0
$LN11@BuildTechD:

; 1698 : 
; 1699 : 		for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)

	add	edi, 63236				; 0000f704H
	add	edx, 4
	mov	DWORD PTR tv483[esp+40], edx
	mov	DWORD PTR tv448[esp+40], edi
	cmp	edi, 1391192				; 00153a58H
	jb	$LL67@BuildTechD
	add	ebx, 63236				; 0000f704H
	mov	DWORD PTR tv504[esp+40], ebx
	cmp	ebx, 1391192				; 00153a58H
	jb	$LL69@BuildTechD
	pop	edi
	pop	ebp
	pop	ebx
$LN13@BuildTechD:
	pop	esi

; 1733 : 			}
; 1734 : 		}
; 1735 : 	}
; 1736 : #endif
; 1737 : }

	add	esp, 24					; 00000018H
	ret	0
?BuildTechDifference@CvGameTrade@@QAEXXZ ENDP		; CvGameTrade::BuildTechDifference
_TEXT	ENDS
PUBLIC	?CreateVis@CvGameTrade@@QAEXH@Z			; CvGameTrade::CreateVis
EXTRN	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z:PROC ; CvUnit::SetAutomateType
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
; Function compile flags: /Ogtpy
;	COMDAT ?CreateVis@CvGameTrade@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CreateVis@CvGameTrade@@QAEXH@Z PROC			; CvGameTrade::CreateVis, COMDAT
; _this$ = ecx

; 1868 : {

	push	esi

; 1869 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1870 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	mov	esi, DWORD PTR _iIndex$[esp]
	test	esi, esi
	jl	SHORT $LN4@CreateVis
	cmp	esi, DWORD PTR [ecx+4]
	jge	SHORT $LN4@CreateVis

; 1871 : 	{
; 1872 : 		return;
; 1873 : 	}
; 1874 : 
; 1875 : 	TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];

	imul	esi, 444				; 000001bcH
	add	esi, DWORD PTR [ecx]

; 1876 : 
; 1877 : 	if (kTradeConnection.m_unitID == -1)

	cmp	DWORD PTR [esi+380], -1
	jne	SHORT $LN4@CreateVis

; 1878 : 	{
; 1879 : 		UnitTypes eUnitType = CvPlayerTrade::GetTradeUnit(kTradeConnection.m_eDomain);

	mov	eax, DWORD PTR [esi+28]
	push	eax
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4

; 1880 : 		if (eUnitType != NO_UNIT)

	cmp	eax, -1
	je	SHORT $LN4@CreateVis

; 1881 : 		{
; 1882 : 			CvPlayer& kPlayer = GET_PLAYER(kTradeConnection.m_eOriginOwner);

	mov	ecx, DWORD PTR [esi+20]

; 1883 : 			CvUnit* pkUnit = kPlayer.initUnit(eUnitType, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iX, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iY, NO_UNITAI, NO_DIRECTION, false, true, TRADE_UNIT_MAP_LAYER);

	mov	edx, DWORD PTR [esi+36]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, DWORD PTR [esi+44]
	push	0
	push	1
	push	1
	push	0
	push	-1
	lea	edx, DWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx]
	push	-1
	push	edi
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	edi, eax

; 1884 : 			if (pkUnit)

	test	edi, edi
	je	SHORT $LN22@CreateVis

; 1885 : 			{
; 1886 : 				pkUnit->SetAutomateType(AUTOMATE_TRADE);

	push	1272735960				; 4bdc68d8H
	mov	ecx, edi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 1887 : 				kTradeConnection.m_unitID = pkUnit->GetID();

	mov	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+380], eax
$LN22@CreateVis:
	pop	edi
$LN4@CreateVis:
	pop	esi

; 1888 : 			}
; 1889 : 		}
; 1890 : 	}
; 1891 : }

	ret	4
?CreateVis@CvGameTrade@@QAEXH@Z ENDP			; CvGameTrade::CreateVis
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
EXTRN	?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@40000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
CONST	ENDS
;	COMDAT ?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_iCeilTechDifference$221190 = 12			; size = 4
_iCeilTechDifference$221181 = 12			; size = 4
_eYield$ = 12						; size = 4
tv282 = 16						; size = 4
tv262 = 16						; size = 4
tv256 = 16						; size = 4
$T233483 = 16						; size = 4
$T233488 = 16						; size = 4
$T233450 = 16						; size = 4
_iTechDifference$221187 = 16				; size = 4
$T233449 = 16						; size = 4
_iTechDifference$221178 = 16				; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100, COMDAT
; _this$ = ecx

; 2341 : 	if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp-4], 0
	je	$LN10@GetTradeCo@3

; 2342 : 	{
; 2343 : 		if (GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR _kTradeConnection$[esp]
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	je	$LN6@GetTradeCo@3

; 2344 : 		{
; 2345 : 			if (eYield == YIELD_GOLD)

	mov	eax, DWORD PTR _eYield$[esp]
	cmp	eax, 2
	jne	SHORT $LN8@GetTradeCo@3

; 2346 : 			{
; 2347 : 				int iResult = 0;
; 2348 : 				int iBase = GC.getINTERNATIONAL_TRADE_BASE();
; 2349 : 				iResult = iBase;
; 2350 : 				return iResult;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7956
	pop	esi

; 2391 : }

	ret	12					; 0000000cH
$LN8@GetTradeCo@3:

; 2351 : 			}
; 2352 : 			else if (eYield == YIELD_SCIENCE)

	cmp	eax, 3
	jne	$LN6@GetTradeCo@3

; 2353 : 			{
; 2354 : 				int iTechDifference = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eOriginOwner, kTradeConnection.m_eDestOwner);

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+20]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference

; 2355 : 				int iAdjustedTechDifference = 0;

	xor	edi, edi
	mov	DWORD PTR _iTechDifference$221178[esp+4], eax

; 2356 : 				if (iTechDifference > 0)

	test	eax, eax
	jle	SHORT $LN5@GetTradeCo@3

; 2357 : 				{
; 2358 : 					int iCeilTechDifference = (int)ceil(iTechDifference / 2.0f);

	fild	DWORD PTR _iTechDifference$221178[esp+4]
	push	ecx
	fdiv	DWORD PTR __real@40000000
	fstp	DWORD PTR tv282[esp+8]
	fld	DWORD PTR tv282[esp+8]
	fstp	DWORD PTR [esp]
	call	?ceil@@YAMM@Z				; ceil
	add	esp, 4
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iCeilTechDifference$221181[esp+4], eax

; 2359 : 					iAdjustedTechDifference = max(iCeilTechDifference, 1);

	cmp	eax, 1
	mov	DWORD PTR $T233449[esp+4], 1
	lea	eax, DWORD PTR $T233449[esp+4]
	jl	SHORT $LN22@GetTradeCo@3
	lea	eax, DWORD PTR _iCeilTechDifference$221181[esp+4]
$LN22@GetTradeCo@3:
	mov	edi, DWORD PTR [eax]
$LN5@GetTradeCo@3:

; 2360 : 				}
; 2361 : 
; 2362 : 				// Cultural influence bump
; 2363 : 				int iInfluenceBoost = GET_PLAYER(kTradeConnection.m_eOriginOwner).GetCulture()->GetInfluenceTradeRouteScienceBonus(kTradeConnection.m_eDestOwner);

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus

; 2364 : 				iAdjustedTechDifference += iInfluenceBoost;
; 2365 : 
; 2366 : 				return iAdjustedTechDifference * 100;

	add	eax, edi
	pop	edi
	imul	eax, 100				; 00000064H
	pop	esi

; 2391 : }

	ret	12					; 0000000cH
$LN6@GetTradeCo@3:

; 2387 : 		}
; 2388 : 	}
; 2389 : 
; 2390 : 	return 0;

	xor	eax, eax
	pop	esi

; 2391 : }

	ret	12					; 0000000cH
$LN10@GetTradeCo@3:

; 2367 : 			}
; 2368 : 		}
; 2369 : 	}
; 2370 : 	else
; 2371 : 	{
; 2372 : 		if (eYield == YIELD_SCIENCE)

	cmp	DWORD PTR _eYield$[esp-4], 3
	jne	$LN3@GetTradeCo@3

; 2373 : 		{
; 2374 : 			int iTechDifference = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eDestOwner, kTradeConnection.m_eOriginOwner);

	mov	eax, DWORD PTR _kTradeConnection$[esp-4]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edx
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference

; 2375 : 			int iAdjustedTechDifference = 0;

	xor	ecx, ecx
	mov	DWORD PTR _iTechDifference$221187[esp-4], eax

; 2376 : 			if (iTechDifference > 0)

	test	eax, eax
	jle	SHORT $LN2@GetTradeCo@3

; 2377 : 			{
; 2378 : 				int iCeilTechDifference = (int)ceil(iTechDifference / 2.0f);

	fild	DWORD PTR _iTechDifference$221187[esp-4]
	sub	esp, 8
	fdiv	DWORD PTR __real@40000000
	fstp	DWORD PTR tv262[esp+4]
	fld	DWORD PTR tv262[esp+4]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv256[esp+4]
	fld	DWORD PTR tv256[esp+4]
	add	esp, 8
	fstp	DWORD PTR $T233483[esp-4]
	mov	eax, DWORD PTR $T233483[esp-4]
	mov	DWORD PTR $T233488[esp-4], eax
	fld	DWORD PTR $T233488[esp-4]
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iCeilTechDifference$221190[esp-4], eax

; 2379 : 				iAdjustedTechDifference = max(iCeilTechDifference, 1);

	cmp	eax, 1
	mov	DWORD PTR $T233450[esp-4], 1
	lea	eax, DWORD PTR $T233450[esp-4]
	jl	SHORT $LN34@GetTradeCo@3
	lea	eax, DWORD PTR _iCeilTechDifference$221190[esp-4]
$LN34@GetTradeCo@3:
	mov	ecx, DWORD PTR [eax]
$LN2@GetTradeCo@3:

; 2380 : 			}
; 2381 : 
; 2382 : 			return  iAdjustedTechDifference * 100;

	mov	eax, ecx
	imul	eax, 100				; 00000064H

; 2391 : }

	ret	12					; 0000000cH
$LN3@GetTradeCo@3:

; 2383 : 		}
; 2384 : 		else
; 2385 : 		{
; 2386 : 			return 100;

	mov	eax, 100				; 00000064H

; 2391 : }

	ret	12					; 0000000cH
?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
_bOriginCity$ = 20					; size = 1
?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z PROC ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100, COMDAT
; _this$ = ecx

; 2400 : 	if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp-4], 0
	je	$LN9@GetTradeCo@4

; 2401 : 	{
; 2402 : 		if (GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR _kTradeConnection$[esp]
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	je	$LN7@GetTradeCo@4

; 2403 : 		{
; 2404 : 			if (eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[esp], 2
	jne	$LN7@GetTradeCo@4

; 2405 : 			{
; 2406 : 				int iX, iY;
; 2407 : 				if (bOriginCity)

	cmp	BYTE PTR _bOriginCity$[esp], 0
	push	ebx
	je	SHORT $LN6@GetTradeCo@4

; 2408 : 				{
; 2409 : 					iX = kTradeConnection.m_iOriginX;

	mov	eax, DWORD PTR [esi+4]

; 2410 : 					iY = kTradeConnection.m_iOriginY;

	mov	ebx, DWORD PTR [esi+8]

; 2411 : 				}
; 2412 : 				else

	jmp	SHORT $LN5@GetTradeCo@4
$LN6@GetTradeCo@4:

; 2413 : 				{
; 2414 : 					iX = kTradeConnection.m_iDestX;

	mov	eax, DWORD PTR [esi+12]

; 2415 : 					iY = kTradeConnection.m_iDestY;

	mov	ebx, DWORD PTR [esi+16]
$LN5@GetTradeCo@4:
	push	ebp
	push	edi

; 2416 : 				}
; 2417 : 
; 2418 : 				CvPlot* pPlot = GC.getMap().plot(iX, iY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN57@GetTradeCo@4
	cmp	ebx, -2147483647			; 80000001H
	je	$LN57@GetTradeCo@4
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN58@GetTradeCo@4
	test	eax, eax
	jge	SHORT $LN28@GetTradeCo@4
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN30@GetTradeCo@4
$LN28@GetTradeCo@4:
	cmp	eax, ecx
	jl	SHORT $LN58@GetTradeCo@4
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN30@GetTradeCo@4
$LN58@GetTradeCo@4:
	mov	esi, eax
$LN30@GetTradeCo@4:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN59@GetTradeCo@4
	test	ebx, ebx
	jge	SHORT $LN38@GetTradeCo@4
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN40@GetTradeCo@4
$LN38@GetTradeCo@4:
	cmp	ebx, edi
	jl	SHORT $LN59@GetTradeCo@4
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN40@GetTradeCo@4
$LN59@GetTradeCo@4:
	mov	edx, ebx
$LN40@GetTradeCo@4:
	test	esi, esi
	jl	SHORT $LN57@GetTradeCo@4
	cmp	esi, ecx
	jge	SHORT $LN57@GetTradeCo@4
	test	edx, edx
	jl	SHORT $LN57@GetTradeCo@4
	cmp	edx, edi
	jge	SHORT $LN57@GetTradeCo@4
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 2419 : 
; 2420 : 				CvAssertMsg(pPlot, "CvPlayerTrade - plot is null");
; 2421 : 				if (!pPlot)

	test	ecx, ecx

; 2422 : 				{
; 2423 : 					return 0;

	je	SHORT $LN57@GetTradeCo@4

; 2424 : 				}
; 2425 : 
; 2426 : 				CvCity* pCity = pPlot->getPlotCity();

	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 2427 : 				CvAssertMsg(pCity, "CvPlayerTrade - pCity is null");	
; 2428 : 				if (!pCity)

	test	eax, eax
	jne	SHORT $LN3@GetTradeCo@4
$LN57@GetTradeCo@4:
	pop	edi
	pop	ebp
	pop	ebx

; 2429 : 				{
; 2430 : 					return 0;

	xor	eax, eax
	pop	esi

; 2448 : }

	ret	16					; 00000010H
$LN3@GetTradeCo@4:

; 2431 : 				}
; 2432 : 
; 2433 : 				int iDivisor = GC.getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7964

; 2434 : 				if (iDivisor == 0)

	test	esi, esi
	jne	SHORT $LN2@GetTradeCo@4

; 2435 : 				{
; 2436 : 					iDivisor = 1;

	mov	esi, 1
$LN2@GetTradeCo@4:

; 2437 : 				}
; 2438 : 				return pCity->getYieldRateTimes100(eYield, true) / iDivisor;

	push	1
	push	2
	mov	ecx, eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	pop	edi
	pop	ebp
	cdq
	pop	ebx
	idiv	esi
	pop	esi

; 2448 : }

	ret	16					; 00000010H
$LN7@GetTradeCo@4:

; 2445 : 	}
; 2446 : 
; 2447 : 	return 0;

	xor	eax, eax
	pop	esi

; 2448 : }

	ret	16					; 00000010H
$LN9@GetTradeCo@4:

; 2439 : 			}
; 2440 : 		}
; 2441 : 	}
; 2442 : 	else
; 2443 : 	{
; 2444 : 		return 0;

	xor	eax, eax

; 2448 : }

	ret	16					; 00000010H
?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ENDP ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100
EXTRN	?IsHasResourceLocal@CvCity@@QBE_NW4ResourceTypes@@_N@Z:PROC ; CvCity::IsHasResourceLocal
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_pDestCity$221229 = 12					; size = 4
_eYield$ = 12						; size = 4
_iValue$221232 = 16					; size = 4
_pOriginPlot$221224 = 16				; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100, COMDAT
; _this$ = ecx

; 2457 : 	if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp-4], 0
	je	$LN15@GetTradeCo@5

; 2458 : 	{
; 2459 : 		if (GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR _kTradeConnection$[esp]
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	je	$LN13@GetTradeCo@5

; 2460 : 		{
; 2461 : 			if (eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[esp], 2
	jne	$LN13@GetTradeCo@5

; 2462 : 			{
; 2463 : 				CvPlot* pOriginPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [esi+8]
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN22@GetTradeCo@5
	cmp	ebx, -2147483647			; 80000001H
	je	$LN22@GetTradeCo@5
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN109@GetTradeCo@5
	test	eax, eax
	jge	SHORT $LN34@GetTradeCo@5
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN36@GetTradeCo@5
$LN34@GetTradeCo@5:
	cmp	eax, ecx
	jl	SHORT $LN109@GetTradeCo@5
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN36@GetTradeCo@5
$LN109@GetTradeCo@5:
	mov	esi, eax
$LN36@GetTradeCo@5:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN112@GetTradeCo@5
	test	ebx, ebx
	jge	SHORT $LN44@GetTradeCo@5
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN46@GetTradeCo@5
$LN44@GetTradeCo@5:
	cmp	ebx, edi
	jl	SHORT $LN112@GetTradeCo@5
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN46@GetTradeCo@5
$LN112@GetTradeCo@5:
	mov	edx, ebx
$LN46@GetTradeCo@5:
	test	esi, esi
	jl	SHORT $LN26@GetTradeCo@5
	cmp	esi, ecx
	jge	SHORT $LN26@GetTradeCo@5
	test	edx, edx
	jl	SHORT $LN26@GetTradeCo@5
	cmp	edx, edi
	jge	SHORT $LN26@GetTradeCo@5
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	DWORD PTR _pOriginPlot$221224[esp+12], ecx
	jmp	SHORT $LN24@GetTradeCo@5
$LN26@GetTradeCo@5:
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
$LN22@GetTradeCo@5:
	mov	DWORD PTR _pOriginPlot$221224[esp+12], 0
$LN24@GetTradeCo@5:

; 2464 : 				CvPlot* pDestPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN62@GetTradeCo@5
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN62@GetTradeCo@5
	cmp	BYTE PTR [ebp+4056], 0
	mov	esi, DWORD PTR [ebp+4020]
	je	SHORT $LN72@GetTradeCo@5
	test	eax, eax
	jge	SHORT $LN74@GetTradeCo@5
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN76@GetTradeCo@5
$LN74@GetTradeCo@5:
	cmp	eax, esi
	jl	SHORT $LN72@GetTradeCo@5
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN76@GetTradeCo@5
$LN72@GetTradeCo@5:
	mov	edi, eax
$LN76@GetTradeCo@5:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN113@GetTradeCo@5
	test	ecx, ecx
	jge	SHORT $LN84@GetTradeCo@5
	mov	eax, ecx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN86@GetTradeCo@5
$LN84@GetTradeCo@5:
	cmp	ecx, ebx
	jl	SHORT $LN113@GetTradeCo@5
	mov	eax, ecx
	cdq
	idiv	ebx
	jmp	SHORT $LN86@GetTradeCo@5
$LN113@GetTradeCo@5:
	mov	edx, ecx
$LN86@GetTradeCo@5:
	test	edi, edi
	jl	SHORT $LN62@GetTradeCo@5
	cmp	edi, esi
	jge	SHORT $LN62@GetTradeCo@5
	test	edx, edx
	jl	SHORT $LN62@GetTradeCo@5
	cmp	edx, ebx
	jge	SHORT $LN62@GetTradeCo@5
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ebp+4068]
	jmp	SHORT $LN64@GetTradeCo@5
$LN62@GetTradeCo@5:
	xor	esi, esi
$LN64@GetTradeCo@5:

; 2465 : 
; 2466 : 				CvAssertMsg(pOriginPlot && pDestPlot, "pOriginPlot or pDestPlot are null");
; 2467 : 				if (!pOriginPlot || !pDestPlot)

	mov	ecx, DWORD PTR _pOriginPlot$221224[esp+12]
	test	ecx, ecx
	je	$LN11@GetTradeCo@5
	test	esi, esi
	je	$LN11@GetTradeCo@5

; 2470 : 				}
; 2471 : 
; 2472 : 				CvCity* pOriginCity = pOriginPlot->getPlotCity();

	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 2473 : 				CvCity* pDestCity = pDestPlot->getPlotCity();

	mov	ecx, esi
	mov	ebp, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 2474 : 
; 2475 : 				CvAssertMsg(pOriginCity && pDestCity, "pOriginCity or pDestCity are null");
; 2476 : 				if (!pOriginCity || !pDestCity)

	xor	esi, esi
	mov	ebx, eax
	mov	DWORD PTR _pDestCity$221229[esp+12], ebx
	cmp	ebp, esi
	je	$LN11@GetTradeCo@5
	cmp	ebx, esi
	je	$LN11@GetTradeCo@5

; 2477 : 				{
; 2478 : 					return 0;
; 2479 : 				}
; 2480 : 
; 2481 : 				int iValue = 0;
; 2482 : #ifdef AUI_WARNING_FIXES
; 2483 : 				for (uint i = 0; i < GC.getNumResourceInfos(); i++)
; 2484 : #else
; 2485 : 				for(int i = 0; i < GC.getNumResourceInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iValue$221232[esp+12], esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN6@GetTradeCo@5
	jmp	SHORT $LN8@GetTradeCo@5
	npad	1
$LL114@GetTradeCo@5:
	mov	ebx, DWORD PTR _pDestCity$221229[esp+12]
$LN8@GetTradeCo@5:

; 2486 : #endif
; 2487 : 				{
; 2488 : 					ResourceTypes eResource = (ResourceTypes)i;
; 2489 : 					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	edi, eax

; 2490 : 					if (pkResourceInfo)

	test	edi, edi
	je	SHORT $LN7@GetTradeCo@5

; 2491 : 					{
; 2492 : 						if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY || pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ecx, edi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	je	SHORT $LN110@GetTradeCo@5
	mov	ecx, edi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN7@GetTradeCo@5
$LN110@GetTradeCo@5:

; 2493 : 						{
; 2494 : 							if (pOriginCity->IsHasResourceLocal(eResource, false) != pDestCity->IsHasResourceLocal(eResource, false))

	push	0
	push	esi
	mov	ecx, ebx
	call	?IsHasResourceLocal@CvCity@@QBE_NW4ResourceTypes@@_N@Z ; CvCity::IsHasResourceLocal
	push	0
	push	esi
	mov	ecx, ebp
	mov	bl, al
	call	?IsHasResourceLocal@CvCity@@QBE_NW4ResourceTypes@@_N@Z ; CvCity::IsHasResourceLocal
	cmp	al, bl
	je	SHORT $LN7@GetTradeCo@5

; 2495 : 							{
; 2496 : 								iValue += 50;

	add	DWORD PTR _iValue$221232[esp+12], 50	; 00000032H
$LN7@GetTradeCo@5:

; 2477 : 				{
; 2478 : 					return 0;
; 2479 : 				}
; 2480 : 
; 2481 : 				int iValue = 0;
; 2482 : #ifdef AUI_WARNING_FIXES
; 2483 : 				for (uint i = 0; i < GC.getNumResourceInfos(); i++)
; 2484 : #else
; 2485 : 				for(int i = 0; i < GC.getNumResourceInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL114@GetTradeCo@5
$LN6@GetTradeCo@5:

; 2497 : 							}
; 2498 : 						}
; 2499 : 					}
; 2500 : 				}
; 2501 : 
; 2502 : 				int iModifer = 100 + GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerTraits()->GetTradeRouteResourceModifier();

	mov	eax, DWORD PTR _kTradeConnection$[esp+12]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, 100				; 00000064H

; 2503 : 				iValue *= iModifer;

	imul	ecx, DWORD PTR _iValue$221232[esp+12]

; 2504 : 				iValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebx
	add	eax, edx
	pop	esi

; 2516 : }

	ret	12					; 0000000cH
$LN11@GetTradeCo@5:
	pop	edi
	pop	ebp
	pop	ebx

; 2468 : 				{
; 2469 : 					return 0;

	xor	eax, eax
	pop	esi

; 2516 : }

	ret	12					; 0000000cH
$LN13@GetTradeCo@5:

; 2513 : 	}
; 2514 : 
; 2515 : 	return 0;

	xor	eax, eax
	pop	esi

; 2516 : }

	ret	12					; 0000000cH
$LN15@GetTradeCo@5:

; 2505 : 
; 2506 : 				return iValue;
; 2507 : 			}
; 2508 : 		}
; 2509 : 	}
; 2510 : 	else
; 2511 : 	{
; 2512 : 		return 0;	

	xor	eax, eax

; 2516 : }

	ret	12					; 0000000cH
?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
EXTRN	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteLandGoldBonus
EXTRN	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_pOriginPlot$ = 12					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100, COMDAT
; _this$ = ecx

; 2525 : 	// this only applies to international trade routes, so otherwise, buzz off!
; 2526 : 	if (!GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR _kTradeConnection$[esp]
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	jne	SHORT $LN17@GetTradeCo@6
$LN132@GetTradeCo@6:

; 2527 : 	{
; 2528 : 		return 0;

	xor	eax, eax
	pop	esi

; 2593 : 		iBonus /= 100;
; 2594 : 	}	
; 2595 : 
; 2596 : 	return iBonus;
; 2597 : }

	ret	12					; 0000000cH
$LN17@GetTradeCo@6:

; 2529 : 	}
; 2530 : 	
; 2531 : 	if (eYield != YIELD_GOLD)

	cmp	DWORD PTR _eYield$[esp], 2

; 2532 : 	{
; 2533 : 		return 0;

	jne	SHORT $LN132@GetTradeCo@6

; 2534 : 	}
; 2535 : 
; 2536 : 	CvPlot* pOriginPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [esi+8]
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN24@GetTradeCo@6
	cmp	ebx, -2147483647			; 80000001H
	je	$LN24@GetTradeCo@6
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN123@GetTradeCo@6
	test	eax, eax
	jge	SHORT $LN36@GetTradeCo@6
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN38@GetTradeCo@6
$LN36@GetTradeCo@6:
	cmp	eax, ecx
	jl	SHORT $LN123@GetTradeCo@6
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN38@GetTradeCo@6
$LN123@GetTradeCo@6:
	mov	esi, eax
$LN38@GetTradeCo@6:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN124@GetTradeCo@6
	test	ebx, ebx
	jge	SHORT $LN46@GetTradeCo@6
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN48@GetTradeCo@6
$LN46@GetTradeCo@6:
	cmp	ebx, edi
	jl	SHORT $LN124@GetTradeCo@6
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN48@GetTradeCo@6
$LN124@GetTradeCo@6:
	mov	edx, ebx
$LN48@GetTradeCo@6:
	test	esi, esi
	jl	SHORT $LN28@GetTradeCo@6
	cmp	esi, ecx
	jge	SHORT $LN28@GetTradeCo@6
	test	edx, edx
	jl	SHORT $LN28@GetTradeCo@6
	cmp	edx, edi
	jge	SHORT $LN28@GetTradeCo@6
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	DWORD PTR _pOriginPlot$[esp+12], ecx
	jmp	SHORT $LN26@GetTradeCo@6
$LN28@GetTradeCo@6:
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
$LN24@GetTradeCo@6:
	mov	DWORD PTR _pOriginPlot$[esp+12], 0
$LN26@GetTradeCo@6:

; 2537 : 	CvPlot* pDestPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	eax, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi+16]
	cmp	eax, -2147483647			; 80000001H
	je	$LN64@GetTradeCo@6
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN64@GetTradeCo@6
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN74@GetTradeCo@6
	test	eax, eax
	jge	SHORT $LN76@GetTradeCo@6
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN78@GetTradeCo@6
$LN76@GetTradeCo@6:
	cmp	eax, ecx
	jl	SHORT $LN74@GetTradeCo@6
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN78@GetTradeCo@6
$LN74@GetTradeCo@6:
	mov	esi, eax
$LN78@GetTradeCo@6:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN125@GetTradeCo@6
	test	ebx, ebx
	jge	SHORT $LN86@GetTradeCo@6
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN88@GetTradeCo@6
$LN86@GetTradeCo@6:
	cmp	ebx, edi
	jl	SHORT $LN125@GetTradeCo@6
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN88@GetTradeCo@6
$LN125@GetTradeCo@6:
	mov	edx, ebx
$LN88@GetTradeCo@6:
	test	esi, esi
	jl	SHORT $LN68@GetTradeCo@6
	cmp	esi, ecx
	jge	SHORT $LN68@GetTradeCo@6
	test	edx, edx
	jl	SHORT $LN68@GetTradeCo@6
	cmp	edx, edi
	jge	SHORT $LN68@GetTradeCo@6
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	jmp	SHORT $LN66@GetTradeCo@6
$LN68@GetTradeCo@6:
	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
$LN64@GetTradeCo@6:
	xor	ecx, ecx
$LN66@GetTradeCo@6:

; 2538 : 
; 2539 : 	CvAssertMsg(pOriginPlot && pDestPlot, "pOriginPlot or pDestPlot are null");
; 2540 : 	if (!pOriginPlot || !pDestPlot)

	cmp	DWORD PTR _pOriginPlot$[esp+12], 0
	je	$LN14@GetTradeCo@6
	test	ecx, ecx
	je	$LN14@GetTradeCo@6

; 2541 : 	{
; 2542 : 		return 0;
; 2543 : 	}
; 2544 : 
; 2545 : 	CvCity* pDestCity = pDestPlot->getPlotCity();

	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 2546 : 	if (!pDestCity)

	test	eax, eax

; 2547 : 	{
; 2548 : 		return 0;

	je	$LN14@GetTradeCo@6

; 2549 : 	}
; 2550 : 
; 2551 : 	int iBonus = 0;

	xor	ebp, ebp

; 2552 : 	if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp+12], 0
	je	$LN2@GetTradeCo@6

; 2553 : 	{
; 2554 : 		CvCity* pOriginCity = CvGameTrade::GetOriginCity(kTradeConnection);

	push	esi
	call	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
	add	esp, 4

; 2555 : #ifdef AUI_WARNING_FIXES
; 2556 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 2557 : #else
; 2558 : 		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN9@GetTradeCo@6
	npad	4
$LL11@GetTradeCo@6:

; 2559 : #endif
; 2560 : 		{
; 2561 : 			BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 2562 : 			if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN10@GetTradeCo@6

; 2563 : 			{
; 2564 : 				CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	esi, eax

; 2565 : 				if (!pBuildingEntry)

	test	esi, esi
	je	SHORT $LN10@GetTradeCo@6

; 2566 : 				{
; 2567 : 					continue;
; 2568 : 				}
; 2569 : 
; 2570 : 				if (pBuildingEntry && pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()))

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN10@GetTradeCo@6

; 2571 : 				{
; 2572 : 					if (pBuildingEntry->GetTradeRouteSeaGoldBonus() > 0 && kTradeConnection.m_eDomain == DOMAIN_SEA)

	mov	ecx, esi
	call	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
	test	eax, eax
	jle	SHORT $LN126@GetTradeCo@6
	mov	eax, DWORD PTR _kTradeConnection$[esp+12]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN126@GetTradeCo@6

; 2573 : 					{
; 2574 : 						iBonus += pBuildingEntry->GetTradeRouteSeaGoldBonus();

	mov	ecx, esi
	call	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
	jmp	SHORT $LN131@GetTradeCo@6
$LN126@GetTradeCo@6:

; 2575 : 					}
; 2576 : 					else if (pBuildingEntry->GetTradeRouteLandGoldBonus() > 0 && kTradeConnection.m_eDomain == DOMAIN_LAND)

	mov	ecx, esi
	call	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandGoldBonus
	test	eax, eax
	jle	SHORT $LN10@GetTradeCo@6
	mov	ecx, DWORD PTR _kTradeConnection$[esp+12]
	cmp	DWORD PTR [ecx+28], 2
	jne	SHORT $LN10@GetTradeCo@6

; 2577 : 					{
; 2578 : 						iBonus += pBuildingEntry->GetTradeRouteLandGoldBonus();

	mov	ecx, esi
	call	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandGoldBonus
$LN131@GetTradeCo@6:
	add	ebp, eax
$LN10@GetTradeCo@6:

; 2555 : #ifdef AUI_WARNING_FIXES
; 2556 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 2557 : #else
; 2558 : 		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	$LL11@GetTradeCo@6
$LN9@GetTradeCo@6:

; 2579 : 					}
; 2580 : 				}
; 2581 : 			}
; 2582 : 		}
; 2583 : 	}
; 2584 : 
; 2585 : 	if (bAsOriginPlayer)
; 2586 : 	{
; 2587 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	edx, DWORD PTR _kTradeConnection$[esp+12]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [eax+328]
	add	ecx, 100				; 00000064H
	imul	ecx, ebp

; 2588 : 		iBonus /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebx
	add	eax, edx
	pop	esi

; 2593 : 		iBonus /= 100;
; 2594 : 	}	
; 2595 : 
; 2596 : 	return iBonus;
; 2597 : }

	ret	12					; 0000000cH
$LN2@GetTradeCo@6:

; 2589 : 	}
; 2590 : 	else
; 2591 : 	{
; 2592 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	ecx, DWORD PTR [esi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
$LN14@GetTradeCo@6:
	pop	edi
	pop	ebp
	pop	ebx
	xor	eax, eax
	pop	esi

; 2593 : 		iBonus /= 100;
; 2594 : 	}	
; 2595 : 
; 2596 : 	return iBonus;
; 2597 : }

	ret	12					; 0000000cH
?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
EXTRN	?GetTradeRouteRecipientBonus@CvCity@@QBEHXZ:PROC ; CvCity::GetTradeRouteRecipientBonus
EXTRN	?GetTradeRouteTargetBonus@CvCity@@QBEHXZ:PROC	; CvCity::GetTradeRouteTargetBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_pOriginPlot$ = 12					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100, COMDAT
; _this$ = ecx

; 2605 : {

	push	ecx
	push	esi

; 2606 : 	// this only applies to international trade routes, so otherwise, buzz off!
; 2607 : 	if (!GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	esi, DWORD PTR _kTradeConnection$[esp+4]
	mov	DWORD PTR _this$[esp+8], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	jne	SHORT $LN10@GetTradeCo@7
$LN124@GetTradeCo@7:

; 2608 : 	{
; 2609 : 		return 0;

	xor	eax, eax
	pop	esi

; 2657 : 	}	
; 2658 : 
; 2659 : 	return iBonus;
; 2660 : }

	pop	ecx
	ret	12					; 0000000cH
$LN10@GetTradeCo@7:

; 2610 : 	}
; 2611 : 
; 2612 : 	if (eYield != YIELD_GOLD)

	cmp	DWORD PTR _eYield$[esp+4], 2

; 2613 : 	{
; 2614 : 		return 0;

	jne	SHORT $LN124@GetTradeCo@7

; 2615 : 	}
; 2616 : 
; 2617 : 	CvPlot* pOriginPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [esi+8]
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN17@GetTradeCo@7
	cmp	ebx, -2147483647			; 80000001H
	je	$LN17@GetTradeCo@7
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN117@GetTradeCo@7
	test	eax, eax
	jge	SHORT $LN29@GetTradeCo@7
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN31@GetTradeCo@7
$LN29@GetTradeCo@7:
	cmp	eax, ecx
	jl	SHORT $LN117@GetTradeCo@7
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN31@GetTradeCo@7
$LN117@GetTradeCo@7:
	mov	esi, eax
$LN31@GetTradeCo@7:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN118@GetTradeCo@7
	test	ebx, ebx
	jge	SHORT $LN39@GetTradeCo@7
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN41@GetTradeCo@7
$LN39@GetTradeCo@7:
	cmp	ebx, edi
	jl	SHORT $LN118@GetTradeCo@7
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN41@GetTradeCo@7
$LN118@GetTradeCo@7:
	mov	edx, ebx
$LN41@GetTradeCo@7:
	test	esi, esi
	jl	SHORT $LN21@GetTradeCo@7
	cmp	esi, ecx
	jge	SHORT $LN21@GetTradeCo@7
	test	edx, edx
	jl	SHORT $LN21@GetTradeCo@7
	cmp	edx, edi
	jge	SHORT $LN21@GetTradeCo@7
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR _kTradeConnection$[esp+16]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	DWORD PTR _pOriginPlot$[esp+16], ecx
	jmp	SHORT $LN19@GetTradeCo@7
$LN21@GetTradeCo@7:
	mov	esi, DWORD PTR _kTradeConnection$[esp+16]
$LN17@GetTradeCo@7:
	mov	DWORD PTR _pOriginPlot$[esp+16], 0
$LN19@GetTradeCo@7:

; 2618 : 	CvPlot* pDestPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	eax, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi+16]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN57@GetTradeCo@7
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN57@GetTradeCo@7
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN67@GetTradeCo@7
	test	eax, eax
	jge	SHORT $LN69@GetTradeCo@7
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN71@GetTradeCo@7
$LN69@GetTradeCo@7:
	cmp	eax, ecx
	jl	SHORT $LN67@GetTradeCo@7
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN71@GetTradeCo@7
$LN67@GetTradeCo@7:
	mov	esi, eax
$LN71@GetTradeCo@7:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN119@GetTradeCo@7
	test	ebx, ebx
	jge	SHORT $LN79@GetTradeCo@7
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN81@GetTradeCo@7
$LN79@GetTradeCo@7:
	cmp	ebx, edi
	jl	SHORT $LN119@GetTradeCo@7
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN81@GetTradeCo@7
$LN119@GetTradeCo@7:
	mov	edx, ebx
$LN81@GetTradeCo@7:
	test	esi, esi
	jl	SHORT $LN57@GetTradeCo@7
	cmp	esi, ecx
	jge	SHORT $LN57@GetTradeCo@7
	test	edx, edx
	jl	SHORT $LN57@GetTradeCo@7
	cmp	edx, edi
	jge	SHORT $LN57@GetTradeCo@7
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	jmp	SHORT $LN59@GetTradeCo@7
$LN57@GetTradeCo@7:
	xor	ecx, ecx
$LN59@GetTradeCo@7:

; 2619 : 
; 2620 : 	CvAssertMsg(pOriginPlot && pDestPlot, "pOriginPlot or pDestPlot are null");
; 2621 : 	if (!pOriginPlot || !pDestPlot)

	cmp	DWORD PTR _pOriginPlot$[esp+16], 0
	je	$LN7@GetTradeCo@7
	test	ecx, ecx
	je	$LN7@GetTradeCo@7

; 2624 : 	}
; 2625 : 
; 2626 : 	CvCity* pDestCity = pDestPlot->getPlotCity();

	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	edi, eax

; 2627 : 	if (!pDestCity)

	test	edi, edi

; 2628 : 	{
; 2629 : 		return 0;

	je	$LN7@GetTradeCo@7

; 2630 : 	}
; 2631 : 
; 2632 : 	int iBonus = 0;
; 2633 : 
; 2634 : 	// minor civs should not get bonuses for others trading with them
; 2635 : 	if (!GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv() && !GET_PLAYER(kTradeConnection.m_eOriginOwner).isMinorCiv())

	mov	ebx, DWORD PTR _kTradeConnection$[esp+16]
	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	esi, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN3@GetTradeCo@7
	mov	ecx, DWORD PTR [ebx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN3@GetTradeCo@7

; 2636 : 	{
; 2637 : 		if (kTradeConnection.m_eOriginOwner == m_pPlayer->GetID())

	mov	ebp, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [ebp+79104]
	mov	ecx, DWORD PTR [ebx+20]
	cmp	ecx, DWORD PTR [eax+44]
	jne	SHORT $LN4@GetTradeCo@7

; 2638 : 		{
; 2639 : 			iBonus += pDestCity->GetTradeRouteTargetBonus() * 100;

	mov	ecx, edi
	call	?GetTradeRouteTargetBonus@CvCity@@QBEHXZ ; CvCity::GetTradeRouteTargetBonus
	mov	esi, eax
	imul	esi, 100				; 00000064H
$LN4@GetTradeCo@7:

; 2640 : 		}
; 2641 : 
; 2642 : 		if (kTradeConnection.m_eDestOwner == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp+79104]
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, DWORD PTR [edx+44]
	jne	SHORT $LN3@GetTradeCo@7

; 2643 : 		{
; 2644 : 			iBonus += pDestCity->GetTradeRouteRecipientBonus() * 100;

	mov	ecx, edi
	call	?GetTradeRouteRecipientBonus@CvCity@@QBEHXZ ; CvCity::GetTradeRouteRecipientBonus
	imul	eax, 100				; 00000064H
	add	esi, eax
$LN3@GetTradeCo@7:

; 2645 : 		}
; 2646 : 	}
; 2647 : 
; 2648 : 	if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp+16], 0
	je	SHORT $LN2@GetTradeCo@7

; 2649 : 	{
; 2650 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	ecx, DWORD PTR [ebx+20]

; 2651 : 		iBonus /= 100;
; 2652 : 	}
; 2653 : 	else

	jmp	SHORT $LN123@GetTradeCo@7
$LN2@GetTradeCo@7:

; 2654 : 	{
; 2655 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	ecx, DWORD PTR [ebx+24]
$LN123@GetTradeCo@7:
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [eax+328]
	add	ecx, 100				; 00000064H
	imul	ecx, esi

; 2656 : 		iBonus /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebx
	add	eax, edx
	pop	esi

; 2657 : 	}	
; 2658 : 
; 2659 : 	return iBonus;
; 2660 : }

	pop	ecx
	ret	12					; 0000000cH
$LN7@GetTradeCo@7:
	pop	edi
	pop	ebp
	pop	ebx

; 2622 : 	{
; 2623 : 		return 0;

	xor	eax, eax
	pop	esi

; 2657 : 	}	
; 2658 : 
; 2659 : 	return iBonus;
; 2660 : }

	pop	ecx
	ret	12					; 0000000cH
?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100, COMDAT
; _this$ = ecx

; 2795 : {

	push	esi

; 2796 : 	// unnecessary code to make it compile for now
; 2797 : 	if (eYield != NO_YIELD)
; 2798 : 	{
; 2799 : 		eYield = eYield;
; 2800 : 	}
; 2801 : 
; 2802 : 	int iModifier = 0;
; 2803 : 	if (eYield == YIELD_GOLD && kTradeConnection.m_eDomain == DOMAIN_LAND)

	mov	ecx, 2
	xor	esi, esi
	cmp	DWORD PTR _eYield$[esp], ecx
	jne	SHORT $LN20@GetTradeCo@8
	mov	eax, DWORD PTR _kTradeConnection$[esp]
	cmp	DWORD PTR [eax+28], ecx
	jne	SHORT $LN20@GetTradeCo@8

; 2804 : 	{
; 2805 : 		if (bAsOriginPlayer)

	cmp	BYTE PTR _bAsOriginPlayer$[esp], 0

; 2806 : 		{
; 2807 : 			CvCity* pOriginCity = CvGameTrade::GetOriginCity(kTradeConnection);

	push	eax
	je	SHORT $LN6@GetTradeCo@8
	call	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
	add	esp, 4

; 2808 : 			CvAssert(pOriginCity != NULL);
; 2809 : 			if (pOriginCity)

	test	eax, eax
	je	SHORT $LN20@GetTradeCo@8

; 2810 : 			{
; 2811 : 				CvPlot* pOriginCityPlot = pOriginCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 2812 : 				if (pOriginCityPlot->isRiver())

	cmp	BYTE PTR [eax+457], 0
	jle	SHORT $LN20@GetTradeCo@8

; 2813 : 				{
; 2814 : 					iModifier = 25;

	lea	eax, DWORD PTR [esi+25]
	pop	esi

; 2834 : }

	ret	12					; 0000000cH
$LN6@GetTradeCo@8:

; 2815 : 				}
; 2816 : 			}
; 2817 : 		}
; 2818 : 		else
; 2819 : 		{
; 2820 : 			CvCity* pDestCity = CvGameTrade::GetDestCity(kTradeConnection);

	call	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
	add	esp, 4

; 2821 : 			CvAssert(pDestCity != NULL);
; 2822 : 			if (pDestCity)

	test	eax, eax
	je	SHORT $LN20@GetTradeCo@8

; 2823 : 			{
; 2824 : 				CvPlot* pDestCityPlot = pDestCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 2825 : 				if (pDestCityPlot->isRiver())

	cmp	BYTE PTR [eax+457], 0

; 2826 : 				{
; 2827 : 					iModifier = 25;

	mov	eax, 25					; 00000019H
	jg	SHORT $LN1@GetTradeCo@8
$LN20@GetTradeCo@8:

; 2828 : 				}
; 2829 : 			}
; 2830 : 		}
; 2831 : 	}
; 2832 : 
; 2833 : 	return iModifier;

	mov	eax, esi
$LN1@GetTradeCo@8:
	pop	esi

; 2834 : }

	ret	12					; 0000000cH
?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
EXTRN	?getGrowthPercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getGrowthPercent
EXTRN	?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getTradeRouteFoodBonusTimes100
EXTRN	?getTrainPercent@CvEraInfo@@QBEHXZ:PROC		; CvEraInfo::getTrainPercent
EXTRN	?getConstructPercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getConstructPercent
EXTRN	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getStartEra
EXTRN	?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getTradeRouteProductionBonusTimes100
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_iYourBuildingBonus$221391 = -20			; size = 4
_iExclusiveBonus$221390 = -16				; size = 4
_iResourceBonus$221389 = -12				; size = 4
_iDestPerTurnBonus$221388 = -8				; size = 4
_iOriginPerTurnBonus$221387 = -4			; size = 4
_iDomainModifier$221413 = 8				; size = 4
$T234435 = 8						; size = 4
_iTraitBonus$221393 = 8					; size = 4
_kTradeConnection$ = 8					; size = 4
_iTheirBuildingBonus$221411 = 12			; size = 4
_iDomainModifier$221395 = 12				; size = 4
_iValue$ = 12						; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
_iTheirBuildingBonus$221392 = 16			; size = 4
?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionValueTimes100, COMDAT
; _this$ = ecx

; 2842 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2843 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 2844 : 	int iValue = 0;
; 2845 : 
; 2846 : 	if (bAsOriginPlayer)

	mov	ebx, DWORD PTR _bAsOriginPlayer$[esp+32]
	xor	edi, edi

; 2847 : 	{
; 2848 : 		if (pTrade->IsConnectionInternational(kTradeConnection))

	mov	ecx, eax
	test	bl, bl
	je	$LN23@GetTradeCo@9
	mov	ebp, DWORD PTR _kTradeConnection$[esp+32]
	push	ebp
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	je	$LN3@GetTradeCo@9

; 2849 : 		{
; 2850 : 			
; 2851 : 			switch (eYield)

	mov	eax, DWORD PTR _eYield$[esp+32]
	cmp	eax, 3
	ja	$LN3@GetTradeCo@9
	jmp	DWORD PTR $LN80@GetTradeCo@9[eax*4]
$LN19@GetTradeCo@9:

; 2852 : 			{
; 2853 : 			// NQMP GJS - New Merchant Confederacy begin
; 2854 : 			case YIELD_PRODUCTION:
; 2855 : 			case YIELD_FOOD:
; 2856 : 			//case YIELD_CULTURE: // this doesn't work yet with JONSCulture stuff, figure it out later
; 2857 : 				iValue = GetTradeConnectionPolicyValueTimes100(kTradeConnection, eYield);

	push	eax
	push	ebp
	mov	ecx, esi
	call	?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100
	mov	edi, eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3043 : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$LN18@GetTradeCo@9:

; 2858 : 				break;
; 2859 : 			// NQMP GJS - New Merchant Confederacy end
; 2860 : 			case YIELD_GOLD:
; 2861 : 				{
; 2862 : 					int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100

; 2863 : 					int iOriginPerTurnBonus = GetTradeConnectionGPTValueTimes100(kTradeConnection, eYield, bAsOriginPlayer, true);

	push	1
	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	edi, eax
	call	?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100

; 2864 : 					int iDestPerTurnBonus = GetTradeConnectionGPTValueTimes100(kTradeConnection, eYield, bAsOriginPlayer, false);

	push	0
	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iOriginPerTurnBonus$221387[esp+52], eax
	call	?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100

; 2865 : 					int iResourceBonus = GetTradeConnectionResourceValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iDestPerTurnBonus$221388[esp+48], eax
	call	?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100

; 2866 : 					int iExclusiveBonus = GetTradeConnectionExclusiveValueTimes100(kTradeConnection, eYield);

	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iResourceBonus$221389[esp+44], eax
	call	?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100

; 2867 : 					//int iPolicyBonus = GetTradeConnectionPolicyValueTimes100(kTradeConnection, eYield); -- Sike, nerfing this ~EAP
; 2868 : 					int iYourBuildingBonus = GetTradeConnectionYourBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iExclusiveBonus$221390[esp+48], eax
	call	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100

; 2869 : 					int iTheirBuildingBonus = GetTradeConnectionTheirBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iYourBuildingBonus$221391[esp+48], eax
	call	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100

; 2870 : 					int iTraitBonus = GetTradeConnectionOtherTraitValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iTheirBuildingBonus$221392[esp+44], eax
	call	?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100

; 2871 : 
; 2872 : 					int iModifier = 100;
; 2873 : 					int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iTraitBonus$221393[esp+40], eax
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100

; 2874 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2875 : 					iValue *= iDomainModifier + 100;
; 2876 : 					iValue /= 100;
; 2877 : #endif
; 2878 : 					int iOriginRiverModifier = GetTradeConnectionRiverValueModifierTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	2
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iDomainModifier$221395[esp+44], eax
	call	?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100

; 2879 : 
; 2880 : 					iValue = iBaseValue;
; 2881 : 					iValue += iOriginPerTurnBonus;
; 2882 : 					iValue += iDestPerTurnBonus;
; 2883 : 					iValue += iExclusiveBonus;
; 2884 : 					iValue += iYourBuildingBonus;
; 2885 : 					iValue += iTheirBuildingBonus;
; 2886 : 					iValue += iResourceBonus;
; 2887 : 					//iValue += iPolicyBonus;
; 2888 : 					iValue += iTraitBonus;
; 2889 : 
; 2890 : #ifndef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2891 : 					iModifier += iDomainModifier;
; 2892 : #endif
; 2893 : 					iModifier += iOriginRiverModifier;
; 2894 : 
; 2895 : 					iValue *= iModifier;
; 2896 : 					iValue /= 100;

	mov	ecx, DWORD PTR _iDomainModifier$221395[esp+32]
	mov	edx, DWORD PTR _iTraitBonus$221393[esp+32]
	lea	ecx, DWORD PTR [eax+ecx+100]
	mov	eax, DWORD PTR _iTheirBuildingBonus$221392[esp+32]
	add	edx, eax
	add	edx, DWORD PTR _iYourBuildingBonus$221391[esp+36]
	mov	eax, 1374389535				; 51eb851fH
	add	edx, DWORD PTR _iExclusiveBonus$221390[esp+36]

; 2897 : 					iValue = max(100, iValue);

	mov	DWORD PTR $T234435[esp+32], 100		; 00000064H
	add	edx, DWORD PTR _iResourceBonus$221389[esp+36]
	add	edx, DWORD PTR _iDestPerTurnBonus$221388[esp+36]
	add	edx, DWORD PTR _iOriginPerTurnBonus$221387[esp+36]
	add	edx, edi
	imul	ecx, edx
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iValue$[esp+32], eax
	cmp	eax, 100				; 00000064H
	lea	eax, DWORD PTR _iValue$[esp+32]
	jg	SHORT $LN31@GetTradeCo@9
	lea	eax, DWORD PTR $T234435[esp+32]
$LN31@GetTradeCo@9:
	mov	edi, DWORD PTR [eax]

; 3028 : #endif
; 3029 : 				}
; 3030 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3031 : 				if (eYield == YIELD_FOOD)
; 3032 : 				{
; 3033 : 					iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 3034 : 				}
; 3035 : #endif
; 3036 : 
; 3037 : 				break;
; 3038 : 			}
; 3039 : 		}
; 3040 : 	}
; 3041 : 
; 3042 : 	return iValue;	

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3043 : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$LN17@GetTradeCo@9:

; 2898 : 				}
; 2899 : 				break;
; 2900 : 			case YIELD_SCIENCE:
; 2901 : 				int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	ebx
	push	3
	push	ebp
	mov	ecx, esi
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
	mov	ecx, eax

; 2902 : 
; 2903 : 				iValue = iBaseValue;
; 2904 : 
; 2905 : 				int iModifier = 100;
; 2906 : 				
; 2907 : 				iValue *= iModifier;

	imul	ecx, 100				; 00000064H

; 2908 : 				iValue /= 100;
; 2909 : 				break;
; 2910 : 			}
; 2911 : 		}
; 2912 : 	}
; 2913 : 	else

	jmp	$LN79@GetTradeCo@9
$LN23@GetTradeCo@9:

; 2914 : 	{
; 2915 : 		if (pTrade->IsConnectionInternational(kTradeConnection))

	mov	ebx, DWORD PTR _kTradeConnection$[esp+32]
	push	ebx
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	je	$LN15@GetTradeCo@9

; 2916 : 		{
; 2917 : 			if (kTradeConnection.m_eDestOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR [esi+79104]
	mov	edx, DWORD PTR [ebx+24]
	cmp	edx, DWORD PTR [ecx+44]
	jne	$LN3@GetTradeCo@9

; 2918 : 			{
; 2919 : 				switch (eYield)

	mov	eax, DWORD PTR _eYield$[esp+32]
	sub	eax, 2
	je	SHORT $LN11@GetTradeCo@9
	sub	eax, 1
	jne	$LN3@GetTradeCo@9

; 2948 : 					}
; 2949 : 					break;
; 2950 : 				case YIELD_SCIENCE:
; 2951 : 					{
; 2952 : 						int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	eax
	push	3
	push	ebx
	mov	ecx, esi
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
	mov	ecx, eax

; 2953 : 
; 2954 : 						int iModifier = 100;
; 2955 : 
; 2956 : 						iValue = iBaseValue;
; 2957 : 
; 2958 : 						iValue *= iModifier;

	imul	ecx, 100				; 00000064H

; 2959 : 						iValue /= 100;						
; 2960 : 					}
; 2961 : 					break;

	jmp	SHORT $LN79@GetTradeCo@9
$LN11@GetTradeCo@9:

; 2920 : 				{
; 2921 : 				case YIELD_GOLD:
; 2922 : 					{
; 2923 : 						int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	0
	push	2
	push	ebx
	mov	ecx, esi
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100

; 2924 : 						int iYourBuildingBonus = GetTradeConnectionYourBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	0
	push	2
	push	ebx
	mov	ecx, esi
	mov	edi, eax
	call	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100

; 2925 : 						int iTheirBuildingBonus = GetTradeConnectionTheirBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	push	0
	push	2
	push	ebx
	mov	ecx, esi
	mov	ebp, eax
	call	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100

; 2926 : 
; 2927 : 						int iModifier = 100;
; 2928 : 						int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	push	2
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _iTheirBuildingBonus$221411[esp+40], eax
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100

; 2929 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2930 : 						iValue *= iDomainModifier + 100;
; 2931 : 						iValue /= 100;
; 2932 : #endif
; 2933 : 						int iDestRiverModifier = GetTradeConnectionRiverValueModifierTimes100(kTradeConnection, eYield, false);

	xor	esi, esi
	cmp	DWORD PTR [ebx+28], 2
	mov	DWORD PTR _iDomainModifier$221413[esp+32], eax
	jne	SHORT $LN78@GetTradeCo@9
	push	ebx
	call	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
	add	esp, 4
	test	eax, eax
	je	SHORT $LN78@GetTradeCo@9
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	BYTE PTR [eax+457], 0
	jle	SHORT $LN78@GetTradeCo@9
	mov	esi, 25					; 00000019H
$LN78@GetTradeCo@9:
	mov	eax, DWORD PTR _iTheirBuildingBonus$221411[esp+32]

; 2934 : 						int iTraitBonus = GetTradeConnectionOtherTraitValueTimes100(kTradeConnection, eYield, false);
; 2935 : 
; 2936 : 						iValue = iBaseValue;
; 2937 : 						iValue += iYourBuildingBonus;
; 2938 : 						iValue += iTheirBuildingBonus;
; 2939 : 						iValue += iTraitBonus;
; 2940 : 
; 2941 : #ifndef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2942 : 						iModifier += iDomainModifier;
; 2943 : #endif
; 2944 : 						iModifier += iDestRiverModifier;
; 2945 : 
; 2946 : 						iValue *= iModifier;
; 2947 : 						iValue /= 100;

	mov	edx, DWORD PTR _iDomainModifier$221413[esp+32]
	lea	ecx, DWORD PTR [eax+ebp]
	add	ecx, edi
	lea	eax, DWORD PTR [esi+edx+100]
	imul	ecx, eax
$LN79@GetTradeCo@9:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 3028 : #endif
; 3029 : 				}
; 3030 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3031 : 				if (eYield == YIELD_FOOD)
; 3032 : 				{
; 3033 : 					iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 3034 : 				}
; 3035 : #endif
; 3036 : 
; 3037 : 				break;
; 3038 : 			}
; 3039 : 		}
; 3040 : 	}
; 3041 : 
; 3042 : 	return iValue;	

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3043 : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$LN15@GetTradeCo@9:

; 2962 : 				}
; 2963 : 			}
; 2964 : 		}
; 2965 : 		else
; 2966 : 		{
; 2967 : 			// NQMP GJS - Silk Road begin
; 2968 : 			if (eYield == YIELD_GOLD)

	mov	ebp, DWORD PTR _eYield$[esp+32]
	cmp	ebp, 2
	jne	SHORT $LN8@GetTradeCo@9

; 2969 : 			{
; 2970 : 				iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_GOLD_CHANGE);

	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	67					; 00000043H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	edi, eax
$LN8@GetTradeCo@9:

; 2971 : 			}
; 2972 : 			// NQMP GJS - Silk Road end
; 2973 : 			switch (kTradeConnection.m_eConnectionType)

	mov	eax, DWORD PTR [ebx+32]
	sub	eax, 1
	je	$LN5@GetTradeCo@9
	sub	eax, 1
	jne	$LN3@GetTradeCo@9

; 3003 : 				}
; 3004 : #endif
; 3005 : 
; 3006 : 				break;
; 3007 : 			case TRADE_CONNECTION_PRODUCTION:
; 3008 : 				if (eYield == YIELD_PRODUCTION)

	cmp	ebp, 1
	jne	$LN3@GetTradeCo@9

; 3009 : 				{
; 3010 : 					iValue = 300;
; 3011 : 					iValue += GC.getEraInfo(GET_PLAYER(kTradeConnection.m_eDestOwner).GetCurrentEra())->getTradeRouteProductionBonusTimes100();

	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ ; CvEraInfo::getTradeRouteProductionBonusTimes100

; 3012 : 					iValue *= (GC.getEraInfo(GC.getGame().getStartEra())->getConstructPercent() + GC.getEraInfo(GC.getGame().getStartEra())->getTrainPercent()) / 2;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	add	edi, 300				; 0000012cH
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getConstructPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getConstructPercent
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, eax
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getTrainPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getTrainPercent
	add	eax, ebp
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	imul	ecx, edi

; 3013 : 					iValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx

; 3014 : 
; 3015 : 					int iModifier = 100;
; 3016 : 					int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	push	1
	shr	edi, 31					; 0000001fH
	push	ebx
	mov	ecx, esi
	add	edi, edx
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100

; 3017 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 3018 : 					iValue *= iDomainModifier + 100;
; 3019 : 					iValue /= 100;
; 3020 : #else
; 3021 : 					iModifier += iDomainModifier;
; 3022 : #endif
; 3023 : 					iModifier += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_MODIFIER);

	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	43					; 0000002bH
	mov	esi, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 3024 : 					iValue *= iModifier;
; 3025 : 					iValue /= 100;
; 3026 : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 3027 : 					iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_PRODUCTION_YIELD_CHANGE);

	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	44					; 0000002cH
	lea	esi, DWORD PTR [eax+esi+100]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	imul	esi, edi
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	ecx, edx
	add	edi, ecx

; 3028 : #endif
; 3029 : 				}
; 3030 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3031 : 				if (eYield == YIELD_FOOD)
; 3032 : 				{
; 3033 : 					iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 3034 : 				}
; 3035 : #endif
; 3036 : 
; 3037 : 				break;
; 3038 : 			}
; 3039 : 		}
; 3040 : 	}
; 3041 : 
; 3042 : 	return iValue;	

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3043 : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$LN5@GetTradeCo@9:

; 2974 : 			{
; 2975 : 			case TRADE_CONNECTION_FOOD:
; 2976 : 				if (eYield == YIELD_FOOD)

	test	ebp, ebp
	jne	$LN4@GetTradeCo@9

; 2977 : 				{
; 2978 : 					iValue = 300;
; 2979 : 					iValue += GC.getEraInfo(GET_PLAYER(kTradeConnection.m_eDestOwner).GetCurrentEra())->getTradeRouteFoodBonusTimes100();

	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ ; CvEraInfo::getTradeRouteFoodBonusTimes100

; 2980 : 					iValue *= GC.getEraInfo(GC.getGame().getStartEra())->getGrowthPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	add	edi, 300				; 0000012cH
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getGrowthPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getGrowthPercent
	mov	ecx, eax
	imul	ecx, edi

; 2981 : 					iValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx

; 2982 : 
; 2983 : 					int iModifier = 100;
; 2984 : 					int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	push	ebp
	shr	edi, 31					; 0000001fH
	push	ebx
	mov	ecx, esi
	add	edi, edx
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100

; 2985 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2986 : 					iValue *= iDomainModifier + 100;
; 2987 : 					iValue /= 100;
; 2988 : #else
; 2989 : 					iModifier += iDomainModifier;
; 2990 : #endif
; 2991 : 					iModifier += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_MODIFIER);

	mov	ebx, DWORD PTR [ebx+24]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	43					; 0000002bH
	mov	ecx, ebx
	mov	esi, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 2992 : 					iValue *= iModifier;
; 2993 : 					iValue /= 100;

	lea	ecx, DWORD PTR [eax+esi+100]
	imul	ecx, edi

; 2994 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 2995 : 					iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 2996 : #endif
; 2997 : 				}
; 2998 : 
; 2999 : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 3000 : 				if (eYield == YIELD_PRODUCTION)

	jmp	$LN79@GetTradeCo@9
$LN4@GetTradeCo@9:
	cmp	ebp, 1
	jne	SHORT $LN3@GetTradeCo@9

; 3001 : 				{
; 3002 : 					iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_PRODUCTION_YIELD_CHANGE);

	mov	ecx, DWORD PTR [ebx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	44					; 0000002cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax
$LN3@GetTradeCo@9:

; 3028 : #endif
; 3029 : 				}
; 3030 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3031 : 				if (eYield == YIELD_FOOD)
; 3032 : 				{
; 3033 : 					iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 3034 : 				}
; 3035 : #endif
; 3036 : 
; 3037 : 				break;
; 3038 : 			}
; 3039 : 		}
; 3040 : 	}
; 3041 : 
; 3042 : 	return iValue;	

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3043 : }

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$LN80@GetTradeCo@9:
	DD	$LN19@GetTradeCo@9
	DD	$LN19@GetTradeCo@9
	DD	$LN18@GetTradeCo@9
	DD	$LN17@GetTradeCo@9
?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionValueTimes100
_TEXT	ENDS
PUBLIC	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_pTrade$ = -12						; size = 4
_ui$221439 = -8						; size = 4
tv363 = -4						; size = 4
?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ PROC	; CvPlayerTrade::UpdateTradeConnectionValues, COMDAT
; _this$ = ecx

; 3047 : {

	sub	esp, 12					; 0000000cH
	push	ebp
	mov	ebp, ecx

; 3048 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 3049 : #ifdef AUI_ITERATORIZE
; 3050 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3051 : 	{
; 3052 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3053 : #else
; 3054 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	xor	esi, esi
	mov	DWORD PTR _pTrade$[esp+20], eax
	mov	DWORD PTR _ui$221439[esp+20], esi
	cmp	DWORD PTR [eax+4], esi
	jbe	$LN10@UpdateTrad@2
	push	ebx
	mov	DWORD PTR tv363[esp+24], esi
	push	edi
	npad	5
$LL49@UpdateTrad@2:

; 3055 : 	{
; 3056 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	ecx, DWORD PTR [eax]
	add	esi, ecx

; 3057 : 
; 3058 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	or	ecx, -1
	cmp	DWORD PTR [esi+4], ecx
	jne	SHORT $LN22@UpdateTrad@2
	cmp	DWORD PTR [esi+8], ecx
	jne	SHORT $LN22@UpdateTrad@2
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN22@UpdateTrad@2
	cmp	DWORD PTR [esi+16], ecx
	je	SHORT $LN11@UpdateTrad@2
$LN22@UpdateTrad@2:

; 3059 : #endif
; 3060 : 		{
; 3061 : 			continue;
; 3062 : 		}
; 3063 : 
; 3064 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp+79104]
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, DWORD PTR [edx+44]
	jne	SHORT $LN5@UpdateTrad@2

; 3065 : 		{
; 3066 : 			for (uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	xor	edi, edi
	lea	ebx, DWORD PTR [esi+396]
$LL7@UpdateTrad@2:

; 3067 : 			{
; 3068 : 				pConnection->m_aiOriginYields[uiYields] = GetTradeConnectionValueTimes100(*pConnection, (YieldTypes)uiYields, true);

	push	1
	push	edi
	push	esi
	mov	ecx, ebp
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
	mov	DWORD PTR [ebx], eax
	inc	edi
	add	ebx, 4
	cmp	edi, 6
	jb	SHORT $LL7@UpdateTrad@2

; 3065 : 		{
; 3066 : 			for (uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	mov	eax, DWORD PTR _pTrade$[esp+28]
$LN5@UpdateTrad@2:

; 3069 : 			}
; 3070 : 		}
; 3071 : 
; 3072 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp+79104]
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, DWORD PTR [edx+44]
	jne	SHORT $LN11@UpdateTrad@2

; 3073 : 		{
; 3074 : 			for (uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	xor	edi, edi
	lea	ebx, DWORD PTR [esi+420]
$LL48@UpdateTrad@2:

; 3075 : 			{
; 3076 : 				pConnection->m_aiDestYields[uiYields] = GetTradeConnectionValueTimes100(*pConnection, (YieldTypes)uiYields, false);

	push	0
	push	edi
	push	esi
	mov	ecx, ebp
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
	mov	DWORD PTR [ebx], eax
	inc	edi
	add	ebx, 4
	cmp	edi, 6
	jb	SHORT $LL48@UpdateTrad@2

; 3073 : 		{
; 3074 : 			for (uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	mov	eax, DWORD PTR _pTrade$[esp+28]
$LN11@UpdateTrad@2:

; 3049 : #ifdef AUI_ITERATORIZE
; 3050 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3051 : 	{
; 3052 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3053 : #else
; 3054 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	ecx, DWORD PTR _ui$221439[esp+28]
	mov	esi, DWORD PTR tv363[esp+28]
	inc	ecx
	add	esi, 444				; 000001bcH
	mov	DWORD PTR _ui$221439[esp+28], ecx
	mov	DWORD PTR tv363[esp+28], esi
	cmp	ecx, DWORD PTR [eax+4]
	jb	$LL49@UpdateTrad@2
	pop	edi
	pop	ebx
$LN10@UpdateTrad@2:
	pop	esi
	pop	ebp

; 3077 : 			}
; 3078 : 		}
; 3079 : 	}
; 3080 : }

	add	esp, 12					; 0000000cH
	ret	0
?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ENDP	; CvPlayerTrade::UpdateTradeConnectionValues
_TEXT	ENDS
PUBLIC	?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeValuesAtCityTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z
_TEXT	SEGMENT
tv168 = -8						; size = 4
_this$ = -4						; size = 4
_iCityY$ = 8						; size = 4
_pCity$ = 8						; size = 4
_eYield$ = 12						; size = 4
?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeValuesAtCityTimes100, COMDAT
; _this$ = ecx

; 3088 : {

	sub	esp, 8

; 3089 : 	int iResult = 0;
; 3090 : 	int iCityX = pCity->getX();

	mov	eax, DWORD PTR _pCity$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR [eax+96]

; 3091 : 	int iCityY = pCity->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR _this$[esp+12], ecx

; 3092 : 
; 3093 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	xor	edi, edi
	mov	DWORD PTR _iCityY$[esp+12], eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, DWORD PTR [eax+4]

; 3094 : #ifdef AUI_ITERATORIZE
; 3095 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3096 : 	{
; 3097 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3098 : #else
; 3099 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	test	ecx, ecx
	jbe	SHORT $LN48@GetTradeVa
	mov	eax, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR _eYield$[esp+16]
	mov	DWORD PTR tv168[esp+20], ecx
	push	esi
	or	ecx, -1
	npad	6
$LL8@GetTradeVa:

; 3100 : 	{
; 3101 : #ifdef AUI_CONSTIFY
; 3102 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3103 : #else
; 3104 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3105 : #endif
; 3106 : 
; 3107 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	esi, DWORD PTR [eax+4]
	cmp	esi, ecx
	jne	SHORT $LN26@GetTradeVa
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN26@GetTradeVa
	cmp	DWORD PTR [eax+12], ecx
	jne	SHORT $LN26@GetTradeVa
	cmp	DWORD PTR [eax+16], ecx
	je	SHORT $LN7@GetTradeVa
$LN26@GetTradeVa:

; 3108 : #endif
; 3109 : 		{
; 3110 : 			continue;
; 3111 : 		}
; 3112 : 
; 3113 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	edx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [edx+79104]
	mov	edx, DWORD PTR [edx+44]
	cmp	DWORD PTR [eax+20], edx
	jne	SHORT $LN49@GetTradeVa

; 3114 : 		{
; 3115 : 			if (pConnection->m_iOriginX == iCityX && pConnection->m_iOriginY == iCityY)

	cmp	esi, ebp
	jne	SHORT $LN49@GetTradeVa
	mov	esi, DWORD PTR [eax+8]
	cmp	esi, DWORD PTR _iCityY$[esp+20]
	jne	SHORT $LN49@GetTradeVa

; 3116 : 			{
; 3117 : 				iResult += pConnection->m_aiOriginYields[eYield];

	add	edi, DWORD PTR [eax+ebx*4+396]
$LN49@GetTradeVa:

; 3118 : 			}
; 3119 : 		}
; 3120 : 		
; 3121 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID())

	cmp	DWORD PTR [eax+24], edx
	jne	SHORT $LN7@GetTradeVa

; 3122 : 		{
; 3123 : 			if (pConnection->m_iDestX == iCityX && pConnection->m_iDestY == iCityY)

	cmp	DWORD PTR [eax+12], ebp
	jne	SHORT $LN7@GetTradeVa
	mov	edx, DWORD PTR _iCityY$[esp+20]
	cmp	DWORD PTR [eax+16], edx
	jne	SHORT $LN7@GetTradeVa

; 3124 : 			{
; 3125 : 				iResult += pConnection->m_aiDestYields[eYield];

	add	edi, DWORD PTR [eax+ebx*4+420]
$LN7@GetTradeVa:

; 3094 : #ifdef AUI_ITERATORIZE
; 3095 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3096 : 	{
; 3097 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3098 : #else
; 3099 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	add	eax, 444				; 000001bcH
	sub	DWORD PTR tv168[esp+24], 1
	jne	SHORT $LL8@GetTradeVa
	pop	esi
	pop	ebx
$LN48@GetTradeVa:

; 3126 : 			}
; 3127 : 		}
; 3128 : 	}
; 3129 : 
; 3130 : 	return iResult;

	mov	eax, edi
	pop	edi
	pop	ebp

; 3131 : }

	add	esp, 8
	ret	8
?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeValuesAtCityTimes100
_TEXT	ENDS
PUBLIC	?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z ; CvPlayerTrade::GetAllTradeValueTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z PROC ; CvPlayerTrade::GetAllTradeValueTimes100, COMDAT
; _this$ = ecx

; 3139 : {

	push	ebp
	mov	ebp, ecx

; 3140 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx+4]

; 3141 : 	int iTotal = 0;

	xor	eax, eax

; 3142 : #ifdef AUI_ITERATORIZE
; 3143 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3144 : 	{
; 3145 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3146 : #else
; 3147 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN4@GetAllTrad
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _eYield$[esp+12]
	or	ebx, -1
$LL6@GetAllTrad:

; 3148 : 	{
; 3149 : #ifdef AUI_CONSTIFY
; 3150 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3151 : #else
; 3152 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3153 : #endif
; 3154 : 
; 3155 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN16@GetAllTrad
	cmp	DWORD PTR [ecx+8], ebx
	jne	SHORT $LN16@GetAllTrad
	cmp	DWORD PTR [ecx+12], ebx
	jne	SHORT $LN16@GetAllTrad
	cmp	DWORD PTR [ecx+16], ebx
	je	SHORT $LN5@GetAllTrad
$LN16@GetAllTrad:

; 3156 : #endif
; 3157 : 		{
; 3158 : 			continue;
; 3159 : 		}
; 3160 : 
; 3161 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	esi, DWORD PTR [ebp+79104]
	mov	esi, DWORD PTR [esi+44]
	cmp	DWORD PTR [ecx+20], esi
	jne	SHORT $LN2@GetAllTrad

; 3162 : 		{
; 3163 : 			iTotal += pConnection->m_aiOriginYields[eYield];

	add	eax, DWORD PTR [ecx+edi*4+396]
$LN2@GetAllTrad:

; 3164 : 		}
; 3165 : 
; 3166 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID())

	cmp	DWORD PTR [ecx+24], esi
	jne	SHORT $LN5@GetAllTrad

; 3167 : 		{
; 3168 : 			iTotal += pConnection->m_aiDestYields[eYield];

	add	eax, DWORD PTR [ecx+edi*4+420]
$LN5@GetAllTrad:

; 3142 : #ifdef AUI_ITERATORIZE
; 3143 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3144 : 	{
; 3145 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3146 : #else
; 3147 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	add	ecx, 444				; 000001bcH
	sub	edx, 1
	jne	SHORT $LL6@GetAllTrad
	pop	edi
	pop	esi
	pop	ebx
$LN4@GetAllTrad:
	pop	ebp

; 3169 : 		}
; 3170 : 	}
; 3171 : 
; 3172 : 	return iTotal;
; 3173 : }

	ret	4
?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetAllTradeValueTimes100
_TEXT	ENDS
PUBLIC	?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z ; CvPlayerTrade::GetAllTradeValueFromPlayerTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv196 = -8						; size = 4
_this$ = -4						; size = 4
_eYield$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z PROC ; CvPlayerTrade::GetAllTradeValueFromPlayerTimes100, COMDAT
; _this$ = ecx

; 3181 : {

	sub	esp, 8
	mov	DWORD PTR _this$[esp+8], ecx

; 3182 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx+4]

; 3183 : 	int iTotal = 0;

	xor	eax, eax

; 3184 : #ifdef AUI_ITERATORIZE
; 3185 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3186 : 	{
; 3187 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3188 : #else
; 3189 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN4@GetAllTrad@2
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp+12]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eYield$[esp+20]
	mov	DWORD PTR tv196[esp+24], edx
	or	ebx, -1
$LL41@GetAllTrad@2:

; 3190 : 	{
; 3191 : #ifdef AUI_CONSTIFY
; 3192 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3193 : #else
; 3194 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3195 : #endif
; 3196 : 
; 3197 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN16@GetAllTrad@2
	cmp	DWORD PTR [ecx+8], ebx
	jne	SHORT $LN16@GetAllTrad@2
	cmp	DWORD PTR [ecx+12], ebx
	jne	SHORT $LN16@GetAllTrad@2
	cmp	DWORD PTR [ecx+16], ebx
	je	SHORT $LN5@GetAllTrad@2
$LN16@GetAllTrad@2:

; 3198 : #endif
; 3199 : 		{
; 3200 : 			continue;
; 3201 : 		}
; 3202 : 
; 3203 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID() && pConnection->m_eDestOwner == ePlayer)

	mov	edx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [edx+79104]
	mov	edx, DWORD PTR [edx+44]
	mov	esi, DWORD PTR [ecx+20]
	cmp	esi, edx
	jne	SHORT $LN39@GetAllTrad@2
	cmp	DWORD PTR [ecx+24], ebp
	jne	SHORT $LN39@GetAllTrad@2

; 3204 : 		{
; 3205 : 			iTotal += pConnection->m_aiOriginYields[eYield];

	add	eax, DWORD PTR [ecx+edi*4+396]
$LN39@GetAllTrad@2:

; 3206 : 		}
; 3207 : 
; 3208 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID() && pConnection->m_eOriginOwner == ePlayer)

	cmp	DWORD PTR [ecx+24], edx
	jne	SHORT $LN5@GetAllTrad@2
	cmp	esi, ebp
	jne	SHORT $LN5@GetAllTrad@2

; 3209 : 		{
; 3210 : 			iTotal += pConnection->m_aiDestYields[eYield];

	add	eax, DWORD PTR [ecx+edi*4+420]
$LN5@GetAllTrad@2:

; 3184 : #ifdef AUI_ITERATORIZE
; 3185 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3186 : 	{
; 3187 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3188 : #else
; 3189 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	add	ecx, 444				; 000001bcH
	sub	DWORD PTR tv196[esp+24], 1
	jne	SHORT $LL41@GetAllTrad@2
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN4@GetAllTrad@2:

; 3211 : 		}
; 3212 : 	}
; 3213 : 
; 3214 : 	return iTotal;
; 3215 : }

	add	esp, 8
	ret	8
?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayerTrade::GetAllTradeValueFromPlayerTimes100
_TEXT	ENDS
PUBLIC	?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z ; CvPlayerTrade::IsConnectedToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eOtherPlayer$ = 8					; size = 4
?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlayerTrade::IsConnectedToPlayer, COMDAT
; _this$ = ecx

; 3224 : 	return GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), eOtherPlayer);

	mov	eax, DWORD PTR [ecx+79104]
	mov	ecx, DWORD PTR _eOtherPlayer$[esp-4]
	mov	eax, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer

; 3225 : }

	ret	4
?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlayerTrade::IsConnectedToPlayer
_TEXT	ENDS
PUBLIC	?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z ; CvPlayerTrade::GetTradeConnection
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z
_TEXT	SEGMENT
tv185 = 8						; size = 4
_pOriginCity$ = 8					; size = 4
_iDestY$ = 12						; size = 4
_pDestCity$ = 12					; size = 4
?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z PROC ; CvPlayerTrade::GetTradeConnection, COMDAT
; _this$ = ecx

; 3438 : 	int iOriginX = pOriginCity->getX();

	mov	eax, DWORD PTR _pOriginCity$[esp-4]
	push	ebx

; 3439 : 	int iOriginY = pOriginCity->getY();

	mov	ebx, DWORD PTR [eax+108]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+96]

; 3440 : 	int iDestX = pDestCity->getX();

	mov	eax, DWORD PTR _pDestCity$[esp+12]
	mov	ebp, DWORD PTR [eax+96]

; 3441 : 	int iDestY = pDestCity->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	esi, ecx

; 3442 : 
; 3443 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _iDestY$[esp+12], eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, DWORD PTR [eax+4]

; 3444 : #ifdef AUI_ITERATORIZE
; 3445 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3446 : 	{
; 3447 : #else
; 3448 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	xor	edx, edx
	test	ecx, ecx
	jbe	SHORT $LN3@GetTradeCo@10
	mov	esi, DWORD PTR [esi+79104]

; 3449 : 	{
; 3450 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3451 : #endif
; 3452 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	esi, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv185[esp+12], esi
$LL37@GetTradeCo@10:
	mov	esi, DWORD PTR tv185[esp+12]
	cmp	DWORD PTR [eax+20], esi
	jne	SHORT $LN4@GetTradeCo@10

; 3453 : 		{
; 3454 : 			if (pConnection->m_iOriginX == iOriginX && pConnection->m_iOriginY == iOriginY && pConnection->m_iDestX == iDestX && pConnection->m_iDestY == iDestY)

	cmp	DWORD PTR [eax+4], edi
	jne	SHORT $LN4@GetTradeCo@10
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN4@GetTradeCo@10
	cmp	DWORD PTR [eax+12], ebp
	jne	SHORT $LN4@GetTradeCo@10
	mov	esi, DWORD PTR _iDestY$[esp+12]
	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN6@GetTradeCo@10
$LN4@GetTradeCo@10:

; 3444 : #ifdef AUI_ITERATORIZE
; 3445 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3446 : 	{
; 3447 : #else
; 3448 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	inc	edx
	add	eax, 444				; 000001bcH
	cmp	edx, ecx
	jb	SHORT $LL37@GetTradeCo@10
$LN3@GetTradeCo@10:

; 3455 : 			{
; 3456 : 				return pConnection;
; 3457 : 			}
; 3458 : 		}
; 3459 : 	}
; 3460 : 
; 3461 : 	return NULL;

	xor	eax, eax
$LN6@GetTradeCo@10:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3462 : }

	ret	8
?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z ENDP ; CvPlayerTrade::GetTradeConnection
_TEXT	ENDS
PUBLIC	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ
_TEXT	SEGMENT
_iNumConnections$ = -4					; size = 4
?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ PROC ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes, COMDAT
; _this$ = ecx

; 3470 : {

	push	ecx
	push	ebp
	push	esi
	mov	ebp, ecx

; 3471 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	esi, eax

; 3472 : 	int iNumConnections = 0;

	xor	eax, eax

; 3473 : #ifdef AUI_ITERATORIZE
; 3474 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3475 : 	{
; 3476 : #else
; 3477 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	xor	edi, edi
	mov	DWORD PTR _iNumConnections$[esp+16], eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN3@GetNumberO
	push	ebx
	xor	ebx, ebx
$LL5@GetNumberO:

; 3478 : 	{
; 3479 : #ifdef AUI_CONSTIFY
; 3480 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3481 : #else
; 3482 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	eax, DWORD PTR [esi]

; 3483 : #endif
; 3484 : #endif
; 3485 : 
; 3486 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR [ebp+79104]
	mov	edx, DWORD PTR [eax+ebx+20]
	add	eax, ebx
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN4@GetNumberO

; 3487 : 		{
; 3488 : 			if(GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv())

	mov	eax, DWORD PTR [eax+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN4@GetNumberO

; 3489 : 			{
; 3490 : 				iNumConnections++;

	inc	DWORD PTR _iNumConnections$[esp+20]
$LN4@GetNumberO:

; 3473 : #ifdef AUI_ITERATORIZE
; 3474 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3475 : 	{
; 3476 : #else
; 3477 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	inc	edi
	add	ebx, 444				; 000001bcH
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL5@GetNumberO

; 3491 : 			}
; 3492 : 		}
; 3493 : 	}
; 3494 : 
; 3495 : 	return iNumConnections;

	mov	eax, DWORD PTR _iNumConnections$[esp+20]
	pop	ebx
$LN3@GetNumberO:
	pop	edi
	pop	esi
	pop	ebp

; 3496 : }

	pop	ecx
	ret	0
?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ENDP ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
_TEXT	ENDS
PUBLIC	?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ; CvPlayerTrade::IsPreviousTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
_TEXT	SEGMENT
_iDestCityY$ = 8					; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z PROC ; CvPlayerTrade::IsPreviousTradeRoute, COMDAT
; _this$ = ecx

; 3505 : 	int iOriginCityX = pOriginCity->getX();

	mov	eax, DWORD PTR _pOriginCity$[esp-4]
	push	ebx

; 3506 : 	int iOriginCityY = pOriginCity->getY();

	mov	ebx, DWORD PTR [eax+108]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	push	edi
	mov	edi, DWORD PTR [eax+96]

; 3507 : 	int iDestCityX = pDestCity->getX();

	mov	eax, DWORD PTR _pDestCity$[esp+12]
	mov	ebp, DWORD PTR [eax+96]

; 3508 : 	int iDestCityY = pDestCity->getY();

	mov	eax, DWORD PTR [eax+108]

; 3509 : 
; 3510 : #ifdef AUI_ITERATORIZE
; 3511 : 	for (TradeConnectionList::const_iterator it = m_aRecentlyExpiredConnections.begin(); it != m_aRecentlyExpiredConnections.end(); ++it)
; 3512 : 	{
; 3513 : 		if (it->m_iOriginX == iOriginCityX &&
; 3514 : 			it->m_iOriginY == iOriginCityY &&
; 3515 : 			it->m_iDestX == iDestCityX &&
; 3516 : 			it->m_iDestY == iDestCityY &&
; 3517 : 			it->m_eDomain == eDomain &&
; 3518 : 			it->m_eConnectionType == eConnectionType)
; 3519 : #else
; 3520 : 	for (uint ui = 0; ui < m_aRecentlyExpiredConnections.size(); ui++)

	xor	edx, edx
	mov	DWORD PTR _iDestCityY$[esp+12], eax
	test	esi, esi
	jbe	SHORT $LN2@IsPrevious
	mov	eax, DWORD PTR [ecx]
	add	eax, 8
	npad	6
$LL4@IsPrevious:

; 3521 : 	{
; 3522 : 		if (m_aRecentlyExpiredConnections[ui].m_iOriginX == iOriginCityX &&
; 3523 : 			m_aRecentlyExpiredConnections[ui].m_iOriginY == iOriginCityY &&
; 3524 : 			m_aRecentlyExpiredConnections[ui].m_iDestX == iDestCityX &&
; 3525 : 			m_aRecentlyExpiredConnections[ui].m_iDestY == iDestCityY &&
; 3526 : 			m_aRecentlyExpiredConnections[ui].m_eDomain == eDomain &&
; 3527 : 			m_aRecentlyExpiredConnections[ui].m_eConnectionType == eConnectionType) 

	cmp	DWORD PTR [eax-4], edi
	jne	SHORT $LN3@IsPrevious
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN3@IsPrevious
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN3@IsPrevious
	mov	ecx, DWORD PTR _iDestCityY$[esp+12]
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN3@IsPrevious
	mov	ecx, DWORD PTR _eDomain$[esp+12]
	cmp	DWORD PTR [eax+20], ecx
	jne	SHORT $LN3@IsPrevious
	mov	ecx, DWORD PTR _eConnectionType$[esp+12]
	cmp	DWORD PTR [eax+24], ecx
	je	SHORT $LN38@IsPrevious
$LN3@IsPrevious:

; 3509 : 
; 3510 : #ifdef AUI_ITERATORIZE
; 3511 : 	for (TradeConnectionList::const_iterator it = m_aRecentlyExpiredConnections.begin(); it != m_aRecentlyExpiredConnections.end(); ++it)
; 3512 : 	{
; 3513 : 		if (it->m_iOriginX == iOriginCityX &&
; 3514 : 			it->m_iOriginY == iOriginCityY &&
; 3515 : 			it->m_iDestX == iDestCityX &&
; 3516 : 			it->m_iDestY == iDestCityY &&
; 3517 : 			it->m_eDomain == eDomain &&
; 3518 : 			it->m_eConnectionType == eConnectionType)
; 3519 : #else
; 3520 : 	for (uint ui = 0; ui < m_aRecentlyExpiredConnections.size(); ui++)

	inc	edx
	add	eax, 444				; 000001bcH
	cmp	edx, esi
	jb	SHORT $LL4@IsPrevious
$LN2@IsPrevious:
	pop	edi
	pop	esi
	pop	ebp

; 3531 : 		}
; 3532 : 	}
; 3533 : 
; 3534 : 	return false;

	xor	al, al
	pop	ebx

; 3535 : }

	ret	16					; 00000010H
$LN38@IsPrevious:
	pop	edi
	pop	esi
	pop	ebp

; 3528 : #endif
; 3529 : 		{
; 3530 : 			return true;

	mov	al, 1
	pop	ebx

; 3535 : }

	ret	16					; 00000010H
?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ENDP ; CvPlayerTrade::IsPreviousTradeRoute
_TEXT	ENDS
PUBLIC	?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z ; CvPlayerTrade::GetTradeRouteRange
EXTRN	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
EXTRN	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
EXTRN	?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z:PROC ; CvTechEntry::GetTradeRouteDomainExtraRange
EXTRN	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z:PROC ; CvTechXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_iTraitRange$ = -12					; size = 4
_iExtendedRange$ = -8					; size = 4
_iBaseRange$ = -4					; size = 4
_eDomain$ = 8						; size = 4
_pOriginCity$ = 12					; size = 4
?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z PROC ; CvPlayerTrade::GetTradeRouteRange, COMDAT
; _this$ = ecx

; 4042 : {

	sub	esp, 12					; 0000000cH
	push	ebp
	push	esi
	mov	esi, ecx

; 4043 : 	int iRange = 0;
; 4044 : 
; 4045 : 	int iBaseRange = 0;
; 4046 : 	switch (eDomain)

	mov	ecx, DWORD PTR _eDomain$[esp+16]
	mov	eax, ecx
	xor	ebp, ebp
	sub	eax, ebp
	je	SHORT $LN21@GetTradeRo@2
	sub	eax, 2
	je	SHORT $LN20@GetTradeRo@2
	pop	esi

; 4054 : 	default:
; 4055 : 		CvAssertMsg(false, "Undefined domain for trade route range");
; 4056 : 		return -1;

	or	eax, -1
	pop	ebp

; 4132 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN20@GetTradeRo@2:

; 4050 : 		break;
; 4051 : 	case DOMAIN_LAND:
; 4052 : 		iBaseRange = 10;

	mov	DWORD PTR _iBaseRange$[esp+20], 10	; 0000000aH

; 4053 : 		break;

	jmp	SHORT $LN22@GetTradeRo@2
$LN21@GetTradeRo@2:

; 4047 : 	{
; 4048 : 	case DOMAIN_SEA:
; 4049 : 		iBaseRange = 20;

	mov	DWORD PTR _iBaseRange$[esp+20], 20	; 00000014H
$LN22@GetTradeRo@2:

; 4057 : 		break;
; 4058 : 	}
; 4059 : 
; 4060 : 	int iTraitRange = 0;
; 4061 : 	switch (eDomain)

	mov	eax, ecx
	sub	eax, ebp
	mov	DWORD PTR _iTraitRange$[esp+20], ebp
	je	SHORT $LN16@GetTradeRo@2
	sub	eax, 2
	jne	SHORT $LN17@GetTradeRo@2

; 4066 : 		break;
; 4067 : 	case DOMAIN_LAND:
; 4068 : 		iTraitRange = m_pPlayer->GetPlayerTraits()->GetLandTradeRouteRangeBonus();

	mov	ecx, DWORD PTR [esi+79104]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+320]
	mov	DWORD PTR _iTraitRange$[esp+20], eax

; 4069 : 		break;

	jmp	SHORT $LN17@GetTradeRo@2
$LN16@GetTradeRo@2:

; 4062 : 	{
; 4063 : 	case DOMAIN_SEA:
; 4064 : 		// not implemented
; 4065 : 		iTraitRange = 0;

	mov	DWORD PTR _iTraitRange$[esp+20], ebp
$LN17@GetTradeRo@2:

; 4070 : 	}
; 4071 : 
; 4072 : 	CvPlayerTechs* pMyPlayerTechs = m_pPlayer->GetPlayerTechs();

	mov	ecx, DWORD PTR [esi+79104]
	push	ebx
	push	edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs

; 4073 : 	CvTeamTechs* pMyTeamTechs = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).GetTeamTechs();

	mov	ecx, DWORD PTR [esi+79104]
	mov	edx, DWORD PTR [ecx+44]
	imul	edx, 63236				; 0000f704H
	mov	edi, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN38@GetTradeRo@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN39@GetTradeRo@2
$LN38@GetTradeRo@2:
	or	eax, -1
$LN39@GetTradeRo@2:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs

; 4074 : 	CvTechEntry* pTechInfo = NULL; 
; 4075 : 
; 4076 : 	int iExtendedRange = 0;
; 4077 : #ifdef AUI_WARNING_FIXES
; 4078 : 	for (uint iTechLoop = 0; iTechLoop < pMyPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 4079 : #else
; 4080 : 	for(int iTechLoop = 0; iTechLoop < pMyPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, edi
	mov	ebx, eax
	mov	DWORD PTR _iExtendedRange$[esp+28], ebp
	xor	esi, esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN12@GetTradeRo@2
	npad	7
$LL14@GetTradeRo@2:

; 4081 : #endif
; 4082 : 	{
; 4083 : 		TechTypes eTech = (TechTypes)iTechLoop;
; 4084 : 		if (!pMyTeamTechs->HasTech(eTech))

	push	esi
	mov	ecx, ebx
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN13@GetTradeRo@2

; 4085 : 		{
; 4086 : 			continue;
; 4087 : 		}
; 4088 : 
; 4089 : 		pTechInfo = pMyPlayerTechs->GetTechs()->GetEntry(eTech);

	push	esi
	mov	ecx, edi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry

; 4090 : 		CvAssertMsg(pTechInfo, "null tech entry");
; 4091 : 		if (pTechInfo)

	test	eax, eax
	je	SHORT $LN13@GetTradeRo@2

; 4092 : 		{
; 4093 : 			iExtendedRange += pTechInfo->GetTradeRouteDomainExtraRange(eDomain);

	mov	ecx, DWORD PTR _eDomain$[esp+24]
	push	ecx
	mov	ecx, eax
	call	?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z ; CvTechEntry::GetTradeRouteDomainExtraRange
	add	ebp, eax
$LN13@GetTradeRo@2:
	mov	ecx, edi
	inc	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL14@GetTradeRo@2
	mov	DWORD PTR _iExtendedRange$[esp+28], ebp
$LN12@GetTradeRo@2:

; 4094 : 		}
; 4095 : 	}
; 4096 : 	
; 4097 : 	int iRangeModifier = 0;
; 4098 : #ifdef AUI_WARNING_FIXES
; 4099 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4100 : #else
; 4101 : 	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN7@GetTradeRo@2
	mov	ebx, DWORD PTR _pOriginCity$[esp+24]
	npad	2
$LL9@GetTradeRo@2:

; 4102 : #endif
; 4103 : 	{
; 4104 : 		BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 4105 : 		if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN8@GetTradeRo@2

; 4106 : 		{
; 4107 : 			CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	esi, eax

; 4108 : 			if (!pBuildingEntry)

	test	esi, esi
	je	SHORT $LN8@GetTradeRo@2

; 4109 : 			{
; 4110 : 				continue;
; 4111 : 			}
; 4112 : 
; 4113 : 			if (pBuildingEntry && pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()))

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN8@GetTradeRo@2

; 4114 : 			{
; 4115 : 				if (pBuildingEntry->GetTradeRouteSeaDistanceModifier() > 0 && eDomain == DOMAIN_SEA)

	mov	ecx, esi
	call	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
	test	eax, eax
	jle	SHORT $LN3@GetTradeRo@2
	cmp	DWORD PTR _eDomain$[esp+24], 0
	jne	SHORT $LN3@GetTradeRo@2

; 4116 : 				{
; 4117 : 					iRangeModifier += pBuildingEntry->GetTradeRouteSeaDistanceModifier();

	mov	ecx, esi
	call	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
	jmp	SHORT $LN59@GetTradeRo@2
$LN3@GetTradeRo@2:

; 4118 : 				}
; 4119 : 				else if (pBuildingEntry->GetTradeRouteLandDistanceModifier() > 0 && eDomain == DOMAIN_LAND)

	mov	ecx, esi
	call	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
	test	eax, eax
	jle	SHORT $LN8@GetTradeRo@2
	cmp	DWORD PTR _eDomain$[esp+24], 2
	jne	SHORT $LN8@GetTradeRo@2

; 4120 : 				{
; 4121 : 					iRangeModifier += pBuildingEntry->GetTradeRouteLandDistanceModifier();

	mov	ecx, esi
	call	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
$LN59@GetTradeRo@2:
	add	ebp, eax
$LN8@GetTradeRo@2:

; 4094 : 		}
; 4095 : 	}
; 4096 : 	
; 4097 : 	int iRangeModifier = 0;
; 4098 : #ifdef AUI_WARNING_FIXES
; 4099 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4100 : #else
; 4101 : 	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	$LL9@GetTradeRo@2
$LN7@GetTradeRo@2:
	mov	edx, DWORD PTR _iExtendedRange$[esp+28]
	mov	eax, DWORD PTR _iTraitRange$[esp+28]
	lea	ecx, DWORD PTR [edx+eax]

; 4122 : 				}
; 4123 : 			}
; 4124 : 		}
; 4125 : 	}
; 4126 : 
; 4127 : 	iRange = iBaseRange;
; 4128 : 	iRange += iTraitRange;
; 4129 : 	iRange += iExtendedRange;
; 4130 : 	iRange = (iRange * (100 + iRangeModifier)) / 100;
; 4131 : 	return iRange;

	add	ecx, DWORD PTR _iBaseRange$[esp+28]
	add	ebp, 100				; 00000064H
	imul	ecx, ebp
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	ebx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebp

; 4132 : }

	add	esp, 12					; 0000000cH
	ret	8
?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z ENDP ; CvPlayerTrade::GetTradeRouteRange
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
EXTRN	?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetNumTradeRouteBonus
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetFounderBenefitsReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetNumInternationalTradeRoutesChange
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ
_TEXT	SEGMENT
_iNumRoutes$ = -12					; size = 4
_this$ = -8						; size = 4
_iLoop$ = -4						; size = 4
?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ PROC	; CvPlayerTrade::GetNumTradeRoutesPossible, COMDAT
; _this$ = ecx

; 4161 : {

	sub	esp, 12					; 0000000cH
	push	ebp
	mov	ebp, ecx

; 4162 : 	int iNumRoutes = 0;
; 4163 : 
; 4164 : 	CvAssert(m_pPlayer->getCivilizationType() != NO_CIVILIZATION);
; 4165 : 	if (m_pPlayer->getCivilizationType() == NO_CIVILIZATION)

	mov	ecx, DWORD PTR [ebp+79104]
	mov	DWORD PTR _this$[esp+16], ebp
	mov	DWORD PTR _iNumRoutes$[esp+16], 0
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	eax, -1
	jne	SHORT $LN19@GetNumTrad@3

; 4166 : 		return 0;

	xor	eax, eax
	pop	ebp

; 4244 : 
; 4245 : 	return iNumRoutes;
; 4246 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN19@GetNumTrad@3:

; 4167 : 
; 4168 : 	CvPlayerTechs* pMyPlayerTechs = m_pPlayer->GetPlayerTechs();

	mov	ecx, DWORD PTR [ebp+79104]
	push	esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs

; 4169 : 	CvTeamTechs* pMyTeamTechs = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).GetTeamTechs();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	mov	eax, DWORD PTR [ebp+79104]
	mov	ecx, DWORD PTR [eax+44]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN32@GetNumTrad@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN33@GetNumTrad@3
$LN32@GetNumTrad@3:
	or	eax, -1
$LN33@GetNumTrad@3:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	push	edi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs

; 4170 : 	CvTechEntry* pTechInfo = NULL; 
; 4171 : 
; 4172 : 	CvTechXMLEntries* pMyPlayerTechEntries = pMyPlayerTechs->GetTechs();

	mov	ecx, esi
	mov	ebx, eax
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	edi, eax

; 4173 : 	CvAssert(pMyPlayerTechEntries);
; 4174 : 	if (pMyPlayerTechEntries == NULL)

	test	edi, edi
	jne	SHORT $LN18@GetNumTrad@3
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 4244 : 
; 4245 : 	return iNumRoutes;
; 4246 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN18@GetNumTrad@3:

; 4175 : 		return 0;
; 4176 : 
; 4177 : #ifdef AUI_WARNING_FIXES
; 4178 : 	for (uint iTechLoop = 0; iTechLoop < pMyPlayerTechEntries->GetNumTechs(); iTechLoop++)
; 4179 : #else
; 4180 : 	for(int iTechLoop = 0; iTechLoop < pMyPlayerTechEntries->GetNumTechs(); iTechLoop++)

	mov	ecx, edi
	xor	esi, esi
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN15@GetNumTrad@3
	npad	1
$LL17@GetNumTrad@3:

; 4181 : #endif
; 4182 : 	{
; 4183 : 		TechTypes eTech = (TechTypes)iTechLoop;
; 4184 : 		if (!pMyTeamTechs->HasTech(eTech))

	push	esi
	mov	ecx, ebx
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN16@GetNumTrad@3

; 4185 : 		{
; 4186 : 			continue;
; 4187 : 		}
; 4188 : 
; 4189 : 		pTechInfo = pMyPlayerTechEntries->GetEntry(eTech);

	push	esi
	mov	ecx, edi
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry

; 4190 : 		CvAssertMsg(pTechInfo, "null tech entry");
; 4191 : 		if (pTechInfo)

	test	eax, eax
	je	SHORT $LN16@GetNumTrad@3

; 4192 : 		{
; 4193 : 			iNumRoutes += pTechInfo->GetNumInternationalTradeRoutesChange();

	mov	ecx, eax
	call	?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetNumInternationalTradeRoutesChange
	add	DWORD PTR _iNumRoutes$[esp+28], eax
$LN16@GetNumTrad@3:
	mov	ecx, edi
	inc	esi
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL17@GetNumTrad@3
$LN15@GetNumTrad@3:

; 4194 : 		}
; 4195 : 	}
; 4196 : 
; 4197 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 4198 : 	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebp+79104]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetFounderBenefitsReligion

; 4199 : 	if (eFoundedReligion && eFoundedReligion != NO_RELIGION)

	test	eax, eax
	je	SHORT $LN12@GetNumTrad@3
	cmp	eax, -1
	je	SHORT $LN12@GetNumTrad@3

; 4200 : 	{
; 4201 : 		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFoundedReligion, NO_PLAYER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	-1
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 4202 : 		iNumRoutes += pReligion->m_Beliefs.GetExtraTradeRoutes();

	mov	ecx, DWORD PTR [eax+224]
	add	DWORD PTR _iNumRoutes$[esp+28], ecx
$LN12@GetNumTrad@3:

; 4203 : 	}
; 4204 : #endif
; 4205 : 
; 4206 : 	CvCivilizationInfo& kCivInfo = m_pPlayer->getCivilizationInfo();

	mov	ecx, DWORD PTR [ebp+79104]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4207 : 	int iLoop = 0;
; 4208 : 	CvCity* pLoopCity;
; 4209 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	esi, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [esi+79104]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+32]
	push	edx
	mov	ebp, eax
	mov	DWORD PTR _iLoop$[esp+36], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN9@GetNumTrad@3
	npad	8
$LL61@GetNumTrad@3:

; 4210 : 	{
; 4211 : #ifdef AUI_WARNING_FIXES
; 4212 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4213 : #else
; 4214 : 		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN10@GetNumTrad@3
$LL8@GetNumTrad@3:

; 4215 : #endif
; 4216 : 		{
; 4217 : 			BuildingTypes eBuilding = (BuildingTypes)kCivInfo.getCivilizationBuildings(iI);

	push	edi
	mov	ecx, ebp
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 4218 : 			if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN7@GetNumTrad@3

; 4219 : 			{
; 4220 : 				CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	esi, eax

; 4221 : 				if (!pBuildingEntry)

	test	esi, esi
	je	SHORT $LN7@GetNumTrad@3

; 4222 : 				{
; 4223 : 					continue;
; 4224 : 				}
; 4225 : 
; 4226 : 				if (pBuildingEntry)
; 4227 : 				{
; 4228 : 					if (pLoopCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()))

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN7@GetNumTrad@3

; 4229 : 					{
; 4230 : 						int iNumRouteBonus = pBuildingEntry->GetNumTradeRouteBonus();

	mov	ecx, esi
	call	?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetNumTradeRouteBonus

; 4231 : 						if (iNumRouteBonus != 0)

	test	eax, eax
	je	SHORT $LN7@GetNumTrad@3

; 4232 : 						{
; 4233 : 							iNumRoutes += iNumRouteBonus;

	add	DWORD PTR _iNumRoutes$[esp+28], eax
$LN7@GetNumTrad@3:

; 4210 : 	{
; 4211 : #ifdef AUI_WARNING_FIXES
; 4212 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4213 : #else
; 4214 : 		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL8@GetNumTrad@3
	mov	esi, DWORD PTR _this$[esp+28]
$LN10@GetNumTrad@3:

; 4207 : 	int iLoop = 0;
; 4208 : 	CvCity* pLoopCity;
; 4209 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+79104]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+32]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL61@GetNumTrad@3
$LN9@GetNumTrad@3:

; 4234 : 						}
; 4235 : 					}
; 4236 : 				}
; 4237 : 			}
; 4238 : 		}
; 4239 : 	}
; 4240 : 
; 4241 : 	int iModifier = 100 + m_pPlayer->GetPlayerTraits()->GetNumTradeRoutesModifier();

	mov	ecx, DWORD PTR [esi+79104]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [eax+292]
	add	ecx, 100				; 00000064H

; 4242 : 	iNumRoutes *= iModifier;

	imul	ecx, DWORD PTR _iNumRoutes$[esp+28]

; 4243 : 	iNumRoutes /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	ebx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebp

; 4244 : 
; 4245 : 	return iNumRoutes;
; 4246 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ENDP	; CvPlayerTrade::GetNumTradeRoutesPossible
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesRemaining
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z
_TEXT	SEGMENT
_bContinueTraining$ = 8					; size = 1
?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z PROC ; CvPlayerTrade::GetNumTradeRoutesRemaining, COMDAT
; _this$ = ecx

; 4289 : 	return (GetNumTradeRoutesPossible() - GetNumTradeRoutesUsed(bContinueTraining));

	mov	eax, DWORD PTR _bContinueTraining$[esp-4]
	push	esi
	push	edi
	push	eax
	mov	esi, ecx
	call	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesUsed
	mov	ecx, esi
	mov	edi, eax
	call	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
	sub	eax, edi
	pop	edi
	pop	esi

; 4290 : }

	ret	4
?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ENDP ; CvPlayerTrade::GetNumTradeRoutesRemaining
_TEXT	ENDS
PUBLIC	??1CvTradeAI@@QAE@XZ				; CvTradeAI::~CvTradeAI
; Function compile flags: /Ogtpy
;	COMDAT ??1CvTradeAI@@QAE@XZ
_TEXT	SEGMENT
??1CvTradeAI@@QAE@XZ PROC				; CvTradeAI::~CvTradeAI, COMDAT
; _this$ = ecx

; 4932 : 	Uninit();

	mov	DWORD PTR [ecx+4], 0

; 4933 : }

	ret	0
??1CvTradeAI@@QAE@XZ ENDP				; CvTradeAI::~CvTradeAI
_TEXT	ENDS
PUBLIC	?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z ; CvTradeAI::ScoreInternationalTR
EXTRN	?GetTourism@CvPlayerCulture@@QAEHXZ:PROC	; CvPlayerCulture::GetTourism
EXTRN	?WouldExertTradeRoutePressureToward@CvCityReligions@@QAE_NPAVCvCity@@AAW4ReligionTypes@@AAH@Z:PROC ; CvCityReligions::WouldExertTradeRoutePressureToward
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z
_TEXT	SEGMENT
_iDangerSum$ = -36					; size = 4
_this$ = -32						; size = 4
_iToPressure$222905 = -28				; size = 4
_pOtherPlayerTrade$ = -28				; size = 4
_iFromPressure$222907 = -24				; size = 4
_eToReligion$222904 = -20				; size = 4
_eFromReligion$222906 = -16				; size = 4
_iGoldDelta$ = -12					; size = 4
_iGoldAmount$ = -12					; size = 4
_pPlayerTrade$ = -12					; size = 4
_eOwnerFoundedReligion$ = -8				; size = 4
_iTechDelta$ = -4					; size = 4
_iTheirBuildingBonus$236923 = 8				; size = 4
_iReligionDelta$ = 8					; size = 4
_uiPlotList$222881 = 8					; size = 4
_kTradeConnection$ = 8					; size = 4
?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z PROC ; CvTradeAI::ScoreInternationalTR, COMDAT
; _this$ = ecx

; 5071 : {

	sub	esp, 36					; 00000024H
	push	esi
	push	edi

; 5072 : 	// don't evaluate other trade types
; 5073 : 	if (kTradeConnection.m_eConnectionType != TRADE_CONNECTION_INTERNATIONAL)

	mov	edi, DWORD PTR _kTradeConnection$[esp+40]
	cmp	DWORD PTR [edi+32], 0
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+44], esi
	je	SHORT $LN19@ScoreInter
$LN639@ScoreInter:
	pop	edi

; 5074 : 	{
; 5075 : 		return 0;

	xor	eax, eax
	pop	esi

; 5187 : }

	add	esp, 36					; 00000024H
	ret	4
$LN19@ScoreInter:

; 5076 : 	}
; 5077 : 
; 5078 : 	// if this was recently plundered, 0 the score
; 5079 : 	if (m_pPlayer->GetTrade()->CheckTradeConnectionWasPlundered(kTradeConnection))

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
	test	al, al

; 5080 : 	{
; 5081 : 		return 0;

	jne	SHORT $LN639@ScoreInter

; 5082 : 	}
; 5083 : 
; 5084 : 	CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	ebp
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade

; 5085 : 	CvPlayerTrade* pOtherPlayerTrade = GET_PLAYER(kTradeConnection.m_eDestOwner).GetTrade();

	mov	ecx, DWORD PTR [edi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pPlayerTrade$[esp+52], eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade

; 5086 : 	int iDangerSum = 1; // can't be zero because we divide by zero!
; 5087 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	cmp	DWORD PTR [edi+48], 0
	mov	DWORD PTR _pOtherPlayerTrade$[esp+52], eax
	mov	DWORD PTR _iDangerSum$[esp+52], 1
	mov	DWORD PTR _uiPlotList$222881[esp+48], 0
	jbe	$LN634@ScoreInter
$LL629@ScoreInter:
	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR _uiPlotList$222881[esp+48]

; 5088 : 	{
; 5089 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

	mov	ebp, DWORD PTR [eax+ecx*8+4]
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2147483647			; 80000001H
	je	$LN634@ScoreInter
	cmp	ebp, -2147483647			; 80000001H
	je	$LN634@ScoreInter
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ebx, DWORD PTR [edx+4020]
	je	SHORT $LN42@ScoreInter
	test	eax, eax
	jge	SHORT $LN44@ScoreInter
	cdq
	idiv	ebx
	mov	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebx
	jmp	SHORT $LN46@ScoreInter
$LN44@ScoreInter:
	cmp	eax, ebx
	jl	SHORT $LN42@ScoreInter
	cdq
	idiv	ebx
	mov	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN46@ScoreInter
$LN42@ScoreInter:
	mov	ecx, eax
$LN46@ScoreInter:
	cmp	BYTE PTR [edx+4057], 0
	mov	esi, DWORD PTR [edx+4024]
	je	SHORT $LN630@ScoreInter
	test	ebp, ebp
	jge	SHORT $LN54@ScoreInter
	mov	eax, ebp
	cdq
	idiv	esi
	add	edx, esi
	jmp	SHORT $LN56@ScoreInter
$LN54@ScoreInter:
	cmp	ebp, esi
	jl	SHORT $LN630@ScoreInter
	mov	eax, ebp
	cdq
	idiv	esi
	jmp	SHORT $LN56@ScoreInter
$LN630@ScoreInter:
	mov	edx, ebp
$LN56@ScoreInter:
	test	ecx, ecx
	jl	$LN634@ScoreInter
	cmp	ecx, ebx
	jge	$LN634@ScoreInter
	test	edx, edx
	jl	$LN634@ScoreInter
	cmp	edx, esi
	jge	$LN634@ScoreInter
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	edx, ebx
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	add	edx, DWORD PTR [eax+4068]
	mov	esi, edx

; 5090 : 		CvAssertMsg(pPlot, "pPlot is null when trying to evaluate the list");
; 5091 : 		if (pPlot == NULL)

	je	$LN634@ScoreInter

; 5092 : 		{
; 5093 : 			break;
; 5094 : 		}
; 5095 : 		int iDangerValue = m_pPlayer->GetPlotDanger(*pPlot);

	mov	ebx, DWORD PTR _this$[esp+52]
	mov	ecx, DWORD PTR [ebx+4]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	ebp, eax

; 5096 : 		if (iDangerValue == 0)

	test	ebp, ebp
	jne	$LN633@ScoreInter

; 5097 : 		{
; 5098 : 			if (!pPlot->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	ebx, 63					; 0000003fH
	ja	SHORT $LN631@ScoreInter
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+ebx*4]
	cmp	eax, -1
	je	SHORT $LN631@ScoreInter
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+eax*2], bp
	setg	al
	test	al, al
	jne	SHORT $LN632@ScoreInter
$LN631@ScoreInter:

; 5099 : 			{
; 5100 : 				iDangerValue += 1;

	mov	ebp, 1
$LN632@ScoreInter:

; 5101 : 			}
; 5102 : 
; 5103 : 			if (pPlot->getTeam() != NO_TEAM && GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN633@ScoreInter
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN633@ScoreInter
	mov	ecx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+eax*4], -1
	je	SHORT $LN633@ScoreInter
	cmp	eax, -1
	je	SHORT $LN98@ScoreInter
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN105@ScoreInter
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, eax
	jmp	SHORT $LN97@ScoreInter
$LN105@ScoreInter:
	or	eax, -1
	mov	edx, eax
	jmp	SHORT $LN97@ScoreInter
$LN98@ScoreInter:
	or	edx, -1
$LN97@ScoreInter:
	cmp	ebx, 63					; 0000003fH
	ja	SHORT $LN114@ScoreInter
	mov	eax, DWORD PTR [ecx+ebx*4]
	jmp	SHORT $LN115@ScoreInter
$LN114@ScoreInter:
	or	eax, -1
$LN115@ScoreInter:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN633@ScoreInter

; 5104 : 			{
; 5105 : 				iDangerValue += 1000;

	add	ebp, 1000				; 000003e8H
$LN633@ScoreInter:

; 5086 : 	int iDangerSum = 1; // can't be zero because we divide by zero!
; 5087 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	eax, DWORD PTR _uiPlotList$222881[esp+48]

; 5106 : 			}
; 5107 : 		}
; 5108 : 		iDangerSum += iDangerValue;

	add	DWORD PTR _iDangerSum$[esp+52], ebp
	inc	eax
	mov	DWORD PTR _uiPlotList$222881[esp+48], eax
	cmp	eax, DWORD PTR [edi+48]
	jb	$LL629@ScoreInter
$LN634@ScoreInter:

; 5109 : 	}
; 5110 : 
; 5111 : 	// gold
; 5112 : 	int iGoldAmount = pPlayerTrade->GetTradeConnectionValueTimes100(kTradeConnection, YIELD_GOLD, true);

	mov	ecx, DWORD PTR _pPlayerTrade$[esp+52]
	push	1
	push	2
	push	edi
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100

; 5113 : 	int iOtherGoldAmount = pOtherPlayerTrade->GetTradeConnectionValueTimes100(kTradeConnection, YIELD_GOLD, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	mov	DWORD PTR _iGoldAmount$[esp+52], ebx
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	push	edi
	mov	ecx, eax
	xor	esi, esi
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	test	al, al
	je	$LN135@ScoreInter
	mov	ecx, DWORD PTR _pOtherPlayerTrade$[esp+52]
	mov	eax, DWORD PTR [ecx+79104]
	mov	edx, DWORD PTR [edi+24]
	cmp	edx, DWORD PTR [eax+44]
	jne	$LN122@ScoreInter
	push	esi
	push	2
	push	edi
	call	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
	mov	ecx, DWORD PTR _pOtherPlayerTrade$[esp+52]
	push	esi
	push	2
	push	edi
	mov	ebp, eax
	call	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+28]
	mov	DWORD PTR _iTheirBuildingBonus$236923[esp+48], eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	neg	esi
	sbb	esi, esi
	and	esi, -100				; ffffff9cH
	add	esi, 100				; 00000064H
	xor	ebx, ebx
	cmp	DWORD PTR [edi+28], 2
	jne	SHORT $LN502@ScoreInter
	push	edi
	call	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
	add	esp, 4
	test	eax, eax
	je	SHORT $LN502@ScoreInter
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	BYTE PTR [eax+457], bl
	jle	SHORT $LN502@ScoreInter
	mov	ebx, 25					; 00000019H
$LN502@ScoreInter:
	mov	eax, DWORD PTR _iTheirBuildingBonus$236923[esp+48]
	lea	edx, DWORD PTR [ebx+esi+100]
	lea	ecx, DWORD PTR [eax+ebp+100]
	mov	ebx, DWORD PTR _iGoldAmount$[esp+52]
	imul	ecx, edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	jmp	SHORT $LN122@ScoreInter
$LN135@ScoreInter:
	mov	ecx, DWORD PTR [edi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	67					; 00000043H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	esi, eax
$LN122@ScoreInter:

; 5114 : 	int iGoldDelta = iGoldAmount - iOtherGoldAmount;

	sub	ebx, esi
	mov	DWORD PTR _iGoldDelta$[esp+52], ebx

; 5115 : 
; 5116 : 	// getting out of a logjam at the beginning of the game on an archepeligo map
; 5117 : 	// if the player has made a trade unit but all the trade routes yields will be negative to the player
; 5118 : 	// still try to trade with some of the minor civs
; 5119 : 	if (iGoldDelta <= 0 && GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv())

	test	ebx, ebx
	jg	SHORT $LN10@ScoreInter
	mov	ecx, DWORD PTR [edi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN10@ScoreInter

; 5120 : 	{
; 5121 : 		iGoldDelta = 1;

	mov	DWORD PTR _iGoldDelta$[esp+52], 1
$LN10@ScoreInter:

; 5122 : 	}
; 5123 : 
; 5124 : 	// tech
; 5125 : 	int iTechDifferenceP1fromP2 = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eOriginOwner, kTradeConnection.m_eDestOwner);

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+20]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference

; 5126 : 	int iTechDifferenceP2fromP1 = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eDestOwner,   kTradeConnection.m_eOriginOwner);

	mov	edx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	mov	eax, DWORD PTR [edi+24]
	push	edx
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference

; 5127 : 	int iTechDelta = iTechDifferenceP1fromP2 - iTechDifferenceP2fromP1;
; 5128 : 
; 5129 : 	// religion
; 5130 : 	ReligionTypes eOwnerFoundedReligion = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[esp+52]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sub	esi, eax
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	DWORD PTR _iTechDelta$[esp+56], esi
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer

; 5131 : 	int iReligionDelta = 0;
; 5132 : 	if (eOwnerFoundedReligion != NO_RELIGION)

	or	ebx, -1
	mov	DWORD PTR _eOwnerFoundedReligion$[esp+52], eax
	mov	DWORD PTR _iReligionDelta$[esp+48], 0
	cmp	eax, ebx
	je	$LN628@ScoreInter

; 5133 : 	{
; 5134 : 		CvCity* pToCity = CvGameTrade::GetDestCity(kTradeConnection);

	push	edi
	call	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity

; 5135 : 		CvCity* pFromCity = CvGameTrade::GetOriginCity(kTradeConnection);

	push	edi
	mov	ebp, eax
	call	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
	mov	esi, eax

; 5136 : 		CvAssert(pToCity != NULL && pFromCity != NULL);
; 5137 : 		if (pToCity != NULL && pFromCity != NULL)

	xor	eax, eax
	add	esp, 8
	cmp	ebp, eax
	je	$LN628@ScoreInter
	cmp	esi, eax
	je	$LN628@ScoreInter

; 5138 : 		{
; 5139 : 			ReligionTypes eToReligion = NO_RELIGION;
; 5140 : 			int iToPressure = 0;

	mov	DWORD PTR _iToPressure$222905[esp+52], eax

; 5141 : 			ReligionTypes eFromReligion = NO_RELIGION;
; 5142 : 			int iFromPressure = 0;

	mov	DWORD PTR _iFromPressure$222907[esp+52], eax

; 5143 : 			bool bAnyFromCityPressure = pFromCity->GetCityReligions()->WouldExertTradeRoutePressureToward(pToCity, eToReligion, iToPressure);

	lea	eax, DWORD PTR _iToPressure$222905[esp+52]
	push	eax
	lea	ecx, DWORD PTR _eToReligion$222904[esp+56]
	push	ecx
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _eToReligion$222904[esp+64], ebx
	mov	DWORD PTR _eFromReligion$222906[esp+64], ebx
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?WouldExertTradeRoutePressureToward@CvCityReligions@@QAE_NPAVCvCity@@AAW4ReligionTypes@@AAH@Z ; CvCityReligions::WouldExertTradeRoutePressureToward

; 5144 : 			bool bAnyToCityPressure = pToCity->GetCityReligions()->WouldExertTradeRoutePressureToward(pFromCity, eFromReligion, iFromPressure);

	lea	edx, DWORD PTR _iFromPressure$222907[esp+52]
	mov	bl, al
	push	edx
	lea	eax, DWORD PTR _eFromReligion$222906[esp+56]
	push	eax
	push	esi
	mov	ecx, ebp
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?WouldExertTradeRoutePressureToward@CvCityReligions@@QAE_NPAVCvCity@@AAW4ReligionTypes@@AAH@Z ; CvCityReligions::WouldExertTradeRoutePressureToward

; 5145 : 
; 5146 : 			// Internally pressure is now 10 times greater than what is shown to user
; 5147 : 			iToPressure /= GC.getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7900
	mov	cl, al
	mov	eax, DWORD PTR _iToPressure$222905[esp+52]
	cdq
	idiv	esi
	mov	ebp, eax

; 5148 : 			iFromPressure /= GC.getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER();

	mov	eax, DWORD PTR _iFromPressure$222907[esp+52]
	cdq
	idiv	esi

; 5149 : 
; 5150 : 			// if anyone is exerting pressure
; 5151 : 			if (bAnyFromCityPressure || bAnyToCityPressure)

	test	bl, bl
	jne	SHORT $LN6@ScoreInter
	test	cl, cl
	je	SHORT $LN628@ScoreInter
$LN6@ScoreInter:

; 5152 : 			{
; 5153 : 				// "to" and "from" religions need to be different for us to care
; 5154 : 				if (eToReligion != eFromReligion)

	mov	ecx, DWORD PTR _eToReligion$222904[esp+52]
	mov	esi, DWORD PTR _eFromReligion$222906[esp+52]
	cmp	ecx, esi
	je	SHORT $LN628@ScoreInter

; 5155 : 				{
; 5156 : 					if (eToReligion == eOwnerFoundedReligion)

	mov	edx, DWORD PTR _eOwnerFoundedReligion$[esp+52]
	cmp	ecx, edx
	jne	SHORT $LN4@ScoreInter

; 5157 : 					{
; 5158 : 						iReligionDelta += iToPressure;

	mov	DWORD PTR _iReligionDelta$[esp+48], ebp
$LN4@ScoreInter:

; 5159 : 					}
; 5160 : 
; 5161 : 					if (eFromReligion != eOwnerFoundedReligion)

	cmp	esi, edx
	je	SHORT $LN628@ScoreInter

; 5162 : 					{
; 5163 : 						iReligionDelta -= iFromPressure;

	sub	DWORD PTR _iReligionDelta$[esp+48], eax
$LN628@ScoreInter:

; 5164 : 					}
; 5165 : 				}
; 5166 : 			}
; 5167 : 		}
; 5168 : 	}
; 5169 : 
; 5170 : 	int iScore = 0;
; 5171 : 	iScore += iGoldDelta;
; 5172 : 	iScore += iTechDelta * 3; // 3 science = 1 gold
; 5173 : 	iScore += iReligionDelta * 2; // 2 religion = 1 gold
; 5174 : 	iScore = (iScore * 10) / iDangerSum;

	mov	eax, DWORD PTR _iTechDelta$[esp+52]
	mov	ecx, DWORD PTR _iGoldDelta$[esp+52]
	lea	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _iReligionDelta$[esp+48]
	lea	eax, DWORD PTR [edx+eax*2]
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR _iDangerSum$[esp+52]

; 5175 : 	
; 5176 : 	// if we have any tourism and the destination owner is not a minor civ
; 5177 : 	if (m_pPlayer->GetCulture()->GetTourism() > 0 && !GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv())

	mov	ebx, DWORD PTR _this$[esp+52]
	mov	ecx, DWORD PTR [ebx+4]
	mov	esi, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	test	eax, eax
	jle	SHORT $LN1@ScoreInter
	mov	ecx, DWORD PTR [edi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN1@ScoreInter

; 5178 : 	{
; 5179 : 		// if we're not connected to a player, double the value to that player
; 5180 : 		if (!GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), kTradeConnection.m_eDestOwner))

	mov	ecx, DWORD PTR [edi+24]
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	jne	SHORT $LN1@ScoreInter

; 5181 : 		{
; 5182 : 			iScore *= 2;

	add	esi, esi
$LN1@ScoreInter:
	pop	ebp
	pop	ebx
	pop	edi

; 5183 : 		}
; 5184 : 	}
; 5185 : 
; 5186 : 	return iScore;

	mov	eax, esi
	pop	esi

; 5187 : }

	add	esp, 36					; 00000024H
	ret	4
?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z ENDP ; CvTradeAI::ScoreInternationalTR
_TEXT	ENDS
PUBLIC	?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z ; CvTradeAI::ScoreFoodTR
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z
_TEXT	SEGMENT
_iDangerSum$ = -12					; size = 4
_iDistanceScore$ = -8					; size = 4
_this$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_uiPlotList$222931 = 12					; size = 4
_pSmallestCity$ = 12					; size = 4
?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z PROC ; CvTradeAI::ScoreFoodTR, COMDAT
; _this$ = ecx

; 5195 : {

	sub	esp, 12					; 0000000cH
	push	esi

; 5196 : 	if (kTradeConnection.m_eConnectionType != TRADE_CONNECTION_FOOD)

	mov	esi, DWORD PTR _kTradeConnection$[esp+12]
	push	edi
	mov	edi, 1
	mov	DWORD PTR _this$[esp+20], ecx
	cmp	DWORD PTR [esi+32], edi
	je	SHORT $LN11@ScoreFoodT
$LN134@ScoreFoodT:
	pop	edi

; 5197 : 	{
; 5198 : 		return 0;

	xor	eax, eax
	pop	esi

; 5248 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN11@ScoreFoodT:

; 5199 : 	}
; 5200 : 
; 5201 : 	// if this was recently plundered, 0 the score
; 5202 : 	if (m_pPlayer->GetTrade()->CheckTradeConnectionWasPlundered(kTradeConnection))

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
	test	al, al

; 5203 : 	{
; 5204 : 		return 0;

	jne	SHORT $LN134@ScoreFoodT

; 5205 : 	}
; 5206 : 
; 5207 : 	// if we're not going to the smallest city, ignore
; 5208 : 	if (kTradeConnection.m_iDestX != pSmallestCity->getX() && kTradeConnection.m_iDestY != pSmallestCity->getY())

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _pSmallestCity$[esp+16]
	cmp	ecx, DWORD PTR [eax+96]
	je	SHORT $LN9@ScoreFoodT
	mov	edx, DWORD PTR [esi+16]
	cmp	edx, DWORD PTR [eax+108]

; 5209 : 	{
; 5210 : 		return 0;

	jne	SHORT $LN134@ScoreFoodT
$LN9@ScoreFoodT:

; 5211 : 	}
; 5212 : 
; 5213 : 	int iMaxDistance = 60;
; 5214 : 	int iDistance = kTradeConnection.m_aPlotList.size();

	mov	eax, DWORD PTR [esi+48]

; 5215 : 	int iDistanceScore = iMaxDistance - iDistance;

	mov	ecx, 60					; 0000003cH
	sub	ecx, eax

; 5216 : 	if (kTradeConnection.m_eDomain == DOMAIN_SEA)

	cmp	DWORD PTR [esi+28], 0
	mov	DWORD PTR _iDistanceScore$[esp+20], ecx
	jne	SHORT $LN8@ScoreFoodT

; 5217 : 	{
; 5218 : 		iDistanceScore = iDistanceScore * 2;

	add	ecx, ecx
	mov	DWORD PTR _iDistanceScore$[esp+20], ecx
$LN8@ScoreFoodT:

; 5219 : 	}
; 5220 : 
; 5221 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5222 : 	int iDangerSum = 1; // can't be zero because we divide by zero!

	mov	DWORD PTR _iDangerSum$[esp+20], edi

; 5223 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	DWORD PTR _uiPlotList$222931[esp+16], 0
	test	eax, eax
	jbe	$LN131@ScoreFoodT
	push	ebx
	push	ebp
	jmp	SHORT $LN7@ScoreFoodT
	npad	5
$LL127@ScoreFoodT:
	mov	esi, ecx
$LN7@ScoreFoodT:
	mov	edx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR _uiPlotList$222931[esp+24]

; 5224 : 	{
; 5225 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

	mov	ebx, DWORD PTR [edx+eax*8+4]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2147483647			; 80000001H
	je	$LN132@ScoreFoodT
	cmp	ebx, -2147483647			; 80000001H
	je	$LN132@ScoreFoodT
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN42@ScoreFoodT
	test	eax, eax
	jge	SHORT $LN44@ScoreFoodT
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN46@ScoreFoodT
$LN44@ScoreFoodT:
	cmp	eax, ecx
	jl	SHORT $LN42@ScoreFoodT
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN46@ScoreFoodT
$LN42@ScoreFoodT:
	mov	esi, eax
$LN46@ScoreFoodT:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN52@ScoreFoodT
	test	ebx, ebx
	jge	SHORT $LN54@ScoreFoodT
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN56@ScoreFoodT
$LN54@ScoreFoodT:
	cmp	ebx, edi
	jl	SHORT $LN52@ScoreFoodT
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN56@ScoreFoodT
$LN52@ScoreFoodT:
	mov	edx, ebx
$LN56@ScoreFoodT:
	test	esi, esi
	jl	$LN132@ScoreFoodT
	cmp	esi, ecx
	jge	$LN132@ScoreFoodT
	test	edx, edx
	jl	$LN132@ScoreFoodT
	cmp	edx, edi
	jge	$LN132@ScoreFoodT
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx

; 5226 : 		CvAssertMsg(pPlot, "pPlot is null when trying to evaluate the list");
; 5227 : 		if (pPlot == NULL)

	je	$LN132@ScoreFoodT

; 5228 : 		{
; 5229 : 			break;
; 5230 : 		}
; 5231 : 		int iDangerValue = m_pPlayer->GetPlotDanger(*pPlot);

	mov	edi, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	ebx, eax

; 5232 : 		if (iDangerValue == 0)

	test	ebx, ebx
	jne	$LN130@ScoreFoodT

; 5233 : 		{
; 5234 : 			if (!pPlot->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN128@ScoreFoodT
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+edi*4]
	cmp	eax, -1
	je	SHORT $LN128@ScoreFoodT
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+eax*2], bx
	setg	al
	test	al, al
	jne	SHORT $LN129@ScoreFoodT
$LN128@ScoreFoodT:

; 5235 : 			{
; 5236 : 				iDangerValue += 1;

	mov	ebx, 1
$LN129@ScoreFoodT:

; 5237 : 			}
; 5238 : 
; 5239 : 			if (pPlot->getTeam() != NO_TEAM && GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN130@ScoreFoodT
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN130@ScoreFoodT
	mov	ecx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+eax*4], -1
	je	SHORT $LN130@ScoreFoodT
	cmp	eax, -1
	je	SHORT $LN98@ScoreFoodT
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN105@ScoreFoodT
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, eax
	jmp	SHORT $LN97@ScoreFoodT
$LN105@ScoreFoodT:
	or	eax, -1
	mov	edx, eax
	jmp	SHORT $LN97@ScoreFoodT
$LN98@ScoreFoodT:
	or	edx, -1
$LN97@ScoreFoodT:
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN114@ScoreFoodT
	mov	eax, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN115@ScoreFoodT
$LN114@ScoreFoodT:
	or	eax, -1
$LN115@ScoreFoodT:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN130@ScoreFoodT

; 5240 : 			{
; 5241 : 				iDangerValue += 1000;

	add	ebx, 1000				; 000003e8H
$LN130@ScoreFoodT:

; 5223 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	eax, DWORD PTR _uiPlotList$222931[esp+24]
	mov	ecx, DWORD PTR _kTradeConnection$[esp+24]

; 5242 : 			}
; 5243 : 		}
; 5244 : 		iDangerSum += iDangerValue;

	add	DWORD PTR _iDangerSum$[esp+28], ebx
	inc	eax
	mov	DWORD PTR _uiPlotList$222931[esp+24], eax
	cmp	eax, DWORD PTR [ecx+48]
	jb	$LL127@ScoreFoodT
$LN132@ScoreFoodT:
	pop	ebp
	pop	ebx
$LN131@ScoreFoodT:

; 5245 : 	}
; 5246 : 
; 5247 : 	return iDistanceScore - iDangerSum;

	mov	eax, DWORD PTR _iDistanceScore$[esp+20]
	sub	eax, DWORD PTR _iDangerSum$[esp+20]
	pop	edi
	pop	esi

; 5248 : }

	add	esp, 12					; 0000000cH
	ret	8
?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z ENDP ; CvTradeAI::ScoreFoodTR
_TEXT	ENDS
PUBLIC	?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::ChooseTradeUnitTargetPlot
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?canMakeTradeRouteAt@CvUnit@@QBE_NPBVCvPlot@@HHW4TradeConnectionType@@@Z:PROC ; CvUnit::canMakeTradeRouteAt
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_pPlot$223577 = -28					; size = 4
_uiNumDuplicateTRs$ = -28				; size = 4
tv596 = -24						; size = 4
_ui$223570 = -24					; size = 4
_pkTradeAI$ = -20					; size = 4
tv1053 = -16						; size = 4
tv648 = -12						; size = 4
_iLoop$237745 = -8					; size = 4
_uiNumTradeRoutesPossible$ = -4				; size = 4
_pUnit$ = 8						; size = 4
_iOriginPlotIndex$ = 12					; size = 4
_iDestPlotIndex$ = 16					; size = 4
_eTradeConnectionType$ = 20				; size = 4
_bDisband$ = 24						; size = 4
_aTradeConnections$ = 28				; size = 4
?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z PROC ; CvTradeAI::ChooseTradeUnitTargetPlot, COMDAT
; _this$ = ecx

; 5541 : 	// clearing the returned data
; 5542 : 	iOriginPlotIndex = MAX_INT;

	mov	eax, DWORD PTR _iOriginPlotIndex$[esp-4]

; 5543 : 	iDestPlotIndex = MAX_INT;
; 5544 : 	eTradeConnectionType = NUM_TRADE_CONNECTION_TYPES;

	mov	edx, DWORD PTR _eTradeConnectionType$[esp-4]
	sub	esp, 28					; 0000001cH
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _iDestPlotIndex$[esp+28]
	mov	DWORD PTR [eax], 2147483647		; 7fffffffH

; 5545 : 	bDisband = false;

	mov	eax, DWORD PTR _bDisband$[esp+28]
	mov	DWORD PTR [ecx], 2147483647		; 7fffffffH

; 5546 : 
; 5547 : 	CvCity* pOriginCity = pUnit->plot()->getPlotCity();

	mov	ecx, DWORD PTR _pUnit$[esp+28]
	mov	DWORD PTR [edx], 3
	mov	BYTE PTR [eax], 0
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN167@ChooseTrad
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN167@ChooseTrad
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 5548 : 	CvAssertMsg(pOriginCity, "pOriginCity is null! Whaa?");
; 5549 : 	if (!pOriginCity)

	test	eax, eax
	jne	SHORT $LN15@ChooseTrad
$LN167@ChooseTrad:

; 5550 : 	{
; 5551 : 		return false;

	xor	al, al
	pop	esi

; 5638 : }

	add	esp, 28					; 0000001cH
	ret	24					; 00000018H
$LN15@ChooseTrad:

; 5552 : 	}
; 5553 : 
; 5554 : 	CvPlayerTrade* pkTradeAI = m_pPlayer->GetTrade();

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	ebp
	push	edi
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade

; 5555 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5556 : 	uint uiNumDuplicateTRs = 0;
; 5557 : 	uint uiNumTradeRoutesPossible =  pkTradeAI->GetNumTradeRoutesPossible();

	mov	ecx, eax
	mov	DWORD PTR _pkTradeAI$[esp+44], eax
	mov	DWORD PTR _uiNumDuplicateTRs$[esp+44], 0
	call	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
	mov	ebp, eax

; 5558 : #ifdef AUI_ITERATORIZE
; 5559 : 	const TradeConnectionList::const_iterator pNoMoreTradeRoutesPossible = aTradeConnections.begin() + uiNumTradeRoutesPossible;
; 5560 : 	for (TradeConnectionList::const_iterator it = aTradeConnections.begin(); it != aTradeConnections.end() && it < pNoMoreTradeRoutesPossible; ++it)
; 5561 : 	{
; 5562 : 		for (TradeConnectionList::const_iterator it2 = it + 1; it2 != aTradeConnections.end() && it2 < pNoMoreTradeRoutesPossible; ++it2)
; 5563 : 		{
; 5564 : 			if (it->m_iOriginX == it2->m_iOriginX &&
; 5565 : 				it->m_iOriginY == it2->m_iOriginY &&
; 5566 : 				it->m_iDestX == it2->m_iDestX &&
; 5567 : 				it->m_iDestY == it2->m_iDestY &&
; 5568 : 				it->m_eConnectionType == it2->m_eConnectionType)
; 5569 : #else
; 5570 : 	uint uiNumTradeConnections = aTradeConnections.size();

	mov	eax, DWORD PTR _aTradeConnections$[esp+40]
	mov	ebx, DWORD PTR [eax+4]

; 5571 : 
; 5572 : 	for (uint ui = 0; ui < uiNumTradeRoutesPossible && ui < uiNumTradeConnections; ui++)

	xor	eax, eax
	mov	DWORD PTR _uiNumTradeRoutesPossible$[esp+44], ebp
	mov	DWORD PTR tv596[esp+44], ebx
	test	ebp, ebp
	jbe	SHORT $LN12@ChooseTrad

; 5552 : 	}
; 5553 : 
; 5554 : 	CvPlayerTrade* pkTradeAI = m_pPlayer->GetTrade();

	xor	edx, edx
	npad	7
$LL177@ChooseTrad:

; 5571 : 
; 5572 : 	for (uint ui = 0; ui < uiNumTradeRoutesPossible && ui < uiNumTradeConnections; ui++)

	cmp	eax, ebx
	jae	SHORT $LN12@ChooseTrad

; 5573 : 	{
; 5574 : 		for (uint ui2 = ui + 1;  ui2 < uiNumTradeRoutesPossible && ui2 < uiNumTradeConnections; ui2++)

	lea	edi, DWORD PTR [eax+1]
	mov	esi, edi
	cmp	edi, ebp
	jae	SHORT $LN13@ChooseTrad
	lea	ecx, DWORD PTR [edx+444]
$LL11@ChooseTrad:
	cmp	esi, ebx
	jae	SHORT $LN13@ChooseTrad

; 5575 : 		{
; 5576 : 			if (aTradeConnections[ui].m_iOriginX == aTradeConnections[ui2].m_iOriginX && 
; 5577 : 				aTradeConnections[ui].m_iOriginY == aTradeConnections[ui2].m_iOriginY && 
; 5578 : 				aTradeConnections[ui].m_iDestX   == aTradeConnections[ui2].m_iDestX && 
; 5579 : 				aTradeConnections[ui].m_iDestY   == aTradeConnections[ui2].m_iDestY && 
; 5580 : 				aTradeConnections[ui].m_eConnectionType == aTradeConnections[ui2].m_eConnectionType)

	mov	eax, DWORD PTR _aTradeConnections$[esp+40]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [edx+eax+4]
	cmp	ebx, DWORD PTR [ecx+eax+4]
	jne	SHORT $LN10@ChooseTrad
	mov	ebx, DWORD PTR [edx+eax+8]
	cmp	ebx, DWORD PTR [ecx+eax+8]
	jne	SHORT $LN10@ChooseTrad
	mov	ebx, DWORD PTR [edx+eax+12]
	cmp	ebx, DWORD PTR [ecx+eax+12]
	jne	SHORT $LN10@ChooseTrad
	mov	ebx, DWORD PTR [edx+eax+16]
	cmp	ebx, DWORD PTR [ecx+eax+16]
	jne	SHORT $LN10@ChooseTrad
	mov	ebx, DWORD PTR [edx+eax+32]
	cmp	ebx, DWORD PTR [ecx+eax+32]
	jne	SHORT $LN10@ChooseTrad

; 5581 : #endif
; 5582 : 			{
; 5583 : 				uiNumDuplicateTRs++;

	inc	DWORD PTR _uiNumDuplicateTRs$[esp+44]
$LN10@ChooseTrad:

; 5573 : 	{
; 5574 : 		for (uint ui2 = ui + 1;  ui2 < uiNumTradeRoutesPossible && ui2 < uiNumTradeConnections; ui2++)

	mov	ebx, DWORD PTR tv596[esp+44]
	inc	esi
	add	ecx, 444				; 000001bcH
	cmp	esi, ebp
	jb	SHORT $LL11@ChooseTrad
$LN13@ChooseTrad:

; 5571 : 
; 5572 : 	for (uint ui = 0; ui < uiNumTradeRoutesPossible && ui < uiNumTradeConnections; ui++)

	mov	eax, edi
	add	edx, 444				; 000001bcH
	cmp	eax, ebp
	jb	SHORT $LL177@ChooseTrad
$LN12@ChooseTrad:

; 5584 : 			}
; 5585 : 		}
; 5586 : 	}
; 5587 : 
; 5588 : #ifdef AUI_ITERATORIZE
; 5589 : 	const TradeConnectionList::const_iterator pDisbandThreshold = aTradeConnections.begin() + uiNumTradeRoutesPossible + uiNumDuplicateTRs;
; 5590 : 	for (TradeConnectionList::const_iterator it = aTradeConnections.begin(); it != aTradeConnections.end() && it < pNoMoreTradeRoutesPossible; ++it)
; 5591 : 	{
; 5592 : 		if (it >= pDisbandThreshold)
; 5593 : 		{
; 5594 : 			if ((uiNumTradeRoutesPossible - pkTradeAI->GetNumTradeRoutesUsed(true)) == 0) // GetNumTradeRoutesRemaining(true)
; 5595 : 			{
; 5596 : 				bDisband = true;
; 5597 : 				return true;
; 5598 : 			}
; 5599 : 		}
; 5600 : 
; 5601 : 		if (it->m_eDomain == pUnit->getDomainType())
; 5602 : 		{
; 5603 : 			CvPlot* pPlot = GC.getMap().plot(it->m_iOriginX, it->m_iOriginY);
; 5604 : 			if (pUnit->canMakeTradeRouteAt(pPlot, it->m_iDestX, it->m_iDestY, it->m_eConnectionType))
; 5605 : 			{
; 5606 : 				CvPlot* pDestPlot = GC.getMap().plot(it->m_iDestX, it->m_iDestY);
; 5607 : 				iOriginPlotIndex = pPlot->GetPlotIndex();
; 5608 : 				iDestPlotIndex = pDestPlot->GetPlotIndex();
; 5609 : 				eTradeConnectionType = it->m_eConnectionType;
; 5610 : #else
; 5611 : 	for (uint ui = 0; ui < aTradeConnections.size(); ui++)

	xor	edi, edi
	mov	DWORD PTR _ui$223570[esp+44], edi
	test	ebx, ebx
	jbe	$LN5@ChooseTrad
	mov	ecx, DWORD PTR _uiNumDuplicateTRs$[esp+44]
	lea	edx, DWORD PTR [ecx+ebp]
	xor	ebx, ebx
	mov	DWORD PTR tv648[esp+44], edx
	mov	DWORD PTR tv1053[esp+44], ebx
	npad	3
$LL174@ChooseTrad:

; 5612 : 	{
; 5613 : 		if (ui >= (uiNumTradeRoutesPossible + uiNumDuplicateTRs))

	cmp	edi, DWORD PTR tv648[esp+44]
	jb	SHORT $LN3@ChooseTrad

; 5614 : 		{
; 5615 : 			if ((uiNumTradeRoutesPossible - pkTradeAI->GetNumTradeRoutesUsed(true)) == 0) // GetNumTradeRoutesRemaining(true)

	mov	ecx, DWORD PTR _pkTradeAI$[esp+44]
	mov	ecx, DWORD PTR [ecx+79104]
	xor	esi, esi
	push	esi
	lea	eax, DWORD PTR _iLoop$237745[esp+48]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN52@ChooseTrad
$LL54@ChooseTrad:
	mov	ecx, eax
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	test	al, al
	je	SHORT $LN53@ChooseTrad
	inc	esi
$LN53@ChooseTrad:
	mov	eax, DWORD PTR _pkTradeAI$[esp+44]
	mov	ecx, DWORD PTR [eax+79104]
	push	0
	lea	edx, DWORD PTR _iLoop$237745[esp+48]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL54@ChooseTrad
$LN52@ChooseTrad:
	mov	ecx, ebp
	sub	ecx, esi
	je	$LN160@ChooseTrad
$LN3@ChooseTrad:

; 5619 : 			}
; 5620 : 		}
; 5621 : 
; 5622 : 		if (aTradeConnections[ui].m_eDomain == pUnit->getDomainType())

	mov	edx, DWORD PTR _aTradeConnections$[esp+40]
	mov	esi, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pUnit$[esp+40]
	add	esi, ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	DWORD PTR [esi+28], eax
	jne	$LN6@ChooseTrad

; 5623 : 		{
; 5624 : 			CvPlot* pPlot = GC.getMap().plot(aTradeConnections[ui].m_iOriginX, aTradeConnections[ui].m_iOriginY);

	mov	eax, DWORD PTR _aTradeConnections$[esp+40]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+ebx+4]
	lea	ebp, DWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN65@ChooseTrad
	cmp	ebx, -2147483647			; 80000001H
	je	$LN65@ChooseTrad
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN75@ChooseTrad
	test	eax, eax
	jge	SHORT $LN77@ChooseTrad
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN79@ChooseTrad
$LN77@ChooseTrad:
	cmp	eax, ecx
	jl	SHORT $LN75@ChooseTrad
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN79@ChooseTrad
$LN75@ChooseTrad:
	mov	esi, eax
$LN79@ChooseTrad:
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edx+4024]
	je	SHORT $LN172@ChooseTrad
	test	ebx, ebx
	jge	SHORT $LN87@ChooseTrad
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN89@ChooseTrad
$LN87@ChooseTrad:
	cmp	ebx, edi
	jl	SHORT $LN172@ChooseTrad
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN89@ChooseTrad
$LN172@ChooseTrad:
	mov	edx, ebx
$LN89@ChooseTrad:
	test	esi, esi
	jl	SHORT $LN69@ChooseTrad
	cmp	esi, ecx
	jge	SHORT $LN69@ChooseTrad
	test	edx, edx
	jl	SHORT $LN69@ChooseTrad
	cmp	edx, edi
	jge	SHORT $LN69@ChooseTrad
	mov	edi, DWORD PTR _ui$223570[esp+44]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$223577[esp+44], ecx
	jmp	SHORT $LN67@ChooseTrad
$LN69@ChooseTrad:
	mov	edi, DWORD PTR _ui$223570[esp+44]
$LN65@ChooseTrad:
	mov	DWORD PTR _pPlot$223577[esp+44], 0
$LN67@ChooseTrad:

; 5625 : 			if (pUnit->canMakeTradeRouteAt(pPlot, aTradeConnections[ui].m_iDestX, aTradeConnections[ui].m_iDestY, aTradeConnections[ui].m_eConnectionType))

	mov	eax, DWORD PTR [ebp+32]
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [ebp+12]
	push	eax
	mov	eax, DWORD PTR _pPlot$223577[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[esp+48]
	push	edx
	push	eax
	call	?canMakeTradeRouteAt@CvUnit@@QBE_NPBVCvPlot@@HHW4TradeConnectionType@@@Z ; CvUnit::canMakeTradeRouteAt
	test	al, al
	jne	SHORT $LN161@ChooseTrad
	mov	ebx, DWORD PTR tv1053[esp+44]
	mov	ebp, DWORD PTR _uiNumTradeRoutesPossible$[esp+44]
$LN6@ChooseTrad:
	mov	ecx, DWORD PTR _aTradeConnections$[esp+40]
	inc	edi
	add	ebx, 444				; 000001bcH
	mov	DWORD PTR _ui$223570[esp+44], edi
	mov	DWORD PTR tv1053[esp+44], ebx
	cmp	edi, DWORD PTR [ecx+4]
	jb	$LL174@ChooseTrad
$LN5@ChooseTrad:
	pop	edi
	pop	ebp
	pop	ebx

; 5633 : 			}
; 5634 : 		}
; 5635 : 	}
; 5636 : 
; 5637 : 	return false;

	xor	al, al
	pop	esi

; 5638 : }

	add	esp, 28					; 0000001cH
	ret	24					; 00000018H
$LN160@ChooseTrad:

; 5616 : 			{
; 5617 : 				bDisband = true;

	mov	edx, DWORD PTR _bDisband$[esp+40]
	pop	edi
	pop	ebp
	pop	ebx
	mov	BYTE PTR [edx], 1

; 5618 : 				return true;

	mov	al, 1
	pop	esi

; 5638 : }

	add	esp, 28					; 0000001cH
	ret	24					; 00000018H
$LN161@ChooseTrad:

; 5626 : 			{
; 5627 : 				CvPlot* pDestPlot = GC.getMap().plot(aTradeConnections[ui].m_iDestX, aTradeConnections[ui].m_iDestY);

	mov	eax, DWORD PTR _aTradeConnections$[esp+40]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, edi
	imul	ebx, 444				; 000001bcH
	mov	edi, DWORD PTR [ebx+ecx+16]
	lea	eax, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN115@ChooseTrad
	cmp	edi, -2147483647			; 80000001H
	je	$LN115@ChooseTrad
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN125@ChooseTrad
	test	eax, eax
	jge	SHORT $LN127@ChooseTrad
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN129@ChooseTrad
$LN127@ChooseTrad:
	cmp	eax, ecx
	jl	SHORT $LN125@ChooseTrad
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN129@ChooseTrad
$LN125@ChooseTrad:
	mov	esi, eax
$LN129@ChooseTrad:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebp, DWORD PTR [edx+4024]
	je	SHORT $LN171@ChooseTrad
	test	edi, edi
	jge	SHORT $LN137@ChooseTrad
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN139@ChooseTrad
$LN137@ChooseTrad:
	cmp	edi, ebp
	jl	SHORT $LN171@ChooseTrad
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN139@ChooseTrad
$LN171@ChooseTrad:
	mov	edx, edi
$LN139@ChooseTrad:
	test	esi, esi
	jl	SHORT $LN115@ChooseTrad
	cmp	esi, ecx
	jge	SHORT $LN115@ChooseTrad
	test	edx, edx
	jl	SHORT $LN115@ChooseTrad
	cmp	edx, ebp
	jge	SHORT $LN115@ChooseTrad
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	esi, ecx
	jmp	SHORT $LN117@ChooseTrad
$LN115@ChooseTrad:
	xor	esi, esi
$LN117@ChooseTrad:

; 5628 : 				iOriginPlotIndex = pPlot->GetPlotIndex();

	mov	ecx, DWORD PTR _pPlot$223577[esp+44]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR _iOriginPlotIndex$[esp+40]
	mov	DWORD PTR [ecx], eax

; 5629 : 				iDestPlotIndex = pDestPlot->GetPlotIndex();

	mov	ecx, esi
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	edx, DWORD PTR _iDestPlotIndex$[esp+40]
	mov	DWORD PTR [edx], eax

; 5630 : 				eTradeConnectionType = aTradeConnections[ui].m_eConnectionType;

	mov	eax, DWORD PTR _aTradeConnections$[esp+40]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ebx+ecx+32]
	mov	eax, DWORD PTR _eTradeConnectionType$[esp+40]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR [eax], edx

; 5631 : #endif
; 5632 : 				return true;

	mov	al, 1
	pop	esi

; 5638 : }

	add	esp, 28					; 0000001cH
	ret	24					; 00000018H
?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ENDP ; CvTradeAI::ChooseTradeUnitTargetPlot
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@13

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@13
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@13:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 40					; 00000028H
	jbe	SHORT $LN16@operator@13
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	ecx, DWORD PTR [edi*8]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	ebx

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	push	ebp
	mov	ecx, esi
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

$LN16@operator@13:
	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [esi+8], 40			; 00000028H
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@13:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	push	ebp
	mov	ecx, esi
	call	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=
_TEXT	ENDS
PUBLIC	?begin@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@XZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 153391689				; 09249249H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	5
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN33@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 40					; 00000028H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 40			; 00000028H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN1@GrowSize
	mov	ecx, ebp
$LL38@GrowSize:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN2@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+eax*8]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR [ecx+4], edx
$LN2@GrowSize:
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL38@GrowSize
$LN1@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN37@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN37@GrowSize:
	pop	edi

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+332], 1
	pop	esi
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)

	mov	esi, DWORD PTR __Capacity$[esp]
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	cmp	esi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 9586980				; 00924924H
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	esi
	call	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	imul	esi, 448				; 000001c0H
	add	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Ucopy
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Ucopy:
	pop	edi
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	12					; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::fill<CvString *,CvString>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill@4
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill@4:
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL5@fill@4
	pop	ebx
$LN3@fill@4:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN13@Move_backw@4
$LL6@Move_backw@4:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL6@Move_backw@4
$LN13@Move_backw@4:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ; std::allocator<CvString>::construct
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0
__ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
_TEXT	SEGMENT
$T238422 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$238430 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z PROC ; std::allocator<CvString>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$238430[esp+12], ecx
	mov	DWORD PTR $T238422[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@3
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN5@construct@3:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0:
	mov	eax, DWORD PTR __Vptr$238430[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T238422[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ENDP ; std::allocator<CvString>::construct
PUBLIC	??$_Distance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	add	edx, ecx
	sar	edx, 8
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL14@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@4:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
$LL14@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@5:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@6
	pop	esi
$LN7@unchecked_@6:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z	; std::_Destroy<CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z PROC	; std::_Destroy<CvString>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z ENDP	; std::_Destroy<CvString>
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$226267 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ PROC ; std::_Temp_iterator<TRSortElement>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$226267[esp+16]
	push	eax
	call	??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z ; std::get_temporary_buffer<TRSortElement>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$226267[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$226267[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<TRSortElement>::_Maxlen
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	imul	ecx, 448				; 000001c0H
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 2293 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN38@Lower_boun
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+444]
	npad	2
$LL4@Lower_boun:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	imul	ecx, 448				; 000001c0H
	add	ecx, edi

; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	cmp	DWORD PTR [ecx+444], ebx
	jge	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+448]
	or	ecx, -1
	sub	ecx, eax
	mov	DWORD PTR __First$[esp+8], edi
	add	esi, ecx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Lower_boun
	pop	ebx
$LN38@Lower_boun:

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi

; 2306 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 2364 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN38@Upper_boun
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+444]
	npad	2
$LL4@Upper_boun:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	imul	ecx, 448				; 000001c0H
	add	ecx, edi

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	cmp	ebx, DWORD PTR [ecx+444]
	jl	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+448]
	or	ecx, -1
	sub	ecx, eax
	mov	DWORD PTR __First$[esp+8], edi
	add	esi, ecx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Upper_boun
	pop	ebx
$LN38@Upper_boun:

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi

; 2377 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
_TEXT	ENDS
PUBLIC	??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1786 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1787 : 		}

	ret	4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2053 : 		const size_type _Maxsize = _Myvec.max_size();
; 2054 : 		return (_Maxsize < (size_type)(-1) / _VBITS
; 2055 : 			? _Maxsize * _VBITS : (size_type)(-1));

	or	eax, -1

; 2056 : 		}

	ret	0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
	npad	2

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

$LL18@Copy_opt@3:
	mov	eax, DWORD PTR __First$[esp+4]
	cmp	eax, DWORD PTR __Last$[esp+4]
	jne	SHORT $LN26@Copy_opt@3
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN62@Copy_opt@3
$LN26@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	ebx, 1
	shl	ebx, cl
	mov	ecx, esi
	test	ebx, DWORD PTR [eax]
	mov	eax, 1
	je	SHORT $LN49@Copy_opt@3
	shl	eax, cl
	or	DWORD PTR [edx], eax
	jmp	SHORT $LN2@Copy_opt@3
$LN49@Copy_opt@3:
	shl	eax, cl
	not	eax
	and	DWORD PTR [edx], eax
$LN2@Copy_opt@3:
	mov	esi, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR __Dest$[esp+4]
	cmp	esi, 31					; 0000001fH
	jae	SHORT $LN11@Copy_opt@3

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	inc	esi
	jmp	SHORT $LN63@Copy_opt@3
$LN11@Copy_opt@3:
	xor	esi, esi
	add	edx, 4
	mov	DWORD PTR __Dest$[esp+4], edx
$LN63@Copy_opt@3:
	mov	ecx, DWORD PTR __First$[esp+8]
	mov	DWORD PTR __Dest$[esp+8], esi
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN19@Copy_opt@3
	inc	ecx
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@3
$LN19@Copy_opt@3:
	xor	ecx, ecx
	add	DWORD PTR __First$[esp+4], 4
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@3
$LN62@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 3188 : 	}

	ret	0
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1808 : 		{	// predecrement

	mov	eax, ecx

; 1809 : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN6@operator@14
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0

; 1809 : 		--*(_Mybase *)this;

$LN6@operator@14:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@7
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@7:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@7
	pop	esi
$LN7@unchecked_@7:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@8
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@8:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@8
	pop	esi
$LN7@unchecked_@8:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	?DoTurn@CvGameTrade@@QAEXXZ			; CvGameTrade::DoTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?DoTurn@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvGameTrade@@QAEXXZ PROC			; CvGameTrade::DoTurn, COMDAT
; _this$ = ecx

; 85   : {

	mov	edx, ecx
	push	edi

; 86   : 	ResetTechDifference();

	lea	edi, DWORD PTR [edx+74612]
	mov	ecx, 484				; 000001e4H
	or	eax, -1
	rep stosd

; 87   : 	BuildTechDifference();

	mov	ecx, edx
	pop	edi
	jmp	?BuildTechDifference@CvGameTrade@@QAEXXZ ; CvGameTrade::BuildTechDifference
?DoTurn@CvGameTrade@@QAEXXZ ENDP			; CvGameTrade::DoTurn
_TEXT	ENDS
PUBLIC	??0TradeConnection@@QAE@XZ			; TradeConnection::TradeConnection
; Function compile flags: /Ogtpy
;	COMDAT ??0TradeConnection@@QAE@XZ
_TEXT	SEGMENT
??0TradeConnection@@QAE@XZ PROC				; TradeConnection::TradeConnection, COMDAT
; _this$ = ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 40			; 00000028H
	mov	DWORD PTR [eax+44], ecx
	ret	0
??0TradeConnection@@QAE@XZ ENDP				; TradeConnection::TradeConnection
_TEXT	ENDS
PUBLIC	??1TradeConnection@@QAE@XZ			; TradeConnection::~TradeConnection
; Function compile flags: /Ogtpy
;	COMDAT ??1TradeConnection@@QAE@XZ
_TEXT	SEGMENT
??1TradeConnection@@QAE@XZ PROC				; TradeConnection::~TradeConnection, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN6@TradeConne
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@TradeConne:
	ret	0
??1TradeConnection@@QAE@XZ ENDP				; TradeConnection::~TradeConnection
_TEXT	ENDS
PUBLIC	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
EXTRN	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteLandFinder
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteWaterFinder
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z
_TEXT	SEGMENT
_iDestY$ = -4						; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z PROC ; CvGameTrade::IsValidTradeRoutePath, COMDAT
; _this$ = ecx

; 471  : {

	push	ecx

; 472  : 	// AI_PERF_FORMAT("Trade-route-perf.csv", ("CvGameTrade::IsValidTradeRoutePath, Turn %03d, %s, %s, %d, %d, %s, %d, %d", GC.getGame().getElapsedGameTurns(), pOriginCity->GetPlayer()->getCivilizationShortDescription(), pOriginCity->getName().c_str(), pOriginCity->getX(), pOriginCity->getY(), pDestCity->getName().c_str(), pDestCity->getX(), pDestCity->getY()) );
; 473  : 
; 474  : 	PlayerTypes eOriginPlayer = pOriginCity->getOwner();
; 475  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 476  : 	PlayerTypes eDestPlayer = pDestCity->getOwner();
; 477  : #endif
; 478  : 
; 479  : 	int iOriginX = pOriginCity->getX();
; 480  : 	int iOriginY = pOriginCity->getY();
; 481  : 	int iDestX = pDestCity->getX();

	mov	eax, DWORD PTR _pDestCity$[esp]
	mov	ecx, DWORD PTR _pOriginCity$[esp]

; 482  : 	int iDestY = pDestCity->getY();
; 483  : 
; 484  : 	bool bSuccess = false;
; 485  : 	CvAStarNode* pPathfinderNode = NULL;
; 486  : 	if (eDomain == DOMAIN_SEA)

	mov	edx, DWORD PTR _eDomain$[esp]
	push	ebx
	mov	ebx, DWORD PTR [ecx+108]
	push	ebp
	mov	ebp, DWORD PTR [eax+96]
	mov	eax, DWORD PTR [eax+108]
	push	esi
	mov	esi, DWORD PTR [ecx+84]
	push	edi
	mov	edi, DWORD PTR [ecx+96]
	mov	DWORD PTR _iDestY$[esp+20], eax
	test	edx, edx
	jne	SHORT $LN7@IsValidTra

; 487  : 	{
; 488  : 		if (pOriginCity->isCoastal(0) && pDestCity->isCoastal(0))	// Both must be on the coast (a lake is ok)  A better check would be to see if they are adjacent to the same water body.

	push	edx
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN36@IsValidTra
	mov	ecx, DWORD PTR _pDestCity$[esp+16]
	push	0
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN36@IsValidTra

; 489  : 		{
; 490  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 491  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 492  : #else
; 493  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	mov	eax, DWORD PTR _iDestY$[esp+20]
	push	0
	push	esi
	push	eax
	push	ebp
	push	ebx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 494  : #endif
; 495  : 			pPathfinderNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, al
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder

; 496  : 		}
; 497  : 	}

	jmp	SHORT $LN37@IsValidTra
$LN7@IsValidTra:

; 498  : 	else if (eDomain == DOMAIN_LAND)

	cmp	edx, 2
	jne	SHORT $LN36@IsValidTra

; 499  : 	{
; 500  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 501  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 502  : #else
; 503  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	push	esi
	push	eax
	push	ebp
	push	ebx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 504  : #endif
; 505  : 		pPathfinderNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, al
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
$LN37@IsValidTra:
	mov	eax, DWORD PTR [eax+96]

; 506  : 	}
; 507  : 
; 508  : 	if (!bSuccess)

	test	bl, bl
	jne	SHORT $LN3@IsValidTra
$LN36@IsValidTra:
	pop	edi
	pop	esi
	pop	ebp

; 509  : 	{
; 510  : 		return false;

	xor	al, al
	pop	ebx

; 523  : 	{
; 524  : 		return false;
; 525  : 	}
; 526  : 
; 527  : 	return true;
; 528  : }

	pop	ecx
	ret	12					; 0000000cH
$LN3@IsValidTra:

; 511  : 	}
; 512  : 
; 513  : 	CvAssertMsg(pPathfinderNode, "pPathfinderNode is null. Whaa?");
; 514  : 	if (pPathfinderNode == NULL)

	test	eax, eax

; 515  : 	{
; 516  : 		return false;

	je	SHORT $LN36@IsValidTra

; 517  : 	}
; 518  : 
; 519  : 	// beyond the origin player's trade range
; 520  : 	int iPathDistance = pPathfinderNode->m_iTotalCost;
; 521  : 	int iRange = GET_PLAYER(eOriginPlayer).GetTrade()->GetTradeRouteRange(eDomain, pOriginCity) * 100 + 99; // adding 99 so that any movement penalties are ignored

	mov	edx, DWORD PTR _pOriginCity$[esp+16]
	imul	esi, 63236				; 0000f704H
	mov	edi, DWORD PTR [eax]
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR _eDomain$[esp+16]
	push	edx
	mov	ecx, esi
	push	eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z ; CvPlayerTrade::GetTradeRouteRange
	imul	eax, 100				; 00000064H
	add	eax, 99					; 00000063H

; 522  : 	if (iPathDistance > iRange)

	cmp	edi, eax
	pop	edi
	pop	esi
	pop	ebp
	setle	al
	pop	ebx

; 523  : 	{
; 524  : 		return false;
; 525  : 	}
; 526  : 
; 527  : 	return true;
; 528  : }

	pop	ecx
	ret	12					; 0000000cH
?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ENDP ; CvGameTrade::IsValidTradeRoutePath
_TEXT	ENDS
PUBLIC	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z		; CvGameTrade::EmptyTradeRoute
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
; Function compile flags: /Ogtpy
;	COMDAT ?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
tv395 = -4						; size = 4
_iIndex$ = 8						; size = 4
?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z PROC		; CvGameTrade::EmptyTradeRoute, COMDAT
; _this$ = ecx

; 1036 : {

	push	ecx
	push	ebx
	push	esi

; 1037 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1038 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	mov	esi, DWORD PTR _iIndex$[esp+8]
	xor	ebx, ebx
	cmp	esi, ebx
	jl	$LN6@EmptyTrade
	cmp	esi, DWORD PTR [ecx+4]
	jge	$LN6@EmptyTrade

; 1041 : 	}
; 1042 : 
; 1043 : 	TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];

	imul	esi, 444				; 000001bcH
	add	esi, DWORD PTR [ecx]
	push	ebp

; 1044 : 	PlayerTypes eOriginPlayer = kTradeConnection.m_eOriginOwner;
; 1045 : 	PlayerTypes eDestPlayer = kTradeConnection.m_eDestOwner;
; 1046 : 
; 1047 : 	// Remove any visualization
; 1048 : 	if (kTradeConnection.m_unitID != -1)

	mov	eax, DWORD PTR [esi+380]
	mov	ecx, DWORD PTR [esi+20]
	or	ebp, -1
	push	edi
	mov	edi, DWORD PTR [esi+24]
	mov	DWORD PTR tv395[esp+20], ecx
	cmp	eax, ebp
	je	SHORT $LN40@EmptyTrade

; 1049 : 	{
; 1050 : 		CvUnit* pkUnit = GET_PLAYER(kTradeConnection.m_eOriginOwner).getUnit(kTradeConnection.m_unitID);

	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 1051 : 		if (pkUnit)

	cmp	eax, ebx
	je	SHORT $LN40@EmptyTrade

; 1052 : 		{
; 1053 : 			pkUnit->kill(false);

	push	ebp
	push	ebx
	mov	ecx, eax
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN40@EmptyTrade:

; 1054 : 		}
; 1055 : 	}
; 1056 : 
; 1057 : 	kTradeConnection.m_iID = -1;
; 1058 : 	kTradeConnection.m_iDestX = -1;
; 1059 : 	kTradeConnection.m_iDestY = -1;
; 1060 : 	kTradeConnection.m_eDestOwner = NO_PLAYER;
; 1061 : 	kTradeConnection.m_iOriginX = -1;
; 1062 : 	kTradeConnection.m_iOriginY = -1;
; 1063 : 	kTradeConnection.m_eOriginOwner = NO_PLAYER;
; 1064 : 	kTradeConnection.m_eDomain = NO_DOMAIN;
; 1065 : 	kTradeConnection.m_eConnectionType = NUM_TRADE_CONNECTION_TYPES;
; 1066 : #ifdef AUI_WARNING_FIXES
; 1067 : 	kTradeConnection.m_iTradeUnitLocationIndex = MAX_UNSIGNED_INT;
; 1068 : #else
; 1069 : 	kTradeConnection.m_iTradeUnitLocationIndex = -1;
; 1070 : #endif
; 1071 : 	kTradeConnection.m_bTradeUnitMovingForward = false;
; 1072 : 	kTradeConnection.m_iCircuitsCompleted = 0;
; 1073 : 	kTradeConnection.m_iCircuitsToComplete = 0;
; 1074 : 	kTradeConnection.m_iTurnRouteComplete = 0;
; 1075 : 	kTradeConnection.m_aPlotList.clear();
; 1076 : 	kTradeConnection.m_unitID = -1;
; 1077 : 
; 1078 : 	for (uint ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 1079 : 	{
; 1080 : 		kTradeConnection.m_aiOriginYields[ui] = 0;
; 1081 : 		kTradeConnection.m_aiDestYields[ui] = 0;
; 1082 : 	}
; 1083 : 
; 1084 : 	GET_PLAYER(eOriginPlayer).GetTrade()->UpdateTradeConnectionValues();

	mov	ecx, DWORD PTR tv395[esp+20]
	mov	DWORD PTR [esi], ebp
	imul	ecx, 63236				; 0000f704H
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+20], ebp
	mov	DWORD PTR [esi+28], ebp
	mov	DWORD PTR [esi+32], 3
	mov	DWORD PTR [esi+36], ebp
	mov	BYTE PTR [esi+40], bl
	mov	DWORD PTR [esi+384], ebx
	mov	DWORD PTR [esi+388], ebx
	mov	DWORD PTR [esi+392], ebx
	mov	DWORD PTR [esi+48], ebx
	mov	DWORD PTR [esi+380], ebp
	mov	DWORD PTR [esi+396], ebx
	mov	DWORD PTR [esi+420], ebx
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+428], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+440], ebx
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 1085 : 	GET_PLAYER(eDestPlayer).GetTrade()->UpdateTradeConnectionValues();

	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, edi
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 1086 : 
; 1087 : 	gDLL->TradeVisuals_DestroyRoute(iIndex, eOriginPlayer);

	mov	edx, DWORD PTR tv395[esp+20]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+980]
	push	edx
	mov	edx, DWORD PTR _iIndex$[esp+20]
	push	edx
	call	eax
	pop	edi
	pop	ebp
	pop	esi

; 1088 : 	return true;

	mov	al, 1
	pop	ebx

; 1089 : }

	pop	ecx
	ret	4
$LN6@EmptyTrade:
	pop	esi

; 1039 : 	{
; 1040 : 		return false;

	xor	al, al
	pop	ebx

; 1089 : }

	pop	ecx
	ret	4
?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z ENDP		; CvGameTrade::EmptyTradeRoute
_TEXT	ENDS
PUBLIC	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ; CvGameTrade::ClearAllCityTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_iY$220611 = -4						; size = 4
_iX$220610 = 8						; size = 4
_pPlot$ = 8						; size = 4
?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z PROC ; CvGameTrade::ClearAllCityTradeRoutes, COMDAT
; _this$ = ecx

; 1132 : {

	push	ecx

; 1133 : 	CvAssert(pPlot != NULL);
; 1134 : 
; 1135 : 	if (pPlot)

	mov	eax, DWORD PTR _pPlot$[esp]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	$LN6@ClearAllCi

; 1136 : 	{
; 1137 : 		int iX = pPlot->getX();

	movsx	ecx, WORD PTR [eax]

; 1138 : 		int iY = pPlot->getY();

	movsx	edx, WORD PTR [eax+2]
	push	ebx

; 1139 : 		for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	ebx, ebx
	mov	DWORD PTR _iX$220610[esp+8], ecx
	mov	DWORD PTR _iY$220611[esp+12], edx
	cmp	DWORD PTR [esi+4], ebx
	jbe	$LN77@ClearAllCi
	push	ebp
	push	edi
	xor	edi, edi
	or	ebp, -1
$LL76@ClearAllCi:

; 1140 : 		{
; 1141 : 			if (IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+edi+4]
	add	eax, edi
	cmp	ecx, ebp
	jne	SHORT $LN23@ClearAllCi
	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN23@ClearAllCi
	cmp	DWORD PTR [eax+12], ebp
	jne	SHORT $LN23@ClearAllCi
	cmp	DWORD PTR [eax+16], ebp
	je	$LN7@ClearAllCi
$LN23@ClearAllCi:

; 1142 : 			{
; 1143 : 				continue;
; 1144 : 			}
; 1145 : 
; 1146 : 			bool bMatchesOrigin = (m_aTradeConnections[ui].m_iOriginX == iX && m_aTradeConnections[ui].m_iOriginY == iY);

	cmp	ecx, DWORD PTR _iX$220610[esp+16]
	jne	SHORT $LN12@ClearAllCi
	mov	ecx, DWORD PTR _iY$220611[esp+20]
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN12@ClearAllCi
	mov	dl, 1
	jmp	SHORT $LN13@ClearAllCi
$LN12@ClearAllCi:
	xor	dl, dl
$LN13@ClearAllCi:

; 1147 : 			bool bMatchesDest = (m_aTradeConnections[ui].m_iDestX == iX && m_aTradeConnections[ui].m_iDestY == iY);

	mov	ecx, DWORD PTR _iX$220610[esp+16]
	cmp	DWORD PTR [eax+12], ecx
	jne	SHORT $LN14@ClearAllCi
	mov	ecx, DWORD PTR _iY$220611[esp+20]
	cmp	DWORD PTR [eax+16], ecx
	jne	SHORT $LN14@ClearAllCi
	mov	cl, 1
	jmp	SHORT $LN15@ClearAllCi
$LN14@ClearAllCi:
	xor	cl, cl
$LN15@ClearAllCi:

; 1148 : 
; 1149 : 			if (bMatchesOrigin || bMatchesDest)

	test	dl, dl
	jne	SHORT $LN3@ClearAllCi
	test	cl, cl
	je	$LN7@ClearAllCi

; 1150 : 			{
; 1151 : 				// if the destination was wiped, the origin gets a trade unit back
; 1152 : 				if (bMatchesDest && GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isAlive())

	jmp	SHORT $LN71@ClearAllCi
$LN3@ClearAllCi:
	test	cl, cl
	je	SHORT $LN73@ClearAllCi
$LN71@ClearAllCi:
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edx, 63236				; 0000f704H
	cmp	BYTE PTR [edx+eax+2256], 0
	lea	ecx, DWORD PTR [edx+eax]
	je	SHORT $LN73@ClearAllCi

; 1153 : 				{
; 1154 : 					UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+ecx+28]
	cmp	eax, 2
	jne	SHORT $LN58@ClearAllCi
	push	0
	push	OFFSET $SG222599
	jmp	SHORT $LN79@ClearAllCi
$LN58@ClearAllCi:
	test	eax, eax
	jne	SHORT $LN73@ClearAllCi
	push	eax
	push	OFFSET $SG222603
$LN79@ClearAllCi:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1155 : 					CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1156 : 					if (eUnitType != NO_UNIT)

	cmp	eax, ebp
	je	SHORT $LN73@ClearAllCi

; 1157 : 					{
; 1158 : 						GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	edx, DWORD PTR [esi]
	push	0
	push	0
	push	1
	push	0
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [ecx+8]
	push	ebp
	push	38					; 00000026H
	push	edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN73@ClearAllCi:

; 1159 : 					}
; 1160 : 				}
; 1161 : 
; 1162 : 				EmptyTradeRoute(ui);

	push	ebx
	mov	ecx, esi
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN7@ClearAllCi:
	inc	ebx
	add	edi, 444				; 000001bcH
	cmp	ebx, DWORD PTR [esi+4]
	jb	$LL76@ClearAllCi
	pop	edi
	pop	ebp
$LN77@ClearAllCi:
	pop	ebx
$LN6@ClearAllCi:
	pop	esi

; 1163 : 			}		
; 1164 : 		}
; 1165 : 	}
; 1166 : }

	pop	ecx
	ret	4
?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ENDP ; CvGameTrade::ClearAllCityTradeRoutes
_TEXT	ENDS
PUBLIC	?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z ; CvGameTrade::ClearAllCivTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ui$220628 = -4						; size = 4
_bMatchesOrigin$220633 = 8				; size = 1
_ePlayer$ = 8						; size = 4
?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z PROC ; CvGameTrade::ClearAllCivTradeRoutes, COMDAT
; _this$ = ecx

; 1171 : {

	push	ecx
	push	esi
	push	edi

; 1172 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edi, edi
	mov	esi, ecx
	mov	DWORD PTR _ui$220628[esp+12], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	$LN9@ClearAllCi@2
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp+16]
	npad	6
$LL11@ClearAllCi@2:

; 1173 : 	{
; 1174 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+eax]
	or	eax, -1
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN19@ClearAllCi@2
	cmp	DWORD PTR [ecx+8], eax
	jne	SHORT $LN19@ClearAllCi@2
	cmp	DWORD PTR [ecx+12], eax
	jne	SHORT $LN19@ClearAllCi@2
	cmp	DWORD PTR [ecx+16], eax
	je	$LN10@ClearAllCi@2
$LN19@ClearAllCi@2:

; 1175 : 		{
; 1176 : 			continue;
; 1177 : 		}
; 1178 : 
; 1179 : 		bool bMatchesOrigin = (m_aTradeConnections[ui].m_eOriginOwner == ePlayer);

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, ebp
	sete	BYTE PTR _bMatchesOrigin$220633[esp+16]

; 1180 : 		bool bMatchesDest = (m_aTradeConnections[ui].m_eDestOwner == ePlayer);

	cmp	DWORD PTR [ecx+24], ebp
	sete	bl

; 1181 : 		bool bCityStateRoute = (GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isMinorCiv() || GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).isMinorCiv());

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN10@ClearAllCi@2
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi+ecx+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 1182 : 
; 1183 : 		if (!bCityStateRoute)

	jne	$LN10@ClearAllCi@2

; 1184 : 		{
; 1185 : 			if (bMatchesOrigin && bMatchesDest)

	cmp	BYTE PTR _bMatchesOrigin$220633[esp+16], al
	je	SHORT $LN71@ClearAllCi@2
	test	bl, bl
	jne	$LN10@ClearAllCi@2

; 1186 : 			{
; 1187 : 				// Internal trade route - don't wipe it
; 1188 : 				continue;
; 1189 : 			}
; 1190 : 			else if (bMatchesOrigin || bMatchesDest)

	jmp	SHORT $LN3@ClearAllCi@2
$LN71@ClearAllCi@2:
	test	bl, bl
	je	$LN10@ClearAllCi@2
$LN3@ClearAllCi@2:

; 1191 : 			{
; 1192 : 				// if the destination was wiped, the origin gets a trade unit back
; 1193 : 				if (GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isAlive())

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+edx+20]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	add	ecx, eax
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN74@ClearAllCi@2

; 1194 : 				{
; 1195 : 					UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+edx+28]
	cmp	eax, 2
	jne	SHORT $LN58@ClearAllCi@2
	push	0
	push	OFFSET $SG222599
	jmp	SHORT $LN78@ClearAllCi@2
$LN58@ClearAllCi@2:
	test	eax, eax
	jne	SHORT $LN74@ClearAllCi@2
	push	eax
	push	OFFSET $SG222603
$LN78@ClearAllCi@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1196 : 					CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1197 : 					if (eUnitType != NO_UNIT)

	cmp	eax, -1
	je	SHORT $LN74@ClearAllCi@2

; 1198 : 					{
; 1199 : 						GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+edi+8]
	push	0
	push	0
	push	1
	push	0
	add	ecx, edi
	push	-1
	push	38					; 00000026H
	push	edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN74@ClearAllCi@2:

; 1200 : 					}
; 1201 : 				}
; 1202 : 
; 1203 : 				EmptyTradeRoute(ui);

	mov	eax, DWORD PTR _ui$220628[esp+20]
	push	eax
	mov	ecx, esi
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN10@ClearAllCi@2:
	mov	eax, DWORD PTR _ui$220628[esp+20]
	inc	eax
	add	edi, 444				; 000001bcH
	mov	DWORD PTR _ui$220628[esp+20], eax
	cmp	eax, DWORD PTR [esi+4]
	jb	$LL11@ClearAllCi@2
	pop	ebp
	pop	ebx
$LN9@ClearAllCi@2:
	pop	edi
	pop	esi

; 1204 : 			}
; 1205 : 		}
; 1206 : 	}
; 1207 : }

	pop	ecx
	ret	4
?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z ENDP ; CvGameTrade::ClearAllCivTradeRoutes
_TEXT	ENDS
PUBLIC	?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ ; CvGameTrade::ClearAllCityStateTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ PROC	; CvGameTrade::ClearAllCityStateTradeRoutes, COMDAT
; _this$ = ecx

; 1212 : {

	push	ebp
	push	esi
	mov	esi, ecx

; 1213 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+4], ebp
	jbe	$LN5@ClearAllCi@3
	push	ebx
	push	edi
	xor	edi, edi
	or	ebx, -1
$LL7@ClearAllCi@3:

; 1214 : 	{
; 1215 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR [esi]
	add	eax, edi
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN13@ClearAllCi@3
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN13@ClearAllCi@3
	cmp	DWORD PTR [eax+12], ebx
	jne	SHORT $LN13@ClearAllCi@3
	cmp	DWORD PTR [eax+16], ebx
	je	$LN6@ClearAllCi@3
$LN13@ClearAllCi@3:

; 1216 : 		{
; 1217 : 			continue;
; 1218 : 		}
; 1219 : 
; 1220 : 		bool bMatchesDest = (GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).isMinorCiv());

	mov	eax, DWORD PTR [eax+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 1221 : 		if (bMatchesDest)

	test	al, al
	je	$LN6@ClearAllCi@3

; 1222 : 		{
; 1223 : 			// if the destination was wiped, the origin gets a trade unit back
; 1224 : 			if (GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isAlive())

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edi+ecx+20]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edx, 63236				; 0000f704H
	cmp	BYTE PTR [edx+eax+2256], 0
	lea	ecx, DWORD PTR [edx+eax]
	je	SHORT $LN1@ClearAllCi@3

; 1225 : 			{
; 1226 : 				UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+ecx+28]
	cmp	eax, 2
	jne	SHORT $LN44@ClearAllCi@3
	push	0
	push	OFFSET $SG222599
	jmp	SHORT $LN58@ClearAllCi@3
$LN44@ClearAllCi@3:
	test	eax, eax
	jne	SHORT $LN1@ClearAllCi@3
	push	eax
	push	OFFSET $SG222603
$LN58@ClearAllCi@3:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1227 : 				CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1228 : 				if (eUnitType != NO_UNIT)

	cmp	eax, ebx
	je	SHORT $LN1@ClearAllCi@3

; 1229 : 				{
; 1230 : 					GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	edx, DWORD PTR [esi]
	push	0
	push	0
	push	1
	push	0
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [ecx+8]
	push	ebx
	push	38					; 00000026H
	push	edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN1@ClearAllCi@3:

; 1231 : 				}
; 1232 : 			}
; 1233 : 
; 1234 : 			EmptyTradeRoute(ui);

	push	ebp
	mov	ecx, esi
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN6@ClearAllCi@3:
	inc	ebp
	add	edi, 444				; 000001bcH
	cmp	ebp, DWORD PTR [esi+4]
	jb	$LL7@ClearAllCi@3
	pop	edi
	pop	ebx
$LN5@ClearAllCi@3:
	pop	esi
	pop	ebp

; 1235 : 		}		
; 1236 : 	}
; 1237 : }

	ret	0
?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ ENDP	; CvGameTrade::ClearAllCityStateTradeRoutes
_TEXT	ENDS
PUBLIC	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ; CvGameTrade::CancelTradeBetweenTeams
; Function compile flags: /Ogtpy
;	COMDAT ?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z
_TEXT	SEGMENT
_ui$220665 = -4						; size = 4
_eTeam1$ = 8						; size = 4
_eTeam2$ = 12						; size = 4
_bReturnUnits$ = 16					; size = 1
?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z PROC ; CvGameTrade::CancelTradeBetweenTeams, COMDAT
; _this$ = ecx

; 1246 : {

	push	ecx

; 1247 : 	// there shouldn't be trade routes between the same team
; 1248 : 	if (eTeam1 == eTeam2)

	mov	eax, DWORD PTR _eTeam1$[esp]
	push	esi
	mov	esi, ecx
	cmp	eax, DWORD PTR _eTeam2$[esp+4]
	je	$LN7@CancelTrad
	push	edi

; 1249 : 	{
; 1250 : 		return;
; 1251 : 	}
; 1252 : 
; 1253 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edi, edi
	mov	DWORD PTR _ui$220665[esp+12], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	$LN82@CancelTrad
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	npad	6
$LL81@CancelTrad:

; 1254 : 	{
; 1255 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR [esi]
	or	ebx, -1
	cmp	DWORD PTR [edi+ecx+4], ebx
	lea	eax, DWORD PTR [edi+ecx]
	jne	SHORT $LN16@CancelTrad
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN16@CancelTrad
	cmp	DWORD PTR [eax+12], ebx
	jne	SHORT $LN16@CancelTrad
	cmp	DWORD PTR [eax+16], ebx
	je	$LN8@CancelTrad
$LN16@CancelTrad:

; 1256 : 		{
; 1257 : 			continue;
; 1258 : 		}
; 1259 : 
; 1260 : 		TeamTypes eOriginTeam = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).getTeam();

	mov	edx, DWORD PTR [eax+20]
	imul	edx, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edx+ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN35@CancelTrad
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx+edx*4]
	jmp	SHORT $LN36@CancelTrad
$LN35@CancelTrad:
	mov	edx, ebx
$LN36@CancelTrad:

; 1261 : 		TeamTypes eDestTeam = GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).getTeam();

	mov	eax, DWORD PTR [eax+24]
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN48@CancelTrad
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN49@CancelTrad
$LN48@CancelTrad:
	or	eax, -1
$LN49@CancelTrad:

; 1262 : 		if ((eOriginTeam == eTeam1 && eDestTeam == eTeam2) || (eOriginTeam == eTeam2 && eDestTeam == eTeam1)) 

	cmp	edx, DWORD PTR _eTeam1$[esp+16]
	jne	SHORT $LN75@CancelTrad
	cmp	eax, DWORD PTR _eTeam2$[esp+16]
	je	SHORT $LN76@CancelTrad
$LN75@CancelTrad:
	cmp	edx, DWORD PTR _eTeam2$[esp+16]
	jne	SHORT $LN8@CancelTrad
	cmp	eax, DWORD PTR _eTeam1$[esp+16]
	jne	SHORT $LN8@CancelTrad
$LN76@CancelTrad:

; 1263 : 		{
; 1264 : #ifdef NQM_TEAM_TRADE_ROUTES_CANCELLED_NOT_DESTROYED_FOR_WAR_DEFENDER_ON_DOW
; 1265 : 			if (bReturnUnits)

	cmp	BYTE PTR _bReturnUnits$[esp+16], 0
	je	SHORT $LN77@CancelTrad

; 1266 : 			{
; 1267 : 				UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+ecx+28]
	cmp	eax, 2
	jne	SHORT $LN61@CancelTrad
	push	0
	push	OFFSET $SG222599
	jmp	SHORT $LN84@CancelTrad
$LN61@CancelTrad:
	test	eax, eax
	jne	SHORT $LN77@CancelTrad
	push	eax
	push	OFFSET $SG222603
$LN84@CancelTrad:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1268 : 				CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1269 : 				if (eUnitType != NO_UNIT)

	cmp	eax, -1
	je	SHORT $LN77@CancelTrad

; 1270 : 				{
; 1271 : 					GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	edx, DWORD PTR [esi]
	push	0
	push	0
	push	1
	push	0
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [ecx+8]
	push	-1
	push	38					; 00000026H
	push	edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN77@CancelTrad:

; 1272 : 				}
; 1273 : 			}
; 1274 : #endif
; 1275 : 			EmptyTradeRoute(ui);

	mov	eax, DWORD PTR _ui$220665[esp+20]
	push	eax
	mov	ecx, esi
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN8@CancelTrad:
	mov	eax, DWORD PTR _ui$220665[esp+20]
	inc	eax
	add	edi, 444				; 000001bcH
	mov	DWORD PTR _ui$220665[esp+20], eax
	cmp	eax, DWORD PTR [esi+4]
	jb	$LL81@CancelTrad
	pop	ebp
	pop	ebx
$LN82@CancelTrad:
	pop	edi
$LN7@CancelTrad:
	pop	esi

; 1276 : 		}
; 1277 : 	}
; 1278 : }

	pop	ecx
	ret	12					; 0000000cH
?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ENDP ; CvGameTrade::CancelTradeBetweenTeams
_TEXT	ENDS
PUBLIC	?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::InvalidateTradeBetweenTeams
; Function compile flags: /Ogtpy
;	COMDAT ?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z
_TEXT	SEGMENT
_ui$220684 = -4						; size = 4
_eOriginTeam$ = 8					; size = 4
_eDestinationTeam$ = 12					; size = 4
?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z PROC ; CvGameTrade::InvalidateTradeBetweenTeams, COMDAT
; _this$ = ecx

; 1283 : {

	push	ecx

; 1284 : 	// there shouldn't be trade routes between the same team
; 1285 : 	if (eOriginTeam == eDestinationTeam)

	mov	eax, DWORD PTR _eOriginTeam$[esp]
	push	esi
	mov	esi, ecx
	cmp	eax, DWORD PTR _eDestinationTeam$[esp+4]
	je	$LN4@Invalidate
	push	edi

; 1286 : 	{
; 1287 : 		return;
; 1288 : 	}
; 1289 : 
; 1290 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	xor	edi, edi
	mov	DWORD PTR _ui$220684[esp+12], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	$LN76@Invalidate
	push	ebx
	mov	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	npad	6
$LL75@Invalidate:

; 1291 : 	{
; 1292 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR [esi]
	or	ebp, -1
	cmp	DWORD PTR [edi+ecx+4], ebp
	lea	eax, DWORD PTR [edi+ecx]
	jne	SHORT $LN13@Invalidate
	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN13@Invalidate
	cmp	DWORD PTR [eax+12], ebp
	jne	SHORT $LN13@Invalidate
	cmp	DWORD PTR [eax+16], ebp
	je	$LN5@Invalidate
$LN13@Invalidate:

; 1293 : 		{
; 1294 : 			continue;
; 1295 : 		}
; 1296 : 
; 1297 : 		TeamTypes eLoopOriginTeam = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).getTeam();

	mov	edx, DWORD PTR [eax+20]
	imul	edx, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edx+ebx]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN32@Invalidate
	mov	ebp, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebp, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp+edx*4]
	jmp	SHORT $LN33@Invalidate
$LN32@Invalidate:
	mov	edx, ebp
$LN33@Invalidate:

; 1298 : 		TeamTypes eLoopDestTeam = GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).getTeam();

	mov	eax, DWORD PTR [eax+24]
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN45@Invalidate
	mov	ebp, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebp, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	jmp	SHORT $LN46@Invalidate
$LN45@Invalidate:
	or	eax, -1
$LN46@Invalidate:

; 1299 : 		if (eOriginTeam == eLoopOriginTeam && eLoopDestTeam == eDestinationTeam)

	cmp	DWORD PTR _eOriginTeam$[esp+16], edx
	jne	SHORT $LN5@Invalidate
	cmp	eax, DWORD PTR _eDestinationTeam$[esp+16]
	jne	SHORT $LN5@Invalidate

; 1300 : 		{
; 1301 : 			UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+ecx+28]
	cmp	eax, 2
	jne	SHORT $LN58@Invalidate
	push	0
	push	OFFSET $SG222599
	jmp	SHORT $LN78@Invalidate
$LN58@Invalidate:
	test	eax, eax
	jne	SHORT $LN72@Invalidate
	push	eax
	push	OFFSET $SG222603
$LN78@Invalidate:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1302 : 			CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1303 : 			if (eUnitType != NO_UNIT)

	cmp	eax, -1
	je	SHORT $LN72@Invalidate

; 1304 : 			{
; 1305 : 				GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	edx, DWORD PTR [esi]
	push	0
	push	0
	push	1
	push	0
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [ecx+8]
	push	-1
	push	38					; 00000026H
	push	edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN72@Invalidate:

; 1306 : 			}
; 1307 : 			EmptyTradeRoute(ui);

	mov	eax, DWORD PTR _ui$220684[esp+20]
	push	eax
	mov	ecx, esi
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
	mov	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN5@Invalidate:
	mov	eax, DWORD PTR _ui$220684[esp+20]
	inc	eax
	add	edi, 444				; 000001bcH
	mov	DWORD PTR _ui$220684[esp+20], eax
	cmp	eax, DWORD PTR [esi+4]
	jb	$LL75@Invalidate
	pop	ebp
	pop	ebx
$LN76@Invalidate:
	pop	edi
$LN4@Invalidate:
	pop	esi

; 1308 : 		}
; 1309 : 	}
; 1310 : }

	pop	ecx
	ret	8
?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z ENDP ; CvGameTrade::InvalidateTradeBetweenTeams
_TEXT	ENDS
PUBLIC	??0TradeConnection@@QAE@ABU0@@Z			; TradeConnection::TradeConnection
; Function compile flags: /Ogtpy
;	COMDAT ??0TradeConnection@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TradeConnection@@QAE@ABU0@@Z PROC			; TradeConnection::TradeConnection, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax
	mov	cl, BYTE PTR [edi+40]
	lea	edx, DWORD PTR [edi+44]
	mov	BYTE PTR [esi+40], cl
	push	edx
	lea	ecx, DWORD PTR [esi+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	eax, DWORD PTR [edi+380]
	mov	DWORD PTR [esi+380], eax
	mov	ecx, DWORD PTR [edi+384]
	mov	DWORD PTR [esi+384], ecx
	mov	edx, DWORD PTR [edi+388]
	mov	DWORD PTR [esi+388], edx
	mov	eax, DWORD PTR [edi+392]
	mov	DWORD PTR [esi+392], eax
	mov	ecx, DWORD PTR [edi+396]
	mov	DWORD PTR [esi+396], ecx
	mov	edx, DWORD PTR [edi+400]
	mov	DWORD PTR [esi+400], edx
	mov	eax, DWORD PTR [edi+404]
	mov	DWORD PTR [esi+404], eax
	mov	ecx, DWORD PTR [edi+408]
	mov	DWORD PTR [esi+408], ecx
	mov	edx, DWORD PTR [edi+412]
	mov	DWORD PTR [esi+412], edx
	mov	eax, DWORD PTR [edi+416]
	mov	DWORD PTR [esi+416], eax
	mov	ecx, DWORD PTR [edi+420]
	lea	eax, DWORD PTR [edi+420]
	mov	DWORD PTR [esi+420], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+424], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+428], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+432], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+436], ecx
	mov	edx, DWORD PTR [eax+20]
	pop	edi
	mov	DWORD PTR [esi+440], edx
	mov	eax, esi
	pop	esi
	ret	4
??0TradeConnection@@QAE@ABU0@@Z ENDP			; TradeConnection::TradeConnection
_TEXT	ENDS
PUBLIC	??0TradeConnectionWasPlundered@@QAE@XZ		; TradeConnectionWasPlundered::TradeConnectionWasPlundered
; Function compile flags: /Ogtpy
;	COMDAT ??0TradeConnectionWasPlundered@@QAE@XZ
_TEXT	SEGMENT
??0TradeConnectionWasPlundered@@QAE@XZ PROC		; TradeConnectionWasPlundered::TradeConnectionWasPlundered, COMDAT
; _this$ = ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 40			; 00000028H
	mov	DWORD PTR [eax+44], ecx
	ret	0
??0TradeConnectionWasPlundered@@QAE@XZ ENDP		; TradeConnectionWasPlundered::TradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	??1TradeConnectionWasPlundered@@QAE@XZ		; TradeConnectionWasPlundered::~TradeConnectionWasPlundered
; Function compile flags: /Ogtpy
;	COMDAT ??1TradeConnectionWasPlundered@@QAE@XZ
_TEXT	SEGMENT
??1TradeConnectionWasPlundered@@QAE@XZ PROC		; TradeConnectionWasPlundered::~TradeConnectionWasPlundered, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN9@TradeConne@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN9@TradeConne@2:
	ret	0
??1TradeConnectionWasPlundered@@QAE@XZ ENDP		; TradeConnectionWasPlundered::~TradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	??4TradeConnection@@QAEAAU0@ABU0@@Z		; TradeConnection::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4TradeConnection@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4TradeConnection@@QAEAAU0@ABU0@@Z PROC		; TradeConnection::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax
	mov	cl, BYTE PTR [edi+40]
	lea	edx, DWORD PTR [edi+44]
	mov	BYTE PTR [esi+40], cl
	push	edx
	lea	ecx, DWORD PTR [esi+44]
	call	??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=
	mov	eax, DWORD PTR [edi+380]
	mov	DWORD PTR [esi+380], eax
	mov	ecx, DWORD PTR [edi+384]
	mov	DWORD PTR [esi+384], ecx
	mov	edx, DWORD PTR [edi+388]
	mov	DWORD PTR [esi+388], edx
	mov	eax, DWORD PTR [edi+392]
	mov	DWORD PTR [esi+392], eax
	mov	ecx, DWORD PTR [edi+396]
	mov	DWORD PTR [esi+396], ecx
	mov	edx, DWORD PTR [edi+400]
	mov	DWORD PTR [esi+400], edx
	mov	eax, DWORD PTR [edi+404]
	mov	DWORD PTR [esi+404], eax
	mov	ecx, DWORD PTR [edi+408]
	mov	DWORD PTR [esi+408], ecx
	mov	edx, DWORD PTR [edi+412]
	mov	DWORD PTR [esi+412], edx
	mov	eax, DWORD PTR [edi+416]
	mov	DWORD PTR [esi+416], eax
	mov	ecx, DWORD PTR [edi+420]
	mov	DWORD PTR [esi+420], ecx
	mov	edx, DWORD PTR [edi+424]
	mov	DWORD PTR [esi+424], edx
	mov	eax, DWORD PTR [edi+428]
	mov	DWORD PTR [esi+428], eax
	mov	ecx, DWORD PTR [edi+432]
	mov	DWORD PTR [esi+432], ecx
	mov	edx, DWORD PTR [edi+436]
	mov	DWORD PTR [esi+436], edx
	mov	eax, DWORD PTR [edi+440]
	mov	DWORD PTR [esi+440], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??4TradeConnection@@QAEAAU0@ABU0@@Z ENDP		; TradeConnection::operator=
_TEXT	ENDS
PUBLIC	??0TRSortElement@@QAE@XZ			; TRSortElement::TRSortElement
; Function compile flags: /Ogtpy
;	COMDAT ??0TRSortElement@@QAE@XZ
_TEXT	SEGMENT
??0TRSortElement@@QAE@XZ PROC				; TRSortElement::TRSortElement, COMDAT
; _this$ = ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 40			; 00000028H
	mov	DWORD PTR [eax+44], ecx
	ret	0
??0TRSortElement@@QAE@XZ ENDP				; TRSortElement::TRSortElement
_TEXT	ENDS
PUBLIC	??1TRSortElement@@QAE@XZ			; TRSortElement::~TRSortElement
; Function compile flags: /Ogtpy
;	COMDAT ??1TRSortElement@@QAE@XZ
_TEXT	SEGMENT
??1TRSortElement@@QAE@XZ PROC				; TRSortElement::~TRSortElement, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN9@TRSortElem
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN9@TRSortElem:
	ret	0
??1TRSortElement@@QAE@XZ ENDP				; TRSortElement::~TRSortElement
_TEXT	ENDS
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+332], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??0TradeConnectionWasPlundered@@QAE@ABU0@@Z	; TradeConnectionWasPlundered::TradeConnectionWasPlundered
; Function compile flags: /Ogtpy
;	COMDAT ??0TradeConnectionWasPlundered@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TradeConnectionWasPlundered@@QAE@ABU0@@Z PROC	; TradeConnectionWasPlundered::TradeConnectionWasPlundered, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0TradeConnectionWasPlundered@@QAE@ABU0@@Z ENDP	; TradeConnectionWasPlundered::TradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	??_GTradeConnection@@QAEPAXI@Z			; TradeConnection::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GTradeConnection@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTradeConnection@@QAEPAXI@Z PROC			; TradeConnection::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN9@scalar@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN9@scalar@5:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN23@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GTradeConnection@@QAEPAXI@Z ENDP			; TradeConnection::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GTradeConnectionWasPlundered@@QAEPAXI@Z	; TradeConnectionWasPlundered::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GTradeConnectionWasPlundered@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTradeConnectionWasPlundered@@QAEPAXI@Z PROC		; TradeConnectionWasPlundered::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN12@scalar@6
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN12@scalar@6:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN26@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GTradeConnectionWasPlundered@@QAEPAXI@Z ENDP		; TradeConnectionWasPlundered::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0TRSortElement@@QAE@ABU0@@Z			; TRSortElement::TRSortElement
; Function compile flags: /Ogtpy
;	COMDAT ??0TRSortElement@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TRSortElement@@QAE@ABU0@@Z PROC			; TRSortElement::TRSortElement, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0TRSortElement@@QAE@ABU0@@Z ENDP			; TRSortElement::TRSortElement
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvString *,CvString *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN19@Unchecked_@4
$LL12@Unchecked_@4:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL12@Unchecked_@4
$LN19@Unchecked_@4:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z
_TEXT	SEGMENT
$T241003 = -4						; size = 1
__Cat$241008 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241003[esp+4], 0
	mov	eax, DWORD PTR $T241003[esp+4]
	mov	ecx, DWORD PTR __Cat$241008[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z
_TEXT	SEGMENT
$T241012 = -4						; size = 1
__Cat$241017 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241012[esp+4], 0
	mov	eax, DWORD PTR $T241012[esp+4]
	mov	ecx, DWORD PTR __Cat$241017[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??4TRSortElement@@QAEAAU0@ABU0@@Z		; TRSortElement::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4TRSortElement@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4TRSortElement@@QAEAAU0@ABU0@@Z PROC			; TRSortElement::operator=, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??4TRSortElement@@QAEAAU0@ABU0@@Z ENDP			; TRSortElement::operator=
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ; std::allocator<CvString>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z PROC ; std::allocator<CvString>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ENDP ; std::allocator<CvString>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241198 = -28						; size = 4
__Vptr$241206 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	mov	eax, DWORD PTR __First$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

$LL14@Uninit_cop@6:
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$241206[ebp], esi
	mov	DWORD PTR $T241198[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN26@Uninit_cop@6
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR __First$[ebp]
$LN26@Uninit_cop@6:
	add	esi, 28					; 0000001cH
	add	eax, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	mov	DWORD PTR __First$[ebp], eax
	jmp	SHORT $LL14@Uninit_cop@6
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@6
	npad	6
$LL3@Uninit_cop@6:

; 134  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN50@Uninit_cop@6:
$LN4@Uninit_cop@6:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@Uninit_cop@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$241206[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241198[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
PUBLIC	??$_Copy_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN9@Copy_backw@5
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	sub	esi, 448				; 000001c0H
	sub	edi, 448				; 000001c0H
	push	esi
	mov	ecx, edi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@5

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN9@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z ; std::_Construct<TRSortElement,TRSortElement>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z
_TEXT	SEGMENT
$T241263 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z PROC ; std::_Construct<TRSortElement,TRSortElement>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	esi, DWORD PTR __Ptr$[esp+16]
	mov	DWORD PTR __Vptr$[esp+16], esi

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T241263[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	esi, esi
	je	SHORT $LN3@Construct@4
	push	edi
	mov	edi, DWORD PTR __Val$[esp+20]
	push	edi
	mov	ecx, esi
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
	pop	edi
$LN3@Construct@4:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T241263[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z ENDP ; std::_Construct<TRSortElement,TRSortElement>
PUBLIC	??_GTRSortElement@@QAEPAXI@Z			; TRSortElement::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GTRSortElement@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTRSortElement@@QAEPAXI@Z PROC			; TRSortElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN12@scalar@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN12@scalar@7:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN26@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GTRSortElement@@QAEPAXI@Z ENDP			; TRSortElement::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z ; std::lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z
_TEXT	SEGMENT
$T241371 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z PROC ; std::lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,SortTR>, COMDAT

; 2313 : 	{	// find first element not before _Val, using _Pred

	push	ecx

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T241371[esp+24]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2317 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,SortTR>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z ; std::upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z
_TEXT	SEGMENT
$T241378 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z PROC ; std::upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,SortTR>, COMDAT

; 2384 : 	{	// find first element that _Val is before, using _Pred

	push	ecx

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T241378[esp+24]
	push	ecx
	call	??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2388 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,SortTR>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241418 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$241426 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@7:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$241426[ebp], esi
	mov	DWORD PTR $T241418[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@7
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_cop@7:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $LL6@Uninit_cop@7
__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@7
$LL3@Uninit_cop@7:

; 134  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_cop@7:
$LN4@Uninit_cop@7:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_cop@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$241426[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241418[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ; std::swap<TRSortElement>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z$0
__ehfuncinfo$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	ENDS
;	COMDAT ??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
_TEXT	SEGMENT
__Tmp$227093 = -460					; size = 448
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z PROC ; std::swap<TRSortElement>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 448				; 000001c0H
	push	esi

; 18   : 	if (&_Left != &_Right)

	mov	esi, DWORD PTR __Left$[esp+460]
	push	edi
	mov	edi, DWORD PTR __Right$[esp+464]
	cmp	esi, edi
	je	SHORT $LN20@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	push	esi
	lea	ecx, DWORD PTR __Tmp$227093[esp+472]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR __Tmp$227093[esp+912], eax

; 21   : 
; 22   : 		_Left = _Right;

	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+480], 0
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR [edi+444]

; 23   : 		_Right = _Tmp;

	lea	edx, DWORD PTR __Tmp$227093[esp+468]
	mov	DWORD PTR [esi+444], ecx
	push	edx
	mov	ecx, edi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR __Tmp$227093[esp+912]
	mov	DWORD PTR [edi+444], eax

; 24   : 		}

	mov	eax, DWORD PTR __Tmp$227093[esp+512]
	lea	ecx, DWORD PTR __Tmp$227093[esp+524]
	mov	DWORD PTR __$EHRec$[esp+476], -1
	cmp	eax, ecx
	je	SHORT $LN20@swap
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@swap:

; 25   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+468]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 460				; 000001ccH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z$0:
	lea	ecx, DWORD PTR __Tmp$227093[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ENDP ; std::swap<TRSortElement>
PUBLIC	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z PROC ; std::_Temp_iterator<TRSortElement>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	esi
	mov	esi, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@15
	push	ebx

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ebx, DWORD PTR __Val$[esp+4]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [edi+448]
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR [eax+4], edx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [ebx+444]
	mov	DWORD PTR [edi+444], eax
	pop	edi
	pop	ebx

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, esi
	pop	esi

; 573  : 		}

	ret	4
$LN2@operator@15:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	push	eax
	call	??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z ; std::_Construct<TRSortElement,TRSortElement>

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR [esi+16]
	add	DWORD PTR [eax+4], 448			; 000001c0H
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+4]
	add	esp, 8
	mov	DWORD PTR [eax+8], ecx

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, esi
	pop	esi

; 573  : 		}

	ret	4
??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ENDP ; std::_Temp_iterator<TRSortElement>::operator=
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN29@Copy_backw@6
	push	esi
	push	edi
	npad	4
$LL2@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp+4]
	sub	eax, 448				; 000001c0H
	sub	ecx, 448				; 000001c0H
	push	eax
	mov	DWORD PTR __Last$[esp+8], eax
	mov	esi, eax
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	edi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	mov	eax, DWORD PTR __Last$[esp+4]
	cmp	DWORD PTR __First$[esp+4], eax
	jne	SHORT $LL2@Copy_backw@6

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2678 : 	}

	ret	0
$LN29@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN30@Copy_opt@4
	push	esi
	push	edi
$LL12@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	push	eax
	mov	esi, eax
	mov	edi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	mov	eax, DWORD PTR __First$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	add	eax, 448				; 000001c0H
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __Dest$[esp+4], ecx
	mov	DWORD PTR __First$[esp+4], eax
	cmp	eax, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL12@Copy_opt@4
	pop	edi
	pop	esi
$LN30@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN17@Copy_backw@7
	push	edi
	npad	1
$LL2@Copy_backw@7:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	sub	ecx, 448				; 000001c0H
	sub	esi, 448				; 000001c0H
	push	esi
	mov	DWORD PTR __Dest$[esp+12], ecx
	mov	edi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@7

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	ecx, DWORD PTR __Dest$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 2678 : 	}

	ret	0
$LN17@Copy_backw@7:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN18@Copy_opt@5
	push	edi
$LL3@Copy_opt@5:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	edi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	mov	ecx, DWORD PTR __Dest$[esp+8]
	add	ecx, 448				; 000001c0H
	add	esi, 448				; 000001c0H
	mov	DWORD PTR __Dest$[esp+8], ecx
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@5
	pop	edi
$LN18@Copy_opt@5:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z$0
__ehfuncinfo$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
_TEXT	SEGMENT
__Count$ = -484						; size = 4
tv603 = -480						; size = 4
tv431 = -476						; size = 4
$T241739 = -472						; size = 4
$T241744 = -468						; size = 4
$T241743 = -464						; size = 4
__Holeval$227550 = -460					; size = 448
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z PROC ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	-1
	push	__ehhandler$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 472				; 000001d8H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp+480]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+492]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+492]
	sar	edx, 8
	mov	ebx, edx
	sub	ecx, edi
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, ecx
	mov	DWORD PTR __Count$[esp+496], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
	npad	7
$LL124@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	DWORD PTR __Count$[esp+496], esi
	mov	eax, DWORD PTR __Count$[esp+496]
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL124@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate
	mov	esi, ebx
	imul	esi, 448				; 000001c0H
	imul	eax, 448				; 000001c0H
	push	ebp
	mov	DWORD PTR tv431[esp+500], esi
	mov	DWORD PTR tv603[esp+500], eax
	jmp	SHORT $LN5@Rotate
	npad	6
$LL123@Rotate:
	mov	edi, DWORD PTR __First$[esp+496]
	mov	esi, DWORD PTR tv431[esp+500]
	mov	eax, DWORD PTR tv603[esp+500]
$LN5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	lea	ebp, DWORD PTR [eax+edi]

; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	push	ebp
	lea	ecx, DWORD PTR __Holeval$227550[esp+504]
	mov	edi, ebp
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [ebp+444]
	mov	DWORD PTR __Holeval$227550[esp+944], eax

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	eax, DWORD PTR [esi+ebp]
	mov	DWORD PTR __$EHRec$[esp+508], 0
	cmp	eax, DWORD PTR __Last$[esp+496]
	jne	SHORT $LN11@Rotate
	lea	eax, DWORD PTR __First$[esp+496]
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	DWORD PTR $T241739[esp+500], eax
	lea	eax, DWORD PTR $T241739[esp+500]
$LN12@Rotate:
	mov	esi, DWORD PTR [eax]

; 1698 : 			while (_Next1 != _Hole)

	cmp	esi, ebp
	je	SHORT $LN1@Rotate
	npad	7
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	push	esi
	mov	ecx, edi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], ecx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ecx, DWORD PTR __Last$[esp+496]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	mov	edi, esi
	jge	SHORT $LN13@Rotate
	mov	edx, DWORD PTR tv431[esp+500]
	add	edx, esi
	mov	DWORD PTR $T241743[esp+500], edx
	lea	eax, DWORD PTR $T241743[esp+500]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	ecx, ebx
	sub	ecx, eax
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __First$[esp+496]
	lea	eax, DWORD PTR $T241744[esp+500]
	mov	DWORD PTR $T241744[esp+500], ecx
$LN14@Rotate:
	mov	esi, DWORD PTR [eax]
	cmp	esi, ebp
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	lea	edx, DWORD PTR __Holeval$227550[esp+500]
	push	edx
	mov	ecx, edi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR __Holeval$227550[esp+944]
	mov	DWORD PTR [edi+444], eax

; 1706 : 			}

	mov	eax, DWORD PTR __Holeval$227550[esp+544]
	lea	ecx, DWORD PTR __Holeval$227550[esp+556]
	mov	DWORD PTR __$EHRec$[esp+508], -1
	cmp	eax, ecx
	je	SHORT $LN4@Rotate
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN4@Rotate:
	mov	eax, DWORD PTR __Count$[esp+500]
	sub	DWORD PTR tv603[esp+500], 448		; 000001c0H
	dec	eax
	mov	DWORD PTR __Count$[esp+500], eax
	test	eax, eax
	jg	$LL123@Rotate
	pop	ebp
$LN3@Rotate:

; 1707 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+496]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 484				; 000001e4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z$0:
	lea	ecx, DWORD PTR __Holeval$227550[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1985 : 		return (iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1986 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jbe	SHORT $LN20@end

; 1998 : 			_Tmp += _Mysize;

	push	ecx
	mov	ecx, esi
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@end:

; 1999 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2000 : 		}

	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 2013 : 		if (0 < _Mysize)

	cmp	DWORD PTR [ecx], 0
	jbe	SHORT $LN36@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Where$[esp]
	sub	edx, ecx
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[esp+4]
	mov	ecx, esi
	push	edx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@Make_iter:

; 2015 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2016 : 		}

	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
PUBLIC	??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T242616 = -4						; size = 1
__Cat$242621 = 8					; size = 1
$T242618 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2587 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 2588 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2589 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242621[esp]
	mov	edx, DWORD PTR $T242618[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T242616[esp+8], 0
	mov	eax, DWORD PTR $T242616[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2590 : 	}

	pop	ecx
	ret	0
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi
	push	edi
$LL2@Copy_backw@8:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	esi, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR __Last$[esp+8]
	cmp	DWORD PTR __First$[esp+4], esi
	jne	SHORT $LN9@Copy_backw@8
	cmp	DWORD PTR __First$[esp+8], ecx
	je	SHORT $LN61@Copy_backw@8
$LN9@Copy_backw@8:

; 2676 : 		*--_Dest = *--_Last;

	test	ecx, ecx
	je	SHORT $LN16@Copy_backw@8
	dec	ecx
	jmp	SHORT $LN62@Copy_backw@8
$LN16@Copy_backw@8:
	sub	esi, 4
	mov	DWORD PTR __Last$[esp+4], esi
	mov	ecx, 31					; 0000001fH
$LN62@Copy_backw@8:
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR __Last$[esp+8], ecx
	test	edx, edx
	je	SHORT $LN30@Copy_backw@8
	dec	edx
	jmp	SHORT $LN63@Copy_backw@8
$LN30@Copy_backw@8:
	sub	eax, 4
	mov	DWORD PTR __Dest$[esp+4], eax
	mov	edx, 31					; 0000001fH
$LN63@Copy_backw@8:
	mov	edi, 1
	shl	edi, cl
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	ecx, edx
	test	edi, DWORD PTR [esi]
	mov	esi, 1
	je	SHORT $LN48@Copy_backw@8
	shl	esi, cl
	or	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@8
$LN48@Copy_backw@8:
	shl	esi, cl
	not	esi
	and	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@8
$LN61@Copy_backw@8:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@7
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@7:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@3
	pop	esi
$LN9@Uninit_fil@3:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
EXTRN	?IsRazing@CvCity@@QBE_NXZ:PROC			; CvCity::IsRazing
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::AllowsProductionTradeRoutes
EXTRN	?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::AllowsFoodTradeRoutes
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eDestTeam$ = -4					; size = 4
_iDestY$220263 = 8					; size = 4
_bAllowsProductionConnection$220241 = 8			; size = 1
_bAllowsFoodConnection$220225 = 8			; size = 1
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
_iDestX$220262 = 24					; size = 4
_bIgnoreExisting$ = 24					; size = 1
_bCheckPath$ = 28					; size = 1
?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z PROC ; CvGameTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 97   : {

	sub	esp, 8
	push	ebx

; 98   : 	if (pOriginCity == NULL)

	mov	ebx, DWORD PTR _pOriginCity$[esp+8]
	mov	DWORD PTR _this$[esp+12], ecx
	test	ebx, ebx
	jne	SHORT $LN38@CanCreateT

; 99   : 	{
; 100  : 		return false;

	xor	al, al
	pop	ebx

; 245  : }

	add	esp, 8
	ret	24					; 00000018H
$LN38@CanCreateT:
	push	ebp

; 101  : 	}
; 102  : 
; 103  : 	if (pDestCity == NULL)

	mov	ebp, DWORD PTR _pDestCity$[esp+12]
	test	ebp, ebp

; 104  : 	{
; 105  : 		return false;

	je	SHORT $LN108@CanCreateT

; 106  : 	}
; 107  : 
; 108  : 	// A city may not trade with itself
; 109  : 	if (pOriginCity == pDestCity)

	cmp	ebx, ebp
	jne	SHORT $LN36@CanCreateT
$LN108@CanCreateT:
	pop	ebp

; 110  : 	{
; 111  : 		return false;

	xor	al, al
	pop	ebx

; 245  : }

	add	esp, 8
	ret	24					; 00000018H
$LN36@CanCreateT:
	push	esi
	push	edi

; 112  : 	}
; 113  : 
; 114  : 	TeamTypes eOriginTeam = pOriginCity->getTeam();

	mov	ecx, ebx
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam

; 115  : 	TeamTypes eDestTeam = pDestCity->getTeam();

	mov	ecx, ebp
	mov	esi, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	edi, eax

; 116  : 
; 117  : 	if (eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	eax, DWORD PTR _eConnectionType$[esp+20]
	mov	DWORD PTR _eDestTeam$[esp+24], edi
	test	eax, eax
	jne	SHORT $LN35@CanCreateT

; 118  : 	{
; 119  : 		// can't have an international trade route within the same team
; 120  : 		if (eOriginTeam == eDestTeam)

	cmp	esi, edi
	jne	$LN11@CanCreateT
$LN7@CanCreateT:
	pop	edi
	pop	esi
	pop	ebp

; 218  : 	{
; 219  : 		return false;

	xor	al, al
	pop	ebx

; 245  : }

	add	esp, 8
	ret	24					; 00000018H
$LN35@CanCreateT:

; 121  : 		{
; 122  : 			return false;
; 123  : 		}
; 124  : 	}
; 125  : 	else if (eConnectionType == TRADE_CONNECTION_PRODUCTION || eConnectionType == TRADE_CONNECTION_FOOD)

	cmp	eax, 2
	je	SHORT $LN98@CanCreateT
	cmp	eax, 1
	jne	$LN11@CanCreateT
$LN98@CanCreateT:

; 126  : 	{
; 127  : 		// can't have production or food connections internationally
; 128  : 		if (eOriginTeam != eDestTeam)

	cmp	esi, edi

; 129  : 		{
; 130  : 			return false;

	jne	SHORT $LN7@CanCreateT

; 131  : 		}
; 132  : 
; 133  : 		if (eConnectionType == TRADE_CONNECTION_FOOD)

	cmp	eax, 1
	jne	$LN29@CanCreateT

; 134  : 		{
; 135  : 			bool bAllowsFoodConnection = false;
; 136  : #ifdef AUI_WARNING_FIXES
; 137  : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 138  : #else
; 139  : 			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bAllowsFoodConnection$220225[esp+20], 0
	xor	ebp, ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN7@CanCreateT
	npad	12
$LL28@CanCreateT:

; 140  : #endif
; 141  : 			{
; 142  : 				BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 143  : 				if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN27@CanCreateT

; 144  : 				{
; 145  : 					CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	edi, eax

; 146  : #ifndef AUI_WARNING_FIXES
; 147  : 					if (!pBuildingEntry)

	test	edi, edi
	je	SHORT $LN27@CanCreateT

; 148  : 					{
; 149  : 						continue;
; 150  : 					}
; 151  : #endif
; 152  : 
; 153  : 					if (pBuildingEntry && pBuildingEntry->AllowsFoodTradeRoutes())

	mov	ecx, edi
	call	?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsFoodTradeRoutes
	test	al, al
	je	SHORT $LN27@CanCreateT

; 154  : 					{
; 155  : 						if (pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()) > 0)

	mov	edi, DWORD PTR [edi+4]
	push	edi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN27@CanCreateT

; 156  : 						{
; 157  : 							bAllowsFoodConnection = true;

	mov	BYTE PTR _bAllowsFoodConnection$220225[esp+20], 1
$LN27@CanCreateT:

; 134  : 		{
; 135  : 			bool bAllowsFoodConnection = false;
; 136  : #ifdef AUI_WARNING_FIXES
; 137  : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 138  : #else
; 139  : 			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	SHORT $LL28@CanCreateT

; 158  : 						}
; 159  : 					}
; 160  : 				}
; 161  : 			}
; 162  : 
; 163  : 			if (!bAllowsFoodConnection)

	cmp	BYTE PTR _bAllowsFoodConnection$220225[esp+20], 0
	jne	$LN103@CanCreateT
	pop	edi
	pop	esi
	pop	ebp

; 218  : 	{
; 219  : 		return false;

	xor	al, al
	pop	ebx

; 245  : }

	add	esp, 8
	ret	24					; 00000018H
$LN29@CanCreateT:

; 164  : 			{
; 165  : 				return false;
; 166  : 			}
; 167  : 		}
; 168  : 		else if (eConnectionType == TRADE_CONNECTION_PRODUCTION)

	cmp	eax, 2
	jne	$LN11@CanCreateT

; 169  : 		{
; 170  : 			bool bAllowsProductionConnection = false;
; 171  : #ifdef AUI_WARNING_FIXES
; 172  : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 173  : #else
; 174  : 			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bAllowsProductionConnection$220241[esp+20], 0
	xor	ebp, ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN7@CanCreateT
	npad	9
$LL18@CanCreateT:

; 175  : #endif
; 176  : 			{
; 177  : 				BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 178  : 				if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN17@CanCreateT

; 179  : 				{
; 180  : 					CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	edi, eax

; 181  : #ifndef AUI_WARNING_FIXES
; 182  : 					if (!pBuildingEntry)

	test	edi, edi
	je	SHORT $LN17@CanCreateT

; 183  : 					{
; 184  : 						continue;
; 185  : 					}
; 186  : #endif
; 187  : 
; 188  : 					if (pBuildingEntry && pBuildingEntry->AllowsProductionTradeRoutes())

	mov	ecx, edi
	call	?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsProductionTradeRoutes
	test	al, al
	je	SHORT $LN17@CanCreateT

; 189  : 					{
; 190  : 						if (pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()) > 0)

	mov	edi, DWORD PTR [edi+4]
	push	edi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN17@CanCreateT

; 191  : 						{
; 192  : 							bAllowsProductionConnection = true;

	mov	BYTE PTR _bAllowsProductionConnection$220241[esp+20], 1
$LN17@CanCreateT:

; 169  : 		{
; 170  : 			bool bAllowsProductionConnection = false;
; 171  : #ifdef AUI_WARNING_FIXES
; 172  : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 173  : #else
; 174  : 			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	SHORT $LL18@CanCreateT

; 193  : 						}
; 194  : 					}
; 195  : 				}
; 196  : 			}
; 197  : 
; 198  : 			if (!bAllowsProductionConnection)

	cmp	BYTE PTR _bAllowsProductionConnection$220241[esp+20], 0

; 199  : 			{
; 200  : 				return false;

	je	$LN7@CanCreateT
$LN103@CanCreateT:

; 193  : 						}
; 194  : 					}
; 195  : 				}
; 196  : 			}
; 197  : 
; 198  : 			if (!bAllowsProductionConnection)

	mov	ebp, DWORD PTR _pDestCity$[esp+20]
	mov	edi, DWORD PTR _eDestTeam$[esp+24]
$LN11@CanCreateT:

; 201  : 			}
; 202  : 		}
; 203  : 	}
; 204  : 
; 205  : 	// teams at war can't fight
; 206  : 	if (GET_TEAM(eOriginTeam).isAtWar(eDestTeam))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	esi, 2984				; 00000ba8H
	lea	ecx, DWORD PTR [esi+eax]
	push	edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 207  : 	{
; 208  : 		return false;

	jne	$LN7@CanCreateT

; 209  : 	}
; 210  : 
; 211  : 	// teams that have not met cannot trade
; 212  : 	if (!GET_TEAM(eOriginTeam).isHasMet(eDestTeam))

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	push	edi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 213  : 	{
; 214  : 		return false;

	je	$LN7@CanCreateT

; 215  : 	}
; 216  : 
; 217  : 	if (pOriginCity->IsRazing() || pDestCity->IsRazing())

	mov	ecx, ebx
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	test	al, al
	jne	$LN7@CanCreateT
	mov	ecx, ebp
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	test	al, al
	jne	$LN7@CanCreateT

; 220  : 	}
; 221  : 
; 222  : 	if (!bIgnoreExisting)

	cmp	BYTE PTR _bIgnoreExisting$[esp+20], al
	jne	SHORT $LN102@CanCreateT

; 223  : 	{
; 224  : 		int iOriginX = pOriginCity->getX();
; 225  : 		int iOriginY = pOriginCity->getY();
; 226  : 		int iDestX = pDestCity->getX();

	mov	eax, DWORD PTR _pDestCity$[esp+20]
	mov	edx, DWORD PTR [eax+96]

; 227  : 		int iDestY = pDestCity->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	esi, DWORD PTR [ebx+96]
	mov	edi, DWORD PTR [ebx+108]
	mov	DWORD PTR _iDestX$220262[esp+20], edx

; 228  : 
; 229  : 		// check for duplicate routes
; 230  : 		for (uint i = 0; i < m_aTradeConnections.size(); i++)

	mov	edx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	DWORD PTR _iDestY$220263[esp+20], eax
	test	edx, edx
	jbe	SHORT $LN102@CanCreateT
	mov	eax, DWORD PTR _this$[esp+24]
	mov	eax, DWORD PTR [eax]
	add	eax, 8
$LL104@CanCreateT:

; 231  : 		{
; 232  : 			if (m_aTradeConnections[i].m_iOriginX == iOriginX && m_aTradeConnections[i].m_iOriginY == iOriginY && m_aTradeConnections[i].m_iDestX == iDestX && m_aTradeConnections[i].m_iDestY == iDestY)

	cmp	DWORD PTR [eax-4], esi
	jne	SHORT $LN4@CanCreateT
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN4@CanCreateT
	mov	ebp, DWORD PTR _iDestX$220262[esp+20]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN4@CanCreateT
	mov	ebp, DWORD PTR _iDestY$220263[esp+20]
	cmp	DWORD PTR [eax+8], ebp
	je	$LN7@CanCreateT
$LN4@CanCreateT:

; 228  : 
; 229  : 		// check for duplicate routes
; 230  : 		for (uint i = 0; i < m_aTradeConnections.size(); i++)

	inc	ecx
	add	eax, 444				; 000001bcH
	cmp	ecx, edx
	jb	SHORT $LL104@CanCreateT
$LN102@CanCreateT:

; 233  : 			{
; 234  : 				return false;
; 235  : 			}
; 236  : 		}
; 237  : 	}
; 238  : 
; 239  : 	if (bCheckPath && !IsValidTradeRoutePath(pOriginCity, pDestCity, eDomain))

	cmp	BYTE PTR _bCheckPath$[esp+20], 0
	je	SHORT $LN1@CanCreateT
	mov	ecx, DWORD PTR _eDomain$[esp+20]
	mov	edx, DWORD PTR _pDestCity$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+28]
	push	edx
	push	ebx
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	test	al, al

; 240  : 	{
; 241  : 		return false;

	je	$LN7@CanCreateT
$LN1@CanCreateT:
	pop	edi
	pop	esi
	pop	ebp

; 242  : 	}
; 243  : 
; 244  : 	return true;

	mov	al, 1
	pop	ebx

; 245  : }

	add	esp, 8
	ret	24					; 00000018H
?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ENDP ; CvGameTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z ; CvGameTrade::CanCreateTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pGameTrade$ = -12					; size = 4
tv192 = -8						; size = 4
_iOriginCityLoop$ = -4					; size = 4
tv195 = 8						; size = 4
_eOriginPlayer$ = 8					; size = 4
_iDestCityLoop$220282 = 12				; size = 4
_eDestPlayer$ = 12					; size = 4
_eDomainRestriction$ = 16				; size = 4
?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z PROC ; CvGameTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 253  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+28], ecx

; 254  : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 255  : 
; 256  : 	int iOriginCityLoop;
; 257  : 	CvCity* pOriginLoopCity = NULL;
; 258  : 	for(pOriginLoopCity = GET_PLAYER(eOriginPlayer).firstCity(&iOriginCityLoop); pOriginLoopCity != NULL; pOriginLoopCity = GET_PLAYER(eOriginPlayer).nextCity(&iOriginCityLoop))

	mov	edi, DWORD PTR _eOriginPlayer$[esp+28]
	imul	edi, 63236				; 0000f704H
	mov	DWORD PTR _pGameTrade$[esp+32], eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iOriginCityLoop$[esp+36]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	mov	DWORD PTR tv192[esp+40], edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN14@CanCreateT@2
	mov	esi, DWORD PTR _eDestPlayer$[esp+28]
	imul	esi, 63236				; 0000f704H
	mov	DWORD PTR tv195[esp+28], esi
$LL41@CanCreateT@2:

; 259  : 	{
; 260  : 		int iDestCityLoop;
; 261  : 		CvCity* pDestLoopCity = NULL;
; 262  : 		for(pDestLoopCity = GET_PLAYER(eDestPlayer).firstCity(&iDestCityLoop); pDestLoopCity != NULL; pDestLoopCity = GET_PLAYER(eDestPlayer).nextCity(&iDestCityLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iDestCityLoop$220282[esp+32]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN15@CanCreateT@2
	npad	2
$LL39@CanCreateT@2:

; 263  : 		{
; 264  : 			for (uint uiDomain = 0; uiDomain < NUM_DOMAIN_TYPES; uiDomain++)

	xor	edi, edi
$LL10@CanCreateT@2:

; 265  : 			{
; 266  : 				DomainTypes eDomain = (DomainTypes)uiDomain;
; 267  : 				// check only the domain we want
; 268  : 				if (eDomainRestriction != NO_DOMAIN && eDomainRestriction != eDomain)

	mov	eax, DWORD PTR _eDomainRestriction$[esp+28]
	cmp	eax, -1
	je	SHORT $LN7@CanCreateT@2
	cmp	eax, edi
	jne	SHORT $LN9@CanCreateT@2
$LN7@CanCreateT@2:

; 269  : 				{
; 270  : 					continue;
; 271  : 				}
; 272  : 
; 273  : 				if (eDomain != DOMAIN_LAND && eDomain != DOMAIN_SEA)

	cmp	edi, 2
	je	SHORT $LN40@CanCreateT@2
	test	edi, edi
	jne	SHORT $LN9@CanCreateT@2
$LN40@CanCreateT@2:

; 274  : 				{
; 275  : 					continue;
; 276  : 				}
; 277  : 
; 278  : 				for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	xor	esi, esi
	npad	6
$LL5@CanCreateT@2:

; 279  : 				{
; 280  : 					// Check the route, but not the path
; 281  : 					if (CanCreateTradeRoute(pOriginLoopCity, pDestLoopCity, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	mov	ecx, DWORD PTR _this$[esp+32]
	push	0
	push	0
	push	esi
	push	edi
	push	ebx
	push	ebp
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
	test	al, al
	jne	SHORT $LN33@CanCreateT@2
	inc	esi
	cmp	esi, 3
	jb	SHORT $LL5@CanCreateT@2

; 282  : 					{
; 283  : 						// Check the path
; 284  : 						if (pGameTrade->IsValidTradeRoutePath(pOriginLoopCity, pDestLoopCity, eDomain))

	jmp	SHORT $LN9@CanCreateT@2
$LN33@CanCreateT@2:
	mov	ecx, DWORD PTR _pGameTrade$[esp+32]
	push	edi
	push	ebx
	push	ebp
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	test	al, al
	jne	SHORT $LN34@CanCreateT@2
$LN9@CanCreateT@2:

; 263  : 		{
; 264  : 			for (uint uiDomain = 0; uiDomain < NUM_DOMAIN_TYPES; uiDomain++)

	inc	edi
	cmp	edi, 5
	jb	SHORT $LL10@CanCreateT@2
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, DWORD PTR tv195[esp+28]
	push	0
	lea	edx, DWORD PTR _iDestCityLoop$220282[esp+32]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL39@CanCreateT@2

; 259  : 	{
; 260  : 		int iDestCityLoop;
; 261  : 		CvCity* pDestLoopCity = NULL;
; 262  : 		for(pDestLoopCity = GET_PLAYER(eDestPlayer).firstCity(&iDestCityLoop); pDestLoopCity != NULL; pDestLoopCity = GET_PLAYER(eDestPlayer).nextCity(&iDestCityLoop))

	mov	edi, DWORD PTR tv192[esp+32]
$LN15@CanCreateT@2:

; 255  : 
; 256  : 	int iOriginCityLoop;
; 257  : 	CvCity* pOriginLoopCity = NULL;
; 258  : 	for(pOriginLoopCity = GET_PLAYER(eOriginPlayer).firstCity(&iOriginCityLoop); pOriginLoopCity != NULL; pOriginLoopCity = GET_PLAYER(eOriginPlayer).nextCity(&iOriginCityLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iOriginCityLoop$[esp+36]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL41@CanCreateT@2
$LN14@CanCreateT@2:
	pop	edi
	pop	esi
	pop	ebp

; 286  : 
; 287  : 						// else we can just break out of the loop
; 288  : 						break;
; 289  : 					}
; 290  : 				}
; 291  : 			}
; 292  : 		}
; 293  : 	}
; 294  : 
; 295  : 	return false;

	xor	al, al
	pop	ebx

; 296  : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN34@CanCreateT@2:
	pop	edi
	pop	esi
	pop	ebp

; 285  : 							return true;

	mov	al, 1
	pop	ebx

; 296  : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z ENDP ; CvGameTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection
; Function compile flags: /Ogtpy
;	COMDAT ?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z
_TEXT	SEGMENT
_kTradeConnectionPlot$220463 = -8			; size = 8
_pNode$ = 8						; size = 4
_pTradeConnection$ = 12					; size = 4
?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z PROC ; CvGameTrade::CopyPathIntoTradeConnection, COMDAT
; _this$ = ecx

; 673  : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 674  : 	// beyond the origin player's trade range
; 675  : #ifndef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 676  : 	int iPathSteps = 0;
; 677  : #endif
; 678  : #ifdef AUI_CONSTIFY
; 679  : 	const CvAStarNode* pWalkingPath = pNode;
; 680  : #else
; 681  : 	CvAStarNode* pWalkingPath = pNode;

	mov	edi, DWORD PTR _pNode$[esp+16]
	xor	ebp, ebp
	mov	eax, edi

; 682  : #endif
; 683  : 	while (pWalkingPath)

	test	edi, edi
	je	SHORT $LN6@CopyPathIn
$LL7@CopyPathIn:

; 684  : 	{
; 685  : #ifdef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 686  : 		TradeConnectionPlot kTradeConnectionPlot;
; 687  : 		pTradeConnection->m_aPlotList.push_back(kTradeConnectionPlot);
; 688  : #else
; 689  : 		iPathSteps++;
; 690  : #endif
; 691  : 		pWalkingPath = pWalkingPath->m_pParent;

	mov	eax, DWORD PTR [eax+24]
	inc	ebp
	test	eax, eax
	jne	SHORT $LL7@CopyPathIn
$LN6@CopyPathIn:

; 692  : 	}
; 693  : 
; 694  : #ifdef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 695  : 	int iIndex = pTradeConnection->m_aPlotList.size();
; 696  : #else
; 697  : 	pTradeConnection->m_aPlotList.clear();

	mov	esi, DWORD PTR _pTradeConnection$[esp+16]
	add	esi, 44					; 0000002cH
	mov	DWORD PTR [esi+4], 0

; 698  : 	for (int i = 0; i < iPathSteps; i++)

	test	ebp, ebp
	jle	SHORT $LN3@CopyPathIn
	push	ebx
	mov	ebx, ebp
	npad	1
$LL5@CopyPathIn:

; 699  : 	{
; 700  : 		TradeConnectionPlot kTradeConnectionPlot;
; 701  : 		pTradeConnection->m_aPlotList.push_back(kTradeConnectionPlot);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+332], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN18@CopyPathIn
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
$LN18@CopyPathIn:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN21@CopyPathIn
	mov	edx, DWORD PTR _kTradeConnectionPlot$220463[esp+24]
	mov	ecx, DWORD PTR _kTradeConnectionPlot$220463[esp+28]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
$LN21@CopyPathIn:
	inc	DWORD PTR [esi+4]
	sub	ebx, 1
	jne	SHORT $LL5@CopyPathIn
	pop	ebx
$LN3@CopyPathIn:

; 705  : #endif
; 706  : 	while (pNode != NULL)

	test	edi, edi
	je	SHORT $LN1@CopyPathIn

; 702  : 	}
; 703  : 
; 704  : 	int iIndex = iPathSteps - 1;

	lea	eax, DWORD PTR [ebp*8-8]
$LL2@CopyPathIn:

; 707  : 	{
; 708  : #ifdef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 709  : 		iIndex--;
; 710  : #endif
; 711  : 		pTradeConnection->m_aPlotList[iIndex].m_iX = pNode->m_iX;

	movsx	edx, WORD PTR [edi+80]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+ecx], edx

; 712  : 		pTradeConnection->m_aPlotList[iIndex].m_iY = pNode->m_iY;

	movsx	edx, WORD PTR [edi+82]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+eax+4], edx

; 713  : 		pNode = pNode->m_pParent;

	mov	edi, DWORD PTR [edi+24]

; 714  : #ifndef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 715  : 		iIndex--;

	sub	eax, 8
	test	edi, edi
	jne	SHORT $LL2@CopyPathIn
$LN1@CopyPathIn:
	pop	edi
	pop	esi
	pop	ebp

; 716  : #endif
; 717  : 	}
; 718  : }

	add	esp, 8
	ret	8
?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ENDP ; CvGameTrade::CopyPathIntoTradeConnection
_TEXT	ENDS
PUBLIC	?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z ; CvGameTrade::DisplayTemporaryPopupTradeRoute
EXTRN	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z:PROC ; CvGlobals::UnwrapUnitPointer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$1
__ehfuncinfo$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_iOriginY$ = -2516					; size = 4
_pSelectedUnit$220994 = -2516				; size = 4
_this$ = -2512						; size = 4
_eOriginPlayer$ = -2508					; size = 4
_tempTradeConnection$ = -2504				; size = 444
_plotsY$ = -2060					; size = 1024
_plotsX$ = -1036					; size = 1024
__$EHRec$ = -12						; size = 12
_iDestX$ = 8						; size = 4
_iDestY$ = 12						; size = 4
_type$ = 16						; size = 4
_eDomain$ = 20						; size = 4
?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z PROC ; CvGameTrade::DisplayTemporaryPopupTradeRoute, COMDAT
; _this$ = ecx

; 1929 : {

	push	-1
	push	__ehhandler$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2504				; 000009c8H
	push	ebx
	push	esi
	push	edi

; 1930 : 	int i,n;
; 1931 : 	int plotsX[MAX_PLOTS_TO_DISPLAY], plotsY[MAX_PLOTS_TO_DISPLAY];
; 1932 : 
; 1933 : 	int iOriginX,iOriginY;
; 1934 : 	PlayerTypes eOriginPlayer;
; 1935 : 	bool bSuccess = false;
; 1936 : 	CvAStarNode* pPathfinderNode = NULL;

	xor	edi, edi

; 1937 : 	TradeConnection tempTradeConnection;

	lea	eax, DWORD PTR _tempTradeConnection$[esp+2584]
	mov	DWORD PTR _this$[esp+2528], ecx
	xor	bl, bl
	mov	DWORD PTR _tempTradeConnection$[esp+2576], edi
	mov	DWORD PTR _tempTradeConnection$[esp+2580], 40 ; 00000028H
	mov	DWORD PTR _tempTradeConnection$[esp+2572], eax

; 1938 : 
; 1939 : 	{
; 1940 : 		auto_ptr<ICvUnit1> pSelectedUnit(GC.GetEngineUserInterface()->GetHeadSelectedUnit());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __$EHRec$[esp+2536], edi
	call	eax
	mov	esi, eax
	mov	DWORD PTR _pSelectedUnit$220994[esp+2528], esi

; 1941 : 		CvUnit* pkSelectedUnit = GC.UnwrapUnitPointer(pSelectedUnit.get());

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+2540], 1
	call	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ; CvGlobals::UnwrapUnitPointer

; 1952 : 		}
; 1953 : 	}

	mov	BYTE PTR __$EHRec$[esp+2536], 0
	cmp	eax, edi
	je	$LN11@DisplayTem
	mov	ecx, DWORD PTR [eax+88]
	push	ebp
	mov	ebp, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [eax+40]
	mov	DWORD PTR _iOriginY$[esp+2532], ecx
	mov	DWORD PTR _eOriginPlayer$[esp+2532], eax
	test	esi, esi
	je	SHORT $LN69@DisplayTem
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
	mov	ecx, DWORD PTR _iOriginY$[esp+2532]
	mov	eax, DWORD PTR _eOriginPlayer$[esp+2532]
$LN69@DisplayTem:

; 1954 : 
; 1955 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 1956 : 	PlayerTypes eDestPlayer = NO_PLAYER;
; 1957 : 	CvPlot* pDestPlot = GC.getMap().plot(iDestX, iDestY);
; 1958 : 	if (pDestPlot)
; 1959 : 	{
; 1960 : 		CvCity* pDestCity = pDestPlot->getPlotCity();
; 1961 : 		if (pDestCity)
; 1962 : 		{
; 1963 : 			eDestPlayer = pDestCity->getOwner();
; 1964 : 		}
; 1965 : 	}
; 1966 : #endif
; 1967 : 
; 1968 : 	switch (eDomain)

	mov	edx, DWORD PTR _eDomain$[esp+2528]
	sub	edx, 0
	je	SHORT $LN6@DisplayTem
	sub	edx, 2
	jne	SHORT $LN8@DisplayTem

; 1969 : 	{
; 1970 : 	case DOMAIN_LAND:
; 1971 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 1972 : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 1973 : #else
; 1974 : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	edx
	mov	edx, DWORD PTR _iDestX$[esp+2532]
	push	eax
	mov	eax, DWORD PTR _iDestY$[esp+2536]
	push	eax
	push	edx
	push	ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 1975 : #endif
; 1976 : 		pPathfinderNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, al
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder

; 1977 : 		break;

	jmp	SHORT $LN116@DisplayTem
$LN6@DisplayTem:

; 1978 : 	case DOMAIN_SEA:
; 1979 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 1980 : 		bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 1981 : #else
; 1982 : 		bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	mov	edx, DWORD PTR _iDestX$[esp+2528]
	push	0
	push	eax
	mov	eax, DWORD PTR _iDestY$[esp+2536]
	push	eax
	push	edx
	push	ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 1983 : #endif
; 1984 : 		pPathfinderNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, al
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
$LN116@DisplayTem:
	mov	edi, DWORD PTR [eax+96]
$LN8@DisplayTem:

; 1985 : 		break;
; 1986 : 	}
; 1987 : 
; 1988 : 	gDLL->TradeVisuals_DestroyRoute(TEMPORARY_POPUPROUTE_ID,GC.getGame().getActivePlayer());

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	esi, DWORD PTR [ebp]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esi, 980				; 000003d4H
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	mov	eax, DWORD PTR [esi]
	push	-1
	mov	ecx, ebp
	call	eax

; 1989 : 	if (bSuccess && pPathfinderNode != NULL) {

	test	bl, bl
	mov	ebx, DWORD PTR _type$[esp+2528]
	pop	ebp
	je	$LN113@DisplayTem
	test	edi, edi
	je	$LN113@DisplayTem

; 1990 : 		CopyPathIntoTradeConnection(pPathfinderNode, &tempTradeConnection);

	mov	esi, DWORD PTR _this$[esp+2528]
	lea	ecx, DWORD PTR _tempTradeConnection$[esp+2528]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection

; 1991 : 		n = tempTradeConnection.m_aPlotList.size();
; 1992 : 		if (n>0 && n <=MAX_PLOTS_TO_DISPLAY) {

	mov	edx, DWORD PTR _tempTradeConnection$[esp+2576]
	test	edx, edx
	jle	SHORT $LN114@DisplayTem
	cmp	edx, 256				; 00000100H
	jg	SHORT $LN114@DisplayTem

; 1993 : 			for (i=0;i<n;++i) {

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1@DisplayTem
	mov	ecx, DWORD PTR _tempTradeConnection$[esp+2572]
	npad	4
$LL3@DisplayTem:

; 1994 : 				plotsX[i] = tempTradeConnection.m_aPlotList[i].m_iX;

	mov	edi, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _plotsX$[esp+eax*4+2528], edi

; 1995 : 				plotsY[i] = tempTradeConnection.m_aPlotList[i].m_iY;

	mov	edi, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _plotsY$[esp+eax*4+2528], edi
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL3@DisplayTem
$LN1@DisplayTem:

; 1996 : 			}
; 1997 : 			gDLL->TradeVisuals_NewRoute(TEMPORARY_POPUPROUTE_ID,eOriginPlayer,type,n,plotsX,plotsY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+972]
	lea	edi, DWORD PTR _plotsY$[esp+2528]
	push	edi
	lea	edi, DWORD PTR _plotsX$[esp+2532]
	push	edi
	push	edx
	mov	edx, DWORD PTR _eOriginPlayer$[esp+2540]
	push	ebx
	push	edx
	push	-1
	call	eax

; 1998 : 			gDLL->TradeVisuals_ActivatePopupRoute(TEMPORARY_POPUPROUTE_ID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+984]
	push	-1
	call	eax
	jmp	SHORT $LN114@DisplayTem
$LN113@DisplayTem:
	mov	esi, DWORD PTR _this$[esp+2528]
$LN114@DisplayTem:

; 1999 : 		}
; 2000 : 	}
; 2001 : 	m_CurrentTemporaryPopupRoute.iPlotX = iDestX;

	mov	ecx, DWORD PTR _iDestX$[esp+2524]

; 2002 : 	m_CurrentTemporaryPopupRoute.iPlotY = iDestY;

	mov	edx, DWORD PTR _iDestY$[esp+2524]
	mov	DWORD PTR [esi+76548], ecx
	mov	DWORD PTR [esi+76552], edx

; 2003 : 	m_CurrentTemporaryPopupRoute.type = type;

	mov	DWORD PTR [esi+76556], ebx

; 2004 : }

	jmp	SHORT $LN47@DisplayTem
$LN11@DisplayTem:

; 1942 : 		CvAssert(pkSelectedUnit != NULL);
; 1943 : 		if (pkSelectedUnit)
; 1944 : 		{
; 1945 : 			iOriginX = pkSelectedUnit->getX();
; 1946 : 			iOriginY = pkSelectedUnit->getY();
; 1947 : 			eOriginPlayer = pkSelectedUnit->getOwner();
; 1948 : 		}
; 1949 : 		else
; 1950 : 		{
; 1951 : 			return;

	cmp	esi, edi
	je	SHORT $LN47@DisplayTem
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax
$LN47@DisplayTem:
	mov	eax, DWORD PTR _tempTradeConnection$[esp+2572]
	lea	ecx, DWORD PTR _tempTradeConnection$[esp+2584]
	mov	DWORD PTR __$EHRec$[esp+2536], -1
	cmp	eax, ecx
	je	SHORT $LN55@DisplayTem
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN55@DisplayTem:

; 2004 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2528]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 2516				; 000009d4H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _tempTradeConnection$[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$1:
	lea	ecx, DWORD PTR _pSelectedUnit$220994[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z ENDP ; CvGameTrade::DisplayTemporaryPopupTradeRoute
PUBLIC	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
EXTRN	?IsAllowedToTradeWith@CvPlayer@@QAE_NW4PlayerTypes@@@Z:PROC ; CvPlayer::IsAllowedToTradeWith
; Function compile flags: /Ogtpy
;	COMDAT ?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z
_TEXT	SEGMENT
_pOriginCity$ = 8					; size = 4
tv208 = 12						; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
_bIgnoreExisting$ = 24					; size = 1
_bCheckPath$ = 28					; size = 1
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z PROC ; CvPlayerTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 3234 : {

	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 3235 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ebp, eax

; 3236 : 
; 3237 : 	// if you can't see the plot, you're not allowed to connect it
; 3238 : 	if (!pDestCity->plot()->isRevealed(m_pPlayer->getTeam(), false))

	mov	eax, DWORD PTR [ebx+79104]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@CanCreateT@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN14@CanCreateT@3
$LN13@CanCreateT@3:
	or	esi, -1
$LN14@CanCreateT@3:
	mov	edi, DWORD PTR _pDestCity$[esp+12]
	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, esi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv208[esp+12], ecx
	mov	ecx, esi
	mov	esi, DWORD PTR tv208[esp+12]
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [eax+edx*4+8]
	jne	SHORT $LN4@CanCreateT@3
$LN29@CanCreateT@3:
	pop	edi
	pop	esi
	pop	ebp

; 3239 : 	{
; 3240 : 		return false;

	xor	al, al
	pop	ebx

; 3249 : 	{
; 3250 : 		return true;
; 3251 : 	}
; 3252 : 	else
; 3253 : 	{
; 3254 : 		return false;
; 3255 : 	}
; 3256 : }

	ret	24					; 00000018H
$LN4@CanCreateT@3:

; 3241 : 	}
; 3242 : 
; 3243 : 	if (!m_pPlayer->IsAllowedToTradeWith(pDestCity->getOwner()))

	mov	eax, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [ebx+79104]
	push	eax
	call	?IsAllowedToTradeWith@CvPlayer@@QAE_NW4PlayerTypes@@@Z ; CvPlayer::IsAllowedToTradeWith
	test	al, al

; 3244 : 	{
; 3245 : 		return false;

	je	SHORT $LN29@CanCreateT@3

; 3246 : 	}
; 3247 : 
; 3248 : 	if (pTrade->CanCreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnectionType, bIgnoreExisting, bCheckPath))

	mov	edx, DWORD PTR _bCheckPath$[esp+12]
	mov	eax, DWORD PTR _bIgnoreExisting$[esp+12]
	mov	ecx, DWORD PTR _eConnectionType$[esp+12]
	push	edx
	mov	edx, DWORD PTR _eDomain$[esp+16]
	push	eax
	mov	eax, DWORD PTR _pOriginCity$[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	mov	ecx, ebp
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
	pop	edi
	pop	esi
	test	al, al
	pop	ebp
	setne	al
	pop	ebx

; 3249 : 	{
; 3250 : 		return true;
; 3251 : 	}
; 3252 : 	else
; 3253 : 	{
; 3254 : 		return false;
; 3255 : 	}
; 3256 : }

	ret	24					; 00000018H
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ENDP ; CvPlayerTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::CanCreateTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pGameTrade$ = -8					; size = 4
_iCityLoop$ = -4					; size = 4
tv164 = 8						; size = 4
_eOtherPlayer$ = 8					; size = 4
_iCityLoop2$221534 = 12					; size = 4
_eDomain$ = 12						; size = 4
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z PROC ; CvPlayerTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 3264 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3265 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 3266 : 
; 3267 : 	int iCityLoop;
; 3268 : 	CvCity* pLoopCity;
; 3269 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [esi+79104]
	mov	DWORD PTR _pGameTrade$[esp+28], eax
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+32]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN9@CanCreateT@4
	mov	edi, DWORD PTR _eOtherPlayer$[esp+24]
	mov	ebp, DWORD PTR _eDomain$[esp+24]
	imul	edi, 63236				; 0000f704H
	mov	DWORD PTR tv164[esp+24], edi
	npad	6
$LL29@CanCreateT@4:

; 3270 : 	{
; 3271 : 		int iCityLoop2;
; 3272 : 		CvCity* pLoopCity2;
; 3273 : 		for (pLoopCity2 = GET_PLAYER(eOtherPlayer).firstCity(&iCityLoop2); pLoopCity2 != NULL; pLoopCity2 = GET_PLAYER(eOtherPlayer).nextCity(&iCityLoop2))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop2$221534[esp+28]
	add	ecx, edi
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN10@CanCreateT@4
	npad	6
$LL28@CanCreateT@4:

; 3274 : 		{
; 3275 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	xor	edi, edi
$LL5@CanCreateT@4:

; 3276 : 			{
; 3277 : 				// Check the route, but not the path
; 3278 : 				if (CanCreateTradeRoute(pLoopCity, pLoopCity2, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	mov	ecx, DWORD PTR _this$[esp+28]
	push	0
	push	0
	push	edi
	push	ebp
	push	esi
	push	ebx
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	test	al, al
	jne	SHORT $LN23@CanCreateT@4
	inc	edi
	cmp	edi, 3
	jb	SHORT $LL5@CanCreateT@4

; 3279 : 				{
; 3280 : 					// Check the path
; 3281 : 					if (pGameTrade->IsValidTradeRoutePath(pLoopCity, pLoopCity2, eDomain))

	jmp	SHORT $LN7@CanCreateT@4
$LN23@CanCreateT@4:
	mov	ecx, DWORD PTR _pGameTrade$[esp+28]
	push	ebp
	push	esi
	push	ebx
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	test	al, al
	jne	SHORT $LN24@CanCreateT@4
$LN7@CanCreateT@4:

; 3270 : 	{
; 3271 : 		int iCityLoop2;
; 3272 : 		CvCity* pLoopCity2;
; 3273 : 		for (pLoopCity2 = GET_PLAYER(eOtherPlayer).firstCity(&iCityLoop2); pLoopCity2 != NULL; pLoopCity2 = GET_PLAYER(eOtherPlayer).nextCity(&iCityLoop2))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv164[esp+24]
	push	0
	lea	edx, DWORD PTR _iCityLoop2$221534[esp+28]
	add	ecx, eax
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL28@CanCreateT@4
	mov	edi, DWORD PTR tv164[esp+24]
$LN10@CanCreateT@4:

; 3266 : 
; 3267 : 	int iCityLoop;
; 3268 : 	CvCity* pLoopCity;
; 3269 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [ecx+79104]
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+32]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL29@CanCreateT@4
$LN9@CanCreateT@4:
	pop	edi
	pop	esi
	pop	ebp

; 3283 : 
; 3284 : 					// else we can just break out of the loop
; 3285 : 					break;
; 3286 : 				}
; 3287 : 			}
; 3288 : 		}
; 3289 : 	}
; 3290 : 
; 3291 : 	return false;

	xor	al, al
	pop	ebx

; 3292 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN24@CanCreateT@4:
	pop	edi
	pop	esi
	pop	ebp

; 3282 : 						return true;

	mov	al, 1
	pop	ebx

; 3292 : }

	add	esp, 12					; 0000000cH
	ret	8
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z ENDP ; CvPlayerTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z ; CvPlayerTrade::CanCreateTradeRoute
EXTRN	?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z:PROC ; CvCityManager::GetNearbyCities
; Function compile flags: /Ogtpy
;	COMDAT ?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pGameTrade$ = -12					; size = 4
_kNearbyCities$221556 = -8				; size = 4
_iCityLoop$ = -4					; size = 4
_itr$221956 = 8						; size = 4
_eDomain$ = 8						; size = 4
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z PROC ; CvPlayerTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 3301 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3302 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 3303 : 
; 3304 : 	int iCityLoop;
; 3305 : 	CvCity* pLoopCity;
; 3306 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [esi+79104]
	mov	DWORD PTR _pGameTrade$[esp+32], eax
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+36]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN9@CanCreateT@5
	mov	ebp, DWORD PTR _eDomain$[esp+28]
	npad	4
$LL11@CanCreateT@5:

; 3307 : 	{
; 3308 : 		// Get a sorted list of nearby cities 
; 3309 : 		const CvCityManager::CityList& kNearbyCities = CvCityManager::GetNearbyCities(pLoopCity);

	push	ebx
	call	?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z ; CvCityManager::GetNearbyCities

; 3310 : 		for (CvCityManager::CityList::const_iterator itr = kNearbyCities.begin(); itr != kNearbyCities.end(); ++itr)

	mov	ecx, DWORD PTR [eax+4]
	add	esp, 4
	mov	DWORD PTR _kNearbyCities$221556[esp+32], eax
	mov	DWORD PTR _itr$221956[esp+28], ecx
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN10@CanCreateT@5
	jmp	SHORT $LN20@CanCreateT@5
	npad	5
$LL40@CanCreateT@5:
	mov	ecx, DWORD PTR _itr$221956[esp+28]
$LN20@CanCreateT@5:

; 3311 : 		{
; 3312 : 			CvCity* pLoopCity2 = (*itr);

	mov	edi, DWORD PTR [ecx]

; 3313 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	xor	esi, esi
$LL5@CanCreateT@5:

; 3314 : 			{
; 3315 : 				// Check the route, but not the path
; 3316 : 				if (CanCreateTradeRoute(pLoopCity, pLoopCity2, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	mov	ecx, DWORD PTR _this$[esp+32]
	push	0
	push	0
	push	esi
	push	ebp
	push	edi
	push	ebx
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	test	al, al
	jne	SHORT $LN35@CanCreateT@5
	inc	esi
	cmp	esi, 3
	jb	SHORT $LL5@CanCreateT@5

; 3317 : 				{
; 3318 : 					// Check the path
; 3319 : 					if (pGameTrade->IsValidTradeRoutePath(pLoopCity, pLoopCity2, eDomain))

	jmp	SHORT $LN7@CanCreateT@5
$LN35@CanCreateT@5:
	mov	ecx, DWORD PTR _pGameTrade$[esp+32]
	push	ebp
	push	edi
	push	ebx
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	test	al, al
	jne	SHORT $LN36@CanCreateT@5
$LN7@CanCreateT@5:

; 3310 : 		for (CvCityManager::CityList::const_iterator itr = kNearbyCities.begin(); itr != kNearbyCities.end(); ++itr)

	mov	eax, DWORD PTR _itr$221956[esp+28]
	mov	ecx, DWORD PTR _kNearbyCities$221556[esp+32]
	add	eax, 4
	mov	DWORD PTR _itr$221956[esp+28], eax
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LL40@CanCreateT@5
	mov	esi, DWORD PTR _this$[esp+32]
$LN10@CanCreateT@5:

; 3303 : 
; 3304 : 	int iCityLoop;
; 3305 : 	CvCity* pLoopCity;
; 3306 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [esi+79104]
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+36]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL11@CanCreateT@5
$LN9@CanCreateT@5:
	pop	edi
	pop	esi
	pop	ebp

; 3321 : 
; 3322 : 					// else we can just break out of the loop
; 3323 : 					break;
; 3324 : 				}
; 3325 : 			}
; 3326 : 		}
; 3327 : 	}
; 3328 : 
; 3329 : 	return false;

	xor	al, al
	pop	ebx

; 3330 : 
; 3331 : }

	add	esp, 16					; 00000010H
	ret	4
$LN36@CanCreateT@5:
	pop	edi
	pop	esi
	pop	ebp

; 3320 : 						return true;

	mov	al, 1
	pop	ebx

; 3330 : 
; 3331 : }

	add	esp, 16					; 00000010H
	ret	4
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z ENDP ; CvPlayerTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ; CvPlayerTrade::GetNumPotentialConnections
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z
_TEXT	SEGMENT
tv248 = -16						; size = 4
_iNumValid$ = -12					; size = 4
_this$ = -8						; size = 4
_pGameTrade$ = -4					; size = 4
_iLoop$222086 = 8					; size = 4
_pFromCity$ = 8						; size = 4
_bCheckPath$222091 = 12					; size = 1
_eDomain$ = 12						; size = 4
?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z PROC ; CvPlayerTrade::GetNumPotentialConnections, COMDAT
; _this$ = ecx

; 3543 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+28], ecx

; 3544 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ebp, DWORD PTR _eDomain$[esp+28]
	mov	ebx, DWORD PTR _pFromCity$[esp+28]

; 3545 : 
; 3546 : 	int iNumValid = 0;

	xor	edi, edi
	mov	DWORD PTR _pGameTrade$[esp+32], eax
	mov	DWORD PTR _iNumValid$[esp+32], edi
	mov	DWORD PTR tv248[esp+32], edi
	npad	4
$LL42@GetNumPote:

; 3548 : 	{
; 3549 : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 3550 : 
; 3551 : 		if (!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+eax+2256], 0
	lea	ecx, DWORD PTR [edi+eax]
	je	$LN13@GetNumPote

; 3552 : 		{
; 3553 : 			continue;
; 3554 : 		}
; 3555 : 
; 3556 : 		if (GET_PLAYER(ePlayer).isBarbarian())

	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN13@GetNumPote

; 3557 : 		{
; 3558 : 			continue;
; 3559 : 		}
; 3560 : 
; 3561 : 		int iLoop;
; 3562 : 		CvCity* pLoopCity;
; 3563 : 		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$222086[esp+32]
	add	ecx, edi
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN13@GetNumPote
	npad	3
$LL39@GetNumPote:

; 3564 : 		{
; 3565 : 			bool bCheckPath = true;

	mov	BYTE PTR _bCheckPath$222091[esp+28], 1

; 3566 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	xor	edi, edi
$LL6@GetNumPote:

; 3567 : 			{
; 3568 : 				// Check the trade route, ignoring the path for now
; 3569 : 				if (CanCreateTradeRoute(pFromCity, pLoopCity, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	mov	ecx, DWORD PTR _this$[esp+32]
	push	0
	push	0
	push	edi
	push	ebp
	push	esi
	push	ebx
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	test	al, al
	je	SHORT $LN5@GetNumPote

; 3570 : 				{
; 3571 : 					// Now test the path
; 3572 : 					if (bCheckPath)

	cmp	BYTE PTR _bCheckPath$222091[esp+28], 0
	je	SHORT $LN2@GetNumPote

; 3573 : 					{
; 3574 : 						bool bTradeAvailable = pGameTrade->IsValidTradeRoutePath(pFromCity, pLoopCity, eDomain);

	mov	ecx, DWORD PTR _pGameTrade$[esp+32]
	push	ebp
	push	esi
	push	ebx
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath

; 3575 : 						if (!bTradeAvailable)

	test	al, al
	je	SHORT $LN8@GetNumPote

; 3576 : 							break;		// If there is no path for this domain, just skip the rest of the connection tests.
; 3577 : 
; 3578 : 						bCheckPath = false;		// No need to check the path for this domain again

	mov	BYTE PTR _bCheckPath$222091[esp+28], 0
$LN2@GetNumPote:

; 3579 : 					}
; 3580 : 
; 3581 : 					iNumValid++;

	inc	DWORD PTR _iNumValid$[esp+32]
$LN5@GetNumPote:

; 3566 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	inc	edi
	cmp	edi, 3
	jb	SHORT $LL6@GetNumPote
$LN8@GetNumPote:

; 3557 : 		{
; 3558 : 			continue;
; 3559 : 		}
; 3560 : 
; 3561 : 		int iLoop;
; 3562 : 		CvCity* pLoopCity;
; 3563 : 		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv248[esp+32]
	push	0
	lea	edx, DWORD PTR _iLoop$222086[esp+32]
	add	ecx, eax
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL39@GetNumPote
	mov	edi, DWORD PTR tv248[esp+32]
$LN13@GetNumPote:

; 3547 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	add	edi, 63236				; 0000f704H
	mov	DWORD PTR tv248[esp+32], edi
	cmp	edi, 3983868				; 003cc9fcH
	jb	$LL42@GetNumPote

; 3582 : 				}
; 3583 : 			}
; 3584 : 		}
; 3585 : 	}
; 3586 : 
; 3587 : 	return iNumValid;

	mov	eax, DWORD PTR _iNumValid$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3588 : }

	add	esp, 16					; 00000010H
	ret	8
?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ENDP ; CvPlayerTrade::GetNumPotentialConnections
_TEXT	ENDS
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__Tmp$243718 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	sub	esp, 8

; 2091 : 		return (*(begin() + _Off));

	mov	ecx, DWORD PTR [ecx+8]
	xor	eax, eax
	mov	DWORD PTR __Tmp$243718[esp+12], eax
	mov	eax, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$243718[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$243718[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$243718[esp+8]
	mov	edx, DWORD PTR __Tmp$243718[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 2092 : 		}

	add	esp, 8
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; BaseVector<TradeConnection,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	add	esi, 44					; 0000002cH
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN15@Destroy
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN15@Destroy:
	add	esi, 444				; 000001bcH
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; BaseVector<TradeConnection,0>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z PROC ; BaseVector<TradeConnectionWasPlundered,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy@2
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	add	esi, 44					; 0000002cH
$LL3@Destroy@2:

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN18@Destroy@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN18@Destroy@2:
	add	esi, 448				; 000001c0H
	sub	edi, 1
	jne	SHORT $LL3@Destroy@2
	pop	esi
$LN1@Destroy@2:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ENDP ; BaseVector<TradeConnectionWasPlundered,0>::Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z
_TEXT	SEGMENT
$T243966 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243970 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$243970[esp]
	mov	BYTE PTR $T243966[esp+4], 0
	mov	eax, DWORD PTR $T243966[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ucopy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
$T243984 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243988 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ucopy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$243988[esp]
	mov	BYTE PTR $T243984[esp+4], 0
	mov	eax, DWORD PTR $T243984[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ucopy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@9
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@9:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@9
	pop	esi
$LN13@unchecked_@9:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@stdext@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@0PAV1@AAV?$allocator@VCvString@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@stdext@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@0PAV1@AAV?$allocator@VCvString@@@3@@Z
_TEXT	SEGMENT
$T244151 = -4						; size = 1
__Cat$244156 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@stdext@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@0PAV1@AAV?$allocator@VCvString@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244151[esp+4], 0
	mov	eax, DWORD PTR $T244151[esp+4]
	mov	ecx, DWORD PTR __Cat$244156[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@stdext@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@0PAV1@AAV?$allocator@VCvString@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244192 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$244200 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@4:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$244200[ebp], esi
	mov	DWORD PTR $T244192[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@4
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_fil@4:
	dec	edi
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@4
$LL3@Uninit_fil@4:

; 407  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_fil@4:
$LN4@Uninit_fil@4:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_fil@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$244200[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244192[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
PUBLIC	??$_Copy_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN10@Copy_opt@6
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@6:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	add	esi, 448				; 000001c0H
	add	edi, 448				; 000001c0H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@6

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN10@Copy_opt@6:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:

; 234  : 		_Al.destroy(_First);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ; std::_Fill<TRSortElement *,TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z PROC ; std::_Fill<TRSortElement *,TRSortElement>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN1@Fill@6
	push	edi
	mov	edi, DWORD PTR __Val$[esp+8]
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	push	edi
	mov	ecx, esi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
	add	esi, 448				; 000001c0H
	cmp	esi, ebx
	jne	SHORT $LL3@Fill@6
	pop	edi
$LN1@Fill@6:
	pop	esi
	pop	ebx

; 3160 : 	}

	ret	0
??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ENDP ; std::_Fill<TRSortElement *,TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244296 = -4						; size = 1
__Cat$244300 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T244296[esp+4], 0
	mov	eax, DWORD PTR $T244296[esp+4]
	mov	ecx, DWORD PTR __Cat$244300[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@ABU3@@Z ; std::allocator<TRSortElement>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@ABU3@@Z PROC ; std::allocator<TRSortElement>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	eax
	push	ecx
	call	??$_Construct@UTRSortElement@@U1@@std@@YAXPAUTRSortElement@@ABU1@@Z ; std::_Construct<TRSortElement,TRSortElement>
	add	esp, 8

; 156  : 		}

	ret	8
?construct@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@ABU3@@Z ENDP ; std::allocator<TRSortElement>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ; std::_Destroy<TRSortElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z PROC ; std::_Destroy<TRSortElement>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN14@Destroy@3
	mov	DWORD PTR __Ptr$[esp-4], eax
	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
$LN14@Destroy@3:

; 60   : 	}

	ret	0
??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ENDP ; std::_Destroy<TRSortElement>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T244419 = -4						; size = 1
__Cat$244423 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244419[esp+4], 0
	mov	eax, DWORD PTR $T244419[esp+4]
	mov	ecx, DWORD PTR __Cat$244423[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	push	ecx
	call	??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ; std::swap<TRSortElement>
	add	esp, 8

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T244447 = -4						; size = 1
__Cat$244452 = 8					; size = 1
$T244449 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244452[esp]
	mov	edx, DWORD PTR $T244449[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T244447[esp+8], 0
	mov	eax, DWORD PTR $T244447[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T244461 = -4						; size = 1
__Cat$244466 = 8					; size = 1
$T244463 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244466[esp]
	mov	edx, DWORD PTR $T244463[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T244461[esp+8], 0
	mov	eax, DWORD PTR $T244461[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z ; stdext::unchecked_copy_backward<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z
_TEXT	SEGMENT
$T244475 = -4						; size = 1
__Cat$244480 = 8					; size = 1
$T244477 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z PROC ; stdext::unchecked_copy_backward<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244480[esp]
	mov	edx, DWORD PTR $T244477[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T244475[esp+8], 0
	mov	eax, DWORD PTR $T244475[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z ; stdext::unchecked_copy<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z
_TEXT	SEGMENT
$T244489 = -4						; size = 1
__Cat$244494 = 8					; size = 1
$T244491 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z PROC ; stdext::unchecked_copy<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244494[esp]
	mov	edx, DWORD PTR $T244491[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T244489[esp+8], 0
	mov	eax, DWORD PTR $T244489[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@@Z ENDP ; stdext::unchecked_copy<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
$T244586 = 20						; size = 1
$T244561 = 20						; size = 1
$T244512 = 20						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$244590 = 28					; size = 1
$T244588 = 28						; size = 1
__Cat$244565 = 28					; size = 1
$T244563 = 28						; size = 1
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+8]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+12]
	cmp	esi, ebp
	je	SHORT $LN3@Merge
$LL10@Merge:
	cmp	edi, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR [edi+444]
	cmp	eax, DWORD PTR [esi+444]

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, ecx
	jge	SHORT $LN2@Merge
	push	edi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR [edi+444]
	mov	DWORD PTR [ebx+444], ecx
	add	edi, 448				; 000001c0H

; 2600 : 		else

	jmp	SHORT $LN4@Merge
$LN2@Merge:

; 2601 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR [esi+444]
	mov	DWORD PTR [ebx+444], edx
	add	esi, 448				; 000001c0H
$LN4@Merge:
	mov	ecx, DWORD PTR __Dest$[esp+12]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __Dest$[esp+12], ecx
	cmp	esi, ebp
	jne	SHORT $LL10@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Cat$244565[esp+12]
	xor	bl, bl
	mov	BYTE PTR $T244561[esp+12], bl
	mov	eax, DWORD PTR $T244561[esp+12]
	push	eax
	mov	eax, DWORD PTR $T244563[esp+16]
	push	edx
	push	eax
	push	ecx
	push	ebp
	lea	ecx, DWORD PTR $T244512[esp+32]
	push	esi
	push	ecx
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR $T244512[esp+40]

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	DWORD PTR __Dest$[esp+40], eax
	mov	ecx, DWORD PTR __Cat$244590[esp+40]
	mov	BYTE PTR $T244586[esp+40], bl
	mov	edx, DWORD PTR $T244586[esp+40]
	push	edx
	mov	edx, DWORD PTR $T244588[esp+44]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+56]
	push	eax
	push	edi
	push	esi
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
; Function compile flags: /Ogtpy
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T244795 = 8						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebx

; 2361 : 		if (max_size() < _Size)

	mov	ebx, DWORD PTR __Size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, -1
	jbe	SHORT $LN3@Trim

; 2362 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN42@Trim:
$LN3@Trim:

; 2363 : 		size_type _Words = _Nw(_Size);
; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	eax, DWORD PTR [edi+12]
	sub	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+4]
	push	esi
	lea	esi, DWORD PTR [ebx+31]
	shr	esi, 5
	sar	eax, 2
	cmp	esi, eax
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	lea	edx, DWORD PTR [edx+esi*4]
	push	edx
	lea	eax, DWORD PTR $T244795[esp+16]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	DWORD PTR [edi], ebx

; 2368 : 		_Size %= _VBITS;

	and	ebx, 31					; 0000001fH

; 2369 : 		if (0 < _Size)

	jbe	SHORT $LN40@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ecx+esi*4-4]
	mov	edx, 1
	mov	ecx, ebx
	shl	edx, cl
	dec	edx
	and	DWORD PTR [eax], edx
$LN40@Trim:
	pop	esi
	pop	edi
	pop	ebx

; 2371 : 		}

	ret	4
$LN41@Trim:
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@10
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@10
	pop	esi
$LN13@unchecked_@10:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T245047 = -4						; size = 1
__Cat$245053 = 8					; size = 1
$T245049 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Cat$245053[esp]
	mov	edx, DWORD PTR $T245049[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245047[esp+8], 0
	mov	eax, DWORD PTR $T245047[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2743 : 	}

	pop	ecx
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@11
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@11:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@11
	pop	esi
$LN13@unchecked_@11:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvTradeAI::ScoreProductionTR
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0
__ehfuncinfo$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
_TEXT	SEGMENT
_iDistanceScore$ = -28					; size = 4
_uiPlotList$222967 = -24				; size = 4
_iDangerSum$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_kTradeConnection$ = 8					; size = 4
_aTargetCityList$ = 12					; size = 16
?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z PROC ; CvTradeAI::ScoreProductionTR, COMDAT
; _this$ = ecx

; 5256 : {

	push	-1
	push	__ehhandler$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	DWORD PTR _this$[esp+32], ecx

; 5257 : 	// only consider production trades
; 5258 : 	if (kTradeConnection.m_eConnectionType != TRADE_CONNECTION_PRODUCTION)

	mov	ebx, DWORD PTR _kTradeConnection$[esp+28]
	cmp	DWORD PTR [ebx+32], 2
	mov	DWORD PTR __$EHRec$[esp+40], 0
	je	SHORT $LN15@ScoreProdu
$LN181@ScoreProdu:

; 5259 : 	{
; 5260 : 		return 0;

	mov	eax, DWORD PTR _aTargetCityList$[esp+32]
	test	eax, eax
	je	SHORT $LN24@ScoreProdu
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@ScoreProdu:
	xor	eax, eax
	pop	ebx

; 5326 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
$LN15@ScoreProdu:

; 5261 : 	}
; 5262 : 
; 5263 : 	// if this was recently plundered, 0 the score
; 5264 : 	if (m_pPlayer->GetTrade()->CheckTradeConnectionWasPlundered(kTradeConnection))

	mov	ecx, DWORD PTR [ecx+4]
	push	ebx
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
	test	al, al

; 5265 : 	{
; 5266 : 		return 0;

	jne	SHORT $LN181@ScoreProdu

; 5267 : 	}
; 5268 : 
; 5269 : 	// if we're not going to a target production city, ignore
; 5270 : 	bool bValidTarget = false;
; 5271 : #ifdef AUI_ITERATORIZE
; 5272 : 	for (std::vector<const CvCity*>::iterator it = aTargetCityList.begin(); it != aTargetCityList.end(); ++it)
; 5273 : 	{
; 5274 : 		if (kTradeConnection.m_iDestX == (*it)->getX() && kTradeConnection.m_iDestY == (*it)->getY())
; 5275 : #else
; 5276 : 	for (uint ui = 0; ui < aTargetCityList.size(); ui++)

	mov	edx, DWORD PTR _aTargetCityList$[esp+36]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _aTargetCityList$[esp+40]
	sub	edx, esi
	sar	edx, 2
	xor	eax, eax
	push	edi
	test	edx, edx
	jbe	SHORT $LN166@ScoreProdu
	mov	edi, DWORD PTR [ebx+12]
$LL13@ScoreProdu:

; 5277 : 	{
; 5278 : 		if (kTradeConnection.m_iDestX == aTargetCityList[ui]->getX() && kTradeConnection.m_iDestY == aTargetCityList[ui]->getY())

	mov	ecx, DWORD PTR [esi+eax*4]
	cmp	edi, DWORD PTR [ecx+96]
	jne	SHORT $LN12@ScoreProdu
	mov	ebp, DWORD PTR [ebx+16]
	cmp	ebp, DWORD PTR [ecx+108]
	je	SHORT $LN9@ScoreProdu
$LN12@ScoreProdu:

; 5267 : 	}
; 5268 : 
; 5269 : 	// if we're not going to a target production city, ignore
; 5270 : 	bool bValidTarget = false;
; 5271 : #ifdef AUI_ITERATORIZE
; 5272 : 	for (std::vector<const CvCity*>::iterator it = aTargetCityList.begin(); it != aTargetCityList.end(); ++it)
; 5273 : 	{
; 5274 : 		if (kTradeConnection.m_iDestX == (*it)->getX() && kTradeConnection.m_iDestY == (*it)->getY())
; 5275 : #else
; 5276 : 	for (uint ui = 0; ui < aTargetCityList.size(); ui++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL13@ScoreProdu
$LN166@ScoreProdu:

; 5279 : #endif
; 5280 : 		{
; 5281 : 			bValidTarget = true;
; 5282 : 			break;
; 5283 : 		}
; 5284 : 	}
; 5285 : 
; 5286 : 	if (!bValidTarget)
; 5287 : 	{
; 5288 : 		return 0;

	test	esi, esi
	je	SHORT $LN52@ScoreProdu
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@ScoreProdu:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 5326 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
$LN9@ScoreProdu:

; 5289 : 	}
; 5290 : 
; 5291 : 	int iMaxDistance = 60;
; 5292 : 	int iDistance = kTradeConnection.m_aPlotList.size();

	mov	eax, DWORD PTR [ebx+48]

; 5293 : 	int iDistanceScore = iMaxDistance - iDistance;

	mov	edi, 60					; 0000003cH
	sub	edi, eax

; 5294 : 	if (kTradeConnection.m_eDomain == DOMAIN_SEA)

	cmp	DWORD PTR [ebx+28], 0
	mov	DWORD PTR _iDistanceScore$[esp+44], edi
	jne	SHORT $LN8@ScoreProdu

; 5295 : 	{
; 5296 : 		iDistanceScore = iDistanceScore * 2;

	lea	ecx, DWORD PTR [edi+edi]
	mov	DWORD PTR _iDistanceScore$[esp+44], ecx
	mov	edi, ecx
$LN8@ScoreProdu:

; 5297 : 	}
; 5298 : 
; 5299 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5300 : 	int iDangerSum = 1; // can't be zero because we divide by zero!

	mov	DWORD PTR _iDangerSum$[esp+44], 1

; 5301 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	DWORD PTR _uiPlotList$222967[esp+44], 0
	test	eax, eax
	jbe	$LN92@ScoreProdu
	jmp	SHORT $LN7@ScoreProdu
$LL171@ScoreProdu:
	mov	edi, DWORD PTR _iDistanceScore$[esp+44]
	mov	ebx, ecx
$LN7@ScoreProdu:
	mov	edx, DWORD PTR [ebx+44]
	mov	eax, DWORD PTR _uiPlotList$222967[esp+44]

; 5302 : 	{
; 5303 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

	mov	ebx, DWORD PTR [edx+eax*8+4]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2147483647			; 80000001H
	je	$LN170@ScoreProdu
	cmp	ebx, -2147483647			; 80000001H
	je	$LN170@ScoreProdu
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN74@ScoreProdu
	test	eax, eax
	jge	SHORT $LN76@ScoreProdu
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN78@ScoreProdu
$LN76@ScoreProdu:
	cmp	eax, ecx
	jl	SHORT $LN74@ScoreProdu
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN78@ScoreProdu
$LN74@ScoreProdu:
	mov	esi, eax
$LN78@ScoreProdu:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN172@ScoreProdu
	test	ebx, ebx
	jge	SHORT $LN86@ScoreProdu
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN88@ScoreProdu
$LN86@ScoreProdu:
	cmp	ebx, edi
	jl	SHORT $LN172@ScoreProdu
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN88@ScoreProdu
$LN172@ScoreProdu:
	mov	edx, ebx
$LN88@ScoreProdu:
	test	esi, esi
	jl	$LN176@ScoreProdu
	cmp	esi, ecx
	jge	$LN176@ScoreProdu
	test	edx, edx
	jl	$LN176@ScoreProdu
	cmp	edx, edi
	jge	$LN176@ScoreProdu
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx

; 5304 : 		CvAssertMsg(pPlot, "pPlot is null when trying to evaluate the list");
; 5305 : 		if (pPlot == NULL)

	je	$LN176@ScoreProdu

; 5306 : 		{
; 5307 : 			break;
; 5308 : 		}
; 5309 : 		int iDangerValue = m_pPlayer->GetPlotDanger(*pPlot);

	mov	edi, DWORD PTR _this$[esp+44]
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	ebx, eax

; 5310 : 		if (iDangerValue == 0)

	test	ebx, ebx
	jne	$LN175@ScoreProdu

; 5311 : 		{
; 5312 : 			if (!pPlot->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN173@ScoreProdu
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+edi*4]
	cmp	eax, -1
	je	SHORT $LN173@ScoreProdu
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+eax*2], bx
	setg	al
	test	al, al
	jne	SHORT $LN174@ScoreProdu
$LN173@ScoreProdu:

; 5313 : 			{
; 5314 : 				iDangerValue += 1;

	mov	ebx, 1
$LN174@ScoreProdu:

; 5315 : 			}
; 5316 : 
; 5317 : 			if (pPlot->getTeam() != NO_TEAM && GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN175@ScoreProdu
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN175@ScoreProdu
	mov	ecx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+eax*4], -1
	je	SHORT $LN175@ScoreProdu
	cmp	eax, -1
	je	SHORT $LN130@ScoreProdu
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN137@ScoreProdu
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, eax
	jmp	SHORT $LN129@ScoreProdu
$LN137@ScoreProdu:
	or	eax, -1
	mov	edx, eax
	jmp	SHORT $LN129@ScoreProdu
$LN130@ScoreProdu:
	or	edx, -1
$LN129@ScoreProdu:
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN146@ScoreProdu
	mov	eax, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN147@ScoreProdu
$LN146@ScoreProdu:
	or	eax, -1
$LN147@ScoreProdu:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN175@ScoreProdu

; 5318 : 			{
; 5319 : 				iDangerValue += 1000;

	add	ebx, 1000				; 000003e8H
$LN175@ScoreProdu:

; 5301 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	eax, DWORD PTR _uiPlotList$222967[esp+44]
	mov	ecx, DWORD PTR _kTradeConnection$[esp+40]

; 5320 : 			}
; 5321 : 		}
; 5322 : 		iDangerSum += iDangerValue;

	add	DWORD PTR _iDangerSum$[esp+44], ebx
	inc	eax
	mov	DWORD PTR _uiPlotList$222967[esp+44], eax
	cmp	eax, DWORD PTR [ecx+48]
	jb	$LL171@ScoreProdu
$LN176@ScoreProdu:

; 5301 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	edi, DWORD PTR _iDistanceScore$[esp+44]
$LN170@ScoreProdu:
	mov	esi, DWORD PTR _aTargetCityList$[esp+44]

; 5302 : 	{
; 5303 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

$LN92@ScoreProdu:

; 5323 : 	}
; 5324 : 
; 5325 : 	return iDistanceScore - iDangerSum;

	sub	edi, DWORD PTR _iDangerSum$[esp+44]
	test	esi, esi
	je	SHORT $LN158@ScoreProdu
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN158@ScoreProdu:

; 5326 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aTargetCityList$[ebp-4]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__ehhandler$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ENDP ; CvTradeAI::ScoreProductionTR
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T245726 = 8						; size = 1
__Cat$245729 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@4
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@4
	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN54@vector@4:
$LN22@vector@4:
	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T245726[ebp], 0
	mov	edx, DWORD PTR $T245726[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$245729[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@4:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@4:
$LN53@vector@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN33@operator@16
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@16

; 572  : 				clear();	// new sequence empty, erase existing sequence

	call	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
	pop	ebp
	pop	ebx
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@16:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@16

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@16:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN24@operator@16
	xor	ebx, ebx
	jmp	SHORT $LN25@operator@16
$LN24@operator@16:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN25@operator@16:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@16

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@16:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN28@operator@16

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@operator@16:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	test	al, al
	je	SHORT $LN32@operator@16

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	mov	DWORD PTR [esi+8], eax
$LN32@operator@16:
	pop	ebp
	pop	ebx
$LN33@operator@16:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ; BaseVector<TradeConnection,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ PROC	; BaseVector<TradeConnection,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	esi
	mov	esi, ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy

; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 123  : 	};

	ret	0
?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ENDP	; BaseVector<TradeConnection,0>::clear
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ ; BaseVector<TradeConnectionWasPlundered,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ PROC ; BaseVector<TradeConnectionWasPlundered,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	esi
	mov	esi, ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy

; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 123  : 	};

	ret	0
?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ ENDP ; BaseVector<TradeConnectionWasPlundered,0>::clear
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T245909 = 8						; size = 1
__Cat$245913 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@5
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@5
	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN54@vector@5:
$LN22@vector@5:
	push	eax
	push	edi
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T245909[ebp], 0
	mov	edx, DWORD PTR $T245909[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$245913[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@5:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@5:
$LN53@vector@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, DWORD PTR _uiNumElements$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pVal$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy

; 811  : 		if( pVal != (T*)m_aData )

	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free@2:
	pop	edi
	pop	esi

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, DWORD PTR _uiNumElements$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pVal$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy

; 811  : 		if( pVal != (T*)m_aData )

	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free@3:
	pop	edi
	pop	esi

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$224480 = 16					; size = 4
__Tmp$224470 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$224470[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$224470[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$224470[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$224480[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@1@0PAV2@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ucopy<std::_Vector_const_iterator<CvString,std::allocator<CvString> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@1@0PAV2@@Z
_TEXT	SEGMENT
$T246138 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246142 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@1@0PAV2@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Ucopy<std::_Vector_const_iterator<CvString,std::allocator<CvString> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$246142[esp]
	mov	BYTE PTR $T246138[esp+4], 0
	mov	eax, DWORD PTR $T246138[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@1@0PAV2@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Ucopy<std::_Vector_const_iterator<CvString,std::allocator<CvString> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T246148 = -4						; size = 1
__Cat$246153 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T246148[esp+4], 0
	mov	eax, DWORD PTR $T246148[esp+4]
	mov	ecx, DWORD PTR __Cat$246153[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z
_TEXT	SEGMENT
$T246157 = -4						; size = 1
__Cat$246163 = -4					; size = 1
$T246159 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z PROC ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T246157[esp+4], 0
	mov	eax, DWORD PTR $T246157[esp+4]
	mov	ecx, DWORD PTR __Cat$246163[esp+4]
	mov	edx, DWORD PTR $T246159[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ENDP ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ; std::fill<TRSortElement *,TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z PROC ; std::fill<TRSortElement *,TRSortElement>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ; std::_Fill<TRSortElement *,TRSortElement>
??$fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ENDP ; std::fill<TRSortElement *,TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z
_TEXT	SEGMENT
$T246249 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246252 = 16					; size = 1
$T246232 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$246252[esp]
	mov	edx, DWORD PTR $T246232[esp]
	mov	BYTE PTR $T246249[esp+4], 0
	mov	eax, DWORD PTR $T246249[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@@Z ; std::allocator<TRSortElement>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@@Z PROC ; std::allocator<TRSortElement>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN16@destroy
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN16@destroy:

; 161  : 		}

	ret	4
?destroy@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@@Z ENDP ; std::allocator<TRSortElement>::destroy
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ PROC	; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	esi
	push	edi
	mov	edi, ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN32@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@Temp_itera
	npad	1
$LL3@Temp_itera:

; 550  : 				_Destroy(&*_Next);

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN20@Temp_itera
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@Temp_itera:
	add	esi, 448				; 000001c0H
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL3@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	edx, DWORD PTR [edi]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@Temp_itera:
	pop	edi
	pop	esi

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T246547 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246550 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$246550[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T246547[esp+4], 0
	mov	eax, DWORD PTR $T246547[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z$0
__ehfuncinfo$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
_TEXT	SEGMENT
$T246629 = -468						; size = 1
__Cat$246633 = -468					; size = 1
$T246631 = -468						; size = 1
$T246557 = -464						; size = 4
__Val$226611 = -460					; size = 448
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp+8]
	mov	ecx, DWORD PTR __Last$[esp+8]
	sub	esp, 456				; 000001c8H
	cmp	eax, ecx
	je	$LN6@Insertion_
	push	edi

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edi, DWORD PTR [eax+448]
	cmp	edi, ecx
	je	$LN105@Insertion_
	push	ebx
	push	ebp
	push	esi
	xor	ebx, ebx
	npad	1
$LL7@Insertion_:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	push	edi
	lea	ecx, DWORD PTR __Val$226611[esp+488]
	mov	ebp, edi
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR __Val$226611[esp+928], eax

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	ecx, DWORD PTR __First$[esp+480]
	cmp	eax, DWORD PTR [ecx+444]
	mov	DWORD PTR __$EHRec$[esp+492], ebx
	jge	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T246629[esp+484], bl
	mov	edx, DWORD PTR $T246629[esp+484]
	push	edx
	mov	edx, DWORD PTR __Cat$246633[esp+488]
	push	edx
	mov	edx, DWORD PTR $T246631[esp+492]
	push	edx
	lea	eax, DWORD PTR [edi+448]
	push	eax
	push	edi
	push	ecx
	lea	eax, DWORD PTR $T246557[esp+508]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>

; 3133 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[esp+508]
	add	esp, 28					; 0000001cH
	lea	edx, DWORD PTR __Val$226611[esp+484]
	push	edx
	mov	esi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR __Val$226611[esp+928]
	mov	DWORD PTR [esi+444], eax

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN77@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	cmp	eax, DWORD PTR [edi-4]
	lea	esi, DWORD PTR [edi-448]
	jge	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	push	esi
	mov	ecx, ebp
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR [esi+444]
	mov	edx, DWORD PTR __Val$226611[esp+928]
	mov	DWORD PTR [ebp+444], ecx
	mov	ebp, esi
	sub	esi, 448				; 000001c0H
	cmp	edx, DWORD PTR [esi+444]
	jl	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	lea	eax, DWORD PTR __Val$226611[esp+484]
	push	eax
	mov	ecx, ebp
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR __Val$226611[esp+928]
	mov	DWORD PTR [ebp+444], ecx
$LN77@Insertion_:

; 3142 : 				}
; 3143 : 			}

	mov	eax, DWORD PTR __Val$226611[esp+528]
	lea	edx, DWORD PTR __Val$226611[esp+540]
	mov	DWORD PTR __$EHRec$[esp+492], -1
	cmp	eax, edx
	je	SHORT $LN87@Insertion_
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN87@Insertion_:
	add	edi, 448				; 000001c0H
	cmp	edi, DWORD PTR __Last$[esp+480]
	jne	$LL7@Insertion_
	pop	esi
	pop	ebp
	pop	ebx
$LN105@Insertion_:
	pop	edi
$LN6@Insertion_:

; 3144 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+468]
	mov	DWORD PTR fs:0, ecx
	add	esp, 468				; 000001d4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z$0:
	lea	ecx, DWORD PTR __Val$226611[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
PUBLIC	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T246835 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$246843 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@8:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@8

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$246843[ebp], esi
	mov	DWORD PTR $T246835[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@8
	push	edi
	mov	ecx, esi
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
$LN18@Uninit_cop@8:
	add	esi, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 448				; 000001c0H
	jmp	SHORT $LL6@Uninit_cop@8
__catch$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@8
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_cop@8:

; 134  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@@Z ; std::allocator<TRSortElement>::destroy
	add	esi, 448				; 000001c0H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@8
$LN1@Uninit_cop@8:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN32@Uninit_cop@8:
$LN4@Uninit_cop@8:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@Uninit_cop@8:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$246843[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246835[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T246863 = -24						; size = 4
__Vptr$246937 = -20					; size = 4
$T246929 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	-1
	push	__ehhandler$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T246863[esp+36], ebx
	mov	edi, DWORD PTR __First$[esp+32]
	mov	DWORD PTR __$EHRec$[esp+44], 1
	cmp	edi, DWORD PTR __Last$[esp+32]
	je	SHORT $LN1@Copy_opt@7
$LL13@Copy_opt@7:

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __Dest$[esp+48]
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [eax+8]
	jae	SHORT $LN26@Copy_opt@7
	lea	ecx, DWORD PTR [esi+448]
	mov	DWORD PTR [eax+4], ecx
	push	edi
	mov	ecx, esi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], edx
	jmp	SHORT $LN2@Copy_opt@7
$LN26@Copy_opt@7:
	mov	DWORD PTR __Vptr$246937[esp+36], esi
	mov	DWORD PTR $T246929[esp+36], esi
	mov	BYTE PTR __$EHRec$[esp+44], 2
	cmp	esi, ebx
	je	SHORT $LN33@Copy_opt@7
	push	edi
	mov	ecx, esi
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [esi+444], eax
	mov	eax, DWORD PTR __Dest$[esp+48]
$LN33@Copy_opt@7:
	add	DWORD PTR [eax+4], 448			; 000001c0H
	mov	eax, DWORD PTR __Dest$[esp+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	mov	DWORD PTR [eax+8], ecx
$LN2@Copy_opt@7:
	mov	edi, DWORD PTR __First$[esp+32]
	add	edi, 448				; 000001c0H
	mov	DWORD PTR __First$[esp+32], edi
	cmp	edi, DWORD PTR __Last$[esp+32]
	jne	SHORT $LL13@Copy_opt@7
$LN1@Copy_opt@7:

; 2473 : 	return (_Dest);

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	edx, DWORD PTR __Dest$[esp+48]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], ebx
	mov	DWORD PTR [edi+16], edx
	mov	eax, DWORD PTR __Dest$[esp+32]
	mov	DWORD PTR $T246863[esp+36], 1
	mov	BYTE PTR __$EHRec$[esp+44], bl
	cmp	eax, ebx
	je	SHORT $LN84@Copy_opt@7
	cmp	eax, DWORD PTR __Dest$[esp+40]
	je	SHORT $LN45@Copy_opt@7
	lea	esi, DWORD PTR [eax+44]
$LL47@Copy_opt@7:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN64@Copy_opt@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN64@Copy_opt@7:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, DWORD PTR __Dest$[esp+40]
	jne	SHORT $LL47@Copy_opt@7
	mov	eax, DWORD PTR __Dest$[esp+32]
$LN45@Copy_opt@7:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN84@Copy_opt@7:

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$246937[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246929[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:
	mov	eax, DWORD PTR $T246863[ebp]
	and	eax, 1
	je	$LN8@Copy_opt@7
	and	DWORD PTR $T246863[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN8@Copy_opt@7:
	ret	0
__ehhandler$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>
PUBLIC	??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T247242 = 12						; size = 1
$T247217 = 12						; size = 1
$T247135 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$247246 = 28					; size = 1
$T247244 = 28						; size = 1
__Cat$247221 = 28					; size = 1
$T247219 = 28						; size = 1
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+8]
	push	edi
	cmp	esi, ebp
	je	SHORT $LN3@Merge@2
	mov	eax, DWORD PTR __First2$[esp+12]
$LL10@Merge@2:
	cmp	eax, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR [eax+444]
	cmp	edx, DWORD PTR [esi+444]
	jge	SHORT $LN2@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	push	eax
	mov	edi, eax
	mov	ebx, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [edi+444]
	mov	DWORD PTR [ebx+444], eax
	mov	eax, DWORD PTR __First2$[esp+12]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __First2$[esp+12], eax

; 2600 : 		else

	jmp	SHORT $LN4@Merge@2
$LN2@Merge@2:

; 2601 : 			*_Dest = *_First1, ++_First1;

	push	esi
	mov	edi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], ecx
	mov	eax, DWORD PTR __First2$[esp+12]
	add	esi, 448				; 000001c0H
$LN4@Merge@2:
	mov	ecx, DWORD PTR __Dest$[esp+12]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __Dest$[esp+12], ecx
	cmp	esi, ebp
	jne	SHORT $LL10@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Cat$247221[esp+12]
	xor	bl, bl
	mov	BYTE PTR $T247217[esp+12], bl
	mov	edx, DWORD PTR $T247217[esp+12]
	push	edx
	mov	edx, DWORD PTR $T247219[esp+16]
	push	eax
	push	edx
	push	ecx
	push	ebp
	lea	eax, DWORD PTR $T247135[esp+32]
	push	esi
	push	eax
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR $T247135[esp+40]

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	DWORD PTR __Dest$[esp+40], eax
	mov	edx, DWORD PTR __Cat$247246[esp+40]
	mov	BYTE PTR $T247242[esp+40], bl
	mov	ecx, DWORD PTR $T247242[esp+40]
	push	ecx
	mov	ecx, DWORD PTR $T247244[esp+44]
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+48]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __First2$[esp+56]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T247302 = -4						; size = 1
$T247277 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$247306 = 16					; size = 1
$T247304 = 16						; size = 1
__Cat$247281 = 16					; size = 1
$T247279 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ecx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __First1$[esp]
	mov	eax, DWORD PTR __Last1$[esp]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __First2$[esp+8]
	push	esi
	mov	esi, DWORD PTR __Last2$[esp+12]
	push	edi
	cmp	ecx, eax
	je	$LN65@Merge_back
	npad	3
$LL8@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	cmp	ebp, esi
	je	$LN66@Merge_back

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	ecx, DWORD PTR [esi-4]
	sub	esi, 448				; 000001c0H
	sub	eax, 448				; 000001c0H
	mov	DWORD PTR __Last1$[esp+16], eax
	cmp	ecx, DWORD PTR [eax+444]

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	ecx, DWORD PTR __Dest$[esp+16]
	jge	SHORT $LN2@Merge_back
	sub	ecx, 448				; 000001c0H
	push	eax
	mov	edi, eax
	mov	DWORD PTR __Dest$[esp+20], ecx
	mov	ebx, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR [edi+444]
	mov	DWORD PTR [ebx+444], edx

; 2847 : 		else

	mov	eax, DWORD PTR __Last1$[esp+16]
	add	esi, 448				; 000001c0H
	jmp	SHORT $LN61@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	sub	ecx, 448				; 000001c0H
	push	esi
	mov	DWORD PTR __Dest$[esp+20], ecx
	mov	edi, ecx
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [edi+444], eax
	mov	eax, DWORD PTR __Last1$[esp+16]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Last1$[esp+16], eax
$LN61@Merge_back:
	mov	ecx, DWORD PTR __First1$[esp+16]
	cmp	ecx, eax
	jne	$LL8@Merge_back
$LN65@Merge_back:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$247281[esp+16]
	mov	eax, DWORD PTR $T247279[esp+16]
	mov	BYTE PTR $T247277[esp+20], 0
	mov	ecx, DWORD PTR $T247277[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+20]
	push	edx
	push	eax
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	push	ebp
	push	esi
	call	??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2849 : 	}

	pop	ecx
	ret	0
$LN66@Merge_back:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	BYTE PTR $T247302[esp+20], 0
	mov	edx, DWORD PTR $T247302[esp+20]
	push	edx
	mov	edx, DWORD PTR __Cat$247306[esp+20]
	push	edx
	mov	edx, DWORD PTR $T247304[esp+24]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+28]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2849 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
	add	esp, 20					; 00000014H
$LN14@rotate:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@000V12@USortTR@@@Z ; stdext::unchecked_merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@000V12@USortTR@@@Z
_TEXT	SEGMENT
$T247441 = -4						; size = 1
$T247442 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@000V12@USortTR@@@Z PROC ; stdext::unchecked_merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T247442[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T247441[esp+8], 0
	mov	eax, DWORD PTR $T247441[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@000V12@USortTR@@@Z ENDP ; stdext::unchecked_merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
_TEXT	ENDS
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1903 : 		{	// construct empty vector

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 1904 : 		}

	ret	0
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1958 : 		_Mysize = 0;

	mov	DWORD PTR [esi], 0

; 1959 : 		}

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@vector@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@vector@6:
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T248072 = -28						; size = 1
__First$ = -24						; size = 8
$T247630 = -16						; size = 8
__Next$ = -8						; size = 8
__Last$ = -8						; size = 8
__Cat$248077 = 8					; size = 1
$T248074 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Tmp$248199 = 12					; size = 8
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebp, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+8]
	xor	esi, esi
	mov	DWORD PTR __First$[esp+44], ebx
	mov	DWORD PTR __First$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN36@erase@3
	mov	eax, DWORD PTR __First_arg$[esp+40]
	sub	eax, ebx
	sar	eax, 2
	shl	eax, 5
	add	eax, DWORD PTR __First_arg$[esp+44]
	lea	ecx, DWORD PTR __First$[esp+44]
	push	eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@erase@3:

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	DWORD PTR __Last$[esp+44], ebx
	mov	DWORD PTR __Last$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN71@erase@3
	mov	ecx, DWORD PTR __Last_arg$[esp+40]
	sub	ecx, ebx
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Last_arg$[esp+44]
	push	ecx
	lea	ecx, DWORD PTR __Last$[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN71@erase@3:

; 2224 : 		size_type _Off = _First - begin();

	mov	esi, DWORD PTR __First$[esp+44]
	sub	esi, ebx
	sar	esi, 2
	shl	esi, 5
	add	esi, DWORD PTR __First$[esp+48]

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	DWORD PTR $T247630[esp+44], ebx
	mov	DWORD PTR $T247630[esp+48], 0
	test	ebp, ebp
	jbe	SHORT $LN108@erase@3
	push	ebp
	lea	ecx, DWORD PTR $T247630[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN108@erase@3:
	mov	eax, DWORD PTR __Cat$248077[esp+40]
	mov	ecx, DWORD PTR $T248074[esp+40]
	mov	BYTE PTR $T248072[esp+44], 0
	mov	edx, DWORD PTR $T248072[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+52]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR $T247630[esp+60]
	push	edx
	mov	edx, DWORD PTR $T247630[esp+60]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+68]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR __Next$[esp+80]
	push	edx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>

; 2236 : 		_Trim(_Next - begin());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR __Next$[esp+84]
	sub	ecx, eax
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[esp+88]
	add	esp, 40					; 00000028H
	push	ecx
	mov	ecx, edi
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$248199[esp+44]
	mov	DWORD PTR __Tmp$248199[esp+44], edi
	mov	DWORD PTR __Tmp$248199[esp+48], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	edx, DWORD PTR __Tmp$248199[esp+40]
	mov	ecx, DWORD PTR __Tmp$248199[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 2240 : 		}

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@2
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@2
	pop	ebx
$LN22@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215407 = 16					; size = 4
__Tmp$215397 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@2
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215397[esp+16], edx
	jae	SHORT $LN3@Insert_n@2
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215397[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215397[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215407[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@2:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@2:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@3
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@3:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@3
	pop	ebx
$LN22@Ufill@3:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
PUBLIC	?Reset@CvGameTrade@@QAEXXZ			; CvGameTrade::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?Reset@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvGameTrade@@QAEXXZ PROC				; CvGameTrade::Reset, COMDAT
; _this$ = ecx

; 65   : {

	push	esi
	mov	esi, ecx

; 66   : 	m_aTradeConnections.clear();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax

; 67   : 	m_iNextID = 0;

	mov	DWORD PTR [esi+74608], eax

; 68   : 	m_CurrentTemporaryPopupRoute.iPlotX = 0;

	mov	DWORD PTR [esi+76548], eax

; 69   : 	m_CurrentTemporaryPopupRoute.iPlotY = 0;

	mov	DWORD PTR [esi+76552], eax

; 70   : 	m_CurrentTemporaryPopupRoute.type = TRADE_CONNECTION_INTERNATIONAL;

	mov	DWORD PTR [esi+76556], eax
	pop	esi

; 71   : #ifdef AUI_WARNING_FIXES
; 72   : 	ResetTechDifference();
; 73   : #endif
; 74   : }

	ret	0
?Reset@CvGameTrade@@QAEXXZ ENDP				; CvGameTrade::Reset
_TEXT	ENDS
PUBLIC	?Reset@CvPlayerTrade@@QAEXXZ			; CvPlayerTrade::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::Reset, COMDAT
; _this$ = ecx

; 2278 : {

	push	esi
	mov	esi, ecx

; 2279 : 	m_pPlayer = NULL;
; 2280 : 	m_aRecentlyExpiredConnections.clear();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [esi+79104], 0
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	mov	DWORD PTR [esi+4], 0

; 2281 : 	m_aTradeConnectionWasPlundered.clear();

	mov	edx, DWORD PTR [esi+74612]
	mov	eax, DWORD PTR [esi+74608]
	add	esi, 74608				; 00012370H
	push	edx
	push	eax
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 2282 : }

	ret	0
?Reset@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::Reset
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	esi
	mov	esi, ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	push	eax
	push	edi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN3@FStaticVec@3
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@FStaticVec@3:
	pop	edi
	pop	esi

; 619  : 	};

	ret	0
??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	esi
	mov	esi, ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	push	eax
	push	edi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN3@FStaticVec@4
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@FStaticVec@4:
	pop	edi
	pop	esi

; 619  : 	};

	ret	0
??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T248546 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$248549 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$248549[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T248546[esp+12], 0
	mov	eax, DWORD PTR $T248546[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Ufill
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pTemp$ = -20						; size = 4
$T248556 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T248713 = 8						; size = 4
_i$224159 = 8						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN61@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN61@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+28]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN55@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN55@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 168				; 000000a8H
	jbe	SHORT $LN16@GrowSize@2
	mov	eax, edi
	imul	eax, 444				; 000001bcH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@GrowSize@2
$LN16@GrowSize@2:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 168			; 000000a8H
$LN15@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	edi, edi
	push	ebp
	mov	DWORD PTR _pTemp$[esp+36], ebx
	mov	DWORD PTR _i$224159[esp+32], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN1@GrowSize@2
	or	ebp, -1
$LL3@GrowSize@2:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, edi
	imul	eax, 444				; 000001bcH
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR $T248556[esp+36], ecx
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR [esi]
	add	edx, eax
	push	edx
	call	??0TradeConnection@@QAE@ABU0@@Z
$LN12@GrowSize@2:
	inc	edi
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR _i$224159[esp+32], edi
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@2
$LN1@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T248713[esp+32], ecx
	test	eax, eax
	jbe	SHORT $LN25@GrowSize@2
	lea	edi, DWORD PTR [ecx+44]
	mov	ebp, eax
	npad	6
$LL27@GrowSize@2:
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [edi+12]
	cmp	eax, edx
	je	SHORT $LN39@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR $T248713[esp+36]
	add	esp, 4
$LN39@GrowSize@2:
	add	edi, 444				; 000001bcH
	sub	ebp, 1
	jne	SHORT $LL27@GrowSize@2
$LN25@GrowSize@2:
	lea	eax, DWORD PTR [esi+12]
	pop	ebp
	cmp	ecx, eax
	je	SHORT $LN60@GrowSize@2
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN60@GrowSize@2:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;
; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [esi], ebx
	pop	edi
	mov	BYTE PTR [esi+74604], 1
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$224159[ebp-4]
	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248556[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
PUBLIC	?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_i$224209 = -24						; size = 4
_pTemp$ = -20						; size = 4
$T248736 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T248925 = 8						; size = 4
_pRet$248743 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN67@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN67@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+28]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN61@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN61@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	ebx

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebx, DWORD PTR [esi+8]
	push	ebp
	cmp	ebx, 10					; 0000000aH
	jbe	SHORT $LN16@GrowSize@3
	mov	eax, ebx
	imul	eax, 448				; 000001c0H
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$248743[esp+36], edi
	mov	DWORD PTR [esi+8], ebx
	jmp	SHORT $LN15@GrowSize@3
$LN16@GrowSize@3:
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _pRet$248743[esp+36], ecx
	mov	DWORD PTR [esi+8], 10			; 0000000aH
	mov	edi, ecx
$LN15@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebx, ebx
	mov	DWORD PTR _pTemp$[esp+40], edi
	mov	DWORD PTR _i$224209[esp+40], ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN1@GrowSize@3
	npad	7
$LL3@GrowSize@3:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, ebx
	imul	eax, 448				; 000001c0H
	lea	ebp, DWORD PTR [eax+edi]
	mov	DWORD PTR $T248736[esp+40], ebp
	mov	DWORD PTR __$EHRec$[esp+48], 0
	test	ebp, ebp
	je	SHORT $LN12@GrowSize@3
	mov	edi, DWORD PTR [esi]
	add	edi, eax
	push	edi
	mov	ecx, ebp
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	edx, DWORD PTR [edi+444]
	mov	edi, DWORD PTR _pRet$248743[esp+36]
	mov	DWORD PTR [ebp+444], edx
$LN12@GrowSize@3:
	inc	ebx
	mov	DWORD PTR __$EHRec$[esp+48], -1
	mov	DWORD PTR _i$224209[esp+40], ebx
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@3
$LN1@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T248925[esp+36], ecx
	test	eax, eax
	jbe	SHORT $LN28@GrowSize@3
	lea	ebx, DWORD PTR [ecx+44]
	mov	ebp, eax
	npad	5
$LL30@GrowSize@3:
	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [ebx+12]
	cmp	eax, edx
	je	SHORT $LN45@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR $T248925[esp+40]
	add	esp, 4
$LN45@GrowSize@3:
	add	ebx, 448				; 000001c0H
	sub	ebp, 1
	jne	SHORT $LL30@GrowSize@3
$LN28@GrowSize@3:
	lea	eax, DWORD PTR [esi+12]
	pop	ebp
	pop	ebx
	cmp	ecx, eax
	je	SHORT $LN66@GrowSize@3
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN66@GrowSize@3:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;
; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [esi], edi
	mov	BYTE PTR [esi+4492], 1
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$224209[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248736[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy@4
	npad	2
$LL9@Destroy@4:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@4
$LN7@Destroy@4:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249118 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$249126 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@5:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@5

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$249126[ebp], esi
	mov	DWORD PTR $T249118[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@5
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [esi+444], edx
$LN18@Uninit_fil@5:
	dec	edi
	add	esi, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@5
__catch$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@5
	mov	ebx, DWORD PTR __Al$[ebp]
$LL3@Uninit_fil@5:

; 407  : 		_Al.destroy(_Next);

	push	esi
	mov	ecx, ebx
	call	?destroy@?$allocator@UTRSortElement@@@std@@QAEXPAUTRSortElement@@@Z ; std::allocator<TRSortElement>::destroy
	add	esi, 448				; 000001c0H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@5
$LN1@Uninit_fil@5:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN32@Uninit_fil@5:
$LN4@Uninit_fil@5:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@Uninit_fil@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$249126[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249118[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T249170 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$249174 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$249174[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T249170[esp+4], 0
	mov	eax, DWORD PTR $T249170[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<TRSortElement> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@3
	npad	2
$LL3@Destroy_ra@3:

; 234  : 		_Al.destroy(_First);

	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN21@Destroy_ra@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN21@Destroy_ra@3:
	add	esi, 448				; 000001c0H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@3
$LN1@Destroy_ra@3:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z ; std::_Insertion_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z
_TEXT	SEGMENT
$T249351 = -4						; size = 1
__Cat$249355 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T249351[esp+4], 0
	mov	eax, DWORD PTR $T249351[esp+4]
	mov	ecx, DWORD PTR __Cat$249355[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T249360 = -20						; size = 1
$T249363 = -20						; size = 4
$T249367 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Cat$249372 = 8					; size = 1
$T249362 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	-1
	push	__ehhandler$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T249367[esp+28], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$249372[esp+24]
	mov	edx, DWORD PTR $T249362[esp+24]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	BYTE PTR $T249360[esp+28], bl
	mov	eax, DWORD PTR $T249360[esp+28]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+56]
	mov	eax, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T249363[esp+60], esp
	push	edx
	push	eax
	push	esi
	mov	DWORD PTR __$EHRec$[esp+80], 1
	call	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	lea	ecx, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR $T249367[esp+28], 1
	mov	BYTE PTR __$EHRec$[esp+36], bl
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$2:
	mov	eax, DWORD PTR $T249367[ebp]
	and	eax, 1
	je	$LN6@unchecked_@12
	and	DWORD PTR $T249367[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN6@unchecked_@12:
	ret	0
__ehhandler$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
PUBLIC	??$unchecked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@11USortTR@@@Z ; stdext::unchecked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@11USortTR@@@Z
_TEXT	SEGMENT
$T249395 = -4						; size = 1
$T249396 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@11USortTR@@@Z PROC ; stdext::unchecked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T249396[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T249395[esp+8], 0
	mov	eax, DWORD PTR $T249395[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@11USortTR@@@Z ENDP ; stdext::unchecked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@0PAUTRSortElement@@10USortTR@@@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@0PAUTRSortElement@@10USortTR@@@Z
_TEXT	SEGMENT
$T249404 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Unchecked_merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@0PAUTRSortElement@@10USortTR@@@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T249404[esp+8], 0
	mov	eax, DWORD PTR $T249404[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5229 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@0PAUTRSortElement@@10USortTR@@@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z
_TEXT	SEGMENT
$T249412 = -20						; size = 20
$T249409 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T249546 = 24						; size = 1
__Cat$249550 = 24					; size = 1
$T249548 = 24						; size = 1
$T249514 = 24						; size = 1
__Cat$249518 = 24					; size = 1
$T249516 = 24						; size = 1
$T249476 = 24						; size = 1
__Cat$249480 = 24					; size = 1
$T249478 = 24						; size = 1
$T249443 = 24						; size = 1
__Cat$249447 = 24					; size = 1
$T249445 = 24						; size = 1
$T249413 = 24						; size = 4
$T249411 = 24						; size = 4
$T249410 = 24						; size = 4
$T249408 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count1$[esp+20]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+24]
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+28]
	cmp	ebx, edi
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	ebx, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+48]
	mov	ecx, DWORD PTR __First$[esp+48]
	mov	DWORD PTR $T249408[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T249409[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T249409[esp+32]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T249443[esp+28], bl
	mov	eax, DWORD PTR $T249443[esp+28]
	mov	ecx, DWORD PTR __Cat$249447[esp+28]
	mov	edx, DWORD PTR $T249445[esp+28]
	push	eax
	mov	eax, DWORD PTR __First$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+36]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T249410[esp+52]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T249476[esp+56], bl
	mov	ecx, DWORD PTR $T249476[esp+56]
	mov	edx, DWORD PTR __Cat$249480[esp+56]
	mov	eax, DWORD PTR $T249478[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	edi, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+48]
	mov	ecx, DWORD PTR __Mid$[esp+48]
	mov	DWORD PTR $T249411[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T249412[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T249412[esp+32]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T249514[esp+28], bl
	mov	eax, DWORD PTR $T249514[esp+28]
	mov	ecx, DWORD PTR __Cat$249518[esp+28]
	mov	edx, DWORD PTR $T249516[esp+28]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+36]
	push	edx
	mov	edx, DWORD PTR __First$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T249413[esp+52]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T249546[esp+56], bl
	mov	ecx, DWORD PTR $T249546[esp+56]
	mov	edx, DWORD PTR __Cat$249550[esp+56]
	mov	eax, DWORD PTR $T249548[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+28]
	mov	ecx, DWORD PTR __Mid$[esp+28]
	cmp	eax, ecx
	je	SHORT $LN68@Buffered_r
	mov	edx, DWORD PTR __Last$[esp+28]
	cmp	ecx, edx
	je	SHORT $LN68@Buffered_r
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
	mov	eax, DWORD PTR __First$[esp+48]
	add	esp, 20					; 00000014H
$LN68@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	imul	edi, 448				; 000001c0H
	add	edi, eax

; 2701 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR [eax], edi

; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249703 = -8						; size = 1
$T249657 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T249726 = 24						; size = 1
__Cat$249730 = 24					; size = 1
$T249728 = 24						; size = 1
$T249704 = 24						; size = 1
$T249659 = 24						; size = 4
$T249658 = 24						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>, COMDAT

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+8]
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, eax
	jg	SHORT $LN3@Chunked_me
	push	ebx
	imul	ebp, 448				; 000001c0H
	push	esi
$LL43@Chunked_me:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T249703[esp+24], 0
	mov	ebx, DWORD PTR $T249703[esp+24]
	push	ebx
	mov	ebx, DWORD PTR $T249704[esp+24]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+28]
	push	ebx
	lea	eax, DWORD PTR [ecx+ebp]
	push	edx
	lea	esi, DWORD PTR [eax+ebp]
	push	esi
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T249657[esp+56]
	push	eax
	call	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	mov	eax, DWORD PTR __Count$[esp+56]
	mov	edx, DWORD PTR $T249657[esp+60]
	sub	eax, edi
	add	esp, 36					; 00000024H
	cmp	eax, edi
	mov	DWORD PTR __Dest$[esp+20], edx

; 3443 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+20], eax
	jge	SHORT $LL43@Chunked_me
	mov	ebp, DWORD PTR __Chunk$[esp+20]
	pop	esi
	pop	ebx
$LN3@Chunked_me:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)
; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	BYTE PTR $T249726[esp+12], 0
	cmp	eax, ebp
	mov	eax, DWORD PTR $T249726[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$249730[esp+16]
	push	eax
	jg	SHORT $LN2@Chunked_me
	mov	eax, DWORD PTR $T249728[esp+20]
	push	eax
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T249658[esp+36]
	push	eax
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	add	esp, 8
	ret	0
$LN2@Chunked_me:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+20]
	imul	ebp, 448				; 000001c0H
	push	eax
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	add	ebp, ecx
	push	ebp
	push	ebp
	push	ecx
	lea	eax, DWORD PTR $T249659[esp+44]
	push	eax
	call	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	pop	edi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	add	esp, 8
	ret	0
??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249788 = -40						; size = 4
$T249782 = -36						; size = 4
$T249780 = -36						; size = 4
$T249781 = -32						; size = 20
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	-1
	push	__ehhandler$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T249788[esp+52], ebx
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR __$EHRec$[esp+60], 1
	cmp	eax, DWORD PTR __Last1$[esp+48]
	je	SHORT $LN3@Merge@3
	mov	ecx, DWORD PTR __First2$[esp+48]
$LL4@Merge@3:
	cmp	ecx, DWORD PTR __Last2$[esp+48]
	je	SHORT $LN3@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR [ecx+444]
	cmp	edx, DWORD PTR [eax+444]
	jge	SHORT $LN2@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	push	ecx
	lea	ecx, DWORD PTR __Dest$[esp+52]
	call	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
	mov	ecx, DWORD PTR __First2$[esp+48]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+48]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __First2$[esp+48], ecx
	jmp	SHORT $LN52@Merge@3
$LN2@Merge@3:

; 2601 : 			*_Dest = *_First1, ++_First1;

	push	eax
	lea	ecx, DWORD PTR __Dest$[esp+52]
	call	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	ecx, DWORD PTR __First2$[esp+48]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __First1$[esp+48], eax
$LN52@Merge@3:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+48]
	jne	SHORT $LL4@Merge@3
$LN3@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+68]
	mov	eax, DWORD PTR __First1$[esp+68]
	mov	DWORD PTR $T249780[esp+72], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T249781[esp+80]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T249781[esp+84]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+64], edx
	cmp	eax, ebx
	je	SHORT $LN91@Merge@3
	cmp	eax, DWORD PTR $T249781[esp+60]
	je	SHORT $LN60@Merge@3
	lea	esi, DWORD PTR [eax+44]
$LL62@Merge@3:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN79@Merge@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN79@Merge@3:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, DWORD PTR $T249781[esp+60]
	jne	SHORT $LL62@Merge@3
	mov	eax, DWORD PTR $T249781[esp+52]
$LN60@Merge@3:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Merge@3:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+48]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+68]
	mov	eax, DWORD PTR __First2$[esp+68]
	mov	DWORD PTR $T249782[esp+72], esp
	push	edx
	push	eax
	push	edi
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR __Dest$[esp+48]
	mov	DWORD PTR $T249788[esp+52], 1
	mov	BYTE PTR __$EHRec$[esp+60], bl
	cmp	eax, ebx
	je	SHORT $LN139@Merge@3
	cmp	eax, DWORD PTR __Dest$[esp+56]
	je	SHORT $LN97@Merge@3
	lea	esi, DWORD PTR [eax+44]
$LL99@Merge@3:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN116@Merge@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN116@Merge@3:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, DWORD PTR __Dest$[esp+56]
	jne	SHORT $LL99@Merge@3
	mov	eax, DWORD PTR __Dest$[esp+48]
$LN97@Merge@3:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN139@Merge@3:

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4:
	mov	eax, DWORD PTR $T249788[ebp]
	and	eax, 1
	je	$LN13@Merge@3
	and	DWORD PTR $T249788[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN13@Merge@3:
	ret	0
__ehhandler$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215619 = 16					; size = 4
__Tmp$215609 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@3
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN64@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215609[esp+16], edx
	jae	SHORT $LN3@Insert_n@3
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215609[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215609[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215619[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@3:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@3:
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??0CvGameTrade@@QAE@XZ				; CvGameTrade::CvGameTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvGameTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGameTrade@@QAE@XZ$0
__ehfuncinfo$??0CvGameTrade@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvGameTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvGameTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGameTrade@@QAE@XZ PROC				; CvGameTrade::CvGameTrade, COMDAT
; _this$ = ecx

; 37   : {

	push	-1
	push	__ehhandler$??0CvGameTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], 168			; 000000a8H
	mov	DWORD PTR [esi], eax

; 38   : 	Reset();

	push	edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], edi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+74608], edi
	mov	DWORD PTR [esi+76548], edi
	mov	DWORD PTR [esi+76552], edi
	mov	DWORD PTR [esi+76556], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGameTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__ehhandler$??0CvGameTrade@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvGameTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGameTrade@@QAE@XZ ENDP				; CvGameTrade::CvGameTrade
PUBLIC	??1CvGameTrade@@QAE@XZ				; CvGameTrade::~CvGameTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvGameTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameTrade@@QAE@XZ$0
__ehfuncinfo$??1CvGameTrade@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvGameTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvGameTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvGameTrade@@QAE@XZ PROC				; CvGameTrade::~CvGameTrade, COMDAT
; _this$ = ecx

; 44   : {

	push	-1
	push	__ehhandler$??1CvGameTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi

; 45   : 	Reset();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	xor	ebx, ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy

; 46   : }

	mov	edi, DWORD PTR [esi]
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+74608], ebx
	mov	DWORD PTR [esi+76548], ebx
	mov	DWORD PTR [esi+76552], ebx
	mov	DWORD PTR [esi+76556], ebx
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN10@CvGameTrad
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN10@CvGameTrad:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvGameTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__ehhandler$??1CvGameTrade@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvGameTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvGameTrade@@QAE@XZ ENDP				; CvGameTrade::~CvGameTrade
PUBLIC	?Init@CvGameTrade@@QAEXXZ			; CvGameTrade::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
?Init@CvGameTrade@@QAEXXZ PROC				; CvGameTrade::Init, COMDAT
; _this$ = ecx

; 51   : {

	push	esi
	mov	esi, ecx

; 52   : 	Reset();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+74608], eax
	mov	DWORD PTR [esi+76548], eax
	mov	DWORD PTR [esi+76552], eax
	mov	DWORD PTR [esi+76556], eax
	pop	esi

; 53   : }

	ret	0
?Init@CvGameTrade@@QAEXXZ ENDP				; CvGameTrade::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvGameTrade@@QAEXXZ			; CvGameTrade::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvGameTrade@@QAEXXZ PROC			; CvGameTrade::Uninit, COMDAT
; _this$ = ecx

; 58   : {

	push	esi
	mov	esi, ecx

; 59   : 	Reset();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+74608], eax
	mov	DWORD PTR [esi+76548], eax
	mov	DWORD PTR [esi+76552], eax
	mov	DWORD PTR [esi+76556], eax
	pop	esi

; 60   : }

	ret	0
?Uninit@CvGameTrade@@QAEXXZ ENDP			; CvGameTrade::Uninit
_TEXT	ENDS
PUBLIC	??0CvPlayerTrade@@QAE@XZ			; CvPlayerTrade::CvPlayerTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvPlayerTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$1
__ehfuncinfo$??0CvPlayerTrade@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvPlayerTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlayerTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerTrade@@QAE@XZ PROC				; CvPlayerTrade::CvPlayerTrade, COMDAT
; _this$ = ecx

; 2250 : {

	push	-1
	push	__ehhandler$??0CvPlayerTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	xor	ebx, ebx
	lea	eax, DWORD PTR [esi+12]
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], 168			; 000000a8H
	mov	DWORD PTR [esi], eax
	lea	edi, DWORD PTR [esi+74608]
	lea	eax, DWORD PTR [edi+12]
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], 10			; 0000000aH
	mov	DWORD PTR [edi], eax

; 2251 : 	Reset();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	mov	DWORD PTR [esi+79104], ebx
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	mov	DWORD PTR [esi+4], ebx
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	mov	ecx, edi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy

; 2252 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [edi+4], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	jmp	??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
__ehhandler$??0CvPlayerTrade@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerTrade@@QAE@XZ ENDP				; CvPlayerTrade::CvPlayerTrade
PUBLIC	??1CvPlayerTrade@@QAE@XZ			; CvPlayerTrade::~CvPlayerTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPlayerTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$1
__ehfuncinfo$??1CvPlayerTrade@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvPlayerTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlayerTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerTrade@@QAE@XZ PROC				; CvPlayerTrade::~CvPlayerTrade, COMDAT
; _this$ = ecx

; 2257 : {

	push	-1
	push	__ehhandler$??1CvPlayerTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+28], edi

; 2258 : 	Reset();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ecx
	xor	ebx, ebx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], 1
	mov	DWORD PTR [edi+79104], ebx
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	lea	esi, DWORD PTR [edi+74608]
	mov	DWORD PTR [edi+4], ebx
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	eax
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy

; 2259 : }

	mov	eax, ebx
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR __$EHRec$[esp+36], bl
	mov	ebx, DWORD PTR [esi]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	ebx, esi
	je	SHORT $LN13@CvPlayerTr
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN13@CvPlayerTr:
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi]
	push	ecx
	push	esi
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	add	edi, 12					; 0000000cH
	cmp	esi, edi
	je	SHORT $LN21@CvPlayerTr
	push	esi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN21@CvPlayerTr:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	jmp	??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
__ehhandler$??1CvPlayerTrade@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerTrade@@QAE@XZ ENDP				; CvPlayerTrade::~CvPlayerTrade
PUBLIC	?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z	; CvPlayerTrade::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z PROC		; CvPlayerTrade::Init, COMDAT
; _this$ = ecx

; 2264 : {

	push	esi
	mov	esi, ecx

; 2265 : 	Reset();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [esi+79104], 0
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	lea	edi, DWORD PTR [esi+74608]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	mov	ecx, edi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy

; 2266 : 	m_pPlayer = pPlayer;

	mov	ecx, DWORD PTR _pPlayer$[esp+4]
	mov	DWORD PTR [edi+4], 0
	pop	edi
	mov	DWORD PTR [esi+79104], ecx
	pop	esi

; 2267 : }

	ret	4
?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z ENDP		; CvPlayerTrade::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvPlayerTrade@@QAEXXZ			; CvPlayerTrade::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::Uninit, COMDAT
; _this$ = ecx

; 2272 : {

	push	esi
	mov	esi, ecx

; 2273 : 	Reset();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [esi+79104], 0
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR [esi+74612]
	mov	eax, DWORD PTR [esi+74608]
	add	esi, 74608				; 00012370H
	push	edx
	push	eax
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; BaseVector<TradeConnectionWasPlundered,0>::Destroy
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 2274 : }

	ret	0
?Uninit@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::Uninit
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250652 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+24], esi
	mov	BYTE PTR [esi+74604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T250652[esp+24], ecx
	mov	DWORD PTR __$EHRec$[esp+32], 0
	je	SHORT $LN4@push_back@2
	mov	eax, DWORD PTR _element$[esp+20]
	push	eax
	call	??0TradeConnection@@QAE@ABU0@@Z
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], ecx

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T250652[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::push_back
PUBLIC	?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250669 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	BYTE PTR [esi+4492], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	edi, DWORD PTR [esi+4]
	imul	edi, 448				; 000001c0H
	add	edi, DWORD PTR [esi]
	mov	DWORD PTR $T250669[esp+32], edi
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	je	SHORT $LN4@push_back@3
	mov	ebx, DWORD PTR _element$[esp+28]
	push	ebx
	mov	ecx, edi
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR [ebx+444]
	mov	DWORD PTR [edi+444], eax
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], ecx

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T250669[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@4
	xor	eax, eax
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@4:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN25@Tidy@4
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@4
$LL12@Tidy@4:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@4
$LN10@Tidy@4:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN25@Tidy@4:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@std@@@Z
_TEXT	SEGMENT
$T251046 = -4						; size = 1
__Cat$251051 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T251046[esp+4], 0
	mov	eax, DWORD PTR $T251046[esp+4]
	mov	ecx, DWORD PTR __Cat$251051[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z
_TEXT	SEGMENT
$T251099 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$251103 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$251103[esp]
	mov	BYTE PTR $T251099[esp+4], 0
	mov	eax, DWORD PTR $T251099[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@@Z
_TEXT	SEGMENT
__Cat$251114 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@@Z PROC ; std::_Destroy_range<std::allocator<TRSortElement> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Cat$251114[esp+4]
	mov	ecx, DWORD PTR __Al$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >

; 226  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<TRSortElement *,TRSortElement *,std::allocator<TRSortElement>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251127 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$251131 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<TRSortElement *,TRSortElement *,std::allocator<TRSortElement>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$251131[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T251127[esp+4], 0
	mov	eax, DWORD PTR $T251127[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@U_Undefined_move_tag@3@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<TRSortElement *,TRSortElement *,std::allocator<TRSortElement>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z
_TEXT	SEGMENT
tv477 = -24						; size = 4
$T251399 = -24						; size = 4
$T251309 = -24						; size = 4
$T251141 = -20						; size = 20
$T251138 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T251240 = 20						; size = 1
__Midn$226445 = 20					; size = 4
$T251142 = 20						; size = 4
$T251140 = 20						; size = 4
$T251139 = 20						; size = 4
$T251137 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+444]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+444]
	jge	$LN3@Buffered_m

; 2893 : 			std::iter_swap(_First, _Mid);

	push	eax
	push	ecx
	call	??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ; std::swap<TRSortElement>
	add	esp, 8

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T251137[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T251138[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T251138[esp+40]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+36]
	mov	ecx, DWORD PTR __First$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T251139[esp+60]
	push	eax
	call	??$unchecked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@0V12@11USortTR@@@Z ; stdext::unchecked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
	add	esp, 28					; 0000001cH

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T251140[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T251141[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T251141[esp+40]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	BYTE PTR $T251240[esp+36], bl
	mov	eax, DWORD PTR $T251240[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+48]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T251142[esp+64]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
	add	esp, 32					; 00000020H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m:

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	push	0
	jge	SHORT $LN2@Buffered_m
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Pred$[esp+40]
	mov	ebx, eax
	mov	eax, DWORD PTR __Last$[esp+40]
	sar	ebx, 1
	mov	ebp, ebx
	imul	ebp, 448				; 000001c0H
	add	ebp, DWORD PTR __First$[esp+40]
	push	edx
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T251309[esp+56]
	push	esi
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
	mov	edi, DWORD PTR [eax]

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, edi
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 24					; 00000018H
	add	esi, edx

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN116@Buffered_m
$LN2@Buffered_m:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ebx, DWORD PTR __First$[esp+40]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Pred$[esp+40]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	mov	edi, esi
	imul	edi, 448				; 000001c0H
	push	edx
	add	edi, eax
	push	edi
	push	eax
	lea	eax, DWORD PTR $T251399[esp+56]
	push	ebx
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
	mov	ebp, DWORD PTR [eax]

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, ebp
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	esp, 24					; 00000018H
	add	ebx, edx
$LN116@Buffered_m:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, ebx
	push	eax
	push	edi
	push	edx
	mov	DWORD PTR tv477[esp+60], eax
	lea	eax, DWORD PTR __Midn$226445[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	edx, DWORD PTR __Tempbuf$[esp+64]
	mov	eax, DWORD PTR __First$[esp+64]
	push	ecx
	push	edx
	push	esi
	push	ebx
	mov	ebx, DWORD PTR __Midn$226445[esp+80]
	push	ebx
	push	ebp
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+92]
	mov	edx, DWORD PTR __Tempbuf$[esp+92]
	mov	eax, DWORD PTR __Count2$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+96]
	push	edx
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR tv477[esp+108]
	push	eax
	push	ecx
	push	edi
	push	ebx
	call	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 84					; 00000054H
$LN3@Buffered_m:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@stdext@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HHUSortTR@@@Z ; stdext::_Unchecked_chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@stdext@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HHUSortTR@@@Z
_TEXT	SEGMENT
$T251446 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@stdext@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HHUSortTR@@@Z PROC ; stdext::_Unchecked_chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T251446[esp+4], 0
	mov	eax, DWORD PTR $T251446[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@stdext@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HHUSortTR@@@Z ENDP ; stdext::_Unchecked_chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$0
__ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
_TEXT	SEGMENT
$T251450 = -20						; size = 1
$T251452 = -20						; size = 4
$T251456 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T251451 = 48						; size = 1
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	-1
	push	__ehhandler$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T251456[esp+28], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T251451[esp+24]
	mov	edx, DWORD PTR __Pred$[esp+24]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	BYTE PTR $T251450[esp+28], bl
	mov	eax, DWORD PTR $T251450[esp+28]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+56]
	mov	eax, DWORD PTR __First2$[esp+56]
	mov	ecx, DWORD PTR __Last1$[esp+56]
	mov	DWORD PTR $T251452[esp+60], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+60]
	push	eax
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+88], 1
	call	??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>
	add	esp, 52					; 00000034H
	lea	ecx, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR $T251456[esp+28], 1
	mov	BYTE PTR __$EHRec$[esp+36], bl
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$2:
	mov	eax, DWORD PTR $T251456[ebp]
	and	eax, 1
	je	$LN6@unchecked_@13
	and	DWORD PTR $T251456[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN6@unchecked_@13:
	ret	0
__ehhandler$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@5
	xor	eax, eax
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@5:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@5
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
$T251736 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T251736[esp+12]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN1@resize:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z	; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z$0
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
_TEXT	SEGMENT
tv298 = -2536						; size = 4
_nPlots$ = -2536					; size = 4
_i2$221065 = -2536					; size = 4
tv76 = -2532						; size = 4
_i$221051 = -2532					; size = 4
_uiVersion$ = -2528					; size = 4
_iNum$ = -2524						; size = 4
_iNum2$221064 = -2520					; size = 4
_kTradeConnectionPlot$221069 = -2516			; size = 8
_iConnectionType$221060 = -2516				; size = 4
_iDomain$221058 = -2508					; size = 4
_kTradeConnection$221055 = -2504			; size = 444
_plotsY$ = -2060					; size = 1024
_plotsX$ = -1036					; size = 1024
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z PROC	; operator>>, COMDAT

; 2047 : {

	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2524				; 000009dcH
	push	ebx
	push	ebp

; 2048 : 	int plotsX[MAX_PLOTS_TO_DISPLAY];
; 2049 : 	int plotsY[MAX_PLOTS_TO_DISPLAY];
; 2050 : 	int nPlots;
; 2051 : 
; 2052 : 	uint uiVersion;
; 2053 : 	loadFrom >> uiVersion;

	mov	ebp, DWORD PTR _loadFrom$[esp+2540]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+2552]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2054 : 
; 2055 : 	int iNum = 0;
; 2056 : 	loadFrom >> iNum;

	lea	ecx, DWORD PTR _iNum$[esp+2552]
	push	ecx
	xor	ebx, ebx
	mov	ecx, ebp
	mov	DWORD PTR _iNum$[esp+2556], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2057 : 	for (int i = 0; i < iNum; i++)

	cmp	DWORD PTR _iNum$[esp+2552], ebx
	mov	esi, DWORD PTR _writeTo$[esp+2548]
	mov	DWORD PTR _i$221051[esp+2552], ebx
	jle	$LN196@operator@17

; 2048 : 	int plotsX[MAX_PLOTS_TO_DISPLAY];
; 2049 : 	int plotsY[MAX_PLOTS_TO_DISPLAY];
; 2050 : 	int nPlots;
; 2051 : 
; 2052 : 	uint uiVersion;
; 2053 : 	loadFrom >> uiVersion;

	xor	edi, edi
	jmp	SHORT $LN30@operator@17
	npad	3
$LL197@operator@17:
	xor	ebx, ebx
$LN30@operator@17:

; 2058 : 	{
; 2059 : 		TradeConnection kTradeConnection;

	lea	edx, DWORD PTR _kTradeConnection$221055[esp+2608]
	mov	DWORD PTR _kTradeConnection$221055[esp+2600], ebx
	mov	DWORD PTR _kTradeConnection$221055[esp+2604], 40 ; 00000028H
	mov	DWORD PTR _kTradeConnection$221055[esp+2596], edx

; 2060 : 		writeTo.m_aTradeConnections.push_back(kTradeConnection);

	lea	eax, DWORD PTR _kTradeConnection$221055[esp+2552]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+2564], ebx
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 2061 : 		if (uiVersion >= 1)

	cmp	DWORD PTR _uiVersion$[esp+2552], 1
	jb	SHORT $LN27@operator@17

; 2062 : 		{
; 2063 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_iID;

	mov	eax, DWORD PTR [esi]
	add	eax, edi
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2064 : 		}
; 2065 : 		else

	jmp	SHORT $LN26@operator@17
$LN27@operator@17:

; 2066 : 		{
; 2067 : 			writeTo.m_aTradeConnections[i].m_iID = MAX_INT;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edi+ecx], 2147483647		; 7fffffffH
$LN26@operator@17:

; 2068 : 		}
; 2069 : 
; 2070 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iOriginX;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi+4]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2071 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iOriginY;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi+8]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2072 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iDestX;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi+12]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2073 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iDestY;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi+16]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2074 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_eOriginOwner;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edi+20]
	push	ecx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 2075 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_eDestOwner;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi+24]
	push	eax
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 2076 : 		int iDomain;
; 2077 : 		loadFrom >> iDomain;

	lea	ecx, DWORD PTR _iDomain$221058[esp+2552]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2078 : 		writeTo.m_aTradeConnections[i].m_eDomain = (DomainTypes)iDomain;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _iDomain$221058[esp+2552]

; 2079 : 		int iConnectionType;
; 2080 : 		loadFrom >> iConnectionType;

	lea	ecx, DWORD PTR _iConnectionType$221060[esp+2552]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR [edx+edi+28], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2081 : 		writeTo.m_aTradeConnections[i].m_eConnectionType = (TradeConnectionType)iConnectionType;

	mov	eax, DWORD PTR _iConnectionType$221060[esp+2552]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edx+edi+32], eax

; 2082 : 
; 2083 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi+36]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2084 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_bTradeUnitMovingForward;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi+40]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2085 : 
; 2086 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_unitID;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi+380]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2087 : 
; 2088 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iCircuitsCompleted;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi+384]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2089 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iCircuitsToComplete;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi+388]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2090 : 
; 2091 : 		if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+2552], 2
	jb	SHORT $LN25@operator@17

; 2092 : 		{
; 2093 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_iTurnRouteComplete;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi+392]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2094 : 		}
; 2095 : 		else

	jmp	SHORT $LN24@operator@17
$LN25@operator@17:

; 2096 : 		{
; 2097 : 			writeTo.m_aTradeConnections[i].m_iTurnRouteComplete = 0;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edi+392], ebx
$LN24@operator@17:

; 2098 : 		}
; 2099 : 
; 2100 : 		int iNum2 = 0;
; 2101 : 		loadFrom >> iNum2;

	lea	edx, DWORD PTR _iNum2$221064[esp+2552]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR _iNum2$221064[esp+2556], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2102 : 
; 2103 : 		for (int i2 = 0; i2 < iNum2; i2++)

	mov	ecx, DWORD PTR _iNum2$221064[esp+2552]
	cmp	ecx, ebx
	mov	DWORD PTR _i2$221065[esp+2552], ebx
	jle	$LN21@operator@17
	npad	6
$LL195@operator@17:

; 2104 : 		{
; 2105 : 			TradeConnectionPlot kTradeConnectionPlot;
; 2106 : 			writeTo.m_aTradeConnections[i].m_aPlotList.push_back(kTradeConnectionPlot);

	mov	eax, DWORD PTR [esi]
	lea	ebx, DWORD PTR [eax+edi+44]
	mov	eax, DWORD PTR [ebx+8]
	mov	BYTE PTR [ebx+332], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN113@operator@17
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
$LN113@operator@17:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN116@operator@17
	mov	ecx, DWORD PTR _kTradeConnectionPlot$221069[esp+2552]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _kTradeConnectionPlot$221069[esp+2556]
	mov	DWORD PTR [eax+4], edx
$LN116@operator@17:
	inc	DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR _i2$221065[esp+2552]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edi+44]
	add	ebx, ebx
	add	ebx, ebx
	add	ebx, ebx
	add	eax, ebx

; 2107 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iX;

	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2108 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iY;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+edi+44]
	lea	eax, DWORD PTR [edx+ebx+4]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2109 : 			
; 2110 : 			if (i2 < MAX_PLOTS_TO_DISPLAY) {

	mov	eax, DWORD PTR _i2$221065[esp+2552]
	cmp	eax, 256				; 00000100H
	jge	SHORT $LN22@operator@17

; 2111 : 				plotsX[i2] = writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iX;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+edi+44]
	mov	edx, DWORD PTR [ebx+edx]
	lea	ecx, DWORD PTR [ecx+edi+44]
	mov	DWORD PTR _plotsX$[esp+eax*4+2552], edx

; 2112 : 				plotsY[i2] = writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iY;

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx+ecx+4]
	mov	DWORD PTR _plotsY$[esp+eax*4+2552], edx
$LN22@operator@17:
	mov	ecx, DWORD PTR _iNum2$221064[esp+2552]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i2$221065[esp+2552], eax
	jl	$LL195@operator@17

; 2102 : 
; 2103 : 		for (int i2 = 0; i2 < iNum2; i2++)

	xor	ebx, ebx
$LN21@operator@17:

; 2113 : 			}
; 2114 : 		}
; 2115 : 
; 2116 : 		nPlots = iNum2;
; 2117 : 		if (nPlots > 0)

	cmp	ecx, ebx
	mov	DWORD PTR _nPlots$[esp+2552], ecx
	jle	SHORT $LN19@operator@17

; 2118 : 		{
; 2119 : 			if (nPlots > MAX_PLOTS_TO_DISPLAY)

	cmp	ecx, 256				; 00000100H
	jle	SHORT $LN18@operator@17

; 2120 : 				nPlots = MAX_PLOTS_TO_DISPLAY;

	mov	DWORD PTR _nPlots$[esp+2552], 256	; 00000100H
$LN18@operator@17:

; 2121 : 			gDLL->TradeVisuals_NewRoute(i,writeTo.m_aTradeConnections[i].m_eOriginOwner,writeTo.m_aTradeConnections[i].m_eConnectionType,nPlots,plotsX,plotsY);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+972]
	lea	ebx, DWORD PTR _plotsY$[esp+2552]
	push	ebx
	lea	ebx, DWORD PTR _plotsX$[esp+2556]
	push	ebx
	mov	ebx, DWORD PTR _nPlots$[esp+2560]
	push	ebx
	mov	ebx, DWORD PTR [eax+edi+32]
	add	eax, edi
	mov	eax, DWORD PTR [eax+20]
	push	ebx
	mov	ebx, DWORD PTR _i$221051[esp+2568]
	push	eax
	push	ebx
	call	edx

; 2122 : 			gDLL->TradeVisuals_UpdateRouteDirection(i, writeTo.m_aTradeConnections[i].m_bTradeUnitMovingForward);

	mov	edx, DWORD PTR [esi]
	movzx	edx, BYTE PTR [edx+edi+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+976]
	push	edx
	push	ebx
	call	eax
$LN19@operator@17:

; 2123 : 		}
; 2124 : 
; 2125 : 		for (uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	lea	ebx, DWORD PTR [edi+420]
	mov	DWORD PTR tv298[esp+2552], 6
	npad	6
$LL17@operator@17:

; 2126 : 		{
; 2127 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aiOriginYields[ui];

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+ebx-24]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR [esi]
	add	eax, ebx

; 2128 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aiDestYields[ui];

	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	DWORD PTR tv298[esp+2552], 1
	jne	SHORT $LL17@operator@17

; 2129 : 		}
; 2130 : 	}

	mov	eax, DWORD PTR _kTradeConnection$221055[esp+2596]
	lea	edx, DWORD PTR _kTradeConnection$221055[esp+2608]
	mov	DWORD PTR __$EHRec$[esp+2560], -1
	cmp	eax, edx
	je	SHORT $LN29@operator@17
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN29@operator@17:
	mov	eax, DWORD PTR _i$221051[esp+2552]
	inc	eax
	add	edi, 444				; 000001bcH
	cmp	eax, DWORD PTR _iNum$[esp+2552]
	mov	DWORD PTR _i$221051[esp+2552], eax
	jl	$LL197@operator@17
$LN196@operator@17:

; 2131 : 
; 2132 : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[esp+2552], 3

; 2133 : 	{
; 2134 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	lea	edi, DWORD PTR [esi+74612]
	jb	SHORT $LN14@operator@17
	mov	DWORD PTR tv76[esp+2552], 22		; 00000016H
$LL198@operator@17:

; 2135 : 		{
; 2136 : 			for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)

	mov	ebx, 22					; 00000016H
$LL10@operator@17:

; 2137 : 			{
; 2138 : 				loadFrom >> writeTo.m_aaiTechDifference[ui][ui2];

	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL10@operator@17

; 2133 : 	{
; 2134 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	sub	DWORD PTR tv76[esp+2552], 1
	jne	SHORT $LL198@operator@17

; 2139 : 			}
; 2140 : 		}
; 2141 : 	}
; 2142 : 	else

	jmp	SHORT $LN6@operator@17
$LN14@operator@17:

; 2143 : 	{
; 2144 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 2145 : 		{
; 2146 : 			for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)
; 2147 : 			{
; 2148 : 				writeTo.m_aaiTechDifference[ui][ui2] = 0;

	mov	ecx, 484				; 000001e4H
	xor	eax, eax
	rep stosd
$LN6@operator@17:

; 2149 : 			}
; 2150 : 		}
; 2151 : 	}
; 2152 : 
; 2153 : 	loadFrom >> writeTo.m_iNextID;

	add	esi, 74608				; 00012370H
	push	esi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2154 : 
; 2155 : 	return loadFrom;
; 2156 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2552]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 2536				; 000009e8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z$0:
	lea	ecx, DWORD PTR _kTradeConnection$221055[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z ENDP	; operator>>
PUBLIC	?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradeUnitsAtPlot
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0
__ehfuncinfo$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
_TEXT	SEGMENT
_uiConnection$222123 = -40				; size = 4
_iX$ = -36						; size = 4
$T252139 = -32						; size = 4
_iY$ = -32						; size = 4
_aiTradeConnectionIDs$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T252318 = 12						; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
_bExcludingMe$ = 20					; size = 1
_bOnlyWar$ = 24						; size = 1
?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z PROC ; CvPlayerTrade::GetTradeUnitsAtPlot, COMDAT
; _this$ = ecx

; 3596 : {

	push	-1
	push	__ehhandler$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T252139[esp+48], edi

; 3597 : 	std::vector<int> aiTradeConnectionIDs;

	mov	DWORD PTR _aiTradeConnectionIDs$[esp+52], edi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+56], edi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+60], edi

; 3598 : 
; 3599 : 	if (pPlot == NULL)

	mov	eax, DWORD PTR _pPlot$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], edi
	cmp	eax, edi
	jne	SHORT $LN10@GetTradeUn@2

; 3600 : 	{
; 3601 : 		return aiTradeConnectionIDs;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+44]
	lea	eax, DWORD PTR _aiTradeConnectionIDs$[esp+48]
	push	eax
	mov	ecx, esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	pop	edi

; 3650 : 			{
; 3651 : 				break;
; 3652 : 			}
; 3653 : 		}
; 3654 : 	}
; 3655 : 
; 3656 : 	return aiTradeConnectionIDs;	

	mov	eax, esi
	pop	esi

; 3657 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	20					; 00000014H
$LN10@GetTradeUn@2:

; 3602 : 	}
; 3603 : 
; 3604 : 	int iX = pPlot->getX();

	movsx	edx, WORD PTR [eax]

; 3605 : 	int iY = pPlot->getY();

	movsx	eax, WORD PTR [eax+2]

; 3606 : 
; 3607 : 	TeamTypes eMyTeam = m_pPlayer->getTeam();

	mov	ecx, DWORD PTR [ecx+79104]
	push	ebx
	mov	DWORD PTR _iY$[esp+52], eax
	mov	eax, DWORD PTR [ecx+44]
	or	ebx, -1
	push	ebp
	mov	DWORD PTR _iX$[esp+56], edx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN68@GetTradeUn@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T252318[esp+52], edx
	jmp	SHORT $LN69@GetTradeUn@2
$LN68@GetTradeUn@2:
	mov	DWORD PTR $T252318[esp+52], ebx
$LN69@GetTradeUn@2:

; 3608 : 
; 3609 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ebp, eax

; 3610 : #ifdef AUI_ITERATORIZE
; 3611 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3612 : 	{
; 3613 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3614 : #else
; 3615 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$222123[esp+56], edi
	cmp	DWORD PTR [ebp+4], edi
	jbe	$LN116@GetTradeUn@2
	npad	1
$LL9@GetTradeUn@2:

; 3616 : 	{
; 3617 : #ifdef AUI_CONSTIFY
; 3618 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);
; 3619 : #else
; 3620 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);

	mov	eax, DWORD PTR [ebp]

; 3621 : #endif
; 3622 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	cmp	DWORD PTR [edi+eax+4], ebx
	lea	esi, DWORD PTR [edi+eax]
	jne	SHORT $LN80@GetTradeUn@2
	cmp	DWORD PTR [esi+8], ebx
	jne	SHORT $LN80@GetTradeUn@2
	cmp	DWORD PTR [esi+12], ebx
	jne	SHORT $LN80@GetTradeUn@2
	cmp	DWORD PTR [esi+16], ebx
	je	$LN8@GetTradeUn@2
$LN80@GetTradeUn@2:

; 3623 : #endif
; 3624 : 		{
; 3625 : 			continue;
; 3626 : 		}
; 3627 : 
; 3628 : 		TeamTypes eOtherTeam = GET_PLAYER(pConnection->m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN97@GetTradeUn@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN98@GetTradeUn@2
$LN97@GetTradeUn@2:
	mov	eax, ebx
$LN98@GetTradeUn@2:

; 3629 : 
; 3630 : 		bool bIgnore = false;

	xor	bl, bl

; 3631 : 		if (bExcludingMe && eOtherTeam == eMyTeam)

	cmp	BYTE PTR _bExcludingMe$[esp+52], bl
	je	SHORT $LN121@GetTradeUn@2
	cmp	eax, DWORD PTR $T252318[esp+52]
	jne	SHORT $LN121@GetTradeUn@2

; 3632 : 		{
; 3633 : 			bIgnore = true;

	mov	bl, 1
$LN121@GetTradeUn@2:

; 3634 : 		}
; 3635 : 
; 3636 : 		if (bOnlyWar && !GET_TEAM(eMyTeam).isAtWar(eOtherTeam))

	cmp	BYTE PTR _bOnlyWar$[esp+52], 0
	je	SHORT $LN4@GetTradeUn@2
	mov	ecx, DWORD PTR $T252318[esp+52]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 3637 : 		{
; 3638 : 			bIgnore = true;
; 3639 : 		}
; 3640 : 
; 3641 : 		if (bIgnore)

	je	SHORT $LN122@GetTradeUn@2
$LN4@GetTradeUn@2:
	test	bl, bl
	jne	SHORT $LN122@GetTradeUn@2

; 3642 : 		{
; 3643 : 			continue;
; 3644 : 		}
; 3645 : 
; 3646 : 		if (pConnection->m_aPlotList[pConnection->m_iTradeUnitLocationIndex].m_iX == iX && pConnection->m_aPlotList[pConnection->m_iTradeUnitLocationIndex].m_iY == iY)

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR _iX$[esp+56]
	cmp	DWORD PTR [ecx+eax*8], edx
	lea	eax, DWORD PTR [ecx+eax*8]
	jne	SHORT $LN122@GetTradeUn@2
	mov	ecx, DWORD PTR _iY$[esp+56]
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN122@GetTradeUn@2

; 3647 : 		{
; 3648 : 			aiTradeConnectionIDs.push_back(pConnection->m_iID);

	push	esi
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+60]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3649 : 			if (bFailAtFirstFound)

	cmp	BYTE PTR _bFailAtFirstFound$[esp+52], bl
	jne	SHORT $LN123@GetTradeUn@2
$LN122@GetTradeUn@2:
	or	ebx, -1
$LN8@GetTradeUn@2:

; 3610 : #ifdef AUI_ITERATORIZE
; 3611 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3612 : 	{
; 3613 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3614 : #else
; 3615 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	eax, DWORD PTR _uiConnection$222123[esp+56]
	inc	eax
	add	edi, 444				; 000001bcH
	mov	DWORD PTR _uiConnection$222123[esp+56], eax
	cmp	eax, DWORD PTR [ebp+4]
	jb	$LL9@GetTradeUn@2
$LN123@GetTradeUn@2:
	mov	edi, DWORD PTR _aiTradeConnectionIDs$[esp+60]
$LN116@GetTradeUn@2:

; 3650 : 			{
; 3651 : 				break;
; 3652 : 			}
; 3653 : 		}
; 3654 : 	}
; 3655 : 
; 3656 : 	return aiTradeConnectionIDs;	

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+52]
	lea	edx, DWORD PTR _aiTradeConnectionIDs$[esp+56]
	push	edx
	mov	ecx, esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	pop	ebp
	pop	ebx
	test	edi, edi
	je	SHORT $LN113@GetTradeUn@2
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN113@GetTradeUn@2:

; 3657 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ENDP ; CvPlayerTrade::GetTradeUnitsAtPlot
PUBLIC	?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradePlotsAtPlot
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0
__ehfuncinfo$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
_TEXT	SEGMENT
_pTrade$ = -48						; size = 4
_uiConnection$222158 = -44				; size = 4
tv856 = -40						; size = 4
_iX$ = -36						; size = 4
$T252441 = -32						; size = 4
_iY$ = -32						; size = 4
_aiTradeConnectionIDs$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T252620 = 12						; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
_bExcludingMe$ = 20					; size = 1
_bOnlyWar$ = 24						; size = 1
?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z PROC ; CvPlayerTrade::GetTradePlotsAtPlot, COMDAT
; _this$ = ecx

; 3666 : {

	push	-1
	push	__ehhandler$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebp
	push	esi
	xor	esi, esi

; 3667 : 	std::vector<int> aiTradeConnectionIDs;

	xor	ebp, ebp
	mov	DWORD PTR $T252441[esp+56], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+60], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+64], ebp
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+68], esi

; 3668 : 
; 3669 : 	if (pPlot == NULL)

	mov	eax, DWORD PTR _pPlot$[esp+52]
	mov	DWORD PTR __$EHRec$[esp+64], esi
	cmp	eax, esi
	jne	SHORT $LN14@GetTradePl

; 3670 : 	{
; 3671 : 		return aiTradeConnectionIDs;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+52]
	lea	eax, DWORD PTR _aiTradeConnectionIDs$[esp+56]
	push	eax
	mov	ecx, esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 3735 : 		{
; 3736 : 			break;
; 3737 : 		}
; 3738 : 	}
; 3739 : 
; 3740 : 	return aiTradeConnectionIDs;	

	mov	eax, esi
	pop	esi
	pop	ebp

; 3741 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	20					; 00000014H
$LN14@GetTradePl:

; 3672 : 	}
; 3673 : 
; 3674 : 	int iX = pPlot->getX();

	movsx	edx, WORD PTR [eax]

; 3675 : 	int iY = pPlot->getY();

	movsx	eax, WORD PTR [eax+2]

; 3676 : 
; 3677 : 	TeamTypes eMyTeam = m_pPlayer->getTeam();

	mov	ecx, DWORD PTR [ecx+79104]
	mov	DWORD PTR _iY$[esp+56], eax
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR _iX$[esp+56], edx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN72@GetTradePl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T252620[esp+52], edx
	jmp	SHORT $LN73@GetTradePl
$LN72@GetTradePl:
	mov	DWORD PTR $T252620[esp+52], -1
$LN73@GetTradePl:

; 3678 : 
; 3679 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	edi, eax
	mov	DWORD PTR _pTrade$[esp+60], edi

; 3680 : #ifdef AUI_ITERATORIZE
; 3681 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3682 : 	{
; 3683 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3684 : #else
; 3685 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$222158[esp+60], esi
	cmp	DWORD PTR [edi+4], esi
	jbe	$LN201@GetTradePl
	mov	DWORD PTR tv856[esp+60], esi
	push	ebx
	npad	6
$LL204@GetTradePl:

; 3686 : 	{
; 3687 : #ifdef AUI_CONSTIFY
; 3688 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);
; 3689 : #else
; 3690 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);

	mov	eax, DWORD PTR [edi]
	add	esi, eax

; 3691 : #endif
; 3692 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	or	ecx, -1
	cmp	DWORD PTR [esi+4], ecx
	jne	SHORT $LN84@GetTradePl
	cmp	DWORD PTR [esi+8], ecx
	jne	SHORT $LN84@GetTradePl
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN84@GetTradePl
	cmp	DWORD PTR [esi+16], ecx
	je	$LN12@GetTradePl
$LN84@GetTradePl:

; 3693 : #endif
; 3694 : 		{
; 3695 : 			continue;
; 3696 : 		}
; 3697 : 
; 3698 : 		TeamTypes eOtherTeam = GET_PLAYER(pConnection->m_eOriginOwner).getTeam();

	mov	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN101@GetTradePl
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN102@GetTradePl
$LN101@GetTradePl:
	mov	eax, ecx
$LN102@GetTradePl:

; 3699 : 
; 3700 : 		bool bIgnore = false;

	xor	bl, bl

; 3701 : 		if (bExcludingMe && eOtherTeam == eMyTeam)

	cmp	BYTE PTR _bExcludingMe$[esp+60], bl
	je	SHORT $LN202@GetTradePl
	cmp	eax, DWORD PTR $T252620[esp+60]
	jne	SHORT $LN202@GetTradePl

; 3702 : 		{
; 3703 : 			bIgnore = true;

	mov	bl, 1
$LN202@GetTradePl:

; 3704 : 		}
; 3705 : 
; 3706 : 		if (bOnlyWar && !GET_TEAM(eMyTeam).isAtWar(eOtherTeam))

	cmp	BYTE PTR _bOnlyWar$[esp+60], 0
	je	SHORT $LN8@GetTradePl
	mov	ecx, DWORD PTR $T252620[esp+60]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN12@GetTradePl
$LN8@GetTradePl:

; 3707 : 		{
; 3708 : 			bIgnore = true;
; 3709 : 		}
; 3710 : 
; 3711 : 		if (bIgnore)

	test	bl, bl
	jne	$LN12@GetTradePl

; 3712 : 		{
; 3713 : 			continue;
; 3714 : 		}
; 3715 : 
; 3716 : #ifdef AUI_ITERATORIZE
; 3717 : 		for (TradeConnectionPlotList::const_iterator it = pConnection->m_aPlotList.begin(); it != pConnection->m_aPlotList.end(); ++it)
; 3718 : 		{
; 3719 : 			if (it->m_iX == iX && it->m_iY == iY)
; 3720 : #else
; 3721 : 		for (uint ui = 0; ui < pConnection->m_aPlotList.size(); ui++)

	xor	edi, edi
	cmp	DWORD PTR [esi+48], edi
	jbe	SHORT $LN187@GetTradePl
	npad	6
$LL6@GetTradePl:
	mov	eax, DWORD PTR [esi+44]

; 3722 : 		{
; 3723 : 			if (pConnection->m_aPlotList[ui].m_iX == iX && pConnection->m_aPlotList[ui].m_iY == iY)

	mov	ecx, DWORD PTR _iX$[esp+64]
	cmp	DWORD PTR [eax+edi*8], ecx
	lea	eax, DWORD PTR [eax+edi*8]
	jne	SHORT $LN5@GetTradePl
	mov	edx, DWORD PTR _iY$[esp+64]
	cmp	DWORD PTR [eax+4], edx
	jne	SHORT $LN5@GetTradePl

; 3724 : #endif
; 3725 : 			{
; 3726 : 				aiTradeConnectionIDs.push_back(pConnection->m_iID);

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+68]
	test	ecx, ecx
	jne	SHORT $LN122@GetTradePl
	xor	eax, eax
	jmp	SHORT $LN123@GetTradePl
$LN122@GetTradePl:
	mov	eax, DWORD PTR _aiTradeConnectionIDs$[esp+76]
	sub	eax, ecx
	sar	eax, 2
$LN123@GetTradePl:
	mov	edx, ebp
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN115@GetTradePl
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax
	add	ebp, 4
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+72], ebp
	jmp	SHORT $LN169@GetTradePl
$LN115@GetTradePl:
	push	esi
	push	1
	push	ebp
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+76]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebp, DWORD PTR _aiTradeConnectionIDs$[esp+72]
	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+68]
$LN169@GetTradePl:

; 3727 : 				if (bFailAtFirstFound)

	cmp	BYTE PTR _bFailAtFirstFound$[esp+60], 0
	jne	SHORT $LN192@GetTradePl
$LN5@GetTradePl:

; 3712 : 		{
; 3713 : 			continue;
; 3714 : 		}
; 3715 : 
; 3716 : #ifdef AUI_ITERATORIZE
; 3717 : 		for (TradeConnectionPlotList::const_iterator it = pConnection->m_aPlotList.begin(); it != pConnection->m_aPlotList.end(); ++it)
; 3718 : 		{
; 3719 : 			if (it->m_iX == iX && it->m_iY == iY)
; 3720 : #else
; 3721 : 		for (uint ui = 0; ui < pConnection->m_aPlotList.size(); ui++)

	inc	edi
	cmp	edi, DWORD PTR [esi+48]
	jb	SHORT $LL6@GetTradePl
$LN187@GetTradePl:

; 3728 : 				{
; 3729 : 					break;
; 3730 : 				}
; 3731 : 			}
; 3732 : 		}
; 3733 : 
; 3734 : 		if (bFailAtFirstFound && aiTradeConnectionIDs.size() > 0)

	cmp	BYTE PTR _bFailAtFirstFound$[esp+60], 0
	je	SHORT $LN200@GetTradePl
	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+68]
$LN192@GetTradePl:
	mov	edx, ebp
	sub	edx, ecx
	sar	edx, 2
	test	edx, edx
	ja	SHORT $LN206@GetTradePl
$LN200@GetTradePl:
	mov	edi, DWORD PTR _pTrade$[esp+64]
$LN12@GetTradePl:

; 3680 : #ifdef AUI_ITERATORIZE
; 3681 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3682 : 	{
; 3683 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3684 : #else
; 3685 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	eax, DWORD PTR _uiConnection$222158[esp+64]
	mov	esi, DWORD PTR tv856[esp+64]
	inc	eax
	add	esi, 444				; 000001bcH
	mov	DWORD PTR _uiConnection$222158[esp+64], eax
	mov	DWORD PTR tv856[esp+64], esi
	cmp	eax, DWORD PTR [edi+4]
	jb	$LL204@GetTradePl
$LN206@GetTradePl:
	pop	ebx
$LN201@GetTradePl:

; 3735 : 		{
; 3736 : 			break;
; 3737 : 		}
; 3738 : 	}
; 3739 : 
; 3740 : 	return aiTradeConnectionIDs;	

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+56]
	lea	eax, DWORD PTR _aiTradeConnectionIDs$[esp+60]
	push	eax
	mov	ecx, esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _aiTradeConnectionIDs$[esp+64]
	pop	edi
	test	eax, eax
	je	SHORT $LN182@GetTradePl
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN182@GetTradePl:

; 3741 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ENDP ; CvPlayerTrade::GetTradePlotsAtPlot
PUBLIC	?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z
_TEXT	SEGMENT
$T253082 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z PROC ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot, COMDAT
; _this$ = ecx

; 3749 : {

	push	ecx

; 3750 : 	return GetTradeUnitsAtPlot(pPlot, bFailAtFirstFound, true, false);

	mov	eax, DWORD PTR _bFailAtFirstFound$[esp]
	mov	edx, DWORD PTR _pPlot$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	0
	push	1
	push	eax
	push	edx
	push	esi
	mov	DWORD PTR $T253082[esp+28], 0
	call	?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradeUnitsAtPlot
	mov	eax, esi
	pop	esi

; 3751 : }

	pop	ecx
	ret	12					; 0000000cH
?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ENDP ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot
_TEXT	ENDS
PUBLIC	?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsOpposingPlayerTradeUnit
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1
__ehfuncinfo$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
_aiTradeConnectionIDs$ = -44				; size = 16
$T253087 = -28						; size = 16
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z PROC ; CvPlayerTrade::ContainsOpposingPlayerTradeUnit, COMDAT
; _this$ = ecx

; 3759 : {

	push	-1
	push	__ehhandler$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi

; 3760 : 	std::vector<int> aiTradeConnectionIDs;

	xor	esi, esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+52], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+56], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+60], esi

; 3761 : 	aiTradeConnectionIDs = GetOpposingTradeUnitsAtPlot(pPlot, true);

	mov	eax, DWORD PTR _pPlot$[esp+44]
	push	1
	push	eax
	lea	edx, DWORD PTR $T253087[esp+56]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+68], esi
	call	?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+52]
	mov	BYTE PTR __$EHRec$[esp+60], 1
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	eax, DWORD PTR $T253087[esp+52]
	cmp	eax, esi
	je	SHORT $LN49@ContainsOp
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@ContainsOp:

; 3762 : 	if (aiTradeConnectionIDs.size() > 0)

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+56]
	mov	eax, DWORD PTR _aiTradeConnectionIDs$[esp+52]
	sub	ecx, eax
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN2@ContainsOp

; 3763 : 	{
; 3764 : 		return true;

	cmp	eax, esi
	je	SHORT $LN58@ContainsOp
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@ContainsOp:
	mov	al, 1
	pop	esi

; 3769 : 	}
; 3770 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN2@ContainsOp:

; 3765 : 	}
; 3766 : 	else
; 3767 : 	{
; 3768 : 		return false;

	cmp	eax, esi
	je	SHORT $LN65@ContainsOp
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@ContainsOp:

; 3769 : 	}
; 3770 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	xor	al, al
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T253087[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ENDP ; CvPlayerTrade::ContainsOpposingPlayerTradeUnit
PUBLIC	?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z
_TEXT	SEGMENT
$T253300 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z PROC ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot, COMDAT
; _this$ = ecx

; 3778 : {

	push	ecx

; 3779 : 	return GetTradeUnitsAtPlot(pPlot, bFailAtFirstFound, true, true);

	mov	eax, DWORD PTR _bFailAtFirstFound$[esp]
	mov	edx, DWORD PTR _pPlot$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	1
	push	1
	push	eax
	push	edx
	push	esi
	mov	DWORD PTR $T253300[esp+28], 0
	call	?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradeUnitsAtPlot
	mov	eax, esi
	pop	esi

; 3780 : }

	pop	ecx
	ret	12					; 0000000cH
?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ENDP ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot
_TEXT	ENDS
PUBLIC	?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsEnemyTradeUnit
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1
__ehfuncinfo$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
_aiTradeConnectionIDs$ = -44				; size = 16
$T253305 = -28						; size = 16
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z PROC ; CvPlayerTrade::ContainsEnemyTradeUnit, COMDAT
; _this$ = ecx

; 3788 : {

	push	-1
	push	__ehhandler$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi

; 3789 : 	std::vector<int> aiTradeConnectionIDs;

	xor	esi, esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+52], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+56], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+60], esi

; 3790 : 	aiTradeConnectionIDs = GetEnemyTradeUnitsAtPlot(pPlot, true);

	mov	eax, DWORD PTR _pPlot$[esp+44]
	push	1
	push	eax
	lea	edx, DWORD PTR $T253305[esp+56]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+68], esi
	call	?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+52]
	mov	BYTE PTR __$EHRec$[esp+60], 1
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	eax, DWORD PTR $T253305[esp+52]
	cmp	eax, esi
	je	SHORT $LN49@ContainsEn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@ContainsEn:

; 3791 : 	if (aiTradeConnectionIDs.size() > 0)

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+56]
	mov	eax, DWORD PTR _aiTradeConnectionIDs$[esp+52]
	sub	ecx, eax
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN2@ContainsEn

; 3792 : 	{
; 3793 : 		return true;

	cmp	eax, esi
	je	SHORT $LN58@ContainsEn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@ContainsEn:
	mov	al, 1
	pop	esi

; 3798 : 	}
; 3799 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN2@ContainsEn:

; 3794 : 	}
; 3795 : 	else
; 3796 : 	{
; 3797 : 		return false;

	cmp	eax, esi
	je	SHORT $LN65@ContainsEn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@ContainsEn:

; 3798 : 	}
; 3799 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	xor	al, al
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T253305[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ENDP ; CvPlayerTrade::ContainsEnemyTradeUnit
PUBLIC	?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradePlotsAtPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z
_TEXT	SEGMENT
$T253518 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z PROC ; CvPlayerTrade::GetEnemyTradePlotsAtPlot, COMDAT
; _this$ = ecx

; 3807 : {

	push	ecx

; 3808 : 	return GetTradePlotsAtPlot(pPlot, bFailAtFirstFound, true, true);

	mov	eax, DWORD PTR _bFailAtFirstFound$[esp]
	mov	edx, DWORD PTR _pPlot$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	1
	push	1
	push	eax
	push	edx
	push	esi
	mov	DWORD PTR $T253518[esp+28], 0
	call	?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradePlotsAtPlot
	mov	eax, esi
	pop	esi

; 3809 : }

	pop	ecx
	ret	12					; 0000000cH
?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ENDP ; CvPlayerTrade::GetEnemyTradePlotsAtPlot
_TEXT	ENDS
PUBLIC	?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsEnemyTradePlot
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1
__ehfuncinfo$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
_aiTradeConnectionIDs$ = -44				; size = 16
$T253523 = -28						; size = 16
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z PROC ; CvPlayerTrade::ContainsEnemyTradePlot, COMDAT
; _this$ = ecx

; 3817 : {

	push	-1
	push	__ehhandler$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi

; 3818 : 	std::vector<int> aiTradeConnectionIDs;

	xor	esi, esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+52], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+56], esi
	mov	DWORD PTR _aiTradeConnectionIDs$[esp+60], esi

; 3819 : 	aiTradeConnectionIDs = GetEnemyTradePlotsAtPlot(pPlot, true);

	mov	eax, DWORD PTR _pPlot$[esp+44]
	push	1
	push	eax
	lea	edx, DWORD PTR $T253523[esp+56]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+68], esi
	call	?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradePlotsAtPlot
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+52]
	mov	BYTE PTR __$EHRec$[esp+60], 1
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	eax, DWORD PTR $T253523[esp+52]
	cmp	eax, esi
	je	SHORT $LN49@ContainsEn@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@ContainsEn@2:

; 3820 : 	if (aiTradeConnectionIDs.size() > 0)

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[esp+56]
	mov	eax, DWORD PTR _aiTradeConnectionIDs$[esp+52]
	sub	ecx, eax
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN2@ContainsEn@2

; 3821 : 	{
; 3822 : 		return true;

	cmp	eax, esi
	je	SHORT $LN58@ContainsEn@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@ContainsEn@2:
	mov	al, 1
	pop	esi

; 3827 : 	}
; 3828 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN2@ContainsEn@2:

; 3823 : 	}
; 3824 : 	else
; 3825 : 	{
; 3826 : 		return false;

	cmp	eax, esi
	je	SHORT $LN65@ContainsEn@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@ContainsEn@2:

; 3827 : 	}
; 3828 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	xor	al, al
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T253523[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ENDP ; CvPlayerTrade::ContainsEnemyTradePlot
PUBLIC	?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z ; CvPlayerTrade::AddTradeConnectionWasPlundered
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$1
__ehfuncinfo$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
_TEXT	SEGMENT
_kWasPlundered$222567 = -460				; size = 448
__$EHRec$ = -12						; size = 12
_kTradeConnection$ = 8					; size = 444
?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z PROC ; CvPlayerTrade::AddTradeConnectionWasPlundered, COMDAT
; _this$ = ecx

; 4409 : {

	push	-1
	push	__ehhandler$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 448				; 000001c0H
	push	ebp
	push	esi
	push	edi

; 4410 : 	bool bAdded = false;
; 4411 : #ifdef AUI_ITERATORIZE
; 4412 : 	for (TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4413 : 	{
; 4414 : 		if (it->m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4415 : 			it->m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4416 : 			it->m_kTradeConnection.m_iDestX == kTradeConnection.m_iDestX &&
; 4417 : 			it->m_kTradeConnection.m_iDestY == kTradeConnection.m_iDestY)
; 4418 : 		{
; 4419 : 			it->m_iTurnPlundered = GC.getGame().getGameTurn();
; 4420 : #else
; 4421 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	mov	esi, DWORD PTR [ecx+74612]
	xor	edx, edx
	mov	DWORD PTR __$EHRec$[esp+480], 0
	test	esi, esi
	jbe	SHORT $LN90@AddTradeCo
	mov	edi, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edi+8]
	npad	2
$LL5@AddTradeCo:

; 4422 : 	{
; 4423 : 		if (m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4424 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4425 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestX   == kTradeConnection.m_iDestX &&
; 4426 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestY   == kTradeConnection.m_iDestY)

	mov	ebp, DWORD PTR [eax-4]
	cmp	ebp, DWORD PTR _kTradeConnection$[esp+472]
	jne	SHORT $LN4@AddTradeCo
	mov	ebp, DWORD PTR _kTradeConnection$[esp+476]
	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN4@AddTradeCo
	mov	ebp, DWORD PTR _kTradeConnection$[esp+480]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN4@AddTradeCo
	mov	ebp, DWORD PTR _kTradeConnection$[esp+484]
	cmp	DWORD PTR [eax+8], ebp
	je	$LN86@AddTradeCo
$LN4@AddTradeCo:

; 4410 : 	bool bAdded = false;
; 4411 : #ifdef AUI_ITERATORIZE
; 4412 : 	for (TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4413 : 	{
; 4414 : 		if (it->m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4415 : 			it->m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4416 : 			it->m_kTradeConnection.m_iDestX == kTradeConnection.m_iDestX &&
; 4417 : 			it->m_kTradeConnection.m_iDestY == kTradeConnection.m_iDestY)
; 4418 : 		{
; 4419 : 			it->m_iTurnPlundered = GC.getGame().getGameTurn();
; 4420 : #else
; 4421 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	inc	edx
	add	eax, 448				; 000001c0H
	cmp	edx, esi
	jb	SHORT $LL5@AddTradeCo
$LN90@AddTradeCo:

; 4436 : 	{
; 4437 : 		TradeConnectionWasPlundered kWasPlundered;

	lea	eax, DWORD PTR _kWasPlundered$222567[esp+528]
	mov	DWORD PTR _kWasPlundered$222567[esp+520], 0
	mov	DWORD PTR _kWasPlundered$222567[esp+524], 40 ; 00000028H
	mov	DWORD PTR _kWasPlundered$222567[esp+516], eax

; 4438 : #ifdef AUI_ITERATORIZE
; 4439 : 		m_aTradeConnectionWasPlundered.push_back(kWasPlundered);
; 4440 : 		const TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.end() - 1;
; 4441 : 		it->m_kTradeConnection = kTradeConnection;
; 4442 : 		it->m_iTurnPlundered = GC.getGame().getGameTurn();
; 4443 : #else
; 4444 : 		uint uiIndex = m_aTradeConnectionWasPlundered.size();
; 4445 : 		m_aTradeConnectionWasPlundered.push_back(kWasPlundered);

	lea	edi, DWORD PTR [ecx+74608]
	lea	ecx, DWORD PTR _kWasPlundered$222567[esp+472]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+484], 1
	call	?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back

; 4446 : 		m_aTradeConnectionWasPlundered[uiIndex].m_kTradeConnection = kTradeConnection;

	imul	esi, 448				; 000001c0H
	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR _kTradeConnection$[esp+468]
	push	edx
	add	ecx, esi
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 4447 : 		m_aTradeConnectionWasPlundered[uiIndex].m_iTurnPlundered = GC.getGame().getGameTurn();

	mov	edi, DWORD PTR [edi]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	edi, esi
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [edi+444], eax

; 4448 : #endif
; 4449 : 	}

	mov	eax, DWORD PTR _kWasPlundered$222567[esp+516]
	lea	ecx, DWORD PTR _kWasPlundered$222567[esp+528]
	mov	BYTE PTR __$EHRec$[esp+480], 0
	cmp	eax, ecx
	je	SHORT $LN54@AddTradeCo
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN54@AddTradeCo:

; 4450 : }

	mov	eax, DWORD PTR _kTradeConnection$[esp+512]
	pop	edi
	lea	edx, DWORD PTR _kTradeConnection$[esp+520]
	pop	esi
	mov	DWORD PTR __$EHRec$[esp+472], -1
	pop	ebp
	cmp	eax, edx
	je	SHORT $LN71@AddTradeCo
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN71@AddTradeCo:
	mov	ecx, DWORD PTR __$EHRec$[esp+460]
	mov	DWORD PTR fs:0, ecx
	add	esp, 460				; 000001ccH
	ret	444					; 000001bcH
$LN86@AddTradeCo:

; 4427 : 		{
; 4428 : 			m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	imul	edx, 448				; 000001c0H
	add	edx, edi
	mov	esi, edx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [esi+444], eax

; 4429 : #endif
; 4430 : 			bAdded = true;
; 4431 : 			break;
; 4432 : 		}
; 4433 : 	}
; 4434 : 
; 4435 : 	if (!bAdded)

	jmp	SHORT $LN54@AddTradeCo
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$0:
	lea	ecx, DWORD PTR _kTradeConnection$[ebp-4]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$1:
	lea	ecx, DWORD PTR _kWasPlundered$222567[ebp]
	jmp	??1TradeConnectionWasPlundered@@QAE@XZ
__ehhandler$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z ENDP ; CvPlayerTrade::AddTradeConnectionWasPlundered
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z	; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$1
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
_TEXT	SEGMENT
_i$222770 = -932					; size = 4
_iNum$222756 = -932					; size = 4
_iNum$222769 = -928					; size = 4
_i$222757 = -928					; size = 4
_iEmptyInt$222767 = -924				; size = 4
_iConnectionType$222764 = -924				; size = 4
_uiVersion$ = -920					; size = 4
_iDomain$222775 = -916					; size = 4
_iConnectionType$222777 = -912				; size = 4
_iDomain$222762 = -908					; size = 4
_kTradeConnection$222761 = -904				; size = 444
_kTradeConnectionWasPlundered$222774 = -460		; size = 448
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z PROC	; operator>>, COMDAT

; 4742 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 920				; 00000398H
	push	ebx
	push	ebp
	push	esi

; 4743 : 	uint uiVersion;
; 4744 : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+940]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+948]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4745 : 
; 4746 : 	if (uiVersion >= 1) 

	mov	edi, DWORD PTR _writeTo$[esp+944]
	xor	ebp, ebp
	cmp	DWORD PTR _uiVersion$[esp+948], 1
	jb	$LN9@operator@18

; 4749 : 		loadFrom >> iNum;

	lea	ecx, DWORD PTR _iNum$222756[esp+948]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _iNum$222756[esp+952], ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4750 : 		for (int i = 0; i < iNum; i++)

	cmp	DWORD PTR _iNum$222756[esp+948], ebp
	mov	DWORD PTR _i$222757[esp+948], ebp
	jle	$LN102@operator@18

; 4747 : 	{
; 4748 : 		int iNum = 0;

	xor	ebx, ebx
	npad	10
$LL8@operator@18:

; 4751 : 		{
; 4752 : 			TradeConnection kTradeConnection;

	lea	edx, DWORD PTR _kTradeConnection$222761[esp+1004]
	mov	DWORD PTR _kTradeConnection$222761[esp+996], ebp
	mov	DWORD PTR _kTradeConnection$222761[esp+1000], 40 ; 00000028H
	mov	DWORD PTR _kTradeConnection$222761[esp+992], edx

; 4753 : 			writeTo.m_aRecentlyExpiredConnections.push_back(kTradeConnection);

	lea	eax, DWORD PTR _kTradeConnection$222761[esp+948]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+960], ebp
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 4754 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iID;

	mov	eax, DWORD PTR [edi]
	add	eax, ebx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4755 : 
; 4756 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iOriginX;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4757 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iOriginY;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+8]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4758 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iDestX;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4759 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iDestY;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+16]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4760 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_eOriginOwner;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+20]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 4761 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_eDestOwner;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [ecx+ebx+24]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 4762 : 			int iDomain;
; 4763 : 			loadFrom >> iDomain;

	lea	eax, DWORD PTR _iDomain$222762[esp+948]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4764 : 			writeTo.m_aRecentlyExpiredConnections[i].m_eDomain = (DomainTypes)iDomain;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iDomain$222762[esp+948]

; 4765 : 			int iConnectionType;
; 4766 : 			loadFrom >> iConnectionType;

	lea	eax, DWORD PTR _iConnectionType$222764[esp+948]
	mov	DWORD PTR [ecx+ebx+28], edx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4767 : 			writeTo.m_aRecentlyExpiredConnections[i].m_eConnectionType = (TradeConnectionType)iConnectionType;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iConnectionType$222764[esp+948]
	mov	DWORD PTR [ecx+ebx+32], edx

; 4768 : 
; 4769 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iTradeUnitLocationIndex;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4770 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_bTradeUnitMovingForward;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+40]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 4771 : 
; 4772 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_unitID;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+380]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4773 : 
; 4774 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iCircuitsCompleted;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+384]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4775 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iCircuitsToComplete;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+388]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4776 : 
; 4777 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iTurnRouteComplete;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+392]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4778 : 		}

	mov	eax, DWORD PTR _kTradeConnection$222761[esp+992]
	lea	ecx, DWORD PTR _kTradeConnection$222761[esp+1004]
	mov	DWORD PTR __$EHRec$[esp+956], -1
	cmp	eax, ecx
	je	SHORT $LN7@operator@18
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN7@operator@18:
	mov	eax, DWORD PTR _i$222757[esp+948]
	inc	eax
	add	ebx, 444				; 000001bcH
	cmp	eax, DWORD PTR _iNum$222756[esp+948]
	mov	DWORD PTR _i$222757[esp+948], eax
	jl	$LL8@operator@18

; 4779 : 	}
; 4780 : 	else

	jmp	SHORT $LN102@operator@18
$LN9@operator@18:

; 4781 : 	{
; 4782 : 		int iEmptyInt;
; 4783 : 		loadFrom >> iEmptyInt;

	lea	edx, DWORD PTR _iEmptyInt$222767[esp+948]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN102@operator@18:

; 4784 : 	}
; 4785 : 
; 4786 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+948], 2
	jb	$LN205@operator@18

; 4787 : 	{
; 4788 : 		int iNum = 0;
; 4789 : 		loadFrom >> iNum;

	lea	eax, DWORD PTR _iNum$222769[esp+948]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _iNum$222769[esp+952], ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4790 : 		for (int i = 0; i < iNum; i++)

	cmp	DWORD PTR _iNum$222769[esp+948], ebp
	mov	DWORD PTR _i$222770[esp+948], ebp
	jle	$LN205@operator@18
	add	edi, 74608				; 00012370H
	xor	ebx, ebx
	npad	4
$LL3@operator@18:

; 4791 : 		{
; 4792 : 			TradeConnectionWasPlundered kTradeConnectionWasPlundered;

	lea	ecx, DWORD PTR _kTradeConnectionWasPlundered$222774[esp+1004]
	mov	DWORD PTR _kTradeConnectionWasPlundered$222774[esp+996], ebp
	mov	DWORD PTR _kTradeConnectionWasPlundered$222774[esp+1000], 40 ; 00000028H
	mov	DWORD PTR _kTradeConnectionWasPlundered$222774[esp+992], ecx

; 4793 : 			writeTo.m_aTradeConnectionWasPlundered.push_back(kTradeConnectionWasPlundered);

	lea	edx, DWORD PTR _kTradeConnectionWasPlundered$222774[esp+948]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+960], 1
	call	?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back

; 4794 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_iTurnPlundered;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+444]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4795 : 
; 4796 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iOriginX;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4797 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iOriginY;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+8]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4798 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iDestX;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4799 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iDestY;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+16]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4800 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eOriginOwner;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+20]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 4801 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eDestOwner;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [ecx+ebx+24]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 4802 : 			int iDomain;
; 4803 : 			loadFrom >> iDomain;

	lea	eax, DWORD PTR _iDomain$222775[esp+948]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4804 : 			writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eDomain = (DomainTypes)iDomain;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iDomain$222775[esp+948]

; 4805 : 			int iConnectionType;
; 4806 : 			loadFrom >> iConnectionType;

	lea	eax, DWORD PTR _iConnectionType$222777[esp+948]
	mov	DWORD PTR [ecx+ebx+28], edx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4807 : 			writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eConnectionType = (TradeConnectionType)iConnectionType;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iConnectionType$222777[esp+948]
	mov	DWORD PTR [ecx+ebx+32], edx

; 4808 : 
; 4809 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iTradeUnitLocationIndex;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4810 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_bTradeUnitMovingForward;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+40]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 4811 : 
; 4812 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_unitID;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+380]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4813 : 
; 4814 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iCircuitsCompleted;

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx+384]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4815 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iCircuitsToComplete;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+ebx+388]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4816 : 
; 4817 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iTurnRouteComplete;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx+392]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4818 : 		}

	mov	eax, DWORD PTR _kTradeConnectionWasPlundered$222774[esp+992]
	lea	ecx, DWORD PTR _kTradeConnectionWasPlundered$222774[esp+1004]
	mov	DWORD PTR __$EHRec$[esp+956], -1
	cmp	eax, ecx
	je	SHORT $LN2@operator@18
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN2@operator@18:
	mov	eax, DWORD PTR _i$222770[esp+948]
	inc	eax
	add	ebx, 448				; 000001c0H
	cmp	eax, DWORD PTR _iNum$222769[esp+948]
	mov	DWORD PTR _i$222770[esp+948], eax
	jl	$LL3@operator@18
$LN205@operator@18:

; 4819 : 	}
; 4820 : 
; 4821 : 	return loadFrom;
; 4822 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+948]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 932				; 000003a4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$0:
	lea	ecx, DWORD PTR _kTradeConnection$222761[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$1:
	lea	ecx, DWORD PTR _kTradeConnectionWasPlundered$222774[ebp]
	jmp	??1TradeConnectionWasPlundered@@QAE@XZ
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z ENDP	; operator>>
PUBLIC	?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::GetAvailableTR
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$3
__ehfuncinfo$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_bCheckPath$222855 = -485				; size = 1
tv755 = -484						; size = 4
_iDestCityLoop$222842 = -480				; size = 4
_iOriginCityLoop$ = -476				; size = 4
_this$ = -472						; size = 4
_pPlayerTrade$ = -468					; size = 4
_pGameTrade$ = -464					; size = 4
$T254640 = -460						; size = 4
_kConnection$222866 = -456				; size = 444
__$EHRec$ = -12						; size = 12
_aTradeConnectionList$ = 8				; size = 4
?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z PROC ; CvTradeAI::GetAvailableTR, COMDAT
; _this$ = ecx

; 4963 : {

	push	-1
	push	__ehhandler$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 476				; 000001dcH
	push	ebp
	push	esi

; 4964 : 	aTradeConnectionList.clear();

	mov	esi, DWORD PTR _aTradeConnectionList$[esp+492]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+508], edi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	mov	DWORD PTR [esi+4], 0

; 4965 : 
; 4966 : 	// build trade route list
; 4967 : 	CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();

	mov	ecx, DWORD PTR [edi+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade

; 4968 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _pPlayerTrade$[esp+500], eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 4969 : 	int iOriginCityLoop;
; 4970 : 	CvCity* pOriginCity = NULL;
; 4971 : 	for (pOriginCity = m_pPlayer->firstCity(&iOriginCityLoop); pOriginCity != NULL; pOriginCity = m_pPlayer->nextCity(&iOriginCityLoop))

	mov	ecx, DWORD PTR [edi+4]
	push	0
	lea	edx, DWORD PTR _iOriginCityLoop$[esp+504]
	push	edx
	mov	DWORD PTR _pGameTrade$[esp+508], eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN24@GetAvailab
	push	ebx
$LL149@GetAvailab:

; 4972 : 	{
; 4973 : 		PlayerTypes eOtherPlayer = NO_PLAYER;
; 4974 : 		for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	xor	ebx, ebx
	mov	DWORD PTR tv755[esp+504], ebx
	npad	5
$LL23@GetAvailab:

; 4975 : 		{
; 4976 : 			eOtherPlayer = (PlayerTypes)ui;
; 4977 : 
; 4978 : 			if (!GET_PLAYER(eOtherPlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	ecx, DWORD PTR [ebx+eax]
	je	$LN22@GetAvailab

; 4979 : 			{
; 4980 : 				continue;
; 4981 : 			}
; 4982 : 
; 4983 : 			if (GET_PLAYER(eOtherPlayer).isBarbarian())

	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN22@GetAvailab

; 4984 : 			{
; 4985 : 				continue;
; 4986 : 			}
; 4987 : 
; 4988 : 			int iDestCityLoop;
; 4989 : 			CvCity* pDestCity = NULL;
; 4990 : 			for (pDestCity = GET_PLAYER(eOtherPlayer).firstCity(&iDestCityLoop); pDestCity != NULL; pDestCity = GET_PLAYER(eOtherPlayer).nextCity(&iDestCityLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iDestCityLoop$222842[esp+508]
	add	ecx, ebx
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN22@GetAvailab
$LL18@GetAvailab:

; 4991 : 			{
; 4992 : 				// if this is the same city
; 4993 : 				if (pOriginCity == pDestCity)

	cmp	ebp, esi
	je	$LN17@GetAvailab

; 4994 : 				{
; 4995 : 					continue;
; 4996 : 				}
; 4997 : 
; 4998 : 				DomainTypes eDomain = NO_DOMAIN;
; 4999 : 				for (eDomain = (DomainTypes)0; eDomain < NUM_DOMAIN_TYPES; eDomain = (DomainTypes)(eDomain + 1))

	xor	edi, edi
	npad	5
$LL14@GetAvailab:

; 5000 : 				{
; 5001 : 					// if this isn't a valid trade domain, ignore
; 5002 : 					if (eDomain != DOMAIN_LAND && eDomain != DOMAIN_SEA)

	cmp	edi, 2
	je	SHORT $LN148@GetAvailab
	test	edi, edi
	jne	$LN13@GetAvailab
$LN148@GetAvailab:

; 5003 : 					{
; 5004 : 						continue;
; 5005 : 					}
; 5006 : 
; 5007 : 					bool bCheckPath = true;

	mov	BYTE PTR _bCheckPath$222855[esp+504], 1

; 5008 : 					TradeConnectionType eConnection = NUM_TRADE_CONNECTION_TYPES;
; 5009 : 					for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	xor	ebx, ebx
$LL10@GetAvailab:

; 5010 : 					{
; 5011 : 						eConnection = (TradeConnectionType)uiConnectionTypes;
; 5012 : 
; 5013 : 						// Check the trade route, ignoring the path for now
; 5014 : 						bool bTradeAvailable = pPlayerTrade->CanCreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnection, true, false);

	mov	ecx, DWORD PTR _pPlayerTrade$[esp+504]
	push	0
	push	1
	push	ebx
	push	edi
	push	esi
	push	ebp
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute

; 5015 : 						if (!bTradeAvailable)

	test	al, al
	je	$LN9@GetAvailab

; 5016 : 						{
; 5017 : 							continue;
; 5018 : 						}
; 5019 : 
; 5020 : 						// Now test the path
; 5021 : 						if (bCheckPath)

	cmp	BYTE PTR _bCheckPath$222855[esp+504], 0
	je	SHORT $LN6@GetAvailab

; 5022 : 						{
; 5023 : 							bTradeAvailable = pGameTrade->IsValidTradeRoutePath(pOriginCity, pDestCity, eDomain);

	mov	ecx, DWORD PTR _pGameTrade$[esp+504]
	push	edi
	push	esi
	push	ebp
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath

; 5024 : 							if (!bTradeAvailable)

	test	al, al
	je	$LN147@GetAvailab

; 5025 : 								break;		// If there is no path for this domain, just skip the rest of the connection tests.
; 5026 : 
; 5027 : 							bCheckPath = false;		// No need to check the path for this domain again

	mov	BYTE PTR _bCheckPath$222855[esp+504], 0
$LN6@GetAvailab:

; 5028 : 						}
; 5029 : 
; 5030 : 						TradeConnection kConnection;

	xor	ecx, ecx
	lea	eax, DWORD PTR _kConnection$222866[esp+560]
	mov	DWORD PTR _kConnection$222866[esp+552], ecx
	mov	DWORD PTR _kConnection$222866[esp+556], 40 ; 00000028H
	mov	DWORD PTR _kConnection$222866[esp+548], eax

; 5031 : 						kConnection.m_iOriginX = pOriginCity->getX();

	mov	edx, DWORD PTR [ebp+96]
	mov	DWORD PTR _kConnection$222866[esp+508], edx

; 5032 : 						kConnection.m_iOriginY = pOriginCity->getY();

	mov	edx, DWORD PTR [ebp+108]
	mov	DWORD PTR _kConnection$222866[esp+512], edx

; 5033 : 						kConnection.m_iDestX = pDestCity->getX();

	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR _kConnection$222866[esp+516], edx

; 5034 : 						kConnection.m_iDestY = pDestCity->getY();

	mov	edx, DWORD PTR [esi+108]
	mov	DWORD PTR _kConnection$222866[esp+520], edx

; 5035 : 						kConnection.m_eConnectionType = eConnection;
; 5036 : 						kConnection.m_eDomain = eDomain;
; 5037 : 						kConnection.m_eOriginOwner = pOriginCity->getOwner();

	mov	edx, DWORD PTR [ebp+84]
	mov	DWORD PTR _kConnection$222866[esp+524], edx

; 5038 : 						kConnection.m_eDestOwner = pDestCity->getOwner();

	mov	edx, DWORD PTR [esi+84]
	mov	DWORD PTR __$EHRec$[esp+512], ecx
	mov	DWORD PTR _kConnection$222866[esp+536], ebx
	mov	DWORD PTR _kConnection$222866[esp+532], edi
	mov	DWORD PTR _kConnection$222866[esp+528], edx

; 5039 : 
; 5040 : 						CvAStarNode* pNode = NULL;
; 5041 : 						if (eDomain ==  DOMAIN_LAND)

	cmp	edi, 2
	jne	SHORT $LN4@GetAvailab

; 5042 : 						{
; 5043 : 							pNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	jmp	SHORT $LN151@GetAvailab
$LN4@GetAvailab:

; 5044 : 						}
; 5045 : 						else if (eDomain == DOMAIN_SEA)

	cmp	edi, ecx
	jne	$LN144@GetAvailab

; 5046 : 						{
; 5047 : 							pNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
$LN151@GetAvailab:
	mov	eax, DWORD PTR [eax+96]

; 5048 : 						}
; 5049 : 
; 5050 : 						CvAssertMsg(pNode != NULL, "no path found for unit");
; 5051 : 						if (pNode == NULL)

	test	eax, eax

; 5052 : 						{
; 5053 : 							continue;

	je	SHORT $LN153@GetAvailab

; 5054 : 						}
; 5055 : 
; 5056 : 						GC.getGame().GetGameTrade()->CopyPathIntoTradeConnection(pNode, &kConnection);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	edx, DWORD PTR _kConnection$222866[esp+504]
	push	edx
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection

; 5057 : 						aTradeConnectionList.push_back(kConnection);

	mov	edx, DWORD PTR _aTradeConnectionList$[esp+500]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+74604], 0
	cmp	DWORD PTR [edx+4], eax
	jne	SHORT $LN104@GetAvailab
	push	eax
	mov	ecx, edx
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
	mov	edx, DWORD PTR _aTradeConnectionList$[esp+500]
$LN104@GetAvailab:
	mov	ecx, DWORD PTR [edx+4]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T254640[esp+504], ecx
	mov	BYTE PTR __$EHRec$[esp+512], 1
	je	SHORT $LN107@GetAvailab
	lea	eax, DWORD PTR _kConnection$222866[esp+504]
	push	eax
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	edx, DWORD PTR _aTradeConnectionList$[esp+500]
$LN107@GetAvailab:
	inc	DWORD PTR [edx+4]
$LN153@GetAvailab:

; 5058 : 					}

	mov	eax, DWORD PTR _kConnection$222866[esp+548]
$LN144@GetAvailab:
	lea	ecx, DWORD PTR _kConnection$222866[esp+560]
	mov	DWORD PTR __$EHRec$[esp+512], -1
	cmp	eax, ecx
	je	SHORT $LN9@GetAvailab
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN9@GetAvailab:
	inc	ebx
	cmp	ebx, 3
	jb	$LL10@GetAvailab
$LN147@GetAvailab:

; 5008 : 					TradeConnectionType eConnection = NUM_TRADE_CONNECTION_TYPES;
; 5009 : 					for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	mov	ebx, DWORD PTR tv755[esp+504]
$LN13@GetAvailab:

; 4994 : 				{
; 4995 : 					continue;
; 4996 : 				}
; 4997 : 
; 4998 : 				DomainTypes eDomain = NO_DOMAIN;
; 4999 : 				for (eDomain = (DomainTypes)0; eDomain < NUM_DOMAIN_TYPES; eDomain = (DomainTypes)(eDomain + 1))

	inc	edi
	cmp	edi, 5
	jl	$LL14@GetAvailab
$LN17@GetAvailab:

; 4984 : 			{
; 4985 : 				continue;
; 4986 : 			}
; 4987 : 
; 4988 : 			int iDestCityLoop;
; 4989 : 			CvCity* pDestCity = NULL;
; 4990 : 			for (pDestCity = GET_PLAYER(eOtherPlayer).firstCity(&iDestCityLoop); pDestCity != NULL; pDestCity = GET_PLAYER(eOtherPlayer).nextCity(&iDestCityLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iDestCityLoop$222842[esp+508]
	lea	ecx, DWORD PTR [ebx+edx]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL18@GetAvailab
$LN22@GetAvailab:

; 4972 : 	{
; 4973 : 		PlayerTypes eOtherPlayer = NO_PLAYER;
; 4974 : 		for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	add	ebx, 63236				; 0000f704H
	mov	DWORD PTR tv755[esp+504], ebx
	cmp	ebx, 3983868				; 003cc9fcH
	jb	$LL23@GetAvailab
	mov	edx, DWORD PTR _this$[esp+504]
	push	0
	lea	ecx, DWORD PTR _iOriginCityLoop$[esp+508]
	push	ecx
	mov	ecx, DWORD PTR [edx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL149@GetAvailab
	pop	ebx
$LN24@GetAvailab:

; 5059 : 				}
; 5060 : 			}
; 5061 : 		}
; 5062 : 	}
; 5063 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+500]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 488				; 000001e8H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0:
	lea	ecx, DWORD PTR _kConnection$222866[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$3:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T254640[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ENDP ; CvTradeAI::GetAvailableTR
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T254816 = 8						; size = 1
__Cat$254819 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _this$[ebp], esi
	call	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
	test	al, al
	je	SHORT $LN7@vector@7

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	mov	BYTE PTR $T254816[ebp], 0
	mov	edx, DWORD PTR $T254816[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$254819[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@7:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN38@vector@7:
$LN37@vector@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
PUBLIC	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU3@IABU3@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T254850 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$254853 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU3@IABU3@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$254853[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T254850[esp+12], 0
	mov	eax, DWORD PTR $T254850[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	imul	eax, 448				; 000001c0H
	add	esp, 24					; 00000018H
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU3@IABU3@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11
__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
_TEXT	SEGMENT
__Tmp$224407 = -92					; size = 28
__Tmp$224397 = -64					; size = 28
__Whereoff$224383 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$224384 = -28					; size = 4
__Newvec$224382 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$255063 = 8					; size = 1
__Cat$254995 = 8					; size = 1
__Where$ = 8						; size = 4
tv525 = 12						; size = 4
__Count$ = 12						; size = 4
$T255059 = 16						; size = 1
$T254992 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@4
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@4
$LN31@Insert_n@4:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@4

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 153391689				; 09249249H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN103@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 153391689				; 09249249H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	add	esp, 8
	mov	DWORD PTR __Ncopied$224384[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	lea	eax, DWORD PTR [ebx*8]
	mov	DWORD PTR __Newvec$224382[ebp], ecx
	sub	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$224383[ebp], ebx
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$254995[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T254992[ebp], 0
	mov	edx, DWORD PTR $T254992[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$224382[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224384[ebp], 1
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$224382[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T255059[ebp], 0
	mov	edx, DWORD PTR $T255059[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$255063[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$224384[ebp], 2
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN83@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Newvec$224382[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$224384[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$224383[ebp]
	mov	edi, DWORD PTR __Newvec$224382[ebp]
	jle	SHORT $LN7@Insert_n@4
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edx, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN104@Insert_n@4:
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224397[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224397[ebp]
	push	edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224397[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$224397[ebp]

; 1233 : 		else

	jmp	$LN102@Insert_n@4
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN105@Insert_n@4:
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224407[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224407[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$224407[ebp]
$LN102@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n@4:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN101@Insert_n@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224397[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224407[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
PUBLIC	?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$255125 = 12					; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Cat$255125[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+4]
	push	ecx
	push	edx
	call	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >
	add	esp, 16					; 00000010H

; 1120 : 		}

	ret	8
?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z
_TEXT	SEGMENT
$T255157 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$255161 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$255161[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T255157[esp+4], 0
	mov	eax, DWORD PTR $T255157[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T255174 = -32						; size = 20
$T255172 = -32						; size = 20
$T255170 = -32						; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T255169 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T255173 = 40						; size = 4
$T255171 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	-1
	push	__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ebp, DWORD PTR __Chunk$[esp+44]
	lea	eax, DWORD PTR [ebp+ebp]
	xor	esi, esi
	cmp	eax, DWORD PTR __Count$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], esi
	jg	$LN3@Chunked_me@2
	mov	ebx, ebp
	imul	ebx, 448				; 000001c0H
$LL5@Chunked_me@2:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);

	lea	ecx, DWORD PTR [ebx+eax]

; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+44]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T255169[esp+68], esp
	lea	edi, DWORD PTR [ebx+ecx]
	push	edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR __Dest$[esp+88]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255170[esp+88]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T255170[esp+92]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+60], edx
	cmp	eax, esi
	je	SHORT $LN72@Chunked_me@2
	cmp	eax, DWORD PTR $T255170[esp+56]
	je	SHORT $LN41@Chunked_me@2
	lea	esi, DWORD PTR [eax+44]
$LL43@Chunked_me@2:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN60@Chunked_me@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN60@Chunked_me@2:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, DWORD PTR $T255170[esp+56]
	jne	SHORT $LL43@Chunked_me@2
	mov	eax, DWORD PTR $T255170[esp+48]
	xor	esi, esi
$LN41@Chunked_me@2:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@Chunked_me@2:
	mov	edx, DWORD PTR __Count$[esp+44]
	lea	ecx, DWORD PTR [ebp+ebp]
	sub	edx, ecx
	cmp	edx, ecx

; 3443 : 		_First = _Mid2;

	mov	eax, edi
	mov	DWORD PTR __First$[esp+44], eax
	mov	DWORD PTR __Count$[esp+44], edx
	jge	$LL5@Chunked_me@2
$LN3@Chunked_me@2:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	DWORD PTR __Count$[esp+44], ebp
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	ecx, DWORD PTR __Dest$[esp+80]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+64]
	mov	eax, DWORD PTR __First$[esp+64]
	mov	DWORD PTR $T255171[esp+64], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T255172[esp+76]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	mov	eax, DWORD PTR $T255172[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	$LN156@Chunked_me@2
	cmp	eax, DWORD PTR $T255172[esp+56]
	je	$LN125@Chunked_me@2
	lea	esi, DWORD PTR [eax+44]
$LL80@Chunked_me@2:
	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+12]
	cmp	eax, edx
	je	SHORT $LN97@Chunked_me@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN97@Chunked_me@2:
	add	esi, 448				; 000001c0H
	lea	eax, DWORD PTR [esi-44]
	cmp	eax, DWORD PTR $T255172[esp+56]
	jne	SHORT $LL80@Chunked_me@2

; 3448 : 	else

	jmp	SHORT $LN211@Chunked_me@2
$LN2@Chunked_me@2:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+44]
	imul	ebp, 448				; 000001c0H
	push	edx
	sub	esp, 20					; 00000014H
	add	ebp, eax
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+68]
	mov	DWORD PTR $T255173[esp+68], esp
	push	eax
	mov	ecx, ebp
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+80]
	push	ecx
	lea	edx, DWORD PTR $T255174[esp+88]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
	mov	eax, DWORD PTR $T255174[esp+92]
	add	esp, 44					; 0000002cH
	cmp	eax, esi
	je	SHORT $LN156@Chunked_me@2
	cmp	eax, DWORD PTR $T255174[esp+56]
	je	SHORT $LN125@Chunked_me@2
	lea	esi, DWORD PTR [eax+44]
$LL127@Chunked_me@2:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN144@Chunked_me@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN144@Chunked_me@2:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, DWORD PTR $T255174[esp+56]
	jne	SHORT $LL127@Chunked_me@2
$LN211@Chunked_me@2:
	mov	eax, DWORD PTR $T255174[esp+48]
	xor	esi, esi
$LN125@Chunked_me@2:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN156@Chunked_me@2:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	cmp	eax, esi
	je	SHORT $LN189@Chunked_me@2
	cmp	eax, DWORD PTR __Dest$[esp+52]
	je	SHORT $LN158@Chunked_me@2
	lea	esi, DWORD PTR [eax+44]
$LL160@Chunked_me@2:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN177@Chunked_me@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN177@Chunked_me@2:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, DWORD PTR __Dest$[esp+52]
	jne	SHORT $LL160@Chunked_me@2
	mov	eax, DWORD PTR __Dest$[esp+44]
$LN158@Chunked_me@2:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN189@Chunked_me@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T256014 = -32						; size = 8
__Oldend$215544 = -24					; size = 8
$T256017 = -16						; size = 8
$T256015 = -16						; size = 8
$T256016 = -8						; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	sub	esp, 32					; 00000020H
	push	ebx

; 2297 : 		size_type _Off = _Where - begin();
; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Where$[esp+36]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	sub	ebp, eax
	sar	ebp, 2
	shl	ebp, 5
	add	ebp, DWORD PTR __Where$[esp+44]
	test	ebx, ebx
	je	$LN1@Insert_x

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	eax, DWORD PTR [esi]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN97@Insert_x:
$LN4@Insert_x:
	push	edi

; 2309 : 		else
; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	lea	edx, DWORD PTR [eax+ebx+31]
	push	0
	shr	edx, 5
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LN2@Insert_x
	pop	edi

; 2313 : 				_Mysize += _Count;

	mov	DWORD PTR [esi], ebx
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN2@Insert_x:

; 2314 : 			else
; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR __Oldend$215544[esp+48], ebx
	mov	DWORD PTR __Oldend$215544[esp+52], 0
	test	edi, edi
	jbe	SHORT $LN60@Insert_x
	push	edi
	lea	ecx, DWORD PTR __Oldend$215544[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN60@Insert_x:

; 2317 : 				_Mysize += _Count;

	mov	eax, DWORD PTR __Count$[esp+44]
	add	eax, edi
	mov	DWORD PTR [esi], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	DWORD PTR $T256014[esp+48], ebx
	mov	DWORD PTR $T256014[esp+52], 0
	je	SHORT $LN79@Insert_x
	push	eax
	lea	ecx, DWORD PTR $T256014[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN79@Insert_x:
	push	ebp
	lea	ecx, DWORD PTR $T256016[esp+52]
	push	ecx
	lea	ecx, DWORD PTR $T256015[esp+56]
	mov	DWORD PTR $T256015[esp+56], ebx
	mov	DWORD PTR $T256015[esp+60], 0
	call	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
	mov	edx, DWORD PTR $T256014[esp+52]
	mov	ecx, DWORD PTR $T256014[esp+48]
	push	edx
	mov	edx, DWORD PTR __Oldend$215544[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Oldend$215544[esp+56]
	push	edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T256017[esp+72]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
	pop	edi
$LN1@Insert_x:
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN96@Insert_x:
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z	; CvPlayerTrade::PlunderTradeRoute
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	?getNickName@CvPlayer@@QBEQBDXZ:PROC		; CvPlayer::getNickName
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z:PROC ; CvBarbarians::DoSpawnBarbarianUnit
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	_memset:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__ehfuncinfo$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$14
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$15
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
_TEXT	SEGMENT
_ui$256388 = -776					; size = 4
_pNotifications$222315 = -776				; size = 4
_iLoop$222308 = -776					; size = 4
_iPlunderGoldValue$ = -776				; size = 4
_this$ = -772						; size = 4
_pDestCity$ = -768					; size = 4
$T256321 = -768						; size = 4
$T256562 = -764						; size = 4
_pPlunderPlot$ = -764					; size = 4
_pOriginCity$ = -760					; size = 4
tv1209 = -756						; size = 4
$T256905 = -752						; size = 4
_pTrade$ = -752						; size = 4
tv1202 = -748						; size = 4
$T256984 = -744						; size = 4
_eOwningPlayer$ = -744					; size = 4
tv1223 = -740						; size = 4
$T256440 = -736						; size = 4
$T256413 = -732						; size = 4
_eDestPlayer$ = -728					; size = 4
_strMessage$222349 = -724				; size = 80
_strBuffer$222284 = -644				; size = 28
_strMessage$222318 = -616				; size = 80
_strSummary$222348 = -536				; size = 80
$T256333 = -536						; size = 80
$T256328 = -536						; size = 80
$T256325 = -536						; size = 80
$T256324 = -536						; size = 80
$T256323 = -456						; size = 28
$T256322 = -456						; size = 28
$T256342 = -428						; size = 80
$T256337 = -428						; size = 80
$T256336 = -428						; size = 80
_strSummary$222317 = -428				; size = 80
$T256349 = -348						; size = 80
_text$222276 = -268					; size = 256
__$EHRec$ = -12						; size = 12
_iTradeConnectionID$ = 8				; size = 4
?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z PROC		; CvPlayerTrade::PlunderTradeRoute, COMDAT
; _this$ = ecx

; 3832 : {

	push	-1
	push	__ehhandler$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 764				; 000002fcH
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+788], ecx

; 3833 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 3834 : 	int iTradeConnectionIndex = pTrade->GetIndexFromID(iTradeConnectionID);

	mov	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	mov	DWORD PTR _pTrade$[esp+792], eax
	test	ecx, ecx
	jbe	SHORT $LN373@PlunderTra
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR _iTradeConnectionID$[esp+788]
	mov	eax, edx
$LL59@PlunderTra:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN60@PlunderTra
	inc	esi
	add	eax, 444				; 000001bcH
	cmp	esi, ecx
	jb	SHORT $LL59@PlunderTra

; 3838 : 	{
; 3839 : 		return false;

	xor	al, al
	jmp	$LN36@PlunderTra

; 3834 : 	int iTradeConnectionIndex = pTrade->GetIndexFromID(iTradeConnectionID);

$LN60@PlunderTra:
	mov	DWORD PTR _ui$256388[esp+792], esi

; 3835 : 
; 3836 : 	CvAssertMsg(iTradeConnectionIndex >= 0, "iTradeConnectionIndex < 0");
; 3837 : 	if (iTradeConnectionIndex < 0)

	test	esi, esi
	jge	SHORT $LN35@PlunderTra
$LN373@PlunderTra:

; 3838 : 	{
; 3839 : 		return false;

	xor	al, al
	jmp	$LN36@PlunderTra
$LN35@PlunderTra:

; 3840 : 	}
; 3841 : 
; 3842 : 	TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[iTradeConnectionIndex]);
; 3843 : 	DomainTypes eDomain = pTradeConnection->m_eDomain;
; 3844 : 	PlayerTypes eOwningPlayer = pTradeConnection->m_eOriginOwner;
; 3845 : 	PlayerTypes eDestPlayer = pTradeConnection->m_eDestOwner;
; 3846 : 	TeamTypes eOwningTeam = GET_PLAYER(eOwningPlayer).getTeam();

	mov	edi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	imul	esi, 444				; 000001bcH
	mov	ebx, DWORD PTR [esi+edx+20]
	mov	eax, DWORD PTR [esi+edx+28]
	mov	ecx, DWORD PTR [esi+edx+24]
	add	esi, edx
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _eOwningPlayer$[esp+792], ebx
	imul	ebx, 63236				; 0000f704H
	mov	DWORD PTR tv1202[esp+792], eax
	mov	eax, DWORD PTR [ebx+edx+44]
	mov	DWORD PTR _eDestPlayer$[esp+792], ecx
	mov	DWORD PTR tv1209[esp+792], ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@PlunderTra
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	mov	DWORD PTR $T256413[esp+792], eax
	jmp	SHORT $LN75@PlunderTra
$LN74@PlunderTra:
	mov	DWORD PTR $T256413[esp+792], -1
$LN75@PlunderTra:

; 3847 : 	TeamTypes eDestTeam = GET_PLAYER(eDestPlayer).getTeam();

	mov	eax, ecx
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv1223[esp+792], eax
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN85@PlunderTra
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T256440[esp+792], edx
	jmp	SHORT $LN86@PlunderTra
$LN85@PlunderTra:
	mov	DWORD PTR $T256440[esp+792], -1
$LN86@PlunderTra:

; 3848 : 	CvPlot* pPlunderPlot = GC.getMap().plot(pTradeConnection->m_aPlotList[pTradeConnection->m_iTradeUnitLocationIndex].m_iX, pTradeConnection->m_aPlotList[pTradeConnection->m_iTradeUnitLocationIndex].m_iY);

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+36]
	mov	edi, DWORD PTR [ecx+eax*8]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256562[esp+792], ecx
	cmp	edi, -2147483647			; 80000001H
	je	$LN96@PlunderTra
	cmp	ecx, -2147483647			; 80000001H
	je	$LN96@PlunderTra
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN106@PlunderTra
	test	edi, edi
	jge	SHORT $LN108@PlunderTra
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN106@PlunderTra
$LN108@PlunderTra:
	cmp	edi, ecx
	jl	SHORT $LN106@PlunderTra
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN106@PlunderTra:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	mov	edx, DWORD PTR $T256562[esp+792]
	test	al, al
	je	SHORT $LN116@PlunderTra
	test	edx, edx
	jge	SHORT $LN118@PlunderTra
	mov	eax, edx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN116@PlunderTra
$LN118@PlunderTra:
	cmp	edx, ebp
	jl	SHORT $LN116@PlunderTra
	mov	eax, DWORD PTR $T256562[esp+792]
	cdq
	idiv	ebp
$LN116@PlunderTra:
	test	edi, edi
	jl	SHORT $LN96@PlunderTra
	cmp	edi, ecx
	jge	SHORT $LN96@PlunderTra
	test	edx, edx
	jl	SHORT $LN96@PlunderTra
	cmp	edx, ebp
	jge	SHORT $LN96@PlunderTra
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlunderPlot$[esp+792], ecx
	jmp	SHORT $LN98@PlunderTra
$LN96@PlunderTra:
	mov	DWORD PTR _pPlunderPlot$[esp+792], 0
$LN98@PlunderTra:

; 3849 : 	int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(*pTradeConnection, YIELD_GOLD);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	edi, DWORD PTR tv1202[esp+792]
	neg	edi
	sbb	edi, edi

; 3850 : 
; 3851 : 	// add trade connnection to broken list
; 3852 : 	GET_PLAYER(eOwningPlayer).GetTrade()->AddTradeConnectionWasPlundered(*pTradeConnection);

	sub	esp, 444				; 000001bcH
	mov	ecx, esp
	mov	DWORD PTR $T256321[esp+1236], esp
	and	edi, -100				; ffffff9cH
	push	esi
	add	edi, 100				; 00000064H
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebp, ebp
	lea	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR __$EHRec$[esp+1244], ebp
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+1244], -1
	call	?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z ; CvPlayerTrade::AddTradeConnectionWasPlundered

; 3853 : 
; 3854 : 	CvCity* pOriginCity = NULL;
; 3855 : 	CvCity* pDestCity = NULL;
; 3856 : 	CvPlot* pPlot = GC.getMap().plot(pTradeConnection->m_iOriginX, pTradeConnection->m_iOriginY);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _pOriginCity$[esp+792], ebp
	mov	DWORD PTR _pDestCity$[esp+792], ebp
	mov	ebp, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN383@PlunderTra
	cmp	ebp, -2147483647			; 80000001H
	je	$LN383@PlunderTra
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [edx+4056]
	mov	ecx, DWORD PTR [edx+4020]
	test	bl, bl
	je	SHORT $LN382@PlunderTra
	test	eax, eax
	jge	SHORT $LN159@PlunderTra
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ebx, ecx
	jmp	SHORT $LN161@PlunderTra
$LN159@PlunderTra:
	cmp	eax, ecx
	jl	SHORT $LN382@PlunderTra
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN161@PlunderTra
$LN382@PlunderTra:
	mov	ebx, eax
$LN161@PlunderTra:
	mov	al, BYTE PTR [edx+4057]
	mov	edx, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN167@PlunderTra
	test	ebp, ebp
	jge	SHORT $LN169@PlunderTra
	mov	eax, ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebp, DWORD PTR [ebp+4024]
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN171@PlunderTra
$LN169@PlunderTra:
	cmp	ebp, edx
	jl	SHORT $LN167@PlunderTra
	mov	eax, ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cdq
	idiv	DWORD PTR [ebp+4024]
	jmp	SHORT $LN171@PlunderTra
$LN167@PlunderTra:
	mov	edx, ebp
$LN171@PlunderTra:
	test	ebx, ebx
	jl	SHORT $LN383@PlunderTra
	cmp	ebx, ecx
	jge	SHORT $LN383@PlunderTra
	test	edx, edx
	jl	SHORT $LN383@PlunderTra
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	edx, DWORD PTR [eax+4024]
	jge	SHORT $LN383@PlunderTra
	imul	ecx, edx
	add	ecx, ebx
	imul	ecx, 484				; 000001e4H
	mov	edx, eax
	add	ecx, DWORD PTR [edx+4068]

; 3857 : 	if (pPlot)

	test	ecx, ecx
	je	SHORT $LN383@PlunderTra

; 3858 : 	{
; 3859 : 		pOriginCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN185@PlunderTra
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN185@PlunderTra
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pOriginCity$[esp+792], eax
	jmp	SHORT $LN383@PlunderTra
$LN185@PlunderTra:
	mov	DWORD PTR _pOriginCity$[esp+792], 0
$LN383@PlunderTra:

; 3860 : 	}
; 3861 : 	pPlot = GC.getMap().plot(pTradeConnection->m_iDestX, pTradeConnection->m_iDestY);

	mov	ebp, DWORD PTR [esi+16]
	mov	esi, DWORD PTR [esi+12]
	cmp	esi, -2147483647			; 80000001H
	je	$LN196@PlunderTra
	cmp	ebp, -2147483647			; 80000001H
	je	$LN196@PlunderTra
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN385@PlunderTra
	test	esi, esi
	jge	SHORT $LN204@PlunderTra
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN385@PlunderTra
$LN204@PlunderTra:
	cmp	esi, ecx
	jl	SHORT $LN385@PlunderTra
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN385@PlunderTra:
	mov	al, BYTE PTR [ebx+4057]
	mov	ebx, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN387@PlunderTra
	test	ebp, ebp
	jge	SHORT $LN214@PlunderTra
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN216@PlunderTra
$LN214@PlunderTra:
	cmp	ebp, ebx
	jl	SHORT $LN387@PlunderTra
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN216@PlunderTra
$LN387@PlunderTra:
	mov	edx, ebp
$LN216@PlunderTra:
	test	esi, esi
	jl	SHORT $LN196@PlunderTra
	cmp	esi, ecx
	jge	SHORT $LN196@PlunderTra
	test	edx, edx
	jl	SHORT $LN196@PlunderTra
	cmp	edx, ebx
	jge	SHORT $LN196@PlunderTra
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	ebx, ecx

; 3862 : 	if (pPlot)

	test	ebx, ebx
	je	SHORT $LN231@PlunderTra

; 3863 : 	{
; 3864 : 		pDestCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN230@PlunderTra
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN230@PlunderTra
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pDestCity$[esp+792], eax
	jmp	SHORT $LN231@PlunderTra

; 3860 : 	}
; 3861 : 	pPlot = GC.getMap().plot(pTradeConnection->m_iDestX, pTradeConnection->m_iDestY);

$LN196@PlunderTra:
	xor	ebx, ebx
	jmp	SHORT $LN231@PlunderTra

; 3863 : 	{
; 3864 : 		pDestCity = pPlot->getPlotCity();

$LN230@PlunderTra:
	mov	DWORD PTR _pDestCity$[esp+792], 0
$LN231@PlunderTra:

; 3865 : 	}
; 3866 : 	CvAssertMsg(pOriginCity, "pOriginCity doesn't exist");
; 3867 : 	CvAssertMsg(pDestCity, "pDestCity doesn't exist");
; 3868 : 
; 3869 : 	bool bEmptyResult = pTrade->EmptyTradeRoute(iTradeConnectionIndex);

	mov	edx, DWORD PTR _ui$256388[esp+792]
	mov	ecx, DWORD PTR _pTrade$[esp+792]
	push	edx
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute

; 3870 : 
; 3871 : 	// if the trade route was not broken
; 3872 : 	if (!bEmptyResult)

	test	al, al

; 3873 : 	{
; 3874 : 		return false;

	je	$LN373@PlunderTra

; 3875 : 	}
; 3876 : 
; 3877 : 	int iPlunderGoldValue = 100;
; 3878 : 	iPlunderGoldValue *= 100 + iDomainModifier;
; 3879 : 	iPlunderGoldValue /= 100;

	add	edi, 100				; 00000064H
	imul	edi, 100				; 00000064H
	mov	eax, 1374389535				; 51eb851fH
	imul	edi

; 3880 : 	m_pPlayer->GetTreasury()->ChangeGold(iPlunderGoldValue);

	mov	edi, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [edi+79104]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	push	esi
	mov	DWORD PTR _iPlunderGoldValue$[esp+796], esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3881 : 
; 3882 : 	// do the floating popup
; 3883 : 	if (GC.getGame().getActivePlayer() == m_pPlayer->GetID())

	mov	eax, DWORD PTR [edi+79104]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, ebp
	jne	$LN384@PlunderTra

; 3884 : 	{
; 3885 : 		char text[256] = {0};

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _text$222276[esp+797]
	push	0
	push	ecx
	mov	BYTE PTR _text$222276[esp+804], 0
	call	_memset

; 3886 : 		sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iPlunderGoldValue);

	push	esi
	lea	edx, DWORD PTR _text$222276[esp+808]
	push	OFFSET $SG222282
	push	edx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>

; 3887 : 		float fDelay = 0.0f;
; 3888 : 		DLLUI->AddPopupText(pPlunderPlot->getX(), pPlunderPlot->getY(), text, fDelay);

	mov	ebp, DWORD PTR _pPlunderPlot$[esp+816]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+184]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp], 0
	lea	edx, DWORD PTR _text$222276[esp+796]
	push	edx
	movsx	edx, WORD PTR [ebp+2]
	push	edx
	movsx	edx, WORD PTR [ebp]
	push	edx
	call	eax

; 3889 : 		CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$222284[esp+792]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3890 : 		if (eDomain == DOMAIN_LAND)

	cmp	DWORD PTR tv1202[esp+792], 2
	mov	DWORD PTR __$EHRec$[esp+800], 1
	jne	SHORT $LN30@PlunderTra

; 3891 : 		{
; 3892 : 			strBuffer = GetLocalizedText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPlunderGoldValue, "TXT_KEY_UNIT_CARAVAN");

	push	OFFSET $SG222294
	lea	ecx, DWORD PTR _iPlunderGoldValue$[esp+796]
	push	ecx
	lea	edx, DWORD PTR $T256322[esp+800]
	push	OFFSET $SG222295
	push	edx
	call	??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z ; GetLocalizedText<int,char const [21]>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+800], 2

; 3893 : 		}
; 3894 : 		else

	jmp	SHORT $LN390@PlunderTra
$LN30@PlunderTra:

; 3895 : 		{
; 3896 : 			strBuffer = GetLocalizedText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPlunderGoldValue, "TXT_KEY_UNIT_CARGO_SHIP");

	push	OFFSET $SG222305
	lea	eax, DWORD PTR _iPlunderGoldValue$[esp+796]
	push	eax
	lea	ecx, DWORD PTR $T256323[esp+800]
	push	OFFSET $SG222306
	push	ecx
	call	??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z ; GetLocalizedText<int,char const [24]>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+800], 3
$LN390@PlunderTra:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$222284[esp+796]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256323[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3897 : 		}
; 3898 : 
; 3899 : 		
; 3900 : 		DLLUI->AddMessage(0, m_pPlayer->GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$222284[esp+792]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi+79104]
	mov	ecx, DWORD PTR [edx+44]
	push	0
	mov	edx, DWORD PTR [esi]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	1
	push	ecx
	push	0
	mov	ecx, esi
	call	edx

; 3901 : 	}

	lea	ecx, DWORD PTR _strBuffer$222284[esp+792]
	mov	DWORD PTR __$EHRec$[esp+800], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN31@PlunderTra
$LN384@PlunderTra:
	mov	ebp, DWORD PTR _pPlunderPlot$[esp+792]
$LN31@PlunderTra:

; 3902 : 
; 3903 : 	// barbarians get a bonus unit out of the deal!
; 3904 : 	if (m_pPlayer->isBarbarian() && pPlot)

	mov	ecx, DWORD PTR [edi+79104]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN388@PlunderTra
	test	ebx, ebx
	je	SHORT $LN388@PlunderTra

; 3905 : 	{
; 3906 : 		int iLoop = 0;
; 3907 : 		for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [edi+79104]
	push	0
	lea	eax, DWORD PTR _iLoop$222308[esp+796]
	push	eax
	mov	DWORD PTR _iLoop$222308[esp+800], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN388@PlunderTra
$LL27@PlunderTra:

; 3908 : 		{
; 3909 : 			if (pLoopUnit->plot() == pPlunderPlot)

	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebp
	je	SHORT $LN370@PlunderTra
	push	0
	lea	ecx, DWORD PTR _iLoop$222308[esp+796]
	push	ecx
	mov	ecx, DWORD PTR [edi+79104]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL27@PlunderTra
	jmp	SHORT $LN388@PlunderTra
$LN370@PlunderTra:

; 3910 : 			{
; 3911 : 				CvBarbarians::DoSpawnBarbarianUnit(pPlunderPlot, true, true);

	push	1
	push	1
	push	ebp
	call	?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z ; CvBarbarians::DoSpawnBarbarianUnit
	add	esp, 12					; 0000000cH
$LN388@PlunderTra:

; 3912 : 				break;
; 3913 : 			}
; 3914 : 		}
; 3915 : 	}
; 3916 : 
; 3917 : 	// do the notification stuff
; 3918 : 	if (pOriginCity && pDestCity)

	cmp	DWORD PTR _pOriginCity$[esp+792], 0
	je	$LN14@PlunderTra
	cmp	DWORD PTR _pDestCity$[esp+792], 0
	je	$LN14@PlunderTra

; 3919 : 	{
; 3920 : 		// send notification to owner player
; 3921 : 		CvNotifications* pNotifications = GET_PLAYER(eOwningPlayer).GetNotifications();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1209[esp+792]
	lea	ecx, DWORD PTR [eax+edx]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications

; 3922 : 		if(pNotifications)

	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	DWORD PTR _pNotifications$222315[esp+792], eax
	test	eax, eax
	je	$LN22@PlunderTra

; 3923 : 		{
; 3924 : 			Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$222317[esp+792]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 3925 : 			Localization::String strMessage;

	lea	ecx, DWORD PTR _strMessage$222318[esp+792]
	mov	DWORD PTR __$EHRec$[esp+800], 4
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 3926 : 
; 3927 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_SUMMARY");

	lea	ecx, DWORD PTR $T256324[esp+792]
	push	OFFSET $SG222320
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+808], 5
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$222317[esp+796]
	mov	BYTE PTR __$EHRec$[esp+804], 6
	call	ebp
	lea	ecx, DWORD PTR $T256324[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 5
	call	edi

; 3928 : 			if (m_pPlayer->isBarbarian())

	mov	edx, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [edx+79104]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN21@PlunderTra

; 3929 : 			{
; 3930 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_BARBARIAN");

	lea	eax, DWORD PTR $T256325[esp+792]
	push	OFFSET $SG222323
	push	eax
	call	ebx
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+800], 7

; 3931 : 				strMessage << pOriginCity->getNameKey();
; 3932 : 				strMessage << pDestCity->getNameKey();

	jmp	$LN391@PlunderTra
$LN21@PlunderTra:

; 3933 : 			}
; 3934 : 			else if (GET_TEAM(eOwningTeam).isHasMet(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR $T256413[esp+792]
	mov	ecx, DWORD PTR _this$[esp+792]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [ecx+79104]
	mov	DWORD PTR $T256905[esp+792], eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, DWORD PTR $T256905[esp+792]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN19@PlunderTra

; 3935 : 			{
; 3936 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_KNOWN");

	lea	edx, DWORD PTR $T256328[esp+792]
	push	OFFSET $SG222334
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+796]
	mov	BYTE PTR __$EHRec$[esp+804], 8
	call	ebp
	lea	ecx, DWORD PTR $T256328[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 5
	call	edi

; 3937 : 				if(GC.getGame().isGameMultiPlayer() && m_pPlayer->isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN18@PlunderTra
	mov	eax, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [eax+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN18@PlunderTra

; 3938 : 				{
; 3939 : 					strMessage << m_pPlayer->getNickName();

	mov	ecx, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3940 : 				}
; 3941 : 				else
; 3942 : 				{
; 3943 : 					strMessage << m_pPlayer->getNameKey();

	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+796]
	call	esi

; 3944 : 				}
; 3945 : 				strMessage << pOriginCity->getNameKey();
; 3946 : 				strMessage << pDestCity->getNameKey();
; 3947 : 			}
; 3948 : 			else

	jmp	SHORT $LN393@PlunderTra
$LN18@PlunderTra:

; 3940 : 				}
; 3941 : 				else
; 3942 : 				{
; 3943 : 					strMessage << m_pPlayer->getNameKey();

	mov	edx, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [edx+79104]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+796]
	call	esi

; 3944 : 				}
; 3945 : 				strMessage << pOriginCity->getNameKey();
; 3946 : 				strMessage << pDestCity->getNameKey();
; 3947 : 			}
; 3948 : 			else

	jmp	SHORT $LN393@PlunderTra
$LN19@PlunderTra:

; 3949 : 			{
; 3950 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_UNKNOWN");

	lea	eax, DWORD PTR $T256333[esp+792]
	push	OFFSET $SG222343
	push	eax
	call	ebx
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+800], 9
$LN391@PlunderTra:
	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+796]
	call	ebp
	lea	ecx, DWORD PTR $T256333[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 5
	call	edi
$LN393@PlunderTra:

; 3951 : 				strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[esp+792]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+796]
	call	esi

; 3952 : 				strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[esp+792]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+796]
	call	esi

; 3953 : 			}
; 3954 : 
; 3955 : 			pNotifications->Add(NOTIFICATION_TRADE_ROUTE_BROKEN, strMessage.toUTF8(), strSummary.toUTF8(), pPlunderPlot->getX(), pPlunderPlot->getY(), -1);

	mov	ecx, DWORD PTR _pPlunderPlot$[esp+792]
	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	-1
	push	-1
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$222317[esp+808]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$222318[esp+812]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$222315[esp+812]
	push	eax
	push	-344621894				; eb757cbaH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3956 : 		}

	lea	ecx, DWORD PTR _strMessage$222318[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 4
	call	edi
	lea	ecx, DWORD PTR _strSummary$222317[esp+792]
	mov	DWORD PTR __$EHRec$[esp+800], -1
	call	edi
$LN22@PlunderTra:

; 3957 : 
; 3958 : 		if (!GET_PLAYER(eDestPlayer).isMinorCiv() && eOwningPlayer != eDestPlayer && eDestPlayer != m_pPlayer->GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv1223[esp+792]
	add	ecx, edx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN14@PlunderTra
	mov	eax, DWORD PTR _eDestPlayer$[esp+792]
	cmp	DWORD PTR _eOwningPlayer$[esp+792], eax
	je	$LN14@PlunderTra
	mov	ecx, DWORD PTR _this$[esp+792]
	mov	edx, DWORD PTR [ecx+79104]
	cmp	eax, DWORD PTR [edx+44]
	je	$LN14@PlunderTra

; 3959 : 		{
; 3960 : 			// send notification to destination player
; 3961 : 			pNotifications = GET_PLAYER(eDestPlayer).GetNotifications();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv1223[esp+792]
	add	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$222315[esp+792], eax

; 3962 : 			if (pNotifications)

	test	eax, eax
	je	$LN14@PlunderTra

; 3963 : 			{
; 3964 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$222348[esp+792]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 3965 : 				Localization::String strMessage;

	lea	ecx, DWORD PTR _strMessage$222349[esp+792]
	mov	DWORD PTR __$EHRec$[esp+800], 10	; 0000000aH
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 3966 : 
; 3967 : 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_SUMMARY");

	lea	edx, DWORD PTR $T256336[esp+792]
	push	OFFSET $SG222351
	push	edx
	mov	BYTE PTR __$EHRec$[esp+808], 11		; 0000000bH
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$222348[esp+796]
	mov	BYTE PTR __$EHRec$[esp+804], 12		; 0000000cH
	call	ebp
	lea	ecx, DWORD PTR $T256336[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 11		; 0000000bH
	call	edi

; 3968 : 				if (m_pPlayer->isBarbarian())

	mov	eax, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [eax+79104]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN13@PlunderTra

; 3969 : 				{
; 3970 : 					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_BARBARIANS");

	lea	ecx, DWORD PTR $T256337[esp+792]
	push	OFFSET $SG222354
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	mov	BYTE PTR __$EHRec$[esp+804], 13		; 0000000dH
	call	ebp
	lea	ecx, DWORD PTR $T256337[esp+792]
$LN399@PlunderTra:
	mov	BYTE PTR __$EHRec$[esp+800], 11		; 0000000bH
	call	edi

; 3971 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eOwningPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	mov	ebx, DWORD PTR tv1209[esp+792]
	test	al, al
	je	$LN3@PlunderTra
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN3@PlunderTra

; 3972 : 					{
; 3973 : 						strMessage << GET_PLAYER(eOwningPlayer).getNickName();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3974 : 					}
; 3975 : 					else

	jmp	$LN394@PlunderTra
$LN13@PlunderTra:

; 3976 : 					{
; 3977 : 						strMessage << GET_PLAYER(eOwningPlayer).getNameKey();
; 3978 : 					}
; 3979 : 					strMessage << pOriginCity->getNameKey();
; 3980 : 					strMessage << pDestCity->getNameKey();
; 3981 : 				}
; 3982 : 				else if (GET_TEAM(eDestTeam).isHasMet(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR $T256440[esp+792]
	mov	edx, DWORD PTR _this$[esp+792]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [edx+79104]
	mov	DWORD PTR $T256984[esp+792], eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, DWORD PTR $T256984[esp+792]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN9@PlunderTra

; 3983 : 				{
; 3984 : 					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_KNOWN");

	lea	eax, DWORD PTR $T256342[esp+792]
	push	OFFSET $SG222364
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	mov	BYTE PTR __$EHRec$[esp+804], 14		; 0000000eH
	call	ebp
	lea	ecx, DWORD PTR $T256342[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 11		; 0000000bH
	call	edi

; 3985 : 					if(GC.getGame().isGameMultiPlayer() && m_pPlayer->isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	mov	ebx, DWORD PTR _this$[esp+792]
	test	al, al
	je	SHORT $LN8@PlunderTra
	mov	ecx, DWORD PTR [ebx+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN8@PlunderTra

; 3986 : 					{
; 3987 : 						strMessage << m_pPlayer->getNickName();

	mov	ecx, DWORD PTR [ebx+79104]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3988 : 					}
; 3989 : 					else

	jmp	SHORT $LN395@PlunderTra
$LN8@PlunderTra:

; 3990 : 					{
; 3991 : 						strMessage << m_pPlayer->getNameKey();

	mov	ecx, DWORD PTR [ebx+79104]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN395@PlunderTra:
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	call	esi

; 3992 : 					}
; 3993 : 
; 3994 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eOwningPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	mov	ebx, DWORD PTR tv1209[esp+792]
	test	al, al
	je	SHORT $LN6@PlunderTra
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebx
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN6@PlunderTra

; 3995 : 					{
; 3996 : 						strMessage << GET_PLAYER(eOwningPlayer).getNickName();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3997 : 					}
; 3998 : 					else

	jmp	SHORT $LN394@PlunderTra
$LN6@PlunderTra:

; 3999 : 					{
; 4000 : 						strMessage << GET_PLAYER(eOwningPlayer).getNameKey();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]

; 4001 : 					}
; 4002 : 
; 4003 : 					strMessage << pOriginCity->getNameKey();
; 4004 : 					strMessage << pDestCity->getNameKey();
; 4005 : 				}
; 4006 : 				else

	jmp	SHORT $LN397@PlunderTra
$LN9@PlunderTra:

; 4007 : 				{
; 4008 : 					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_UNKNOWN");

	lea	ecx, DWORD PTR $T256349[esp+792]
	push	OFFSET $SG222377
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	mov	BYTE PTR __$EHRec$[esp+804], 15		; 0000000fH
	call	ebp
	lea	ecx, DWORD PTR $T256349[esp+792]

; 4009 : 
; 4010 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eOwningPlayer).isHuman())
; 4011 : 					{
; 4012 : 						strMessage << GET_PLAYER(eOwningPlayer).getNickName();
; 4013 : 					}
; 4014 : 					else

	jmp	$LN399@PlunderTra
$LN3@PlunderTra:

; 4015 : 					{
; 4016 : 						strMessage << GET_PLAYER(eOwningPlayer).getNameKey();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebx
$LN397@PlunderTra:
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN394@PlunderTra:
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	call	esi

; 4017 : 					}
; 4018 : 
; 4019 : 					strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[esp+792]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	call	esi

; 4020 : 					strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[esp+792]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+796]
	call	esi

; 4021 : 				}
; 4022 : 
; 4023 : 				pNotifications->Add(NOTIFICATION_TRADE_ROUTE_BROKEN, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$222348[esp+808]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strMessage$222349[esp+812]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$222315[esp+812]
	push	eax
	push	-344621894				; eb757cbaH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4024 : 			}

	lea	ecx, DWORD PTR _strMessage$222349[esp+792]
	mov	BYTE PTR __$EHRec$[esp+800], 10		; 0000000aH
	call	edi
	lea	ecx, DWORD PTR _strSummary$222348[esp+792]
	mov	DWORD PTR __$EHRec$[esp+800], -1
	call	edi
$LN14@PlunderTra:

; 4025 : 		}
; 4026 : 	}
; 4027 : 
; 4028 : 	if (eDomain == DOMAIN_LAND && m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	cmp	DWORD PTR tv1202[esp+792], 2
	jne	SHORT $LN1@PlunderTra
	mov	edx, DWORD PTR _this$[esp+792]
	mov	ecx, DWORD PTR [edx+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN1@PlunderTra
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN1@PlunderTra

; 4029 : 	{
; 4030 : 		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_28);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	270					; 0000010eH
	call	edx
$LN1@PlunderTra:

; 4031 : 	}
; 4032 : 
; 4033 : 	return true;

	mov	al, 1
$LN36@PlunderTra:

; 4034 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+792]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 776				; 00000308H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$0:
	mov	ecx, DWORD PTR $T256321[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$1:
	lea	ecx, DWORD PTR _strBuffer$222284[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$2:
	lea	ecx, DWORD PTR $T256322[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$3:
	lea	ecx, DWORD PTR $T256323[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$4:
	lea	ecx, DWORD PTR _strSummary$222317[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$5:
	lea	ecx, DWORD PTR _strMessage$222318[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$6:
	lea	ecx, DWORD PTR $T256324[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$7:
	lea	ecx, DWORD PTR $T256325[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$8:
	lea	ecx, DWORD PTR $T256328[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$9:
	lea	ecx, DWORD PTR $T256333[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$10:
	lea	ecx, DWORD PTR _strSummary$222348[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$11:
	lea	ecx, DWORD PTR _strMessage$222349[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$12:
	lea	ecx, DWORD PTR $T256336[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$13:
	lea	ecx, DWORD PTR $T256337[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$14:
	lea	ecx, DWORD PTR $T256342[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$15:
	lea	ecx, DWORD PTR $T256349[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z ENDP		; CvPlayerTrade::PlunderTradeRoute
PUBLIC	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z
_TEXT	SEGMENT
$T257213 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$257246 = 12					; size = 1
__Cat$257218 = 12					; size = 1
$T257215 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [ebx], eax
	cmp	eax, edx
	je	SHORT $LN32@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	BYTE PTR $T257213[esp+8], 0
	mov	edi, DWORD PTR $T257213[esp+8]
	push	edi
	mov	edi, DWORD PTR __Cat$257218[esp+12]
	push	edi
	mov	edi, DWORD PTR $T257215[esp+16]
	push	edi
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUTRSortElement@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUTRSortElement@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,TRSortElement *,std::random_access_iterator_tag>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR [esi+8]
	mov	edi, eax
	mov	eax, DWORD PTR __Cat$257246[esp+32]
	push	eax
	push	esi
	push	ecx
	push	edi
	call	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >
	add	esp, 40					; 00000028H

; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], edi
	pop	edi
$LN32@erase@4:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$257274 = -4					; size = 1
?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR __Cat$257274[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN10@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUTRSortElement@@@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU2@00@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Umove<TRSortElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUTRSortElement@@@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU2@00@Z
_TEXT	SEGMENT
$T257331 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$257335 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUTRSortElement@@@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU2@00@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Umove<TRSortElement *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$257335[esp]
	mov	BYTE PTR $T257331[esp+4], 0
	mov	eax, DWORD PTR $T257331[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUTRSortElement@@@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU2@00@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Umove<TRSortElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
_TEXT	SEGMENT
$T257342 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T257343 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>, COMDAT

; 5285 : 	{

	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Pred$[esp+12]
	xor	ecx, ecx
	mov	BYTE PTR $T257342[esp+16], cl
	mov	eax, DWORD PTR $T257342[esp+16]
	push	eax
	mov	eax, DWORD PTR __Count$[esp+16]
	push	edx
	mov	edx, DWORD PTR __Chunk$[esp+20]
	push	eax
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR __$EHRec$[esp+60], ecx
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+48]
	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR $T257343[esp+48], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
	add	esp, 44					; 0000002cH

; 5287 : 	}

	lea	ecx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
__Tmp$257425 = -16					; size = 8
__Tmp$257483 = -8					; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	sub	esp, 16					; 00000010H

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Where$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+16]
	push	esi
	push	edi
	push	ebx
	mov	esi, ecx
	mov	ecx, DWORD PTR __Where$[esp+28]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	esi, DWORD PTR [esi+8]
	mov	edi, eax
	lea	edx, DWORD PTR [edi+ebx]
	xor	eax, eax
	push	edx
	lea	ecx, DWORD PTR __Tmp$257425[esp+32]
	mov	DWORD PTR __Tmp$257425[esp+32], esi
	mov	DWORD PTR __Tmp$257425[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	xor	eax, eax
	push	edi
	lea	ecx, DWORD PTR __Tmp$257483[esp+32]
	mov	DWORD PTR __Tmp$257483[esp+32], esi
	mov	DWORD PTR __Tmp$257483[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$257425[esp+32]
	mov	edx, DWORD PTR __Tmp$257425[esp+28]
	lea	eax, DWORD PTR __Val$[esp+24]
	push	eax
	mov	eax, DWORD PTR __Tmp$257483[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$257483[esp+36]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 2293 : 		}

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
PUBLIC	?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::DoAutoWarPlundering
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canPlunderTradeRoute
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z
_TEXT	SEGMENT
_ePlunderTeam$220704 = -32				; size = 4
tv805 = -28						; size = 4
_eTRTeam$220703 = -24					; size = 4
_uiPlayer$220711 = -20					; size = 4
_uiTradeRoute$220718 = -16				; size = 4
_this$ = -12						; size = 4
tv884 = -8						; size = 4
_uiTeam$220699 = -4					; size = 4
_eTeam1$ = 8						; size = 4
_eTeam2$ = 12						; size = 4
?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z PROC ; CvGameTrade::DoAutoWarPlundering, COMDAT
; _this$ = ecx

; 1316 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1317 : 	// walk through each team
; 1318 : 	for (uint uiTeam = 0; uiTeam < 2; uiTeam++)

	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR _this$[esp+48], ecx
	mov	DWORD PTR _uiTeam$220699[esp+48], eax
	jmp	SHORT $LN22@DoAutoWarP
$LL158@DoAutoWarP:
	xor	edi, edi
$LN22@DoAutoWarP:

; 1319 : 	{
; 1320 : 		TeamTypes eTRTeam = NO_TEAM;

	or	esi, -1

; 1321 : 		TeamTypes ePlunderTeam = NO_TEAM;
; 1322 : 		switch (uiTeam)

	sub	eax, edi
	mov	DWORD PTR _eTRTeam$220703[esp+48], esi
	mov	DWORD PTR _ePlunderTeam$220704[esp+48], esi
	je	SHORT $LN17@DoAutoWarP
	sub	eax, 1
	jne	SHORT $LN18@DoAutoWarP

; 1327 : 			break;
; 1328 : 		case 1:
; 1329 : 			eTRTeam = eTeam2;
; 1330 : 			ePlunderTeam = eTeam1;

	mov	edx, DWORD PTR _eTeam1$[esp+44]
	mov	eax, DWORD PTR _eTeam2$[esp+44]
	mov	DWORD PTR _ePlunderTeam$220704[esp+48], edx

; 1331 : 		}
; 1332 : 
; 1333 : 		// walk through each player on the team
; 1334 : 		for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	xor	edx, edx
	mov	DWORD PTR _eTRTeam$220703[esp+48], eax
	mov	DWORD PTR _uiPlayer$220711[esp+48], edi
	mov	DWORD PTR tv884[esp+48], edx
	jmp	SHORT $LN15@DoAutoWarP
$LN17@DoAutoWarP:

; 1323 : 		{
; 1324 : 		case 0:
; 1325 : 			eTRTeam = eTeam1;

	mov	eax, DWORD PTR _eTeam1$[esp+44]

; 1326 : 			ePlunderTeam = eTeam2;

	mov	edx, DWORD PTR _eTeam2$[esp+44]
	mov	DWORD PTR _ePlunderTeam$220704[esp+48], edx
	mov	DWORD PTR _eTRTeam$220703[esp+48], eax
$LN18@DoAutoWarP:

; 1331 : 		}
; 1332 : 
; 1333 : 		// walk through each player on the team
; 1334 : 		for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	xor	edx, edx
	mov	DWORD PTR _uiPlayer$220711[esp+48], edi
	mov	DWORD PTR tv884[esp+48], edx
	jmp	SHORT $LN15@DoAutoWarP
$LL159@DoAutoWarP:
	xor	edi, edi
$LN15@DoAutoWarP:

; 1335 : 		{
; 1336 : 			PlayerTypes ePlayer = (PlayerTypes)uiPlayer;
; 1337 : 			if (GET_PLAYER(ePlayer).getTeam() != eTRTeam)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN31@DoAutoWarP
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN32@DoAutoWarP
$LN31@DoAutoWarP:
	mov	eax, esi
$LN32@DoAutoWarP:
	cmp	eax, DWORD PTR _eTRTeam$220703[esp+48]
	jne	$LN14@DoAutoWarP

; 1338 : 			{
; 1339 : 				continue;
; 1340 : 			}
; 1341 : 			
; 1342 : 			// walk through each of the trade routes
; 1343 : 			for (uint uiTradeRoute = 0; uiTradeRoute < m_aTradeConnections.size(); uiTradeRoute++)

	mov	DWORD PTR _uiTradeRoute$220718[esp+48], edi
	cmp	DWORD PTR [ecx+4], edi
	jbe	$LN14@DoAutoWarP
	mov	DWORD PTR tv805[esp+48], edi
	npad	2
$LL11@DoAutoWarP:

; 1344 : 			{
; 1345 : 				if (IsTradeRouteIndexEmpty(uiTradeRoute))

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv805[esp+48]
	cmp	DWORD PTR [edx+ecx+4], esi
	lea	eax, DWORD PTR [edx+ecx]
	jne	SHORT $LN39@DoAutoWarP
	cmp	DWORD PTR [eax+8], esi
	jne	SHORT $LN39@DoAutoWarP
	cmp	DWORD PTR [eax+12], esi
	jne	SHORT $LN39@DoAutoWarP
	cmp	DWORD PTR [eax+16], esi
	je	$LN10@DoAutoWarP
$LN39@DoAutoWarP:

; 1346 : 				{
; 1347 : 					continue;
; 1348 : 				}
; 1349 : 
; 1350 : 				// if it's not my trade route
; 1351 : 				if (m_aTradeConnections[uiTradeRoute].m_eOriginOwner != ePlayer)

	mov	ecx, DWORD PTR _uiPlayer$220711[esp+48]
	cmp	DWORD PTR [eax+20], ecx
	jne	$LN10@DoAutoWarP

; 1352 : 				{
; 1353 : 					continue;
; 1354 : 				}
; 1355 : 
; 1356 : 				// if the destination is not the civ I'm going to war with
; 1357 : 				if (GET_PLAYER(m_aTradeConnections[uiTradeRoute].m_eDestOwner).getTeam() != ePlunderTeam)

	mov	edx, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edx, 63236				; 0000f704H
	mov	ecx, DWORD PTR [edx+ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN60@DoAutoWarP
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN61@DoAutoWarP
$LN60@DoAutoWarP:
	mov	ecx, esi
$LN61@DoAutoWarP:
	cmp	ecx, DWORD PTR _ePlunderTeam$220704[esp+48]
	jne	$LN10@DoAutoWarP

; 1358 : 				{
; 1359 : 					continue;
; 1360 : 				}
; 1361 : 
; 1362 : 				// get the plot where the trade route is
; 1363 : 				int iLocationIndex = m_aTradeConnections[uiTradeRoute].m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR [eax+36]

; 1364 : 				int iPlotX = m_aTradeConnections[uiTradeRoute].m_aPlotList[iLocationIndex].m_iX;

	mov	eax, DWORD PTR [eax+44]

; 1365 : 				int iPlotY = m_aTradeConnections[uiTradeRoute].m_aPlotList[iLocationIndex].m_iY;

	mov	ebx, DWORD PTR [eax+ecx*8+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [ecx]

; 1366 : 				CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN77@DoAutoWarP
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN77@DoAutoWarP
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN87@DoAutoWarP
	test	eax, eax
	jge	SHORT $LN89@DoAutoWarP
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN91@DoAutoWarP
$LN89@DoAutoWarP:
	cmp	eax, ecx
	jl	SHORT $LN87@DoAutoWarP
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN91@DoAutoWarP
$LN87@DoAutoWarP:
	mov	esi, eax
$LN91@DoAutoWarP:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN155@DoAutoWarP
	test	ebx, ebx
	jge	SHORT $LN99@DoAutoWarP
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN101@DoAutoWarP
$LN99@DoAutoWarP:
	cmp	ebx, edi
	jl	SHORT $LN155@DoAutoWarP
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN101@DoAutoWarP
$LN155@DoAutoWarP:
	mov	edx, ebx
$LN101@DoAutoWarP:
	test	esi, esi
	jl	SHORT $LN77@DoAutoWarP
	cmp	esi, ecx
	jge	SHORT $LN77@DoAutoWarP
	test	edx, edx
	jl	SHORT $LN77@DoAutoWarP
	cmp	edx, edi
	jge	SHORT $LN77@DoAutoWarP
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	ebx, ecx
	jmp	SHORT $LN79@DoAutoWarP
$LN77@DoAutoWarP:
	xor	ebx, ebx
$LN79@DoAutoWarP:

; 1367 : 
; 1368 : 				// see if there is unit from the other team above it
; 1369 : 				IDInfo* pUnitNode = pPlot->headUnitNode();

	mov	ecx, ebx
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	edi, eax

; 1370 : 				while(pUnitNode != NULL)

	test	edi, edi
	je	$LN10@DoAutoWarP
$LL5@DoAutoWarP:

; 1371 : 				{
; 1372 : 					CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jl	SHORT $LN156@DoAutoWarP
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN156@DoAutoWarP
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	edx
	mov	esi, eax

; 1373 : 					if(pLoopUnit)

	test	esi, esi
	je	SHORT $LN156@DoAutoWarP

; 1374 : 					{
; 1375 : 						if (GET_PLAYER(pLoopUnit->getOwner()).getTeam() == ePlunderTeam)

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN130@DoAutoWarP
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN131@DoAutoWarP
$LN130@DoAutoWarP:
	or	eax, -1
$LN131@DoAutoWarP:
	cmp	eax, DWORD PTR _ePlunderTeam$220704[esp+48]
	jne	SHORT $LN156@DoAutoWarP

; 1376 : 						{
; 1377 : 							if (pLoopUnit->canPlunderTradeRoute(pPlot, true))

	push	1
	push	ebx
	mov	ecx, esi
	call	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canPlunderTradeRoute
	test	al, al
	jne	SHORT $LN147@DoAutoWarP
$LN156@DoAutoWarP:

; 1381 : 								break;
; 1382 : 							}
; 1383 : 						}
; 1384 : 					}
; 1385 : 
; 1386 : 					pUnitNode = pPlot->nextUnitNode(pUnitNode);

	push	edi
	mov	ecx, ebx
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL5@DoAutoWarP

; 1376 : 						{
; 1377 : 							if (pLoopUnit->canPlunderTradeRoute(pPlot, true))

	jmp	SHORT $LN10@DoAutoWarP
$LN147@DoAutoWarP:

; 1378 : 							{
; 1379 : 								// cheating to get around war!
; 1380 : 								GET_PLAYER(pLoopUnit->getOwner()).GetTrade()->PlunderTradeRoute(m_aTradeConnections[uiTradeRoute].m_iID);

	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR _this$[esp+48]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR tv805[esp+48]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z ; CvPlayerTrade::PlunderTradeRoute
$LN10@DoAutoWarP:
	mov	eax, DWORD PTR _uiTradeRoute$220718[esp+48]
	mov	ecx, DWORD PTR _this$[esp+48]
	add	DWORD PTR tv805[esp+48], 444		; 000001bcH
	inc	eax
	or	esi, -1
	mov	DWORD PTR _uiTradeRoute$220718[esp+48], eax
	cmp	eax, DWORD PTR [ecx+4]
	jb	$LL11@DoAutoWarP

; 1338 : 			{
; 1339 : 				continue;
; 1340 : 			}
; 1341 : 			
; 1342 : 			// walk through each of the trade routes
; 1343 : 			for (uint uiTradeRoute = 0; uiTradeRoute < m_aTradeConnections.size(); uiTradeRoute++)

	mov	edx, DWORD PTR tv884[esp+48]
$LN14@DoAutoWarP:

; 1331 : 		}
; 1332 : 
; 1333 : 		// walk through each player on the team
; 1334 : 		for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	inc	DWORD PTR _uiPlayer$220711[esp+48]
	add	edx, 63236				; 0000f704H
	mov	DWORD PTR tv884[esp+48], edx
	cmp	edx, 1391192				; 00153a58H
	jb	$LL159@DoAutoWarP
	mov	eax, DWORD PTR _uiTeam$220699[esp+48]
	inc	eax
	mov	DWORD PTR _uiTeam$220699[esp+48], eax
	cmp	eax, 2
	jb	$LL158@DoAutoWarP
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1387 : 				}
; 1388 : 			}
; 1389 : 		}
; 1390 : 	}
; 1391 : }

	add	esp, 32					; 00000020H
	ret	8
?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z ENDP ; CvGameTrade::DoAutoWarPlundering
_TEXT	ENDS
PUBLIC	?StepUnit@CvGameTrade@@QAE_NH@Z			; CvGameTrade::StepUnit
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
EXTRN	?setXY@CvUnit@@QAEXHH_N0000@Z:PROC		; CvUnit::setXY
; Function compile flags: /Ogtpy
;	COMDAT ?StepUnit@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?StepUnit@CvGameTrade@@QAE_NH@Z PROC			; CvGameTrade::StepUnit, COMDAT
; _this$ = ecx

; 1806 : {

	push	edi

; 1807 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1808 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	mov	edi, DWORD PTR _iIndex$[esp]
	test	edi, edi
	jl	$LN10@StepUnit
	cmp	edi, DWORD PTR [ecx+4]
	jge	$LN10@StepUnit
	push	ebx
	push	esi

; 1811 : 	}
; 1812 : 
; 1813 : 	// if the unit needs to turn around
; 1814 : 	TradeConnection &kTradeConnection = m_aTradeConnections[iIndex];

	mov	esi, edi
	imul	esi, 444				; 000001bcH
	add	esi, DWORD PTR [ecx]

; 1815 : #ifdef AUI_WARNING_FIXES
; 1816 : 	bool bAtEndGoingForward = (kTradeConnection.m_bTradeUnitMovingForward && kTradeConnection.m_iTradeUnitLocationIndex + 1 >= kTradeConnection.m_aPlotList.size());
; 1817 : #else
; 1818 : 	bool bAtEndGoingForward = (kTradeConnection.m_bTradeUnitMovingForward && kTradeConnection.m_iTradeUnitLocationIndex >= ((int)kTradeConnection.m_aPlotList.size() - 1));

	mov	al, BYTE PTR [esi+40]
	test	al, al
	je	SHORT $LN79@StepUnit
	mov	edx, DWORD PTR [esi+48]
	dec	edx
	cmp	DWORD PTR [esi+36], edx
	jl	SHORT $LN79@StepUnit
	mov	bl, 1
	jmp	SHORT $LN15@StepUnit
$LN79@StepUnit:
	xor	bl, bl
$LN15@StepUnit:

; 1819 : #endif
; 1820 : 	bool bAtEndGoingBackward = (!kTradeConnection.m_bTradeUnitMovingForward && kTradeConnection.m_iTradeUnitLocationIndex <= 0);

	test	al, al
	jne	SHORT $LN16@StepUnit
	cmp	DWORD PTR [esi+36], 0
	jg	SHORT $LN16@StepUnit
	mov	dl, 1
	jmp	SHORT $LN17@StepUnit
$LN16@StepUnit:
	xor	dl, dl
$LN17@StepUnit:

; 1821 : 	if (bAtEndGoingForward || bAtEndGoingBackward)

	test	bl, bl
	jne	SHORT $LN8@StepUnit
	test	dl, dl
	je	SHORT $LN9@StepUnit
$LN8@StepUnit:

; 1822 : 	{
; 1823 : 		kTradeConnection.m_bTradeUnitMovingForward = !kTradeConnection.m_bTradeUnitMovingForward;

	test	al, al
	sete	al
	mov	BYTE PTR [esi+40], al
$LN9@StepUnit:

; 1824 : 	}
; 1825 : 
; 1826 : 	// if moving forward
; 1827 : 	if (kTradeConnection.m_bTradeUnitMovingForward)

	cmp	BYTE PTR [esi+40], 0
	je	SHORT $LN7@StepUnit

; 1828 : 	{
; 1829 : 		kTradeConnection.m_iTradeUnitLocationIndex += 1;

	inc	DWORD PTR [esi+36]

; 1830 : 	}
; 1831 : 	else // if moving back

	jmp	SHORT $LN81@StepUnit
$LN7@StepUnit:

; 1832 : 	{
; 1833 : 		kTradeConnection.m_iTradeUnitLocationIndex -= 1;

	add	DWORD PTR [esi+36], -1

; 1834 : 		if (kTradeConnection.m_iTradeUnitLocationIndex == 0)

	jne	SHORT $LN81@StepUnit

; 1835 : 		{
; 1836 : 			kTradeConnection.m_iCircuitsCompleted += 1;

	inc	DWORD PTR [esi+384]
$LN81@StepUnit:

; 1837 : 		}
; 1838 : 	}
; 1839 : 
; 1840 : 	// Move the visualization
; 1841 : 	CvUnit *pkUnit = GetVis(iIndex);

	push	edi
	call	?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z	; CvGameTrade::GetVis

; 1842 : 	if (pkUnit)

	test	eax, eax
	je	SHORT $LN4@StepUnit

; 1843 : 	{
; 1844 : 		pkUnit->setXY(kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iX, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iY, true, false, true, true);

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+44]
	push	0
	push	1
	push	1
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx]
	push	0
	push	1
	push	ecx
	push	edx
	mov	ecx, eax
	call	?setXY@CvUnit@@QAEXHH_N0000@Z		; CvUnit::setXY
$LN4@StepUnit:

; 1845 : 	}
; 1846 : 
; 1847 : 	// auto-pillage when a trade unit moves under an enemy unit
; 1848 : 	CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iX, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iY);

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [eax]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@StepUnit
	cmp	ebx, -2147483647			; 80000001H
	je	$LN1@StepUnit
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN44@StepUnit
	test	eax, eax
	jge	SHORT $LN46@StepUnit
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN48@StepUnit
$LN46@StepUnit:
	cmp	eax, ecx
	jl	SHORT $LN44@StepUnit
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN48@StepUnit
$LN44@StepUnit:
	mov	edi, eax
$LN48@StepUnit:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebp, DWORD PTR [edx+4024]
	je	SHORT $LN80@StepUnit
	test	ebx, ebx
	jge	SHORT $LN56@StepUnit
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN58@StepUnit
$LN56@StepUnit:
	cmp	ebx, ebp
	jl	SHORT $LN80@StepUnit
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN58@StepUnit
$LN80@StepUnit:
	mov	edx, ebx
$LN58@StepUnit:
	test	edi, edi
	jl	SHORT $LN1@StepUnit
	cmp	edi, ecx
	jge	SHORT $LN1@StepUnit
	test	edx, edx
	jl	SHORT $LN1@StepUnit
	cmp	edx, ebp
	jge	SHORT $LN1@StepUnit
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx

; 1849 : 	if (pPlot)

	je	SHORT $LN1@StepUnit

; 1850 : 	{
; 1851 : 		CvUnit* pEnemyUnit = pPlot->getVisibleEnemyDefender(kTradeConnection.m_eOriginOwner);

	mov	eax, DWORD PTR [esi+20]
	push	eax
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	ebp, eax

; 1852 : 		if (pEnemyUnit)

	test	ebp, ebp
	je	SHORT $LN1@StepUnit

; 1853 : 		{
; 1854 : 			if (pEnemyUnit->canPlunderTradeRoute(pPlot, false))

	push	0
	push	edi
	mov	ecx, ebp
	call	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canPlunderTradeRoute
	test	al, al
	je	SHORT $LN1@StepUnit

; 1855 : 			{
; 1856 : 				GET_PLAYER(pEnemyUnit->getOwner()).GetTrade()->PlunderTradeRoute(kTradeConnection.m_iID);

	mov	ecx, DWORD PTR [ebp+40]
	mov	edx, DWORD PTR [esi]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z ; CvPlayerTrade::PlunderTradeRoute
	pop	ebp
	pop	esi
	pop	ebx

; 1857 : 				// done died!
; 1858 : 				return false;

	xor	al, al
	pop	edi

; 1864 : }

	ret	4
$LN1@StepUnit:
	pop	ebp
	pop	esi
	pop	ebx

; 1859 : 			}
; 1860 : 		}
; 1861 : 	}
; 1862 : 
; 1863 : 	return true;

	mov	al, 1
	pop	edi

; 1864 : }

	ret	4
$LN10@StepUnit:

; 1809 : 	{
; 1810 : 		return false;

	xor	al, al
	pop	edi

; 1864 : }

	ret	4
?StepUnit@CvGameTrade@@QAE_NH@Z ENDP			; CvGameTrade::StepUnit
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
$T257976 = -4						; size = 1
__Cat$257979 = 8					; size = 1
$T257945 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 810  : 		if (size() < capacity())

	mov	ebp, DWORD PTR [edi+4]
	test	ebp, ebp
	jne	SHORT $LN9@push_back@6
	xor	esi, esi
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@push_back@6:
	mov	ebx, DWORD PTR [edi+8]
	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$257979[esp+16]
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	BYTE PTR $T257976[esp+20], 0
	mov	ecx, DWORD PTR $T257976[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR [edi+8], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	ebx
	lea	edx, DWORD PTR $T257945[esp+24]
	push	edx
	mov	ecx, edi
	call	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::push_back
_TEXT	ENDS
PUBLIC	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT	SEGMENT
$T258004 = -16						; size = 8
$T258002 = -16						; size = 8
__Tmp$258228 = -8					; size = 8
$T258008 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2039 : 		{	// determine new length, padding with _Val elements as needed

	sub	esp, 16					; 00000010H
	push	ebx

; 2040 : 		if (size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp+16]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	cmp	ebx, esi
	jbe	SHORT $LN68@resize@2

; 2041 : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR $T258002[esp+28], eax
	mov	DWORD PTR $T258002[esp+32], 0
	test	esi, esi
	jbe	SHORT $LN25@resize@2
	push	esi
	lea	ecx, DWORD PTR $T258002[esp+32]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN25@resize@2:
	mov	ecx, DWORD PTR __Val$[esp+24]
	mov	edx, DWORD PTR $T258002[esp+32]
	mov	eax, DWORD PTR $T258002[esp+28]
	push	ecx
	sub	ebx, esi
	push	ebx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	pop	edi
	pop	esi
	pop	ebx

; 2044 : 		}

	add	esp, 16					; 00000010H
	ret	8
$LN68@resize@2:

; 2042 : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@2
	push	ebp

; 2043 : 			erase(begin() + _Newsize, end());

	mov	ebp, DWORD PTR [edi+8]
	mov	DWORD PTR $T258004[esp+32], ebp
	mov	DWORD PTR $T258004[esp+36], 0
	test	esi, esi
	jbe	SHORT $LN48@resize@2
	push	esi
	lea	ecx, DWORD PTR $T258004[esp+36]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN48@resize@2:
	xor	eax, eax
	push	ebx
	lea	ecx, DWORD PTR __Tmp$258228[esp+36]
	mov	DWORD PTR __Tmp$258228[esp+36], ebp
	mov	DWORD PTR __Tmp$258228[esp+40], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR $T258004[esp+36]
	mov	edx, DWORD PTR $T258004[esp+32]
	mov	eax, DWORD PTR __Tmp$258228[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$258228[esp+36]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T258008[esp+48]
	push	edx
	mov	ecx, edi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
	pop	ebp
$LN1@resize@2:
	pop	edi
	pop	esi
	pop	ebx

; 2044 : 		}

	add	esp, 16					; 00000010H
	ret	8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
_TEXT	ENDS
PUBLIC	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$258272 = -4					; size = 1
??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@vector@8
	mov	ecx, DWORD PTR __Cat$258272[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN12@vector@8:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	pop	ecx
	ret	0
??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T258284 = -4						; size = 4
?clear@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T258284[esp+12]
	push	eax
	call	?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$2
__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$11
__unwindtable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
_TEXT	SEGMENT
__Tmp$224555 = -928					; size = 448
__Tmp$224545 = -480					; size = 448
__Ncopied$224532 = -32					; size = 4
_this$ = -28						; size = 4
tv557 = -24						; size = 4
__Whereoff$224531 = -24					; size = 4
__Newvec$224530 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$258556 = 8					; size = 1
__Cat$258525 = 8					; size = 1
__Cat$258453 = 8					; size = 1
__Where$ = 8						; size = 4
tv601 = 12						; size = 4
__Count$ = 12						; size = 4
$T258521 = 16						; size = 1
$T258449 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 916				; 00000394H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@5
	xor	ebx, ebx
	jmp	SHORT $LN32@Insert_n@5
$LN31@Insert_n@5:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
$LN32@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN123@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 9586980				; 00924924H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
$LN145@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	ecx, DWORD PTR [eax+edi]
	cmp	ebx, ecx
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ebx
	shr	eax, 1
	mov	edx, 9586980				; 00924924H
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN17@Insert_n@5
	xor	ebx, ebx
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ebx, eax
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebx, ecx
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	ebx, ecx
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ebx
	call	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Newvec$224530[ebp], eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$224531[ebp], eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Newvec$224530[ebp]
	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR __Ncopied$224532[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU3@IABU3@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$258453[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T258449[ebp], 0
	mov	edx, DWORD PTR $T258449[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$224530[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224532[ebp], 1
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Whereoff$224531[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edx+edi]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Newvec$224530[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T258521[ebp], 0
	mov	edx, DWORD PTR $T258521[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$258525[ebp]
	push	edx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224532[ebp], 2
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	add	edx, ecx
	sar	edx, 8
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	test	eax, eax
	je	SHORT $LN89@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR __Cat$258556[ebp]
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	push	esi
	push	ecx
	push	eax
	call	??$_Destroy_range@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@0AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<TRSortElement> >

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN89@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$224530[ebp]
	imul	ebx, 448				; 000001c0H

; 1206 : 			_Mylast = _Newvec + _Count;

	imul	edi, 448				; 000001c0H
	add	ebx, eax
	add	edi, eax
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$224532[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$224531[ebp]
	mov	edi, DWORD PTR __Newvec$224530[ebp]
	jle	SHORT $LN7@Insert_n@5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, esi
	imul	eax, 448				; 000001c0H
	add	eax, edi
	push	eax
	push	edi
	call	?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [esi+ecx]
	imul	esi, 448				; 000001c0H
	mov	ecx, DWORD PTR _this$[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, edi
	push	edx
	add	esi, edi
	push	esi
	call	?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN146@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224545[ebp]
	call	??0TRSortElement@@QAE@ABU0@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, edi
	imul	ebx, 448				; 000001c0H
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAUTRSortElement@@@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU2@00@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Umove<TRSortElement *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224545[ebp]
	push	edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU3@IABU3@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224545[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ; std::_Fill<TRSortElement *,TRSortElement>

; 1232 : 			}

	mov	ecx, DWORD PTR __Tmp$224545[ebp+48]
	mov	edx, DWORD PTR __Tmp$224545[ebp+44]
	add	esp, 12					; 0000000cH
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	test	ecx, ecx
	jbe	SHORT $LN105@Insert_n@5
$LL107@Insert_n@5:
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL107@Insert_n@5
$LN105@Insert_n@5:
	lea	eax, DWORD PTR __Tmp$224545[ebp+56]
	cmp	edx, eax
	je	$LN123@Insert_n@5
	push	edx

; 1233 : 		else

	jmp	$LN144@Insert_n@5
__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, 448				; 000001c0H
	mov	edx, DWORD PTR [ecx+8]
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXPAUTRSortElement@@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN147@Insert_n@5:
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224555[ebp]
	call	??0TRSortElement@@QAE@ABU0@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	imul	edi, 448				; 000001c0H
	mov	ebx, DWORD PTR [esi+8]
	push	ebx
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv601[ebp], eax
	call	??$_Umove@PAUTRSortElement@@@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEPAUTRSortElement@@PAU2@00@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Umove<TRSortElement *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv601[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224555[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAUTRSortElement@@U1@@std@@YAXPAUTRSortElement@@0ABU1@@Z ; std::_Fill<TRSortElement *,TRSortElement>

; 1249 : 			}

	mov	eax, DWORD PTR __Tmp$224555[ebp+44]
	lea	ecx, DWORD PTR __Tmp$224555[ebp+56]
	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	cmp	eax, ecx
	je	SHORT $LN123@Insert_n@5
	push	eax
$LN144@Insert_n@5:
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN123@Insert_n@5:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN143@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224545[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224555[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z
_TEXT	SEGMENT
$T258760 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T258836 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ecx

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+16]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@2
	mov	ebp, edi
	shr	ebp, 5
	npad	7
$LL6@Buffered_m@2:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+16]
	push	ebx
	push	ecx
	lea	esi, DWORD PTR [eax+14336]
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@2
$LN4@Buffered_m@2:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	edx, DWORD PTR __Pred$[esp+16]
	mov	ecx, DWORD PTR __Last$[esp+16]
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@2
	mov	ebp, DWORD PTR __Tempbuf$[esp+16]
	npad	2
$LL3@Buffered_m@2:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+16]
	mov	eax, DWORD PTR [ebp+16]
	mov	ecx, DWORD PTR [eax]
	push	edx
	mov	DWORD PTR [eax+4], ecx
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+48]
	mov	ecx, DWORD PTR __First$[esp+48]
	mov	DWORD PTR $T258760[esp+52], esp
	push	eax
	push	ecx
	call	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+56]
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR $T258836[esp+56], bl
	mov	edx, DWORD PTR $T258836[esp+56]
	push	edx
	mov	edx, DWORD PTR __First$[esp+60]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
	add	esi, esi
	add	esp, 68					; 00000044H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@2
$LN1@Buffered_m@2:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
_TEXT	ENDS
PUBLIC	?MoveUnit@CvGameTrade@@QAE_NH@Z			; CvGameTrade::MoveUnit
EXTRN	?setMoves@CvUnit@@QAEXH@Z:PROC			; CvUnit::setMoves
EXTRN	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z:PROC ; CvUnit::UnitMove
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?MoveUnit@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
_iMoves$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?MoveUnit@CvGameTrade@@QAE_NH@Z PROC			; CvGameTrade::MoveUnit, COMDAT
; _this$ = ecx

; 1767 : {

	push	ecx
	push	ebx
	push	edi

; 1768 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1769 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	mov	edi, DWORD PTR _iIndex$[esp+8]
	mov	ebx, ecx
	test	edi, edi
	jl	$LN7@MoveUnit
	cmp	edi, DWORD PTR [ebx+4]
	jge	$LN7@MoveUnit

; 1772 : 	}
; 1773 : 
; 1774 : 	TradeConnection &kTradeConnection = m_aTradeConnections[iIndex];

	imul	edi, 444				; 000001bcH
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ebx]

; 1775 : 	int iMoves = GET_PLAYER(kTradeConnection.m_eOriginOwner).GetTrade()->GetTradeRouteSpeed(kTradeConnection.m_eDomain);

	mov	ecx, DWORD PTR [esi+edi+20]
	mov	ebp, DWORD PTR [esi+edi+28]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, edi
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	eax, ebp
	sub	eax, 0
	je	SHORT $LN18@MoveUnit
	sub	eax, 2
	je	SHORT $LN17@MoveUnit
	mov	DWORD PTR _iMoves$[esp+20], -1
	jmp	SHORT $LN21@MoveUnit
$LN17@MoveUnit:
	mov	DWORD PTR _iMoves$[esp+20], 2
	jmp	SHORT $LN21@MoveUnit
$LN18@MoveUnit:
	mov	DWORD PTR _iMoves$[esp+20], 4
$LN21@MoveUnit:

; 1776 : 	for (int i = 0; i < iMoves; i++)

	xor	ebp, ebp
	cmp	DWORD PTR _iMoves$[esp+20], ebp
	jle	SHORT $LN40@MoveUnit
	npad	1
$LL6@MoveUnit:

; 1777 : 	{
; 1778 : 		if (kTradeConnection.m_iCircuitsCompleted >= kTradeConnection.m_iCircuitsToComplete)

	mov	eax, DWORD PTR [esi+384]
	cmp	eax, DWORD PTR [esi+388]
	jge	SHORT $LN40@MoveUnit

; 1779 : 		{
; 1780 : 			break;
; 1781 : 		}
; 1782 : 
; 1783 : 		bool bAbleToStep = StepUnit(iIndex);

	mov	ecx, DWORD PTR _iIndex$[esp+16]
	push	ecx
	mov	ecx, ebx
	call	?StepUnit@CvGameTrade@@QAE_NH@Z		; CvGameTrade::StepUnit

; 1784 : 		if (!bAbleToStep)

	test	al, al
	je	SHORT $LN40@MoveUnit
	inc	ebp
	cmp	ebp, DWORD PTR _iMoves$[esp+20]
	jl	SHORT $LL6@MoveUnit
$LN40@MoveUnit:

; 1785 : 		{
; 1786 : 			break;
; 1787 : 		}
; 1788 : 	}
; 1789 : 
; 1790 : 	gDLL->TradeVisuals_UpdateRouteDirection(iIndex, kTradeConnection.m_bTradeUnitMovingForward);

	movzx	eax, BYTE PTR [esi+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _iIndex$[esp+16]
	mov	edx, DWORD PTR [edx+976]
	push	eax
	push	esi
	call	edx

; 1791 : 
; 1792 : 	// Send a NULL plot move to say we are complete to the vis unit.
; 1793 : 	CvUnit *pkUnit = GetVis(iIndex);

	cmp	esi, DWORD PTR [ebx+4]
	jge	SHORT $LN1@MoveUnit
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+edi+380]
	add	eax, edi
	cmp	edx, -1
	je	SHORT $LN1@MoveUnit
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax

; 1794 : 	if (pkUnit)

	test	esi, esi
	je	SHORT $LN1@MoveUnit

; 1795 : 	{
; 1796 : 		pkUnit->UnitMove(NULL, false, NULL);

	push	0
	push	0
	push	0
	push	0
	mov	ecx, esi
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove

; 1797 : 		pkUnit->setMoves(0);

	push	0
	mov	ecx, esi
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves
$LN1@MoveUnit:
	pop	esi
	pop	ebp
	pop	edi

; 1798 : 	}
; 1799 : 
; 1800 : 	return true;

	mov	al, 1
	pop	ebx

; 1801 : }

	pop	ecx
	ret	4
$LN7@MoveUnit:
	pop	edi

; 1770 : 	{
; 1771 : 		return false;

	xor	al, al
	pop	ebx

; 1801 : }

	pop	ecx
	ret	4
?MoveUnit@CvGameTrade@@QAE_NH@Z ENDP			; CvGameTrade::MoveUnit
_TEXT	ENDS
PUBLIC	?MoveUnits@CvPlayerTrade@@QAEXXZ		; CvPlayerTrade::MoveUnits
; Function compile flags: /Ogtpy
;	COMDAT ?MoveUnits@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ui$221154 = -8						; size = 4
tv313 = -4						; size = 4
?MoveUnits@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::MoveUnits, COMDAT
; _this$ = ecx

; 2297 : {

	sub	esp, 12					; 0000000cH
	push	ebp
	mov	DWORD PTR _this$[esp+16], ecx

; 2298 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 2299 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	xor	ebp, ebp
	mov	edi, eax
	mov	DWORD PTR _ui$221154[esp+20], ebp
	cmp	DWORD PTR [edi+4], ebp
	jbe	$LN3@MoveUnits
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR tv313[esp+28], ebx
	npad	3
$LL5@MoveUnits:

; 2300 : 	{
; 2301 : 		TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	esi, DWORD PTR [edi]

; 2302 : 		if (pTradeConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	eax, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [esi+ebx+20]
	add	esi, ebx
	cmp	edx, DWORD PTR [ecx+44]
	jne	$LN4@MoveUnits

; 2303 : 		{
; 2304 : 			pTrade->MoveUnit(ui);

	push	ebp
	mov	ecx, edi
	call	?MoveUnit@CvGameTrade@@QAE_NH@Z		; CvGameTrade::MoveUnit

; 2305 : 
; 2306 : 			// check to see if the trade route is still active but the circuit is completed
; 2307 : 			if (!pTrade->IsTradeRouteIndexEmpty(ui) && pTradeConnection->m_iCircuitsCompleted >= pTradeConnection->m_iCircuitsToComplete)

	mov	eax, DWORD PTR [edi]
	add	eax, ebx
	or	ecx, -1
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN19@MoveUnits
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN19@MoveUnits
	cmp	DWORD PTR [eax+12], ecx
	jne	SHORT $LN19@MoveUnits
	cmp	DWORD PTR [eax+16], ecx
	je	SHORT $LN4@MoveUnits
$LN19@MoveUnits:
	mov	ecx, DWORD PTR [esi+384]
	cmp	ecx, DWORD PTR [esi+388]
	jl	SHORT $LN4@MoveUnits

; 2308 : 			{
; 2309 : 				m_aRecentlyExpiredConnections.push_back(*pTradeConnection);

	mov	ecx, DWORD PTR _this$[esp+28]
	push	esi
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 2310 : 
; 2311 : 				// get data before we wipe the trade route
; 2312 : 				int iOriginX = pTradeConnection->m_iOriginX;
; 2313 : 				int iOriginY = pTradeConnection->m_iOriginY;
; 2314 : 				DomainTypes eDomain = pTradeConnection->m_eDomain;
; 2315 : 
; 2316 : 				// wipe trade route
; 2317 : 				pTrade->EmptyTradeRoute(ui);

	mov	edx, DWORD PTR _ui$221154[esp+28]
	mov	ebx, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+28]
	push	edx
	mov	ecx, edi
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute

; 2318 : 				
; 2319 : 				// create new unit
; 2320 : 				UnitTypes eUnitType = GetTradeUnit(eDomain);

	or	eax, -1
	cmp	esi, 2
	jne	SHORT $LN32@MoveUnits
	push	0
	push	OFFSET $SG222599
	jmp	SHORT $LN40@MoveUnits
$LN32@MoveUnits:
	test	esi, esi
	jne	SHORT $LN38@MoveUnits
	push	esi
	push	OFFSET $SG222603
$LN40@MoveUnits:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
$LN38@MoveUnits:

; 2321 : #ifdef CVASSERT_ENABLE
; 2322 : 				CvUnit* pRebornUnit = m_pPlayer->initUnit(eUnitType, iOriginX, iOriginY, UNITAI_TRADE_UNIT);
; 2323 : 
; 2324 : 				DEBUG_VARIABLE(pRebornUnit);
; 2325 : 				CvAssertMsg(pRebornUnit, "pRebornUnit is null. This is bad!!");
; 2326 : #else
; 2327 : 				m_pPlayer->initUnit(eUnitType, iOriginX, iOriginY, UNITAI_TRADE_UNIT);

	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	push	ebp
	push	ebx
	push	eax
	mov	eax, DWORD PTR _this$[esp+64]
	mov	ecx, DWORD PTR [eax+79104]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	ebp, DWORD PTR _ui$221154[esp+28]
	mov	ebx, DWORD PTR tv313[esp+28]
$LN4@MoveUnits:
	inc	ebp
	add	ebx, 444				; 000001bcH
	mov	DWORD PTR _ui$221154[esp+28], ebp
	mov	DWORD PTR tv313[esp+28], ebx
	cmp	ebp, DWORD PTR [edi+4]
	jb	$LL5@MoveUnits
	pop	esi
	pop	ebx
$LN3@MoveUnits:
	pop	edi
	pop	ebp

; 2328 : #endif
; 2329 : 			}
; 2330 : 		}
; 2331 : 	}
; 2332 : }

	add	esp, 12					; 0000000cH
	ret	0
?MoveUnits@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::MoveUnits
_TEXT	ENDS
PUBLIC	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumDifferentTradingPartners
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$0
__ehfuncinfo$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
_TEXT	SEGMENT
_ui$222530 = -84					; size = 4
tv953 = -80						; size = 4
_this$ = -76						; size = 4
_pTrade$ = -72						; size = 4
__Tmp$259309 = -68					; size = 8
__Tmp$259431 = -60					; size = 8
__Tmp$259574 = -52					; size = 8
__Tmp$259697 = -44					; size = 8
_abConnections$ = -36					; size = 20
__$EHRec$ = -12						; size = 12
?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ PROC ; CvPlayerTrade::GetNumDifferentTradingPartners, COMDAT
; _this$ = ecx

; 4320 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+100], ecx

; 4321 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 4322 : 
; 4323 : #ifdef AUI_TRADE_FIX_GET_NUM_DIFFERENT_TRADING_PARTNERS_USES_ARRAY
; 4324 : 	bool abConnections[MAX_CIV_PLAYERS] = {};
; 4325 : #else
; 4326 : 	std::vector<bool> abConnections;

	xor	edi, edi
	mov	esi, eax
	mov	DWORD PTR _pTrade$[esp+104], esi
	mov	DWORD PTR _abConnections$[esp+104], edi
	mov	DWORD PTR _abConnections$[esp+112], edi
	mov	DWORD PTR _abConnections$[esp+116], edi
	mov	DWORD PTR _abConnections$[esp+120], edi

; 4327 : 	abConnections.resize(MAX_CIV_PLAYERS, false);

	push	edi
	push	63					; 0000003fH
	lea	ecx, DWORD PTR _abConnections$[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], edi
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 4328 : #endif
; 4329 : 
; 4330 : 	int iResult = 0;
; 4331 : 
; 4332 : #ifdef AUI_ITERATORIZE
; 4333 : 	for (TradeConnectionList::const_iterator pTradeConnection = pTrade->m_aTradeConnections.begin(); pTradeConnection != pTrade->m_aTradeConnections.end(); ++pTradeConnection)
; 4334 : 	{
; 4335 : 		if (pTrade->IsTradeRouteIndexEmpty(pTradeConnection))
; 4336 : #else
; 4337 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	ebx, DWORD PTR _abConnections$[esp+112]
	xor	ebp, ebp
	mov	DWORD PTR _ui$222530[esp+104], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	$LN8@GetNumDiff
	xor	eax, eax
	mov	DWORD PTR tv953[esp+104], eax
$LL10@GetNumDiff:

; 4338 : 	{
; 4339 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR [esi]
	add	eax, ecx
	or	ecx, -1
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN64@GetNumDiff
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN64@GetNumDiff
	cmp	DWORD PTR [eax+12], ecx
	jne	SHORT $LN64@GetNumDiff
	cmp	DWORD PTR [eax+16], ecx
	je	$LN9@GetNumDiff
$LN64@GetNumDiff:

; 4340 : #endif
; 4341 : 		{
; 4342 : 			continue;
; 4343 : 		}
; 4344 : 
; 4345 : #ifndef AUI_ITERATORIZE
; 4346 : #ifdef AUI_CONSTIFY
; 4347 : 		const TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);
; 4348 : #else
; 4349 : 		TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);
; 4350 : #endif
; 4351 : #endif
; 4352 : 		if (pTradeConnection->m_eOriginOwner == pTradeConnection->m_eDestOwner)

	mov	esi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [eax+24]
	cmp	esi, edi
	je	$LN9@GetNumDiff

; 4353 : 		{
; 4354 : 			continue;
; 4355 : 		}
; 4356 : 
; 4357 : 		// this involves us
; 4358 : 		if (pTradeConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	edx, DWORD PTR _this$[esp+104]
	mov	eax, DWORD PTR [edx+79104]
	mov	eax, DWORD PTR [eax+44]
	cmp	esi, eax
	jne	SHORT $LN5@GetNumDiff

; 4359 : 		{
; 4360 : 			if (!abConnections[pTradeConnection->m_eDestOwner])

	xor	eax, eax
	push	edi
	lea	ecx, DWORD PTR __Tmp$259309[esp+108]
	mov	DWORD PTR __Tmp$259309[esp+108], ebx
	mov	DWORD PTR __Tmp$259309[esp+112], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$259309[esp+108]
	mov	eax, DWORD PTR __Tmp$259309[esp+104]
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [eax]
	jne	SHORT $LN9@GetNumDiff

; 4361 : 			{
; 4362 : 				abConnections[pTradeConnection->m_eDestOwner] = true;

	xor	eax, eax
	push	edi
	lea	ecx, DWORD PTR __Tmp$259431[esp+108]
	mov	DWORD PTR __Tmp$259431[esp+108], ebx
	mov	DWORD PTR __Tmp$259431[esp+112], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$259431[esp+108]
	mov	eax, DWORD PTR __Tmp$259431[esp+104]

; 4363 : 				iResult++;
; 4364 : 			}
; 4365 : 		}

	jmp	SHORT $LN246@GetNumDiff
$LN5@GetNumDiff:

; 4366 : 		else if (pTradeConnection->m_eDestOwner == m_pPlayer->GetID())

	cmp	edi, eax
	jne	SHORT $LN9@GetNumDiff

; 4367 : 		{
; 4368 : 			if (!abConnections[pTradeConnection->m_eOriginOwner])

	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$259574[esp+108]
	mov	DWORD PTR __Tmp$259574[esp+108], ebx
	mov	DWORD PTR __Tmp$259574[esp+112], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$259574[esp+108]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR __Tmp$259574[esp+104]
	test	eax, DWORD PTR [ecx]
	jne	SHORT $LN9@GetNumDiff

; 4369 : 			{
; 4370 : 				abConnections[pTradeConnection->m_eOriginOwner] = true;

	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$259697[esp+108]
	mov	DWORD PTR __Tmp$259697[esp+108], ebx
	mov	DWORD PTR __Tmp$259697[esp+112], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$259697[esp+108]
	mov	eax, DWORD PTR __Tmp$259697[esp+104]
$LN246@GetNumDiff:
	mov	edx, 1
	shl	edx, cl
	or	DWORD PTR [eax], edx

; 4371 : 				iResult++;

	inc	ebp
$LN9@GetNumDiff:
	mov	ecx, DWORD PTR _ui$222530[esp+104]
	mov	eax, DWORD PTR tv953[esp+104]
	mov	esi, DWORD PTR _pTrade$[esp+104]
	inc	ecx
	add	eax, 444				; 000001bcH
	mov	DWORD PTR _ui$222530[esp+104], ecx
	mov	DWORD PTR tv953[esp+104], eax
	cmp	ecx, DWORD PTR [esi+4]
	jb	$LL10@GetNumDiff

; 4328 : #endif
; 4329 : 
; 4330 : 	int iResult = 0;
; 4331 : 
; 4332 : #ifdef AUI_ITERATORIZE
; 4333 : 	for (TradeConnectionList::const_iterator pTradeConnection = pTrade->m_aTradeConnections.begin(); pTradeConnection != pTrade->m_aTradeConnections.end(); ++pTradeConnection)
; 4334 : 	{
; 4335 : 		if (pTrade->IsTradeRouteIndexEmpty(pTradeConnection))
; 4336 : #else
; 4337 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	xor	edi, edi
$LN8@GetNumDiff:

; 4372 : 			}
; 4373 : 		}
; 4374 : 	}
; 4375 : 
; 4376 : 	return iResult;

	cmp	ebx, edi
	je	SHORT $LN239@GetNumDiff
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN239@GetNumDiff:

; 4377 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	edi
	mov	eax, ebp
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$0:
	lea	ecx, DWORD PTR _abConnections$[ebp]
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ:
	mov	eax, OFFSET __ehfuncinfo$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ENDP ; CvPlayerTrade::GetNumDifferentTradingPartners
PUBLIC	?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ; CvPlayerTrade::GetPlotToolTips
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationAdjectiveKey
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_pDestCity$ = -332					; size = 4
_pOriginCity$ = -332					; size = 4
tv886 = -328						; size = 4
_uiPlotIndex$222641 = -324				; size = 4
_uiConnection$222626 = -320				; size = 4
_pTrade$ = -316						; size = 4
_iX$ = -312						; size = 4
_iY$ = -308						; size = 4
$T259807 = -304						; size = 4
_aToolTips$ = -300					; size = 16
_ePlayer$ = -284					; size = 4
$T259804 = -280						; size = 28
$T259786 = -280						; size = 28
$T259784 = -280						; size = 28
_strTradeLine$222660 = -252				; size = 80
$T259795 = -172						; size = 80
$T259787 = -172						; size = 80
_strTradeUnit$222655 = -172				; size = 80
_strTradeUnit$222648 = -172				; size = 80
_strResult$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z PROC ; CvPlayerTrade::GetPlotToolTips, COMDAT
; _this$ = ecx

; 4506 : {

	push	-1
	push	__ehhandler$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	ebp
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T259807[esp+344], ebx

; 4507 : 	std::vector<CvString> aToolTips;

	xor	ebp, ebp
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _aToolTips$[esp+352], ebp
	mov	DWORD PTR _aToolTips$[esp+356], ebx
	mov	DWORD PTR _aToolTips$[esp+360], ebx

; 4508 : 
; 4509 : 	if (!pPlot)

	mov	esi, DWORD PTR _pPlot$[esp+344]
	mov	DWORD PTR __$EHRec$[esp+356], 1
	cmp	esi, ebx
	jne	SHORT $LN20@GetPlotToo

; 4510 : 	{
; 4511 : 		return aToolTips;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+344]
	lea	eax, DWORD PTR _aToolTips$[esp+348]
	push	eax
	mov	ecx, esi
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	lea	ecx, DWORD PTR _aToolTips$[esp+348]
	mov	DWORD PTR $T259807[esp+348], 1
	mov	BYTE PTR __$EHRec$[esp+356], 0
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	mov	eax, esi
	jmp	$LN21@GetPlotToo
$LN20@GetPlotToo:

; 4512 : 	}
; 4513 : 
; 4514 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 4515 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	ecx, DWORD PTR [edi+79104]
	mov	edx, DWORD PTR [ecx+44]

; 4516 : 	int iX = pPlot->getX();
; 4517 : 	int iY = pPlot->getY();

	movsx	ecx, WORD PTR [esi+2]
	mov	DWORD PTR _pTrade$[esp+348], eax
	movsx	eax, WORD PTR [esi]
	mov	DWORD PTR _iY$[esp+348], ecx

; 4518 : 	CvCity* pOriginCity = NULL;
; 4519 : 	CvCity* pDestCity = NULL;
; 4520 : 
; 4521 : 	Localization::String strResult;

	lea	ecx, DWORD PTR _strResult$[esp+348]
	mov	DWORD PTR _ePlayer$[esp+348], edx
	mov	DWORD PTR _iX$[esp+348], eax
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 4522 : 
; 4523 : #ifdef AUI_ITERATORIZE
; 4524 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 4525 : 	{
; 4526 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 4527 : #else
; 4528 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	edx, DWORD PTR _pTrade$[esp+348]
	cmp	DWORD PTR [edx+4], 0
	mov	BYTE PTR __$EHRec$[esp+356], 2
	mov	DWORD PTR _uiConnection$222626[esp+348], 0
	jbe	$LN17@GetPlotToo
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	ebp, DWORD PTR _iY$[esp+348]
	mov	edx, DWORD PTR _iX$[esp+348]
	or	ebx, -1
	npad	11
$LL301@GetPlotToo:

; 4529 : 	{
; 4530 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	mov	eax, DWORD PTR _uiConnection$222626[esp+348]
	mov	ecx, DWORD PTR _pTrade$[esp+348]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR [ecx]
	lea	esi, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv886[esp+348], esi
	cmp	DWORD PTR [esi+4], ebx
	jne	SHORT $LN95@GetPlotToo
	cmp	DWORD PTR [esi+8], ebx
	jne	SHORT $LN95@GetPlotToo
	cmp	DWORD PTR [esi+12], ebx
	jne	SHORT $LN95@GetPlotToo
	cmp	DWORD PTR [esi+16], ebx
	je	$LN18@GetPlotToo
$LN95@GetPlotToo:

; 4531 : #endif
; 4532 : 		{
; 4533 : 			continue;
; 4534 : 		}
; 4535 : 
; 4536 : #ifndef AUI_ITERATORIZE
; 4537 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);
; 4538 : #endif
; 4539 : 
; 4540 : 		bool bDisplayInfo = false;
; 4541 : 		if (pConnection->m_eOriginOwner == ePlayer || pConnection->m_eDestOwner == ePlayer)

	mov	eax, DWORD PTR _ePlayer$[esp+348]
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN14@GetPlotToo
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN14@GetPlotToo

; 4542 : 		{
; 4543 : 			bDisplayInfo = true;
; 4544 : 		}
; 4545 : 		else
; 4546 : 		{
; 4547 : 			int iTradeUnitIndex = pConnection->m_iTradeUnitLocationIndex;
; 4548 : 			int iTradeUnitX = pConnection->m_aPlotList[iTradeUnitIndex].m_iX;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+36]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [eax]

; 4549 : 			int iTradeUnitY = pConnection->m_aPlotList[iTradeUnitIndex].m_iY;

	mov	eax, DWORD PTR [eax+4]

; 4550 : 			if (iTradeUnitX == iX && iTradeUnitY == iY)

	cmp	ecx, edx
	jne	$LN18@GetPlotToo
	cmp	eax, ebp
	jne	$LN18@GetPlotToo
$LN14@GetPlotToo:

; 4551 : 			{
; 4552 : 				bDisplayInfo = true;
; 4553 : 			}
; 4554 : 		}
; 4555 : 
; 4556 : 		// if this trade route involves us
; 4557 : 		if (bDisplayInfo)
; 4558 : 		{
; 4559 : 			for (uint uiPlotIndex = 0; uiPlotIndex < pConnection->m_aPlotList.size(); uiPlotIndex++)

	xor	ecx, ecx
	mov	DWORD PTR _uiPlotIndex$222641[esp+348], ecx
	cmp	DWORD PTR [esi+48], ecx
	jbe	$LN18@GetPlotToo
	npad	6
$LL10@GetPlotToo:
	mov	eax, DWORD PTR [esi+44]

; 4560 : 			{
; 4561 : 				if (pConnection->m_aPlotList[uiPlotIndex].m_iX == iX && pConnection->m_aPlotList[uiPlotIndex].m_iY == iY)

	cmp	DWORD PTR [eax+ecx*8], edx
	lea	eax, DWORD PTR [eax+ecx*8]
	jne	$LN9@GetPlotToo
	cmp	DWORD PTR [eax+4], ebp
	jne	$LN9@GetPlotToo

; 4562 : 				{
; 4563 : 					pOriginCity = GC.getMap().plot(pConnection->m_iOriginX, pConnection->m_iOriginY)->getPlotCity();

	mov	eax, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, -2147483647			; 80000001H
	je	$LN120@GetPlotToo
	cmp	ebp, -2147483647			; 80000001H
	je	$LN120@GetPlotToo
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN130@GetPlotToo
	test	eax, eax
	jge	SHORT $LN132@GetPlotToo
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN134@GetPlotToo
$LN132@GetPlotToo:
	cmp	eax, ecx
	jl	SHORT $LN130@GetPlotToo
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN134@GetPlotToo
$LN130@GetPlotToo:
	mov	esi, eax
$LN134@GetPlotToo:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN140@GetPlotToo
	test	ebp, ebp
	jge	SHORT $LN142@GetPlotToo
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN144@GetPlotToo
$LN142@GetPlotToo:
	cmp	ebp, edi
	jl	SHORT $LN140@GetPlotToo
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN144@GetPlotToo
$LN140@GetPlotToo:
	mov	edx, ebp
$LN144@GetPlotToo:
	test	esi, esi
	jl	SHORT $LN124@GetPlotToo
	cmp	esi, ecx
	jge	SHORT $LN124@GetPlotToo
	test	edx, edx
	jl	SHORT $LN124@GetPlotToo
	cmp	edx, edi
	jge	SHORT $LN124@GetPlotToo
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR tv886[esp+348]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN122@GetPlotToo
$LN124@GetPlotToo:
	mov	esi, DWORD PTR tv886[esp+348]
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
$LN120@GetPlotToo:
	xor	ecx, ecx
$LN122@GetPlotToo:
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN158@GetPlotToo
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN158@GetPlotToo
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _pOriginCity$[esp+348], eax
	jmp	SHORT $LN159@GetPlotToo
$LN158@GetPlotToo:
	mov	DWORD PTR _pOriginCity$[esp+348], 0
$LN159@GetPlotToo:

; 4564 : 					pDestCity = GC.getMap().plot(pConnection->m_iDestX, pConnection->m_iDestY)->getPlotCity();

	mov	eax, DWORD PTR [esi+12]
	mov	ebp, DWORD PTR [esi+16]
	cmp	eax, -2147483647			; 80000001H
	je	$LN165@GetPlotToo
	cmp	ebp, -2147483647			; 80000001H
	je	$LN165@GetPlotToo
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN175@GetPlotToo
	test	eax, eax
	jge	SHORT $LN177@GetPlotToo
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN179@GetPlotToo
$LN177@GetPlotToo:
	cmp	eax, ecx
	jl	SHORT $LN175@GetPlotToo
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN179@GetPlotToo
$LN175@GetPlotToo:
	mov	esi, eax
$LN179@GetPlotToo:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN185@GetPlotToo
	test	ebp, ebp
	jge	SHORT $LN187@GetPlotToo
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN189@GetPlotToo
$LN187@GetPlotToo:
	cmp	ebp, edi
	jl	SHORT $LN185@GetPlotToo
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN189@GetPlotToo
$LN185@GetPlotToo:
	mov	edx, ebp
$LN189@GetPlotToo:
	test	esi, esi
	jl	SHORT $LN169@GetPlotToo
	cmp	esi, ecx
	jge	SHORT $LN169@GetPlotToo
	test	edx, edx
	jl	SHORT $LN169@GetPlotToo
	cmp	edx, edi
	jge	SHORT $LN169@GetPlotToo
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR tv886[esp+348]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN304@GetPlotToo
$LN169@GetPlotToo:
	mov	esi, DWORD PTR tv886[esp+348]
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
$LN165@GetPlotToo:
	xor	ecx, ecx
$LN304@GetPlotToo:
	mov	eax, DWORD PTR [ecx+104]
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	ebp, DWORD PTR _pOriginCity$[esp+348]
	test	eax, eax
	jl	SHORT $LN203@GetPlotToo
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN203@GetPlotToo
	mov	edx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pDestCity$[esp+348], eax
	jmp	SHORT $LN204@GetPlotToo
$LN203@GetPlotToo:
	mov	DWORD PTR _pDestCity$[esp+348], 0
$LN204@GetPlotToo:

; 4565 : 
; 4566 : 					// Trade Routes:
; 4567 : 					// (if major to major)
; 4568 : 					// Kyoto (Japan) ~~ London (England)
; 4569 : 					// (if major to minor)
; 4570 : 					// Kyoto (Japan) ~~ Monaco (City-State)
; 4571 : 
; 4572 : 					if (uiPlotIndex == pConnection->m_iTradeUnitLocationIndex)

	mov	eax, DWORD PTR _uiPlotIndex$222641[esp+348]
	cmp	eax, DWORD PTR [esi+36]
	jne	$LN3@GetPlotToo

; 4573 : 					{
; 4574 : 						if (pConnection->m_eDomain == DOMAIN_LAND)

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, 2
	jne	SHORT $LN5@GetPlotToo

; 4575 : 						{
; 4576 : 							Localization::String strTradeUnit = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_CARAVAN");

	lea	ecx, DWORD PTR _strTradeUnit$222648[esp+348]
	push	OFFSET $SG222650
	push	ecx
	call	ebx
	add	esp, 8

; 4577 : 							strTradeUnit << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+356], 3
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strTradeUnit$222648[esp+352]
	call	edi

; 4578 : 							aToolTips.push_back(strTradeUnit.toUTF8());

	lea	ecx, DWORD PTR _strTradeUnit$222648[esp+348]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN215@GetPlotToo
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN215@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR $T259784[esp+352]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR $T259784[esp+348]
	push	edx
	lea	ecx, DWORD PTR _aToolTips$[esp+352]
	mov	BYTE PTR __$EHRec$[esp+360], 4
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	mov	BYTE PTR __$EHRec$[esp+356], 3

; 4579 : 						}

	jmp	SHORT $LN305@GetPlotToo
$LN5@GetPlotToo:

; 4580 : 						else if (pConnection->m_eDomain == DOMAIN_SEA)

	test	eax, eax
	jne	$LN3@GetPlotToo

; 4581 : 						{
; 4582 : 							Localization::String strTradeUnit = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_CARGO_SHIP");

	lea	eax, DWORD PTR _strTradeUnit$222655[esp+348]
	push	OFFSET $SG222657
	push	eax
	call	ebx
	add	esp, 8

; 4583 : 							strTradeUnit << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+356], 5
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strTradeUnit$222655[esp+352]
	call	edi

; 4584 : 							aToolTips.push_back(strTradeUnit.toUTF8());

	lea	ecx, DWORD PTR _strTradeUnit$222655[esp+348]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN227@GetPlotToo
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN227@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR $T259786[esp+352]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T259786[esp+348]
	push	ecx
	lea	ecx, DWORD PTR _aToolTips$[esp+352]
	mov	BYTE PTR __$EHRec$[esp+360], 6
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	mov	BYTE PTR __$EHRec$[esp+356], 5
$LN305@GetPlotToo:
	lea	ecx, DWORD PTR $T259786[esp+348]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4585 : 						}

	lea	ecx, DWORD PTR _strTradeUnit$222655[esp+348]
	mov	BYTE PTR __$EHRec$[esp+356], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN3@GetPlotToo:

; 4586 : 					}
; 4587 : 
; 4588 : 					Localization::String strTradeLine;

	lea	ecx, DWORD PTR _strTradeLine$222660[esp+348]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 4589 : 
; 4590 : 					if (GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv()) // if a minor civ, have a special help text

	mov	ecx, DWORD PTR [esi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+356], 7
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN2@GetPlotToo

; 4591 : 					{
; 4592 : 						strTradeLine = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJOR_MINOR");

	lea	edx, DWORD PTR $T259787[esp+348]
	push	OFFSET $SG222663
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	mov	BYTE PTR __$EHRec$[esp+360], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T259787[esp+348]
	mov	BYTE PTR __$EHRec$[esp+356], 7
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4593 : 						strTradeLine << ((pOriginCity)?pOriginCity->getNameKey():"NULL Origin City");

	test	ebp, ebp
	je	SHORT $LN23@GetPlotToo
	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	jmp	SHORT $LN24@GetPlotToo
$LN23@GetPlotToo:
	mov	eax, OFFSET $SG222665
$LN24@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	call	edi

; 4594 : 						strTradeLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	call	edi

; 4595 : 						strTradeLine << ((pDestCity)?pDestCity->getNameKey():"NULL Dest City");

	mov	ecx, DWORD PTR _pDestCity$[esp+348]
	test	ecx, ecx
	je	SHORT $LN25@GetPlotToo
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	jmp	$LN26@GetPlotToo
$LN25@GetPlotToo:
	mov	eax, OFFSET $SG222668

; 4596 : 					}
; 4597 : 					else

	jmp	$LN26@GetPlotToo
$LN2@GetPlotToo:

; 4598 : 					{
; 4599 : 						strTradeLine = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJOR_MAJOR");

	lea	eax, DWORD PTR $T259795[esp+348]
	push	OFFSET $SG222671
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	mov	BYTE PTR __$EHRec$[esp+360], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T259795[esp+348]
	mov	BYTE PTR __$EHRec$[esp+356], 7
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4600 : 						strTradeLine << ((pOriginCity)?pOriginCity->getNameKey():"NULL Origin City");

	test	ebp, ebp
	je	SHORT $LN27@GetPlotToo
	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	jmp	SHORT $LN28@GetPlotToo
$LN27@GetPlotToo:
	mov	eax, OFFSET $SG222673
$LN28@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	call	edi

; 4601 : 						strTradeLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	call	edi

; 4602 : 						strTradeLine << ((pDestCity)?pDestCity->getNameKey():"NULL Dest City");

	mov	ecx, DWORD PTR _pDestCity$[esp+348]
	test	ecx, ecx
	je	SHORT $LN29@GetPlotToo
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	jmp	SHORT $LN30@GetPlotToo
$LN29@GetPlotToo:
	mov	eax, OFFSET $SG222676
$LN30@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	call	edi

; 4603 : 
; 4604 : 						strTradeLine << GET_PLAYER(pConnection->m_eDestOwner).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [esi+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
$LN26@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$222660[esp+352]
	call	edi

; 4605 : 					}
; 4606 : 
; 4607 : 					aToolTips.push_back(strTradeLine.toUTF8());

	lea	ecx, DWORD PTR _strTradeLine$222660[esp+348]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN257@GetPlotToo
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN257@GetPlotToo:
	push	eax
	lea	ecx, DWORD PTR $T259804[esp+352]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T259804[esp+348]
	push	ecx
	lea	ecx, DWORD PTR _aToolTips$[esp+352]
	mov	BYTE PTR __$EHRec$[esp+360], 10		; 0000000aH
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	lea	ecx, DWORD PTR $T259804[esp+348]
	mov	BYTE PTR __$EHRec$[esp+356], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4608 : 				}

	lea	ecx, DWORD PTR _strTradeLine$222660[esp+348]
	mov	BYTE PTR __$EHRec$[esp+356], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR _iY$[esp+348]
	mov	edx, DWORD PTR _iX$[esp+348]
	mov	ecx, DWORD PTR _uiPlotIndex$222641[esp+348]
	or	ebx, -1
$LN9@GetPlotToo:
	inc	ecx
	mov	DWORD PTR _uiPlotIndex$222641[esp+348], ecx
	cmp	ecx, DWORD PTR [esi+48]
	jb	$LL10@GetPlotToo
$LN18@GetPlotToo:

; 4522 : 
; 4523 : #ifdef AUI_ITERATORIZE
; 4524 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 4525 : 	{
; 4526 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 4527 : #else
; 4528 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	eax, DWORD PTR _uiConnection$222626[esp+348]
	mov	ecx, DWORD PTR _pTrade$[esp+348]
	inc	eax
	mov	DWORD PTR _uiConnection$222626[esp+348], eax
	cmp	eax, DWORD PTR [ecx+4]
	jb	$LL301@GetPlotToo
	mov	ebx, DWORD PTR _aToolTips$[esp+356]
	mov	ebp, DWORD PTR _aToolTips$[esp+352]
$LN17@GetPlotToo:

; 4609 : 			}
; 4610 : 		}
; 4611 : 	}
; 4612 : 
; 4613 : 	return aToolTips;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+344]
	lea	edx, DWORD PTR _aToolTips$[esp+348]
	push	edx
	mov	ecx, edi
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	lea	ecx, DWORD PTR _strResult$[esp+348]
	mov	DWORD PTR $T259807[esp+348], 1
	mov	BYTE PTR __$EHRec$[esp+356], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+356], 0
	test	ebp, ebp
	je	SHORT $LN288@GetPlotToo
	mov	esi, ebp
	cmp	ebp, ebx
	je	SHORT $LN273@GetPlotToo
$LL275@GetPlotToo:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL275@GetPlotToo
$LN273@GetPlotToo:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN288@GetPlotToo:
	mov	eax, edi
$LN21@GetPlotToo:

; 4614 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+348]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 332				; 0000014cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1:
	mov	eax, DWORD PTR $T259807[ebp]
	and	eax, 1
	je	$LN33@GetPlotToo
	and	DWORD PTR $T259807[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
$LN33@GetPlotToo:
	ret	0
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strTradeUnit$222648[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T259784[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5:
	lea	ecx, DWORD PTR _strTradeUnit$222655[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR $T259786[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7:
	lea	ecx, DWORD PTR _strTradeLine$222660[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR $T259787[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$9:
	lea	ecx, DWORD PTR $T259795[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$10:
	lea	ecx, DWORD PTR $T259804[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ENDP ; CvPlayerTrade::GetPlotToolTips
PUBLIC	?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ; CvPlayerTrade::GetPlotMouseoverToolTips
EXTRN	__imp_??4String@Localization@@QAEAAV01@PBD@Z:PROC
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_uiPlotIndex$222716 = -408				; size = 4
tv1330 = -404						; size = 4
$T260547 = -400						; size = 4
_uiConnection$222701 = -396				; size = 4
_pTrade$ = -392						; size = 4
_iY$ = -388						; size = 4
_iX$ = -384						; size = 4
_aToolTips$ = -380					; size = 16
_ePlayer$ = -364					; size = 4
_strLine$222722 = -360					; size = 80
_strColorString$222735 = -280				; size = 80
$T260544 = -200						; size = 28
$T260541 = -172						; size = 80
$T260537 = -172						; size = 80
_strResult$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z PROC ; CvPlayerTrade::GetPlotMouseoverToolTips, COMDAT
; _this$ = ecx

; 4622 : {

	push	-1
	push	__ehhandler$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	ebp
	xor	ebp, ebp
	push	esi
	mov	DWORD PTR $T260547[esp+420], ebp
	push	edi
	mov	edi, ecx

; 4623 : 	std::vector<CvString> aToolTips;

	mov	DWORD PTR _aToolTips$[esp+428], ebp
	mov	DWORD PTR _aToolTips$[esp+432], ebp
	mov	DWORD PTR _aToolTips$[esp+436], ebp

; 4624 : 
; 4625 : 	if (!pPlot)

	mov	esi, DWORD PTR _pPlot$[esp+420]
	mov	ebx, 1
	mov	DWORD PTR __$EHRec$[esp+432], ebx
	cmp	esi, ebp
	jne	SHORT $LN21@GetPlotMou

; 4626 : 	{
; 4627 : 		return aToolTips;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+420]
	lea	eax, DWORD PTR _aToolTips$[esp+424]
	push	eax
	mov	ecx, esi
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	lea	ecx, DWORD PTR _aToolTips$[esp+424]
	mov	DWORD PTR $T260547[esp+424], ebx
	mov	BYTE PTR __$EHRec$[esp+432], 0
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	mov	eax, esi
	jmp	$LN22@GetPlotMou
$LN21@GetPlotMou:

; 4628 : 	}
; 4629 : 
; 4630 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 4631 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	ecx, DWORD PTR [edi+79104]
	mov	edx, DWORD PTR [ecx+44]

; 4632 : 	int iX = pPlot->getX();
; 4633 : 	int iY = pPlot->getY();

	movsx	ecx, WORD PTR [esi+2]
	mov	ebx, eax
	movsx	eax, WORD PTR [esi]
	mov	DWORD PTR _iY$[esp+424], ecx

; 4634 : 	CvCity* pOriginCity = NULL;
; 4635 : 	CvCity* pDestCity = NULL;
; 4636 : 
; 4637 : 	Localization::String strResult;

	lea	ecx, DWORD PTR _strResult$[esp+424]
	mov	DWORD PTR _pTrade$[esp+424], ebx
	mov	DWORD PTR _ePlayer$[esp+424], edx
	mov	DWORD PTR _iX$[esp+424], eax
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+432], 2

; 4638 : 
; 4639 : #ifdef AUI_ITERATORIZE
; 4640 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 4641 : 	{
; 4642 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 4643 : #else
; 4644 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$222701[esp+424], ebp
	cmp	DWORD PTR [ebx+4], ebp
	jbe	$LN18@GetPlotMou

; 4628 : 	}
; 4629 : 
; 4630 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	DWORD PTR tv1330[esp+424], 0
$LL20@GetPlotMou:

; 4645 : 	{
; 4646 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	mov	edx, DWORD PTR _pTrade$[esp+424]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1330[esp+424]
	lea	esi, DWORD PTR [eax+ecx]
	or	eax, -1
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN85@GetPlotMou
	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN85@GetPlotMou
	cmp	DWORD PTR [esi+12], eax
	jne	SHORT $LN85@GetPlotMou
	cmp	DWORD PTR [esi+16], eax
	je	$LN19@GetPlotMou
$LN85@GetPlotMou:

; 4647 : #endif
; 4648 : 		{
; 4649 : 			continue;
; 4650 : 		}
; 4651 : 
; 4652 : #ifndef AUI_ITERATORIZE
; 4653 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);
; 4654 : #endif
; 4655 : 
; 4656 : 		bool bDisplayInfo = false;
; 4657 : 		if (pConnection->m_eOriginOwner == ePlayer || pConnection->m_eDestOwner == ePlayer)

	mov	eax, DWORD PTR _ePlayer$[esp+424]
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN15@GetPlotMou
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN15@GetPlotMou

; 4658 : 		{
; 4659 : 			bDisplayInfo = true;
; 4660 : 		}
; 4661 : 		else
; 4662 : 		{
; 4663 : 			int iTradeUnitIndex = pConnection->m_iTradeUnitLocationIndex;

	mov	eax, DWORD PTR [esi+36]

; 4664 : 			int iTradeUnitX = pConnection->m_aPlotList[iTradeUnitIndex].m_iX;

	mov	edx, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [edx+eax*8]
	lea	eax, DWORD PTR [edx+eax*8]

; 4665 : 			int iTradeUnitY = pConnection->m_aPlotList[iTradeUnitIndex].m_iY;

	mov	eax, DWORD PTR [eax+4]

; 4666 : 			if (iTradeUnitX == iX && iTradeUnitY == iY)

	cmp	ecx, DWORD PTR _iX$[esp+424]
	jne	$LN19@GetPlotMou
	cmp	eax, DWORD PTR _iY$[esp+424]
	jne	$LN19@GetPlotMou
$LN15@GetPlotMou:

; 4667 : 			{
; 4668 : 				bDisplayInfo = true;
; 4669 : 			}
; 4670 : 		}
; 4671 : 
; 4672 : 		// if this trade route involves us
; 4673 : 		if (bDisplayInfo)
; 4674 : 		{
; 4675 : 			for (uint uiPlotIndex = 0; uiPlotIndex < pConnection->m_aPlotList.size(); uiPlotIndex++)

	cmp	DWORD PTR [esi+48], 0
	mov	DWORD PTR _uiPlotIndex$222716[esp+424], 0
	jbe	$LN19@GetPlotMou
	npad	5
$LL11@GetPlotMou:
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uiPlotIndex$222716[esp+424]

; 4676 : 			{
; 4677 : 				if (pConnection->m_aPlotList[uiPlotIndex].m_iX == iX && pConnection->m_aPlotList[uiPlotIndex].m_iY == iY)

	mov	edx, DWORD PTR _iX$[esp+424]
	cmp	DWORD PTR [eax+ecx*8], edx
	lea	eax, DWORD PTR [eax+ecx*8]
	jne	$LN10@GetPlotMou
	mov	ecx, DWORD PTR _iY$[esp+424]
	cmp	DWORD PTR [eax+4], ecx
	jne	$LN10@GetPlotMou

; 4678 : 				{
; 4679 : 					pOriginCity = GC.getMap().plot(pConnection->m_iOriginX, pConnection->m_iOriginY)->getPlotCity();

	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN110@GetPlotMou
	cmp	ebx, -2147483647			; 80000001H
	je	$LN110@GetPlotMou
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN293@GetPlotMou
	test	eax, eax
	jge	SHORT $LN122@GetPlotMou
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN124@GetPlotMou
$LN122@GetPlotMou:
	cmp	eax, ecx
	jl	SHORT $LN293@GetPlotMou
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN124@GetPlotMou
$LN293@GetPlotMou:
	mov	edi, eax
$LN124@GetPlotMou:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebp, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN294@GetPlotMou
	test	ebx, ebx
	jge	SHORT $LN132@GetPlotMou
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN134@GetPlotMou
$LN132@GetPlotMou:
	cmp	ebx, ebp
	jl	SHORT $LN294@GetPlotMou
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN134@GetPlotMou
$LN294@GetPlotMou:
	mov	edx, ebx
$LN134@GetPlotMou:
	test	edi, edi
	jl	SHORT $LN110@GetPlotMou
	cmp	edi, ecx
	jge	SHORT $LN110@GetPlotMou
	test	edx, edx
	jl	SHORT $LN110@GetPlotMou
	cmp	edx, ebp
	jge	SHORT $LN110@GetPlotMou
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN112@GetPlotMou
$LN110@GetPlotMou:
	xor	ecx, ecx
$LN112@GetPlotMou:
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN148@GetPlotMou
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN148@GetPlotMou
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
$LN148@GetPlotMou:

; 4680 : 					pDestCity = GC.getMap().plot(pConnection->m_iDestX, pConnection->m_iDestY)->getPlotCity();

	mov	eax, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi+16]
	cmp	eax, -2147483647			; 80000001H
	je	$LN155@GetPlotMou
	cmp	ebx, -2147483647			; 80000001H
	je	$LN155@GetPlotMou
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN165@GetPlotMou
	test	eax, eax
	jge	SHORT $LN167@GetPlotMou
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN169@GetPlotMou
$LN167@GetPlotMou:
	cmp	eax, ecx
	jl	SHORT $LN165@GetPlotMou
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN169@GetPlotMou
$LN165@GetPlotMou:
	mov	edi, eax
$LN169@GetPlotMou:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN175@GetPlotMou
	test	ebx, ebx
	jge	SHORT $LN177@GetPlotMou
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN179@GetPlotMou
$LN177@GetPlotMou:
	cmp	ebx, ebp
	jl	SHORT $LN175@GetPlotMou
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN179@GetPlotMou
$LN175@GetPlotMou:
	mov	edx, ebx
$LN179@GetPlotMou:
	test	edi, edi
	jl	SHORT $LN155@GetPlotMou
	cmp	edi, ecx
	jge	SHORT $LN155@GetPlotMou
	test	edx, edx
	jl	SHORT $LN155@GetPlotMou
	cmp	edx, ebp
	jge	SHORT $LN155@GetPlotMou
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN157@GetPlotMou
$LN155@GetPlotMou:
	xor	ecx, ecx
$LN157@GetPlotMou:
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN193@GetPlotMou
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN193@GetPlotMou
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
$LN193@GetPlotMou:

; 4681 : 					if (uiPlotIndex == pConnection->m_iTradeUnitLocationIndex)

	mov	edx, DWORD PTR _uiPlotIndex$222716[esp+424]
	cmp	edx, DWORD PTR [esi+36]
	jne	$LN10@GetPlotMou

; 4682 : 					{
; 4683 : #ifdef AUI_WARNING_FIXES
; 4684 : 						CvUnitEntry* pTradeUnitInfo = GC.getUnitInfo(GetTradeUnit(pConnection->m_eDomain));
; 4685 : #endif
; 4686 : 						Localization::String strLine;

	mov	ebp, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strLine$222722[esp+424]
	call	ebp

; 4687 : 						if(strcmp(GET_PLAYER(pConnection->m_eOriginOwner).getNickName(), "") != 0)

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+432], 3
	mov	edi, OFFSET $SG222724
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	npad	2
$LL289@GetPlotMou:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN290@GetPlotMou
	test	cl, cl
	je	SHORT $LN291@GetPlotMou
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN290@GetPlotMou
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL289@GetPlotMou
$LN291@GetPlotMou:
	xor	eax, eax
	jmp	SHORT $LN292@GetPlotMou
$LN290@GetPlotMou:
	sbb	eax, eax
	sbb	eax, -1
$LN292@GetPlotMou:
	test	eax, eax
	je	$LN6@GetPlotMou

; 4688 : 						{
; 4689 : 							strLine = Localization::Lookup("TXT_KEY_MULTIPLAYER_UNIT_TT");

	lea	eax, DWORD PTR $T260537[esp+424]
	push	OFFSET $SG222726
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strLine$222722[esp+428]
	mov	BYTE PTR __$EHRec$[esp+436], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T260537[esp+424]
	mov	BYTE PTR __$EHRec$[esp+432], 3
	call	ebx

; 4690 : 							strLine << GET_PLAYER(pConnection->m_eOriginOwner).getNickName();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strLine$222722[esp+428]
	call	edi

; 4691 : 							strLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strLine$222722[esp+428]
	call	edi

; 4692 : #ifdef AUI_WARNING_FIXES
; 4693 : 							if (pTradeUnitInfo)
; 4694 : 								strLine << pTradeUnitInfo->GetDescription();
; 4695 : #else
; 4696 : 							strLine << GC.getUnitInfo(GetTradeUnit(pConnection->m_eDomain))->GetDescription();

	mov	ecx, DWORD PTR [esi+28]
	push	ecx

; 4697 : #endif
; 4698 : 						}
; 4699 : 						else

	jmp	SHORT $LN296@GetPlotMou
$LN6@GetPlotMou:

; 4700 : 						{
; 4701 : 							strLine = Localization::Lookup("TXT_KEY_PLOTROLL_UNIT_DESCRIPTION_CIV");

	lea	edx, DWORD PTR $T260541[esp+424]
	push	OFFSET $SG222732
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strLine$222722[esp+428]
	mov	BYTE PTR __$EHRec$[esp+436], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T260541[esp+424]
	mov	BYTE PTR __$EHRec$[esp+432], 3
	call	ebx

; 4702 : 							strLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strLine$222722[esp+428]
	call	edi

; 4703 : #ifdef AUI_WARNING_FIXES
; 4704 : 							if (pTradeUnitInfo)
; 4705 : 								strLine << pTradeUnitInfo->GetDescription();
; 4706 : #else
; 4707 : 							strLine << GC.getUnitInfo(GetTradeUnit(pConnection->m_eDomain))->GetDescription();

	mov	eax, DWORD PTR [esi+28]
	push	eax
$LN296@GetPlotMou:
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLine$222722[esp+428]
	call	edi

; 4708 : #endif
; 4709 : 						}
; 4710 : 
; 4711 : 						
; 4712 : 						Localization::String strColorString;

	lea	ecx, DWORD PTR _strColorString$222735[esp+424]
	call	ebp

; 4713 : 						TeamTypes eTeam = GET_PLAYER(pConnection->m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+edx+44]
	mov	BYTE PTR __$EHRec$[esp+432], 6
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN226@GetPlotMou
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN227@GetPlotMou
$LN226@GetPlotMou:
	or	edi, -1
$LN227@GetPlotMou:

; 4714 : 						if (eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN4@GetPlotMou

; 4715 : 						{
; 4716 : 							strColorString = "[COLOR_WHITE]{1_InnerStr}[ENDCOLOR]";

	push	OFFSET $SG222738
	lea	ecx, DWORD PTR _strColorString$222735[esp+428]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z

; 4717 : 							strColorString << strLine;

	lea	eax, DWORD PTR _strLine$222722[esp+424]
	push	eax
	jmp	SHORT $LN297@GetPlotMou
$LN4@GetPlotMou:

; 4718 : 						}
; 4719 : 						else if (GET_TEAM(GC.getGame().getActiveTeam()).isAtWar(eTeam))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar

; 4720 : 						{
; 4721 : 							strColorString = "[COLOR_NEGATIVE_TEXT]{1_InnerStr}[ENDCOLOR]";

	lea	ecx, DWORD PTR _strColorString$222735[esp+424]
	test	al, al
	je	SHORT $LN2@GetPlotMou
	push	OFFSET $SG222746
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z

; 4722 : 							strColorString << strLine;

	lea	ecx, DWORD PTR _strLine$222722[esp+424]
	push	ecx

; 4723 : 						}
; 4724 : 						else

	jmp	SHORT $LN297@GetPlotMou
$LN2@GetPlotMou:

; 4725 : 						{
; 4726 : 							strColorString = "[COLOR_POSITIVE_TEXT]{1_InnerStr}[ENDCOLOR]";

	push	OFFSET $SG222748
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z

; 4727 : 							strColorString << strLine;

	lea	edx, DWORD PTR _strLine$222722[esp+424]
	push	edx
$LN297@GetPlotMou:
	lea	ecx, DWORD PTR _strColorString$222735[esp+428]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NABV12@@Z

; 4728 : 						}
; 4729 : 
; 4730 : 						aToolTips.push_back(strColorString.toUTF8());

	lea	ecx, DWORD PTR _strColorString$222735[esp+424]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN246@GetPlotMou
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN246@GetPlotMou:
	push	eax
	lea	ecx, DWORD PTR $T260544[esp+428]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T260544[esp+424]
	push	eax
	lea	ecx, DWORD PTR _aToolTips$[esp+428]
	mov	BYTE PTR __$EHRec$[esp+436], 7
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	lea	ecx, DWORD PTR $T260544[esp+424]
	mov	BYTE PTR __$EHRec$[esp+432], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4731 : 					}

	lea	ecx, DWORD PTR _strColorString$222735[esp+424]
	mov	BYTE PTR __$EHRec$[esp+432], 3
	call	ebx
	lea	ecx, DWORD PTR _strLine$222722[esp+424]
	mov	BYTE PTR __$EHRec$[esp+432], 2
	call	ebx
$LN10@GetPlotMou:
	mov	eax, DWORD PTR _uiPlotIndex$222716[esp+424]
	inc	eax
	mov	DWORD PTR _uiPlotIndex$222716[esp+424], eax
	cmp	eax, DWORD PTR [esi+48]
	jb	$LL11@GetPlotMou
$LN19@GetPlotMou:

; 4638 : 
; 4639 : #ifdef AUI_ITERATORIZE
; 4640 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 4641 : 	{
; 4642 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 4643 : #else
; 4644 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	eax, DWORD PTR _uiConnection$222701[esp+424]
	mov	ecx, DWORD PTR _pTrade$[esp+424]
	add	DWORD PTR tv1330[esp+424], 444		; 000001bcH
	inc	eax
	mov	DWORD PTR _uiConnection$222701[esp+424], eax
	cmp	eax, DWORD PTR [ecx+4]
	jb	$LL20@GetPlotMou
	mov	ebp, DWORD PTR _aToolTips$[esp+428]
$LN18@GetPlotMou:

; 4732 : 				}
; 4733 : 			}
; 4734 : 		}
; 4735 : 	}
; 4736 : 
; 4737 : 	return aToolTips;

	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+420]
	lea	edx, DWORD PTR _aToolTips$[esp+424]
	push	edx
	mov	ecx, ebx
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	lea	ecx, DWORD PTR _strResult$[esp+424]
	mov	DWORD PTR $T260547[esp+424], 1
	mov	BYTE PTR __$EHRec$[esp+432], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+432], 0
	test	ebp, ebp
	je	SHORT $LN277@GetPlotMou
	mov	edi, DWORD PTR _aToolTips$[esp+432]
	mov	esi, ebp
	cmp	ebp, edi
	je	SHORT $LN262@GetPlotMou
	npad	3
$LL264@GetPlotMou:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL264@GetPlotMou
$LN262@GetPlotMou:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN277@GetPlotMou:
	mov	eax, ebx
$LN22@GetPlotMou:

; 4738 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+424]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 408				; 00000198H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1:
	mov	eax, DWORD PTR $T260547[ebp]
	and	eax, 1
	je	$LN26@GetPlotMou
	and	DWORD PTR $T260547[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
$LN26@GetPlotMou:
	ret	0
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strLine$222722[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T260537[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5:
	lea	ecx, DWORD PTR $T260541[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _strColorString$222735[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7:
	lea	ecx, DWORD PTR $T260544[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ENDP ; CvPlayerTrade::GetPlotMouseoverToolTips
PUBLIC	?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n

; 878  : 		return (begin() + _Off);

	imul	esi, 448				; 000001c0H
	add	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebx

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	ebx, DWORD PTR __Count$[esp]
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
	add	esp, 16					; 00000010H
	pop	ebx

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor:

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [ebx+1]
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+4]
	cdq
	push	esi
	sub	eax, edx
	mov	esi, eax
	push	edi
	sar	esi, 1
	mov	edi, esi
	imul	edi, 448				; 000001c0H
	add	edi, DWORD PTR __First$[esp+12]
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+12]
	mov	ecx, DWORD PTR __First$[esp+12]
	push	eax
	push	ebp
	push	esi
	push	edi
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	mov	eax, DWORD PTR __Last$[esp+32]
	push	edx
	push	ebp
	sub	ebx, esi
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN21@Stable_sor
$LN2@Stable_sor:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	edi
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	ebx, esi
	push	ebx
	push	ecx
	push	edi
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
$LN21@Stable_sor:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	edx, DWORD PTR __Pred$[esp+52]
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	edx
	push	ebp
	push	ebx
	push	esi
	push	eax
	push	edi
	push	ecx
	call	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
_TEXT	ENDS
PUBLIC	?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z ; CvGameTrade::CreateTradeRoute
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?UpdateNumTradeRouteConnections@CvCityReligions@@QAEXPAVCvCity@@@Z:PROC ; CvCityReligions::UpdateNumTradeRouteConnections
EXTRN	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getCulturePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
_TEXT	SEGMENT
$T261798 = -628						; size = 4
_iTurnsPerCircuit$ = -628				; size = 4
_pPathfinderNode$ = -628				; size = 4
_iDestY$ = -628						; size = 4
_bSuccess$ = -621					; size = 1
_iNewTradeRouteIndex$ = -620				; size = 4
_iDestX$ = -620						; size = 4
$T261663 = -616						; size = 4
$T261395 = -616						; size = 4
_iOriginX$ = -616					; size = 4
$T261394 = -612						; size = 4
_ui$220329 = -612					; size = 4
_iOriginY$ = -612					; size = 4
$T261926 = -608						; size = 4
_eOriginPlayer$ = -608					; size = 4
_eDestPlayer$ = -604					; size = 4
tv1107 = -600						; size = 4
_strTRType$220353 = -596				; size = 28
_strDomain$220344 = -568				; size = 28
_strMsg$220343 = -540					; size = 28
$T261396 = -512						; size = 28
$T261397 = -484						; size = 28
_kNewTradeConnection$220327 = -456			; size = 444
__$EHRec$ = -12						; size = 12
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
_iRouteID$ = 24						; size = 4
?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z PROC ; CvGameTrade::CreateTradeRoute, COMDAT
; _this$ = ecx

; 300  : {

	mov	eax, DWORD PTR fs:0

; 301  : 	iRouteID = -1;
; 302  : 
; 303  : 	if (!CanCreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnectionType, false))

	mov	edx, DWORD PTR _eDomain$[esp-4]
	push	-1
	push	__ehhandler$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
	push	eax
	mov	eax, DWORD PTR _iRouteID$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 616				; 00000268H
	push	ebp
	mov	ebp, DWORD PTR _pDestCity$[esp+628]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pOriginCity$[esp+636]
	push	1
	push	0
	mov	esi, ecx
	mov	ecx, DWORD PTR _eConnectionType$[esp+644]
	push	ecx
	push	edx
	push	ebp
	push	edi
	mov	ecx, esi
	mov	DWORD PTR [eax], -1
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
	test	al, al
	je	$LN25@CreateTrad
$LN24@CreateTrad:

; 304  : 	{
; 305  : 		return false;
; 306  : 	}
; 307  : 
; 308  : 	PlayerTypes eOriginPlayer = pOriginCity->getOwner();
; 309  : 	PlayerTypes eDestPlayer = pDestCity->getOwner();
; 310  : 
; 311  : 	int iOriginX = pOriginCity->getX();
; 312  : 	int iOriginY = pOriginCity->getY();
; 313  : 	int iDestX = pDestCity->getX();

	mov	edx, DWORD PTR [ebp+96]
	mov	eax, DWORD PTR [ebp+84]
	mov	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR _iDestX$[esp+640], edx

; 314  : 	int iDestY = pDestCity->getY();

	mov	edx, DWORD PTR [ebp+108]
	mov	DWORD PTR _iDestY$[esp+640], edx

; 315  : 
; 316  : 	bool bSuccess = false;
; 317  : 	CvAStarNode* pPathfinderNode = NULL;
; 318  : 	if (eDomain == DOMAIN_SEA)

	mov	edx, DWORD PTR _eDomain$[esp+636]
	push	ebx
	mov	ebx, DWORD PTR [edi+84]
	mov	DWORD PTR _eDestPlayer$[esp+644], eax
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR _eOriginPlayer$[esp+644], ebx
	mov	DWORD PTR _iOriginX$[esp+644], eax
	mov	DWORD PTR _iOriginY$[esp+644], ecx
	test	edx, edx
	jne	SHORT $LN23@CreateTrad

; 319  : 	{
; 320  : 		if (pOriginCity->isCoastal(0) && pDestCity->isCoastal(0))	// Both must be on the coast (a lake is ok)  A better check would be to see if they are adjacent to the same water body.

	push	edx
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN296@CreateTrad
	push	0
	mov	ecx, ebp
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN296@CreateTrad

; 321  : 		{
; 322  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 323  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 324  : #else
; 325  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	mov	eax, DWORD PTR _iDestY$[esp+644]
	mov	ecx, DWORD PTR _iDestX$[esp+644]
	mov	edx, DWORD PTR _iOriginY$[esp+644]
	push	0
	push	ebx
	push	eax
	mov	eax, DWORD PTR _iOriginX$[esp+656]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 326  : #endif
; 327  : 			pPathfinderNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bSuccess$[esp+644], al
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pPathfinderNode$[esp+644], ecx

; 328  : 		}
; 329  : 	}

	jmp	SHORT $LN59@CreateTrad
$LN23@CreateTrad:

; 330  : 	else if (eDomain == DOMAIN_LAND)

	cmp	edx, 2
	jne	SHORT $LN296@CreateTrad

; 331  : 	{
; 332  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 333  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 334  : #else
; 335  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	mov	edx, DWORD PTR _iDestY$[esp+644]
	push	0
	push	ebx
	push	edx
	mov	edx, DWORD PTR _iDestX$[esp+656]
	push	edx
	push	ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 336  : #endif
; 337  : 		pPathfinderNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bSuccess$[esp+644], al
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	eax, DWORD PTR [eax+96]
	mov	DWORD PTR _pPathfinderNode$[esp+644], eax
$LN59@CreateTrad:

; 338  : 	}
; 339  : 
; 340  : 	if (!bSuccess)

	cmp	BYTE PTR _bSuccess$[esp+644], 0

; 341  : 	{
; 342  : 		return false;

	je	SHORT $LN296@CreateTrad

; 343  : 	}
; 344  : 
; 345  : 	CvAssertMsg(pPathfinderNode, "pPathfinderNode is null. Whaa?");
; 346  : 	if (pPathfinderNode == NULL)

	xor	edi, edi
	cmp	DWORD PTR _pPathfinderNode$[esp+644], edi
	jne	SHORT $LN18@CreateTrad
$LN296@CreateTrad:

; 347  : 	{
; 348  : 		return false;

	xor	al, al
	jmp	$LN302@CreateTrad
$LN18@CreateTrad:

; 349  : 	}
; 350  : 
; 351  : 	int iNewTradeRouteIndex = GetEmptyTradeRouteIndex();

	mov	ecx, esi
	call	?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ ; CvGameTrade::GetEmptyTradeRouteIndex

; 352  : 	CvAssertMsg(iNewTradeRouteIndex < (int)m_aTradeConnections.size(), "iNewTradeRouteIndex out of bounds");
; 353  : 
; 354  : 	// couldn't find valid connection, bail out
; 355  : 	if (iNewTradeRouteIndex < 0)

	cmp	eax, edi
	mov	DWORD PTR _iNewTradeRouteIndex$[esp+644], eax
	jge	SHORT $LN298@CreateTrad

; 356  : 	{
; 357  : 		TradeConnection kNewTradeConnection;

	lea	ecx, DWORD PTR _kNewTradeConnection$220327[esp+700]
	mov	DWORD PTR _kNewTradeConnection$220327[esp+692], edi
	mov	DWORD PTR _kNewTradeConnection$220327[esp+696], 40 ; 00000028H
	mov	DWORD PTR _kNewTradeConnection$220327[esp+688], ecx

; 358  : 		m_aTradeConnections.push_back(kNewTradeConnection);

	lea	edx, DWORD PTR _kNewTradeConnection$220327[esp+644]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+656], edi
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 359  : 		iNewTradeRouteIndex = m_aTradeConnections.size() - 1;

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	mov	DWORD PTR _iNewTradeRouteIndex$[esp+644], eax

; 360  : 	}

	mov	eax, DWORD PTR _kNewTradeConnection$220327[esp+688]
	lea	ecx, DWORD PTR _kNewTradeConnection$220327[esp+700]
	mov	DWORD PTR __$EHRec$[esp+652], -1
	cmp	eax, ecx
	je	SHORT $LN298@CreateTrad
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN298@CreateTrad:

; 361  : 
; 362  : 	iRouteID = m_iNextID;

	mov	edx, DWORD PTR [esi+74608]

; 363  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iID = m_iNextID;

	mov	edi, DWORD PTR _iNewTradeRouteIndex$[esp+644]
	mov	eax, DWORD PTR _iRouteID$[esp+640]
	imul	edi, 444				; 000001bcH
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+74608]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edi+ecx], edx

; 364  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iOriginX = pOriginCity->getX();

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR _pOriginCity$[esp+640]
	mov	eax, DWORD PTR [ecx+96]
	mov	DWORD PTR [edx+edi+4], eax

; 365  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iOriginY = pOriginCity->getY();

	mov	eax, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edx+edi+8], eax

; 366  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eOriginOwner = pOriginCity->getOwner();

	mov	eax, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edi+20], eax

; 367  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iDestX = pDestCity->getX();

	mov	eax, DWORD PTR [ebp+96]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edx+edi+12], eax

; 368  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iDestY = pDestCity->getY();

	mov	eax, DWORD PTR [ebp+108]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edi+16], eax

; 369  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eDestOwner = pDestCity->getOwner();

	mov	ebp, DWORD PTR [ebp+84]
	mov	edx, DWORD PTR [esi]

; 370  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eDomain = eDomain;

	mov	ecx, DWORD PTR _eDomain$[esp+640]
	mov	DWORD PTR [edx+edi+24], ebp
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+edi+28], ecx

; 371  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eConnectionType = eConnectionType;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _eConnectionType$[esp+640]
	mov	DWORD PTR [edx+edi+32], eax

; 372  : 	m_aTradeConnections[iNewTradeRouteIndex].m_unitID = -1;

	mov	ecx, DWORD PTR [esi]

; 373  : 
; 374  : 	// increment m_iNextID for the next connection
; 375  : 	m_iNextID += 1;
; 376  : 
; 377  : 	CopyPathIntoTradeConnection(pPathfinderNode, &(m_aTradeConnections[iNewTradeRouteIndex]));

	mov	eax, DWORD PTR _pPathfinderNode$[esp+644]
	mov	DWORD PTR [ecx+edi+380], -1
	mov	edx, DWORD PTR [esi]
	inc	DWORD PTR [esi+74608]
	add	edx, edi
	push	edx
	push	eax
	mov	ecx, esi
	call	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection

; 378  : 
; 379  : 	// reveal all plots to the player who created the trade route
; 380  : 	TeamTypes eOriginTeam = GET_PLAYER(eOriginPlayer).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, ebx
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv1107[esp+644], eax
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN143@CreateTrad
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T261663[esp+644], edx
	jmp	SHORT $LN144@CreateTrad
$LN143@CreateTrad:
	mov	DWORD PTR $T261663[esp+644], -1
$LN144@CreateTrad:

; 381  : #ifdef AUI_ITERATORIZE
; 382  : 	for (TradeConnectionPlotList::const_iterator it = m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.begin(); it != m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.end(); ++it)
; 383  : 	{
; 384  : 		GC.getMap().plot(it->m_iX, it->m_iY)->setRevealed(eOriginTeam, true, true);
; 385  : #else
; 386  : 	for (uint ui = 0; ui < m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.size(); ui++)

	mov	ecx, DWORD PTR [esi]
	xor	eax, eax
	mov	DWORD PTR _ui$220329[esp+644], eax
	cmp	DWORD PTR [ecx+edi+48], eax
	jbe	$LN14@CreateTrad
	npad	7
$LL300@CreateTrad:
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+edi+44]

; 387  : 	{
; 388  : 		GC.getMap().plot(m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList[ui].m_iX, m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList[ui].m_iY)->setRevealed(eOriginTeam, true, true);

	mov	edx, DWORD PTR [ecx+eax*8+4]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T261798[esp+644], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN162@CreateTrad
	cmp	edx, -2147483647			; 80000001H
	je	$LN162@CreateTrad
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	bl, bl
	je	SHORT $LN172@CreateTrad
	test	eax, eax
	jge	SHORT $LN174@CreateTrad
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR $T261798[esp+644]
	add	ebx, ecx
	jmp	SHORT $LN176@CreateTrad
$LN174@CreateTrad:
	cmp	eax, ecx
	jl	SHORT $LN172@CreateTrad
	cdq
	idiv	ecx
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, edx
	mov	edx, DWORD PTR $T261798[esp+644]
	jmp	SHORT $LN176@CreateTrad
$LN172@CreateTrad:
	mov	ebx, eax
$LN176@CreateTrad:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebp, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN299@CreateTrad
	test	edx, edx
	jge	SHORT $LN184@CreateTrad
	mov	eax, edx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN299@CreateTrad
$LN184@CreateTrad:
	cmp	edx, ebp
	jl	SHORT $LN299@CreateTrad
	mov	eax, edx
	cdq
	idiv	ebp
$LN299@CreateTrad:
	test	ebx, ebx
	jl	SHORT $LN162@CreateTrad
	cmp	ebx, ecx
	jge	SHORT $LN162@CreateTrad
	test	edx, edx
	jl	SHORT $LN162@CreateTrad
	cmp	edx, ebp
	jge	SHORT $LN162@CreateTrad
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebx
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN164@CreateTrad
$LN162@CreateTrad:
	xor	ecx, ecx
$LN164@CreateTrad:
	mov	eax, DWORD PTR $T261663[esp+644]
	push	-1
	push	1
	push	1
	push	eax
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	mov	eax, DWORD PTR _ui$220329[esp+644]
	mov	ecx, DWORD PTR [esi]
	inc	eax
	mov	DWORD PTR _ui$220329[esp+644], eax
	cmp	eax, DWORD PTR [ecx+edi+48]
	jb	$LL300@CreateTrad
$LN14@CreateTrad:

; 389  : #endif
; 390  : 	}
; 391  : 
; 392  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iTradeUnitLocationIndex = 0;

	mov	edx, DWORD PTR [esi]

; 393  : 	m_aTradeConnections[iNewTradeRouteIndex].m_bTradeUnitMovingForward = true;
; 394  : 
; 395  : 	int iRouteSpeed = GET_PLAYER(pOriginCity->getOwner()).GetTrade()->GetTradeRouteSpeed(eDomain);

	mov	ecx, DWORD PTR _pOriginCity$[esp+640]
	mov	DWORD PTR [edx+edi+36], 0
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi+40], 1
	mov	eax, DWORD PTR [ecx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	eax, DWORD PTR _eDomain$[esp+640]
	sub	eax, 0
	je	SHORT $LN211@CreateTrad
	sub	eax, 2
	je	SHORT $LN210@CreateTrad
	or	ecx, -1
	jmp	SHORT $LN214@CreateTrad
$LN210@CreateTrad:
	mov	ecx, 2
	jmp	SHORT $LN214@CreateTrad
$LN211@CreateTrad:
	mov	ecx, 4
$LN214@CreateTrad:

; 396  : 	int iTurnsPerCircuit = 1;

	mov	ebx, 1
	mov	DWORD PTR _iTurnsPerCircuit$[esp+644], ebx

; 397  : 	if (iRouteSpeed != 0)

	test	ecx, ecx
	je	SHORT $LN13@CreateTrad

; 398  : 	{
; 399  : 		iTurnsPerCircuit = ((m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.size() - 1) * 2) / iRouteSpeed;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+edi+48]
	lea	eax, DWORD PTR [eax+eax-2]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _iTurnsPerCircuit$[esp+644], eax
	mov	ebx, eax
$LN13@CreateTrad:

; 400  : 	}
; 401  : 	
; 402  : 	int iTargetTurns = 30; // how many turns do we want the cycle to consume
; 403  : #ifdef NQ_TRADE_ROUTE_DURATION_SCALES_WITH_GAME_SPEED
; 404  : 	iTargetTurns = iTargetTurns * GC.getGame().getGameSpeedInfo().getCulturePercent() / 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	add	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 405  : #endif
; 406  : 	int iCircuitsToComplete = 1; // how many circuits do we want this trade route to run to reach the target turns

	mov	ebp, 1

; 407  : 	if (iTurnsPerCircuit != 0)

	test	ebx, ebx
	je	SHORT $LN12@CreateTrad

; 408  : 	{
; 409  : 		iCircuitsToComplete = max(iTargetTurns / iTurnsPerCircuit, 2);

	cdq
	idiv	ebx
	mov	DWORD PTR $T261394[esp+644], 2
	mov	DWORD PTR $T261395[esp+644], eax
	cmp	eax, 2
	lea	eax, DWORD PTR $T261394[esp+644]
	jl	SHORT $LN225@CreateTrad
	lea	eax, DWORD PTR $T261395[esp+644]
$LN225@CreateTrad:
	mov	ebp, DWORD PTR [eax]
$LN12@CreateTrad:

; 410  : 	}
; 411  : 
; 412  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iCircuitsCompleted = 0;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+edi+384], 0

; 413  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iCircuitsToComplete = iCircuitsToComplete;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edi+388], ebp

; 414  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iTurnRouteComplete = (iTurnsPerCircuit * iCircuitsToComplete) + GC.getGame().getGameTurn();

	mov	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	ebx, edi
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	imul	ebp, DWORD PTR _iTurnsPerCircuit$[esp+644]
	add	eax, ebp
	mov	DWORD PTR [ebx+392], eax

; 415  : 
; 416  : 	GET_PLAYER(eOriginPlayer).GetTrade()->UpdateTradeConnectionValues();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1107[esp+644]
	lea	ecx, DWORD PTR [eax+edx]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 417  : 	if (eDestPlayer != eOriginPlayer)

	mov	eax, DWORD PTR _eDestPlayer$[esp+644]
	cmp	eax, DWORD PTR _eOriginPlayer$[esp+644]
	je	SHORT $LN11@CreateTrad

; 418  : 	{
; 419  : 		GET_PLAYER(eDestPlayer).GetTrade()->UpdateTradeConnectionValues();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues
$LN11@CreateTrad:

; 420  : 	}
; 421  : 
; 422  : 	pOriginCity->GetCityReligions()->UpdateNumTradeRouteConnections(pDestCity);

	mov	ebp, DWORD PTR _pDestCity$[esp+640]
	mov	ebx, DWORD PTR _pOriginCity$[esp+640]
	push	ebp
	mov	ecx, ebx
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?UpdateNumTradeRouteConnections@CvCityReligions@@QAEXPAVCvCity@@@Z ; CvCityReligions::UpdateNumTradeRouteConnections

; 423  : 	pDestCity->GetCityReligions()->UpdateNumTradeRouteConnections(pOriginCity);

	push	ebx
	mov	ecx, ebp
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?UpdateNumTradeRouteConnections@CvCityReligions@@QAEXPAVCvCity@@@Z ; CvCityReligions::UpdateNumTradeRouteConnections

; 424  : 
; 425  : 	CreateVis(iNewTradeRouteIndex);

	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[esp+644]
	push	ecx
	mov	ecx, esi
	call	?CreateVis@CvGameTrade@@QAEXH@Z		; CvGameTrade::CreateVis

; 426  : 	MoveUnit(iNewTradeRouteIndex);

	mov	edx, DWORD PTR _iNewTradeRouteIndex$[esp+644]
	push	edx
	mov	ecx, esi
	call	?MoveUnit@CvGameTrade@@QAE_NH@Z		; CvGameTrade::MoveUnit

; 427  : 
; 428  : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN10@CreateTrad

; 429  : 	{
; 430  : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$220343[esp+644]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 431  : 		CvString strDomain;

	lea	ecx, DWORD PTR _strDomain$220344[esp+644]
	mov	DWORD PTR __$EHRec$[esp+652], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 432  : 		switch (eDomain)

	mov	eax, DWORD PTR _eDomain$[esp+640]
	sub	eax, 0
	mov	BYTE PTR __$EHRec$[esp+652], 2
	je	SHORT $LN6@CreateTrad
	sub	eax, 2
	jne	SHORT $LN248@CreateTrad

; 433  : 		{
; 434  : 		case DOMAIN_LAND:
; 435  : 			strDomain = "land";

	push	OFFSET $SG220350

; 436  : 			break;

	jmp	SHORT $LN303@CreateTrad
$LN6@CreateTrad:

; 437  : 		case DOMAIN_SEA:
; 438  : 			strDomain = "sea";

	push	OFFSET $SG220352
$LN303@CreateTrad:
	lea	ecx, DWORD PTR _strDomain$220344[esp+648]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN248@CreateTrad:

; 439  : 			break;
; 440  : 		}
; 441  : 
; 442  : 		CvString strTRType;

	lea	ecx, DWORD PTR _strTRType$220353[esp+644]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 443  : 		switch (eConnectionType)

	mov	eax, DWORD PTR _eConnectionType$[esp+640]
	sub	eax, 0
	mov	BYTE PTR __$EHRec$[esp+652], 3
	je	SHORT $LN1@CreateTrad
	sub	eax, 1
	je	SHORT $LN3@CreateTrad
	sub	eax, 1
	jne	SHORT $LN263@CreateTrad

; 448  : 		case TRADE_CONNECTION_PRODUCTION:
; 449  : 			strTRType = "production";

	push	OFFSET $SG220361

; 450  : 			break;

	jmp	SHORT $LN304@CreateTrad
$LN3@CreateTrad:

; 444  : 		{
; 445  : 		case TRADE_CONNECTION_FOOD:
; 446  : 			strTRType = "food";

	push	OFFSET $SG220359

; 447  : 			break;

	jmp	SHORT $LN304@CreateTrad
$LN1@CreateTrad:

; 451  : 		case TRADE_CONNECTION_INTERNATIONAL:
; 452  : 			strTRType = "international";

	push	OFFSET $SG220363
$LN304@CreateTrad:
	lea	ecx, DWORD PTR _strTRType$220353[esp+648]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN263@CreateTrad:

; 453  : 			break;
; 454  : 		}
; 455  : 
; 456  : 		strMsg.Format("%s, New Trade Route, %s, %s, %s, %i, %s", GET_PLAYER(pOriginCity->getOwner()).getCivilizationShortDescription(), strDomain.c_str(), pOriginCity->getName().c_str(), pDestCity->getName().c_str(), m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.size(), strTRType.c_str());

	lea	eax, DWORD PTR $T261396[esp+644]
	push	eax
	mov	ecx, ebp
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ebp, eax
	lea	ecx, DWORD PTR $T261397[esp+644]
	push	ecx
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+656], 4
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ebx, eax
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _pOriginCity$[esp+640]
	add	eax, edi
	mov	edi, DWORD PTR [eax+48]
	mov	eax, DWORD PTR [edx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR _strTRType$220353[esp+644]
	mov	BYTE PTR __$EHRec$[esp+652], 5
	mov	DWORD PTR $T261926[esp+644], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	edi
	mov	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDomain$220344[esp+660]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T261926[esp+660]
	push	eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	eax, DWORD PTR _strMsg$220343[esp+668]
	push	OFFSET $SG220366
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T261397[esp+644]
	mov	BYTE PTR __$EHRec$[esp+652], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T261396[esp+644]
	mov	BYTE PTR __$EHRec$[esp+652], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 457  : 		LogTradeMsg(strMsg);

	lea	ecx, DWORD PTR _strMsg$220343[esp+644]
	push	ecx
	mov	ecx, esi
	call	?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z ; CvGameTrade::LogTradeMsg

; 458  : 	}

	lea	ecx, DWORD PTR _strTRType$220353[esp+644]
	mov	BYTE PTR __$EHRec$[esp+652], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strDomain$220344[esp+644]
	mov	BYTE PTR __$EHRec$[esp+652], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strMsg$220343[esp+644]
	mov	DWORD PTR __$EHRec$[esp+652], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@CreateTrad:

; 459  : 
; 460  : 	
; 461  : 
; 462  : 	return true;

	mov	al, 1
$LN302@CreateTrad:
	pop	ebx
$LN25@CreateTrad:

; 463  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+640]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 628				; 00000274H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$0:
	lea	ecx, DWORD PTR _kNewTradeConnection$220327[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$1:
	lea	ecx, DWORD PTR _strMsg$220343[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$2:
	lea	ecx, DWORD PTR _strDomain$220344[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$3:
	lea	ecx, DWORD PTR _strTRType$220353[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$4:
	lea	ecx, DWORD PTR $T261396[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$5:
	lea	ecx, DWORD PTR $T261397[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z ENDP ; CvGameTrade::CreateTradeRoute
PUBLIC	?DoTurn@CvPlayerTrade@@QAEXXZ			; CvPlayerTrade::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::DoTurn, COMDAT
; _this$ = ecx

; 2287 : {

	push	esi
	mov	esi, ecx

; 2288 : 	m_aRecentlyExpiredConnections.clear();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy

; 2289 : 	UpdateTradeConnectionValues();

	mov	ecx, esi
	mov	DWORD PTR [esi+4], 0
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 2290 : 	UpdateTradeConnectionWasPlundered();

	mov	ecx, esi
	call	?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionWasPlundered

; 2291 : 	MoveUnits();

	mov	ecx, esi
	pop	esi
	jmp	?MoveUnits@CvPlayerTrade@@QAEXXZ	; CvPlayerTrade::MoveUnits
?DoTurn@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::DoTurn
_TEXT	ENDS
PUBLIC	?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ; CvPlayerTrade::CreateTradeRoute
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z$0
__ehfuncinfo$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
_TEXT	SEGMENT
_bConnectedToIndia$221998 = -2517			; size = 1
_bConnectedToMongols$221996 = -2516			; size = 1
_bConnectedToChina$221997 = -2515			; size = 1
_bConnectedToPersia$221995 = -2514			; size = 1
_bConnectedToArabs$221994 = -2513			; size = 1
tv1034 = -2512						; size = 4
$T262034 = -2512					; size = 4
_iRouteID$ = -2512					; size = 4
_this$ = -2508						; size = 4
_kConnection$222005 = -2504				; size = 444
_plotsY$ = -2060					; size = 1024
_plotsX$ = -1036					; size = 1024
__$EHRec$ = -12						; size = 12
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z PROC ; CvPlayerTrade::CreateTradeRoute, COMDAT
; _this$ = ecx

; 3335 : {

	push	-1
	push	__ehhandler$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2508				; 000009ccH
	push	ebx
	mov	ebx, ecx

; 3336 : 	int plotsX[MAX_PLOTS_TO_DISPLAY], plotsY[MAX_PLOTS_TO_DISPLAY];
; 3337 : 
; 3338 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _this$[esp+2528], ebx
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade

; 3339 : 	int iRouteID = -1;
; 3340 : 	bool bResult = pTrade->CreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnectionType, iRouteID);

	mov	ecx, DWORD PTR _eConnectionType$[esp+2524]
	mov	edx, DWORD PTR _eDomain$[esp+2524]
	mov	edi, eax
	lea	eax, DWORD PTR _iRouteID$[esp+2528]
	push	eax
	mov	eax, DWORD PTR _pDestCity$[esp+2528]
	push	ecx
	mov	ecx, DWORD PTR _pOriginCity$[esp+2532]
	push	edx
	push	eax
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iRouteID$[esp+2548], -1
	call	?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z ; CvGameTrade::CreateTradeRoute

; 3341 : 	if (!bResult)

	test	al, al
	je	$LN25@CreateTrad@2
$LN24@CreateTrad@2:

; 3342 : 	{
; 3343 : 		return false;
; 3344 : 	}
; 3345 : 
; 3346 : 	int iRouteIndex = pTrade->GetIndexFromID(iRouteID);

	mov	eax, DWORD PTR [edi+4]
	push	ebp
	xor	ebp, ebp
	push	esi
	test	eax, eax
	jbe	$LN188@CreateTrad@2
	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR _iRouteID$[esp+2536]
	mov	ecx, edx
$LL33@CreateTrad@2:
	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN34@CreateTrad@2
	inc	ebp
	add	ecx, 444				; 000001bcH
	cmp	ebp, eax
	jb	SHORT $LL33@CreateTrad@2
	jmp	$LN188@CreateTrad@2
$LN34@CreateTrad@2:

; 3347 : 	if (iRouteIndex != -1)

	cmp	ebp, -1
	je	$LN188@CreateTrad@2

; 3348 : 	{
; 3349 : 		int nPlots = pTrade->m_aTradeConnections[iRouteIndex].m_aPlotList.size();

	mov	esi, ebp
	imul	esi, 444				; 000001bcH
	mov	edx, DWORD PTR [edx+esi+48]

; 3350 : 		if (nPlots > 0) {

	test	edx, edx
	jle	$LN188@CreateTrad@2

; 3351 : 			if (nPlots > MAX_PLOTS_TO_DISPLAY)

	cmp	edx, 256				; 00000100H
	jle	SHORT $LN21@CreateTrad@2

; 3352 : 				nPlots = MAX_PLOTS_TO_DISPLAY;

	mov	edx, 256				; 00000100H
$LN21@CreateTrad@2:

; 3353 : 			for (uint ui = 0; ui < (uint)nPlots; ui++) 

	xor	eax, eax
	test	edx, edx
	jbe	SHORT $LN18@CreateTrad@2
$LL20@CreateTrad@2:

; 3354 : 			{
; 3355 : 				plotsX[ui] = pTrade->m_aTradeConnections[iRouteIndex].m_aPlotList[ui].m_iX;

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+esi+44]
	mov	ecx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _plotsX$[esp+eax*4+2536], ecx

; 3356 : 				plotsY[ui] = pTrade->m_aTradeConnections[iRouteIndex].m_aPlotList[ui].m_iY;

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+esi+44]
	mov	ecx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _plotsY$[esp+eax*4+2536], ecx
	inc	eax
	cmp	eax, edx
	jb	SHORT $LL20@CreateTrad@2
$LN18@CreateTrad@2:

; 3357 : 			}
; 3358 : 			gDLL->TradeVisuals_NewRoute(iRouteIndex, m_pPlayer->GetID(),pTrade->m_aTradeConnections[iRouteIndex].m_eConnectionType, nPlots, plotsX, plotsY);

	mov	eax, DWORD PTR [ebx+79104]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	lea	ebx, DWORD PTR _plotsY$[esp+2536]
	push	ebx
	lea	ebx, DWORD PTR _plotsX$[esp+2540]
	push	ebx
	push	edx
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+esi+32]
	mov	DWORD PTR $T262034[esp+2548], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+972]
	push	edx
	mov	edx, DWORD PTR $T262034[esp+2552]
	push	edx
	push	ebp
	call	eax

; 3359 : 			gDLL->TradeVisuals_UpdateRouteDirection(iRouteIndex, pTrade->m_aTradeConnections[iRouteIndex].m_bTradeUnitMovingForward);

	mov	eax, DWORD PTR [edi]
	movzx	eax, BYTE PTR [eax+esi+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+976]
	push	eax
	push	ebp
	call	edx
	mov	ebx, DWORD PTR _this$[esp+2536]
$LN188@CreateTrad@2:

; 3360 : 		}
; 3361 : 	}
; 3362 : 
; 3363 : 	if (m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR [ebx+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN1@CreateTrad@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN1@CreateTrad@2

; 3364 : 	{
; 3365 : 		bool bConnectedToArabs = false;
; 3366 : 		bool bConnectedToPersia = false;
; 3367 : 		bool bConnectedToMongols = false;
; 3368 : 		bool bConnectedToChina = false;
; 3369 : 		bool bConnectedToIndia = false;
; 3370 : 
; 3371 : #ifdef AUI_ITERATORIZE
; 3372 : 		for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3373 : 		{
; 3374 : 			if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3375 : #else
; 3376 : 		CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR _bConnectedToArabs$221994[esp+2536], al
	mov	BYTE PTR _bConnectedToPersia$221995[esp+2536], al
	mov	BYTE PTR _bConnectedToMongols$221996[esp+2536], al
	mov	BYTE PTR _bConnectedToChina$221997[esp+2536], al
	mov	BYTE PTR _bConnectedToIndia$221998[esp+2536], al
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ebp, eax

; 3377 : 		for (uint ui = 0; ui < pGameTrade->m_aTradeConnections.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	$LN1@CreateTrad@2
	mov	DWORD PTR tv1034[esp+2536], ebx
	lea	edi, DWORD PTR [ebx+2]
	npad	2
$LL16@CreateTrad@2:

; 3378 : 		{
; 3379 : 			if (pGameTrade->IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR tv1034[esp+2536]
	add	eax, ecx
	or	esi, -1
	cmp	DWORD PTR [eax+4], esi
	jne	SHORT $LN71@CreateTrad@2
	cmp	DWORD PTR [eax+8], esi
	jne	SHORT $LN71@CreateTrad@2
	cmp	DWORD PTR [eax+12], esi
	jne	SHORT $LN71@CreateTrad@2
	cmp	DWORD PTR [eax+16], esi
	je	$LN15@CreateTrad@2
$LN71@CreateTrad@2:

; 3380 : #endif
; 3381 : 			{
; 3382 : 				continue;
; 3383 : 			}
; 3384 : 
; 3385 : #ifdef AUI_ITERATORIZE
; 3386 : 			TradeConnection kConnection = *pConnection;
; 3387 : #else
; 3388 : 			TradeConnection kConnection = pGameTrade->m_aTradeConnections[ui];

	push	eax
	lea	ecx, DWORD PTR _kConnection$222005[esp+2540]
	call	??0TradeConnection@@QAE@ABU0@@Z

; 3389 : #endif
; 3390 : 			if (kConnection.m_eOriginOwner != m_pPlayer->GetID())

	mov	edx, DWORD PTR _this$[esp+2536]
	mov	eax, DWORD PTR [edx+79104]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR __$EHRec$[esp+2544], 0
	cmp	DWORD PTR _kConnection$222005[esp+2556], eax
	je	SHORT $LN12@CreateTrad@2

; 3391 : 			{
; 3392 : 				continue;

	mov	DWORD PTR __$EHRec$[esp+2544], esi
	jmp	$LN191@CreateTrad@2
$LN12@CreateTrad@2:

; 3393 : 			}
; 3394 : 
; 3395 : 			if (kConnection.m_eDomain != DOMAIN_LAND)

	cmp	DWORD PTR _kConnection$222005[esp+2564], edi
	je	SHORT $LN11@CreateTrad@2

; 3396 : 			{
; 3397 : 				continue;

	mov	eax, DWORD PTR _kConnection$222005[esp+2580]
	lea	edx, DWORD PTR _kConnection$222005[esp+2592]
	mov	DWORD PTR __$EHRec$[esp+2544], esi
	cmp	eax, edx
	jmp	$LN190@CreateTrad@2
$LN11@CreateTrad@2:

; 3398 : 			}
; 3399 : 
; 3400 : 			if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_ARABIA") == 0)

	mov	ecx, DWORD PTR _kConnection$222005[esp+2560]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, OFFSET $SG222009
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	npad	2
$LL165@CreateTrad@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN166@CreateTrad@2
	test	cl, cl
	je	SHORT $LN167@CreateTrad@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN166@CreateTrad@2
	add	eax, edi
	add	esi, edi
	test	cl, cl
	jne	SHORT $LL165@CreateTrad@2
$LN167@CreateTrad@2:
	xor	eax, eax
	jmp	SHORT $LN168@CreateTrad@2
$LN166@CreateTrad@2:
	sbb	eax, eax
	sbb	eax, -1
$LN168@CreateTrad@2:
	test	eax, eax
	jne	SHORT $LN10@CreateTrad@2

; 3401 : 			{
; 3402 : 				bConnectedToArabs = true;

	mov	BYTE PTR _bConnectedToArabs$221994[esp+2536], 1
	jmp	$LN185@CreateTrad@2
$LN10@CreateTrad@2:

; 3403 : 			}
; 3404 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_PERSIA") == 0)

	mov	ecx, DWORD PTR _kConnection$222005[esp+2560]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, OFFSET $SG222012
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	npad	5
$LL169@CreateTrad@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN170@CreateTrad@2
	test	cl, cl
	je	SHORT $LN171@CreateTrad@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN170@CreateTrad@2
	add	eax, edi
	add	esi, edi
	test	cl, cl
	jne	SHORT $LL169@CreateTrad@2
$LN171@CreateTrad@2:
	xor	eax, eax
	jmp	SHORT $LN172@CreateTrad@2
$LN170@CreateTrad@2:
	sbb	eax, eax
	sbb	eax, -1
$LN172@CreateTrad@2:
	test	eax, eax
	jne	SHORT $LN8@CreateTrad@2

; 3405 : 			{
; 3406 : 				bConnectedToPersia = true;

	mov	BYTE PTR _bConnectedToPersia$221995[esp+2536], 1
	jmp	$LN185@CreateTrad@2
$LN8@CreateTrad@2:

; 3407 : 			}
; 3408 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_MONGOL") == 0)

	mov	ecx, DWORD PTR _kConnection$222005[esp+2560]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, OFFSET $SG222015
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	npad	5
$LL173@CreateTrad@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN174@CreateTrad@2
	test	cl, cl
	je	SHORT $LN175@CreateTrad@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN174@CreateTrad@2
	add	eax, edi
	add	esi, edi
	test	cl, cl
	jne	SHORT $LL173@CreateTrad@2
$LN175@CreateTrad@2:
	xor	eax, eax
	jmp	SHORT $LN176@CreateTrad@2
$LN174@CreateTrad@2:
	sbb	eax, eax
	sbb	eax, -1
$LN176@CreateTrad@2:
	test	eax, eax
	jne	SHORT $LN6@CreateTrad@2

; 3409 : 			{
; 3410 : 				bConnectedToMongols = true;

	mov	BYTE PTR _bConnectedToMongols$221996[esp+2536], 1
	jmp	$LN185@CreateTrad@2
$LN6@CreateTrad@2:

; 3411 : 			}
; 3412 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_CHINA") == 0)

	mov	ecx, DWORD PTR _kConnection$222005[esp+2560]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, OFFSET $SG222018
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	npad	5
$LL177@CreateTrad@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN178@CreateTrad@2
	test	cl, cl
	je	SHORT $LN179@CreateTrad@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN178@CreateTrad@2
	add	eax, edi
	add	esi, edi
	test	cl, cl
	jne	SHORT $LL177@CreateTrad@2
$LN179@CreateTrad@2:
	xor	eax, eax
	jmp	SHORT $LN180@CreateTrad@2
$LN178@CreateTrad@2:
	sbb	eax, eax
	sbb	eax, -1
$LN180@CreateTrad@2:
	test	eax, eax
	jne	SHORT $LN4@CreateTrad@2

; 3413 : 			{
; 3414 : 				bConnectedToChina = true;

	mov	BYTE PTR _bConnectedToChina$221997[esp+2536], 1
	jmp	SHORT $LN185@CreateTrad@2
$LN4@CreateTrad@2:

; 3415 : 			}
; 3416 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_INDIA") == 0)

	mov	ecx, DWORD PTR _kConnection$222005[esp+2560]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, OFFSET $SG222021
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
$LL181@CreateTrad@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN182@CreateTrad@2
	test	cl, cl
	je	SHORT $LN183@CreateTrad@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN182@CreateTrad@2
	add	eax, edi
	add	esi, edi
	test	cl, cl
	jne	SHORT $LL181@CreateTrad@2
$LN183@CreateTrad@2:
	xor	eax, eax
	jmp	SHORT $LN184@CreateTrad@2
$LN182@CreateTrad@2:
	sbb	eax, eax
	sbb	eax, -1
$LN184@CreateTrad@2:
	test	eax, eax
	jne	SHORT $LN185@CreateTrad@2

; 3417 : 			{
; 3418 : 				bConnectedToIndia = true;

	mov	BYTE PTR _bConnectedToIndia$221998[esp+2536], 1
$LN185@CreateTrad@2:

; 3419 : 			}
; 3420 : 		}

	mov	DWORD PTR __$EHRec$[esp+2544], -1
$LN191@CreateTrad@2:
	mov	eax, DWORD PTR _kConnection$222005[esp+2580]
	lea	ecx, DWORD PTR _kConnection$222005[esp+2592]
	cmp	eax, ecx
$LN190@CreateTrad@2:
	je	SHORT $LN15@CreateTrad@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN15@CreateTrad@2:
	add	DWORD PTR tv1034[esp+2536], 444		; 000001bcH
	inc	ebx
	cmp	ebx, DWORD PTR [ebp+4]
	jb	$LL16@CreateTrad@2

; 3421 : 
; 3422 : 		if (bConnectedToArabs && bConnectedToPersia && bConnectedToMongols && bConnectedToChina && bConnectedToIndia)

	cmp	BYTE PTR _bConnectedToArabs$221994[esp+2536], 0
	je	SHORT $LN1@CreateTrad@2
	cmp	BYTE PTR _bConnectedToPersia$221995[esp+2536], 0
	je	SHORT $LN1@CreateTrad@2
	cmp	BYTE PTR _bConnectedToMongols$221996[esp+2536], 0
	je	SHORT $LN1@CreateTrad@2
	cmp	BYTE PTR _bConnectedToChina$221997[esp+2536], 0
	je	SHORT $LN1@CreateTrad@2
	cmp	BYTE PTR _bConnectedToIndia$221998[esp+2536], 0
	je	SHORT $LN1@CreateTrad@2

; 3423 : 		{
; 3424 : 			gDLL->UnlockAchievement(ACHIEVEMENT_XP2_29);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	271					; 0000010fH
	call	eax
$LN1@CreateTrad@2:
	pop	esi

; 3425 : 		}
; 3426 : 	}
; 3427 : 
; 3428 : 	return true;

	mov	al, 1
	pop	ebp
$LN25@CreateTrad@2:

; 3429 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+2528]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 2520				; 000009d8H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z$0:
	lea	ecx, DWORD PTR _kConnection$222005[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__ehhandler$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ENDP ; CvPlayerTrade::CreateTradeRoute
PUBLIC	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z
_TEXT	SEGMENT
$T262381 = -4						; size = 1
__Cat$262385 = 8					; size = 1
$T262351 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 810  : 		if (size() < capacity())

	mov	ebp, DWORD PTR [edi+4]
	test	ebp, ebp
	jne	SHORT $LN9@push_back@7
	xor	esi, esi
	jmp	SHORT $LN10@push_back@7
$LN9@push_back@7:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@push_back@7:
	mov	ebx, DWORD PTR [edi+8]
	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$262385[esp+16]
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	BYTE PTR $T262381[esp+20], 0
	mov	ecx, DWORD PTR $T262381[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
	add	esp, 24					; 00000018H
	add	ebx, 448				; 000001c0H
	mov	DWORD PTR [edi+8], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@7:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	ebx
	lea	edx, DWORD PTR $T262351[esp+24]
	push	edx
	mov	ecx, edi
	call	?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+32]
	push	edi
	mov	edi, DWORD PTR __First$[esp+36]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	mov	DWORD PTR __Tempbuf$[esp+52], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+40]
	mov	DWORD PTR __Tempbuf$[esp+40], edx
	mov	DWORD PTR __Tempbuf$[esp+44], edx
	mov	DWORD PTR __Tempbuf$[esp+48], edx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	mov	DWORD PTR __$EHRec$[esp+48], edx

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+36]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H

; 3565 : 	}

	lea	ecx, DWORD PTR __Tempbuf$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
PUBLIC	??$stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z ; std::stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z PROC ; std::stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN1@stable_sor:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
_TEXT	ENDS
PUBLIC	?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::PrioritizeTradeRoutes
EXTRN	?GetSpaceshipProject@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpaceshipProject
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ:PROC ; CvCity::getProductionUnit
EXTRN	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ:PROC ; CvCitySpecializationAI::GetWonderBuildCity
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetHappiness@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetHappiness
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$25
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$26
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$27
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$28
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
$T262481 = -540						; size = 1
$T262478 = -540						; size = 1
$T262474 = -540						; size = 1
$T265884 = -540						; size = 4
$T265859 = -540						; size = 4
$T265832 = -540						; size = 4
$T265807 = -540						; size = 4
$T262477 = -540						; size = 4
_pWonderCity$ = -540					; size = 4
_this$ = -536						; size = 4
_pCity$ = -532						; size = 4
_iCityLoop$223323 = -532				; size = 4
_apProductionTargetCities$ = -528			; size = 16
_aFoodSortedTR$ = -512					; size = 16
_aGoldSortedTR$ = -496					; size = 16
_aProductionSortedTR$ = -480				; size = 16
_iCityLoop$ = -464					; size = 4
_kElement$223526 = -460					; size = 448
_kElement$223516 = -460					; size = 448
_kElement$223335 = -460					; size = 448
__$EHRec$ = -12						; size = 12
_aTradeConnectionList$ = 8				; size = 4
?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z PROC ; CvTradeAI::PrioritizeTradeRoutes, COMDAT
; _this$ = ecx

; 5345 : {	

	push	-1
	push	__ehhandler$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 528				; 00000210H
	push	ebx
	push	ebp
	push	esi

; 5346 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5347 : 	GetAvailableTR(aTradeConnectionList);

	mov	esi, DWORD PTR _aTradeConnectionList$[esp+548]
	push	edi
	mov	edi, ecx
	push	esi
	mov	DWORD PTR _this$[esp+560], edi
	call	?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::GetAvailableTR

; 5348 : 
; 5349 : 	// if the list is empty, bail
; 5350 : 	if (aTradeConnectionList.size() == 0)

	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	cmp	ecx, eax
	je	$LN928@Prioritize

; 5351 : 	{
; 5352 : 		return;
; 5353 : 	}
; 5354 : 
; 5355 : 	// score TR
; 5356 : 	std::vector<TRSortElement> aProductionSortedTR;

	mov	DWORD PTR _aProductionSortedTR$[esp+560], eax
	mov	DWORD PTR _aProductionSortedTR$[esp+564], eax
	mov	DWORD PTR _aProductionSortedTR$[esp+568], eax
	mov	DWORD PTR __$EHRec$[esp+564], eax

; 5357 : 	std::vector<TRSortElement> aFoodSortedTR;

	mov	DWORD PTR _aFoodSortedTR$[esp+560], eax
	mov	DWORD PTR _aFoodSortedTR$[esp+564], eax
	mov	DWORD PTR _aFoodSortedTR$[esp+568], eax

; 5358 : 	std::vector<TRSortElement> aGoldSortedTR;

	mov	DWORD PTR _aGoldSortedTR$[esp+560], eax
	mov	DWORD PTR _aGoldSortedTR$[esp+564], eax
	mov	DWORD PTR _aGoldSortedTR$[esp+568], eax

; 5359 : 
; 5360 : 	// FOOD FOOD FOOD FOOD
; 5361 : 	if (m_pPlayer->GetHappiness() >= 0)

	mov	ecx, DWORD PTR [edi+4]
	mov	BYTE PTR __$EHRec$[esp+564], 2
	call	?GetHappiness@CvPlayer@@QBEHXZ		; CvPlayer::GetHappiness
	test	eax, eax
	jl	$LN254@Prioritize

; 5362 : 	{
; 5363 : 		// - Find smallest city
; 5364 : 		int iSmallestCitySize = MAX_INT;
; 5365 : 		CvCity* pSmallestCity = NULL;

	xor	ebx, ebx

; 5366 : 		int iCityLoop;
; 5367 : 		CvCity* pCity = NULL;
; 5368 : 		for (pCity = m_pPlayer->firstCity(&iCityLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iCityLoop))

	push	ebx
	lea	eax, DWORD PTR _iCityLoop$223323[esp+560]
	mov	ecx, edi
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	mov	ebp, 2147483647				; 7fffffffH
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	$LN254@Prioritize
$LL33@Prioritize:

; 5369 : 		{
; 5370 : 			int iCitySize = pCity->getPopulation();

	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation

; 5371 : 			if (iCitySize < iSmallestCitySize)

	cmp	eax, ebp
	jge	SHORT $LN32@Prioritize

; 5372 : 			{
; 5373 : 				pSmallestCity = pCity;

	mov	ebx, edi

; 5374 : 				iSmallestCitySize = iCitySize;

	mov	ebp, eax
$LN32@Prioritize:
	mov	eax, DWORD PTR _this$[esp+556]
	mov	ecx, DWORD PTR [eax+4]
	push	0
	lea	edx, DWORD PTR _iCityLoop$223323[esp+560]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL33@Prioritize

; 5375 : 			}
; 5376 : 		}
; 5377 : 
; 5378 : 		// - Send tr there
; 5379 : 		// if there is a smallest city, score according to that
; 5380 : 		if (pSmallestCity)

	test	ebx, ebx
	je	$LN254@Prioritize

; 5381 : 		{
; 5382 : 			aFoodSortedTR.clear();
; 5383 : #ifdef AUI_ITERATORIZE
; 5384 : 			for (TradeConnectionList::iterator it = aTradeConnectionList.begin(); it != aTradeConnectionList.end(); ++it)
; 5385 : 			{
; 5386 : 				TRSortElement kElement;
; 5387 : 				kElement.m_kTradeConnection = *it;
; 5388 : 				kElement.m_iScore = ScoreFoodTR(*it, pSmallestCity);
; 5389 : #else
; 5390 : 			for (uint ui = 0; ui < aTradeConnectionList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+4], ebp
	jbe	$LN26@Prioritize
	npad	2
$LL28@Prioritize:

; 5391 : 			{
; 5392 : 				TRSortElement kElement;

	lea	ecx, DWORD PTR _kElement$223335[esp+612]
	mov	DWORD PTR _kElement$223335[esp+604], 0
	mov	DWORD PTR _kElement$223335[esp+608], 40	; 00000028H
	mov	DWORD PTR _kElement$223335[esp+600], ecx

; 5393 : 				kElement.m_kTradeConnection = aTradeConnectionList[ui];

	mov	edx, DWORD PTR [esi]
	add	edx, edi
	push	edx
	lea	ecx, DWORD PTR _kElement$223335[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 3
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 5394 : 				kElement.m_iScore = ScoreFoodTR(aTradeConnectionList[ui], pSmallestCity);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+556]
	add	eax, edi
	push	ebx
	push	eax
	call	?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z ; CvTradeAI::ScoreFoodTR
	mov	DWORD PTR _kElement$223335[esp+1000], eax

; 5395 : #endif
; 5396 : 				if (kElement.m_iScore > 0)

	test	eax, eax
	jle	SHORT $LN25@Prioritize

; 5397 : 				{
; 5398 : 					aFoodSortedTR.push_back(kElement);

	lea	eax, DWORD PTR _kElement$223335[esp+556]
	push	eax
	lea	ecx, DWORD PTR _aFoodSortedTR$[esp+560]
	call	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
$LN25@Prioritize:

; 5399 : 				}
; 5400 : 			}

	mov	eax, DWORD PTR _kElement$223335[esp+600]
	lea	ecx, DWORD PTR _kElement$223335[esp+612]
	mov	BYTE PTR __$EHRec$[esp+564], 2
	cmp	eax, ecx
	je	SHORT $LN27@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@Prioritize:
	inc	ebp
	add	edi, 444				; 000001bcH
	cmp	ebp, DWORD PTR [esi+4]
	jb	$LL28@Prioritize
$LN26@Prioritize:

; 5401 : 
; 5402 : 			std::stable_sort(aFoodSortedTR.begin(), aFoodSortedTR.end(), SortTR());

	mov	edx, DWORD PTR _aFoodSortedTR$[esp+564]
	mov	BYTE PTR $T262474[esp+556], 0
	cmp	DWORD PTR _aFoodSortedTR$[esp+560], edx
	je	SHORT $LN254@Prioritize
	mov	eax, DWORD PTR $T262474[esp+556]
	push	eax
	push	0
	mov	ecx, edx
	mov	edx, DWORD PTR _aFoodSortedTR$[esp+568]
	push	0
	push	ecx
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN254@Prioritize:

; 5403 : 		}
; 5404 : 	}
; 5405 : 
; 5406 : 	// PRODUCTION PRODUCTION PRODUCTION PRODUCTION
; 5407 : 	// - Search for wonder city
; 5408 : 	// - Search for spaceship city
; 5409 : #ifdef AUI_CONSTIFY
; 5410 : 	std::vector<const CvCity*> apProductionTargetCities;
; 5411 : #else
; 5412 : 	std::vector<CvCity*> apProductionTargetCities;

	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR _apProductionTargetCities$[esp+560], ebx
	mov	DWORD PTR _apProductionTargetCities$[esp+564], edi
	mov	DWORD PTR _apProductionTargetCities$[esp+568], edi

; 5413 : #endif
; 5414 : 	CvCity* pWonderCity = m_pPlayer->GetCitySpecializationAI()->GetWonderBuildCity();

	mov	eax, DWORD PTR _this$[esp+556]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR __$EHRec$[esp+564], 4
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ ; CvCitySpecializationAI::GetWonderBuildCity
	mov	DWORD PTR _pWonderCity$[esp+556], eax

; 5415 : 	if (pWonderCity)

	cmp	eax, edi
	je	SHORT $LN983@Prioritize

; 5416 : 	{
; 5417 : 		apProductionTargetCities.push_back(pWonderCity);

	lea	ecx, DWORD PTR _pWonderCity$[esp+556]
	push	ecx
	xor	eax, eax
	push	1
	push	eax
	lea	ecx, DWORD PTR _apProductionTargetCities$[esp+568]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	mov	edi, DWORD PTR _apProductionTargetCities$[esp+564]
	mov	ebx, DWORD PTR _apProductionTargetCities$[esp+560]
$LN983@Prioritize:

; 5418 : 	}
; 5419 : 	CvCity* pCity = NULL;
; 5420 : 	int iCityLoop;
; 5421 : 	for (pCity = m_pPlayer->firstCity(&iCityLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iCityLoop))

	mov	eax, DWORD PTR _this$[esp+556]
	mov	ecx, DWORD PTR [eax+4]
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+560]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	mov	DWORD PTR _pCity$[esp+556], ebp
	test	ebp, ebp
	je	$LN21@Prioritize
	npad	4
$LL23@Prioritize:

; 5422 : 	{
; 5423 : 		UnitTypes eUnit = pCity->getProductionUnit();

	mov	ecx, ebp
	call	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ ; CvCity::getProductionUnit

; 5424 : 		if (eUnit != -1)

	cmp	eax, -1
	je	SHORT $LN22@Prioritize

; 5425 : 		{
; 5426 : 			CvUnitEntry *pkUnit = GC.GetGameUnits()->GetEntry(eUnit);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry

; 5427 : 			if (pkUnit)

	test	eax, eax
	je	SHORT $LN22@Prioritize

; 5428 : 			{
; 5429 : 				if (pkUnit->GetSpaceshipProject() != NO_PROJECT)

	mov	ecx, eax
	call	?GetSpaceshipProject@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetSpaceshipProject
	cmp	eax, -1
	je	SHORT $LN22@Prioritize

; 5430 : 				{
; 5431 : 					apProductionTargetCities.push_back(pCity);

	test	ebx, ebx
	jne	SHORT $LN370@Prioritize
	xor	eax, eax
	jmp	SHORT $LN371@Prioritize
$LN370@Prioritize:
	mov	eax, DWORD PTR _apProductionTargetCities$[esp+568]
	sub	eax, ebx
	sar	eax, 2
$LN371@Prioritize:
	mov	ecx, edi
	sub	ecx, ebx
	sar	ecx, 2
	cmp	ecx, eax
	jae	SHORT $LN363@Prioritize
	mov	DWORD PTR [edi], ebp
	add	edi, 4
	mov	DWORD PTR _apProductionTargetCities$[esp+564], edi
	jmp	SHORT $LN22@Prioritize
$LN363@Prioritize:
	lea	edx, DWORD PTR _pCity$[esp+556]
	push	edx
	push	1
	push	edi
	lea	ecx, DWORD PTR _apProductionTargetCities$[esp+568]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	mov	edi, DWORD PTR _apProductionTargetCities$[esp+564]
	mov	ebx, DWORD PTR _apProductionTargetCities$[esp+560]
$LN22@Prioritize:
	mov	ecx, DWORD PTR _this$[esp+556]
	mov	ecx, DWORD PTR [ecx+4]
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+560]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	mov	DWORD PTR _pCity$[esp+556], ebp
	test	ebp, ebp
	jne	$LL23@Prioritize
$LN21@Prioritize:

; 5432 : 				}
; 5433 : 			}
; 5434 : 		}
; 5435 : 	}
; 5436 : 	if (apProductionTargetCities.size() > 0)

	sub	edi, ebx
	sar	edi, 2
	test	edi, edi
	jbe	$LN985@Prioritize

; 5437 : 	{
; 5438 : 		aProductionSortedTR.clear();
; 5439 : #ifdef AUI_ITERATORIZE
; 5440 : 		for (TradeConnectionList::iterator it = aTradeConnectionList.begin(); it != aTradeConnectionList.end(); ++it)
; 5441 : 		{
; 5442 : 			TRSortElement kElement;
; 5443 : 			kElement.m_kTradeConnection = *it;
; 5444 : 			kElement.m_iScore = ScoreProductionTR(*it, apProductionTargetCities);
; 5445 : #else
; 5446 : 		for (uint ui = 0; ui < aTradeConnectionList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+4], ebp
	jbe	$LN984@Prioritize
	mov	ebx, DWORD PTR _this$[esp+556]
	xor	edi, edi
	npad	3
$LL16@Prioritize:

; 5447 : 		{
; 5448 : 			TRSortElement kElement;

	lea	edx, DWORD PTR _kElement$223516[esp+612]
	mov	DWORD PTR _kElement$223516[esp+604], 0
	mov	DWORD PTR _kElement$223516[esp+608], 40	; 00000028H
	mov	DWORD PTR _kElement$223516[esp+600], edx

; 5449 : 			kElement.m_kTradeConnection = aTradeConnectionList[ui];

	mov	eax, DWORD PTR [esi]
	add	eax, edi
	push	eax
	lea	ecx, DWORD PTR _kElement$223516[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 5
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 5450 : 			kElement.m_iScore = ScoreProductionTR(aTradeConnectionList[ui], apProductionTargetCities);

	sub	esp, 16					; 00000010H
	lea	edx, DWORD PTR _apProductionTargetCities$[esp+572]
	mov	ecx, esp
	mov	DWORD PTR $T262477[esp+572], esp
	push	edx
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	eax, DWORD PTR [esi]
	add	eax, edi
	push	eax
	mov	ecx, ebx
	call	?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvTradeAI::ScoreProductionTR
	mov	DWORD PTR _kElement$223516[esp+1000], eax

; 5451 : #endif
; 5452 : 			if (kElement.m_iScore > 0)

	test	eax, eax
	jle	SHORT $LN13@Prioritize

; 5453 : 			{
; 5454 : 				aProductionSortedTR.push_back(kElement);

	lea	eax, DWORD PTR _kElement$223516[esp+556]
	push	eax
	lea	ecx, DWORD PTR _aProductionSortedTR$[esp+560]
	call	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
$LN13@Prioritize:

; 5455 : 			}
; 5456 : 		}

	mov	eax, DWORD PTR _kElement$223516[esp+600]
	lea	ecx, DWORD PTR _kElement$223516[esp+612]
	mov	BYTE PTR __$EHRec$[esp+564], 4
	cmp	eax, ecx
	je	SHORT $LN15@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN15@Prioritize:
	inc	ebp
	add	edi, 444				; 000001bcH
	cmp	ebp, DWORD PTR [esi+4]
	jb	$LL16@Prioritize
$LN984@Prioritize:

; 5457 : 		std::stable_sort(aProductionSortedTR.begin(), aProductionSortedTR.end(), SortTR());

	mov	ecx, DWORD PTR _aProductionSortedTR$[esp+560]
	mov	eax, DWORD PTR _aProductionSortedTR$[esp+564]
	mov	BYTE PTR $T262478[esp+556], 0
	cmp	ecx, eax
	je	SHORT $LN985@Prioritize
	mov	edx, DWORD PTR $T262478[esp+556]
	push	edx
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN985@Prioritize:

; 5458 : 	}
; 5459 : 
; 5460 : 	// GOLD GOLD GOLD GOLD
; 5461 : 	aGoldSortedTR.clear();
; 5462 : #ifdef AUI_ITERATORIZE
; 5463 : 	for (TradeConnectionList::iterator it = aTradeConnectionList.begin(); it != aTradeConnectionList.end(); ++it)
; 5464 : 	{
; 5465 : 		TRSortElement kElement;
; 5466 : 		kElement.m_kTradeConnection = *it;
; 5467 : 		kElement.m_iScore = ScoreInternationalTR(*it);
; 5468 : #else
; 5469 : 	for (uint ui = 0; ui < aTradeConnectionList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+4], ebp
	jbe	$LN986@Prioritize
	mov	ebx, DWORD PTR _this$[esp+556]
	xor	edi, edi
	npad	6
$LL12@Prioritize:

; 5470 : 	{
; 5471 : 		TRSortElement kElement;

	lea	eax, DWORD PTR _kElement$223526[esp+612]
	mov	DWORD PTR _kElement$223526[esp+604], 0
	mov	DWORD PTR _kElement$223526[esp+608], 40	; 00000028H
	mov	DWORD PTR _kElement$223526[esp+600], eax

; 5472 : 		kElement.m_kTradeConnection = aTradeConnectionList[ui];

	mov	ecx, DWORD PTR [esi]
	add	ecx, edi
	push	ecx
	lea	ecx, DWORD PTR _kElement$223526[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 6
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 5473 : 		kElement.m_iScore = ScoreInternationalTR(aTradeConnectionList[ui]);

	mov	eax, DWORD PTR [esi]
	add	eax, edi
	push	eax
	mov	ecx, ebx
	call	?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z ; CvTradeAI::ScoreInternationalTR
	mov	DWORD PTR _kElement$223526[esp+1000], eax

; 5474 : #endif
; 5475 : 		if (kElement.m_iScore > 0)

	test	eax, eax
	jle	SHORT $LN9@Prioritize

; 5476 : 		{
; 5477 : 			aGoldSortedTR.push_back(kElement);

	lea	edx, DWORD PTR _kElement$223526[esp+556]
	push	edx
	lea	ecx, DWORD PTR _aGoldSortedTR$[esp+560]
	call	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
$LN9@Prioritize:

; 5478 : 		}
; 5479 : 	}

	mov	eax, DWORD PTR _kElement$223526[esp+600]
	lea	ecx, DWORD PTR _kElement$223526[esp+612]
	mov	BYTE PTR __$EHRec$[esp+564], 4
	cmp	eax, ecx
	je	SHORT $LN11@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN11@Prioritize:
	inc	ebp
	add	edi, 444				; 000001bcH
	cmp	ebp, DWORD PTR [esi+4]
	jb	$LL12@Prioritize
$LN986@Prioritize:

; 5480 : 	std::stable_sort(aGoldSortedTR.begin(), aGoldSortedTR.end(), SortTR());

	mov	ecx, DWORD PTR _aGoldSortedTR$[esp+560]
	mov	eax, DWORD PTR _aGoldSortedTR$[esp+564]
	mov	BYTE PTR $T262481[esp+556], 0
	cmp	ecx, eax
	je	SHORT $LN701@Prioritize
	mov	edx, DWORD PTR $T262481[esp+556]
	push	edx
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN701@Prioritize:

; 5481 : 	uint uiNumInternationalTradesToAdd = 2;
; 5482 : 
; 5483 : 	// clear list
; 5484 : 	aTradeConnectionList.clear();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	jbe	SHORT $LN714@Prioritize
	add	edi, 44					; 0000002cH
	mov	ebx, eax
$LL716@Prioritize:
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	je	SHORT $LN728@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN728@Prioritize:
	add	edi, 444				; 000001bcH
	sub	ebx, 1
	jne	SHORT $LL716@Prioritize
$LN714@Prioritize:

; 5485 : 
; 5486 : 	// add all the gold trs
; 5487 : #ifdef AUI_ITERATORIZE
; 5488 : 	std::vector<TRSortElement>::iterator it;
; 5489 : 	uint ui = 0;
; 5490 : 	for (it = aGoldSortedTR.begin(); ui < uiNumInternationalTradesToAdd && it < aGoldSortedTR.end(); ++it)
; 5491 : 	{
; 5492 : 		aTradeConnectionList.push_back(it->m_kTradeConnection);
; 5493 : 		ui++;
; 5494 : #else
; 5495 : 	for (uint ui = 0; ui < uiNumInternationalTradesToAdd && ui < aGoldSortedTR.size(); ui++)

	mov	ecx, DWORD PTR _aGoldSortedTR$[esp+564]
	mov	ebp, DWORD PTR _aGoldSortedTR$[esp+560]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	ebx, edx
	xor	edi, edi
	shr	ebx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], edi
	add	ebx, edx
$LL8@Prioritize:
	cmp	edi, ebx
	jae	SHORT $LN6@Prioritize

; 5496 : 	{
; 5497 : 		aTradeConnectionList.push_back(aGoldSortedTR[ui].m_kTradeConnection);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+74604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN744@Prioritize
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
$LN744@Prioritize:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T265807[esp+556], ecx
	mov	BYTE PTR __$EHRec$[esp+564], 7
	je	SHORT $LN747@Prioritize
	push	ebp
	call	??0TradeConnection@@QAE@ABU0@@Z
$LN747@Prioritize:
	inc	DWORD PTR [esi+4]
	inc	edi
	add	ebp, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[esp+564], 4
	cmp	edi, 2
	jb	SHORT $LL8@Prioritize
$LN6@Prioritize:

; 5498 : #endif
; 5499 : 	}
; 5500 : 
; 5501 : 	// add first food
; 5502 : 	if (aFoodSortedTR.size() > 0) 

	mov	ecx, DWORD PTR _aFoodSortedTR$[esp+564]
	mov	edi, DWORD PTR _aFoodSortedTR$[esp+560]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN981@Prioritize

; 5503 : 	{
; 5504 : #ifdef AUI_ITERATORIZE
; 5505 : 		aTradeConnectionList.push_back(aFoodSortedTR.begin()->m_kTradeConnection);
; 5506 : #else
; 5507 : 		aTradeConnectionList.push_back(aFoodSortedTR[0].m_kTradeConnection);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+74604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN756@Prioritize
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
$LN756@Prioritize:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T265832[esp+556], ecx
	mov	BYTE PTR __$EHRec$[esp+564], 8
	je	SHORT $LN759@Prioritize
	push	edi
	call	??0TradeConnection@@QAE@ABU0@@Z
$LN759@Prioritize:
	inc	DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+564], 4
$LN981@Prioritize:

; 5508 : #endif
; 5509 : 	}
; 5510 : 	
; 5511 : 	// add first production tr
; 5512 : 	if (aProductionSortedTR.size() > 0)

	mov	ecx, DWORD PTR _aProductionSortedTR$[esp+564]
	mov	ebp, DWORD PTR _aProductionSortedTR$[esp+560]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 8
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	SHORT $LN769@Prioritize

; 5513 : 	{
; 5514 : #ifdef AUI_ITERATORIZE
; 5515 : 		aTradeConnectionList.push_back(aProductionSortedTR.begin()->m_kTradeConnection);
; 5516 : #else
; 5517 : 		aTradeConnectionList.push_back(aProductionSortedTR[0].m_kTradeConnection);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+74604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN768@Prioritize
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
$LN768@Prioritize:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T265859[esp+556], ecx
	mov	BYTE PTR __$EHRec$[esp+564], 9
	je	SHORT $LN771@Prioritize
	push	ebp
	call	??0TradeConnection@@QAE@ABU0@@Z
$LN771@Prioritize:
	inc	DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+564], 4
$LN769@Prioritize:

; 5518 : #endif
; 5519 : 	}
; 5520 : 
; 5521 : 	// add all the gold trs
; 5522 : #ifdef AUI_ITERATORIZE
; 5523 : 	for (;it < aGoldSortedTR.end(); ++it)
; 5524 : 	{
; 5525 : 		aTradeConnectionList.push_back(it->m_kTradeConnection);
; 5526 : #else
; 5527 : 	for (uint ui = uiNumInternationalTradesToAdd; ui < aGoldSortedTR.size(); ui++)

	mov	ebp, DWORD PTR _aGoldSortedTR$[esp+560]
	cmp	ebx, 2
	jbe	SHORT $LN1@Prioritize
	lea	edi, DWORD PTR [ebp+896]
	add	ebx, -2					; fffffffeH
	npad	10
$LL3@Prioritize:

; 5528 : 	{
; 5529 : 		aTradeConnectionList.push_back(aGoldSortedTR[ui].m_kTradeConnection);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+74604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN780@Prioritize
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
$LN780@Prioritize:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T265884[esp+556], ecx
	mov	BYTE PTR __$EHRec$[esp+564], 10		; 0000000aH
	je	SHORT $LN783@Prioritize
	push	edi
	call	??0TradeConnection@@QAE@ABU0@@Z
$LN783@Prioritize:
	inc	DWORD PTR [esi+4]
	add	edi, 448				; 000001c0H
	sub	ebx, 1
	mov	BYTE PTR __$EHRec$[esp+564], 4
	jne	SHORT $LL3@Prioritize

; 5518 : #endif
; 5519 : 	}
; 5520 : 
; 5521 : 	// add all the gold trs
; 5522 : #ifdef AUI_ITERATORIZE
; 5523 : 	for (;it < aGoldSortedTR.end(); ++it)
; 5524 : 	{
; 5525 : 		aTradeConnectionList.push_back(it->m_kTradeConnection);
; 5526 : #else
; 5527 : 	for (uint ui = uiNumInternationalTradesToAdd; ui < aGoldSortedTR.size(); ui++)

	mov	edi, DWORD PTR _aFoodSortedTR$[esp+560]
$LN1@Prioritize:

; 5530 : #endif
; 5531 : 	}
; 5532 : }

	mov	eax, DWORD PTR _apProductionTargetCities$[esp+560]
	test	eax, eax
	je	SHORT $LN793@Prioritize
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN793@Prioritize:
	mov	BYTE PTR __$EHRec$[esp+564], 1
	test	ebp, ebp
	je	SHORT $LN838@Prioritize
	mov	edi, DWORD PTR _aGoldSortedTR$[esp+564]
	cmp	ebp, edi
	je	SHORT $LN806@Prioritize
	lea	esi, DWORD PTR [ebp+44]
$LL808@Prioritize:
	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+12]
	cmp	eax, edx
	je	SHORT $LN826@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN826@Prioritize:
	add	esi, 448				; 000001c0H
	lea	eax, DWORD PTR [esi-44]
	cmp	eax, edi
	jne	SHORT $LL808@Prioritize
$LN806@Prioritize:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	mov	edi, DWORD PTR _aFoodSortedTR$[esp+564]
	add	esp, 4
$LN838@Prioritize:
	mov	BYTE PTR __$EHRec$[esp+564], 0
	test	edi, edi
	je	SHORT $LN883@Prioritize
	mov	ebx, DWORD PTR _aFoodSortedTR$[esp+564]
	cmp	edi, ebx
	je	SHORT $LN851@Prioritize
	lea	esi, DWORD PTR [edi+44]
	npad	5
$LL853@Prioritize:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN871@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN871@Prioritize:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, ebx
	jne	SHORT $LL853@Prioritize
$LN851@Prioritize:
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN883@Prioritize:
	mov	ebx, DWORD PTR _aProductionSortedTR$[esp+560]
	mov	DWORD PTR __$EHRec$[esp+564], -1
	test	ebx, ebx
	je	SHORT $LN928@Prioritize
	mov	edi, DWORD PTR _aProductionSortedTR$[esp+564]
	cmp	ebx, edi
	je	SHORT $LN896@Prioritize
	lea	esi, DWORD PTR [ebx+44]
$LL898@Prioritize:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN916@Prioritize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN916@Prioritize:
	add	esi, 448				; 000001c0H
	lea	edx, DWORD PTR [esi-44]
	cmp	edx, edi
	jne	SHORT $LL898@Prioritize
$LN896@Prioritize:
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN928@Prioritize:
	mov	ecx, DWORD PTR __$EHRec$[esp+556]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 540				; 0000021cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0:
	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	jmp	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$1:
	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	jmp	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$2:
	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	jmp	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$3:
	lea	ecx, DWORD PTR _kElement$223335[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$4:
	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$5:
	lea	ecx, DWORD PTR _kElement$223516[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$7:
	lea	ecx, DWORD PTR _kElement$223526[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$25:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T265807[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$26:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T265832[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$27:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T265859[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$28:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp-4]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp-4]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T265884[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ENDP ; CvTradeAI::PrioritizeTradeRoutes
END
