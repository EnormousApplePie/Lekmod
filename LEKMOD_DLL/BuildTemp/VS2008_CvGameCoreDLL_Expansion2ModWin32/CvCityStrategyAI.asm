; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCityStrategyAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA	; CvCityStrategyAI::m_acBestYields
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
_BSS	SEGMENT
?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA DB 0deH DUP (?) ; CvCityStrategyAI::m_acBestYields
_BSS	ENDS
CONST	SEGMENT
$SG225490 DB	'NoMinorCivs', 00H
$SG225491 DB	'Permanent', 00H
	ORG $+2
$SG225492 DB	'CheckTriggerTurnCount', 00H
	ORG $+2
$SG225493 DB	'MinimumNumTurnsExecuted', 00H
$SG225494 DB	'WeightThreshold', 00H
$SG225496 DB	'Advisor', 00H
$SG225499 DB	'MILITARY', 00H
	ORG $+3
$SG225502 DB	'ECONOMIC', 00H
	ORG $+3
$SG225505 DB	'FOREIGN', 00H
$SG225508 DB	'SCIENCE', 00H
$SG225509 DB	'AdvisorCounsel', 00H
	ORG $+1
$SG225510 DB	'AdvisorCounselImportance', 00H
	ORG $+3
$SG225512 DB	'TechObsolete', 00H
	ORG $+3
$SG225513 DB	'TechPrereq', 00H
	ORG $+1
$SG225515 DB	'AICityStrategyType', 00H
	ORG $+1
$SG225516 DB	'AICityStrategy_Flavors', 00H
	ORG $+1
$SG225517 DB	'AICityStrategyType', 00H
	ORG $+1
$SG225518 DB	'AICityStrategy_PersonalityFlavorThresholdMods', 00H
	ORG $+2
$SG226041 DB	'.csv', 00H
	ORG $+3
$SG226042 DB	'_', 00H
	ORG $+2
$SG226043 DB	'CityStrategyAILog_', 00H
	ORG $+1
$SG226045 DB	'CityStrategyAILog.csv', 00H
	ORG $+2
$SG226285 DB	'ECONOMICAISTRATEGY_ENOUGH_EXPANSION', 00H
$SG226291 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG226306 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG226342 DB	'GAMEOPTION_AI_GIMP_NO_WORLD_WONDER', 00H
	ORG $+1
$SG226389 DB	'GAMEOPTION_AI_GIMP_NO_WORLD_WONDER', 00H
	ORG $+1
$SG226411 DB	'Choosing city build from Top Choices', 00H
	ORG $+3
$SG226472 DB	'AICITYSTRATEGY_TINY_CITY', 00H
	ORG $+3
$SG226475 DB	'AICITYSTRATEGY_SMALL_CITY', 00H
	ORG $+2
$SG226478 DB	'AICITYSTRATEGY_MEDIUM_CITY', 00H
	ORG $+1
$SG226481 DB	'AICITYSTRATEGY_LARGE_CITY', 00H
	ORG $+2
$SG226484 DB	'AICITYSTRATEGY_LANDLOCKED', 00H
	ORG $+2
$SG226487 DB	'AICITYSTRATEGY_NEED_TILE_IMPROVERS', 00H
	ORG $+1
$SG226490 DB	'AICITYSTRATEGY_WANT_TILE_IMPROVERS', 00H
	ORG $+1
$SG226493 DB	'AICITYSTRATEGY_ENOUGH_TILE_IMPROVERS', 00H
	ORG $+3
$SG226496 DB	'AICITYSTRATEGY_NEED_NAVAL_GROWTH', 00H
	ORG $+3
$SG226499 DB	'AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT', 00H
	ORG $+1
$SG226502 DB	'AICITYSTRATEGY_ENOUGH_NAVAL_TILE_IMPROVEMENT', 00H
	ORG $+3
$SG226505 DB	'AICITYSTRATEGY_NEED_IMPROVEMENT_FOOD', 00H
	ORG $+3
$SG226508 DB	'AICITYSTRATEGY_NEED_IMPROVEMENT_PRODUCTION', 00H
	ORG $+1
$SG226511 DB	'AICITYSTRATEGY_HAVE_TRAINING_FACILITY', 00H
	ORG $+2
$SG226514 DB	'AICITYSTRATEGY_CAPITAL_NEED_SETTLER', 00H
$SG226517 DB	'AICITYSTRATEGY_CAPITAL_UNDER_THREAT', 00H
$SG226520 DB	'AICITYSTRATEGY_FIRST_CULTURE_BUILDING_EMERGENCY', 00H
$SG226523 DB	'AICITYSTRATEGY_FIRST_CULTURE_BUILDING', 00H
	ORG $+2
$SG226526 DB	'AICITYSTRATEGY_FIRST_SCIENCE_BUILDING', 00H
	ORG $+2
$SG226529 DB	'AICITYSTRATEGY_FIRST_GOLD_BUILDING', 00H
	ORG $+1
$SG226532 DB	'AICITYSTRATEGY_FIRST_FAITH_BUILDING', 00H
$SG226535 DB	'AICITYSTRATEGY_FIRST_PRODUCTION_BUILDING', 00H
	ORG $+3
$SG226538 DB	'AICITYSTRATEGY_UNDER_BLOCKADE', 00H
	ORG $+2
$SG226541 DB	'AICITYSTRATEGY_IS_PUPPET', 00H
	ORG $+3
$SG226544 DB	'AICITYSTRATEGY_MEDIUM_CITY_HIGH_DIFFICULTY', 00H
	ORG $+1
$SG226547 DB	'AICITYSTRATEGY_ORIGINAL_CAPITAL', 00H
$SG226550 DB	'AICITYSTRATEGY_RIVER_CITY', 00H
	ORG $+2
$SG226553 DB	'AICITYSTRATEGY_MOUNTAIN_CITY', 00H
	ORG $+3
$SG226556 DB	'AICITYSTRATEGY_FOREST_CITY', 00H
	ORG $+1
$SG226559 DB	'AICITYSTRATEGY_HILL_CITY', 00H
	ORG $+3
$SG226562 DB	'AICITYSTRATEGY_JUNGLE_CITY', 00H
	ORG $+1
$SG226565 DB	'AICITYSTRATEGY_COAST_CITY', 00H
	ORG $+2
$SG226568 DB	'AICITYSTRATEGY_MANY_TECHS_STOLEN', 00H
	ORG $+3
$SG226571 DB	'AICITYSTRATEGY_KEY_SCIENCE_CITY', 00H
$SG226574 DB	'AICITYSTRATEGY_GOOD_GP_CITY', 00H
$SG226577 DB	'AICITYSTRATEGY_NEED_INTERNATIONAL_LAND_TRADE_ROUTE', 00H
	ORG $+1
$SG226580 DB	'AICITYSTRATEGY_NO_NEED_INTERNATIONAL_LAND_TRADE_ROUTE', 00H
	ORG $+2
$SG226583 DB	'AICITYSTRATEGY_NEED_INTERNATIONAL_SEA_TRADE_ROUTE', 00H
	ORG $+2
$SG226586 DB	'AICITYSTRATEGY_NO_NEED_INTERNATIONAL_SEA_TRADE_ROUTE', 00H
	ORG $+3
$SG226589 DB	'AICITYSTRATEGY_INTERNATIONAL_TRADE_DESTINATION', 00H
	ORG $+1
$SG226592 DB	'AICITYSTRATEGY_INTERNATIONAL_TRADE_ORIGIN', 00H
	ORG $+2
$SG226595 DB	'AICITYSTRATEGY_NEED_CULTURE_BUILDING', 00H
	ORG $+3
$SG226598 DB	'AICITYSTRATEGY_NEED_TOURISM_BUILDING', 00H
	ORG $+3
$SG226601 DB	'AICITYSTRATEGY_GOOD_AIRLIFT_CITY', 00H
	ORG $+3
$SG226607 DB	'CityStrategyCanActivate', 00H
$SG226744 DB	'CITYSPECIALIZATION_SETTLER_PUMP', 00H
$SG226746 DB	'CITYSPECIALIZATION_COMMERCE', 00H
$SG226810 DB	'%03d, ', 00H
	ORG $+1
$SG226814 DB	', ', 00H
	ORG $+1
$SG226815 DB	', ', 00H
	ORG $+1
$SG226817 DB	'Pop rushed: %s, Spent: %d, Available: %d, Turns Saved: %'
	DB	'd', 00H
	ORG $+2
$SG226819 DB	'Gold rushed: %s, Spent: %d, Available: %d, Turns Saved: '
	DB	'%d', 00H
	ORG $+1
$SG226844 DB	'%03d, ', 00H
	ORG $+1
$SG226848 DB	', ', 00H
	ORG $+1
$SG226849 DB	', ', 00H
	ORG $+1
$SG226856 DB	'Flavor, %s, %d', 00H
	ORG $+1
$SG226859 DB	'Flavor, %s, %d', 00H
	ORG $+1
$SG226874 DB	'%03d, ', 00H
	ORG $+1
$SG226878 DB	', ', 00H
	ORG $+1
$SG226879 DB	', ', 00H
	ORG $+1
$SG226883 DB	'%s, %d', 00H
	ORG $+1
$SG226897 DB	'%03d, ', 00H
	ORG $+1
$SG226901 DB	', ', 00H
	ORG $+1
$SG226902 DB	', ', 00H
	ORG $+1
$SG226915 DB	'Building, %s, %d, %d', 00H
	ORG $+3
$SG226919 DB	'Unit, %s, %d, %d', 00H
	ORG $+3
$SG226923 DB	'Project, %s, %d, %d', 00H
$SG226928 DB	'Process, %s, %d, %d', 00H
$SG226932 DB	'Operation unit, %s, %d, %d', 00H
	ORG $+1
$SG226936 DB	'Army unit, %s, %d, %d', 00H
	ORG $+2
$SG226953 DB	'%03d, ', 00H
	ORG $+1
$SG226957 DB	', ', 00H
	ORG $+1
$SG226958 DB	', ', 00H
	ORG $+1
$SG226977 DB	'SEED: %d, CHOSEN: %s, Rush if possible, TURNS: %d', 00H
	ORG $+2
$SG226979 DB	'SEED: %d, CHOSEN: %s, Do not rush, TURNS: %d', 00H
	ORG $+3
$SG226992 DB	'%03d, ', 00H
	ORG $+1
$SG226996 DB	', ', 00H
	ORG $+1
$SG226997 DB	', ', 00H
	ORG $+1
$SG227003 DB	'Unknown', 00H
$SG227005 DB	'General Economy', 00H
$SG227010 DB	'NEW SPECIALIZATION: Yield Type = ', 00H
	ORG $+2
$SG227075 DB	'MILITARYAISTRATEGY_ERADICATE_BARBARIANS', 00H
$SG227149 DB	'AICITYSTRATEGY_NEED_TILE_IMPROVERS', 00H
	ORG $+1
$SG227202 DB	'AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT', 00H
	ORG $+1
$SG227227 DB	'AICITYSTRATEGY_CAPITAL_UNDER_THREAT', 00H
$SG227232 DB	'MILITARYAISTRATEGY_WAR_MOBILIZATION', 00H
$SG227278 DB	'FLAVOR_RELIGION', 00H
$SG227392 DB	'FLAVOR_ESPIONAGE', 00H
	ORG $+3
$SG227420 DB	'FLAVOR_ESPIONAGE', 00H
	ORG $+3
$SG227446 DB	'UNITCLASS_SCIENTIST', 00H
$SG227450 DB	'UNITCLASS_WRITER', 00H
	ORG $+3
$SG227454 DB	'UNITCLASS_ARTIST', 00H
	ORG $+3
$SG227458 DB	'UNITCLASS_MUSICIAN', 00H
	ORG $+1
$SG227464 DB	'UNITCLASS_MERCHANT', 00H
	ORG $+1
$SG227468 DB	'UNITCLASS_ENGINEER', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ	; CvEconomicAI::GetMinimumSettleFertility
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.h
;	COMDAT ?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ
_TEXT	SEGMENT
?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ PROC	; CvEconomicAI::GetMinimumSettleFertility, COMDAT
; _this$ = ecx

; 211  : 		return m_iMinimumSettleFertility;

	mov	eax, DWORD PTR [ecx+48]

; 212  : 	};

	ret	0
?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ ENDP	; CvEconomicAI::GetMinimumSettleFertility
_TEXT	ENDS
PUBLIC	?GetLastTurnWorkerDisbanded@CvEconomicAI@@QBEHXZ ; CvEconomicAI::GetLastTurnWorkerDisbanded
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastTurnWorkerDisbanded@CvEconomicAI@@QBEHXZ
_TEXT	SEGMENT
?GetLastTurnWorkerDisbanded@CvEconomicAI@@QBEHXZ PROC	; CvEconomicAI::GetLastTurnWorkerDisbanded, COMDAT
; _this$ = ecx

; 232  : 		return m_iLastTurnWorkerDisbanded;

	mov	eax, DWORD PTR [ecx+40]

; 233  : 	};

	ret	0
?GetLastTurnWorkerDisbanded@CvEconomicAI@@QBEHXZ ENDP	; CvEconomicAI::GetLastTurnWorkerDisbanded
_TEXT	ENDS
PUBLIC	?GetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberOfTimesOpsBuildSkippedOver
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.h
;	COMDAT ?GetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
?GetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QBEHXZ PROC ; CvMilitaryAI::GetNumberOfTimesOpsBuildSkippedOver, COMDAT
; _this$ = ecx

; 264  : 		return m_iNumberOfTimesOpsBuildSkippedOver;

	mov	eax, DWORD PTR [ecx+48]

; 265  : 	}

	ret	0
?GetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QBEHXZ ENDP ; CvMilitaryAI::GetNumberOfTimesOpsBuildSkippedOver
_TEXT	ENDS
PUBLIC	?BumpNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ ; CvMilitaryAI::BumpNumberOfTimesOpsBuildSkippedOver
; Function compile flags: /Ogtpy
;	COMDAT ?BumpNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
?BumpNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ PROC ; CvMilitaryAI::BumpNumberOfTimesOpsBuildSkippedOver, COMDAT
; _this$ = ecx

; 268  : 		++m_iNumberOfTimesOpsBuildSkippedOver;

	inc	DWORD PTR [ecx+48]

; 269  : 	}

	ret	0
?BumpNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ ENDP ; CvMilitaryAI::BumpNumberOfTimesOpsBuildSkippedOver
_TEXT	ENDS
PUBLIC	?ResetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ ; CvMilitaryAI::ResetNumberOfTimesOpsBuildSkippedOver
; Function compile flags: /Ogtpy
;	COMDAT ?ResetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
?ResetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ PROC ; CvMilitaryAI::ResetNumberOfTimesOpsBuildSkippedOver, COMDAT
; _this$ = ecx

; 272  : 		m_iNumberOfTimesOpsBuildSkippedOver = 0;

	mov	DWORD PTR [ecx+48], 0

; 273  : 	}

	ret	0
?ResetNumberOfTimesOpsBuildSkippedOver@CvMilitaryAI@@QAEXXZ ENDP ; CvMilitaryAI::ResetNumberOfTimesOpsBuildSkippedOver
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z	; CvAICityStrategyEntry::GetFlavorValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z PROC	; CvAICityStrategyEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 109  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 110  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 111  : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+260]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 112  : }

	ret	4
$LN3@GetFlavorV:

; 109  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 110  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 111  : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	or	eax, -1

; 112  : }

	ret	4
?GetFlavorValue@CvAICityStrategyEntry@@QBEHH@Z ENDP	; CvAICityStrategyEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetWeightThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ PROC	; CvAICityStrategyEntry::GetWeightThreshold, COMDAT
; _this$ = ecx

; 117  : 	return m_iWeightThreshold;

	mov	eax, DWORD PTR [ecx+264]

; 118  : }

	ret	0
?GetWeightThreshold@CvAICityStrategyEntry@@QBEHXZ ENDP	; CvAICityStrategyEntry::GetWeightThreshold
_TEXT	ENDS
PUBLIC	?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z PROC ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod, COMDAT
; _this$ = ecx

; 123  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 124  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 125  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	mov	eax, DWORD PTR [ecx+268]
	test	eax, eax
	je	SHORT $LN3@GetPersona
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 126  : }

	ret	4
$LN3@GetPersona:

; 123  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 124  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 125  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	or	eax, -1

; 126  : }

	ret	4
?GetPersonalityFlavorThresholdMod@CvAICityStrategyEntry@@QBEHH@Z ENDP ; CvAICityStrategyEntry::GetPersonalityFlavorThresholdMod
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ	; CvAICityStrategyEntry::GetTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ PROC	; CvAICityStrategyEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 131  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+272]

; 132  : }

	ret	0
?GetTechPrereq@CvAICityStrategyEntry@@QBEHXZ ENDP	; CvAICityStrategyEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ	; CvAICityStrategyEntry::GetTechObsolete
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ PROC	; CvAICityStrategyEntry::GetTechObsolete, COMDAT
; _this$ = ecx

; 137  : 	return m_iTechObsolete;

	mov	eax, DWORD PTR [ecx+276]

; 138  : }

	ret	0
?GetTechObsolete@CvAICityStrategyEntry@@QBEHXZ ENDP	; CvAICityStrategyEntry::GetTechObsolete
_TEXT	ENDS
PUBLIC	?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ PROC ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted, COMDAT
; _this$ = ecx

; 143  : 	return m_iMinimumNumTurnsExecuted;

	mov	eax, DWORD PTR [ecx+280]

; 144  : }

	ret	0
?GetMinimumNumTurnsExecuted@CvAICityStrategyEntry@@QBEHXZ ENDP ; CvAICityStrategyEntry::GetMinimumNumTurnsExecuted
_TEXT	ENDS
PUBLIC	?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetCheckTriggerTurnCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ PROC ; CvAICityStrategyEntry::GetCheckTriggerTurnCount, COMDAT
; _this$ = ecx

; 149  : 	return m_iCheckTriggerTurnCount;

	mov	eax, DWORD PTR [ecx+284]

; 150  : }

	ret	0
?GetCheckTriggerTurnCount@CvAICityStrategyEntry@@QBEHXZ ENDP ; CvAICityStrategyEntry::GetCheckTriggerTurnCount
_TEXT	ENDS
PUBLIC	?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ	; CvAICityStrategyEntry::IsNoMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ PROC	; CvAICityStrategyEntry::IsNoMinorCivs, COMDAT
; _this$ = ecx

; 155  : 	return m_bNoMinorCivs;

	mov	al, BYTE PTR [ecx+288]

; 156  : }

	ret	0
?IsNoMinorCivs@CvAICityStrategyEntry@@QBE_NXZ ENDP	; CvAICityStrategyEntry::IsNoMinorCivs
_TEXT	ENDS
PUBLIC	?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ	; CvAICityStrategyEntry::IsPermanent
; Function compile flags: /Ogtpy
;	COMDAT ?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ PROC	; CvAICityStrategyEntry::IsPermanent, COMDAT
; _this$ = ecx

; 161  : 	return m_bPermanent;

	mov	al, BYTE PTR [ecx+289]

; 162  : }

	ret	0
?IsPermanent@CvAICityStrategyEntry@@QBE_NXZ ENDP	; CvAICityStrategyEntry::IsPermanent
_TEXT	ENDS
PUBLIC	?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ ; CvAICityStrategyEntry::GetAdvisor
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ
_TEXT	SEGMENT
?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ PROC ; CvAICityStrategyEntry::GetAdvisor, COMDAT
; _this$ = ecx

; 166  : 	return m_eAdvisor;

	mov	eax, DWORD PTR [ecx+292]

; 167  : }

	ret	0
?GetAdvisor@CvAICityStrategyEntry@@QBE?AW4AdvisorTypes@@XZ ENDP ; CvAICityStrategyEntry::GetAdvisor
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ ; CvAICityStrategyEntry::GetAdvisorCounselText
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ PROC ; CvAICityStrategyEntry::GetAdvisorCounselText, COMDAT
; _this$ = ecx

; 171  : 	return m_strAdvisorCounselText.c_str();

	add	ecx, 296				; 00000128H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetAdvisorCounselText@CvAICityStrategyEntry@@QBEPBDXZ ENDP ; CvAICityStrategyEntry::GetAdvisorCounselText
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ ; CvAICityStrategyEntry::GetAdvisorCounselImportance
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ PROC ; CvAICityStrategyEntry::GetAdvisorCounselImportance, COMDAT
; _this$ = ecx

; 176  : 	return m_iAdvisorCounselImportance;

	mov	eax, DWORD PTR [ecx+324]

; 177  : }

	ret	0
?GetAdvisorCounselImportance@CvAICityStrategyEntry@@QBEHXZ ENDP ; CvAICityStrategyEntry::GetAdvisorCounselImportance
_TEXT	ENDS
PUBLIC	?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ; CvAICityStrategies::GetAICityStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ PROC ; CvAICityStrategies::GetAICityStrategyEntries, COMDAT
; _this$ = ecx

; 198  : {

	mov	eax, ecx

; 199  : 	return m_paAICityStrategyEntries;
; 200  : }

	ret	0
?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ENDP ; CvAICityStrategies::GetAICityStrategyEntries
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SetDefaultSpecialization
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_eDefaultSpecialization$ = 8				; size = 4
?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::SetDefaultSpecialization, COMDAT
; _this$ = ecx

; 503  : 	if(eDefaultSpecialization != m_eDefaultSpecialization)

	mov	eax, DWORD PTR _eDefaultSpecialization$[esp-4]
	cmp	eax, DWORD PTR [ecx+24]
	je	SHORT $LN1@SetDefault

; 504  : 	{
; 505  : 		m_eDefaultSpecialization = eDefaultSpecialization;

	mov	DWORD PTR [ecx+24], eax

; 506  : 		return true;

	mov	al, 1

; 510  : }

	ret	4
$LN1@SetDefault:

; 507  : 	}
; 508  : 
; 509  : 	return false;

	xor	al, al

; 510  : }

	ret	4
?SetDefaultSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::SetDefaultSpecialization
_TEXT	ENDS
PUBLIC	?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ	; CvCityStrategyAI::GetCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ
_TEXT	SEGMENT
?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ PROC	; CvCityStrategyAI::GetCity, COMDAT
; _this$ = ecx

; 552  : 	return m_pCity;

	mov	eax, DWORD PTR [ecx+12]

; 553  : }

	ret	0
?GetCity@CvCityStrategyAI@@QAEPAVCvCity@@XZ ENDP	; CvCityStrategyAI::GetCity
_TEXT	ENDS
PUBLIC	?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ; CvCityStrategyAI::GetAICityStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ
_TEXT	SEGMENT
?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ PROC ; CvCityStrategyAI::GetAICityStrategies, COMDAT
; _this$ = ecx

; 558  : 	return m_pAICityStrategies;

	mov	eax, DWORD PTR [ecx+16]

; 559  : }

	ret	0
?GetAICityStrategies@CvCityStrategyAI@@QAEPAVCvAICityStrategies@@XZ ENDP ; CvCityStrategyAI::GetAICityStrategies
_TEXT	ENDS
PUBLIC	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z PROC ; CvCityStrategyAI::IsUsingCityStrategy, COMDAT
; _this$ = ecx

; 564  : 	return m_pabUsingCityStrategy[(int) eStrategy];

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 565  : }

	ret	4
?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ENDP ; CvCityStrategyAI::IsUsingCityStrategy
_TEXT	ENDS
PUBLIC	?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::GetTurnCityStrategyAdopted
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z PROC ; CvCityStrategyAI::GetTurnCityStrategyAdopted, COMDAT
; _this$ = ecx

; 590  : 	return m_paiTurnCityStrategyAdopted[(int) eStrategy];

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 591  : }

	ret	4
?GetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEHW4AICityStrategyTypes@@@Z ENDP ; CvCityStrategyAI::GetTurnCityStrategyAdopted
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z ; CvCityStrategyAI::SetTurnCityStrategyAdopted
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z PROC ; CvCityStrategyAI::SetTurnCityStrategyAdopted, COMDAT
; _this$ = ecx

; 596  : 	if(m_paiTurnCityStrategyAdopted[(int) eStrategy] != iValue)

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _iValue$[esp-4]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1@SetTurnCit

; 597  : 	{
; 598  : 		m_paiTurnCityStrategyAdopted[(int) eStrategy] = iValue;

	mov	DWORD PTR [eax], ecx
$LN1@SetTurnCit:

; 599  : 	}
; 600  : }

	ret	8
?SetTurnCityStrategyAdopted@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@H@Z ENDP ; CvCityStrategyAI::SetTurnCityStrategyAdopted
_TEXT	ENDS
PUBLIC	?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ ; CvCityStrategyAI::GetBuildingProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ
_TEXT	SEGMENT
?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ PROC ; CvCityStrategyAI::GetBuildingProductionAI, COMDAT
; _this$ = ecx

; 605  : 	return m_pBuildingProductionAI;

	mov	eax, DWORD PTR [ecx+40]

; 606  : }

	ret	0
?GetBuildingProductionAI@CvCityStrategyAI@@QAEPAVCvBuildingProductionAI@@XZ ENDP ; CvCityStrategyAI::GetBuildingProductionAI
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ
_TEXT	SEGMENT
?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ PROC ; CvCityStrategyAI::GetUnitProductionAI, COMDAT
; _this$ = ecx

; 611  : 	return m_pUnitProductionAI;

	mov	eax, DWORD PTR [ecx+44]

; 612  : }

	ret	0
?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ENDP ; CvCityStrategyAI::GetUnitProductionAI
_TEXT	ENDS
PUBLIC	?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ ; CvCityStrategyAI::GetProjectProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ
_TEXT	SEGMENT
?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ PROC ; CvCityStrategyAI::GetProjectProductionAI, COMDAT
; _this$ = ecx

; 617  : 	return m_pProjectProductionAI;

	mov	eax, DWORD PTR [ecx+48]

; 618  : }

	ret	0
?GetProjectProductionAI@CvCityStrategyAI@@QAEPAVCvProjectProductionAI@@XZ ENDP ; CvCityStrategyAI::GetProjectProductionAI
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ ; CvCityStrategyAI::GetProcessProductionAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ
_TEXT	SEGMENT
?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ PROC ; CvCityStrategyAI::GetProcessProductionAI, COMDAT
; _this$ = ecx

; 622  : 	return m_pProcessProductionAI;

	mov	eax, DWORD PTR [ecx+52]

; 623  : }

	ret	0
?GetProcessProductionAI@CvCityStrategyAI@@QAEPAVCvProcessProductionAI@@XZ ENDP ; CvCityStrategyAI::GetProcessProductionAI
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@0000000000000000
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?citystrategyround@@YANN@Z
_TEXT	SEGMENT
$T230979 = 8						; size = 8
_x$ = 8							; size = 8
?citystrategyround@@YANN@Z PROC				; citystrategyround, COMDAT

; 646  : 	return (x >= 0) ? floor(x + .5) : ceil(x - .5);

	fldz
	sub	esp, 8
	fld	QWORD PTR _x$[esp+4]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	SHORT $LN3@citystrate
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	fstp	QWORD PTR $T230979[esp+4]
	add	esp, 8
	fld	QWORD PTR $T230979[esp-4]

; 647  : };

	ret	0
$LN3@citystrate:

; 646  : 	return (x >= 0) ? floor(x + .5) : ceil(x - .5);

	fsub	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	QWORD PTR $T230979[esp+4]
	add	esp, 8
	fld	QWORD PTR $T230979[esp-4]

; 647  : };

	ret	0
?citystrategyround@@YANN@Z ENDP				; citystrategyround
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?ResetBestYields@CvCityStrategyAI@@QAEXXZ	; CvCityStrategyAI::ResetBestYields
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?ResetBestYields@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
?ResetBestYields@CvCityStrategyAI@@QAEXXZ PROC		; CvCityStrategyAI::ResetBestYields, COMDAT
; _this$ = ecx

; 1518 : {

	push	esi

; 1519 : 	for(uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	mov	eax, OFFSET ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA ; CvCityStrategyAI::m_acBestYields
	lea	edx, DWORD PTR [ecx+3672]
	mov	esi, 6
$LL6@ResetBestY:

; 1520 : 	{
; 1521 : 		for(uint uiPlots = 0; uiPlots < NUM_CITY_PLOTS - 1; uiPlots++)
; 1522 : 		{
; 1523 : 			m_acBestYields[uiYields][uiPlots] = MAX_UNSIGNED_CHAR;

	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx

; 1524 : 		}
; 1525 : 
; 1526 : 		m_asBestYieldAverageTimes100[uiYields] = MAX_SHORT;

	mov	ecx, 32767				; 00007fffH
	mov	WORD PTR [edx], cx
	add	edx, 2
	add	eax, 37					; 00000025H
	sub	esi, 1
	jne	SHORT $LL6@ResetBestY
	pop	esi

; 1527 : 	}
; 1528 : }

	ret	0
?ResetBestYields@CvCityStrategyAI@@QAEXXZ ENDP		; CvCityStrategyAI::ResetBestYields
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z
_TEXT	SEGMENT
_ucA$ = 8						; size = 1
??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z PROC ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator(), COMDAT
; _ucB$ = eax

; 1544 : 			return ucA > ucB;

	cmp	al, BYTE PTR _ucA$[esp-4]
	sbb	eax, eax
	neg	eax

; 1545 : 		}

	ret	4
??RReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@QAE_NEE@Z ENDP ; `CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort::operator()
_TEXT	ENDS
PUBLIC	?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z ; CvCityStrategyAI::GetBestYieldAverageTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetBestYieldAverageTimes100, COMDAT
; _this$ = ecx

; 1711 : 	return m_asBestYieldAverageTimes100[eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	ax, WORD PTR [ecx+eax*2+3672]

; 1712 : }

	ret	4
?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetBestYieldAverageTimes100
_TEXT	ENDS
PUBLIC	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldDeltaTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetYieldDeltaTimes100, COMDAT
; _this$ = ecx

; 1720 : 	return m_asYieldDeltaTimes100[eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	ax, WORD PTR [ecx+eax*2+3684]

; 1721 : }

	ret	4
?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetYieldDeltaTimes100
_TEXT	ENDS
PUBLIC	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetFocusYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ
_TEXT	SEGMENT
?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ PROC ; CvCityStrategyAI::GetFocusYield, COMDAT
; _this$ = ecx

; 1725 : 	return m_eFocusYield;

	mov	eax, DWORD PTR [ecx+3696]

; 1726 : }

	ret	0
?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ENDP ; CvCityStrategyAI::GetFocusYield
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked, COMDAT

; 2208 : 	// If this City isn't adjacent to a body of water big enough to be "Ocean" then we consider it landlocked
; 2209 : 	if(!pCity->isCoastal())

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	-1
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	sete	al

; 2210 : 	{
; 2211 : 		return true;
; 2212 : 	}
; 2213 : 
; 2214 : 	return false;
; 2215 : }

	ret	0
?IsTestCityStrategy_Landlocked@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_Landlocked
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement, COMDAT

; 2624 : {

	push	esi

; 2625 : 	AICityStrategyTypes eStrategyNeedNavalTileImprovement = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT");

	push	0
	push	OFFSET $SG227202
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 2626 : 
; 2627 : #ifdef AUI_WARNING_FIXES
; 2628 : 	if (eStrategyNeedNavalTileImprovement != NO_AICITYSTRATEGY)
; 2629 : #else
; 2630 : 	if(eStrategyNeedNavalTileImprovement != NO_ECONOMICAISTRATEGY)

	cmp	esi, -1
	je	SHORT $LN1@IsTestCity

; 2631 : #endif
; 2632 : 	{
; 2633 : 		if(!pCity->GetCityStrategyAI()->IsUsingCityStrategy(eStrategyNeedNavalTileImprovement))

	mov	ecx, DWORD PTR _pCity$[esp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	eax, DWORD PTR [eax+28]
	cmp	BYTE PTR [esi+eax], 0
	jne	SHORT $LN1@IsTestCity

; 2634 : 		{
; 2635 : 			return true;

	mov	al, 1
	pop	esi

; 2640 : }

	ret	0
$LN1@IsTestCity:

; 2636 : 		}
; 2637 : 	}
; 2638 : 
; 2639 : 	return false;

	xor	al, al
	pop	esi

; 2640 : }

	ret	0
?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility
EXTRN	?getDomainFreeExperience@CvCity@@QBEHW4DomainTypes@@@Z:PROC ; CvCity::getDomainFreeExperience
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility, COMDAT

; 2656 : 	if(pCity->getDomainFreeExperience(DOMAIN_LAND) > 0)

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	2
	call	?getDomainFreeExperience@CvCity@@QBEHW4DomainTypes@@@Z ; CvCity::getDomainFreeExperience
	test	eax, eax
	setg	al

; 2657 : 	{
; 2658 : 		return true;
; 2659 : 	}
; 2660 : 
; 2661 : 	return false;
; 2662 : }

	ret	0
?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ:PROC ; CvCity::GetJONSCulturePerTurnFromBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding, COMDAT

; 2738 : {

	push	esi

; 2739 : 	if(pCity->GetJONSCulturePerTurnFromBuildings() <= 0)

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetJONSCulturePerTurnFromBuildings
	test	eax, eax
	jg	SHORT $LN2@IsTestCity@2
$LN5@IsTestCity@2:

; 2740 : 	{
; 2741 : 		return true;

	mov	al, 1
	pop	esi

; 2750 : }

	ret	0
$LN2@IsTestCity@2:

; 2742 : 	}
; 2743 : 
; 2744 : 	if(pCity->isCapital() && pCity->GetJONSCulturePerTurnFromBuildings() <= 1)

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN1@IsTestCity@2
	mov	ecx, esi
	call	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetJONSCulturePerTurnFromBuildings
	cmp	eax, 1

; 2745 : 	{
; 2746 : 		return true;

	jle	SHORT $LN5@IsTestCity@2
$LN1@IsTestCity@2:

; 2747 : 	}
; 2748 : 
; 2749 : 	return false;

	xor	al, al
	pop	esi

; 2750 : }

	ret	0
?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency, COMDAT

; 2754 : {

	push	esi

; 2755 : 	if(pCity->getPopulation() >= 5 && pCity->GetJONSCulturePerTurnFromBuildings() <= 0)

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 5
	jl	SHORT $LN1@IsTestCity@3
	mov	ecx, esi
	call	?GetJONSCulturePerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetJONSCulturePerTurnFromBuildings
	test	eax, eax
	jg	SHORT $LN1@IsTestCity@3

; 2756 : 	{
; 2757 : 		return true;

	mov	al, 1
	pop	esi

; 2761 : }

	ret	0
$LN1@IsTestCity@3:

; 2758 : 	}
; 2759 : 
; 2760 : 	return false;

	xor	al, al
	pop	esi

; 2761 : }

	ret	0
?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding
EXTRN	?GetYieldPerPopTimes100@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::GetYieldPerPopTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding, COMDAT

; 2765 : {

	push	esi

; 2766 : 	if(pCity->getPopulation() >= 4 && pCity->GetYieldPerPopTimes100(YIELD_SCIENCE) == 0)

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jl	SHORT $LN1@IsTestCity@4
	push	3
	mov	ecx, esi
	call	?GetYieldPerPopTimes100@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::GetYieldPerPopTimes100
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@4

; 2767 : 	{
; 2768 : 		return true;

	mov	al, 1
	pop	esi

; 2772 : }

	ret	0
$LN1@IsTestCity@4:

; 2769 : 	}
; 2770 : 
; 2771 : 	return false;

	xor	al, al
	pop	esi

; 2772 : }

	ret	0
?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding
EXTRN	?getYieldRateModifier@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getYieldRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding, COMDAT

; 2776 : {

	push	esi

; 2777 : 	if(pCity->getPopulation() >= 4 && pCity->getYieldRateModifier(YIELD_GOLD) == 0)

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jl	SHORT $LN1@IsTestCity@5
	push	2
	mov	ecx, esi
	call	?getYieldRateModifier@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getYieldRateModifier
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@5

; 2778 : 	{
; 2779 : 		return true;

	mov	al, 1
	pop	esi

; 2783 : }

	ret	0
$LN1@IsTestCity@5:

; 2780 : 	}
; 2781 : 
; 2782 : 	return false;

	xor	al, al
	pop	esi

; 2783 : }

	ret	0
?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding
EXTRN	?GetBaseYieldRateFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::GetBaseYieldRateFromBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding, COMDAT

; 2787 : {

	push	esi

; 2788 : 	if(pCity->getPopulation() >= 4 && pCity->GetBaseYieldRateFromBuildings(YIELD_PRODUCTION) == 0 && pCity->getYieldRateModifier(YIELD_PRODUCTION) == 0)

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jl	SHORT $LN1@IsTestCity@6
	push	1
	mov	ecx, esi
	call	?GetBaseYieldRateFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::GetBaseYieldRateFromBuildings
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@6
	push	1
	mov	ecx, esi
	call	?getYieldRateModifier@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getYieldRateModifier
	test	eax, eax
	jne	SHORT $LN1@IsTestCity@6

; 2789 : 	{
; 2790 : 		return true;

	mov	al, 1
	pop	esi

; 2794 : }

	ret	0
$LN1@IsTestCity@6:

; 2791 : 	}
; 2792 : 
; 2793 : 	return false;

	xor	al, al
	pop	esi

; 2794 : }

	ret	0
?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade
EXTRN	?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ:PROC ; CvCityCitizens::IsAnyPlotBlockaded
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade, COMDAT

; 2827 : 	if(pCity->GetCityCitizens()->IsAnyPlotBlockaded()/* && !pCity->IsHasBuildingThatAllowsRangeStrike()*/)

	mov	ecx, DWORD PTR _pCity$[esp-4]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ ; CvCityCitizens::IsAnyPlotBlockaded
	test	al, al
	setne	al

; 2828 : 	{
; 2829 : 		return true;
; 2830 : 	}
; 2831 : 
; 2832 : 	return false;
; 2833 : }

	ret	0
?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet, COMDAT

; 2838 : 	if(pCity->IsPuppet())

	mov	ecx, DWORD PTR _pCity$[esp-4]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	setne	al

; 2839 : 	{
; 2840 : 		return true;
; 2841 : 	}
; 2842 : 
; 2843 : 	return false;
; 2844 : }

	ret	0
?IsTestCityStrategy_IsPuppet@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital, COMDAT

; 2860 : 	if(pCity->IsOriginalCapital())

	mov	ecx, DWORD PTR _pCity$[esp-4]
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	test	al, al
	setne	al

; 2861 : 	{
; 2862 : 		return true;
; 2863 : 	}
; 2864 : 
; 2865 : 	return false;
; 2866 : }

	ret	0
?IsTestCityStrategy_OriginalCapital@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity, COMDAT

; 3033 : 	if(pCity->plot()->isCoastalLand())

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	-1
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	setne	al

; 3034 : 	{
; 3035 : 		return true;
; 3036 : 	}
; 3037 : 
; 3038 : 	return false;
; 3039 : }

	ret	0
?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding
EXTRN	?GetBaseTourism@CvCityCulture@@QAEHXZ:PROC	; CvCityCulture::GetBaseTourism
EXTRN	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ:PROC ; CvCityCulture::GetCultureFromImprovements
EXTRN	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ:PROC ; CvCityCulture::GetCultureFromNaturalWonders
EXTRN	?GetCultureFromWonders@CvCityCulture@@QBEHXZ:PROC ; CvCityCulture::GetCultureFromWonders
EXTRN	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ:PROC ; CvCity::GetCityCulture
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding, COMDAT

; 3305 : {

	push	esi

; 3306 : 	int iTourismValue = 0;
; 3307 : #ifdef AUI_WARNING_FIXES
; 3308 : 	const CvCityCulture* pCityCulture = pCity->GetCityCulture();
; 3309 : 	iTourismValue += pCityCulture->GetCultureFromWonders();
; 3310 : 	iTourismValue += pCityCulture->GetCultureFromNaturalWonders();
; 3311 : 	iTourismValue += pCityCulture->GetCultureFromImprovements();
; 3312 : 	iTourismValue += pCityCulture->GetBaseTourism();
; 3313 : #else
; 3314 : 	iTourismValue += pCity->GetCityCulture()->GetCultureFromWonders();

	mov	esi, DWORD PTR _pCity$[esp]
	push	edi
	mov	ecx, esi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetCultureFromWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromWonders

; 3315 : 	iTourismValue += pCity->GetCityCulture()->GetCultureFromNaturalWonders();

	mov	ecx, esi
	mov	edi, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromNaturalWonders

; 3316 : 	iTourismValue += pCity->GetCityCulture()->GetCultureFromImprovements();

	mov	ecx, esi
	add	edi, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromImprovements

; 3317 : 	iTourismValue += pCity->GetCityCulture()->GetBaseTourism();

	mov	ecx, esi
	add	edi, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetBaseTourism@CvCityCulture@@QAEHXZ	; CvCityCulture::GetBaseTourism
	add	eax, edi

; 3318 : #endif
; 3319 : 
; 3320 : 	if (iTourismValue > 10)

	cmp	eax, 10					; 0000000aH
	pop	edi
	setg	al
	pop	esi

; 3321 : 	{
; 3322 : 		return true;
; 3323 : 	}
; 3324 : 
; 3325 : 	return false;
; 3326 : }

	ret	0
?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z		; Firaxis::Array<int,22>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z PROC		; Firaxis::Array<int,22>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z ENDP		; Firaxis::Array<int,22>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@XZ ; std::allocator<CvAICityStrategyEntry *>::allocator<CvAICityStrategyEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@XZ PROC ; std::allocator<CvAICityStrategyEntry *>::allocator<CvAICityStrategyEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvAICityStrategyEntry *>::allocator<CvAICityStrategyEntry *>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@ABU01@@Z ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@XZ ; std::allocator<CvCitySpecializationXMLEntry *>::allocator<CvCitySpecializationXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@XZ PROC ; std::allocator<CvCitySpecializationXMLEntry *>::allocator<CvCitySpecializationXMLEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::allocator<CvCitySpecializationXMLEntry *>
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvCitySpecializationXMLEntry *>::allocator<CvCitySpecializationXMLEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvCitySpecializationXMLEntry *>::allocator<CvCitySpecializationXMLEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::allocator<CvCitySpecializationXMLEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@I@Z ; std::allocator<CvCitySpecializationXMLEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@I@Z PROC ; std::allocator<CvCitySpecializationXMLEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@I@Z ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEABQAVCvAICityStrategyEntry@@XZ ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEABQAVCvAICityStrategyEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEABQAVCvAICityStrategyEntry@@XZ PROC ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEABQAVCvAICityStrategyEntry@@XZ ENDP ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231154 = -80						; size = 28
$T231153 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231154[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231153[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231154[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231153[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231153[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231153[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231153[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231154[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231153[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvAICityStrategyEntry *>::allocator<CvAICityStrategyEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvAICityStrategyEntry *>::allocator<CvAICityStrategyEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvAICityStrategyEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvAICityStrategyEntry *>::allocator<CvAICityStrategyEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEXPAPAVCvAICityStrategyEntry@@I@Z ; std::allocator<CvAICityStrategyEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEXPAPAVCvAICityStrategyEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEXPAPAVCvAICityStrategyEntry@@I@Z PROC ; std::allocator<CvAICityStrategyEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEXPAPAVCvAICityStrategyEntry@@I@Z ENDP ; std::allocator<CvAICityStrategyEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\lekmod files\lekmod dll versions\v29\le'
	DB	'kmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 225				; 000000e1H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	eax, edi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 225			; 000000e1H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231201 = -80						; size = 28
$T231200 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231201[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231200[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231201[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231200[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231200[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231200[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231200[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231201[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231200[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z PROC ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z ENDP ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis, COMDAT
; _this$ = ecx

; 701  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
_TEXT	ENDS
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr, COMDAT
; _this$ = ecx

; 702  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z PROC ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z ENDP ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvAICityStrategyEntry@@@std@@QBEIXZ ; std::allocator<CvAICityStrategyEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvAICityStrategyEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvAICityStrategyEntry@@@std@@QBEIXZ PROC ; std::allocator<CvAICityStrategyEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvAICityStrategyEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvAICityStrategyEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QBEIXZ ; std::allocator<CvCitySpecializationXMLEntry *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QBEIXZ PROC ; std::allocator<CvCitySpecializationXMLEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z ; std::_Vector_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z PROC ; std::_Vector_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@PAPAVCvCitySpecializationXMLEntry@@@Z ENDP ; std::_Vector_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvAICityStrategyEntry@@@@YAXAAPAVCvAICityStrategyEntry@@@Z ; SAFE_DELETE<CvAICityStrategyEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvAICityStrategyEntry@@@@YAXAAPAVCvAICityStrategyEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvAICityStrategyEntry@@@@YAXAAPAVCvAICityStrategyEntry@@@Z PROC ; SAFE_DELETE<CvAICityStrategyEntry>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvAICityStrategyEntry@@@@YAXAAPAVCvAICityStrategyEntry@@@Z ENDP ; SAFE_DELETE<CvAICityStrategyEntry>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ; std::_Allocate<CvAICityStrategyEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T231287 = -12						; size = 12
$T231291 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvAICityStrategyEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231291[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231287[esp+16]
	mov	DWORD PTR $T231291[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231287[esp+16]
	push	ecx
	mov	DWORD PTR $T231287[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvAICityStrategyEntry *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvCitySpecializationXMLEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T231297 = -12						; size = 12
$T231301 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvCitySpecializationXMLEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231301[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231297[esp+16]
	mov	DWORD PTR $T231301[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231297[esp+16]
	push	ecx
	mov	DWORD PTR $T231297[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCitySpecializationXMLEntry *>
_TEXT	ENDS
PUBLIC	??_GCvBuildingProductionAI@@QAEPAXI@Z		; CvBuildingProductionAI::`scalar deleting destructor'
EXTRN	??1CvBuildingProductionAI@@QAE@XZ:PROC		; CvBuildingProductionAI::~CvBuildingProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvBuildingProductionAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBuildingProductionAI@@QAEPAXI@Z PROC		; CvBuildingProductionAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBuildingProductionAI@@QAE@XZ	; CvBuildingProductionAI::~CvBuildingProductionAI
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBuildingProductionAI@@QAEPAXI@Z ENDP		; CvBuildingProductionAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvUnitProductionAI@@QAEPAXI@Z		; CvUnitProductionAI::`scalar deleting destructor'
EXTRN	??1CvUnitProductionAI@@QAE@XZ:PROC		; CvUnitProductionAI::~CvUnitProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvUnitProductionAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvUnitProductionAI@@QAEPAXI@Z PROC			; CvUnitProductionAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvUnitProductionAI@@QAE@XZ		; CvUnitProductionAI::~CvUnitProductionAI
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvUnitProductionAI@@QAEPAXI@Z ENDP			; CvUnitProductionAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvProjectProductionAI@@QAEPAXI@Z		; CvProjectProductionAI::`scalar deleting destructor'
EXTRN	??1CvProjectProductionAI@@QAE@XZ:PROC		; CvProjectProductionAI::~CvProjectProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvProjectProductionAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvProjectProductionAI@@QAEPAXI@Z PROC		; CvProjectProductionAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvProjectProductionAI@@QAE@XZ	; CvProjectProductionAI::~CvProjectProductionAI
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvProjectProductionAI@@QAEPAXI@Z ENDP		; CvProjectProductionAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvProcessProductionAI@@QAEPAXI@Z		; CvProcessProductionAI::`scalar deleting destructor'
EXTRN	??1CvProcessProductionAI@@QAE@XZ:PROC		; CvProcessProductionAI::~CvProcessProductionAI
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvProcessProductionAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvProcessProductionAI@@QAEPAXI@Z PROC		; CvProcessProductionAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvProcessProductionAI@@QAE@XZ	; CvProcessProductionAI::~CvProcessProductionAI
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvProcessProductionAI@@QAEPAXI@Z ENDP		; CvProcessProductionAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAE@std@@YAPAHPAE@Z		; std::_Dist_type<unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAE@std@@YAPAHPAE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAE@std@@YAPAHPAE@Z PROC			; std::_Dist_type<unsigned char *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAE@std@@YAPAHPAE@Z ENDP			; std::_Dist_type<unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAE@std@@YAPAEPAE@Z		; std::_Val_type<unsigned char *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAE@std@@YAPAEPAE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAE@std@@YAPAEPAE@Z PROC			; std::_Val_type<unsigned char *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAE@std@@YAPAEPAE@Z ENDP			; std::_Val_type<unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCitySpecializationXMLEntry@@0@Z ; std::_Iter_random<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCitySpecializationXMLEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCitySpecializationXMLEntry@@0@Z PROC ; std::_Iter_random<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCitySpecializationXMLEntry@@0@Z ENDP ; std::_Iter_random<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCitySpecializationXMLEntry@@0@Z ; std::_Ptr_cat<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCitySpecializationXMLEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCitySpecializationXMLEntry@@0@Z PROC ; std::_Ptr_cat<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCitySpecializationXMLEntry@@0@Z ENDP ; std::_Ptr_cat<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAICityStrategyEntry@@0@Z ; std::_Iter_random<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAICityStrategyEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAICityStrategyEntry@@0@Z PROC ; std::_Iter_random<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAICityStrategyEntry@@0@Z ENDP ; std::_Iter_random<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAICityStrategyEntry@@0@Z ; std::_Ptr_cat<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAICityStrategyEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAICityStrategyEntry@@0@Z PROC ; std::_Ptr_cat<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvAICityStrategyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAICityStrategyEntry@@0@Z ENDP ; std::_Ptr_cat<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvAICityStrategyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvAICityStrategyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvAICityStrategyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvAICityStrategyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvAICityStrategyEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@E@std@@QAE@H@Z		; std::_Temp_iterator<unsigned char>::_Temp_iterator<unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@E@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@E@std@@QAE@H@Z PROC			; std::_Temp_iterator<unsigned char>::_Temp_iterator<unsigned char>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@E@std@@QAE@H@Z ENDP			; std::_Temp_iterator<unsigned char>::_Temp_iterator<unsigned char>
_TEXT	ENDS
PUBLIC	??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z PROC ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>, COMDAT

; 153  : 	return input;

	mov	eax, DWORD PTR _input$[esp-4]

; 154  : }

	ret	0
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ENDP ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@AAPAPAVCvCitySpecializationXMLEntry@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@AAPAPAVCvCitySpecializationXMLEntry@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@AAPAPAVCvCitySpecializationXMLEntry@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@AAPAPAVCvCitySpecializationXMLEntry@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@E@std@@YAXPAE@Z			; std::_Destroy<unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@E@std@@YAXPAE@Z PROC			; std::_Destroy<unsigned char>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@E@std@@YAXPAE@Z ENDP			; std::_Destroy<unsigned char>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@E@std@@YAXPAE@Z	; std::return_temporary_buffer<unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@E@std@@YAXPAE@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@E@std@@YAXPAE@Z PROC		; std::return_temporary_buffer<unsigned char>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@E@std@@YAXPAE@Z ENDP		; std::return_temporary_buffer<unsigned char>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBE_NABU01@@Z ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEABQAVCvCitySpecializationXMLEntry@@XZ ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEABQAVCvCitySpecializationXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEABQAVCvCitySpecializationXMLEntry@@XZ PROC ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEABQAVCvCitySpecializationXMLEntry@@XZ ENDP ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::pair<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>::pair<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::pair<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>::pair<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>::pair<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
_bound_func$ = 16					; size = 4
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z PROC ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>, COMDAT

; 306  : 			GenericMemFuncType &bound_func) {
; 307  : #if defined __DMC__  
; 308  : 		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
; 309  : 		// even though the standard says you can. The 32-bit compiler lets you
; 310  : 		// static_cast through an int, but the DOS compiler doesn't.
; 311  : 		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
; 312  : #else 
; 313  :         bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

	mov	eax, DWORD PTR _bound_func$[esp-4]
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax], ecx

; 314  : #endif
; 315  :         return reinterpret_cast<GenericClass *>(pthis);

	mov	eax, DWORD PTR _pthis$[esp-4]

; 316  : 	}

	ret	0
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ENDP ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ; std::_Iter_cat<unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z PROC ; std::_Iter_cat<unsigned char *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ENDP ; std::_Iter_cat<unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<unsigned char *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<unsigned char *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAEH@std@@YAXPAE0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<unsigned char *,int>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; std::_Dist_type<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Construct@PAVCvCitySpecializationXMLEntry@@PAV1@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@ABQAV1@@Z ; std::_Construct<CvCitySpecializationXMLEntry *,CvCitySpecializationXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@PAVCvCitySpecializationXMLEntry@@PAV1@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@ABQAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAVCvCitySpecializationXMLEntry@@PAV1@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@ABQAV1@@Z PROC ; std::_Construct<CvCitySpecializationXMLEntry *,CvCitySpecializationXMLEntry *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAVCvCitySpecializationXMLEntry@@PAV1@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@ABQAV1@@Z ENDP ; std::_Construct<CvCitySpecializationXMLEntry *,CvCitySpecializationXMLEntry *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAVCvCitySpecializationXMLEntry@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@@Z ; std::_Destroy<CvCitySpecializationXMLEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAVCvCitySpecializationXMLEntry@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVCvCitySpecializationXMLEntry@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@@Z PROC ; std::_Destroy<CvCitySpecializationXMLEntry *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAVCvCitySpecializationXMLEntry@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@@Z ENDP ; std::_Destroy<CvCitySpecializationXMLEntry *>
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@E@std@@QAEAAV12@XZ	; std::_Temp_iterator<unsigned char>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@E@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@E@std@@QAEAAV12@XZ PROC		; std::_Temp_iterator<unsigned char>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@E@std@@QAEAAV12@XZ ENDP		; std::_Temp_iterator<unsigned char>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@E@std@@QBEPAEXZ	; std::_Temp_iterator<unsigned char>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@E@std@@QBEPAEXZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@E@std@@QBEPAEXZ PROC		; std::_Temp_iterator<unsigned char>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@E@std@@QBEPAEXZ ENDP		; std::_Temp_iterator<unsigned char>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@E@std@@QBEPAEXZ		; std::_Temp_iterator<unsigned char>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@E@std@@QBEPAEXZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@E@std@@QBEPAEXZ PROC		; std::_Temp_iterator<unsigned char>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@E@std@@QBEPAEXZ ENDP		; std::_Temp_iterator<unsigned char>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAEH@std@@QAE@ABQAEABH@Z		; std::pair<unsigned char *,int>::pair<unsigned char *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAEH@std@@QAE@ABQAEABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAEH@std@@QAE@ABQAEABH@Z PROC			; std::pair<unsigned char *,int>::pair<unsigned char *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAEH@std@@QAE@ABQAEABH@Z ENDP			; std::pair<unsigned char *,int>::pair<unsigned char *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@E@std@@QAEAAV01@ABV01@@Z	; std::_Temp_iterator<unsigned char>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@E@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@E@std@@QAEAAV01@ABV01@@Z PROC	; std::_Temp_iterator<unsigned char>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@E@std@@QAEAAV01@ABV01@@Z ENDP	; std::_Temp_iterator<unsigned char>::operator=
_TEXT	ENDS
PUBLIC	??$_Advance@PAEH@std@@YAXAAPAEHUrandom_access_iterator_tag@0@@Z ; std::_Advance<unsigned char *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@PAEH@std@@YAXAAPAEHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAEH@std@@YAXAAPAEHUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<unsigned char *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	ecx, DWORD PTR __Off$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAEH@std@@YAXAAPAEHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<unsigned char *,int>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::swap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::swap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@E@std@@YAXAAE0@Z			; std::swap<unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@E@std@@YAXAAE0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@E@std@@YAXAAE0@Z PROC				; std::swap<unsigned char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@E@std@@YAXAAE0@Z ENDP				; std::swap<unsigned char>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAEABV?$_Temp_iterator@E@0@@Z ; std::_Iter_random<unsigned char *,std::_Temp_iterator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAEABV?$_Temp_iterator@E@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAEABV?$_Temp_iterator@E@0@@Z PROC ; std::_Iter_random<unsigned char *,std::_Temp_iterator<unsigned char> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAEABV?$_Temp_iterator@E@0@@Z ENDP ; std::_Iter_random<unsigned char *,std::_Temp_iterator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAEV?$_Temp_iterator@E@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAEAAV?$_Temp_iterator@E@0@@Z ; std::_Ptr_cat<unsigned char *,std::_Temp_iterator<unsigned char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAEV?$_Temp_iterator@E@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAEAAV?$_Temp_iterator@E@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAEV?$_Temp_iterator@E@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAEAAV?$_Temp_iterator@E@0@@Z PROC ; std::_Ptr_cat<unsigned char *,std::_Temp_iterator<unsigned char> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAEV?$_Temp_iterator@E@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAEAAV?$_Temp_iterator@E@0@@Z ENDP ; std::_Ptr_cat<unsigned char *,std::_Temp_iterator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAEPAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE00@Z ; std::_Iter_random<unsigned char *,unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAEPAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAEPAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE00@Z PROC ; std::_Iter_random<unsigned char *,unsigned char *,unsigned char *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAEPAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE00@Z ENDP ; std::_Iter_random<unsigned char *,unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+12]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	push	ebp
$LL3@Push_heap:
	mov	edx, eax
	shl	edx, 4
	add	edx, esi
	cmp	DWORD PTR [edx+12], ebx
	jle	SHORT $LN10@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	ebp, DWORD PTR [edx]
	shl	ecx, 4
	add	ecx, esi
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN10@Push_heap:
	pop	ebp
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	mov	edx, DWORD PTR __Val$[esp+12]
	shl	ecx, 4
	add	ecx, esi
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val$[esp+16]
	pop	edi
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	pop	esi
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@E@std@@QAEAAV01@XZ		; std::_Temp_iterator<unsigned char>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@E@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@E@std@@QAEAAV01@XZ PROC		; std::_Temp_iterator<unsigned char>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@E@std@@QAEAAV01@XZ ENDP		; std::_Temp_iterator<unsigned char>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@E@std@@QAEAAV01@XZ		; std::_Temp_iterator<unsigned char>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@E@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@E@std@@QAEAAV01@XZ PROC		; std::_Temp_iterator<unsigned char>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@E@std@@QAEAAV01@XZ ENDP		; std::_Temp_iterator<unsigned char>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ; std::_Iter_random<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z PROC ; std::_Iter_random<unsigned char *,unsigned char *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ENDP ; std::_Iter_random<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ; std::_Ptr_cat<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z PROC ; std::_Ptr_cat<unsigned char *,unsigned char *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ENDP ; std::_Ptr_cat<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	sub	eax, ecx
	sub	esi, eax

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	eax
	push	ecx
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edx, DWORD PTR __Dest$[esp-4]
	sub	eax, ecx
	push	esi
	lea	esi, DWORD PTR [eax+edx]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@3:

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@EE@std@@YAXPAEABE@Z		; std::_Construct<unsigned char,unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@EE@std@@YAXPAEABE@Z PROC			; std::_Construct<unsigned char,unsigned char>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@EE@std@@YAXPAEABE@Z ENDP			; std::_Construct<unsigned char,unsigned char>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAEPAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAE0ABV?$_Temp_iterator@E@0@@Z ; std::_Iter_random<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAEPAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAE0ABV?$_Temp_iterator@E@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAEPAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAE0ABV?$_Temp_iterator@E@0@@Z PROC ; std::_Iter_random<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAEPAEV?$_Temp_iterator@E@std@@@std@@YA?AUforward_iterator_tag@0@ABQAE0ABV?$_Temp_iterator@E@0@@Z ENDP ; std::_Iter_random<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z		; std::_Rotate<unsigned char *,int,unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
tv262 = -12						; size = 4
tv260 = -8						; size = 4
tv256 = -4						; size = 4
__First$ = 8						; size = 4
tv161 = 12						; size = 4
__Holeval$230145 = 12					; size = 1
__Mid$ = 12						; size = 4
__Next$230144 = 16					; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z PROC		; std::_Rotate<unsigned char *,int,unsigned char>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 16					; 00000010H
	push	ebx

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ebx, DWORD PTR __First$[esp+16]
	push	ebp

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ebp, DWORD PTR __Last$[esp+20]
	push	esi
	mov	esi, DWORD PTR __Mid$[esp+24]
	sub	esi, ebx
	mov	eax, ebp
	sub	eax, ebx
	push	edi
	mov	DWORD PTR tv161[esp+28], eax
	mov	edi, eax
	mov	DWORD PTR __Count$[esp+32], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	ecx, esi
	test	esi, esi
	je	SHORT $LN7@Rotate
	npad	7
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, edi
	cdq
	idiv	ecx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	edi, ecx
	mov	ecx, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
	mov	eax, DWORD PTR tv161[esp+28]
	mov	DWORD PTR __Count$[esp+32], edi
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	edi, eax
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	edi, edi
	jle	$LN3@Rotate
	lea	eax, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv262[esp+32], eax
	npad	4
$LL5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	cl, BYTE PTR [eax]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	edx, DWORD PTR [eax+esi]
	mov	DWORD PTR __Next$230144[esp+28], eax
	mov	BYTE PTR __Holeval$230145[esp+28], cl
	cmp	edx, ebp
	jne	SHORT $LN11@Rotate
	mov	edx, ebx
$LN11@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	edx, eax
	je	SHORT $LN1@Rotate
	mov	ecx, edx
	mov	edi, esi
	neg	ebx
	mov	eax, ebp
	neg	ecx
	neg	edi
	neg	eax
	mov	DWORD PTR tv256[esp+32], ebx
	mov	DWORD PTR tv260[esp+32], eax
	npad	3
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	ebx, DWORD PTR __Next$230144[esp+28]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ebx], al

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ebx, DWORD PTR __First$[esp+28]
	lea	eax, DWORD PTR [ecx+ebp]
	cmp	esi, eax
	mov	DWORD PTR __Next$230144[esp+28], edx
	jge	SHORT $LN13@Rotate
	add	edx, esi
	add	ecx, edi
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	sub	ecx, DWORD PTR tv260[esp+32]
	mov	eax, esi
	sub	eax, ebp
	add	eax, ebx
	add	edx, eax
	mov	eax, DWORD PTR tv256[esp+32]
	add	ecx, edi
	add	ecx, eax
$LN14@Rotate:
	mov	eax, DWORD PTR tv262[esp+32]
	cmp	edx, eax
	jne	SHORT $LL2@Rotate

; 1698 : 			while (_Next1 != _Hole)

	mov	edi, DWORD PTR __Count$[esp+32]
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	cl, BYTE PTR __Holeval$230145[esp+28]
	mov	edx, DWORD PTR __Next$230144[esp+28]
	dec	edi
	dec	eax
	mov	BYTE PTR [edx], cl
	mov	DWORD PTR __Count$[esp+32], edi
	mov	DWORD PTR tv262[esp+32], eax
	test	edi, edi
	jg	$LL5@Rotate
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z ENDP		; std::_Rotate<unsigned char *,int,unsigned char>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?IsEmpty@CvString@@QBE_NXZ			; CvString::IsEmpty
EXTRN	__imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmpty@CvString@@QBE_NXZ
_TEXT	SEGMENT
?IsEmpty@CvString@@QBE_NXZ PROC				; CvString::IsEmpty, COMDAT
; _this$ = ecx

; 41   : 	bool IsEmpty() const { return (empty() || this[0] == '\0');}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	jne	SHORT $LN3@IsEmpty
	mov	ecx, esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	je	SHORT $LN3@IsEmpty
	xor	eax, eax
	pop	esi
	ret	0
$LN3@IsEmpty:
	mov	eax, 1
	pop	esi
	ret	0
?IsEmpty@CvString@@QBE_NXZ ENDP				; CvString::IsEmpty
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	?getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD, COMDAT
; _this$ = ecx

; 869  : 		return m_iAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD;

	mov	eax, DWORD PTR [ecx+1808]

; 870  : 	}

	ret	0
?getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD
_TEXT	ENDS
PUBLIC	?getFLAVOR_MIN_VALUE@CvGlobals@@QAEHXZ		; CvGlobals::getFLAVOR_MIN_VALUE
; Function compile flags: /Ogtpy
;	COMDAT ?getFLAVOR_MIN_VALUE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFLAVOR_MIN_VALUE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getFLAVOR_MIN_VALUE, COMDAT
; _this$ = ecx

; 941  : 		return m_iFLAVOR_MIN_VALUE;

	mov	eax, DWORD PTR [ecx+1876]

; 942  : 	}

	ret	0
?getFLAVOR_MIN_VALUE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getFLAVOR_MIN_VALUE
_TEXT	ENDS
PUBLIC	?getFLAVOR_MAX_VALUE@CvGlobals@@QAEHXZ		; CvGlobals::getFLAVOR_MAX_VALUE
; Function compile flags: /Ogtpy
;	COMDAT ?getFLAVOR_MAX_VALUE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFLAVOR_MAX_VALUE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getFLAVOR_MAX_VALUE, COMDAT
; _this$ = ecx

; 945  : 		return m_iFLAVOR_MAX_VALUE;

	mov	eax, DWORD PTR [ecx+1880]

; 946  : 	}

	ret	0
?getFLAVOR_MAX_VALUE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getFLAVOR_MAX_VALUE
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD, COMDAT
; _this$ = ecx

; 1385 : 		return m_iAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD;

	mov	eax, DWORD PTR [ecx+2320]

; 1386 : 	}

	ret	0
?getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD, COMDAT
; _this$ = ecx

; 1389 : 		return m_iAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD;

	mov	eax, DWORD PTR [ecx+2324]

; 1390 : 	}

	ret	0
?getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD, COMDAT
; _this$ = ecx

; 1393 : 		return m_iAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD;

	mov	eax, DWORD PTR [ecx+2328]

; 1394 : 	}

	ret	0
?getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN, COMDAT
; _this$ = ecx

; 1405 : 		return m_iAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN;

	mov	eax, DWORD PTR [ecx+2340]

; 1406 : 	}

	ret	0
?getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE, COMDAT
; _this$ = ecx

; 1409 : 		return m_iAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE;

	mov	eax, DWORD PTR [ecx+2344]

; 1410 : 	}

	ret	0
?getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD@CvGlobals@@QAEMXZ ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD, COMDAT
; _this$ = ecx

; 1413 : 		return m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD;

	fld	DWORD PTR [ecx+2348]

; 1414 : 	}

	ret	0
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION@CvGlobals@@QAEMXZ ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION, COMDAT
; _this$ = ecx

; 1417 : 		return m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION;

	fld	DWORD PTR [ecx+2352]

; 1418 : 	}

	ret	0
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD@CvGlobals@@QAEMXZ ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD, COMDAT
; _this$ = ecx

; 1421 : 		return m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD;

	fld	DWORD PTR [ecx+2356]

; 1422 : 	}

	ret	0
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE@CvGlobals@@QAEMXZ ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE, COMDAT
; _this$ = ecx

; 1425 : 		return m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE;

	fld	DWORD PTR [ecx+2360]

; 1426 : 	}

	ret	0
?getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT, COMDAT
; _this$ = ecx

; 1429 : 		return m_iAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT;

	mov	eax, DWORD PTR [ecx+2364]

; 1430 : 	}

	ret	0
?getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER, COMDAT
; _this$ = ecx

; 1433 : 		return m_iAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+2368]

; 1434 : 	}

	ret	0
?getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT, COMDAT
; _this$ = ecx

; 1437 : 		return m_iAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT;

	mov	eax, DWORD PTR [ecx+2372]

; 1438 : 	}

	ret	0
?getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_PRODUCTION_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_PRODUCTION_PERCENT, COMDAT
; _this$ = ecx

; 6421 : 		return m_iMINOR_CIV_PRODUCTION_PERCENT;

	mov	eax, DWORD PTR [ecx+7292]

; 6422 : 	}

	ret	0
?getMINOR_CIV_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_PRODUCTION_PERCENT
_TEXT	ENDS
PUBLIC	?getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ ; CvGlobals::getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT, COMDAT
; _this$ = ecx

; 7012 : 		return m_fAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT;

	fld	DWORD PTR [ecx+8000]

; 7013 : 	}

	ret	0
?getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT
_TEXT	ENDS
PUBLIC	?getAI_PRODUCTION_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ ; CvGlobals::getAI_PRODUCTION_WEIGHT_BASE_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_PRODUCTION_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_PRODUCTION_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_PRODUCTION_WEIGHT_BASE_MOD, COMDAT
; _this$ = ecx

; 7016 : 		return m_fAI_PRODUCTION_WEIGHT_BASE_MOD;

	fld	DWORD PTR [ecx+8004]

; 7017 : 	}

	ret	0
?getAI_PRODUCTION_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_PRODUCTION_WEIGHT_BASE_MOD
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetGreatScientistRateModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGreatScientistRateModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetGreatScientistRateModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGreatScientistRateModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGreatScientistRateModifier, COMDAT
; _this$ = ecx

; 427  : 		return m_iGreatScientistRateModifier;

	mov	eax, DWORD PTR [ecx+48]

; 428  : 	};

	ret	0
?GetGreatScientistRateModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGreatScientistRateModifier
_TEXT	ENDS
PUBLIC	?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ		; CvPlayerTraits::IsNoAnnexing
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ PROC		; CvPlayerTraits::IsNoAnnexing, COMDAT
; _this$ = ecx

; 804  : 		return m_bNoAnnexing;

	mov	al, BYTE PTR [ecx+343]

; 805  : 	};

	ret	0
?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ ENDP		; CvPlayerTraits::IsNoAnnexing
_TEXT	ENDS
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = ecx

; 579  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
_TEXT	ENDS
PUBLIC	?clear@DelegateMemento@fastdelegate@@QAEXXZ	; fastdelegate::DelegateMemento::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@DelegateMemento@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@DelegateMemento@fastdelegate@@QAEXXZ PROC	; fastdelegate::DelegateMemento::clear, COMDAT
; _this$ = ecx

; 580  : 	void clear() {	m_pthis=0; m_pFunction=0;	}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@DelegateMemento@fastdelegate@@QAEXXZ ENDP	; fastdelegate::DelegateMemento::clear
_TEXT	ENDS
PUBLIC	?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ; fastdelegate::DelegateMemento::SetMementoFrom
; Function compile flags: /Ogtpy
;	COMDAT ?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z
_TEXT	SEGMENT
_right$ = 8						; size = 4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z PROC ; fastdelegate::DelegateMemento::SetMementoFrom, COMDAT
; _this$ = ecx

; 637  : 		m_pFunction = right.m_pFunction;

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 638  : 		m_pthis = right.m_pthis;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 639  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 640  : 		m_pStaticFunction = right.m_pStaticFunction;
; 641  : #endif
; 642  : 	}

	ret	4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ENDP ; fastdelegate::DelegateMemento::SetMementoFrom
_TEXT	ENDS
PUBLIC	??0CvCityBuildable@@QAE@XZ			; CvCityBuildable::CvCityBuildable
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.h
;	COMDAT ??0CvCityBuildable@@QAE@XZ
_TEXT	SEGMENT
??0CvCityBuildable@@QAE@XZ PROC				; CvCityBuildable::CvCityBuildable, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 120  : 	}

	ret	0
??0CvCityBuildable@@QAE@XZ ENDP				; CvCityBuildable::CvCityBuildable
_TEXT	ENDS
PUBLIC	?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ ; CvCityStrategyAI::GetSpecialization
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ
_TEXT	SEGMENT
?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ PROC ; CvCityStrategyAI::GetSpecialization, COMDAT
; _this$ = ecx

; 162  : 		return m_eSpecialization;

	mov	eax, DWORD PTR [ecx+20]

; 163  : 	};

	ret	0
?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ ENDP ; CvCityStrategyAI::GetSpecialization
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvAICityStrategyEntry@@6B@			; CvAICityStrategyEntry::`vftable'
PUBLIC	??1CvAICityStrategyEntry@@UAE@XZ		; CvAICityStrategyEntry::~CvAICityStrategyEntry
PUBLIC	??_R4CvAICityStrategyEntry@@6B@			; CvAICityStrategyEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAICityStrategyEntry@@@8		; CvAICityStrategyEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvAICityStrategyEntry@@8			; CvAICityStrategyEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAICityStrategyEntry@@8			; CvAICityStrategyEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAICityStrategyEntry@@8		; CvAICityStrategyEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvAICityStrategyEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvAICityStrategyEntry@@UAEPAXI@Z:PROC	; CvAICityStrategyEntry::`vector deleting destructor'
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvAICityStrategyEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAICityStrategyEntry@@8 DD FLAT:??_R0?AVCvAICityStrategyEntry@@@8 ; CvAICityStrategyEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAICityStrategyEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAICityStrategyEntry@@8
rdata$r	SEGMENT
??_R2CvAICityStrategyEntry@@8 DD FLAT:??_R1A@?0A@EA@CvAICityStrategyEntry@@8 ; CvAICityStrategyEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAICityStrategyEntry@@8
rdata$r	SEGMENT
??_R3CvAICityStrategyEntry@@8 DD 00H			; CvAICityStrategyEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAICityStrategyEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAICityStrategyEntry@@@8
_DATA	SEGMENT
??_R0?AVCvAICityStrategyEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvAICityStrategyEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAICityStrategyEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAICityStrategyEntry@@6B@
rdata$r	SEGMENT
??_R4CvAICityStrategyEntry@@6B@ DD 00H			; CvAICityStrategyEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAICityStrategyEntry@@@8
	DD	FLAT:??_R3CvAICityStrategyEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvAICityStrategyEntry@@6B@
CONST	SEGMENT
??_7CvAICityStrategyEntry@@6B@ DD FLAT:??_R4CvAICityStrategyEntry@@6B@ ; CvAICityStrategyEntry::`vftable'
	DD	FLAT:?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvAICityStrategyEntry@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvAICityStrategyEntry@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAICityStrategyEntry@@UAE@XZ$0
__ehfuncinfo$??1CvAICityStrategyEntry@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvAICityStrategyEntry@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvAICityStrategyEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAICityStrategyEntry@@UAE@XZ PROC			; CvAICityStrategyEntry::~CvAICityStrategyEntry, COMDAT
; _this$ = ecx

; 44   : {

	push	-1
	push	__ehhandler$??1CvAICityStrategyEntry@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvAICityStrategyEntry@@6B@

; 45   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+260]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+260], 0

; 46   : 	SAFE_DELETE_ARRAY(m_piPersonalityFlavorThresholdMod);

	mov	eax, DWORD PTR [esi+268]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8

; 47   : }

	lea	ecx, DWORD PTR [esi+296]
	mov	DWORD PTR [esi+268], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAICityStrategyEntry@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvAICityStrategyEntry@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvAICityStrategyEntry@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAICityStrategyEntry@@UAE@XZ ENDP			; CvAICityStrategyEntry::~CvAICityStrategyEntry
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvAICityStrategyEntry::CacheResults, COMDAT
; _this$ = ecx

; 51   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN9@CacheResul
	pop	edi
	pop	esi

; 104  : }

	ret	8
$LN9@CacheResul:
	push	ebx

; 52   : 		return false;
; 53   : 
; 54   : 	//Basic Properties
; 55   : 	m_bNoMinorCivs				= kResults.GetBool("NoMinorCivs");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	ebp
	push	OFFSET $SG225490
	mov	ecx, edi
	call	ebx

; 56   : 	m_bPermanent				= kResults.GetBool("Permanent");

	push	OFFSET $SG225491
	mov	ecx, edi
	mov	BYTE PTR [esi+288], al
	call	ebx

; 57   : 	m_iCheckTriggerTurnCount	= kResults.GetInt("CheckTriggerTurnCount");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG225492
	mov	ecx, edi
	mov	BYTE PTR [esi+289], al
	call	ebx

; 58   : 	m_iMinimumNumTurnsExecuted	= kResults.GetInt("MinimumNumTurnsExecuted");

	push	OFFSET $SG225493
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 59   : 	m_iWeightThreshold			= kResults.GetInt("WeightThreshold");

	push	OFFSET $SG225494
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 60   : 
; 61   : 	const char* strAdvisor = kResults.GetText("Advisor");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG225496
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebp

; 62   : 	m_eAdvisor = NO_ADVISOR_TYPE;

	mov	DWORD PTR [esi+292], -1

; 63   : 	if(strAdvisor)

	test	eax, eax
	je	$LN35@CacheResul

; 64   : 	{
; 65   : 		if(strcmp(strAdvisor, "MILITARY") == 0)

	mov	edx, OFFSET $SG225499
	mov	ecx, eax
	npad	3
$LL18@CacheResul:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN19@CacheResul
	test	bl, bl
	je	SHORT $LN20@CacheResul
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN19@CacheResul
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL18@CacheResul
$LN20@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN21@CacheResul
$LN19@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN21@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN7@CacheResul

; 66   : 		{
; 67   : 			m_eAdvisor = ADVISOR_MILITARY;

	mov	DWORD PTR [esi+292], ecx
	jmp	$LN35@CacheResul
$LN7@CacheResul:

; 68   : 		}
; 69   : 		else if(strcmp(strAdvisor, "ECONOMIC") == 0)

	mov	edx, OFFSET $SG225502
	mov	ecx, eax
	npad	5
$LL22@CacheResul:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN23@CacheResul
	test	bl, bl
	je	SHORT $LN24@CacheResul
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN23@CacheResul
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL22@CacheResul
$LN24@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN25@CacheResul
$LN23@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN25@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN5@CacheResul

; 70   : 		{
; 71   : 			m_eAdvisor = ADVISOR_ECONOMIC;

	mov	DWORD PTR [esi+292], 1
	jmp	SHORT $LN35@CacheResul
$LN5@CacheResul:

; 72   : 		}
; 73   : 		else if(strcmp(strAdvisor, "FOREIGN") == 0)

	mov	edx, OFFSET $SG225505
	mov	ecx, eax
	npad	4
$LL26@CacheResul:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN27@CacheResul
	test	bl, bl
	je	SHORT $LN28@CacheResul
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN27@CacheResul
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL26@CacheResul
$LN28@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN29@CacheResul
$LN27@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN29@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN3@CacheResul

; 74   : 		{
; 75   : 			m_eAdvisor = ADVISOR_FOREIGN;

	mov	DWORD PTR [esi+292], 2
	jmp	SHORT $LN35@CacheResul
$LN3@CacheResul:

; 76   : 		}
; 77   : 		else if(strcmp(strAdvisor, "SCIENCE") == 0)

	mov	ecx, OFFSET $SG225508
	npad	6
$LL30@CacheResul:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN31@CacheResul
	test	dl, dl
	je	SHORT $LN32@CacheResul
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN31@CacheResul
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL30@CacheResul
$LN32@CacheResul:
	xor	eax, eax
	jmp	SHORT $LN33@CacheResul
$LN31@CacheResul:
	sbb	eax, eax
	sbb	eax, -1
$LN33@CacheResul:
	test	eax, eax
	jne	SHORT $LN35@CacheResul

; 78   : 		{
; 79   : 			m_eAdvisor = ADVISOR_SCIENCE;

	mov	DWORD PTR [esi+292], 3
$LN35@CacheResul:

; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	m_strAdvisorCounselText = kResults.GetText("AdvisorCounsel");

	push	OFFSET $SG225509
	mov	ecx, edi
	call	ebp
	lea	ecx, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN13@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN12@CacheResul
$LN13@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN12@CacheResul:

; 84   : 	m_iAdvisorCounselImportance = kResults.GetInt("AdvisorCounselImportance");

	push	OFFSET $SG225510
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z

; 85   : 
; 86   : 	//References
; 87   : 	const char* szTextVal;
; 88   : 	szTextVal = kResults.GetText("TechObsolete");

	push	OFFSET $SG225512
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebp

; 89   : 	m_iTechObsolete = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 90   : 
; 91   : 	szTextVal = kResults.GetText("TechPrereq");

	push	OFFSET $SG225513
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebp

; 92   : 	m_iTechPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 93   : 
; 94   : 	//Arrays
; 95   : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 96   : 	kUtility.SetFlavors(m_piFlavorValue, "AICityStrategy_Flavors",
; 97   : 	                    "AICityStrategyType", szType);

	mov	ebx, DWORD PTR _kUtility$[esp+12]
	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG225515
	push	OFFSET $SG225516
	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 98   : 
; 99   : 	kUtility.SetFlavors(m_piPersonalityFlavorThresholdMod,
; 100  : 	                    "AICityStrategy_PersonalityFlavorThresholdMods",
; 101  : 	                    "AICityStrategyType", szType);

	push	0
	push	edi
	push	OFFSET $SG225517
	push	OFFSET $SG225518
	add	esi, 268				; 0000010cH
	push	esi
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors
	pop	ebp
	pop	ebx
	pop	edi

; 102  : 
; 103  : 	return true;

	mov	al, 1
	pop	esi

; 104  : }

	ret	8
?CacheResults@CvAICityStrategyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvAICityStrategyEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ; CvAICityStrategies::GetNumAICityStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ
_TEXT	SEGMENT
?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ PROC	; CvAICityStrategies::GetNumAICityStrategies, COMDAT
; _this$ = ecx

; 205  : 	return m_paAICityStrategyEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 206  : }

	ret	0
?GetNumAICityStrategies@CvAICityStrategies@@QAEHXZ ENDP	; CvAICityStrategies::GetNumAICityStrategies
_TEXT	ENDS
PUBLIC	?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ; CvAICityStrategies::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z PROC ; CvAICityStrategies::GetEntry, COMDAT
; _this$ = ecx

; 222  : 	return m_paAICityStrategyEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 223  : }

	ret	4
?GetEntry@CvAICityStrategies@@QAEPAVCvAICityStrategyEntry@@H@Z ENDP ; CvAICityStrategies::GetEntry
_TEXT	ENDS
PUBLIC	?Reset@CvCityStrategyAI@@QAEXXZ			; CvCityStrategyAI::Reset
EXTRN	?Reset@CvProcessProductionAI@@QAEXXZ:PROC	; CvProcessProductionAI::Reset
EXTRN	?Reset@CvProjectProductionAI@@QAEXXZ:PROC	; CvProjectProductionAI::Reset
EXTRN	?Reset@CvUnitProductionAI@@QAEXXZ:PROC		; CvUnitProductionAI::Reset
EXTRN	?Reset@CvBuildingProductionAI@@QAEXXZ:PROC	; CvBuildingProductionAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvCityStrategyAI@@QAEXXZ PROC			; CvCityStrategyAI::Reset, COMDAT
; _this$ = ecx

; 316  : {

	push	esi
	mov	esi, ecx

; 317  : 	int iI;
; 318  : 
; 319  : 	for(iI = 0; iI < m_pAICityStrategies->GetNumAICityStrategies(); iI++)

	mov	ecx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [ecx+8]
	sub	edi, DWORD PTR [ecx+4]
	xor	eax, eax
	or	edx, -1
	test	edi, -4					; fffffffcH
	jle	SHORT $LN1@Reset
	npad	6
$LL3@Reset:

; 320  : 	{
; 321  : 		m_pabUsingCityStrategy[iI] = false;

	mov	ecx, DWORD PTR [esi+28]
	mov	BYTE PTR [eax+ecx], 0

; 322  : 		m_paiTurnCityStrategyAdopted[iI] = -1;

	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [ecx+8]
	sub	edi, DWORD PTR [ecx+4]
	inc	eax
	sar	edi, 2
	cmp	eax, edi
	jl	SHORT $LL3@Reset
$LN1@Reset:

; 323  : 	}
; 324  : 
; 325  : 	m_eSpecialization = NO_CITY_SPECIALIZATION;
; 326  : 	m_eDefaultSpecialization = NO_CITY_SPECIALIZATION;
; 327  : 	m_eFocusYield = (YieldTypes)NO_YIELD;
; 328  : 
; 329  : 	// Reset sub AI objects
; 330  : 	m_pBuildingProductionAI->Reset();

	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+20], edx
	mov	DWORD PTR [esi+24], edx
	mov	DWORD PTR [esi+3696], edx
	call	?Reset@CvBuildingProductionAI@@QAEXXZ	; CvBuildingProductionAI::Reset

; 331  : 	m_pUnitProductionAI->Reset();

	mov	ecx, DWORD PTR [esi+44]
	call	?Reset@CvUnitProductionAI@@QAEXXZ	; CvUnitProductionAI::Reset

; 332  : 	m_pProjectProductionAI->Reset();

	mov	ecx, DWORD PTR [esi+48]
	call	?Reset@CvProjectProductionAI@@QAEXXZ	; CvProjectProductionAI::Reset

; 333  : 	m_pProcessProductionAI->Reset();

	mov	ecx, DWORD PTR [esi+52]
	pop	edi
	pop	esi
	jmp	?Reset@CvProcessProductionAI@@QAEXXZ	; CvProcessProductionAI::Reset
?Reset@CvCityStrategyAI@@QAEXXZ ENDP			; CvCityStrategyAI::Reset
_TEXT	ENDS
PUBLIC	?FlavorUpdate@CvCityStrategyAI@@UAEXXZ		; CvCityStrategyAI::FlavorUpdate
EXTRN	?AddFlavorWeights@CvProcessProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvProcessProductionAI::AddFlavorWeights
EXTRN	?AddFlavorWeights@CvProjectProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvProjectProductionAI::AddFlavorWeights
EXTRN	?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvUnitProductionAI::AddFlavorWeights
EXTRN	?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z:PROC ; CvBuildingProductionAI::AddFlavorWeights
EXTRN	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z:PROC ; CvFlavorRecipient::GetLatestFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?FlavorUpdate@CvCityStrategyAI@@UAEXXZ
_TEXT	SEGMENT
?FlavorUpdate@CvCityStrategyAI@@UAEXXZ PROC		; CvCityStrategyAI::FlavorUpdate, COMDAT
; _this$ = ecx

; 391  : {

	push	esi
	push	edi
	mov	edi, ecx

; 392  : 	// Reset our sub AI objects
; 393  : 	m_pBuildingProductionAI->Reset();

	mov	ecx, DWORD PTR [edi+40]
	call	?Reset@CvBuildingProductionAI@@QAEXXZ	; CvBuildingProductionAI::Reset

; 394  : 	m_pUnitProductionAI->Reset();

	mov	ecx, DWORD PTR [edi+44]
	call	?Reset@CvUnitProductionAI@@QAEXXZ	; CvUnitProductionAI::Reset

; 395  : 	m_pProjectProductionAI->Reset();

	mov	ecx, DWORD PTR [edi+48]
	call	?Reset@CvProjectProductionAI@@QAEXXZ	; CvProjectProductionAI::Reset

; 396  : 	m_pProcessProductionAI->Reset();

	mov	ecx, DWORD PTR [edi+52]
	call	?Reset@CvProcessProductionAI@@QAEXXZ	; CvProcessProductionAI::Reset

; 397  : 
; 398  : 	// Broadcast to our sub AI objects
; 399  : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN1@FlavorUpda
	push	ebx
	npad	1
$LL3@FlavorUpda:

; 400  : 	{
; 401  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_PUPPETS_NULLIFY_BARRACKS
; 402  : 		if (GetCity()->IsPuppet() && (FlavorTypes)iFlavor == (FlavorTypes)GC.getInfoTypeForString("FLAVOR_MILITARY_TRAINING"))
; 403  : 			continue;
; 404  : #endif
; 405  : 		int iFlavorValue = GetLatestFlavorValue((FlavorTypes)iFlavor);// m_piLatestFlavorValues[iFlavor];

	push	0
	push	esi
	mov	ecx, edi
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue

; 406  : 
; 407  : #ifdef AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF
; 408  : 		m_pUnitProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);
; 409  : #endif
; 410  : 		m_pBuildingProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	ecx, DWORD PTR [edi+40]
	mov	ebx, eax
	push	ebx
	push	esi
	call	?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvBuildingProductionAI::AddFlavorWeights

; 411  : #ifndef AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF
; 412  : 		m_pUnitProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	ecx, DWORD PTR [edi+44]
	push	ebx
	push	esi
	call	?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvUnitProductionAI::AddFlavorWeights

; 413  : #endif
; 414  : 		m_pProjectProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	ecx, DWORD PTR [edi+48]
	push	ebx
	push	esi
	call	?AddFlavorWeights@CvProjectProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvProjectProductionAI::AddFlavorWeights

; 415  : 		m_pProcessProductionAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue);

	mov	ecx, DWORD PTR [edi+52]
	push	ebx
	push	esi
	call	?AddFlavorWeights@CvProcessProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvProcessProductionAI::AddFlavorWeights
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL3@FlavorUpda
	pop	ebx
$LN1@FlavorUpda:
	pop	edi
	pop	esi

; 416  : 	}
; 417  : }

	ret	0
?FlavorUpdate@CvCityStrategyAI@@UAEXXZ ENDP		; CvCityStrategyAI::FlavorUpdate
_TEXT	ENDS
PUBLIC	?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SpecializationFlavorChange
EXTRN	?ChangeFlavors@CvFlavorRecipient@@QAEXPAH_N@Z:PROC ; CvFlavorRecipient::ChangeFlavors
EXTRN	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z:PROC ; CvCitySpecializationXMLEntry::GetFlavorValue
EXTRN	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z:PROC ; CvGlobals::getCitySpecializationInfo
; Function compile flags: /Ogtpy
;	COMDAT ?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_bTurnOn$ = 8						; size = 1
_eSpecialization$ = 12					; size = 4
?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::SpecializationFlavorChange, COMDAT
; _this$ = ecx

; 515  : 	if(eSpecialization != NO_CITY_SPECIALIZATION)

	mov	eax, DWORD PTR _eSpecialization$[esp-4]
	push	edi
	mov	edi, ecx
	cmp	eax, -1
	je	$LN9@Specializa
	push	ebx

; 516  : 	{
; 517  : 		CvCitySpecializationXMLEntry* pSpecialization = GC.getCitySpecializationInfo(eSpecialization);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	ebx, eax

; 518  : 		if(pSpecialization)

	test	ebx, ebx
	je	SHORT $LN21@Specializa

; 519  : 		{
; 520  : 			int iFlavorLoop;
; 521  : 
; 522  : 			// Clear out Temp array
; 523  : 			for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN6@Specializa
	npad	2
$LL8@Specializa:

; 524  : 			{
; 525  : 				m_aiTempFlavors[iFlavorLoop] = 0;

	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [ecx+eax*4], 0
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL8@Specializa
$LN6@Specializa:
	push	esi

; 526  : 			}
; 527  : 
; 528  : 			for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN3@Specializa
	push	ebp
	npad	3
$LL5@Specializa:

; 529  : 			{
; 530  : 				if(bTurnOn)

	cmp	BYTE PTR _bTurnOn$[esp+12], 0

; 531  : 				{
; 532  : 					m_aiTempFlavors[iFlavorLoop] += pSpecialization->GetFlavorValue(iFlavorLoop);

	push	esi
	mov	ecx, ebx
	je	SHORT $LN2@Specializa
	mov	edx, DWORD PTR [edi+36]
	lea	ebp, DWORD PTR [edx+esi*4]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	add	DWORD PTR [ebp], eax

; 533  : 				}
; 534  : 				else

	jmp	SHORT $LN4@Specializa
$LN2@Specializa:

; 526  : 			}
; 527  : 
; 528  : 			for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	eax, DWORD PTR [edi+36]
	lea	ebp, DWORD PTR [eax+esi*4]

; 535  : 				{
; 536  : 					m_aiTempFlavors[iFlavorLoop] -= pSpecialization->GetFlavorValue(iFlavorLoop);

	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	sub	DWORD PTR [ebp], eax
$LN4@Specializa:
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL5@Specializa
	pop	ebp
$LN3@Specializa:

; 537  : 				}
; 538  : 			}
; 539  : 
; 540  : 			ChangeFlavors(m_aiTempFlavors, true);

	mov	ecx, DWORD PTR [edi+36]
	push	1
	push	ecx
	mov	ecx, edi
	call	?ChangeFlavors@CvFlavorRecipient@@QAEXPAH_N@Z ; CvFlavorRecipient::ChangeFlavors

; 541  : 
; 542  : 			LogFlavors();

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+12]
	push	-1
	mov	ecx, edi
	call	eax
	pop	esi
$LN21@Specializa:
	pop	ebx
$LN9@Specializa:
	pop	edi

; 543  : 		}
; 544  : 	}
; 545  : }

	ret	8
?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::SpecializationFlavorChange
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
_TEXT	SEGMENT
$T232187 = -128						; size = 4
$T232185 = -124						; size = 28
$T232184 = -96						; size = 28
$T232183 = -68						; size = 28
$T232182 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
_cityName$ = 16						; size = 4
?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z PROC ; CvCityStrategyAI::GetLogFileName, COMDAT
; _this$ = ecx

; 627  : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 116				; 00000074H
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T232187[esp+136], edi

; 628  : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+132]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+144], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 638  : 	}
; 639  : 
; 640  : 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+144], edi
	mov	DWORD PTR $T232187[esp+136], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	$LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+132]
	push	eax
	lea	ecx, DWORD PTR $T232182[esp+140]
	push	OFFSET $SG226043
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226042
	push	eax
	lea	edx, DWORD PTR $T232183[esp+156]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+168], 1
	call	edi
	mov	ecx, DWORD PTR _cityName$[esp+156]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T232184[esp+168]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+180], 2
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG226041
	push	eax
	lea	eax, DWORD PTR $T232185[esp+180]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+192], 3
	call	edi
	add	esp, 48					; 00000030H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+144], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232185[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232184[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232183[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232182[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN21@GetLogFile
$LN2@GetLogFile:

; 629  : 
; 630  : 	// Open the log file
; 631  : 	if(GC.getPlayerAndCityAILogSplit())
; 632  : 	{
; 633  : 		strLogName = "CityStrategyAILog_" + playerName + "_" + cityName + ".csv";
; 634  : 	}
; 635  : 	else
; 636  : 	{
; 637  : 		strLogName = "CityStrategyAILog.csv";

	push	OFFSET $SG226045
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN21@GetLogFile:

; 641  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$0:
	mov	eax, DWORD PTR $T232187[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T232187[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$1:
	lea	ecx, DWORD PTR $T232182[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$2:
	lea	ecx, DWORD PTR $T232183[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$3:
	lea	ecx, DWORD PTR $T232184[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z$4:
	lea	ecx, DWORD PTR $T232185[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ENDP ; CvCityStrategyAI::GetLogFileName
PUBLIC	?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetDeficientYieldValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z
_TEXT	SEGMENT
_fDesiredYield$ = -8					; size = 8
_eYieldType$ = 8					; size = 4
?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetDeficientYieldValue, COMDAT
; _this$ = ecx

; 731  : {

	sub	esp, 8

; 732  : 	double fDesiredYield = -999.0;
; 733  : 
; 734  : 	switch(eYieldType)

	mov	eax, DWORD PTR _eYieldType$[esp+4]
	mov	DWORD PTR _fDesiredYield$[esp+8], 0
	mov	DWORD PTR _fDesiredYield$[esp+12], -1064355840 ; c08f3800H
	cmp	eax, 5
	ja	SHORT $LN1@GetDeficie
	jmp	DWORD PTR $LN21@GetDeficie[eax*4]
$LN7@GetDeficie:

; 735  : 	{
; 736  : 	case YIELD_FOOD:
; 737  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2348

; 744  : 		break;
; 745  : 	case YIELD_GOLD:
; 746  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD();

	fstp	QWORD PTR _fDesiredYield$[esp+8]

; 756  : 	}
; 757  : 
; 758  : 	return fDesiredYield;

	fld	QWORD PTR _fDesiredYield$[esp+8]

; 759  : }

	add	esp, 8
	ret	4
$LN6@GetDeficie:

; 738  : 		break;
; 739  : 	case YIELD_PRODUCTION:
; 740  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2352

; 744  : 		break;
; 745  : 	case YIELD_GOLD:
; 746  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD();

	fstp	QWORD PTR _fDesiredYield$[esp+8]

; 756  : 	}
; 757  : 
; 758  : 	return fDesiredYield;

	fld	QWORD PTR _fDesiredYield$[esp+8]

; 759  : }

	add	esp, 8
	ret	4
$LN5@GetDeficie:

; 741  : 		break;
; 742  : 	case YIELD_SCIENCE:
; 743  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2360

; 744  : 		break;
; 745  : 	case YIELD_GOLD:
; 746  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD();

	fstp	QWORD PTR _fDesiredYield$[esp+8]

; 756  : 	}
; 757  : 
; 758  : 	return fDesiredYield;

	fld	QWORD PTR _fDesiredYield$[esp+8]

; 759  : }

	add	esp, 8
	ret	4
$LN4@GetDeficie:

; 744  : 		break;
; 745  : 	case YIELD_GOLD:
; 746  : 		fDesiredYield = GC.getAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2356
	fstp	QWORD PTR _fDesiredYield$[esp+8]
$LN3@GetDeficie:

; 756  : 	}
; 757  : 
; 758  : 	return fDesiredYield;

	fld	QWORD PTR _fDesiredYield$[esp+8]

; 759  : }

	add	esp, 8
	ret	4
$LN1@GetDeficie:

; 747  : 		break;
; 748  : 		// OK if deficient in the newer (bonus) yields
; 749  : 	case YIELD_CULTURE:
; 750  : 		break;
; 751  : 	case YIELD_FAITH:
; 752  : 		break;
; 753  : 	default:
; 754  : 		FAssertMsg(false, "Yield type is not handled. What?");
; 755  : 		return false;

	fldz

; 759  : }

	add	esp, 8
	ret	4
	npad	2
$LN21@GetDeficie:
	DD	$LN7@GetDeficie
	DD	$LN6@GetDeficie
	DD	$LN4@GetDeficie
	DD	$LN5@GetDeficie
	DD	$LN3@GetDeficie
	DD	$LN3@GetDeficie
?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetDeficientYieldValue
_TEXT	ENDS
PUBLIC	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ; CityStrategyAIHelpers::ReweightByTurnsLeft
EXTRN	_pow:PROC
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z
_TEXT	SEGMENT
_fWeightDivisor$ = -8					; size = 8
_fTotalCostFactor$ = -8					; size = 8
_fAdditionalTurnCostFactor$ = -8			; size = 8
_iOriginalWeight$ = 8					; size = 4
_iTurnsLeft$ = 12					; size = 4
?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z PROC ; CityStrategyAIHelpers::ReweightByTurnsLeft, COMDAT

; 2100 : {

	sub	esp, 8

; 2101 : 	// 10 turns will add 0.02; 80 turns will add 0.16
; 2102 : 	double fAdditionalTurnCostFactor = GC.getAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT() * iTurnsLeft;	// 0.004

	fild	DWORD PTR _iTurnsLeft$[esp+4]

; 2103 : 	double fTotalCostFactor = GC.getAI_PRODUCTION_WEIGHT_BASE_MOD() + fAdditionalTurnCostFactor;	// 0.15
; 2104 : 	double fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);

	sub	esp, 8
	mov	eax, esp
	sub	esp, 8
	fmul	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8000
	fstp	QWORD PTR _fAdditionalTurnCostFactor$[esp+24]
	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8004
	fadd	QWORD PTR _fAdditionalTurnCostFactor$[esp+24]
	fstp	QWORD PTR _fTotalCostFactor$[esp+24]
	mov	ecx, DWORD PTR _fTotalCostFactor$[esp+24]
	fild	DWORD PTR _iTurnsLeft$[esp+20]
	mov	edx, DWORD PTR _fTotalCostFactor$[esp+28]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	fstp	QWORD PTR [esp]
	call	_pow
	fstp	QWORD PTR _fWeightDivisor$[esp+24]

; 2105 : 
; 2106 : 	/* Commented out for now: useful debug code for tweaking the exact effect of this function
; 2107 : 
; 2108 : 	iTurnsLeft = 10;
; 2109 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2110 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2111 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2112 : 
; 2113 : 	iTurnsLeft = 20;
; 2114 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2115 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2116 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2117 : 
; 2118 : 	iTurnsLeft = 40;
; 2119 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2120 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2121 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2122 : 
; 2123 : 	iTurnsLeft = 80;
; 2124 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2125 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2126 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);*/
; 2127 : 
; 2128 : 	return int(double(iOriginalWeight) / fWeightDivisor);

	fild	DWORD PTR _iOriginalWeight$[esp+20]
	fdiv	QWORD PTR _fWeightDivisor$[esp+24]

; 2129 : }

	add	esp, 24					; 00000018H

; 2105 : 
; 2106 : 	/* Commented out for now: useful debug code for tweaking the exact effect of this function
; 2107 : 
; 2108 : 	iTurnsLeft = 10;
; 2109 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2110 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2111 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2112 : 
; 2113 : 	iTurnsLeft = 20;
; 2114 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2115 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2116 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2117 : 
; 2118 : 	iTurnsLeft = 40;
; 2119 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2120 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2121 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);
; 2122 : 
; 2123 : 	iTurnsLeft = 80;
; 2124 : 	fAdditionalTurnCostFactor = 0.004f * iTurnsLeft;
; 2125 : 	fTotalCostFactor = 0.15f + fAdditionalTurnCostFactor;
; 2126 : 	fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);*/
; 2127 : 
; 2128 : 	return int(double(iOriginalWeight) / fWeightDivisor);

	jmp	__ftol2_sse_excpt
?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ENDP ; CityStrategyAIHelpers::ReweightByTurnsLeft
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity, COMDAT

; 2152 : 	// City Population is too low, don't build Settlers yet
; 2153 : 	if(pCity->getPopulation() < GC.getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD())	// Just size 1

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2320
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, esi
	setl	al
	pop	esi

; 2154 : 	{
; 2155 : 		return true;
; 2156 : 	}
; 2157 : 
; 2158 : 	return false;
; 2159 : }

	ret	0
?IsTestCityStrategy_TinyCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_TinyCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity, COMDAT

; 2163 : {

	push	esi

; 2164 : 	// City Population is too low, don't build Settlers yet
; 2165 : 	if(pCity->getPopulation() >= GC.getAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD() &&   // 2 to 4
; 2166 : 	        pCity->getPopulation() < GC.getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2320
	push	edi
	mov	edi, DWORD PTR _pCity$[esp+4]
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, esi
	jl	SHORT $LN1@IsTestCity@7
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2324
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, esi
	jge	SHORT $LN1@IsTestCity@7
	pop	edi

; 2167 : 	{
; 2168 : 		return true;

	mov	al, 1
	pop	esi

; 2172 : }

	ret	0
$LN1@IsTestCity@7:
	pop	edi

; 2169 : 	}
; 2170 : 
; 2171 : 	return false;

	xor	al, al
	pop	esi

; 2172 : }

	ret	0
?IsTestCityStrategy_SmallCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_SmallCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity, COMDAT

; 2176 : {

	push	esi

; 2177 : 	// Never consider the capital to be a medium city (so with late game starts at least one city retains high flavors for SPACESHIP, etc.)
; 2178 : 	if (pCity->isCapital())

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN2@IsTestCity@8

; 2179 : 	{
; 2180 : 		return false;

	xor	al, al
	pop	esi

; 2191 : }

	ret	0
$LN2@IsTestCity@8:
	push	edi

; 2181 : 	}
; 2182 : 
; 2183 : 	// City Population is getting larger, increase science
; 2184 : 	if(pCity->getPopulation() >= GC.getAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD() &&   // 5 to 11
; 2185 : 	        pCity->getPopulation() < GC.getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD())

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2324
	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, edi
	jl	SHORT $LN1@IsTestCity@8
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2328
	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, edi
	jge	SHORT $LN1@IsTestCity@8
	pop	edi

; 2186 : 	{
; 2187 : 		return true;

	mov	al, 1
	pop	esi

; 2191 : }

	ret	0
$LN1@IsTestCity@8:
	pop	edi

; 2188 : 	}
; 2189 : 
; 2190 : 	return false;

	xor	al, al
	pop	esi

; 2191 : }

	ret	0
?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity, COMDAT

; 2196 : 	// City Population is very large, really boost science
; 2197 : 	if(pCity->getPopulation() >= GC.getAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD())	// 12+

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2328
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, esi
	setge	al
	pop	esi

; 2198 : 	{
; 2199 : 		return true;
; 2200 : 	}
; 2201 : 
; 2202 : 	return false;
; 2203 : }

	ret	0
?IsTestCityStrategy_LargeCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_LargeCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty, COMDAT

; 2849 : 	if(pCity->getPopulation() >= 5 && GC.getGame().getHandicapInfo().GetID() > 4)

	mov	ecx, DWORD PTR _pCity$[esp-4]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 5
	jl	SHORT $LN1@IsTestCity@9
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN1@IsTestCity@9

; 2850 : 	{
; 2851 : 		return true;

	mov	al, 1

; 2855 : }

	ret	0
$LN1@IsTestCity@9:

; 2852 : 	}
; 2853 : 
; 2854 : 	return false;

	xor	al, al

; 2855 : }

	ret	0
?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity, COMDAT

; 2872 : 	if(pCity->plot()->isRiver())

	mov	ecx, DWORD PTR _pCity$[esp-4]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	BYTE PTR [eax+457], 0
	setg	al

; 2873 : 	{
; 2874 : 		return true;
; 2875 : 	}
; 2876 : 
; 2877 : 	return false;
; 2878 : }

	ret	0
?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity
EXTRN	?getGreatEngineerRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatEngineerRateModifier
EXTRN	?getGreatMerchantRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatMerchantRateModifier
EXTRN	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::calculateTotalYield
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?getGreatMusicianRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatMusicianRateModifier
EXTRN	?getGreatArtistRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatArtistRateModifier
EXTRN	?getGreatWriterRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatWriterRateModifier
EXTRN	?getGreatScientistRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatScientistRateModifier
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?getGreatPeopleRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatPeopleRateModifier
EXTRN	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ:PROC	; CvCity::GetPlayer
EXTRN	?getGreatPeopleRateModifier@CvCity@@QBEHXZ:PROC	; CvCity::getGreatPeopleRateModifier
EXTRN	?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z:PROC ; CvCityCitizens::GetBuildingGreatPeopleRateChanges
EXTRN	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getGreatPeopleRateChange
EXTRN	?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z:PROC ; CvCityCitizens::GetSpecialistCount
EXTRN	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getGreatPeopleUnitClass
EXTRN	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z:PROC ; CvGlobals::getSpecialistInfo
EXTRN	?getNumSpecialistInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSpecialistInfos
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_iTotalGPPChange$ = -12					; size = 4
_iSpecialistLoop$227431 = -8				; size = 4
_iGPPChange$227441 = -4					; size = 4
_iCount$227440 = -4					; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity, COMDAT

; 3136 : {

	sub	esp, 12					; 0000000cH
	push	ebp

; 3137 : 	// if this city is producing at least 8 GP points a turn (since most GP mod buildings increase by 25% this will yield 2 extra GP points a turn)
; 3138 : 
; 3139 : 	int iTotalGPPChange = 0;

	xor	ebp, ebp

; 3140 : 
; 3141 : #ifdef AUI_WARNING_FIXES
; 3142 : 	for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 3143 : #else
; 3144 : 	for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iTotalGPPChange$[esp+16], ebp
	mov	DWORD PTR _iSpecialistLoop$227431[esp+16], ebp
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	$LN1@IsTestCity@10
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _pCity$[esp+24]
	npad	9
$LL30@IsTestCity@10:

; 3145 : #endif
; 3146 : 	{
; 3147 : 		const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
; 3148 : 		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
	mov	esi, eax

; 3149 : 		if(pkSpecialistInfo)

	test	esi, esi
	je	$LN18@IsTestCity@10

; 3150 : 		{
; 3151 : 			// Does this Specialist spawn a GP?
; 3152 : 			if (pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)

	mov	ecx, esi
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, -1
	je	$LN18@IsTestCity@10

; 3153 : 			{
; 3154 : 				int iCount = pCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);

	push	ebp
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistCount

; 3155 : 
; 3156 : 				// GPP from Specialists
; 3157 : 				int iGPPChange = pkSpecialistInfo->getGreatPeopleRateChange() * iCount * 100;

	mov	ecx, esi
	mov	DWORD PTR _iCount$227440[esp+28], eax
	call	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleRateChange
	mov	ebx, eax
	imul	ebx, DWORD PTR _iCount$227440[esp+28]

; 3158 : 
; 3159 : 				// GPP from Buildings
; 3160 : 				iGPPChange += pCity->GetCityCitizens()->GetBuildingGreatPeopleRateChanges(eSpecialist) * 100;

	push	ebp
	imul	ebx, 100				; 00000064H
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetBuildingGreatPeopleRateChanges
	imul	eax, 100				; 00000064H
	add	ebx, eax
	mov	DWORD PTR _iGPPChange$227441[esp+28], ebx

; 3161 : 
; 3162 : 				if (iGPPChange > 0)

	test	ebx, ebx
	jle	$LN18@IsTestCity@10

; 3163 : 				{
; 3164 : 					int iMod = 0;
; 3165 : 
; 3166 : 					// City mod
; 3167 : 					iMod += pCity->getGreatPeopleRateModifier();

	mov	ecx, edi
	call	?getGreatPeopleRateModifier@CvCity@@QBEHXZ ; CvCity::getGreatPeopleRateModifier

; 3168 : 
; 3169 : 					// Player mod
; 3170 : 					iMod += pCity->GetPlayer()->getGreatPeopleRateModifier();

	mov	ecx, edi
	mov	ebx, eax
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatPeopleRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatPeopleRateModifier

; 3171 : 
; 3172 : 					// Trait mod to this specific class
; 3173 : 					if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))

	push	0
	push	OFFSET $SG227446
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN13@IsTestCity@10

; 3174 : 					{
; 3175 : 						iMod += pCity->GetPlayer()->GetPlayerTraits()->GetGreatScientistRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	esi, DWORD PTR [eax+48]

; 3176 : 						iMod += pCity->GetPlayer()->getGreatScientistRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatScientistRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatScientistRateModifier
	add	eax, esi
	jmp	$LN31@IsTestCity@10
$LN13@IsTestCity@10:

; 3177 : 					}
; 3178 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))

	push	0
	push	OFFSET $SG227450
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN11@IsTestCity@10

; 3179 : 					{
; 3180 : 						iMod += pCity->GetPlayer()->getGreatWriterRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatWriterRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatWriterRateModifier
	jmp	$LN31@IsTestCity@10
$LN11@IsTestCity@10:

; 3181 : 					}					
; 3182 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))

	push	0
	push	OFFSET $SG227454
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN9@IsTestCity@10

; 3183 : 					{
; 3184 : 						iMod += pCity->GetPlayer()->getGreatArtistRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatArtistRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatArtistRateModifier
	jmp	$LN31@IsTestCity@10
$LN9@IsTestCity@10:

; 3185 : 					}					
; 3186 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))

	push	0
	push	OFFSET $SG227458
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN7@IsTestCity@10

; 3187 : 					{
; 3188 : 						iMod += pCity->GetPlayer()->getGreatMusicianRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatMusicianRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMusicianRateModifier

; 3189 : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 3190 : 						int iProductionToGreatMusiciansModifier = pCity->GetPlayer()->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER);

	push	47					; 0000002fH
	mov	ecx, edi
	add	ebx, eax
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	esi, eax

; 3191 : 						if (iProductionToGreatMusiciansModifier > 0)

	test	esi, esi
	jle	$LN26@IsTestCity@10

; 3192 : 						{
; 3193 : 							iMod += pCity->GetPlayer()->calculateTotalYield(YIELD_PRODUCTION) * iProductionToGreatMusiciansModifier / 100;

	push	1
	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 3194 : 						}
; 3195 : #endif
; 3196 : 					}

	jmp	SHORT $LN31@IsTestCity@10
$LN7@IsTestCity@10:

; 3197 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))

	push	0
	push	OFFSET $SG227464
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN4@IsTestCity@10

; 3198 : 					{
; 3199 : 						iMod += pCity->GetPlayer()->getGreatMerchantRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatMerchantRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMerchantRateModifier
	jmp	SHORT $LN31@IsTestCity@10
$LN4@IsTestCity@10:

; 3200 : 					}
; 3201 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))

	push	0
	push	OFFSET $SG227468
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN26@IsTestCity@10

; 3202 : 					{
; 3203 : 						iMod += pCity->GetPlayer()->getGreatEngineerRateModifier();

	mov	ecx, edi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?getGreatEngineerRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatEngineerRateModifier
$LN31@IsTestCity@10:
	add	ebx, eax
$LN26@IsTestCity@10:

; 3204 : 					}
; 3205 : 
; 3206 : 					iGPPChange *= (100 + iMod);

	add	ebx, 100				; 00000064H
	imul	ebx, DWORD PTR _iGPPChange$227441[esp+28]

; 3207 : 					iGPPChange /= 100;
; 3208 : 
; 3209 : 					iTotalGPPChange += iGPPChange;

	mov	ebp, DWORD PTR _iSpecialistLoop$227431[esp+28]
	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR _iTotalGPPChange$[esp+28], ecx
$LN18@IsTestCity@10:
	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSpecialistLoop$227431[esp+28], ebp
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	ebp, eax
	jl	$LL30@IsTestCity@10

; 3210 : 				}
; 3211 : 			}
; 3212 : 		}
; 3213 : 	}
; 3214 : 
; 3215 : 	if (iTotalGPPChange >= 800)

	cmp	DWORD PTR _iTotalGPPChange$[esp+28], 800 ; 00000320H
	pop	edi
	pop	esi
	pop	ebx
	jl	SHORT $LN1@IsTestCity@10

; 3216 : 	{
; 3217 : 		return true;

	mov	al, 1
	pop	ebp

; 3221 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN1@IsTestCity@10:

; 3218 : 	}
; 3219 : 
; 3220 : 	return false;

	xor	al, al
	pop	ebp

; 3221 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination
EXTRN	?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z:PROC ; CvGameTrade::GetNumTimesDestinationCity
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination, COMDAT

; 3261 : 	int iNumTimesDestination = GC.getGame().GetGameTrade()->GetNumTimesDestinationCity(pCity, true);

	mov	eax, DWORD PTR _pCity$[esp-4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesDestinationCity

; 3262 : 	if (iNumTimesDestination >= 2)

	cmp	eax, 2
	setge	al

; 3263 : 	{
; 3264 : 		return true;
; 3265 : 	}
; 3266 : 	else
; 3267 : 	{
; 3268 : 		return false;
; 3269 : 	}
; 3270 : }

	ret	0
?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin
EXTRN	?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z:PROC ; CvGameTrade::GetNumTimesOriginCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin, COMDAT

; 3274 : 	int iNumTimesOrigin = GC.getGame().GetGameTrade()->GetNumTimesOriginCity(pCity, true);

	mov	eax, DWORD PTR _pCity$[esp-4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesOriginCity

; 3275 : 	if (iNumTimesOrigin >= 2)

	cmp	eax, 2
	setge	al

; 3276 : 	{
; 3277 : 		return true;
; 3278 : 	}
; 3279 : 	else
; 3280 : 	{
; 3281 : 		return false;
; 3282 : 	}	
; 3283 : }

	ret	0
?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEABUCvCityBuildable@@I@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEABUCvCityBuildable@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEABUCvCityBuildable@@I@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEABUCvCityBuildable@@I@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::GetElement
_TEXT	ENDS
PUBLIC	?SetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXIH@Z ; CvWeightedVector<CvCityBuildable,225,1>::SetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?SetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXIH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?SetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXIH@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::SetWeight, COMDAT
; _this$ = ecx

; 83   : 		m_pItems[iIndex].m_iWeight = iWeight;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iWeight$[esp-4]
	shl	eax, 4
	mov	DWORD PTR [eax+ecx+12], edx

; 84   : 		CvAssertMsg(m_pItems[iIndex].m_iWeight >= 0, "Weight should not be negative.");
; 85   : 	}

	ret	8
?SetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXIH@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::SetWeight
_TEXT	ENDS
PUBLIC	?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [ecx+4]
	push	esi
	push	edi
	xor	ebx, ebx
	xor	esi, esi
	xor	edi, edi

; 90   : 		int rtnValue = 0;
; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	ebp, 2
	mov	DWORD PTR _rtnValue$[esp+20], ebx
	jl	SHORT $LC15@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ebp-2]
	shr	edx, 1
	add	eax, 28					; 0000001cH
	inc	edx
	lea	ebx, DWORD PTR [edx+edx]
$LL16@GetTotalWe:
	add	esi, DWORD PTR [eax-16]
	add	edi, DWORD PTR [eax]
	add	eax, 32					; 00000020H
	sub	edx, 1
	jne	SHORT $LL16@GetTotalWe
$LC15@GetTotalWe:

; 90   : 		int rtnValue = 0;
; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	ebx, ebp
	jae	SHORT $LN14@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	shl	ebx, 4
	mov	ecx, DWORD PTR [ebx+eax+12]
	mov	DWORD PTR _rtnValue$[esp+20], ecx
$LN14@GetTotalWe:
	lea	eax, DWORD PTR [edi+esi]

; 96   : 		}
; 97   : 
; 98   : 		return rtnValue;

	add	eax, DWORD PTR _rtnValue$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 99   : 	};

	pop	ecx
	ret	0
?GetTotalWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::GetTotalWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ; CvWeightedVector<CvCityBuildable,225,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEHXZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::size
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEAAPAVCvAICityStrategyEntry@@XZ ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEAAPAVCvAICityStrategyEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEAAPAVCvAICityStrategyEntry@@XZ PROC ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEAAPAVCvAICityStrategyEntry@@XZ ENDP ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z PROC ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAICityStrategyEntry@@@1@@Z ENDP ; std::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_val<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 225			; 000000e1H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z PROC ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvCitySpecializationXMLEntry@@@1@@Z ENDP ; std::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Vector_val<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z PROC ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@PAPAVCvAICityStrategyEntry@@@Z ENDP ; std::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Vector_iterator<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z PROC	; fastdelegate::FastDelegate2<int,char const *,int>::operator(), COMDAT
; _this$ = ecx

; 1080 : 	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	eax
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::operator()
_TEXT	ENDS
PUBLIC	?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ; fastdelegate::FastDelegate2<int,char const *,int>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::clear, COMDAT
; _this$ = ecx

; 1101 : 	void clear() { m_Closure.clear();}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::clear
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEPAPAVCvAICityStrategyEntry@@I@Z ; std::allocator<CvAICityStrategyEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEPAPAVCvAICityStrategyEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEPAPAVCvAICityStrategyEntry@@I@Z PROC ; std::allocator<CvAICityStrategyEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ; std::_Allocate<CvAICityStrategyEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvAICityStrategyEntry@@@std@@QAEPAPAVCvAICityStrategyEntry@@I@Z ENDP ; std::allocator<CvAICityStrategyEntry *>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEPAPAVCvCitySpecializationXMLEntry@@I@Z ; std::allocator<CvCitySpecializationXMLEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEPAPAVCvCitySpecializationXMLEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEPAPAVCvCitySpecializationXMLEntry@@I@Z PROC ; std::allocator<CvCitySpecializationXMLEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvCitySpecializationXMLEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEPAPAVCvCitySpecializationXMLEntry@@I@Z ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBuildingProductionAI@@@@YAXAAPAVCvBuildingProductionAI@@@Z ; SAFE_DELETE<CvBuildingProductionAI>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvBuildingProductionAI@@@@YAXAAPAVCvBuildingProductionAI@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBuildingProductionAI@@@@YAXAAPAVCvBuildingProductionAI@@@Z PROC ; SAFE_DELETE<CvBuildingProductionAI>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@2
	mov	ecx, esi
	call	??1CvBuildingProductionAI@@QAE@XZ	; CvBuildingProductionAI::~CvBuildingProductionAI
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBuildingProductionAI@@@@YAXAAPAVCvBuildingProductionAI@@@Z ENDP ; SAFE_DELETE<CvBuildingProductionAI>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvUnitProductionAI@@@@YAXAAPAVCvUnitProductionAI@@@Z ; SAFE_DELETE<CvUnitProductionAI>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvUnitProductionAI@@@@YAXAAPAVCvUnitProductionAI@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvUnitProductionAI@@@@YAXAAPAVCvUnitProductionAI@@@Z PROC ; SAFE_DELETE<CvUnitProductionAI>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@3
	mov	ecx, esi
	call	??1CvUnitProductionAI@@QAE@XZ		; CvUnitProductionAI::~CvUnitProductionAI
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@3:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvUnitProductionAI@@@@YAXAAPAVCvUnitProductionAI@@@Z ENDP ; SAFE_DELETE<CvUnitProductionAI>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvProjectProductionAI@@@@YAXAAPAVCvProjectProductionAI@@@Z ; SAFE_DELETE<CvProjectProductionAI>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvProjectProductionAI@@@@YAXAAPAVCvProjectProductionAI@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvProjectProductionAI@@@@YAXAAPAVCvProjectProductionAI@@@Z PROC ; SAFE_DELETE<CvProjectProductionAI>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@4
	mov	ecx, esi
	call	??1CvProjectProductionAI@@QAE@XZ	; CvProjectProductionAI::~CvProjectProductionAI
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@4:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvProjectProductionAI@@@@YAXAAPAVCvProjectProductionAI@@@Z ENDP ; SAFE_DELETE<CvProjectProductionAI>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvProcessProductionAI@@@@YAXAAPAVCvProcessProductionAI@@@Z ; SAFE_DELETE<CvProcessProductionAI>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvProcessProductionAI@@@@YAXAAPAVCvProcessProductionAI@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvProcessProductionAI@@@@YAXAAPAVCvProcessProductionAI@@@Z PROC ; SAFE_DELETE<CvProcessProductionAI>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@5
	mov	ecx, esi
	call	??1CvProcessProductionAI@@QAE@XZ	; CvProcessProductionAI::~CvProcessProductionAI
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@5:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvProcessProductionAI@@@@YAXAAPAVCvProcessProductionAI@@@Z ENDP ; SAFE_DELETE<CvProcessProductionAI>
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@2
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@2:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@2

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@2:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$228136 = -7					; size = 1
_bValid$228133 = -6					; size = 1
_tValue$228141 = -5					; size = 1
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	sub	esp, 8
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiNumEntries$[esp+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+16], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+16]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$228133[esp+24]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228136[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	al, BYTE PTR _tValue$228136[esp+24]
	mov	ecx, DWORD PTR _paArray$[esp+20]
	mov	BYTE PTR [esi+ecx], al

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$228133[esp+24], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228141[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+24]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 8
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$228148 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$228151 = -8					; size = 4
_tValue$228156 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed@2
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed@2:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$228148[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@2

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228151[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@2

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$228151[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@2
$LN4@ReadHashed@2:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$228148[esp+32], 0
	jne	SHORT $LN6@ReadHashed@2

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228156[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed@2:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed@2
	pop	esi
	pop	ebp
$LN5@ReadHashed@2:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@3:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@3

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@3:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4AICityStrategyTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4AICityStrategyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	ebx
$LN2@WriteHashe:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@2
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@2:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4AICityStrategyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@2:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@2
	pop	edi
$LN2@WriteHashe@2:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
_right$ = 12						; size = 4
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >, COMDAT
; _this$ = ecx

; 763  : #endif
; 764  : 		SetMementoFrom(right);

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 765  : 	}

	ret	8
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvAICityStrategyEntry@@PAPAV1@@stdext@@YAPAPAVCvAICityStrategyEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvAICityStrategyEntry * *,CvAICityStrategyEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@YAXPAPAVCvCitySpecializationXMLEntry@@0AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvAICityStrategyEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@YAXPAPAVCvAICityStrategyEntry@@0AAV?$allocator@PAVCvAICityStrategyEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@E@std@@QAE@XZ		; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Temp_iterator@E@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@E@std@@QAE@XZ PROC			; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@E@std@@QAE@XZ ENDP			; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
_TEXT	ENDS
PUBLIC	??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>, COMDAT
; _this$ = ecx

; 673  : 		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
; 674  : 			::Convert(pthis, function_to_bind, m_pFunction);

	mov	eax, DWORD PTR _function_to_bind$[esp-4]
	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx

; 675  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 676  : 		m_pStaticFunction = 0;
; 677  : #endif
; 678  : 	}

	ret	8
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??$_Distance@PAEH@std@@YAXPAE0AAH@Z		; std::_Distance<unsigned char *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAEH@std@@YAXPAE0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAEH@std@@YAXPAE0AAH@Z PROC		; std::_Distance<unsigned char *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAEH@std@@YAXPAE0AAH@Z ENDP		; std::_Distance<unsigned char *,int>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@ABQAV3@@Z ; std::allocator<CvCitySpecializationXMLEntry *>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@ABQAV3@@Z PROC ; std::allocator<CvCitySpecializationXMLEntry *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@ABQAV3@@Z ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@@Z ; std::allocator<CvCitySpecializationXMLEntry *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@@Z PROC ; std::allocator<CvCitySpecializationXMLEntry *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@QAEXPAPAVCvCitySpecializationXMLEntry@@@Z ENDP ; std::allocator<CvCitySpecializationXMLEntry *>::destroy
_TEXT	ENDS
PUBLIC	??$advance@PAEH@std@@YAXAAPAEH@Z		; std::advance<unsigned char *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@PAEH@std@@YAXAAPAEH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAEH@std@@YAXAAPAEH@Z PROC			; std::advance<unsigned char *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	ecx, DWORD PTR __Off$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAEH@std@@YAXAAPAEH@Z ENDP			; std::advance<unsigned char *,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::iter_swap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z ; std::get_temporary_buffer<unsigned char>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z
_TEXT	SEGMENT
$T232910 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T232914 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z PROC ; std::get_temporary_buffer<unsigned char>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	esi
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 1
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232914[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T232910[esp+20]
	mov	DWORD PTR $T232914[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232910[esp+20]
	push	ecx
	mov	DWORD PTR $T232910[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z ENDP ; std::get_temporary_buffer<unsigned char>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@E@std@@QAE@ABV01@@Z		; std::_Temp_iterator<unsigned char>::_Temp_iterator<unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@E@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@E@std@@QAE@ABV01@@Z PROC		; std::_Temp_iterator<unsigned char>::_Temp_iterator<unsigned char>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@E@std@@QAE@ABV01@@Z ENDP		; std::_Temp_iterator<unsigned char>::_Temp_iterator<unsigned char>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAEPAE@std@@YAXPAE0@Z		; std::iter_swap<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAEPAE@std@@YAXPAE0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAEPAE@std@@YAXPAE0@Z PROC			; std::iter_swap<unsigned char *,unsigned char *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@2
	mov	dl, BYTE PTR [eax]
	push	ebx
	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN3@iter_swap@2:

; 595  : 	}

	ret	0
??$iter_swap@PAEPAE@std@@YAXPAE0@Z ENDP			; std::iter_swap<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
tv173 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	cmp	ebx, DWORD PTR [ecx+12]
	push	ebp
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+12]
	mov	esi, DWORD PTR [edx+12]
	cmp	esi, DWORD PTR [eax+12]
	mov	DWORD PTR tv173[esp+12], esi
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ebp
	mov	edx, DWORD PTR tv173[esp+12]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], edx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	ebx, DWORD PTR [eax+12]
	cmp	ebx, DWORD PTR [ecx+12]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
$LN28@Med3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx
	push	ebp
	push	esi

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	esi, DWORD PTR __First$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Bottom$[esp+12]
	lea	edx, DWORD PTR [ecx+ecx+2]
	cmp	edx, edi
	mov	ebx, ecx
	jge	SHORT $LN14@Adjust_hea
	npad	6
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, edx
	shl	eax, 4
	mov	ebp, DWORD PTR [eax+esi+12]
	add	eax, esi
	cmp	ebp, DWORD PTR [eax-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	edx
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	eax, edx
	shl	eax, 4
	mov	ebp, DWORD PTR [eax+esi]
	add	eax, esi
	shl	ecx, 4
	add	ecx, esi
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, edx
	lea	edx, DWORD PTR [edx+edx+2]
	cmp	edx, edi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, edi
	shl	edx, 4
	lea	eax, DWORD PTR [edx+esi-16]
	mov	edx, DWORD PTR [eax]
	shl	ecx, 4
	add	ecx, esi
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	ecx, DWORD PTR [edi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	edx, DWORD PTR __Val$[esp+12]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Val$[esp+32]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp+36]
	push	ebx
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Val$[esp+44]
	push	ecx
	push	esi
	mov	DWORD PTR [eax+12], edx
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL8@unchecked_@4:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAEPAE@stdext@@YAPAEPAE00@Z ; stdext::unchecked_copy_backward<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAEPAE@stdext@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAEPAE@stdext@@YAPAEPAE00@Z PROC ; stdext::unchecked_copy_backward<unsigned char *,unsigned char *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	eax, ecx
	sub	esi, eax
	test	eax, eax
	jle	SHORT $LN10@unchecked_@5
	push	eax
	push	ecx
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@5:
	mov	eax, esi
	pop	esi

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAEPAE@stdext@@YAPAEPAE00@Z ENDP ; stdext::unchecked_copy_backward<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First1$[esp]
	push	ebp
	mov	ebp, DWORD PTR __First2$[esp+4]
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+12]
	cmp	ebx, esi
	je	SHORT $LN33@Merge_back
	npad	4
$LL8@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	cmp	ebp, edi
	je	SHORT $LN34@Merge_back

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	cl, BYTE PTR [edi-1]
	mov	dl, BYTE PTR [esi-1]
	dec	esi
	dec	edi

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	dec	eax
	cmp	cl, dl
	jbe	SHORT $LN2@Merge_back
	mov	BYTE PTR [eax], dl
	inc	edi

; 2847 : 		else

	jmp	SHORT $LN1@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	BYTE PTR [eax], cl
	inc	esi
$LN1@Merge_back:

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	cmp	ebx, esi
	jne	SHORT $LL8@Merge_back
$LN33@Merge_back:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	sub	edi, ebp
	sub	eax, edi
	mov	esi, eax
	test	edi, edi
	jle	SHORT $LN17@Merge_back
	push	edi
	push	ebp
	push	edi
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN17@Merge_back:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2849 : 	}

	ret	0
$LN34@Merge_back:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	sub	esi, ebx
	sub	eax, esi
	mov	edi, eax
	test	esi, esi
	jle	SHORT $LN26@Merge_back
	push	esi
	push	ebx
	push	esi
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@Merge_back:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2849 : 	}

	ret	0
??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z PROC ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	ebx
	mov	bl, BYTE PTR [eax]
$LL4@Lower_boun:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	cmp	BYTE PTR [eax+esi], bl
	jbe	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [eax+esi+1]
	add	ecx, edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	ebx
$LN22@Lower_boun:

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2306 : 	}

	ret	0
??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ENDP ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z PROC ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	ebx
	mov	bl, BYTE PTR [eax]
$LL4@Upper_boun:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);
; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	cmp	bl, BYTE PTR [eax+esi]
	ja	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [eax+esi+1]
	add	ecx, edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	ebx
$LN22@Upper_boun:

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2377 : 	}

	ret	0
??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ENDP ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z	; stdext::unchecked_copy<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z PROC	; stdext::unchecked_copy<unsigned char *,unsigned char *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	sub	eax, ecx
	push	esi
	lea	esi, DWORD PTR [eax+edx]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@6
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@6:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z ENDP	; stdext::unchecked_copy<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z	; std::_Temp_iterator<unsigned char>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z PROC		; std::_Temp_iterator<unsigned char>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator@4

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx], cl
	mov	ecx, DWORD PTR [eax+16]
	inc	DWORD PTR [ecx+4]

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@4:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN7@operator@4
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [ecx], dl
$LN7@operator@4:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	inc	DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@E@std@@QAEAAV01@ABE@Z ENDP		; std::_Temp_iterator<unsigned char>::operator=
_TEXT	ENDS
PUBLIC	??$_Rotate@PAE@std@@YAXPAE00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAE@std@@YAXPAE00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAE@std@@YAXPAE00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<unsigned char *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z	; std::_Rotate<unsigned char *,int,unsigned char>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAE@std@@YAXPAE00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 16
___formal$ = 36						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR __Val$[esp+20]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR __Val$[esp+24]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR __Last$[esp+12]
	sub	ecx, eax
	sar	ecx, 4
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	??0CvAICityStrategyEntry@@QAE@XZ		; CvAICityStrategyEntry::CvAICityStrategyEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvAICityStrategyEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvAICityStrategyEntry@@QAE@XZ$0
__ehfuncinfo$??0CvAICityStrategyEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvAICityStrategyEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvAICityStrategyEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvAICityStrategyEntry@@QAE@XZ PROC			; CvAICityStrategyEntry::CvAICityStrategyEntry, COMDAT
; _this$ = ecx

; 40   : {

	push	-1
	push	__ehhandler$??0CvAICityStrategyEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	or	ecx, -1
	mov	DWORD PTR [esi+272], ecx
	mov	DWORD PTR [esi+276], ecx
	mov	DWORD PTR [esi+292], ecx
	lea	ecx, DWORD PTR [esi+296]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAICityStrategyEntry@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	BYTE PTR [esi+288], al
	mov	BYTE PTR [esi+289], al
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 41   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi+324], 1
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvAICityStrategyEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvAICityStrategyEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvAICityStrategyEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvAICityStrategyEntry@@QAE@XZ ENDP			; CvAICityStrategyEntry::CvAICityStrategyEntry
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvAICityStrategyEntry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAICityStrategyEntry@@UAEPAXI@Z PROC		; CvAICityStrategyEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAICityStrategyEntry@@UAE@XZ	; CvAICityStrategyEntry::~CvAICityStrategyEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAICityStrategyEntry@@UAEPAXI@Z ENDP		; CvAICityStrategyEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z ; CvCityStrategyAI::Init
EXTRN	??0CvProcessProductionAI@@QAE@PAVCvCity@@@Z:PROC ; CvProcessProductionAI::CvProcessProductionAI
EXTRN	??0CvProjectProductionAI@@QAE@PAVCvCity@@@Z:PROC ; CvProjectProductionAI::CvProjectProductionAI
EXTRN	??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z:PROC ; CvUnitProductionAI::CvUnitProductionAI
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z:PROC ; CvBuildingProductionAI::CvBuildingProductionAI
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$3
__ehfuncinfo$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pAICityStrategies$ = 8					; size = 4
_pCity$ = 12						; size = 4
$T233883 = 16						; size = 4
$T233879 = 16						; size = 4
$T233875 = 16						; size = 4
$T233871 = 16						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z PROC ; CvCityStrategyAI::Init, COMDAT
; _this$ = ecx

; 269  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 270  : 	// Init base class
; 271  : 	CvFlavorRecipient::Init();

	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 272  : 
; 273  : 	// Store off the pointers passed in to this object
; 274  : 	m_bIsCity = bIsCity;
; 275  : 	m_pAICityStrategies = pAICityStrategies;

	mov	ecx, DWORD PTR _pAICityStrategies$[esp+24]
	mov	al, BYTE PTR _bIsCity$[esp+24]

; 276  : 	m_pCity = pCity;

	mov	ebp, DWORD PTR _pCity$[esp+24]
	mov	BYTE PTR [esi+4], al
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+12], ebp

; 277  : 
; 278  : 	// Initialize arrays
; 279  : 	CvAssertMsg(m_pabUsingCityStrategy==NULL, "about to leak memory, CvCityAIStrategies::m_pabUsingCityStrategy");
; 280  : 	m_pabUsingCityStrategy = FNEW(bool[m_pAICityStrategies->GetNumAICityStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 281  : 
; 282  : 	CvAssertMsg(m_paiTurnCityStrategyAdopted==NULL, "about to leak memory, CvCityAIStrategies::m_paiTurnCityStrategyAdopted");
; 283  : 	m_paiTurnCityStrategyAdopted = FNEW(int[m_pAICityStrategies->GetNumAICityStrategies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+32], eax

; 284  : 
; 285  : 	CvAssertMsg(m_aiTempFlavors==NULL, "about to leak memory, CvCityAIStrategies::m_aiTempFlavors");
; 286  : 	m_aiTempFlavors = FNEW(int[GC.getNumFlavorTypes()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 287  : 
; 288  : 	// Create AI subobjects
; 289  : 	m_pBuildingProductionAI = FNEW(CvBuildingProductionAI(pCity, pCity->GetCityBuildings()), c_eCiv5GameplayDLL, 0);

	push	2200					; 00000898H
	mov	DWORD PTR [esi+36], eax
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T233871[esp+24], edi
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], eax
	cmp	edi, eax
	je	SHORT $LN3@Init
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	push	eax
	push	ebp
	mov	ecx, edi
	call	??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z ; CvBuildingProductionAI::CvBuildingProductionAI
$LN3@Init:
	or	ebx, -1

; 290  : 	m_pUnitProductionAI = FNEW(CvUnitProductionAI(pCity, GC.GetGameUnits()), c_eCiv5GameplayDLL, 0);

	push	1480					; 000005c8H
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	mov	DWORD PTR [esi+40], eax
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T233875[esp+24], edi
	mov	DWORD PTR __$EHRec$[esp+36], 1
	test	edi, edi
	je	SHORT $LN5@Init
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	push	eax
	push	ebp
	mov	ecx, edi
	call	??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z ; CvUnitProductionAI::CvUnitProductionAI
	jmp	SHORT $LN6@Init
$LN5@Init:
	xor	eax, eax
$LN6@Init:

; 291  : 	m_pProjectProductionAI = FNEW(CvProjectProductionAI(pCity), c_eCiv5GameplayDLL, 0);

	push	324					; 00000144H
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	mov	DWORD PTR [esi+44], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T233879[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+36], 2
	test	eax, eax
	je	SHORT $LN7@Init
	push	ebp
	mov	ecx, eax
	call	??0CvProjectProductionAI@@QAE@PAVCvCity@@@Z ; CvProjectProductionAI::CvProjectProductionAI
	jmp	SHORT $LN8@Init
$LN7@Init:
	xor	eax, eax
$LN8@Init:

; 292  : 	m_pProcessProductionAI = FNEW(CvProcessProductionAI(pCity), c_eCiv5GameplayDLL, 0);

	push	100					; 00000064H
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	mov	DWORD PTR [esi+48], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T233883[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+36], 3
	test	eax, eax
	je	SHORT $LN9@Init
	push	ebp
	mov	ecx, eax
	call	??0CvProcessProductionAI@@QAE@PAVCvCity@@@Z ; CvProcessProductionAI::CvProcessProductionAI
	jmp	SHORT $LN10@Init
$LN9@Init:
	xor	eax, eax
$LN10@Init:

; 293  : 
; 294  : 	// Clear variables
; 295  : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [esi+52], eax
	call	?Reset@CvCityStrategyAI@@QAEXXZ		; CvCityStrategyAI::Reset

; 296  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$0:
	mov	eax, DWORD PTR $T233871[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$1:
	mov	eax, DWORD PTR $T233875[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$2:
	mov	eax, DWORD PTR $T233879[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z$3:
	mov	eax, DWORD PTR $T233883[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvCityStrategyAI@@QAEXPAVCvAICityStrategies@@PAVCvCity@@_N@Z ENDP ; CvCityStrategyAI::Init
PUBLIC	?Uninit@CvCityStrategyAI@@UAEXXZ		; CvCityStrategyAI::Uninit
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvCityStrategyAI@@UAEXXZ
_TEXT	SEGMENT
?Uninit@CvCityStrategyAI@@UAEXXZ PROC			; CvCityStrategyAI::Uninit, COMDAT
; _this$ = ecx

; 300  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 301  : 	// Uninit base class
; 302  : 	CvFlavorRecipient::Uninit();

	call	?Uninit@CvFlavorRecipient@@UAEXXZ	; CvFlavorRecipient::Uninit

; 303  : 
; 304  : 	// Deallocate member variables
; 305  : 	SAFE_DELETE_ARRAY(m_pabUsingCityStrategy);

	mov	eax, DWORD PTR [esi+28]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+28], ebx

; 306  : 	SAFE_DELETE_ARRAY(m_paiTurnCityStrategyAdopted);

	mov	ecx, DWORD PTR [esi+32]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+32], ebx

; 307  : 	SAFE_DELETE_ARRAY(m_aiTempFlavors);

	mov	edx, DWORD PTR [esi+36]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+36], ebx

; 308  : 	SAFE_DELETE(m_pBuildingProductionAI);

	mov	edi, DWORD PTR [esi+40]
	add	esp, 12					; 0000000cH
	cmp	edi, ebx
	je	SHORT $LN11@Uninit
	mov	ecx, edi
	call	??1CvBuildingProductionAI@@QAE@XZ	; CvBuildingProductionAI::~CvBuildingProductionAI
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@Uninit:
	mov	DWORD PTR [esi+40], ebx

; 309  : 	SAFE_DELETE(m_pUnitProductionAI);

	mov	edi, DWORD PTR [esi+44]
	cmp	edi, ebx
	je	SHORT $LN18@Uninit
	mov	ecx, edi
	call	??1CvUnitProductionAI@@QAE@XZ		; CvUnitProductionAI::~CvUnitProductionAI
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@Uninit:
	mov	DWORD PTR [esi+44], ebx

; 310  : 	SAFE_DELETE(m_pProjectProductionAI);

	mov	edi, DWORD PTR [esi+48]
	cmp	edi, ebx
	je	SHORT $LN25@Uninit
	mov	ecx, edi
	call	??1CvProjectProductionAI@@QAE@XZ	; CvProjectProductionAI::~CvProjectProductionAI
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Uninit:
	mov	DWORD PTR [esi+48], ebx

; 311  : 	SAFE_DELETE(m_pProcessProductionAI);

	mov	edi, DWORD PTR [esi+52]
	cmp	edi, ebx
	je	SHORT $LN37@Uninit
	mov	ecx, edi
	call	??1CvProcessProductionAI@@QAE@XZ	; CvProcessProductionAI::~CvProcessProductionAI
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Uninit:
	pop	edi
	mov	DWORD PTR [esi+52], ebx
	pop	esi
	pop	ebx

; 312  : }

	ret	0
?Uninit@CvCityStrategyAI@@UAEXXZ ENDP			; CvCityStrategyAI::Uninit
_TEXT	ENDS
PUBLIC	?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z	; CvCityStrategyAI::Read
EXTRN	?Read@CvProcessProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvProcessProductionAI::Read
EXTRN	?Read@CvProjectProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvProjectProductionAI::Read
EXTRN	?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvUnitProductionAI::Read
EXTRN	?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvBuildingProductionAI::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CitySpecializationTypes@@@Z:PROC ; operator>>
EXTRN	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumAICityStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iNumFlavors$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z PROC	; CvCityStrategyAI::Read, COMDAT
; _this$ = ecx

; 338  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 339  : 	// Version number to maintain backwards compatibility
; 340  : 	uint uiVersion;
; 341  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 342  : 
; 343  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 344  : 
; 345  : 	int iNumFlavors;
; 346  : 	kStream >> iNumFlavors;

	lea	ecx, DWORD PTR _iNumFlavors$[esp+16]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 347  : 	ArrayWrapper<int> wrapLatestFlavor(iNumFlavors, m_piLatestFlavorValues);
; 348  : 	kStream >> wrapLatestFlavor;

	mov	ebp, DWORD PTR _iNumFlavors$[esp+16]
	mov	ebx, DWORD PTR [edi+8]
	test	ebp, ebp
	jle	SHORT $LN9@Read
	npad	2
$LL11@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL11@Read
$LN9@Read:

; 349  : 
; 350  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabUsingCityStrategy, GC.getNumAICityStrategyInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAICityStrategyInfos
	mov	edx, DWORD PTR [edi+28]
	push	eax
	push	edx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 351  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiTurnCityStrategyAdopted, GC.getNumAICityStrategyInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAICityStrategyInfos
	push	eax
	mov	eax, DWORD PTR [edi+32]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 352  : 
; 353  : 	kStream >> m_eSpecialization;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4CitySpecializationTypes@@@Z ; operator>>

; 354  : 	kStream >> m_eDefaultSpecialization;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4CitySpecializationTypes@@@Z ; operator>>

; 355  : 	m_eFocusYield = (YieldTypes)NO_YIELD;	//force yield to default since we don't serialize it.
; 356  : 
; 357  : 	m_pBuildingProductionAI->Read(kStream);

	mov	ecx, DWORD PTR [edi+40]
	add	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR [edi+3696], -1
	call	?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ; CvBuildingProductionAI::Read

; 358  : 	m_pUnitProductionAI->Read(kStream);

	mov	ecx, DWORD PTR [edi+44]
	push	esi
	call	?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z ; CvUnitProductionAI::Read

; 359  : 	m_pProjectProductionAI->Read(kStream);

	mov	ecx, DWORD PTR [edi+48]
	push	esi
	call	?Read@CvProjectProductionAI@@QAEXAAVFDataStream@@@Z ; CvProjectProductionAI::Read

; 360  : 	m_pProcessProductionAI->Read(kStream);

	mov	ecx, DWORD PTR [edi+52]
	push	esi
	call	?Read@CvProcessProductionAI@@QAEXAAVFDataStream@@@Z ; CvProcessProductionAI::Read
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 361  : }

	pop	ecx
	ret	4
?Read@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z ENDP	; CvCityStrategyAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z	; CvCityStrategyAI::Write
EXTRN	?Write@CvProcessProductionAI@@QBEXAAVFDataStream@@@Z:PROC ; CvProcessProductionAI::Write
EXTRN	?Write@CvProjectProductionAI@@QBEXAAVFDataStream@@@Z:PROC ; CvProjectProductionAI::Write
EXTRN	?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z:PROC ; CvUnitProductionAI::Write
EXTRN	?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z:PROC ; CvBuildingProductionAI::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CitySpecializationTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iNumFlavors$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z PROC	; CvCityStrategyAI::Write, COMDAT
; _this$ = ecx

; 365  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 366  : 	// Current version number
; 367  : 	uint uiVersion = 1;
; 368  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 369  : 
; 370  : 	CvAssertMsg(GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 371  : 	int iNumFlavors = GC.getNumFlavorTypes();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764

; 372  : 	kStream << iNumFlavors;

	lea	edx, DWORD PTR _iNumFlavors$[esp+16]
	mov	DWORD PTR _iNumFlavors$[esp+16], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 373  : 	kStream << ArrayWrapper<int>(iNumFlavors, m_piLatestFlavorValues);

	mov	ebp, DWORD PTR _iNumFlavors$[esp+16]
	mov	ebx, DWORD PTR [edi+8]
	test	ebp, ebp
	jle	SHORT $LN11@Write
$LL13@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL13@Write
$LN11@Write:

; 374  : 
; 375  : 	int iNumStrategies = GC.getNumAICityStrategyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAICityStrategyInfos
	mov	ebx, eax

; 376  : 
; 377  : 	CvInfosSerializationHelper::WriteHashedDataArray<AICityStrategyTypes, bool>(kStream, m_pabUsingCityStrategy, iNumStrategies);

	mov	eax, DWORD PTR [edi+28]
	push	ebx
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4AICityStrategyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,bool>

; 378  : 	CvInfosSerializationHelper::WriteHashedDataArray<AICityStrategyTypes, int>(kStream, m_paiTurnCityStrategyAdopted, iNumStrategies);

	mov	ecx, DWORD PTR [edi+32]
	push	ebx
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4AICityStrategyTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum AICityStrategyTypes,int>

; 379  : 
; 380  : 	kStream << m_eSpecialization;

	lea	edx, DWORD PTR [edi+20]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CitySpecializationTypes@@@Z ; operator<<

; 381  : 	kStream << m_eDefaultSpecialization;

	lea	eax, DWORD PTR [edi+24]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CitySpecializationTypes@@@Z ; operator<<

; 382  : 
; 383  : 	m_pBuildingProductionAI->Write(kStream);

	mov	ecx, DWORD PTR [edi+40]
	add	esp, 40					; 00000028H
	push	esi
	call	?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ; CvBuildingProductionAI::Write

; 384  : 	m_pUnitProductionAI->Write(kStream);

	mov	ecx, DWORD PTR [edi+44]
	push	esi
	call	?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z ; CvUnitProductionAI::Write

; 385  : 	m_pProjectProductionAI->Write(kStream);

	mov	ecx, DWORD PTR [edi+48]
	push	esi
	call	?Write@CvProjectProductionAI@@QBEXAAVFDataStream@@@Z ; CvProjectProductionAI::Write

; 386  : 	m_pProcessProductionAI->Write(kStream);

	mov	ecx, DWORD PTR [edi+52]
	push	esi
	call	?Write@CvProcessProductionAI@@QBEXAAVFDataStream@@@Z ; CvProcessProductionAI::Write
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 387  : }

	pop	ecx
	ret	4
?Write@CvCityStrategyAI@@QAEXAAVFDataStream@@@Z ENDP	; CvCityStrategyAI::Write
_TEXT	ENDS
PUBLIC	?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ ; CvCityStrategyAI::UpdateFlavorsForNewCity
EXTRN	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z:PROC ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
EXTRN	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z:PROC ; CvMilitaryAI::IsUsingStrategy
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z:PROC ; CvGlobals::getMilitaryAIStrategyInfo
EXTRN	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumMilitaryAIStrategyInfos
EXTRN	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z:PROC ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z:PROC ; CvGlobals::getEconomicAIStrategyInfo
EXTRN	?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumEconomicAIStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_iStrategyLoop$225946 = -4				; size = 4
_iStrategyLoop$225934 = -4				; size = 4
?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ PROC	; CvCityStrategyAI::UpdateFlavorsForNewCity, COMDAT
; _this$ = ecx

; 421  : {

	push	ecx
	push	ebx
	push	ebp

; 422  : 	int iFlavorLoop;
; 423  : 
; 424  : 	// Clear out Temp array
; 425  : 	for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	eax, eax
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	push	esi
	push	edi
	mov	ebx, ecx
	jle	SHORT $LN17@UpdateFlav
$LL19@UpdateFlav:

; 426  : 	{
; 427  : 		m_aiTempFlavors[iFlavorLoop] = 0;

	mov	ecx, DWORD PTR [ebx+36]
	mov	DWORD PTR [ecx+eax*4], 0
	inc	eax
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL19@UpdateFlav
$LN17@UpdateFlav:

; 428  : 	}
; 429  : 
; 430  : 	// Go through all Player strategies and for the active ones apply the Flavors
; 431  : #ifdef AUI_WARNING_FIXES
; 432  : 	for (uint iStrategyLoop = 0; iStrategyLoop < GC.getNumEconomicAIStrategyInfos(); iStrategyLoop++)
; 433  : #else
; 434  : 	for(int iStrategyLoop = 0; iStrategyLoop < GC.getNumEconomicAIStrategyInfos(); iStrategyLoop++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iStrategyLoop$225934[esp+20], edi
	call	?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumEconomicAIStrategyInfos
	test	eax, eax
	jle	SHORT $LN14@UpdateFlav
	npad	8
$LL52@UpdateFlav:

; 435  : #endif
; 436  : 	{
; 437  : 		EconomicAIStrategyTypes eStrategy = (EconomicAIStrategyTypes) iStrategyLoop;
; 438  : 		CvEconomicAIStrategyXMLEntry* pStrategy = GC.getEconomicAIStrategyInfo(eStrategy);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z ; CvGlobals::getEconomicAIStrategyInfo
	mov	ebp, eax

; 439  : 
; 440  : 		if(pStrategy)

	test	ebp, ebp
	je	SHORT $LN15@UpdateFlav

; 441  : 		{
; 442  : 			// Active?
; 443  : 			if(GET_PLAYER(m_pCity->getOwner()).GetEconomicAI()->IsUsingStrategy(eStrategy))

	mov	edx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN15@UpdateFlav

; 444  : 			{
; 445  : 				for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN15@UpdateFlav
	npad	2
$LL11@UpdateFlav:
	mov	eax, DWORD PTR [ebx+36]

; 446  : 				{
; 447  : 					m_aiTempFlavors[iFlavorLoop] += pStrategy->GetCityFlavorValue(iFlavorLoop);

	push	esi
	mov	ecx, ebp
	lea	edi, DWORD PTR [eax+esi*4]
	call	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
	add	DWORD PTR [edi], eax
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL11@UpdateFlav

; 444  : 			{
; 445  : 				for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	edi, DWORD PTR _iStrategyLoop$225934[esp+20]
$LN15@UpdateFlav:

; 428  : 	}
; 429  : 
; 430  : 	// Go through all Player strategies and for the active ones apply the Flavors
; 431  : #ifdef AUI_WARNING_FIXES
; 432  : 	for (uint iStrategyLoop = 0; iStrategyLoop < GC.getNumEconomicAIStrategyInfos(); iStrategyLoop++)
; 433  : #else
; 434  : 	for(int iStrategyLoop = 0; iStrategyLoop < GC.getNumEconomicAIStrategyInfos(); iStrategyLoop++)

	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iStrategyLoop$225934[esp+20], edi
	call	?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumEconomicAIStrategyInfos
	cmp	edi, eax
	jl	SHORT $LL52@UpdateFlav
$LN14@UpdateFlav:

; 448  : 				}
; 449  : 			}
; 450  : 		}
; 451  : 	}
; 452  : #ifdef AUI_WARNING_FIXES
; 453  : 	for (uint iStrategyLoop = 0; iStrategyLoop < GC.getNumMilitaryAIStrategyInfos(); iStrategyLoop++)
; 454  : #else
; 455  : 	for(int iStrategyLoop = 0; iStrategyLoop < GC.getNumMilitaryAIStrategyInfos(); iStrategyLoop++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iStrategyLoop$225946[esp+20], edi
	call	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMilitaryAIStrategyInfos
	test	eax, eax
	jle	SHORT $LN6@UpdateFlav
$LL53@UpdateFlav:

; 456  : #endif
; 457  : 	{
; 458  : 		MilitaryAIStrategyTypes eStrategy = (MilitaryAIStrategyTypes) iStrategyLoop;
; 459  : 		CvMilitaryAIStrategyXMLEntry* pStrategy = GC.getMilitaryAIStrategyInfo(eStrategy);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z ; CvGlobals::getMilitaryAIStrategyInfo
	mov	ebp, eax

; 460  : 
; 461  : 		if(pStrategy)

	test	ebp, ebp
	je	SHORT $LN7@UpdateFlav

; 462  : 		{
; 463  : 			// Active?
; 464  : 			if(GET_PLAYER(m_pCity->getOwner()).GetMilitaryAI()->IsUsingStrategy(eStrategy))

	mov	ecx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN7@UpdateFlav

; 465  : 			{
; 466  : 				for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN7@UpdateFlav
$LL3@UpdateFlav:
	mov	edx, DWORD PTR [ebx+36]

; 467  : 				{
; 468  : 					m_aiTempFlavors[iFlavorLoop] += pStrategy->GetCityFlavorValue(iFlavorLoop);

	push	esi
	mov	ecx, ebp
	lea	edi, DWORD PTR [edx+esi*4]
	call	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
	add	DWORD PTR [edi], eax
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL3@UpdateFlav

; 465  : 			{
; 466  : 				for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	edi, DWORD PTR _iStrategyLoop$225946[esp+20]
$LN7@UpdateFlav:

; 448  : 				}
; 449  : 			}
; 450  : 		}
; 451  : 	}
; 452  : #ifdef AUI_WARNING_FIXES
; 453  : 	for (uint iStrategyLoop = 0; iStrategyLoop < GC.getNumMilitaryAIStrategyInfos(); iStrategyLoop++)
; 454  : #else
; 455  : 	for(int iStrategyLoop = 0; iStrategyLoop < GC.getNumMilitaryAIStrategyInfos(); iStrategyLoop++)

	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iStrategyLoop$225946[esp+20], edi
	call	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMilitaryAIStrategyInfos
	cmp	edi, eax
	jl	SHORT $LL53@UpdateFlav
$LN6@UpdateFlav:

; 469  : 				}
; 470  : 			}
; 471  : 		}
; 472  : 	}
; 473  : 
; 474  : 	ChangeFlavors(m_aiTempFlavors, true);

	mov	eax, DWORD PTR [ebx+36]
	push	1
	push	eax
	mov	ecx, ebx
	call	?ChangeFlavors@CvFlavorRecipient@@QAEXPAH_N@Z ; CvFlavorRecipient::ChangeFlavors

; 475  : 
; 476  : 	LogFlavors();

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+12]
	push	-1
	mov	ecx, ebx
	call	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 477  : }

	pop	ecx
	ret	0
?UpdateFlavorsForNewCity@CvCityStrategyAI@@QAEXXZ ENDP	; CvCityStrategyAI::UpdateFlavorsForNewCity
_TEXT	ENDS
PUBLIC	?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldAverage
EXTRN	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z:PROC ; CvPlot::calculateYield
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z
_TEXT	SEGMENT
_iYieldAmount$ = -16					; size = 4
_iTilesWorked$ = -12					; size = 4
_fRatio$ = -8						; size = 8
_this$ = -8						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z PROC ; CvCityStrategyAI::GetYieldAverage, COMDAT
; _this$ = ecx

; 696  : {

	sub	esp, 16					; 00000010H

; 697  : 	CvPlayer* pPlayer = &GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _this$[esp+16], ecx
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	edi

; 698  : 	CvPlotsVector& aiPlots = pPlayer->GetPlots();

	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots

; 699  : 
; 700  : 	int iTilesWorked = 0;

	xor	ebx, ebx
	mov	edi, eax
	xor	ebp, ebp
	mov	DWORD PTR _iTilesWorked$[esp+28], ebp

; 701  : 	int iYieldAmount = 0;

	mov	DWORD PTR _iYieldAmount$[esp+28], ebx

; 702  : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	cmp	DWORD PTR [edi+4], ebx
	jbe	SHORT $LN30@GetYieldAv
	push	esi
$LL33@GetYieldAv:

; 703  : 	{
; 704  : 		// at the end of the plot list
; 705  : 		if(aiPlots[ui] == -1)

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+ebx*4]
	cmp	eax, -1
	je	SHORT $LN34@GetYieldAv

; 706  : 		{
; 707  : 			break;
; 708  : 		}
; 709  : 
; 710  : 		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	test	eax, eax
	jl	SHORT $LN25@GetYieldAv
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN25@GetYieldAv
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax
	jmp	SHORT $LN26@GetYieldAv
$LN25@GetYieldAv:
	xor	esi, esi
$LN26@GetYieldAv:

; 711  : 		if(!m_pCity->GetCityCitizens()->IsWorkingPlot(pPlot))

	mov	edx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [edx+12]
	push	esi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	je	SHORT $LN5@GetYieldAv

; 717  : 		iYieldAmount += pPlot->calculateYield(eYieldType);

	mov	eax, DWORD PTR _eYieldType$[esp+28]
	push	0
	push	eax
	mov	ecx, esi
	inc	ebp
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	add	DWORD PTR _iYieldAmount$[esp+32], eax
$LN5@GetYieldAv:
	inc	ebx
	cmp	ebx, DWORD PTR [edi+4]
	jb	SHORT $LL33@GetYieldAv
$LN34@GetYieldAv:

; 712  : 		{
; 713  : 			continue;
; 714  : 		}
; 715  : 
; 716  : 		iTilesWorked++;

	mov	DWORD PTR _iTilesWorked$[esp+32], ebp
	pop	esi
$LN30@GetYieldAv:

; 718  : 	}
; 719  : 
; 720  : 	double fRatio = 0.0;

	xor	eax, eax
	pop	edi

; 721  : 	if(iTilesWorked > 0)

	cmp	ebp, eax
	pop	ebp
	mov	DWORD PTR _fRatio$[esp+20], eax
	mov	DWORD PTR _fRatio$[esp+24], eax
	pop	ebx
	jle	SHORT $LN32@GetYieldAv

; 722  : 	{
; 723  : 		fRatio = iYieldAmount / (double)iTilesWorked;

	fild	DWORD PTR _iYieldAmount$[esp+16]
	fidiv	DWORD PTR _iTilesWorked$[esp+16]
	fstp	QWORD PTR _fRatio$[esp+16]
$LN32@GetYieldAv:

; 724  : 	}
; 725  : 
; 726  : 	return fRatio;

	fld	QWORD PTR _fRatio$[esp+16]

; 727  : }

	add	esp, 16					; 00000010H
	ret	4
?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::GetYieldAverage
_TEXT	ENDS
PUBLIC	?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z ; CvCityStrategyAI::LogHurry
EXTRN	?getProductionName@CvCity@@QBEPBDXZ:PROC	; CvCity::getProductionName
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
_TEXT	SEGMENT
_playerName$226804 = -292				; size = 28
_cityName$226805 = -264					; size = 28
_strTemp$226803 = -236					; size = 28
_strBaseString$226802 = -208				; size = 28
_strOutBuf$226801 = -180				; size = 28
$T234216 = -152						; size = 28
$T234213 = -152						; size = 28
$T234212 = -124						; size = 28
$T234211 = -124						; size = 28
$T234214 = -96						; size = 28
$T234215 = -68						; size = 28
_strDesc$226806 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_iHurryType$ = 8					; size = 4
_iHurryAmount$ = 12					; size = 4
_iHurryAmountAvailable$ = 16				; size = 4
_iTurnsSaved$ = 20					; size = 4
?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z PROC ; CvCityStrategyAI::LogHurry, COMDAT
; _this$ = ecx

; 1729 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 280				; 00000118H
	push	edi
	mov	edi, ecx

; 1730 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@LogHurry
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@LogHurry
	push	ebx
	push	esi

; 1731 : 	{
; 1732 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226801[esp+304]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1733 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226802[esp+304]
	mov	DWORD PTR __$EHRec$[esp+312], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1734 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226803[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1735 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226804[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1736 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226805[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1737 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226806[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1738 : 
; 1739 : 		// Find the name of this civ and city
; 1740 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	bl, 5
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+312], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$226804[esp+304]
	test	eax, eax
	je	SHORT $LN43@LogHurry
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN42@LogHurry
$LN43@LogHurry:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN42@LogHurry:
	push	ebp

; 1741 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T234211[esp+308]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$226805[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234211[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1742 : 
; 1743 : 		// Open the log file
; 1744 : 		FILogFile* pLog;
; 1745 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$226805[esp+308]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$226804[esp+312]
	push	eax
	lea	ecx, DWORD PTR $T234212[esp+316]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234212[esp+308]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+316], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1746 : 
; 1747 : 		// Get the leading info for this line
; 1748 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226802[esp+312]
	push	OFFSET $SG226810
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1749 : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226815
	lea	edx, DWORD PTR _playerName$226804[esp+324]
	push	edx
	lea	eax, DWORD PTR $T234213[esp+328]
	push	eax
	call	ebp
	lea	ecx, DWORD PTR _cityName$226805[esp+332]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T234214[esp+340]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+352], 8
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG226814
	push	eax
	lea	eax, DWORD PTR $T234215[esp+352]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+364], 9
	call	ebp
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226802[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234215[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234214[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+316], bl
	lea	ecx, DWORD PTR $T234213[esp+308]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1750 : 
; 1751 : 		if(iHurryType == 0)

	cmp	DWORD PTR _iHurryType$[esp+304], 0
	pop	ebp
	jne	SHORT $LN2@LogHurry

; 1752 : 		{
; 1753 : 			strTemp.Format("Pop rushed: %s, Spent: %d, Available: %d, Turns Saved: %d", m_pCity->getProductionName(), iHurryAmount, iHurryAmountAvailable, iTurnsSaved);

	mov	ecx, DWORD PTR _iTurnsSaved$[esp+300]
	mov	edx, DWORD PTR _iHurryAmountAvailable$[esp+300]
	mov	eax, DWORD PTR _iHurryAmount$[esp+300]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	push	edx
	push	eax
	call	?getProductionName@CvCity@@QBEPBDXZ	; CvCity::getProductionName
	push	eax
	push	OFFSET $SG226817
	lea	ecx, DWORD PTR _strTemp$226803[esp+324]
	push	ecx

; 1754 : 		}
; 1755 : 		else

	jmp	SHORT $LN81@LogHurry
$LN2@LogHurry:

; 1756 : 		{
; 1757 : 			strTemp.Format("Gold rushed: %s, Spent: %d, Available: %d, Turns Saved: %d", m_pCity->getProductionName(), iHurryAmount, iHurryAmountAvailable, iTurnsSaved);

	mov	edx, DWORD PTR _iTurnsSaved$[esp+300]
	mov	eax, DWORD PTR _iHurryAmountAvailable$[esp+300]
	mov	ecx, DWORD PTR _iHurryAmount$[esp+300]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	call	?getProductionName@CvCity@@QBEPBDXZ	; CvCity::getProductionName
	push	eax
	push	OFFSET $SG226819
	lea	edx, DWORD PTR _strTemp$226803[esp+324]
	push	edx
$LN81@LogHurry:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1758 : 		}
; 1759 : 
; 1760 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226803[esp+304]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226802[esp+308]
	push	ecx
	lea	edx, DWORD PTR $T234216[esp+312]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+312], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226801[esp+308]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234216[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1761 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226801[esp+304]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 1762 : 	}

	lea	ecx, DWORD PTR _strDesc$226806[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _cityName$226805[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$226804[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$226803[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226802[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$226801[esp+304]
	mov	DWORD PTR __$EHRec$[esp+312], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN3@LogHurry:

; 1763 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 292				; 00000124H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226801[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226802[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$2:
	lea	ecx, DWORD PTR _strTemp$226803[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$3:
	lea	ecx, DWORD PTR _playerName$226804[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$4:
	lea	ecx, DWORD PTR _cityName$226805[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$5:
	lea	ecx, DWORD PTR _strDesc$226806[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$6:
	lea	ecx, DWORD PTR $T234211[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$7:
	lea	ecx, DWORD PTR $T234212[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$8:
	lea	ecx, DWORD PTR $T234213[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$9:
	lea	ecx, DWORD PTR $T234214[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$10:
	lea	ecx, DWORD PTR $T234215[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z$11:
	lea	ecx, DWORD PTR $T234216[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z ENDP ; CvCityStrategyAI::LogHurry
PUBLIC	?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z ; CvCityStrategyAI::LogFlavors
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
_strBaseString$226836 = -292				; size = 28
$T234341 = -264						; size = 28
$T234340 = -264						; size = 28
$T234337 = -264						; size = 28
_strOutBuf$226835 = -236				; size = 28
_strTemp$226837 = -208					; size = 28
_playerName$226838 = -180				; size = 28
_cityName$226839 = -152					; size = 28
$T234336 = -124						; size = 28
$T234335 = -124						; size = 28
$T234338 = -96						; size = 28
$T234339 = -68						; size = 28
_strDesc$226840 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eFlavor$ = 8						; size = 4
?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z PROC ; CvCityStrategyAI::LogFlavors, COMDAT
; _this$ = ecx

; 1785 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 280				; 00000118H
	push	ebp
	mov	ebp, ecx

; 1786 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@LogFlavors
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@LogFlavors

; 1787 : 	{
; 1788 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226835[esp+296]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1789 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226836[esp+296]
	mov	DWORD PTR __$EHRec$[esp+304], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1790 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226837[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1791 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226838[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1792 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226839[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1793 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226840[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1794 : 
; 1795 : 		// Find the name of this civ and city
; 1796 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+304], 5
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$226838[esp+296]
	test	eax, eax
	je	SHORT $LN47@LogFlavors
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN46@LogFlavors
$LN47@LogFlavors:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN46@LogFlavors:
	push	ebx
	push	esi
	push	edi

; 1797 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T234335[esp+308]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$226839[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234335[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1798 : 
; 1799 : 		// Open the log file
; 1800 : 		FILogFile* pLog;
; 1801 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$226839[esp+308]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$226838[esp+312]
	push	eax
	lea	ecx, DWORD PTR $T234336[esp+316]
	push	ecx
	mov	ecx, ebp
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234336[esp+308]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+316], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1802 : 
; 1803 : 		// Get the leading info for this line
; 1804 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226836[esp+312]
	push	OFFSET $SG226844
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1805 : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226849
	lea	edx, DWORD PTR _playerName$226838[esp+324]
	push	edx
	lea	eax, DWORD PTR $T234337[esp+328]
	push	eax
	call	edi
	mov	ebx, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	ecx, DWORD PTR _cityName$226839[esp+332]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T234338[esp+340]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+352], 8
	call	ebx
	push	OFFSET $SG226848
	push	eax
	lea	eax, DWORD PTR $T234339[esp+352]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+364], 9
	call	edi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226836[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234339[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+316], 8
	lea	ecx, DWORD PTR $T234338[esp+308]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234337[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1806 : 
; 1807 : 		// Dump out the setting for each flavor
; 1808 : 		if(eFlavor == NO_FLAVOR)

	mov	edi, DWORD PTR _eFlavor$[esp+304]
	cmp	edi, -1
	jne	$LN5@LogFlavors

; 1809 : 		{
; 1810 : 			for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	jle	$LN1@LogFlavors
	xor	ebx, ebx
$LL4@LogFlavors:

; 1811 : 			{
; 1812 : 				// Only dump if non-zero
; 1813 : 				//		if (m_piLatestFlavorValues[iI] > 0)
; 1814 : 				{
; 1815 : 					strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes((FlavorTypes)iI).GetCString(), m_piLatestFlavorValues[iI]);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	ecx, ebx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edx+edi*4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strTemp$226837[esp+316]
	push	OFFSET $SG226856
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1816 : 					strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226837[esp+324]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226836[esp+328]
	push	ecx
	lea	edx, DWORD PTR $T234340[esp+332]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226835[esp+312]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234340[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1817 : 					pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226835[esp+308]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	inc	edi
	add	esp, 8
	add	ebx, 28					; 0000001cH
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL4@LogFlavors

; 1818 : 				}
; 1819 : 			}
; 1820 : 		}
; 1821 : 		else

	jmp	$LN1@LogFlavors
$LN5@LogFlavors:

; 1822 : 		{
; 1823 : 			strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes(eFlavor).GetCString(), m_piLatestFlavorValues[eFlavor]);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edx+edi*4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strTemp$226837[esp+316]
	push	OFFSET $SG226859
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1824 : 			strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226837[esp+324]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226836[esp+328]
	push	ecx
	lea	edx, DWORD PTR $T234341[esp+332]
	push	edx
	call	ebx
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226835[esp+312]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234341[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1825 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226835[esp+308]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8
$LN1@LogFlavors:

; 1826 : 		}
; 1827 : 	}

	lea	ecx, DWORD PTR _strDesc$226840[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _cityName$226839[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$226838[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$226837[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226836[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$226835[esp+308]
	mov	DWORD PTR __$EHRec$[esp+316], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
$LN6@LogFlavors:

; 1828 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 292				; 00000124H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226835[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226836[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$226837[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$226838[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$4:
	lea	ecx, DWORD PTR _cityName$226839[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$5:
	lea	ecx, DWORD PTR _strDesc$226840[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$6:
	lea	ecx, DWORD PTR $T234335[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$7:
	lea	ecx, DWORD PTR $T234336[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$8:
	lea	ecx, DWORD PTR $T234337[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$9:
	lea	ecx, DWORD PTR $T234338[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$10:
	lea	ecx, DWORD PTR $T234339[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$11:
	lea	ecx, DWORD PTR $T234340[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z$12:
	lea	ecx, DWORD PTR $T234341[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z ENDP ; CvCityStrategyAI::LogFlavors
PUBLIC	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
EXTRN	?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z:PROC ; CvGlobals::getAICityStrategyInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
_TEXT	SEGMENT
_strTemp$226882 = -236					; size = 28
$T234493 = -236						; size = 28
_strOutBuf$226867 = -208				; size = 28
_strBaseString$226868 = -180				; size = 28
_cityName$226870 = -152					; size = 28
_playerName$226869 = -124				; size = 28
$T234490 = -96						; size = 28
$T234492 = -68						; size = 28
$T234491 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z PROC ; CvCityStrategyAI::LogStrategy, COMDAT
; _this$ = ecx

; 1832 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 224				; 000000e0H
	push	edi
	mov	edi, ecx

; 1833 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@LogStrateg
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN2@LogStrateg

; 1834 : 	{
; 1835 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226867[esp+240]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1836 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226868[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1837 : 
; 1838 : 		// Find the name of this civ and city
; 1839 : 		CvString playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+248], 1
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN29@LogStrateg
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN29@LogStrateg:
	push	ebx
	push	esi
	push	eax
	lea	ecx, DWORD PTR _playerName$226869[esp+252]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1840 : 		CvString cityName = m_pCity->getName();

	lea	ecx, DWORD PTR _cityName$226870[esp+248]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	BYTE PTR __$EHRec$[esp+260], 2
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	bl, 3
	mov	BYTE PTR __$EHRec$[esp+256], bl

; 1841 : 
; 1842 : 		// Open the log file
; 1843 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$226870[esp+248]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$226869[esp+252]
	push	eax
	lea	ecx, DWORD PTR $T234490[esp+256]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+256], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234490[esp+248]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+256], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1844 : 
; 1845 : 		// Get the leading info for this line
; 1846 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226868[esp+252]
	push	OFFSET $SG226874
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1847 : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226879
	lea	edx, DWORD PTR _playerName$226869[esp+264]
	push	edx
	lea	eax, DWORD PTR $T234491[esp+268]
	push	eax
	call	esi
	lea	ecx, DWORD PTR _cityName$226870[esp+272]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T234492[esp+280]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+292], 5
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG226878
	push	eax
	lea	eax, DWORD PTR $T234493[esp+292]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+304], 6
	call	esi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226868[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 7
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234493[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234492[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+256], bl
	lea	ecx, DWORD PTR $T234491[esp+248]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1848 : 
; 1849 : 		strOutBuf = strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226868[esp+248]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$226867[esp+252]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1850 : 
; 1851 : 		// Strategy Info
; 1852 : 		CvAICityStrategyEntry* pStrategyEntry = GC.getAICityStrategyInfo(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[esp+244]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z ; CvGlobals::getAICityStrategyInfo
	mov	esi, eax

; 1853 : 		if(pStrategyEntry != NULL)

	test	esi, esi
	je	SHORT $LN1@LogStrateg

; 1854 : 		{
; 1855 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226882[esp+248]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1856 : 			strTemp.Format("%s, %d", pStrategyEntry->GetType(), bValue);

	movzx	eax, BYTE PTR _bValue$[esp+244]
	push	eax
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+260], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$226882[esp+256]
	push	OFFSET $SG226883
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1857 : 			strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$226882[esp+248]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$226867[esp+252]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1858 : 		}

	lea	ecx, DWORD PTR _strTemp$226882[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogStrateg:

; 1859 : 
; 1860 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226867[esp+248]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8

; 1861 : 	}

	lea	ecx, DWORD PTR _cityName$226870[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$226869[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226868[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$226867[esp+248]
	mov	DWORD PTR __$EHRec$[esp+256], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN2@LogStrateg:

; 1862 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+240]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 236				; 000000ecH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226867[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226868[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _playerName$226869[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$3:
	lea	ecx, DWORD PTR _cityName$226870[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$4:
	lea	ecx, DWORD PTR $T234490[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T234491[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$6:
	lea	ecx, DWORD PTR $T234492[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T234493[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z$8:
	lea	ecx, DWORD PTR _strTemp$226882[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ENDP ; CvCityStrategyAI::LogStrategy
PUBLIC	?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z ; CvCityStrategyAI::LogCityProduction
EXTRN	?getSeed@CvRandom@@QBEKXZ:PROC			; CvRandom::getSeed
EXTRN	?getJonRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getJonRand
EXTRN	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z:PROC ; CvGlobals::getProcessInfo
EXTRN	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z:PROC ; CvProjectXMLEntries::GetEntry
EXTRN	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ:PROC ; CvGlobals::GetGameProjects
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
_TEXT	SEGMENT
_strDesc$226949 = -292					; size = 28
_playerName$226947 = -264				; size = 28
_strBaseString$226945 = -236				; size = 28
_strTemp$226946 = -208					; size = 28
_cityName$226948 = -180					; size = 28
$T234590 = -152						; size = 28
$T234589 = -152						; size = 28
$T234594 = -124						; size = 28
$T234591 = -124						; size = 28
_strOutBuf$226944 = -96					; size = 28
$T234593 = -68						; size = 28
$T234592 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_buildable$ = 8						; size = 12
_bRush$ = 20						; size = 1
?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z PROC ; CvCityStrategyAI::LogCityProduction, COMDAT
; _this$ = ecx

; 1968 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 280				; 00000118H
	push	edi
	mov	edi, ecx

; 1969 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN13@LogCityPro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN13@LogCityPro
	push	ebx
	push	ebp
	push	esi

; 1970 : 	{
; 1971 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226944[esp+308]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1972 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226945[esp+308]
	mov	DWORD PTR __$EHRec$[esp+316], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1973 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226946[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1974 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226947[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1975 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226948[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1976 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226949[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1977 : 
; 1978 : 		// Find the name of this civ and city
; 1979 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, 5
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$226947[esp+308]
	test	eax, eax
	je	SHORT $LN53@LogCityPro
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN52@LogCityPro
$LN53@LogCityPro:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN52@LogCityPro:

; 1980 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T234589[esp+308]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$226948[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234589[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1981 : 
; 1982 : 		FILogFile* pLog;
; 1983 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$226948[esp+308]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$226947[esp+312]
	push	eax
	lea	ecx, DWORD PTR $T234590[esp+316]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234590[esp+308]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+316], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1984 : 
; 1985 : 		// Get the leading info for this line
; 1986 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226945[esp+312]
	push	OFFSET $SG226953
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1987 : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226958
	lea	edx, DWORD PTR _playerName$226947[esp+324]
	push	edx
	lea	eax, DWORD PTR $T234591[esp+328]
	push	eax
	call	esi
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	ecx, DWORD PTR _cityName$226948[esp+332]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T234592[esp+340]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+352], 8
	call	ebp
	push	OFFSET $SG226957
	push	eax
	lea	eax, DWORD PTR $T234593[esp+352]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+364], 9
	call	esi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226945[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234593[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234592[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+316], bl
	lea	ecx, DWORD PTR $T234591[esp+308]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1988 : 
; 1989 : 		switch(buildable.m_eBuildableType)

	mov	eax, DWORD PTR _buildable$[esp+304]
	dec	eax
	cmp	eax, ebx
	ja	$LN3@LogCityPro
	jmp	DWORD PTR $LN106@LogCityPro[eax*4]
$LN10@LogCityPro:

; 1990 : 		{
; 1991 : 		case CITY_BUILDABLE_BUILDING:
; 1992 : 		{
; 1993 : 			CvBuildingEntry* pEntry = GC.GetGameBuildings()->GetEntry(buildable.m_iIndex);

	mov	ecx, DWORD PTR _buildable$[esp+308]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 1994 : 			if(pEntry != NULL)
; 1995 : 			{
; 1996 : 				strDesc = pEntry->GetDescription();
; 1997 : 			}
; 1998 : 		}
; 1999 : 		break;

	jmp	SHORT $LN104@LogCityPro
$LN8@LogCityPro:

; 2000 : 		case CITY_BUILDABLE_UNIT:
; 2001 : 		case CITY_BUILDABLE_UNIT_FOR_OPERATION:
; 2002 : 		case CITY_BUILDABLE_UNIT_FOR_ARMY:
; 2003 : 		{
; 2004 : 			CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	mov	edx, DWORD PTR _buildable$[esp+308]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry

; 2005 : 			if(pEntry != NULL)
; 2006 : 			{
; 2007 : 				strDesc = pEntry->GetDescription();
; 2008 : 
; 2009 : 			}
; 2010 : 		}
; 2011 : 		break;

	jmp	SHORT $LN104@LogCityPro
$LN6@LogCityPro:

; 2012 : 		case CITY_BUILDABLE_PROJECT:
; 2013 : 		{
; 2014 : 			CvProjectEntry* pEntry = GC.GetGameProjects()->GetEntry(buildable.m_iIndex);

	mov	eax, DWORD PTR _buildable$[esp+308]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ; CvProjectXMLEntries::GetEntry

; 2015 : 			if(pEntry != NULL)
; 2016 : 			{
; 2017 : 				strDesc = pEntry->GetDescription();
; 2018 : 
; 2019 : 			}
; 2020 : 		}
; 2021 : 		break;

	jmp	SHORT $LN104@LogCityPro
$LN4@LogCityPro:

; 2022 : 		case CITY_BUILDABLE_PROCESS:
; 2023 : 		{
; 2024 : 			CvProcessInfo* pEntry = GC.getProcessInfo((ProcessTypes)buildable.m_iIndex);

	mov	ecx, DWORD PTR _buildable$[esp+308]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z ; CvGlobals::getProcessInfo
$LN104@LogCityPro:

; 2025 : 			if (pEntry != NULL)

	test	eax, eax
	je	SHORT $LN3@LogCityPro

; 2026 : 			{
; 2027 : 				strDesc = pEntry->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226949[esp+312]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN3@LogCityPro:

; 2028 : 			}
; 2029 : 		}
; 2030 : 		break;
; 2031 : 		}
; 2032 : 
; 2033 : 		if(bRush)

	cmp	BYTE PTR _bRush$[esp+304], 0

; 2034 : 		{
; 2035 : 			strTemp.Format("SEED: %d, CHOSEN: %s, Rush if possible, TURNS: %d", GC.getGame().getJonRand().getSeed(), strDesc.c_str(), buildable.m_iTurnsToConstruct);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	je	SHORT $LN2@LogCityPro
	mov	edx, DWORD PTR _buildable$[esp+312]
	push	edx
	lea	ecx, DWORD PTR _strDesc$226949[esp+312]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	?getJonRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getJonRand
	mov	ecx, eax
	call	?getSeed@CvRandom@@QBEKXZ		; CvRandom::getSeed
	push	eax
	push	OFFSET $SG226977
	lea	eax, DWORD PTR _strTemp$226946[esp+324]
	push	eax

; 2036 : 		}
; 2037 : 		else

	jmp	SHORT $LN105@LogCityPro
$LN2@LogCityPro:

; 2038 : 		{
; 2039 : 			strTemp.Format("SEED: %d, CHOSEN: %s, Do not rush, TURNS: %d", GC.getGame().getJonRand().getSeed(), strDesc.c_str(), buildable.m_iTurnsToConstruct);

	mov	ecx, DWORD PTR _buildable$[esp+312]
	push	ecx
	lea	ecx, DWORD PTR _strDesc$226949[esp+312]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	?getJonRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getJonRand
	mov	ecx, eax
	call	?getSeed@CvRandom@@QBEKXZ		; CvRandom::getSeed
	push	eax
	push	OFFSET $SG226979
	lea	edx, DWORD PTR _strTemp$226946[esp+324]
	push	edx
$LN105@LogCityPro:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2040 : 		}
; 2041 : 
; 2042 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$226946[esp+308]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226945[esp+312]
	push	ecx
	lea	edx, DWORD PTR $T234594[esp+316]
	push	edx
	call	ebp
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+316], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226944[esp+312]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234594[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2043 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226944[esp+308]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8

; 2044 : 	}

	lea	ecx, DWORD PTR _strDesc$226949[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _cityName$226948[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$226947[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$226946[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226945[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$226944[esp+308]
	mov	DWORD PTR __$EHRec$[esp+316], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
	pop	ebx
$LN13@LogCityPro:

; 2045 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 292				; 00000124H
	ret	16					; 00000010H
	npad	3
$LN106@LogCityPro:
	DD	$LN10@LogCityPro
	DD	$LN8@LogCityPro
	DD	$LN6@LogCityPro
	DD	$LN4@LogCityPro
	DD	$LN8@LogCityPro
	DD	$LN8@LogCityPro
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226944[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226945[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$2:
	lea	ecx, DWORD PTR _strTemp$226946[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$3:
	lea	ecx, DWORD PTR _playerName$226947[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$4:
	lea	ecx, DWORD PTR _cityName$226948[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$5:
	lea	ecx, DWORD PTR _strDesc$226949[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$6:
	lea	ecx, DWORD PTR $T234589[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$7:
	lea	ecx, DWORD PTR $T234590[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$8:
	lea	ecx, DWORD PTR $T234591[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$9:
	lea	ecx, DWORD PTR $T234592[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$10:
	lea	ecx, DWORD PTR $T234593[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z$11:
	lea	ecx, DWORD PTR $T234594[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z ENDP ; CvCityStrategyAI::LogCityProduction
PUBLIC	?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::LogSpecializationChange
EXTRN	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z:PROC ; CvGlobals::getYieldInfo
EXTRN	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ:PROC ; CvCitySpecializationXMLEntry::GetYieldType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_strYieldString$227002 = -236				; size = 28
$T234738 = -236						; size = 28
_strBaseString$226991 = -208				; size = 28
_strTemp$227009 = -180					; size = 28
$T234739 = -180						; size = 28
_cityName$226987 = -152					; size = 28
_strOutBuf$226998 = -124				; size = 28
$T234740 = -96						; size = 28
$T234737 = -96						; size = 28
_playerName$226986 = -68				; size = 28
$T234736 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eSpecialization$ = 8					; size = 4
?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::LogSpecializationChange, COMDAT
; _this$ = ecx

; 2048 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 224				; 000000e0H
	push	edi
	mov	edi, ecx

; 2049 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@LogSpecial
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN5@LogSpecial

; 2050 : 	{
; 2051 : 		// Find the name of this civ and city
; 2052 : 		CvString playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN28@LogSpecial
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@LogSpecial:
	push	ebp
	push	esi
	push	eax
	lea	ecx, DWORD PTR _playerName$226986[esp+252]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2053 : 		CvString cityName = m_pCity->getName();

	lea	ecx, DWORD PTR _cityName$226987[esp+248]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR __$EHRec$[esp+260], 0
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[esp+256], 1

; 2054 : 
; 2055 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$226987[esp+248]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$226986[esp+252]
	push	eax
	lea	ecx, DWORD PTR $T234736[esp+256]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+256], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234736[esp+248]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+256], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2056 : 
; 2057 : 		// Get the leading info for this line
; 2058 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226991[esp+248]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2059 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+256], 3
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226991[esp+252]
	push	OFFSET $SG226992
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2060 : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226997
	lea	edx, DWORD PTR _playerName$226986[esp+264]
	push	edx
	lea	eax, DWORD PTR $T234737[esp+268]
	push	eax
	call	esi
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	ecx, DWORD PTR _cityName$226987[esp+272]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T234738[esp+280]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+292], 4
	call	ebp
	push	OFFSET $SG226996
	push	eax
	lea	eax, DWORD PTR $T234739[esp+292]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+304], 5
	call	esi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226991[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234739[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234738[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234737[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2061 : 
; 2062 : 		CvString strOutBuf = strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226991[esp+248]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$226998[esp+252]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 2063 : 
; 2064 : 		CvCitySpecializationXMLEntry* pCitySpecializationInfo = GC.getCitySpecializationInfo(eSpecialization);

	mov	edx, DWORD PTR _eSpecialization$[esp+244]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+260], 7
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo

; 2065 : 		if(pCitySpecializationInfo != NULL)

	test	eax, eax
	je	$LN4@LogSpecial

; 2066 : 		{
; 2067 : 			const YieldTypes eYieldType = pCitySpecializationInfo->GetYieldType();

	mov	ecx, eax
	call	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ ; CvCitySpecializationXMLEntry::GetYieldType

; 2068 : 
; 2069 : 			CvString strYieldString = "Unknown";

	push	OFFSET $SG227003
	lea	ecx, DWORD PTR _strYieldString$227002[esp+252]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+256], 8

; 2070 : 			if(eYieldType == NO_YIELD)

	cmp	esi, -1
	jne	SHORT $LN3@LogSpecial

; 2071 : 			{
; 2072 : 				strYieldString = "General Economy";

	push	OFFSET $SG227005

; 2073 : 			}
; 2074 : 			else

	jmp	SHORT $LN76@LogSpecial
$LN3@LogSpecial:

; 2075 : 			{
; 2076 : 				CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYieldType);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo

; 2077 : 				if(pYieldInfo != NULL)

	test	eax, eax
	je	SHORT $LN1@LogSpecial

; 2078 : 				{
; 2079 : 					strYieldString = pYieldInfo->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
$LN76@LogSpecial:
	lea	ecx, DWORD PTR _strYieldString$227002[esp+252]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN1@LogSpecial:

; 2080 : 				}
; 2081 : 			}
; 2082 : 
; 2083 : 			CvString strTemp = "NEW SPECIALIZATION: Yield Type = ";

	push	OFFSET $SG227010
	lea	ecx, DWORD PTR _strTemp$227009[esp+252]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2084 : 			strOutBuf += strTemp + strYieldString;

	lea	eax, DWORD PTR _strYieldString$227002[esp+248]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227009[esp+252]
	push	ecx
	lea	edx, DWORD PTR $T234740[esp+256]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+268], 9
	call	ebp
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226998[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234740[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2085 : 		}

	lea	ecx, DWORD PTR _strTemp$227009[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strYieldString$227002[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@LogSpecial:

; 2086 : 
; 2087 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226998[esp+248]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8

; 2088 : 	}

	lea	ecx, DWORD PTR _strOutBuf$226998[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226991[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _cityName$226987[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$226986[esp+248]
	mov	DWORD PTR __$EHRec$[esp+256], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
$LN5@LogSpecial:

; 2089 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+240]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 236				; 000000ecH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$0:
	lea	ecx, DWORD PTR _playerName$226986[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$1:
	lea	ecx, DWORD PTR _cityName$226987[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$2:
	lea	ecx, DWORD PTR $T234736[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$3:
	lea	ecx, DWORD PTR _strBaseString$226991[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$4:
	lea	ecx, DWORD PTR $T234737[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$5:
	lea	ecx, DWORD PTR $T234738[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$6:
	lea	ecx, DWORD PTR $T234739[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$7:
	lea	ecx, DWORD PTR _strOutBuf$226998[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$8:
	lea	ecx, DWORD PTR _strYieldString$227002[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$9:
	lea	ecx, DWORD PTR _strTemp$227009[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z$10:
	lea	ecx, DWORD PTR $T234740[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::LogSpecializationChange
PUBLIC	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$ = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::GetWeightThresholdModifier, COMDAT

; 2133 : {

	push	ecx

; 2134 : 	int iWeightThresholdModifier = 0;

	xor	eax, eax
	push	esi

; 2135 : 
; 2136 : 	// Look at all Flavors for the Player & this Strategy
; 2137 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	mov	DWORD PTR _iWeightThresholdModifier$[esp+8], eax
	jle	SHORT $LN1@GetWeightT
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _eStrategy$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pCity$[esp+16]
	npad	3
$LL3@GetWeightT:

; 2138 : 	{
; 2139 : 		FlavorTypes eFlavor = (FlavorTypes) iFlavorLoop;
; 2140 : 		int iPersonalityFlavor = GET_PLAYER(pCity->getOwner()).GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 2141 : 		int iStrategyFlavorMod = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy)->GetPersonalityFlavorThresholdMod(eFlavor);

	mov	ecx, edi
	mov	ebx, eax
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+ebp*4]
	mov	eax, DWORD PTR [eax+268]
	test	eax, eax
	je	SHORT $LN22@GetWeightT
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN23@GetWeightT
$LN22@GetWeightT:
	or	eax, -1
$LN23@GetWeightT:

; 2142 : 
; 2143 : 		iWeightThresholdModifier += (iPersonalityFlavor * iStrategyFlavorMod);

	imul	eax, ebx
	add	DWORD PTR _iWeightThresholdModifier$[esp+20], eax
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL3@GetWeightT

; 2144 : 	}
; 2145 : 
; 2146 : 	return iWeightThresholdModifier;

	mov	eax, DWORD PTR _iWeightThresholdModifier$[esp+20]
	pop	edi
	pop	ebp
	pop	ebx
$LN1@GetWeightT:
	pop	esi

; 2147 : }

	pop	ecx
	ret	0
?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::GetWeightThresholdModifier
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers
EXTRN	?getTrainPercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getTrainPercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ:PROC ; CvPlayer::countCitiesFeatureSurrounded
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T234896 = -8						; size = 4
$T234897 = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers, COMDAT

; 2220 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	eax, DWORD PTR _pCity$[esp-4]
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 2221 : #ifdef AUI_CITYSTRATEGY_DONT_EMPHASIZE_WORKERS_IF_NO_MILITARY
; 2222 : 	if (kPlayer.getNumMilitaryUnits() - kPlayer.GetNumUnitsWithUnitAI(UNITAI_EXPLORE) <= 0)
; 2223 : 	{
; 2224 : 		return false;
; 2225 : 	}
; 2226 : #endif
; 2227 : 	int iCurrentNumCities = kPlayer.getNumCities();

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities

; 2228 : 
; 2229 : 	int iLastTurnWorkerDisbanded = kPlayer.GetEconomicAI()->GetLastTurnWorkerDisbanded();

	mov	ecx, esi
	mov	ebx, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edi, DWORD PTR [eax+40]

; 2230 : #ifdef AUI_CITYSTRATEGY_FIX_TILE_IMPROVERS_LAST_DISBAND_WORKER_TURN_SCALE
; 2231 : 	if (iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 25 * GC.getGame().getEstimateEndTurn() / 500)
; 2232 : #else
; 2233 : 	if(iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 25)

	test	edi, edi
	jl	SHORT $LN12@IsTestCity@11
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, edi
	cmp	eax, 25					; 00000019H

; 2234 : #endif
; 2235 : 	{
; 2236 : 		return false;

	jle	SHORT $LN45@IsTestCity@11
$LN12@IsTestCity@11:

; 2237 : 	}
; 2238 : 
; 2239 : 	int iNumWorkers = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	ecx, esi
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2240 : 	// If it's a minor with at least 1 worker per city, always return false
; 2241 : 	if(kPlayer.isMinorCiv())

	mov	ecx, esi
	mov	edi, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN11@IsTestCity@11

; 2242 : 	{
; 2243 : 		if(iNumWorkers >= iCurrentNumCities)

	cmp	edi, ebx
	jl	SHORT $LN7@IsTestCity@11
$LN45@IsTestCity@11:
	pop	edi
	pop	esi

; 2244 : 			return false;

	xor	al, al
	pop	ebx

; 2289 : }

	add	esp, 8
	ret	0
$LN11@IsTestCity@11:

; 2245 : 	}
; 2246 : 	else
; 2247 : 	{
; 2248 : 		int iNumCities = max(1, (iCurrentNumCities * 3) / 4);

	lea	eax, DWORD PTR [ebx+ebx*2]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR $T234896[esp+20], eax
	cmp	eax, 1
	mov	DWORD PTR $T234897[esp+20], 1
	lea	eax, DWORD PTR $T234896[esp+20]
	jg	SHORT $LN28@IsTestCity@11
	lea	eax, DWORD PTR $T234897[esp+20]
$LN28@IsTestCity@11:

; 2249 : 		if(iNumWorkers >= iNumCities)

	cmp	edi, DWORD PTR [eax]

; 2250 : 			return false;

	jge	SHORT $LN45@IsTestCity@11

; 2251 : 		// If we're losing at war, return false
; 2252 : 		if(kPlayer.GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2

; 2253 : 			return false;

	je	SHORT $LN45@IsTestCity@11
$LN7@IsTestCity@11:

; 2254 : 	}
; 2255 : 
; 2256 : 	// If we're under attack from Barbs and have 1 or fewer Cities and no credible defense then training more Workers will only hurt us
; 2257 : 	if(iCurrentNumCities <= 1)

	cmp	ebx, 1
	push	ebp
	jg	SHORT $LN43@IsTestCity@11

; 2258 : 	{
; 2259 : 		CvMilitaryAI* pMilitaryAI =kPlayer.GetMilitaryAI();

	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI

; 2260 : 		MilitaryAIStrategyTypes eStrategyKillBarbs = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_ERADICATE_BARBARIANS");

	push	0
	push	OFFSET $SG227075
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2261 : 		if(eStrategyKillBarbs != NO_MILITARYAISTRATEGY)

	cmp	eax, -1
	je	SHORT $LN43@IsTestCity@11

; 2262 : 		{
; 2263 : 			if(pMilitaryAI->IsUsingStrategy(eStrategyKillBarbs))

	push	eax
	mov	ecx, ebp
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al

; 2264 : 			{
; 2265 : 				return false;

	jne	$LN1@IsTestCity@11
$LN43@IsTestCity@11:

; 2266 : 			}
; 2267 : 		}
; 2268 : 	}
; 2269 : 
; 2270 : 	CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	ecx, DWORD PTR _pCity$[esp+20]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI

; 2271 : 
; 2272 : 	int iModdedNumWorkers = iNumWorkers* /*67*/ pCityStrategy->GetWeightThreshold() / 100;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _eStrategy$[esp+20]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+264]
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH

; 2273 : 	int iModdedNumCities = iCurrentNumCities + kPlayer.countCitiesFeatureSurrounded();

	mov	ecx, esi
	add	edi, edx
	call	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ ; CvPlayer::countCitiesFeatureSurrounded
	add	eax, ebx

; 2274 : 
; 2275 : 	// We have fewer than we think we should, or we have none at all
; 2276 : 	if(iModdedNumWorkers <= iModdedNumCities || iModdedNumWorkers == 0)

	cmp	edi, eax
	jle	SHORT $LN2@IsTestCity@11
	test	edi, edi
	jne	SHORT $LN1@IsTestCity@11
$LN2@IsTestCity@11:

; 2277 : 	{
; 2278 : 		// If we don't have any Workers by turn 30 we really need to get moving
; 2279 : 		int iDesperateTurn = /*30*/ GC.getAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN();
; 2280 : 
; 2281 : 		iDesperateTurn *= GC.getGame().getGameSpeedInfo().getTrainPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2340
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getTrainPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getTrainPercent
	mov	ecx, eax
	imul	ecx, esi

; 2282 : 		iDesperateTurn /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 2283 : 
; 2284 : 		if(GC.getGame().getElapsedGameTurns() > iDesperateTurn)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jle	SHORT $LN1@IsTestCity@11
	pop	ebp
	pop	edi
	pop	esi

; 2285 : 			return true;

	mov	al, 1
	pop	ebx

; 2289 : }

	add	esp, 8
	ret	0
$LN1@IsTestCity@11:
	pop	ebp
	pop	edi
	pop	esi

; 2286 : 	}
; 2287 : 
; 2288 : 	return false;

	xor	al, al
	pop	ebx

; 2289 : }

	add	esp, 8
	ret	0
?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_iNumResources$227103 = -24				; size = 4
_iNumImprovedResources$227104 = -20			; size = 4
_iPlotLoop$227105 = -16					; size = 4
_eResource$227112 = -12					; size = 4
_iPerCityThreshold$227101 = -8				; size = 4
_iNumBuilders$227097 = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers, COMDAT

; 2293 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2294 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	edi, DWORD PTR _pCity$[esp+36]
	mov	ebx, DWORD PTR [edi+84]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2295 : #ifdef AUI_CITYSTRATEGY_DONT_EMPHASIZE_WORKERS_IF_NO_MILITARY
; 2296 : 	if (kPlayer.getNumMilitaryUnits() - kPlayer.GetNumUnitsWithUnitAI(UNITAI_EXPLORE) <= 0)
; 2297 : 	{
; 2298 : 		return false;
; 2299 : 	}
; 2300 : #endif
; 2301 : 	int iLastTurnWorkerDisbanded = kPlayer.GetEconomicAI()->GetLastTurnWorkerDisbanded();

	mov	ecx, ebx
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	esi, DWORD PTR [eax+40]

; 2302 : #ifdef AUI_CITYSTRATEGY_FIX_TILE_IMPROVERS_LAST_DISBAND_WORKER_TURN_SCALE
; 2303 : 	if (iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10 * GC.getGame().getEstimateEndTurn() / 500)
; 2304 : #else
; 2305 : 	if(iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10)

	xor	ebp, ebp
	cmp	esi, ebp
	jl	SHORT $LN26@IsTestCity@12
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, esi
	cmp	eax, 10					; 0000000aH

; 2306 : #endif
; 2307 : 	{
; 2308 : 		return false;

	jle	$LN1@IsTestCity@12
$LN26@IsTestCity@12:

; 2309 : 	}
; 2310 : 
; 2311 : 	if(!GET_PLAYER(pCity->getOwner()).isMinorCiv())

	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN86@IsTestCity@12

; 2312 : 	{
; 2313 : 		// If we're losing at war, return false
; 2314 : 		if(GET_PLAYER(pCity->getOwner()).GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2

; 2315 : 			return false;

	je	$LN1@IsTestCity@12
$LN86@IsTestCity@12:

; 2316 : 	}
; 2317 : 
; 2318 : 	int iNumWorkers = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	ebp
	push	1
	push	2
	mov	ecx, ebx
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2319 : 	if(iNumWorkers >= ((kPlayer.getNumCities() *  3) / 2) + 1)

	mov	ecx, ebx
	mov	esi, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	lea	eax, DWORD PTR [eax+eax*2]
	cdq
	sub	eax, edx
	sar	eax, 1
	inc	eax
	cmp	esi, eax

; 2320 : 		return false;

	jge	$LN1@IsTestCity@12

; 2321 : 
; 2322 : 	// If we're under attack from Barbs and have 1 or fewer cities then training more Workers will only hurt us
; 2323 : 	//if (kPlayer.getNumCities() <= 1)
; 2324 : 	//{
; 2325 : 	//	MilitaryAIStrategyTypes eStrategyKillBarbs = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_ERADICATE_BARBARIANS");
; 2326 : 	//	if (eStrategyKillBarbs != NO_MILITARYAISTRATEGY)
; 2327 : 	//	{
; 2328 : 	//		if (GET_PLAYER(pCity->getOwner()).GetMilitaryAI()->IsUsingStrategy(eStrategyKillBarbs))
; 2329 : 	//			return false;
; 2330 : 	//	}
; 2331 : 	//}
; 2332 : 
; 2333 : 	// Don't get desperate for training a Builder here unless the City is at least of a certain size
; 2334 : 	if(pCity->getPopulation() >= /*2*/ GC.getAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2344
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, esi
	jl	$LN1@IsTestCity@12

; 2335 : 	{
; 2336 : 		int iNumBuilders = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	ebp
	push	1
	push	2
	mov	ecx, ebx
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2337 : 
; 2338 : 		// If we don't even have 1 builder on map or in a queue, turn this on immediately
; 2339 : 		if(iNumBuilders < 1)

	cmp	eax, 1
	mov	DWORD PTR _iNumBuilders$227097[esp+40], eax
	jge	SHORT $LN21@IsTestCity@12
	pop	edi
	pop	esi
	pop	ebp

; 2340 : 		{
; 2341 : 			return true;

	mov	al, 1
	pop	ebx

; 2472 : }

	add	esp, 24					; 00000018H
	ret	0
$LN21@IsTestCity@12:

; 2342 : 		}
; 2343 : 
; 2344 : 		CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	ecx, edi
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _eStrategy$[esp+36]
	mov	esi, DWORD PTR [ecx+eax*4]

; 2345 : 
; 2346 : 		int iWeightThresholdModifier = CityStrategyAIHelpers::GetWeightThresholdModifier(eStrategy, pCity);	// 2 Extra Weight per TILE_IMPROVEMENT Flavor

	push	edi
	push	eax
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier

; 2347 : 		int iPerCityThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 40

	mov	esi, DWORD PTR [esi+264]
	add	esp, 8
	add	esi, eax
	mov	DWORD PTR _iPerCityThreshold$227101[esp+40], esi

; 2348 : 
; 2349 : 		// Look at all Tiles this City could potentially work to see if there are any Water Resources that could be improved
; 2350 : 		CvPlot* pLoopPlot;
; 2351 : 		int iNumResources = 0;

	mov	DWORD PTR _iNumResources$227103[esp+40], ebp

; 2352 : 		int iNumImprovedResources = 0;

	mov	DWORD PTR _iNumImprovedResources$227104[esp+40], ebp

; 2353 : 
; 2354 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$227105[esp+40], ebp
	npad	4
$LL20@IsTestCity@12:

; 2355 : 		{
; 2356 : 			pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+96]
	push	ebp
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 2357 : 
; 2358 : 			if(pLoopPlot != NULL)

	test	ebp, ebp
	je	$LN19@IsTestCity@12

; 2359 : 			{
; 2360 : 				if(pLoopPlot->getOwner() == pCity->getOwner())

	movsx	edx, BYTE PTR [ebp+4]
	cmp	edx, DWORD PTR [edi+84]
	jne	$LN19@IsTestCity@12

; 2361 : 				{
; 2362 : 					if(!pLoopPlot->isWater())

	cmp	BYTE PTR [ebp+5], 3
	je	$LN19@IsTestCity@12

; 2363 : 					{
; 2364 : 						ResourceTypes eResource = pLoopPlot->getResourceType(kPlayer.getTeam());

	mov	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$227112[esp+40], eax

; 2365 : 						if(eResource == NO_RESOURCE)

	cmp	eax, -1
	je	$LN19@IsTestCity@12

; 2366 : 						{
; 2367 : 							continue;
; 2368 : 						}
; 2369 : 
; 2370 : 						// loop through the build types to find one that we can use
; 2371 : 						ImprovementTypes eCorrectImprovement = NO_IMPROVEMENT;
; 2372 : 						BuildTypes eCorrectBuild = NO_BUILD;
; 2373 : #ifdef AUI_WARNING_FIXES
; 2374 : 						for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2375 : #else
; 2376 : 						int iBuildIndex;
; 2377 : 						for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN19@IsTestCity@12
$LL13@IsTestCity@12:

; 2378 : #endif
; 2379 : 						{
; 2380 : 							const BuildTypes eBuild = static_cast<BuildTypes>(iBuildIndex);
; 2381 : 							CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 2382 : 							if(pkBuildInfo)

	test	eax, eax
	je	SHORT $LN12@IsTestCity@12

; 2383 : 							{
; 2384 : 								const ImprovementTypes eImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	edi, eax

; 2385 : 
; 2386 : 								// if this is the improvement we're looking for
; 2387 : 								if(eImprovement != NO_IMPROVEMENT)

	cmp	edi, -1
	je	SHORT $LN82@IsTestCity@12

; 2388 : 								{
; 2389 : 									CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 2390 : 									if(pkImprovementInfo)

	test	eax, eax
	je	SHORT $LN82@IsTestCity@12

; 2391 : 									{
; 2392 : 										if(pkImprovementInfo->IsImprovementResourceTrade(eResource))

	mov	ecx, DWORD PTR _eResource$227112[esp+40]
	push	ecx
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	jne	SHORT $LN79@IsTestCity@12
$LN82@IsTestCity@12:
	mov	edi, DWORD PTR _pCity$[esp+36]
$LN12@IsTestCity@12:

; 2366 : 						{
; 2367 : 							continue;
; 2368 : 						}
; 2369 : 
; 2370 : 						// loop through the build types to find one that we can use
; 2371 : 						ImprovementTypes eCorrectImprovement = NO_IMPROVEMENT;
; 2372 : 						BuildTypes eCorrectBuild = NO_BUILD;
; 2373 : #ifdef AUI_WARNING_FIXES
; 2374 : 						for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2375 : #else
; 2376 : 						int iBuildIndex;
; 2377 : 						for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL13@IsTestCity@12

; 2391 : 									{
; 2392 : 										if(pkImprovementInfo->IsImprovementResourceTrade(eResource))

	jmp	SHORT $LN19@IsTestCity@12
$LN79@IsTestCity@12:

; 2393 : 										{
; 2394 : 											eCorrectBuild = eBuild;
; 2395 : 											eCorrectImprovement = eImprovement;
; 2396 : 											break;
; 2397 : 										}
; 2398 : 									}
; 2399 : 								}
; 2400 : 							}
; 2401 : 
; 2402 : 						}
; 2403 : 
; 2404 : 						// no valid build found
; 2405 : 						if(eCorrectBuild == NO_BUILD || eCorrectImprovement == NO_IMPROVEMENT)

	cmp	esi, -1
	je	SHORT $LN83@IsTestCity@12

; 2406 : 						{
; 2407 : 							continue;
; 2408 : 						}
; 2409 : 
; 2410 : 
; 2411 : 						// if we can't build the improvement for the resource, continue!
; 2412 : 						if(!kPlayer.canBuild(pLoopPlot, eCorrectBuild, false, false))

	push	1
	push	1
	push	0
	push	0
	push	esi
	push	ebp
	mov	ecx, ebx
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	test	al, al
	jne	SHORT $LN4@IsTestCity@12

; 2413 : 						{
; 2414 : 							if(pLoopPlot->getImprovementType() == eCorrectImprovement)

	mov	ecx, ebp
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, edi
	jne	SHORT $LN83@IsTestCity@12

; 2415 : 							{
; 2416 : 								iNumImprovedResources++;

	mov	eax, 1
	add	DWORD PTR _iNumImprovedResources$227104[esp+40], eax

; 2417 : 								iNumResources++;

	add	DWORD PTR _iNumResources$227103[esp+40], eax

; 2418 : 							}
; 2419 : 
; 2420 : 							continue;

	jmp	SHORT $LN83@IsTestCity@12
$LN4@IsTestCity@12:

; 2421 : 						}
; 2422 : 
; 2423 : 						iNumResources++;

	inc	DWORD PTR _iNumResources$227103[esp+40]
$LN83@IsTestCity@12:

; 2418 : 							}
; 2419 : 
; 2420 : 							continue;

	mov	edi, DWORD PTR _pCity$[esp+36]
$LN19@IsTestCity@12:

; 2353 : 
; 2354 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	ebp, DWORD PTR _iPlotLoop$227105[esp+40]
	inc	ebp
	cmp	ebp, 37					; 00000025H
	mov	DWORD PTR _iPlotLoop$227105[esp+40], ebp
	jl	$LL20@IsTestCity@12

; 2424 : 					}
; 2425 : 				}
; 2426 : 			}
; 2427 : 		}
; 2428 : 
; 2429 : 		bool bManyUnimproveResources = (2 * (iNumResources - iNumImprovedResources)) > iNumResources;
; 2430 : 		int iMultiplier = kPlayer.getNumCities();

	mov	ecx, ebx
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities

; 2431 : 		iMultiplier += kPlayer.countCitiesFeatureSurrounded();

	mov	ecx, ebx
	mov	esi, eax
	call	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ ; CvPlayer::countCitiesFeatureSurrounded
	add	esi, eax

; 2432 : 		if(bManyUnimproveResources)

	mov	eax, DWORD PTR _iNumResources$227103[esp+40]
	mov	edx, eax
	sub	edx, DWORD PTR _iNumImprovedResources$227104[esp+40]
	add	edx, edx
	cmp	edx, eax
	jle	SHORT $LN85@IsTestCity@12

; 2433 : 			iMultiplier += 1;

	inc	esi
$LN85@IsTestCity@12:

; 2434 : 
; 2435 : 		int iNumSettlers = kPlayer.GetNumUnitsWithUnitAI(UNITAI_SETTLE, true, false);

	push	0
	push	1
	push	1
	mov	ecx, ebx
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	ecx, eax

; 2436 : 		iMultiplier += iNumSettlers;
; 2437 : 
; 2438 : 		int iWeightThreshold = (iPerCityThreshold * iMultiplier);
; 2439 : 
; 2440 : 		//Do we want more Builders?
; 2441 : 		if((iNumBuilders * 100) < iWeightThreshold)

	mov	eax, DWORD PTR _iNumBuilders$227097[esp+40]
	add	ecx, esi
	imul	eax, 100				; 00000064H
	imul	ecx, DWORD PTR _iPerCityThreshold$227101[esp+40]
	cmp	eax, ecx
	jge	SHORT $LN1@IsTestCity@12

; 2442 : 		{
; 2443 : 			// slewis - need to check to see if training another worker will put us below the -10 threshold.
; 2444 : 			// slewis - todo: move -10 to a xml value
; 2445 : 			return (kPlayer.calculateGoldRate() > -10);

	mov	ecx, ebx
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	pop	edi
	xor	edx, edx
	cmp	eax, -10				; fffffff6H
	pop	esi
	setg	dl
	pop	ebp
	mov	al, dl
	pop	ebx

; 2472 : }

	add	esp, 24					; 00000018H
	ret	0
$LN1@IsTestCity@12:
	pop	edi
	pop	esi
	pop	ebp

; 2446 : 
; 2447 : 			// Also want to check and see if we have enough happiness to support another builder
; 2448 : 			//int iBuilderUnhappiness = 0;
; 2449 : 			//int iBuildersInGame = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, false, false);
; 2450 : 			//if (iBuildersInGame > 0)
; 2451 : 			//{
; 2452 : 			//	CvUnit *pLoopUnit;
; 2453 : 			//	int iLoop;
; 2454 : 			//	for (pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))
; 2455 : 			//	{
; 2456 : 			//		if (pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)
; 2457 : 			//		{
; 2458 : 			//			break;
; 2459 : 			//		}
; 2460 : 			//	}
; 2461 : 			//	if (pLoopUnit)
; 2462 : 			//	{
; 2463 : 			//		iBuilderUnhappiness = pLoopUnit->getUnitInfo().GetUnhappiness();
; 2464 : 			//	}
; 2465 : 			//}
; 2466 : 
; 2467 : 			//return (kPlayer.GetExcessHappiness()) >= (iNumBuilders - iBuildersInGame + 1) * iBuilderUnhappiness;
; 2468 : 		}
; 2469 : 	}
; 2470 : 
; 2471 : 	return false;

	xor	al, al
	pop	ebx

; 2472 : }

	add	esp, 24					; 00000018H
	ret	0
?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
tv228 = 12						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers, COMDAT

; 2476 : {

	push	ebx

; 2477 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	ebx, DWORD PTR _pCity$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 2478 : #ifdef AUI_CITYSTRATEGY_DONT_EMPHASIZE_WORKERS_IF_NO_MILITARY
; 2479 : 	if (kPlayer.getNumMilitaryUnits() - kPlayer.GetNumUnitsWithUnitAI(UNITAI_EXPLORE) <= 0)
; 2480 : 	{
; 2481 : 		return true;
; 2482 : 	}
; 2483 : #endif
; 2484 : 	int iLastTurnWorkerDisbanded = kPlayer.GetEconomicAI()->GetLastTurnWorkerDisbanded();

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edi, DWORD PTR [eax+40]

; 2485 : #ifdef AUI_CITYSTRATEGY_FIX_TILE_IMPROVERS_LAST_DISBAND_WORKER_TURN_SCALE
; 2486 : 	if (iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10 * GC.getGame().getEstimateEndTurn() / 500)
; 2487 : #else
; 2488 : 	if(iLastTurnWorkerDisbanded >= 0 && GC.getGame().getGameTurn() - iLastTurnWorkerDisbanded <= 10)

	test	edi, edi
	jl	SHORT $LN6@IsTestCity@13
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, edi
	cmp	eax, 10					; 0000000aH
	jg	SHORT $LN6@IsTestCity@13
$LN35@IsTestCity@13:
	pop	edi
	pop	esi

; 2489 : #endif
; 2490 : 	{
; 2491 : 		return true;

	mov	al, 1
	pop	ebx

; 2525 : 	{
; 2526 : 		return true;
; 2527 : 	}
; 2528 : 
; 2529 : 	return false;
; 2530 : }

	ret	0
$LN6@IsTestCity@13:

; 2492 : 	}
; 2493 : 
; 2494 : 	AICityStrategyTypes eNeedImproversStrategy = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_TILE_IMPROVERS");

	push	0
	push	OFFSET $SG227149
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2495 : 
; 2496 : #ifdef AUI_WARNING_FIXES
; 2497 : 	if (eNeedImproversStrategy != NO_AICITYSTRATEGY)
; 2498 : #else
; 2499 : 	if(eNeedImproversStrategy != NO_ECONOMICAISTRATEGY)

	cmp	edi, -1
	je	SHORT $LN4@IsTestCity@13

; 2500 : #endif
; 2501 : 	{
; 2502 : 		if(pCity->GetCityStrategyAI()->IsUsingCityStrategy(eNeedImproversStrategy))

	mov	ecx, ebx
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	eax, DWORD PTR [eax+28]
	cmp	BYTE PTR [edi+eax], 0
	je	SHORT $LN4@IsTestCity@13
	pop	edi
	pop	esi

; 2503 : 			return false;

	xor	al, al
	pop	ebx

; 2525 : 	{
; 2526 : 		return true;
; 2527 : 	}
; 2528 : 
; 2529 : 	return false;
; 2530 : }

	ret	0
$LN4@IsTestCity@13:

; 2504 : 	}
; 2505 : 
; 2506 : 	int iNumBuilders = kPlayer.GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	ecx, esi
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2507 : 
; 2508 : 	// If it's a minor with at least 1 worker per city, always return true
; 2509 : 	if(GET_PLAYER(pCity->getOwner()).isMinorCiv())

	mov	ecx, DWORD PTR [ebx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN2@IsTestCity@13

; 2510 : 	{
; 2511 : 		if(iNumBuilders >= kPlayer.getNumCities())

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	edi, eax

; 2512 : 			return true;

	jge	SHORT $LN35@IsTestCity@13
$LN2@IsTestCity@13:
	push	ebp

; 2513 : 	}
; 2514 : 
; 2515 : 	CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	ecx, ebx
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _eStrategy$[esp+12]
	mov	edx, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [edx+eax*4]

; 2516 : 
; 2517 : 	int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pCity);	// 10 Extra Weight per TILE_IMPROVEMENT Flavor

	push	ebx
	push	eax
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier

; 2518 : 	int iPerCityThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 100

	mov	ebp, DWORD PTR [ebp+264]
	add	esp, 8

; 2519 : 
; 2520 : 	int iModdedNumCities = kPlayer.getNumCities() + kPlayer.countCitiesFeatureSurrounded();

	mov	ecx, esi
	mov	ebx, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	ecx, esi
	mov	DWORD PTR tv228[esp+12], eax
	call	?countCitiesFeatureSurrounded@CvPlayer@@QBEHXZ ; CvPlayer::countCitiesFeatureSurrounded

; 2521 : 	int iWeightThreshold = (iPerCityThreshold * iModdedNumCities);
; 2522 : 
; 2523 : 	// Average Player wants no more than 1.50 Builders per City [150 Weight is Average; range is 100 to 200]
; 2524 : 	if((iNumBuilders * 100) >= iWeightThreshold)

	imul	edi, 100				; 00000064H
	mov	ecx, DWORD PTR tv228[esp+12]
	add	ebp, ebx
	add	ecx, eax
	imul	ecx, ebp
	pop	ebp
	cmp	edi, ecx
	pop	edi
	pop	esi
	setge	al
	pop	ebx

; 2525 : 	{
; 2526 : 		return true;
; 2527 : 	}
; 2528 : 
; 2529 : 	return false;
; 2530 : }

	ret	0
?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_iNumOceanPlots$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth, COMDAT

; 2534 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 2535 : 	int iNumOceanPlots = 0;

	xor	ebp, ebp
	push	edi

; 2536 : 	int iNumTotalWorkablePlots = 0;
; 2537 : 
; 2538 : 	CvPlot* pLoopPlot;
; 2539 : 
; 2540 : 	// Look at all Tiles this City could potentially work
; 2541 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	edi, DWORD PTR _pCity$[esp+16]
	mov	DWORD PTR _iNumOceanPlots$[esp+20], ebp
	xor	ebx, ebx
$LL9@IsTestCity@14:

; 2542 : 	{
; 2543 : 		pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+96]
	push	ebp
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2544 : 
; 2545 : 		if(pLoopPlot != NULL)

	test	esi, esi
	je	SHORT $LN8@IsTestCity@14

; 2546 : 		{
; 2547 : 			if(pLoopPlot->getOwner() == pCity->getOwner())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, DWORD PTR [edi+84]
	jne	SHORT $LN8@IsTestCity@14

; 2548 : 			{
; 2549 : 				if(!pLoopPlot->isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN43@IsTestCity@14
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN43@IsTestCity@14
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN8@IsTestCity@14
$LN43@IsTestCity@14:

; 2550 : 				{
; 2551 : 					iNumTotalWorkablePlots++;

	inc	ebx

; 2552 : 
; 2553 : 					if(pLoopPlot->isWater() && !pLoopPlot->isLake())

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN8@IsTestCity@14
	mov	ecx, esi
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	test	al, al
	jne	SHORT $LN8@IsTestCity@14

; 2554 : 					{
; 2555 : 						iNumOceanPlots++;;

	inc	DWORD PTR _iNumOceanPlots$[esp+20]
$LN8@IsTestCity@14:

; 2536 : 	int iNumTotalWorkablePlots = 0;
; 2537 : 
; 2538 : 	CvPlot* pLoopPlot;
; 2539 : 
; 2540 : 	// Look at all Tiles this City could potentially work
; 2541 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	inc	ebp
	cmp	ebp, 37					; 00000025H
	jl	SHORT $LL9@IsTestCity@14

; 2556 : 					}
; 2557 : 				}
; 2558 : 			}
; 2559 : 		}
; 2560 : 	}
; 2561 : 
; 2562 : 	if(iNumTotalWorkablePlots > 0)

	test	ebx, ebx
	jle	SHORT $LN1@IsTestCity@14

; 2563 : 	{
; 2564 : 		CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	ecx, edi
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _eStrategy$[esp+16]
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]

; 2565 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pCity);	// -1 Weight per NAVAL_GROWTH Flavor

	push	edi
	push	eax
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier

; 2566 : 		int iWeightThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 40

	mov	ecx, DWORD PTR [esi+264]
	add	ecx, eax

; 2567 : 
; 2568 : 		// If at least 35% (Average Player) of a City's workable Tiles are low-food Water then we really should be building a Harbor
; 2569 : 		// [35 Weight is Average; range is 30 to 40]
; 2570 : 		if((iNumOceanPlots * 100) / iNumTotalWorkablePlots >= iWeightThreshold)

	mov	eax, DWORD PTR _iNumOceanPlots$[esp+28]
	imul	eax, 100				; 00000064H
	cdq
	idiv	ebx
	add	esp, 8
	cmp	eax, ecx
	jl	SHORT $LN1@IsTestCity@14
	pop	edi
	pop	esi
	pop	ebp

; 2571 : 		{
; 2572 : 			return true;

	mov	al, 1
	pop	ebx

; 2577 : }

	pop	ecx
	ret	0
$LN1@IsTestCity@14:
	pop	edi
	pop	esi
	pop	ebp

; 2573 : 		}
; 2574 : 	}
; 2575 : 
; 2576 : 	return false;

	xor	al, al
	pop	ebx

; 2577 : }

	pop	ecx
	ret	0
?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement
EXTRN	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z:PROC ; CvCityCitizens::IsCanWork
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement, COMDAT

; 2581 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 2582 : 	int iNumUnimprovedWaterResources = 0;
; 2583 : 
; 2584 : 	CvPlot* pLoopPlot;
; 2585 : 
; 2586 : 	// Look at all Tiles this City could potentially work to see if there are any Water Resources that could be improved
; 2587 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	edi, DWORD PTR _pCity$[esp+12]
	xor	ebx, ebx
	xor	ebp, ebp
	npad	4
$LL9@IsTestCity@15:

; 2588 : 	{
; 2589 : 		pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+96]
	push	ebp
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2590 : 
; 2591 : 		if(pLoopPlot != NULL)

	test	esi, esi
	je	SHORT $LN8@IsTestCity@15

; 2592 : 		{
; 2593 : 			if(pLoopPlot->getOwner() == pCity->getOwner())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, DWORD PTR [edi+84]
	jne	SHORT $LN8@IsTestCity@15

; 2594 : 			{
; 2595 : 				if(pLoopPlot->isWater())

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN8@IsTestCity@15

; 2596 : 				{
; 2597 : 					// Only look at Tiles THIS City can use; Prevents issue where two Cities can look at the same tile the same turn and both want Workboats for it; By the time this Strategy is called for a City another City isn't guaranteed to have popped it's previous order and registered that it's now training a Workboat! :(
; 2598 : 					if(pCity->GetCityCitizens()->IsCanWork(pLoopPlot))

	push	esi
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	je	SHORT $LN8@IsTestCity@15

; 2599 : 					{
; 2600 : 						// Does this Tile already have a Resource, and if so, is it already improved?
; 2601 : 						if(pLoopPlot->getResourceType() != NO_RESOURCE && pLoopPlot->getImprovementType() == NO_IMPROVEMENT)

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN8@IsTestCity@15
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN8@IsTestCity@15

; 2602 : 						{
; 2603 : 							iNumUnimprovedWaterResources++;

	inc	ebx
$LN8@IsTestCity@15:

; 2582 : 	int iNumUnimprovedWaterResources = 0;
; 2583 : 
; 2584 : 	CvPlot* pLoopPlot;
; 2585 : 
; 2586 : 	// Look at all Tiles this City could potentially work to see if there are any Water Resources that could be improved
; 2587 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	inc	ebp
	cmp	ebp, 37					; 00000025H
	jl	SHORT $LL9@IsTestCity@15

; 2604 : 						}
; 2605 : 					}
; 2606 : 				}
; 2607 : 			}
; 2608 : 		}
; 2609 : 	}
; 2610 : 
; 2611 : 	int iNumWaterTileImprovers = GET_PLAYER(pCity->getOwner()).GetNumUnitsWithUnitAI(UNITAI_WORKER_SEA, true, true);

	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	1
	push	17					; 00000011H
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	pop	edi
	pop	esi

; 2612 : 
; 2613 : 	// Are there more Water Resources we can build an Improvement on than we have Naval Tile Improvers?
; 2614 : 	if(iNumUnimprovedWaterResources > iNumWaterTileImprovers)

	cmp	ebx, eax
	pop	ebp
	setg	al
	pop	ebx

; 2615 : 	{
; 2616 : 		return true;
; 2617 : 	}
; 2618 : 
; 2619 : 	return false;
; 2620 : }

	ret	0
?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_pCity$ = 12						; size = 4
?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler, COMDAT

; 2666 : {

	push	ebx

; 2667 : 	if(pCity->isCapital())

	mov	ebx, DWORD PTR _pCity$[esp]
	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	$LN4@IsTestCity@16

; 2668 : 	{
; 2669 : 		CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	esi, DWORD PTR [ebx+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2670 : 
; 2671 : 		if(!kPlayer.isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN4@IsTestCity@16

; 2672 : 		{
; 2673 : 			int iNumCities = kPlayer.getNumCities();

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities

; 2674 : 			int iSettlersOnMapOrBuild = kPlayer.GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, esi
	mov	ebp, eax
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	edi, eax

; 2675 : 			int iCitiesPlusSettlers = iNumCities + iSettlersOnMapOrBuild;

	add	edi, ebp

; 2676 : 
; 2677 : 			if((iCitiesPlusSettlers) < 3)

	cmp	edi, 3
	jge	$LN4@IsTestCity@16

; 2678 : 			{
; 2679 : 
; 2680 : 				AICityStrategyTypes eUnderThreat = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_CAPITAL_UNDER_THREAT");

	push	0
	push	OFFSET $SG227227
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebp, eax

; 2681 : 				if(eUnderThreat != NO_AICITYSTRATEGY)

	cmp	ebp, -1
	je	SHORT $LN6@IsTestCity@16

; 2682 : 				{
; 2683 : 					if(GC.getGame().getGameTurn() > 50 && pCity->GetCityStrategyAI()->IsUsingCityStrategy(eUnderThreat))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN6@IsTestCity@16
	mov	ecx, ebx
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	eax, DWORD PTR [eax+28]
	cmp	BYTE PTR [eax+ebp], 0

; 2684 : 					{
; 2685 : 						return false;

	jne	SHORT $LN4@IsTestCity@16
$LN6@IsTestCity@16:

; 2686 : 					}
; 2687 : 				}
; 2688 : 
; 2689 : 				MilitaryAIStrategyTypes eMilStrategy = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_WAR_MOBILIZATION");

	push	0
	push	OFFSET $SG227232
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2690 : 				if(eMilStrategy != NO_MILITARYAISTRATEGY && kPlayer.GetMilitaryAI()->IsUsingStrategy(eMilStrategy))

	cmp	eax, -1
	je	SHORT $LN5@IsTestCity@16
	push	eax
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al

; 2691 : 				{
; 2692 : 					// this is very risky, if this war fails, the civ lost the entire game as they have no backup plan
; 2693 : 					return false;

	jne	SHORT $LN4@IsTestCity@16
$LN5@IsTestCity@16:

; 2694 : 				}
; 2695 : 
; 2696 : 				CvAICityStrategyEntry* pCityStrategy = pCity->GetCityStrategyAI()->GetAICityStrategies()->GetEntry(eStrategy);

	mov	ecx, ebx
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _eStrategy$[esp+12]
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+eax*4]

; 2697 : 				int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pCity);	// -10 per EXPANSION, +2 per DEFENSE

	push	ebx
	push	eax
	call	?GetWeightThresholdModifier@CityStrategyAIHelpers@@YAHW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::GetWeightThresholdModifier

; 2698 : 				int iWeightThreshold = pCityStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 130

	mov	esi, DWORD PTR [esi+264]

; 2699 : 
; 2700 : 				int iGameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 8
	add	esi, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2701 : 				if((iCitiesPlusSettlers == 1 && (iGameTurn * 4) > iWeightThreshold) ||
; 2702 : 					(iCitiesPlusSettlers == 2 && (iGameTurn * 2) > iWeightThreshold) || 
; 2703 : 					(iCitiesPlusSettlers == 3 && iGameTurn > iWeightThreshold) )

	cmp	edi, 1
	jne	SHORT $LN2@IsTestCity@16
	add	eax, eax
	add	eax, eax
	cmp	eax, esi
	jg	SHORT $LN3@IsTestCity@16
$LN4@IsTestCity@16:
	pop	edi
	pop	esi
	pop	ebp

; 2706 : 				}
; 2707 : 			}
; 2708 : 		}
; 2709 : 	}
; 2710 : 
; 2711 : 	return false;

	xor	al, al
	pop	ebx

; 2712 : }

	ret	0
$LN2@IsTestCity@16:

; 2701 : 				if((iCitiesPlusSettlers == 1 && (iGameTurn * 4) > iWeightThreshold) ||
; 2702 : 					(iCitiesPlusSettlers == 2 && (iGameTurn * 2) > iWeightThreshold) || 
; 2703 : 					(iCitiesPlusSettlers == 3 && iGameTurn > iWeightThreshold) )

	cmp	edi, 2
	jne	SHORT $LN4@IsTestCity@16
	lea	ecx, DWORD PTR [eax+eax]
	cmp	ecx, esi
	jle	SHORT $LN4@IsTestCity@16
$LN3@IsTestCity@16:
	pop	edi
	pop	esi
	pop	ebp

; 2704 : 				{
; 2705 : 					return true;

	mov	al, 1
	pop	ebx

; 2712 : }

	ret	0
?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
EXTRN	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z:PROC ; CvMilitaryAI::GetMostThreatenedCity
EXTRN	?getAtWarCount@CvTeam@@QBEH_N@Z:PROC		; CvTeam::getAtWarCount
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat, COMDAT

; 2716 : {

	push	esi
	push	edi

; 2717 : 	if (pCity->isCapital())

	mov	edi, DWORD PTR _pCity$[esp+4]
	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN1@IsTestCity@17

; 2718 : 	{
; 2719 : 		CvPlayer &kPlayer = GET_PLAYER(pCity->getOwner());

	mov	esi, DWORD PTR [edi+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2720 : 
; 2721 : 		bool bAtPeace = GET_TEAM(kPlayer.getTeam()).getAtWarCount(false) == 0;

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@IsTestCity@17
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN17@IsTestCity@17
$LN16@IsTestCity@17:
	or	eax, -1
$LN17@IsTestCity@17:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	mov	ecx, eax
	call	?getAtWarCount@CvTeam@@QBEH_N@Z		; CvTeam::getAtWarCount
	test	eax, eax

; 2722 : 
; 2723 : 		if (!bAtPeace && !kPlayer.isMinorCiv())

	je	SHORT $LN1@IsTestCity@17
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN1@IsTestCity@17

; 2724 : 		{
; 2725 : 			CvCity *pMostThreatened = kPlayer.GetMilitaryAI()->GetMostThreatenedCity();

	push	0
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity

; 2726 : 			if (pMostThreatened == pCity && pMostThreatened->getThreatValue() > 200)

	cmp	eax, edi
	jne	SHORT $LN1@IsTestCity@17
	mov	ecx, eax
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	cmp	eax, 200				; 000000c8H
	jle	SHORT $LN1@IsTestCity@17
	pop	edi

; 2727 : 			{
; 2728 : 				return true;

	mov	al, 1
	pop	esi

; 2734 : }

	ret	0
$LN1@IsTestCity@17:
	pop	edi

; 2729 : 			}
; 2730 : 		}
; 2731 : 	}
; 2732 : 
; 2733 : 	return false;

	xor	al, al
	pop	esi

; 2734 : }

	ret	0
?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding
EXTRN	?HasCreatedPantheon@CvPlayerReligions@@QBE_NXZ:PROC ; CvPlayerReligions::HasCreatedPantheon
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
EXTRN	?GetFaithPerTurnFromBuildings@CvCity@@QBEHXZ:PROC ; CvCity::GetFaithPerTurnFromBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding, COMDAT

; 2798 : {

	push	ebx
	push	esi
	push	edi

; 2799 : 	CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());

	mov	edi, DWORD PTR _pCity$[esp+8]
	mov	esi, DWORD PTR [edi+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2800 : 	FlavorTypes eFlavor = (FlavorTypes)GC.getInfoTypeForString("FLAVOR_RELIGION");

	push	0
	push	OFFSET $SG227278
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2801 : 
; 2802 : 	int iReligionFlavor = kPlayer.GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	push	eax
	mov	ecx, esi
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 2803 : 
; 2804 : 	if(pCity->GetFaithPerTurnFromBuildings() > 0)

	mov	ecx, edi
	mov	ebx, eax
	call	?GetFaithPerTurnFromBuildings@CvCity@@QBEHXZ ; CvCity::GetFaithPerTurnFromBuildings
	test	eax, eax

; 2805 : 	{
; 2806 : 		return false;

	jg	SHORT $LN3@IsTestCity@18

; 2807 : 	}
; 2808 : 
; 2809 : 	// Need population of 2 before worrying about this
; 2810 : 	if(pCity->getPopulation() < 2)

	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 2

; 2811 : 	{
; 2812 : 		return false;

	jl	SHORT $LN3@IsTestCity@18

; 2813 : 	}
; 2814 : 
; 2815 : 	// Turn on if high religion flavor (doesn't need to be as high if already has a pantheon)
; 2816 : 	if((iReligionFlavor > 4 && kPlayer.GetReligions()->HasCreatedPantheon()) || iReligionFlavor > 6)

	cmp	ebx, 4
	jle	SHORT $LN1@IsTestCity@18
	mov	ecx, esi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasCreatedPantheon@CvPlayerReligions@@QBE_NXZ ; CvPlayerReligions::HasCreatedPantheon
	test	al, al
	jne	SHORT $LN2@IsTestCity@18
$LN1@IsTestCity@18:
	cmp	ebx, 6
	jle	SHORT $LN3@IsTestCity@18
$LN2@IsTestCity@18:
	pop	edi
	pop	esi

; 2817 : 	{
; 2818 : 		return true;

	mov	al, 1
	pop	ebx

; 2822 : }

	ret	0
$LN3@IsTestCity@18:
	pop	edi
	pop	esi

; 2819 : 	}
; 2820 : 
; 2821 : 	return false;

	xor	al, al
	pop	ebx

; 2822 : }

	ret	0
?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pPlot$ = -12						; size = 4
_iNumHills$ = -8					; size = 4
tv195 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity, COMDAT

; 2882 : {

	sub	esp, 12					; 0000000cH

; 2886 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _iNumHills$[esp+28], 0
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, eax

; 2887 : 
; 2888 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2889 : 	int iMaxDX, iDX;
; 2890 : 	CvPlot* pLoopPlot;
; 2891 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 2892 : 	{
; 2893 : 		iMaxDX = iRange - MAX(0, iDY);
; 2894 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2895 : 		{
; 2896 : 			// No need for range check because loops are set up properly
; 2897 : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 2898 : #else
; 2899 : 	for(int iDX = -iRange; iDX <= iRange; iDX++)

	mov	edi, -2					; fffffffeH
	mov	DWORD PTR _pPlot$[esp+28], edx
	lea	ebx, DWORD PTR [edi+4]
	jmp	SHORT $LN9@IsTestCity@19
$LL42@IsTestCity@19:

; 2883 : 	// scan the nearby tiles to see if there are at least two hills in the vicinity
; 2884 : 	const int iRange = 2;
; 2885 : 	int iNumHills = 0;

	mov	edx, DWORD PTR _pPlot$[esp+28]
$LN9@IsTestCity@19:

; 2902 : 		{
; 2903 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	esi, -2					; fffffffeH
	lea	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR tv195[esp+28], eax
	jmp	SHORT $LN6@IsTestCity@19
$LL46@IsTestCity@19:

; 2900 : 	{
; 2901 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	mov	edx, DWORD PTR _pPlot$[esp+28]
$LN6@IsTestCity@19:

; 2902 : 		{
; 2903 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv195[esp+28], ecx
	mov	ecx, edi
	jne	SHORT $LN18@IsTestCity@19
	test	ebx, ebx
	jle	SHORT $LN22@IsTestCity@19
	mov	ecx, ebx
$LN22@IsTestCity@19:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN24@IsTestCity@19
	mov	eax, ebp
$LN24@IsTestCity@19:
	add	eax, ecx
	jmp	SHORT $LN29@IsTestCity@19
$LN18@IsTestCity@19:
	test	ebx, ebx
	jle	SHORT $LN26@IsTestCity@19
	mov	ecx, ebx
$LN26@IsTestCity@19:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN28@IsTestCity@19
	mov	eax, ebp
$LN28@IsTestCity@19:
	cmp	ecx, eax
	jl	SHORT $LN29@IsTestCity@19
	mov	eax, ecx
$LN29@IsTestCity@19:
	cmp	eax, 2
	jg	SHORT $LN5@IsTestCity@19
	movsx	eax, WORD PTR [edx+2]
	movsx	ecx, WORD PTR [edx]
	push	esi
	push	edi
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 2904 : #endif
; 2905 : 			if(pLoopPlot)

	test	eax, eax
	je	SHORT $LN5@IsTestCity@19

; 2906 : 			{
; 2907 : 				if(pLoopPlot->isHills() && pLoopPlot->getOwner() == pPlot->getOwner())

	cmp	BYTE PTR [eax+5], 1
	jne	SHORT $LN5@IsTestCity@19
	mov	dl, BYTE PTR [eax+4]
	mov	eax, DWORD PTR _pPlot$[esp+28]
	cmp	dl, BYTE PTR [eax+4]
	jne	SHORT $LN5@IsTestCity@19

; 2908 : 				{
; 2909 : 					iNumHills++;

	mov	eax, DWORD PTR _iNumHills$[esp+28]
	inc	eax

; 2910 : 					if(iNumHills > 1)

	cmp	eax, 1
	mov	DWORD PTR _iNumHills$[esp+28], eax
	jg	SHORT $LN39@IsTestCity@19
$LN5@IsTestCity@19:

; 2900 : 	{
; 2901 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	dec	ebp
	inc	esi
	cmp	ebp, -2					; fffffffeH
	jge	SHORT $LL46@IsTestCity@19
	dec	ebx
	inc	edi
	cmp	ebx, -2					; fffffffeH
	jge	$LL42@IsTestCity@19
	pop	edi
	pop	esi
	pop	ebp

; 2913 : 					}
; 2914 : 				}
; 2915 : 			}
; 2916 : 		}
; 2917 : 	}
; 2918 : 
; 2919 : 	return false;

	xor	al, al
	pop	ebx

; 2920 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN39@IsTestCity@19:
	pop	edi
	pop	esi
	pop	ebp

; 2911 : 					{
; 2912 : 						return true;

	mov	al, 1
	pop	ebx

; 2920 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity, COMDAT

; 2925 : 	// scan the nearby tiles to see if there is a mountain close enough to build an observatory
; 2926 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	ebx
	push	esi
	push	edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 2927 : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)

	movsx	edi, WORD PTR [eax+2]
	movsx	ebx, WORD PTR [eax]
	xor	esi, esi
$LL5@IsTestCity@20:

; 2928 : 	{
; 2929 : 		CvPlot* pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 2930 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@IsTestCity@20

; 2931 : 		{
; 2932 : 			if(pAdjacentPlot->isMountain())

	cmp	BYTE PTR [eax+5], 0
	je	SHORT $LN15@IsTestCity@20
$LN4@IsTestCity@20:

; 2927 : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@IsTestCity@20
	pop	edi
	pop	esi

; 2935 : 			}
; 2936 : 		}
; 2937 : 	}
; 2938 : 
; 2939 : 
; 2940 : 	return false;

	xor	al, al
	pop	ebx

; 2941 : }

	ret	0
$LN15@IsTestCity@20:
	pop	edi
	pop	esi

; 2933 : 			{
; 2934 : 				return true;

	mov	al, 1
	pop	ebx

; 2941 : }

	ret	0
?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pPlot$ = -12						; size = 4
_iNumForests$ = -8					; size = 4
tv163 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity, COMDAT

; 2945 : {

	sub	esp, 12					; 0000000cH

; 2949 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _iNumForests$[esp+28], 0
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, eax

; 2950 : 
; 2951 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2952 : 	int iMaxDX, iDX;
; 2953 : 	CvPlot* pLoopPlot;
; 2954 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 2955 : 	{
; 2956 : 		iMaxDX = iRange - MAX(0, iDY);
; 2957 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2958 : 		{
; 2959 : 			// No need for range check because loops are set up properly
; 2960 : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 2961 : #else
; 2962 : 	for(int iDX = -iRange; iDX <= iRange; iDX++)

	mov	edi, -2					; fffffffeH
	mov	DWORD PTR _pPlot$[esp+28], edx
	lea	ebx, DWORD PTR [edi+4]
	jmp	SHORT $LN9@IsTestCity@21
$LL44@IsTestCity@21:

; 2946 : 	// scan the nearby tiles to see if there are at least two forests in the vicinity
; 2947 : 	const int iRange = 2;
; 2948 : 	int iNumForests = 0;

	mov	edx, DWORD PTR _pPlot$[esp+28]
$LN9@IsTestCity@21:

; 2965 : 		{
; 2966 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	esi, -2					; fffffffeH
	lea	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR tv163[esp+28], eax
	jmp	SHORT $LN6@IsTestCity@21
$LL48@IsTestCity@21:

; 2963 : 	{
; 2964 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	mov	edx, DWORD PTR _pPlot$[esp+28]
$LN6@IsTestCity@21:

; 2965 : 		{
; 2966 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv163[esp+28], ecx
	mov	ecx, edi
	jne	SHORT $LN18@IsTestCity@21
	test	ebx, ebx
	jle	SHORT $LN22@IsTestCity@21
	mov	ecx, ebx
$LN22@IsTestCity@21:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN24@IsTestCity@21
	mov	eax, ebp
$LN24@IsTestCity@21:
	add	eax, ecx
	jmp	SHORT $LN29@IsTestCity@21
$LN18@IsTestCity@21:
	test	ebx, ebx
	jle	SHORT $LN26@IsTestCity@21
	mov	ecx, ebx
$LN26@IsTestCity@21:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN28@IsTestCity@21
	mov	eax, ebp
$LN28@IsTestCity@21:
	cmp	ecx, eax
	jl	SHORT $LN29@IsTestCity@21
	mov	eax, ecx
$LN29@IsTestCity@21:
	cmp	eax, 2
	jg	SHORT $LN5@IsTestCity@21
	movsx	eax, WORD PTR [edx+2]
	movsx	ecx, WORD PTR [edx]
	push	esi
	push	edi
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 2967 : #endif
; 2968 : 			if(pLoopPlot)

	test	eax, eax
	je	SHORT $LN5@IsTestCity@21

; 2969 : 			{
; 2970 : 				// FEATURE_FOREST seems dubious to me...
; 2971 : 				if(pLoopPlot->getFeatureType() == FEATURE_FOREST && pLoopPlot->getOwner() == pPlot->getOwner())

	cmp	BYTE PTR [eax+432], 5
	jne	SHORT $LN5@IsTestCity@21
	mov	dl, BYTE PTR [eax+4]
	mov	eax, DWORD PTR _pPlot$[esp+28]
	cmp	dl, BYTE PTR [eax+4]
	jne	SHORT $LN5@IsTestCity@21

; 2972 : 				{
; 2973 : 					iNumForests++;

	mov	eax, DWORD PTR _iNumForests$[esp+28]
	inc	eax

; 2974 : 					if(iNumForests > 1)

	cmp	eax, 1
	mov	DWORD PTR _iNumForests$[esp+28], eax
	jg	SHORT $LN41@IsTestCity@21
$LN5@IsTestCity@21:

; 2963 : 	{
; 2964 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	dec	ebp
	inc	esi
	cmp	ebp, -2					; fffffffeH
	jge	SHORT $LL48@IsTestCity@21
	dec	ebx
	inc	edi
	cmp	ebx, -2					; fffffffeH
	jge	$LL44@IsTestCity@21
	pop	edi
	pop	esi
	pop	ebp

; 2977 : 					}
; 2978 : 				}
; 2979 : 			}
; 2980 : 		}
; 2981 : 	}
; 2982 : 
; 2983 : 	return false;

	xor	al, al
	pop	ebx

; 2984 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN41@IsTestCity@21:
	pop	edi
	pop	esi
	pop	ebp

; 2975 : 					{
; 2976 : 						return true;

	mov	al, 1
	pop	ebx

; 2984 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pPlot$ = -12						; size = 4
_iNumJungles$ = -8					; size = 4
tv163 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity, COMDAT

; 2988 : {

	sub	esp, 12					; 0000000cH

; 2992 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _iNumJungles$[esp+28], 0
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, eax

; 2993 : 
; 2994 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2995 : 	int iMaxDX, iDX;
; 2996 : 	CvPlot* pLoopPlot;
; 2997 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 2998 : 	{
; 2999 : 		iMaxDX = iRange - MAX(0, iDY);
; 3000 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 3001 : 		{
; 3002 : 			// No need for range check because loops are set up properly
; 3003 : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 3004 : #else
; 3005 : 	for(int iDX = -iRange; iDX <= iRange; iDX++)

	mov	edi, -2					; fffffffeH
	mov	DWORD PTR _pPlot$[esp+28], edx
	lea	ebx, DWORD PTR [edi+4]
	jmp	SHORT $LN9@IsTestCity@22
$LL44@IsTestCity@22:

; 2989 : 	// scan the nearby tiles to see if there are at least two jungles in the vicinity
; 2990 : 	const int iRange = 2;
; 2991 : 	int iNumJungles = 0;

	mov	edx, DWORD PTR _pPlot$[esp+28]
$LN9@IsTestCity@22:

; 3008 : 		{
; 3009 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	esi, -2					; fffffffeH
	lea	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR tv163[esp+28], eax
	jmp	SHORT $LN6@IsTestCity@22
$LL48@IsTestCity@22:

; 3006 : 	{
; 3007 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	mov	edx, DWORD PTR _pPlot$[esp+28]
$LN6@IsTestCity@22:

; 3008 : 		{
; 3009 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv163[esp+28], ecx
	mov	ecx, edi
	jne	SHORT $LN18@IsTestCity@22
	test	ebx, ebx
	jle	SHORT $LN22@IsTestCity@22
	mov	ecx, ebx
$LN22@IsTestCity@22:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN24@IsTestCity@22
	mov	eax, ebp
$LN24@IsTestCity@22:
	add	eax, ecx
	jmp	SHORT $LN29@IsTestCity@22
$LN18@IsTestCity@22:
	test	ebx, ebx
	jle	SHORT $LN26@IsTestCity@22
	mov	ecx, ebx
$LN26@IsTestCity@22:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN28@IsTestCity@22
	mov	eax, ebp
$LN28@IsTestCity@22:
	cmp	ecx, eax
	jl	SHORT $LN29@IsTestCity@22
	mov	eax, ecx
$LN29@IsTestCity@22:
	cmp	eax, 2
	jg	SHORT $LN5@IsTestCity@22
	movsx	eax, WORD PTR [edx+2]
	movsx	ecx, WORD PTR [edx]
	push	esi
	push	edi
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 3010 : #endif
; 3011 : 			if(pLoopPlot)

	test	eax, eax
	je	SHORT $LN5@IsTestCity@22

; 3012 : 			{
; 3013 : 				// FEATURE_JUNGLE seems dubious to me...
; 3014 : 				if(pLoopPlot->getFeatureType() == FEATURE_JUNGLE && pLoopPlot->getOwner() == pPlot->getOwner())

	cmp	BYTE PTR [eax+432], 1
	jne	SHORT $LN5@IsTestCity@22
	mov	dl, BYTE PTR [eax+4]
	mov	eax, DWORD PTR _pPlot$[esp+28]
	cmp	dl, BYTE PTR [eax+4]
	jne	SHORT $LN5@IsTestCity@22

; 3015 : 				{
; 3016 : 					iNumJungles++;

	mov	eax, DWORD PTR _iNumJungles$[esp+28]
	inc	eax

; 3017 : 					if(iNumJungles > 1)

	cmp	eax, 1
	mov	DWORD PTR _iNumJungles$[esp+28], eax
	jg	SHORT $LN41@IsTestCity@22
$LN5@IsTestCity@22:

; 3006 : 	{
; 3007 : 		for(int iDY = -iRange; iDY <= iRange; iDY++)

	dec	ebp
	inc	esi
	cmp	ebp, -2					; fffffffeH
	jge	SHORT $LL48@IsTestCity@22
	dec	ebx
	inc	edi
	cmp	ebx, -2					; fffffffeH
	jge	$LL44@IsTestCity@22
	pop	edi
	pop	esi
	pop	ebp

; 3020 : 					}
; 3021 : 				}
; 3022 : 			}
; 3023 : 		}
; 3024 : 	}
; 3025 : 
; 3026 : 	return false;

	xor	al, al
	pop	ebx

; 3027 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN41@IsTestCity@22:
	pop	edi
	pop	esi
	pop	ebp

; 3018 : 					{
; 3019 : 						return true;

	mov	al, 1
	pop	ebx

; 3027 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ:PROC ; CvCity::GetCityEspionage
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCityEspionage$ = -8					; size = 4
_iTurnsOfEspionage$ = -4				; size = 4
_fRatio$ = 8						; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen, COMDAT

; 3042 : {

	sub	esp, 8
	push	ebp
	push	esi

; 3043 : 	PlayerTypes ePlayer = pCity->getOwner();

	mov	esi, DWORD PTR _pCity$[esp+12]
	mov	ebp, DWORD PTR [esi+84]

; 3044 : 	CvEspionageAI* pEspionageAI = GET_PLAYER(ePlayer).GetEspionageAI();

	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI

; 3045 : 	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, esi
	mov	edi, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 3046 : 	float fRatio = 0.0;
; 3047 : 	int iTurnsOfEspionage = GC.getGame().getGameTurn() - pEspionageAI->m_iTurnEspionageStarted;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+736]
	mov	DWORD PTR _pCityEspionage$[esp+20], eax
	mov	DWORD PTR _fRatio$[esp+16], 0
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, esi
	mov	DWORD PTR _iTurnsOfEspionage$[esp+20], eax

; 3048 : 	if (pEspionageAI->m_iTurnEspionageStarted != 0)

	test	esi, esi
	je	SHORT $LN7@IsTestCity@23

; 3049 : 	{
; 3050 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;
; 3051 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	jle	SHORT $LN4@IsTestCity@23
	push	ebx
	mov	ebx, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	xor	esi, esi
$LL6@IsTestCity@23:

; 3052 : 		{
; 3053 : 			FlavorTypes eFlavor = (FlavorTypes)iFlavor;
; 3054 : 			if (GC.getFlavorTypes(eFlavor) == "FLAVOR_ESPIONAGE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	ecx, DWORD PTR [esi+eax]
	push	OFFSET $SG227392
	push	ecx
	call	ebx
	inc	edi
	add	esp, 8
	add	esi, 28					; 0000001cH
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL6@IsTestCity@23
	pop	ebx
$LN4@IsTestCity@23:

; 3055 : 			{
; 3056 : 				eFlavorEspionage = eFlavor;
; 3057 : 			}
; 3058 : 		}
; 3059 : 		CvAssertMsg(eFlavorEspionage != NO_FLAVOR, "Could not find espionage flavor!");
; 3060 : 		
; 3061 : 		fRatio = pCityEspionage->m_aiNumTimesCityRobbed[ePlayer] / (float)(iTurnsOfEspionage);

	mov	edx, DWORD PTR _pCityEspionage$[esp+20]
	fild	DWORD PTR [edx+ebp*4+708]
	fidiv	DWORD PTR _iTurnsOfEspionage$[esp+20]
	fstp	DWORD PTR _fRatio$[esp+16]
$LN7@IsTestCity@23:

; 3062 : 	}
; 3063 : 
; 3064 : 	if (fRatio > 0.0)

	fld	DWORD PTR _fRatio$[esp+16]
	pop	edi
	fcomp	QWORD PTR __real@0000000000000000
	pop	esi
	pop	ebp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@IsTestCity@23

; 3065 : 	{
; 3066 : 		return true;

	mov	al, 1

; 3071 : 	}
; 3072 : }

	add	esp, 8
	ret	0
$LN2@IsTestCity@23:

; 3067 : 	}
; 3068 : 	else
; 3069 : 	{
; 3070 : 		return false;

	xor	al, al

; 3071 : 	}
; 3072 : }

	add	esp, 8
	ret	0
?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen
_TEXT	ENDS
PUBLIC	__real@3d4ccccd
PUBLIC	?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
;	COMDAT __real@3d4ccccd
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
CONST	ENDS
;	COMDAT ?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_iLoop$ = -12						; size = 4
_eFlavorEspionage$227412 = -8				; size = 4
_fRatio$227421 = -4					; size = 4
_iNumOtherCities$ = -4					; size = 4
tv281 = 8						; size = 4
_fCutOff$227423 = 8					; size = 4
_iNumBetterScienceCities$ = 8				; size = 4
_pCity$ = 8						; size = 4
?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity, COMDAT

; 3075 : {

	sub	esp, 12					; 0000000cH
	push	edi

; 3076 : 	if (GET_PLAYER(pCity->getOwner()).GetEspionageAI()->m_iTurnEspionageStarted == -1)

	mov	edi, DWORD PTR _pCity$[esp+12]
	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	cmp	DWORD PTR [eax+736], -1
	jne	SHORT $LN14@IsTestCity@24

; 3077 : 	{
; 3078 : 		return false;

	xor	al, al
	pop	edi

; 3131 : 	}
; 3132 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN14@IsTestCity@24:
	push	ebx
	push	ebp
	push	esi

; 3079 : 	}
; 3080 : 
; 3081 : 	PlayerTypes ePlayer = pCity->getOwner();

	mov	esi, DWORD PTR [edi+84]

; 3082 : 	CvCity* pLoopCity = NULL;
; 3083 : 	int iLoop = 0;

	xor	ebx, ebx

; 3084 : 	int iNumBetterScienceCities = 0;
; 3085 : 	int iNumOtherCities = 0;
; 3086 : 	int iCityScienceOutput = pCity->getYieldRateTimes100(YIELD_SCIENCE, false);

	push	ebx
	push	3
	mov	ecx, edi
	mov	DWORD PTR _iLoop$[esp+36], ebx
	mov	DWORD PTR _iNumBetterScienceCities$[esp+32], ebx
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100

; 3087 : 
; 3088 : 	for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	imul	esi, 63236				; 0000f704H
	mov	ebp, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	lea	edx, DWORD PTR _iLoop$[esp+32]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	$LN8@IsTestCity@24
	npad	7
$LL41@IsTestCity@24:

; 3089 : 	{
; 3090 : 		iNumOtherCities++;

	inc	ebx

; 3091 : 		// don't evaluate ourselves
; 3092 : 		if (pLoopCity == pCity)

	cmp	eax, edi
	je	SHORT $LN12@IsTestCity@24

; 3093 : 		{
; 3094 : 			continue;
; 3095 : 		}
; 3096 : 
; 3097 : 		if (pLoopCity->getYieldRateTimes100(YIELD_SCIENCE, false) > iCityScienceOutput)

	push	0
	push	3
	mov	ecx, eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cmp	eax, ebp
	jle	SHORT $LN12@IsTestCity@24

; 3098 : 		{
; 3099 : 			iNumBetterScienceCities++;

	inc	DWORD PTR _iNumBetterScienceCities$[esp+24]
$LN12@IsTestCity@24:

; 3087 : 
; 3088 : 	for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+32]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL41@IsTestCity@24

; 3089 : 	{
; 3090 : 		iNumOtherCities++;

	mov	DWORD PTR _iNumOtherCities$[esp+28], ebx

; 3100 : 		}
; 3101 : 	}
; 3102 : 
; 3103 : 	if (iNumOtherCities > 0)

	test	ebx, ebx
	jle	$LN8@IsTestCity@24

; 3104 : 	{
; 3105 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;
; 3106 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	mov	DWORD PTR _eFlavorEspionage$227412[esp+28], -1
	jle	SHORT $LN5@IsTestCity@24
	mov	ebp, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	xor	ebx, ebx
	npad	10
$LL7@IsTestCity@24:

; 3107 : 		{
; 3108 : 			FlavorTypes eFlavor = (FlavorTypes)iFlavor;
; 3109 : 			if (GC.getFlavorTypes(eFlavor) == "FLAVOR_ESPIONAGE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, ebx
	push	OFFSET $SG227420
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN6@IsTestCity@24

; 3110 : 			{
; 3111 : 				eFlavorEspionage = eFlavor;

	mov	DWORD PTR _eFlavorEspionage$227412[esp+28], edi
$LN6@IsTestCity@24:

; 3104 : 	{
; 3105 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;
; 3106 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	inc	edi
	add	ebx, 28					; 0000001cH
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL7@IsTestCity@24
$LN5@IsTestCity@24:

; 3112 : 			}
; 3113 : 		}
; 3114 : 		CvAssertMsg(eFlavorEspionage != NO_FLAVOR, "Could not find espionage flavor!");
; 3115 : 
; 3116 : 		float fRatio = iNumBetterScienceCities / (float)iNumOtherCities;

	fild	DWORD PTR _iNumBetterScienceCities$[esp+24]

; 3117 : 		float fCutOff = (0.05f * GET_PLAYER(ePlayer).GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavorEspionage));

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR _eFlavorEspionage$227412[esp+28]
	add	ecx, esi
	fidiv	DWORD PTR _iNumOtherCities$[esp+28]
	push	edx
	fstp	DWORD PTR _fRatio$227421[esp+32]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR tv281[esp+24], eax
	fild	DWORD PTR tv281[esp+24]
	fmul	DWORD PTR __real@3d4ccccd
	fstp	DWORD PTR _fCutOff$227423[esp+24]

; 3118 : 
; 3119 : 		if (fRatio < fCutOff)

	fld	DWORD PTR _fRatio$227421[esp+28]
	fld	DWORD PTR _fCutOff$227423[esp+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@IsTestCity@24
	pop	esi
	pop	ebp
	pop	ebx

; 3120 : 		{
; 3121 : 			return true;

	mov	al, 1
	pop	edi

; 3131 : 	}
; 3132 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN8@IsTestCity@24:
	pop	esi
	pop	ebp
	pop	ebx

; 3122 : 		}
; 3123 : 		else
; 3124 : 		{
; 3125 : 			return false;
; 3126 : 		}
; 3127 : 	}
; 3128 : 	else
; 3129 : 	{
; 3130 : 		return false;

	xor	al, al
	pop	edi

; 3131 : 	}
; 3132 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
EXTRN	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z:PROC ; CvPlayerTrade::GetNumPotentialConnections
EXTRN	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z:PROC ; CvPlayerTrade::GetNumTradeRoutesRemaining
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_eDomain$ = 12						; size = 4
?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute, COMDAT

; 3224 : {

	push	esi
	push	edi

; 3225 : 	PlayerTypes ePlayer = pCity->getOwner();
; 3226 : 	CvPlayerTrade* pTrade = GET_PLAYER(ePlayer).GetTrade();

	mov	edi, DWORD PTR _pCity$[esp+4]
	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	esi, eax

; 3227 : 
; 3228 : 	if (pTrade->GetNumTradeRoutesRemaining(false) <= 0)

	push	0
	mov	ecx, esi
	call	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesRemaining
	test	eax, eax
	jg	SHORT $LN2@IsTestCity@25
	pop	edi

; 3229 : 	{
; 3230 : 		return false;

	xor	al, al
	pop	esi

; 3234 : 	{
; 3235 : 		return false;
; 3236 : 	}
; 3237 : 
; 3238 : 	return true;
; 3239 : }

	ret	0
$LN2@IsTestCity@25:

; 3231 : 	}
; 3232 : 
; 3233 : 	if (pTrade->GetNumPotentialConnections(pCity, eDomain) <= 0)

	mov	eax, DWORD PTR _eDomain$[esp+4]
	push	eax
	push	edi
	mov	ecx, esi
	call	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ; CvPlayerTrade::GetNumPotentialConnections
	test	eax, eax
	pop	edi
	setg	al
	pop	esi

; 3234 : 	{
; 3235 : 		return false;
; 3236 : 	}
; 3237 : 
; 3238 : 	return true;
; 3239 : }

	ret	0
?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_eDomain$ = 12						; size = 4
?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute, COMDAT

; 3242 : {

	push	esi
	push	edi

; 3243 : 	PlayerTypes ePlayer = pCity->getOwner();
; 3244 : 	CvPlayerTrade* pTrade = GET_PLAYER(ePlayer).GetTrade();

	mov	edi, DWORD PTR _pCity$[esp+4]
	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	esi, eax

; 3245 : 
; 3246 : 	if (pTrade->GetNumTradeRoutesRemaining(false) <= 0)

	push	0
	mov	ecx, esi
	call	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesRemaining
	test	eax, eax
	jg	SHORT $LN2@IsTestCity@26
	pop	edi

; 3247 : 	{
; 3248 : 		return true;

	mov	al, 1
	pop	esi

; 3252 : 	{
; 3253 : 		return true;
; 3254 : 	}
; 3255 : 
; 3256 : 	return false;
; 3257 : }

	ret	0
$LN2@IsTestCity@26:

; 3249 : 	}
; 3250 : 
; 3251 : 	if (pTrade->GetNumPotentialConnections(pCity, eDomain) <= 0)

	mov	eax, DWORD PTR _eDomain$[esp+4]
	push	eax
	push	edi
	mov	ecx, esi
	call	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ; CvPlayerTrade::GetNumPotentialConnections
	test	eax, eax
	pop	edi
	setle	al
	pop	esi

; 3252 : 	{
; 3253 : 		return true;
; 3254 : 	}
; 3255 : 
; 3256 : 	return false;
; 3257 : }

	ret	0
?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding
EXTRN	?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z:PROC ; CvPlayerCulture::GetNumGreatWorkSlots
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ:PROC ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding, COMDAT

; 3287 : 	CvPlayer &kPlayer = GET_PLAYER(pCity->getOwner());

	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3288 : 
; 3289 : 	GreatWorkSlotType eSlotType = pCity->GetCityCulture()->GetSlotTypeFirstAvailableCultureBuilding();

	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding

; 3290 : 
; 3291 : 	if (eSlotType != NO_GREAT_WORK_SLOT)

	cmp	eax, -1
	je	SHORT $LN1@IsTestCity@27

; 3292 : 	{
; 3293 : 		int iSlotsOpen = kPlayer.GetCulture()->GetNumGreatWorkSlots(eSlotType);

	push	eax
	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumGreatWorkSlots

; 3294 : 
; 3295 : 		if (iSlotsOpen <= 2)

	cmp	eax, 2
	jg	SHORT $LN1@IsTestCity@27

; 3296 : 		{
; 3297 : 			return true;

	mov	al, 1
	pop	esi

; 3302 : }

	ret	0
$LN1@IsTestCity@27:

; 3298 : 		}
; 3299 : 	}
; 3300 : 
; 3301 : 	return false;

	xor	al, al
	pop	esi

; 3302 : }

	ret	0
?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding
_TEXT	ENDS
PUBLIC	?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity, COMDAT

; 3329 : {

	push	esi

; 3330 : #ifdef AUI_WARNING_FIXES
; 3331 : 	if (!pCity)
; 3332 : 		return false;
; 3333 : #endif
; 3334 : 	if (pCity->isCapital())

	mov	esi, DWORD PTR _pCity$[esp]
	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN3@IsTestCity@28

; 3335 : 	{
; 3336 : 		return true;

	mov	al, 1
	pop	esi

; 3353 : 	{
; 3354 : 		return true;
; 3355 : 	}
; 3356 : 
; 3357 : 	return false;
; 3358 : }

	ret	0
$LN3@IsTestCity@28:

; 3337 : 	}
; 3338 : 
; 3339 : 	CvPlayer &kPlayer = GET_PLAYER(pCity->getOwner());

	mov	ecx, DWORD PTR [esi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	edi

; 3340 : 	CvCity *pCapital = kPlayer.getCapitalCity();

	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	edi, eax

; 3341 : #ifdef AUI_WARNING_FIXES
; 3342 : 	if (!pCapital)
; 3343 : 		return false;
; 3344 : 	if (pCity->getArea() != pCapital->getArea())
; 3345 : #else
; 3346 : 	if (pCity && pCity->getArea() != pCapital->getArea())

	mov	ecx, edi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, esi
	mov	ebx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	eax, ebx
	je	SHORT $LN2@IsTestCity@28
	pop	edi
	pop	ebx

; 3347 : #endif
; 3348 : 	{
; 3349 : 		return true;

	mov	al, 1
	pop	esi

; 3353 : 	{
; 3354 : 		return true;
; 3355 : 	}
; 3356 : 
; 3357 : 	return false;
; 3358 : }

	ret	0
$LN2@IsTestCity@28:

; 3350 : 	}
; 3351 : 
; 3352 : 	if (plotDistance (pCity->getX(), pCity->getY(), pCapital->getX(), pCapital->getY()) > 20)

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+96]
	mov	edx, DWORD PTR [esi+108]
	push	eax
	mov	eax, DWORD PTR [esi+96]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	pop	edi
	cmp	eax, 20					; 00000014H
	pop	ebx
	setg	al
	pop	esi

; 3353 : 	{
; 3354 : 		return true;
; 3355 : 	}
; 3356 : 
; 3357 : 	return false;
; 3358 : }

	ret	0
?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@XZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::end
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -16						; size = 16
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 16					; 00000010H

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp+12]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$[esp+16], ecx
	mov	ecx, DWORD PTR [eax+8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$[esp+20], edx
	mov	DWORD PTR _elem$[esp+24], ecx

; 75   : 	}

	add	esp, 16					; 00000010H
	ret	4
?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ ; CvWeightedVector<CvCityBuildable,225,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::clear
_TEXT	ENDS
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iNumChoices$ = 12					; size = 4
_rndFcn$ = 16						; size = 4
_szRollName$ = 20					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ecx
	push	ebx
	push	ebp

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	ebp, DWORD PTR _iNumChoices$[esp+8]
	mov	edx, ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	ebp, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+20], edx
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	ebp, eax
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	xor	esi, esi
	xor	edi, edi
	xor	ebx, ebx

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	xor	ecx, ecx

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	test	ebp, ebp
	jle	SHORT $LN5@ChooseFrom
	mov	eax, DWORD PTR [edx]
	mov	edx, ebp
$LL7@ChooseFrom:

; 237  : 		{
; 238  : 			elem = m_pItems[i];
; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	add	ecx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+8]
	add	eax, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL7@ChooseFrom
$LN5@ChooseFrom:

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	eax, DWORD PTR _szRollName$[esp+16]
	push	eax
	mov	eax, DWORD PTR _rndFcn$[esp+20]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	edx

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	xor	edx, edx
	test	ebp, ebp
	jle	SHORT $LN2@ChooseFrom
	mov	ecx, DWORD PTR _this$[esp+20]
	mov	ecx, DWORD PTR [ecx]
$LL4@ChooseFrom:

; 247  : 		{
; 248  : 			elem = m_pItems[i];
; 249  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR [ecx+12]
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx+8]

; 250  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseFrom
	inc	edx
	add	ecx, 16					; 00000010H
	cmp	edx, ebp
	jl	SHORT $LL4@ChooseFrom
$LN2@ChooseFrom:

; 251  : 			{
; 252  : 				return elem.m_Element;
; 253  : 			}
; 254  : 		}
; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+8], ebx
	pop	ebx

; 260  : 	};

	pop	ecx
	ret	16					; 00000010H
?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>, COMDAT
; _this$ = ecx

; 1041 : 	FastDelegate2() { clear(); }

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
_TEXT	ENDS
PUBLIC	??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::operator=, COMDAT
; _this$ = ecx

; 1045 : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	eax, DWORD PTR _x$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	ret	4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@KAXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvAICityStrategyEntry@@@std@@YAPAPAVCvAICityStrategyEntry@@IPAPAV1@@Z ; std::_Allocate<CvAICityStrategyEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::~FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvCitySpecializationXMLEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXPAPAVCvCitySpecializationXMLEntry@@0@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXPAPAVCvCitySpecializationXMLEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXPAPAVCvCitySpecializationXMLEntry@@0@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXPAPAVCvCitySpecializationXMLEntry@@0@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXPAPAVCvAICityStrategyEntry@@0@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXPAPAVCvAICityStrategyEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXPAPAVCvAICityStrategyEntry@@0@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXPAPAVCvAICityStrategyEntry@@0@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN34@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 225				; 000000e1H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	eax, ebp
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 225			; 000000e1H
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+3612], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAPAVCvCitySpecializationXMLEntry@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@PAPAV2@00@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<CvCitySpecializationXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@PAPAVCvCitySpecializationXMLEntry@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVCvCitySpecializationXMLEntry@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@PAPAV2@00@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<CvCitySpecializationXMLEntry * *>, COMDAT
; _this$ = ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Ucopy
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Ucopy:
	pop	edi
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	12					; 0000000cH
??$_Ucopy@PAPAVCvCitySpecializationXMLEntry@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@PAPAV2@00@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<CvCitySpecializationXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>, COMDAT
; _this$ = ecx

; 1057 : 		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL14@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ		; std::_Temp_iterator<unsigned char>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$229079 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ PROC		; std::_Temp_iterator<unsigned char>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$229079[esp+16]
	push	eax
	call	??$get_temporary_buffer@E@std@@YA?AU?$pair@PAEH@0@H@Z ; std::get_temporary_buffer<unsigned char>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$229079[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$229079[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ ENDP		; std::_Temp_iterator<unsigned char>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 4
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	eax, 4
	shl	edi, 5
	mov	ebx, eax
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	ebp
	mov	ebp, DWORD PTR __First$[esp+4]
	sub	ebx, ebp
	sar	ebx, 4

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	push	esi
	sub	eax, edx
	push	edi
	mov	edi, eax
	sar	edi, 1
	test	edi, edi
	jle	SHORT $LN1@Make_heap
	mov	esi, edi
	shl	esi, 4
	add	esi, ebp
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [esi-16]
	sub	esi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	dec	edi
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	push	edi
	push	ebp
	mov	DWORD PTR [eax+12], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH
	test	edi, edi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
__Val$229320 = -16					; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	edi
	mov	edi, DWORD PTR __First$[esp+16]
	cmp	edi, eax
	je	$LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+16]
	cmp	edx, eax
	je	$LN6@Insertion_
	push	ebx
	push	ebp
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+12]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+12]
	mov	ebp, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx]
	mov	eax, edx
	mov	DWORD PTR __Val$229320[esp+36], ebp
	mov	DWORD PTR __Val$229320[esp+40], ecx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	cmp	edi, edx
	je	SHORT $LN21@Insertion_
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-16]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+20], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+28], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __Val$229320[esp+40]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ebp
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	ecx, DWORD PTR [edx-16]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	eax, ecx
	sub	ecx, 16					; 00000010H
	cmp	esi, DWORD PTR [ecx+12]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Val$229320[esp+36]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$229320[esp+40]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], esi
$LN4@Insertion_:
	add	edx, 16					; 00000010H
	cmp	edx, DWORD PTR __Last$[esp+28]
	jne	$LL7@Insertion_
	pop	esi
	pop	ebp
	pop	ebx
$LN6@Insertion_:
	pop	edi

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z PROC ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@Insertion_@2
	push	ebp

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebp, DWORD PTR [edx+1]
	cmp	ebp, eax
	je	SHORT $LN28@Insertion_@2
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	sub	edi, edx
	npad	5
$LL7@Insertion_@2:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	bl, BYTE PTR [ebp]
	mov	esi, ebp

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	cmp	bl, BYTE PTR [edx]
	jbe	SHORT $LN5@Insertion_@2

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	test	edi, edi
	jle	SHORT $LN27@Insertion_@2
	push	edi
	push	edx
	mov	eax, ebp
	sub	eax, edi
	inc	eax
	push	edi
	push	eax
	call	DWORD PTR __imp__memmove_s
	mov	edx, DWORD PTR __First$[esp+28]
	add	esp, 16					; 00000010H
$LN27@Insertion_@2:

; 3133 : 				*_First = _Val;

	mov	BYTE PTR [edx], bl

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	mov	cl, BYTE PTR [edx+edi-1]
	lea	eax, DWORD PTR [edx+edi-1]
	cmp	bl, cl
	jbe	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	BYTE PTR [esi], cl
	mov	cl, BYTE PTR [eax-1]
	mov	esi, eax
	dec	eax
	cmp	bl, cl
	ja	SHORT $LL3@Insertion_@2
$LN1@Insertion_@2:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	BYTE PTR [esi], bl
$LN4@Insertion_@2:

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	inc	ebp
	inc	edi
	cmp	ebp, DWORD PTR __Last$[esp+12]
	jne	SHORT $LL7@Insertion_@2
	pop	edi
	pop	esi
	pop	ebx
$LN28@Insertion_@2:
	pop	ebp
$LN6@Insertion_@2:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	ret	0
??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ENDP ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::_Unchecked_merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T236340 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::_Unchecked_merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T236340[esp+4], 0
	mov	eax, DWORD PTR $T236340[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 5229 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::_Unchecked_merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::lower_bound<unsigned char *,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$lower_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::lower_bound<unsigned char *,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;
; 2317 : 	}

	ret	0
??$lower_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::lower_bound<unsigned char *,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::upper_bound<unsigned char *,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$upper_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::upper_bound<unsigned char *,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;
; 2388 : 	}

	ret	0
??$upper_bound@PAEEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::upper_bound<unsigned char *,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T236358 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebp, ebp
	mov	DWORD PTR $T236358[esp+16], ebp
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@4
	lea	esi, DWORD PTR [ebp+1]
	npad	7
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@4
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@4
$LN14@Copy_opt@4:
	cmp	eax, ebp
	je	SHORT $LN19@Copy_opt@4
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@4:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@4:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+12], ebp
	cmp	eax, ebp
	je	SHORT $LN41@Copy_opt@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@4:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	ecx, DWORD PTR __Last1$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+12]
	cmp	eax, ecx
	je	SHORT $LN3@Merge
$LL5@Merge:
	cmp	edi, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	dl, BYTE PTR [edi]
	mov	bl, BYTE PTR [eax]
	cmp	dl, bl
	jbe	SHORT $LN2@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	BYTE PTR [esi], dl
	inc	edi

; 2600 : 		else

	jmp	SHORT $LN4@Merge
$LN2@Merge:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	BYTE PTR [esi], bl
	inc	eax
$LN4@Merge:
	inc	esi
	cmp	eax, ecx
	jne	SHORT $LL5@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	ebp, DWORD PTR __imp__memmove_s
	sub	ecx, eax
	lea	ebx, DWORD PTR [ecx+esi]
	test	ecx, ecx
	jle	SHORT $LN16@Merge
	push	ecx
	push	eax
	push	ecx
	push	esi
	call	ebp
	add	esp, 16					; 00000010H
$LN16@Merge:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Last2$[esp+12]
	sub	eax, edi
	lea	esi, DWORD PTR [eax+ebx]
	test	eax, eax
	jle	SHORT $LN30@Merge
	push	eax
	push	edi
	push	eax
	push	ebx
	call	ebp
	add	esp, 16					; 00000010H
$LN30@Merge:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAE@std@@YAXPAE00@Z			; std::rotate<unsigned char *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAE@std@@YAXPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAE@std@@YAXPAE00@Z PROC			; std::rotate<unsigned char *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z	; std::_Rotate<unsigned char *,int,unsigned char>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAE@std@@YAXPAE00@Z ENDP			; std::rotate<unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	ebx
	mov	ebx, DWORD PTR [eax-8]
	push	ebp
	mov	ebp, DWORD PTR [eax-4]
	push	esi
	mov	esi, DWORD PTR [eax-16]
	push	edi
	mov	edi, DWORD PTR [eax-12]
	mov	DWORD PTR [eax-16], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-12], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	sub	eax, 16					; 00000010H
	sar	eax, 4
	push	eax
	mov	DWORD PTR [edx], esi
	push	0
	mov	DWORD PTR [edx+4], edi
	push	ecx
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], ebp
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH

; 2090 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SetSpecialization
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_eSpecialization$ = 8					; size = 4
?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z PROC ; CvCityStrategyAI::SetSpecialization, COMDAT
; _this$ = ecx

; 481  : {

	push	esi
	push	edi

; 482  : 	if(eSpecialization != m_eSpecialization)

	mov	edi, DWORD PTR _eSpecialization$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+20]
	je	SHORT $LN1@SetSpecial

; 483  : 	{
; 484  : 		LogSpecializationChange(eSpecialization);

	push	edi
	call	?LogSpecializationChange@CvCityStrategyAI@@AAEXW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::LogSpecializationChange

; 485  : 
; 486  : 		// Turn off old specialization
; 487  : 		SpecializationFlavorChange(false /*Don't turn on */, m_eSpecialization);

	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	0
	mov	ecx, esi
	call	?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SpecializationFlavorChange

; 488  : 
; 489  : 		// Turn on new specialization
; 490  : 		SpecializationFlavorChange(true /* Do turn on */, eSpecialization);

	push	edi
	push	1
	mov	ecx, esi
	call	?SpecializationFlavorChange@CvCityStrategyAI@@QAEX_NW4CitySpecializationTypes@@@Z ; CvCityStrategyAI::SpecializationFlavorChange

; 491  : 
; 492  : 		m_eSpecialization = eSpecialization;

	mov	DWORD PTR [esi+20], edi
	pop	edi

; 493  : 
; 494  : 		return true;

	mov	al, 1
	pop	esi

; 498  : }

	ret	4
$LN1@SetSpecial:
	pop	edi

; 495  : 	}
; 496  : 
; 497  : 	return false;

	xor	al, al
	pop	esi

; 498  : }

	ret	4
?SetSpecialization@CvCityStrategyAI@@QAE_NW4CitySpecializationTypes@@@Z ENDP ; CvCityStrategyAI::SetSpecialization
_TEXT	ENDS
PUBLIC	?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::SetUsingCityStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z PROC ; CvCityStrategyAI::SetUsingCityStrategy, COMDAT
; _this$ = ecx

; 569  : {

	push	ebx

; 570  : 	if(m_pabUsingCityStrategy[eStrategy] != bValue)

	mov	ebx, DWORD PTR _bValue$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+28]
	push	edi
	mov	edi, DWORD PTR _eStrategy$[esp+8]
	add	eax, edi
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN3@SetUsingCi

; 571  : 	{
; 572  : 		m_pabUsingCityStrategy[eStrategy] = bValue;

	mov	BYTE PTR [eax], bl

; 573  : 
; 574  : 		if(bValue)

	test	bl, bl
	je	SHORT $LN2@SetUsingCi

; 575  : 		{
; 576  : 			SetTurnCityStrategyAdopted(eStrategy, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+32]
	cmp	DWORD PTR [ecx+edi*4], eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	je	SHORT $LN11@SetUsingCi

; 581  : 		}
; 582  : 
; 583  : 		LogStrategy(eStrategy, bValue);

	push	ebx
	mov	DWORD PTR [ecx], eax
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
	pop	edi
	pop	esi
	pop	ebx

; 584  : 	}
; 585  : }

	ret	8
$LN2@SetUsingCi:

; 577  : 		}
; 578  : 		else
; 579  : 		{
; 580  : 			SetTurnCityStrategyAdopted(eStrategy, -1);

	mov	edx, DWORD PTR [esi+32]
	cmp	DWORD PTR [edx+edi*4], -1
	lea	eax, DWORD PTR [edx+edi*4]
	je	SHORT $LN11@SetUsingCi
	mov	DWORD PTR [eax], -1
$LN11@SetUsingCi:

; 581  : 		}
; 582  : 
; 583  : 		LogStrategy(eStrategy, bValue);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
$LN3@SetUsingCi:
	pop	edi
	pop	esi
	pop	ebx

; 584  : 	}
; 585  : }

	ret	8
?SetUsingCityStrategy@CvCityStrategyAI@@QAEXW4AICityStrategyTypes@@_N@Z ENDP ; CvCityStrategyAI::SetUsingCityStrategy
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z
_TEXT	SEGMENT
$T236604 = -16						; size = 8
$T236593 = -16						; size = 8
$T236595 = -16						; size = 8
_fDesiredYield$ = -16					; size = 8
$T236606 = -8						; size = 8
_fYieldAverage$ = -8					; size = 8
_eYieldType$ = 8					; size = 4
?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z PROC ; CvCityStrategyAI::IsYieldDeficient, COMDAT
; _this$ = ecx

; 651  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 60					; 0000003cH

; 652  : 	double fDesiredYield = GetDeficientYieldValue(eYieldType);

	mov	edx, DWORD PTR _eYieldType$[ebp]
	push	esi
	push	edx
	call	?GetDeficientYieldValue@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetDeficientYieldValue
	fstp	QWORD PTR _fDesiredYield$[esp+64]

; 653  : 	double fYieldAverage = GetYieldAverage(eYieldType);

	push	edx
	call	?GetYieldAverage@CvCityStrategyAI@@QAENW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldAverage
	fstp	QWORD PTR _fYieldAverage$[esp+64]

; 654  : 
; 655  : 	int iDesiredYield = (int)citystrategyround(fDesiredYield * 100);

	fld	QWORD PTR _fDesiredYield$[esp+64]
	sub	esp, 8
	fmul	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR $T236595[esp+72]
	fldz
	fld	QWORD PTR $T236595[esp+72]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	SHORT $LN7@IsYieldDef
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	jmp	SHORT $LN19@IsYieldDef
$LN7@IsYieldDef:
	fsub	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
$LN19@IsYieldDef:
	fstp	QWORD PTR $T236593[esp+72]
	add	esp, 8
	fld	QWORD PTR $T236593[esp+64]
	call	__ftol2_sse_excpt

; 656  : 	int iYieldAverage = (int)citystrategyround(fYieldAverage * 100);

	fld	QWORD PTR _fYieldAverage$[esp+64]
	fmul	QWORD PTR __real@4059000000000000
	mov	esi, eax
	sub	esp, 8
	fstp	QWORD PTR $T236606[esp+72]
	fldz
	fld	QWORD PTR $T236606[esp+72]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	SHORT $LN11@IsYieldDef
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	jmp	SHORT $LN20@IsYieldDef
$LN11@IsYieldDef:
	fsub	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
$LN20@IsYieldDef:
	fstp	QWORD PTR $T236604[esp+72]
	add	esp, 8

; 657  : 
; 658  : 	if(iYieldAverage < iDesiredYield)

	fld	QWORD PTR $T236604[esp+64]
	call	__ftol2_sse_excpt
	cmp	eax, esi
	setl	al

; 659  : 	{
; 660  : 		return true;
; 661  : 	}
; 662  : 	else
; 663  : 	{
; 664  : 		return false;
; 665  : 	}
; 666  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ENDP ; CvCityStrategyAI::IsYieldDeficient
_TEXT	ENDS
PUBLIC	?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetDeficientYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ
_TEXT	SEGMENT
?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ PROC ; CvCityStrategyAI::GetDeficientYield, COMDAT
; _this$ = ecx

; 670  : {

	push	edi

; 671  : 	if(IsYieldDeficient(YIELD_FOOD))

	push	0
	mov	edi, ecx
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	test	al, al
	je	SHORT $LN8@GetDeficie@2

; 672  : 	{
; 673  : 		return YIELD_FOOD;

	xor	eax, eax
	pop	edi

; 692  : }

	ret	0
$LN8@GetDeficie@2:

; 674  : 	}
; 675  : 	else if(IsYieldDeficient(YIELD_PRODUCTION))

	push	1
	mov	ecx, edi
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	test	al, al
	je	SHORT $LN6@GetDeficie@2

; 676  : 	{
; 677  : 		return YIELD_PRODUCTION;

	mov	eax, 1
	pop	edi

; 692  : }

	ret	0
$LN6@GetDeficie@2:
	push	esi

; 678  : 	}
; 679  : 	else
; 680  : 	{
; 681  : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
	npad	7
$LL4@GetDeficie@2:

; 682  : 		{
; 683  : 			YieldTypes yield = (YieldTypes)ui;
; 684  : 			if(IsYieldDeficient(yield))

	push	esi
	mov	ecx, edi
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	test	al, al
	jne	SHORT $LN12@GetDeficie@2
	inc	esi
	cmp	esi, 6
	jb	SHORT $LL4@GetDeficie@2
	pop	esi

; 687  : 			}
; 688  : 		}
; 689  : 	}
; 690  : 
; 691  : 	return NO_YIELD;

	or	eax, -1
	pop	edi

; 692  : }

	ret	0
$LN12@GetDeficie@2:

; 685  : 			{
; 686  : 				return yield;

	mov	eax, esi
	pop	esi
	pop	edi

; 692  : }

	ret	0
?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ENDP ; CvCityStrategyAI::GetDeficientYield
_TEXT	ENDS
PUBLIC	?ReweightByCost@CvCityStrategyAI@@AAEXXZ	; CvCityStrategyAI::ReweightByCost
; Function compile flags: /Ogtpy
;	COMDAT ?ReweightByCost@CvCityStrategyAI@@AAEXXZ
_TEXT	SEGMENT
_fWeightDivisor$236686 = -40				; size = 8
_fTotalCostFactor$236685 = -40				; size = 8
_fAdditionalTurnCostFactor$236684 = -40			; size = 8
_buildable$ = -28					; size = 12
_elem$236667 = -16					; size = 16
?ReweightByCost@CvCityStrategyAI@@AAEXXZ PROC		; CvCityStrategyAI::ReweightByCost, COMDAT
; _this$ = ecx

; 1770 : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	mov	esi, ecx

; 1771 : 	CvCityBuildable buildable;
; 1772 : 
; 1773 : 	for(int iI = 0; iI < m_Buildables.size(); iI++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+60], ebx
	push	edi
	jle	$LN1@ReweightBy
	xor	edi, edi
	npad	5
$LL3@ReweightBy:

; 1774 : 	{
; 1775 : 		buildable = m_Buildables.GetElement(iI);

	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax+edi+4]
	add	eax, edi
	mov	DWORD PTR _buildable$[esp+64], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _buildable$[esp+72], ecx

; 1776 : 
; 1777 : 		// Compute the new weight and change it
; 1778 : 		int iNewWeight = CityStrategyAIHelpers::ReweightByTurnsLeft(m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	fild	DWORD PTR _buildable$[esp+72]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _buildable$[esp+68], edx
	fmul	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8000
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _elem$236667[esp+64], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	fstp	QWORD PTR _fAdditionalTurnCostFactor$236684[esp+64]
	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8004
	sub	esp, 8
	fadd	QWORD PTR _fAdditionalTurnCostFactor$236684[esp+72]
	mov	DWORD PTR _elem$236667[esp+76], ecx
	mov	DWORD PTR _elem$236667[esp+84], eax
	mov	eax, esp
	fstp	QWORD PTR _fTotalCostFactor$236685[esp+72]
	mov	DWORD PTR _elem$236667[esp+80], edx
	mov	ecx, DWORD PTR _fTotalCostFactor$236685[esp+72]
	fild	DWORD PTR _buildable$[esp+80]
	mov	edx, DWORD PTR _fTotalCostFactor$236685[esp+76]
	mov	DWORD PTR [eax], ecx
	sub	esp, 8
	mov	DWORD PTR [eax+4], edx
	fstp	QWORD PTR [esp]
	call	_pow
	fstp	QWORD PTR _fWeightDivisor$236686[esp+80]

; 1779 : 		m_Buildables.SetWeight(iI, iNewWeight);

	fild	DWORD PTR _elem$236667[esp+92]
	add	esp, 16					; 00000010H
	fdiv	QWORD PTR _fWeightDivisor$236686[esp+64]
	call	__ftol2_sse_excpt
	mov	ecx, DWORD PTR [esi+56]
	mov	DWORD PTR [edi+ecx+12], eax
	inc	ebx
	add	edi, 16					; 00000010H
	cmp	ebx, DWORD PTR [esi+60]
	jl	$LL3@ReweightBy
$LN1@ReweightBy:

; 1780 : 	}
; 1781 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReweightByCost@CvCityStrategyAI@@AAEXXZ ENDP		; CvCityStrategyAI::ReweightByCost
_TEXT	ENDS
PUBLIC	?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ	; CvCityStrategyAI::LogPossibleBuilds
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
_TEXT	SEGMENT
$T236819 = -308						; size = 4
$T236805 = -308						; size = 4
$T236812 = -308						; size = 4
tv791 = -304						; size = 4
_this$ = -300						; size = 4
_pLog$226895 = -296					; size = 4
_strDesc$226893 = -292					; size = 28
_strTemp$226890 = -264					; size = 28
_playerName$226891 = -236				; size = 28
_cityName$226892 = -208					; size = 28
_strBaseString$226889 = -180				; size = 28
$T236701 = -152						; size = 28
$T236700 = -152						; size = 28
$T236705 = -124						; size = 28
$T236702 = -124						; size = 28
_strOutBuf$226888 = -96					; size = 28
$T236704 = -68						; size = 28
$T236703 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ PROC	; CvCityStrategyAI::LogPossibleBuilds, COMDAT
; _this$ = ecx

; 1866 : {

	push	-1
	push	__ehhandler$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 296				; 00000128H
	push	ebx
	mov	ebx, ecx

; 1867 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+312], ebx
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN18@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN18@LogPossibl
	push	esi
	push	edi

; 1868 : 	{
; 1869 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226888[esp+320]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edi, edi

; 1870 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226889[esp+320]
	mov	DWORD PTR __$EHRec$[esp+328], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1871 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226890[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1872 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$226891[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1873 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$226892[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1874 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$226893[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1875 : 
; 1876 : 		// Find the name of this civ and city
; 1877 : 		playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+328], 5
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$226891[esp+320]
	cmp	eax, edi
	je	SHORT $LN58@LogPossibl
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN57@LogPossibl
$LN58@LogPossibl:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN57@LogPossibl:

; 1878 : 		cityName = m_pCity->getName();

	lea	ecx, DWORD PTR $T236700[esp+320]
	push	ecx
	mov	ecx, DWORD PTR [ebx+12]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$226892[esp+324]
	mov	BYTE PTR __$EHRec$[esp+332], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236700[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1879 : 
; 1880 : 		// Open the log file
; 1881 : 		FILogFile* pLog;
; 1882 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$226892[esp+320]
	mov	esi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$226891[esp+324]
	push	eax
	lea	ecx, DWORD PTR $T236701[esp+328]
	push	ecx
	mov	ecx, ebx
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+328], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	edi
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T236701[esp+320]
	mov	DWORD PTR _pLog$226895[esp+320], eax
	mov	BYTE PTR __$EHRec$[esp+328], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1883 : 
; 1884 : 		// Get the leading info for this line
; 1885 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226889[esp+324]
	push	OFFSET $SG226897
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1886 : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226902
	lea	edx, DWORD PTR _playerName$226891[esp+336]
	push	edx
	lea	eax, DWORD PTR $T236702[esp+340]
	push	eax
	call	esi
	lea	ecx, DWORD PTR _cityName$226892[esp+344]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T236703[esp+352]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+364], 8
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG226901
	push	eax
	lea	eax, DWORD PTR $T236704[esp+364]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+376], 9
	call	esi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226889[esp+324]
	mov	BYTE PTR __$EHRec$[esp+332], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236704[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T236703[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T236702[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1887 : 
; 1888 : 		// Dump out the weight of each buildable item
; 1889 : 		for(int iI = 0; iI < m_Buildables.size(); iI++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+60], edi
	jle	$LN15@LogPossibl
	push	ebp
	lea	ebp, DWORD PTR [ebx+56]
	mov	DWORD PTR tv791[esp+324], edi
$LL129@LogPossibl:
	mov	eax, DWORD PTR [ebp]
	add	eax, DWORD PTR tv791[esp+324]

; 1890 : 		{
; 1891 : 			CvCityBuildable buildable = m_Buildables.GetElement(iI);

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]

; 1892 : 
; 1893 : 			switch(buildable.m_eBuildableType)

	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 5
	ja	$LN1@LogPossibl
	jmp	DWORD PTR $LN133@LogPossibl[eax*4]
$LN12@LogPossibl:

; 1894 : 			{
; 1895 : 			case CITY_BUILDABLE_BUILDING:
; 1896 : 			{
; 1897 : 				CvBuildingEntry* pEntry = GC.GetGameBuildings()->GetEntry(buildable.m_iIndex);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 1898 : 				if(pEntry != NULL)

	test	eax, eax
	je	$LN1@LogPossibl

; 1899 : 				{
; 1900 : 					strDesc = pEntry->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226893[esp+328]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1901 : 					strTemp.Format("Building, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	lea	ecx, DWORD PTR _strDesc$226893[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	mov	ecx, ebp
	mov	DWORD PTR $T236805[esp+332], eax
	call	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
	mov	ecx, DWORD PTR $T236805[esp+328]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strTemp$226890[esp+336]
	push	OFFSET $SG226915
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1902 : 				}
; 1903 : 			}
; 1904 : 			break;

	jmp	$LN131@LogPossibl
$LN10@LogPossibl:

; 1905 : 			case CITY_BUILDABLE_UNIT:
; 1906 : 			{
; 1907 : 				CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry

; 1908 : 				if(pEntry != NULL)

	test	eax, eax
	je	$LN1@LogPossibl

; 1909 : 				{
; 1910 : 					strDesc = pEntry->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226893[esp+328]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1911 : 					strTemp.Format("Unit, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	lea	ecx, DWORD PTR _strDesc$226893[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	mov	ecx, ebp
	mov	DWORD PTR $T236812[esp+332], eax
	call	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
	push	eax
	mov	eax, DWORD PTR $T236812[esp+332]
	push	eax
	lea	ecx, DWORD PTR _strTemp$226890[esp+336]
	push	OFFSET $SG226919
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1912 : 				}
; 1913 : 			}
; 1914 : 			break;

	jmp	$LN131@LogPossibl
$LN8@LogPossibl:

; 1915 : 			case CITY_BUILDABLE_PROJECT:
; 1916 : 			{
; 1917 : 				CvProjectEntry* pEntry = GC.GetGameProjects()->GetEntry(buildable.m_iIndex);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ; CvProjectXMLEntries::GetEntry

; 1918 : 				if(pEntry != NULL)

	test	eax, eax
	je	$LN1@LogPossibl

; 1919 : 				{
; 1920 : 					strDesc = pEntry->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226893[esp+328]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1921 : 					strTemp.Format("Project, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	lea	ecx, DWORD PTR _strDesc$226893[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	mov	ecx, ebp
	mov	DWORD PTR $T236819[esp+332], eax
	call	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
	mov	edx, DWORD PTR $T236819[esp+328]
	push	eax
	push	edx
	lea	eax, DWORD PTR _strTemp$226890[esp+336]
	push	OFFSET $SG226923
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1922 : 				}
; 1923 : 			}
; 1924 : 			break;

	jmp	$LN131@LogPossibl
$LN6@LogPossibl:

; 1925 : 			case CITY_BUILDABLE_PROCESS:
; 1926 : 			{
; 1927 : 				CvProcessInfo* pProcess = GC.getProcessInfo((ProcessTypes)buildable.m_iIndex);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z ; CvGlobals::getProcessInfo

; 1928 : 				if (pProcess != NULL)

	test	eax, eax
	je	$LN1@LogPossibl

; 1929 : 				{
; 1930 : 					strDesc = pProcess->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226893[esp+328]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1931 : 					strTemp.Format("Process, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	lea	ecx, DWORD PTR _strDesc$226893[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
	push	eax
	push	ebx
	push	OFFSET $SG226928
	lea	ecx, DWORD PTR _strTemp$226890[esp+340]
	push	ecx

; 1932 : 				}
; 1933 : 			}
; 1934 : 			break;

	jmp	$LN132@LogPossibl
$LN4@LogPossibl:

; 1935 : 			case CITY_BUILDABLE_UNIT_FOR_OPERATION:
; 1936 : 			{
; 1937 : 				CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry

; 1938 : 				if(pEntry != NULL)

	test	eax, eax
	je	$LN1@LogPossibl

; 1939 : 				{
; 1940 : 					strDesc = pEntry->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226893[esp+328]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1941 : 					strTemp.Format("Operation unit, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	lea	ecx, DWORD PTR _strDesc$226893[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
	push	eax
	push	ebx
	push	OFFSET $SG226932
	lea	edx, DWORD PTR _strTemp$226890[esp+340]
	push	edx

; 1942 : 				}
; 1943 : 			}
; 1944 : 			break;

	jmp	SHORT $LN132@LogPossibl
$LN2@LogPossibl:

; 1945 : 			case CITY_BUILDABLE_UNIT_FOR_ARMY:
; 1946 : 			{
; 1947 : 				CvUnitEntry* pEntry = GC.GetGameUnits()->GetEntry(buildable.m_iIndex);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry

; 1948 : 				if(pEntry != NULL)

	test	eax, eax
	je	SHORT $LN1@LogPossibl

; 1949 : 				{
; 1950 : 					strDesc = pEntry->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDesc$226893[esp+328]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1951 : 					strTemp.Format("Army unit, %s, %d, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI), buildable.m_iTurnsToConstruct);

	lea	ecx, DWORD PTR _strDesc$226893[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetWeight@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QBEHI@Z ; CvWeightedVector<CvCityBuildable,225,1>::GetWeight
	push	eax
	push	ebx
	push	OFFSET $SG226936
	lea	eax, DWORD PTR _strTemp$226890[esp+340]
	push	eax
$LN132@LogPossibl:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	mov	ebx, DWORD PTR _this$[esp+344]
$LN131@LogPossibl:
	add	esp, 20					; 00000014H
$LN1@LogPossibl:

; 1952 : 				}
; 1953 : 			}
; 1954 : 			break;
; 1955 : 			}
; 1956 : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$226890[esp+324]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$226889[esp+328]
	push	edx
	lea	eax, DWORD PTR $T236705[esp+332]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+332], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226888[esp+328]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T236705[esp+324]
	mov	BYTE PTR __$EHRec$[esp+332], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1957 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226888[esp+324]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$226895[esp+324]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	add	DWORD PTR tv791[esp+332], 16		; 00000010H
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR [ebx+60]
	jl	$LL129@LogPossibl
	pop	ebp
$LN15@LogPossibl:

; 1958 : 		}
; 1959 : 	}

	lea	ecx, DWORD PTR _strDesc$226893[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _cityName$226892[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$226891[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$226890[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226889[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$226888[esp+320]
	mov	DWORD PTR __$EHRec$[esp+328], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
$LN18@LogPossibl:

; 1960 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+312]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 308				; 00000134H
	ret	0
	npad	1
$LN133@LogPossibl:
	DD	$LN12@LogPossibl
	DD	$LN10@LogPossibl
	DD	$LN8@LogPossibl
	DD	$LN6@LogPossibl
	DD	$LN4@LogPossibl
	DD	$LN2@LogPossibl
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$226888[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$226889[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$226890[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$226891[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _cityName$226892[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strDesc$226893[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T236700[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T236701[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T236702[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR $T236703[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR $T236704[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ$11:
	lea	ecx, DWORD PTR $T236705[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ ENDP	; CvCityStrategyAI::LogPossibleBuilds
PUBLIC	?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_yield$ = 12						; size = 4
?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z PROC ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement, COMDAT

; 2645 : 	if(pCity->GetCityStrategyAI()->GetDeficientYield() == yield)

	mov	ecx, DWORD PTR _pCity$[esp-4]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetDeficientYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetDeficientYield
	cmp	eax, DWORD PTR _yield$[esp-4]
	sete	al

; 2646 : 	{
; 2647 : 		return true;
; 2648 : 	}
; 2649 : 
; 2650 : 	return false;
; 2651 : }

	ret	0
?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ENDP ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ; CvWeightedVector<CvCityBuildable,225,1>::CvWeightedVector<CvCityBuildable,225,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::CvWeightedVector<CvCityBuildable,225,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 225			; 000000e1H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::CvWeightedVector<CvCityBuildable,225,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@2@0@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+3612], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::clear
_TEXT	ENDS
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _func$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx

; 2032 : }

	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@3@@Z
_TEXT	SEGMENT
$T237476 = -4						; size = 1
__Cat$237480 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237476[esp+4], 0
	mov	eax, DWORD PTR $T237476[esp+4]
	mov	ecx, DWORD PTR __Cat$237480[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__Tmp$237591 = -112					; size = 16
__Tmp$237518 = -96					; size = 16
__Tmp$237544 = -80					; size = 16
__Tmp$237568 = -64					; size = 16
__Tmp$237612 = -48					; size = 16
__Tmp$237632 = -32					; size = 16
__Tmp$237653 = -16					; size = 16
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 112				; 00000070H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+112]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+116]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 4
	cdq
	push	esi
	push	edi
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-16]
	shl	edi, 4
	push	eax
	add	edi, ebx
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Median<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+16]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
	npad	4
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx-4]
	cmp	eax, edx
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 16					; 00000010H
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+12]
	npad	6
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+12]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 16					; 00000010H
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	edi, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+124]
	jae	SHORT $LN103@Unguarded_
	npad	3
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [ecx+12]
	cmp	edx, ebx
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 16					; 00000010H
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$237518[esp+132], ebp
	mov	ebp, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$237518[esp+136], ebp
	mov	ebp, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$237518[esp+140], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ebp
	mov	edx, DWORD PTR __Tmp$237518[esp+132]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Tmp$237518[esp+136]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Tmp$237518[esp+140]
	mov	DWORD PTR [eax+12], edx
$LN20@Unguarded_:
	add	eax, 16					; 00000010H
	cmp	eax, DWORD PTR __Last$[esp+124]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	edi, DWORD PTR __First$[esp+124]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [edi-16]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ebx, DWORD PTR [edx+12]
	mov	ebp, DWORD PTR [ecx+12]
	cmp	ebp, ebx
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 16					; 00000010H
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$237544[esp+132], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$237544[esp+136], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$237544[esp+140], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ebp, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], ebp
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR __Tmp$237544[esp+132]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR __Tmp$237544[esp+136]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR __Tmp$237544[esp+140]
	mov	DWORD PTR [edx+12], ebx
$LN13@Unguarded_:
	sub	edi, 16					; 00000010H
	sub	edx, 16					; 00000010H
	cmp	DWORD PTR __First$[esp+124], edi
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	edi, DWORD PTR __First$[esp+124]
$LN115@Unguarded_:
	jne	$LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+124]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237568[esp+136], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$237568[esp+140], ebp
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], ebp
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR __Tmp$237568[esp+136]
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR __Tmp$237568[esp+140]
	mov	DWORD PTR [esi+12], edx
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	ebx, ecx
	add	esi, 16					; 00000010H
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ebx, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR __Tmp$237591[esp+128], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR __Tmp$237591[esp+132], ebp
	mov	ebp, DWORD PTR [ebx+8]
	mov	DWORD PTR __Tmp$237591[esp+136], ebp
	mov	ebp, DWORD PTR [ebx+12]
	mov	DWORD PTR __Tmp$237591[esp+140], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	ebp, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR [edx+12]
	mov	DWORD PTR [ebx+12], ebp
	mov	ebx, DWORD PTR __Tmp$237591[esp+128]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR __Tmp$237591[esp+132]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR __Tmp$237591[esp+136]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR __Tmp$237591[esp+140]
	mov	DWORD PTR [edx+12], ebx
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	edi, 16					; 00000010H
	cmp	eax, DWORD PTR __Last$[esp+124]
	jne	$LN3@Unguarded_
	sub	ecx, 16					; 00000010H
	cmp	edi, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$237612[esp+136], ebp
	mov	ebp, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$237612[esp+140], ebp
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [edi+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [edi+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Tmp$237612[esp+136]
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR __Tmp$237612[esp+140]
	mov	DWORD PTR [ecx+12], edx
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 16					; 00000010H
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237632[esp+136], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$237632[esp+140], ebp
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], ebp
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR __Tmp$237632[esp+136]
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR __Tmp$237632[esp+140]
	mov	DWORD PTR [esi+12], edx

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, edi
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$237653[esp+136], ebp
	mov	ebp, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$237653[esp+140], ebp
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR __Tmp$237653[esp+136]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], edx
	mov	edx, DWORD PTR __Tmp$237653[esp+140]
	mov	DWORD PTR [edi+12], edx
$LN92@Unguarded_:
	add	eax, 16					; 00000010H

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+124]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 112				; 00000070H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -16				; fffffff0H
	cmp	edx, 16					; 00000010H
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Insertion_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Insertion_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Insertion_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z
_TEXT	SEGMENT
$T237699 = -4						; size = 1
$T237706 = -4						; size = 4
$T237702 = -4						; size = 4
__Cat$237711 = 8					; size = 1
$T237701 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z PROC ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T237706[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$237711[esp+4]
	mov	edx, DWORD PTR $T237701[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T237699[esp+12], bl
	mov	eax, DWORD PTR $T237699[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T237702[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAEV?$_Temp_iterator@E@std@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,std::_Temp_iterator<unsigned char>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@7:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ENDP ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T237750 = -4						; size = 1
$T237751 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$unchecked_merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::unchecked_merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Pred$[esp]
	mov	BYTE PTR $T237750[esp+4], 0
	mov	eax, DWORD PTR $T237750[esp+4]
	mov	ecx, DWORD PTR $T237751[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>

; 5160 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$unchecked_merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::unchecked_merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z ; std::_Buffered_rotate<unsigned char *,int,unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z
_TEXT	SEGMENT
$T237762 = -20						; size = 20
$T237760 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T237761 = 20						; size = 4
$T237759 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z PROC ; std::_Buffered_rotate<unsigned char *,int,unsigned char>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T237759[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T237760[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	mov	eax, DWORD PTR $T237760[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edi, DWORD PTR __Last$[esp+32]
	mov	eax, edi
	sub	eax, ebx
	test	eax, eax
	jle	SHORT $LN108@Buffered_r
	push	eax
	push	ebx
	push	eax
	push	ebp
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN108@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	sub	eax, ecx
	sub	edi, eax
	test	eax, eax
	jle	SHORT $LN46@Buffered_r
	push	eax
	push	ecx
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN46@Buffered_r:
	mov	eax, edi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	ebx, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Last$[esp+32]
	mov	edi, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T237761[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T237762[esp+60]
	push	edi
	push	eax
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	mov	eax, DWORD PTR $T237762[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN63@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN63@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	ebx, DWORD PTR __First$[esp+32]
	sub	edi, ebx
	mov	eax, edi
	mov	edi, DWORD PTR __imp__memmove_s
	test	eax, eax
	jle	SHORT $LN71@Buffered_r
	push	eax
	push	ebx
	push	eax
	sub	ebp, eax
	push	ebp
	call	edi
	add	esp, 16					; 00000010H
$LN71@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	sub	eax, ecx
	lea	esi, DWORD PTR [eax+ebx]
	test	eax, eax
	jle	SHORT $LN84@Buffered_r
	push	eax
	push	ecx
	push	eax
	push	ebx
	call	edi
	add	esp, 16					; 00000010H
$LN84@Buffered_r:
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN92@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN92@Buffered_r
	push	0
	push	0
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAEHE@std@@YAXPAE00PAH0@Z	; std::_Rotate<unsigned char *,int,unsigned char>
	add	esp, 20					; 00000014H
$LN92@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	eax, DWORD PTR [esi+ebx]
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z ENDP ; std::_Buffered_rotate<unsigned char *,int,unsigned char>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::pop_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -16				; fffffff0H
	cmp	edx, 16					; 00000010H
	jle	SHORT $LN1@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	push	0
	push	eax
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN1@pop_heap:

; 2099 : 	}

	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T238114 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T238190 = 24						; size = 1
$T238191 = 24						; size = 1
$T238115 = 24						; size = 1
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	ebp
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+4]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, ecx
	jg	SHORT $LN3@Chunked_me
	push	ebx
	push	esi
	npad	5
$LL46@Chunked_me:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T238114[esp+12], 0
	mov	ebx, DWORD PTR $T238114[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T238115[esp+16]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+20]
	push	ebx
	lea	ecx, DWORD PTR [edx+edi]
	push	eax
	lea	esi, DWORD PTR [ecx+edi]
	push	esi
	push	ecx
	push	ecx
	push	edx
	call	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR __Count$[esp+44]
	sub	ecx, ebp
	add	esp, 32					; 00000020H
	cmp	ecx, ebp

; 3443 : 		_First = _Mid2;

	mov	edx, esi
	mov	DWORD PTR __Count$[esp+12], ecx
	jge	SHORT $LL46@Chunked_me
	pop	esi
	pop	ebx
$LN3@Chunked_me:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	ecx, edi
	jg	SHORT $LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN39@Chunked_me
	push	ecx
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	ret	0
$LN2@Chunked_me:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T238190[esp+4], 0
	mov	ecx, DWORD PTR $T238190[esp+4]
	push	ecx
	mov	ecx, DWORD PTR $T238191[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Pred$[esp+12]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	eax
	add	edi, edx
	push	edi
	push	edi
	push	edx
	call	??$_Merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@std@@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
$LN39@Chunked_me:
	pop	edi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	ret	0
??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T238214 = -24						; size = 4
$T238207 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T238206 = 12						; size = 4
__First1$ = 12						; size = 4
$T238208 = 16						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebx, DWORD PTR __First2$[esp+24]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First1$[esp+32]
	xor	ebp, ebp
	push	edi
	mov	DWORD PTR $T238214[esp+40], ebp
	cmp	esi, DWORD PTR __Last1$[esp+36]
	je	SHORT $LN80@Merge@2
	lea	edi, DWORD PTR [ebp+1]
	npad	2
$LL4@Merge@2:
	cmp	ebx, DWORD PTR __Last2$[esp+36]
	je	SHORT $LN80@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	cl, BYTE PTR [ebx]
	mov	dl, BYTE PTR [esi]
	cmp	cl, dl
	jbe	SHORT $LN2@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN21@Merge@2
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	add	ebx, edi

; 2600 : 		else

	jmp	SHORT $LN1@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

$LN21@Merge@2:
	cmp	eax, ebp
	je	SHORT $LN26@Merge@2
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN26@Merge@2:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
	add	ebx, edi

; 2600 : 		else

	jmp	SHORT $LN1@Merge@2
$LN2@Merge@2:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN33@Merge@2
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	jmp	SHORT $LN32@Merge@2
$LN33@Merge@2:
	cmp	eax, ebp
	je	SHORT $LN38@Merge@2
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR __Dest$[esp+52]
$LN38@Merge@2:
	add	DWORD PTR [ecx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN32@Merge@2:
	add	esi, edi
$LN1@Merge@2:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, DWORD PTR __Last1$[esp+36]
	jne	SHORT $LL4@Merge@2
$LN80@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Last1$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR $T238206[esp+56], esp
	push	edx
	mov	DWORD PTR [eax+16], ecx
	lea	eax, DWORD PTR $T238207[esp+64]
	push	esi
	push	eax
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T238207[esp+72]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebp
	je	SHORT $LN56@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+56]
	mov	DWORD PTR $T238208[esp+56], esp
	push	eax
	push	ebx
	push	esi
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN77@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@Merge@2:

; 2605 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??_7CvCityStrategyAI@@6B@			; CvCityStrategyAI::`vftable'
PUBLIC	??0CvCityStrategyAI@@QAE@XZ			; CvCityStrategyAI::CvCityStrategyAI
PUBLIC	??_R4CvCityStrategyAI@@6B@			; CvCityStrategyAI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvCityStrategyAI@@@8			; CvCityStrategyAI `RTTI Type Descriptor'
PUBLIC	??_R3CvCityStrategyAI@@8			; CvCityStrategyAI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvCityStrategyAI@@8			; CvCityStrategyAI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvCityStrategyAI@@8		; CvCityStrategyAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvFlavorRecipient@@8		; CvFlavorRecipient::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvFlavorRecipient@@@8			; CvFlavorRecipient `RTTI Type Descriptor'
PUBLIC	??_R3CvFlavorRecipient@@8			; CvFlavorRecipient::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvFlavorRecipient@@8			; CvFlavorRecipient::`RTTI Base Class Array'
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
;	COMDAT ??_R2CvFlavorRecipient@@8
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
rdata$r	SEGMENT
??_R2CvFlavorRecipient@@8 DD FLAT:??_R1A@?0A@EA@CvFlavorRecipient@@8 ; CvFlavorRecipient::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R3CvFlavorRecipient@@8 DD 00H			; CvFlavorRecipient::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvFlavorRecipient@@@8
_DATA	SEGMENT
??_R0?AVCvFlavorRecipient@@@8 DD FLAT:??_7type_info@@6B@ ; CvFlavorRecipient `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvFlavorRecipient@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvFlavorRecipient@@8 DD FLAT:??_R0?AVCvFlavorRecipient@@@8 ; CvFlavorRecipient::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvCityStrategyAI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvCityStrategyAI@@8 DD FLAT:??_R0?AVCvCityStrategyAI@@@8 ; CvCityStrategyAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvCityStrategyAI@@8
rdata$r	ENDS
;	COMDAT ??_R2CvCityStrategyAI@@8
rdata$r	SEGMENT
??_R2CvCityStrategyAI@@8 DD FLAT:??_R1A@?0A@EA@CvCityStrategyAI@@8 ; CvCityStrategyAI::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R3CvCityStrategyAI@@8
rdata$r	SEGMENT
??_R3CvCityStrategyAI@@8 DD 00H				; CvCityStrategyAI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvCityStrategyAI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvCityStrategyAI@@@8
_DATA	SEGMENT
??_R0?AVCvCityStrategyAI@@@8 DD FLAT:??_7type_info@@6B@	; CvCityStrategyAI `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvCityStrategyAI@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvCityStrategyAI@@6B@
rdata$r	SEGMENT
??_R4CvCityStrategyAI@@6B@ DD 00H			; CvCityStrategyAI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvCityStrategyAI@@@8
	DD	FLAT:??_R3CvCityStrategyAI@@8
rdata$r	ENDS
;	COMDAT ??_7CvCityStrategyAI@@6B@
CONST	SEGMENT
??_7CvCityStrategyAI@@6B@ DD FLAT:??_R4CvCityStrategyAI@@6B@ ; CvCityStrategyAI::`vftable'
	DD	FLAT:?Init@CvFlavorRecipient@@UAEXXZ
	DD	FLAT:?Uninit@CvCityStrategyAI@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvCityStrategyAI@@UAEXXZ
	DD	FLAT:?LogFlavors@CvCityStrategyAI@@EAEXW4FlavorTypes@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvCityStrategyAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCityStrategyAI@@QAE@XZ$0
__ehfuncinfo$??0CvCityStrategyAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvCityStrategyAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvCityStrategyAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCityStrategyAI@@QAE@XZ PROC			; CvCityStrategyAI::CvCityStrategyAI, COMDAT
; _this$ = ecx

; 258  : {

	push	-1
	push	__ehhandler$??0CvCityStrategyAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient

; 259  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	xor	eax, eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvCityStrategyAI@@6B@
	mov	DWORD PTR [esi+60], eax
	lea	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+64], 225			; 000000e1H
	mov	DWORD PTR [esi+3696], -1
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCityStrategyAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
__ehhandler$??0CvCityStrategyAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvCityStrategyAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCityStrategyAI@@QAE@XZ ENDP			; CvCityStrategyAI::CvCityStrategyAI
PUBLIC	??1CvCityStrategyAI@@QAE@XZ			; CvCityStrategyAI::~CvCityStrategyAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvCityStrategyAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$1
__ehfuncinfo$??1CvCityStrategyAI@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvCityStrategyAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvCityStrategyAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvCityStrategyAI@@QAE@XZ PROC			; CvCityStrategyAI::~CvCityStrategyAI, COMDAT
; _this$ = ecx

; 263  : {

	push	-1
	push	__ehhandler$??1CvCityStrategyAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvCityStrategyAI@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], 1

; 264  : 	Uninit();

	call	?Uninit@CvCityStrategyAI@@UAEXXZ	; CvCityStrategyAI::Uninit

; 265  : }

	mov	eax, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [esi+68]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	cmp	eax, ecx
	je	SHORT $LN10@CvCityStra
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN10@CvCityStra:
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
__unwindfunclet$??1CvCityStrategyAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE@XZ ; CvWeightedVector<CvCityBuildable,225,1>::~CvWeightedVector<CvCityBuildable,225,1>
__ehhandler$??1CvCityStrategyAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvCityStrategyAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvCityStrategyAI@@QAE@XZ ENDP			; CvCityStrategyAI::~CvCityStrategyAI
PUBLIC	?DoTurn@CvCityStrategyAI@@QAEXXZ		; CvCityStrategyAI::DoTurn
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoTurn@CvCityStrategyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$1
__ehfuncinfo$?DoTurn@CvCityStrategyAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoTurn@CvCityStrategyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?DoTurn@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_bTestCityStrategyStart$226448 = -59			; size = 1
_bTestCityStrategyEnd$226455 = -58			; size = 1
_bResult$226605 = -57					; size = 1
_iCityStrategiesLoop$ = -56				; size = 4
_args$226604 = -52					; size = 4
_pCityStrategy$226446 = -48				; size = 4
_iNumFlavors$226636 = -44				; size = 4
_iNumFlavors$226623 = -44				; size = 4
_strStrategyName$226468 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?DoTurn@CvCityStrategyAI@@QAEXXZ PROC			; CvCityStrategyAI::DoTurn, COMDAT
; _this$ = ecx

; 1221 : {

	push	-1
	push	__ehhandler$?DoTurn@CvCityStrategyAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	mov	esi, ecx

; 1222 : 	AI_PERF_FORMAT("City-AI-perf.csv", ("CvCityStrategyAI::DoTurn, Turn %03d, %s, %s", GC.getGame().getElapsedGameTurns(), m_pCity->GetPlayer()->getCivilizationShortDescription(), m_pCity->getName().c_str()) );
; 1223 : 
; 1224 : 	int iCityStrategiesLoop = 0;
; 1225 : 
; 1226 : 	// Loop through all CityStrategies
; 1227 : 	for(iCityStrategiesLoop = 0; iCityStrategiesLoop < GetAICityStrategies()->GetNumAICityStrategies(); iCityStrategiesLoop++)

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	ebx, ebx
	mov	DWORD PTR _iCityStrategiesLoop$[esp+68], ebx
	test	ecx, -4					; fffffffcH
	jle	$LN132@DoTurn
	push	ebp
	push	edi
	jmp	SHORT $LN134@DoTurn
	npad	5
$LL423@DoTurn:
	mov	ebx, DWORD PTR _iCityStrategiesLoop$[esp+76]
$LN134@DoTurn:

; 1228 : 	{
; 1229 : 		AICityStrategyTypes eCityStrategy = (AICityStrategyTypes) iCityStrategiesLoop;
; 1230 : 		CvAICityStrategyEntry* pCityStrategy = GetAICityStrategies()->GetEntry(iCityStrategiesLoop);

	mov	edx, DWORD PTR [eax+4]

; 1231 : 
; 1232 : 		// Minor Civs can't run some Strategies
; 1233 : 		if(GET_PLAYER(GetCity()->getOwner()).isMinorCiv() && pCityStrategy->IsNoMinorCivs())

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+84]
	mov	ebp, DWORD PTR [edx+ebx*4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pCityStrategy$226446[esp+76], ebp
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN131@DoTurn
	cmp	BYTE PTR [ebp+288], 0
	jne	$LN133@DoTurn
	mov	ebx, DWORD PTR _iCityStrategiesLoop$[esp+76]
$LN131@DoTurn:

; 1234 : 		{
; 1235 : 			continue;
; 1236 : 		}
; 1237 : 
; 1238 : 		bool bTestCityStrategyStart = true;
; 1239 : 
; 1240 : 		// Do we already have this CityStrategy adopted?
; 1241 : 		if(IsUsingCityStrategy(eCityStrategy))

	mov	eax, DWORD PTR [esi+28]
	cmp	BYTE PTR [ebx+eax], 0
	mov	BYTE PTR _bTestCityStrategyStart$226448[esp+76], 1

; 1242 : 		{
; 1243 : 			bTestCityStrategyStart = false;
; 1244 : 		}
; 1245 : 		else

	jne	SHORT $LN429@DoTurn

; 1246 : 		{
; 1247 : 			// Has the prereq Tech necessary?
; 1248 : 			if(pCityStrategy->GetTechPrereq() != NO_TECH && !GET_TEAM(GetCity()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pCityStrategy->GetTechPrereq()))

	mov	edi, DWORD PTR [ebp+272]
	cmp	edi, -1
	je	SHORT $LN424@DoTurn
	mov	ecx, DWORD PTR [esi+12]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 1249 : 			{
; 1250 : 				bTestCityStrategyStart = false;
; 1251 : 			}
; 1252 : 
; 1253 : 			// Has the Tech which obsoletes this Strategy?
; 1254 : 			if(bTestCityStrategyStart && pCityStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetCity()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pCityStrategy->GetTechObsolete()))

	je	SHORT $LN429@DoTurn
$LN424@DoTurn:
	mov	edi, DWORD PTR [ebp+276]
	cmp	edi, -1
	je	SHORT $LN425@DoTurn
	mov	ecx, DWORD PTR [esi+12]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN425@DoTurn
$LN429@DoTurn:

; 1255 : 			{
; 1256 : 				bTestCityStrategyStart = false;

	mov	BYTE PTR _bTestCityStrategyStart$226448[esp+76], 0
$LN425@DoTurn:

; 1257 : 			}
; 1258 : 		}
; 1259 : 
; 1260 : 		bool bTestCityStrategyEnd = false;
; 1261 : 
; 1262 : 		// CityStrategy is active, check to see if we should even try to disable it
; 1263 : 		if(IsUsingCityStrategy(eCityStrategy))

	mov	ecx, DWORD PTR [esi+28]
	cmp	BYTE PTR [ebx+ecx], 0
	mov	BYTE PTR _bTestCityStrategyEnd$226455[esp+76], 0
	je	SHORT $LN422@DoTurn

; 1264 : 		{
; 1265 : 			// If Strategy is Permanent we can't ever turn it off
; 1266 : 			if(!pCityStrategy->IsPermanent())

	cmp	BYTE PTR [ebp+289], 0
	jne	SHORT $LN422@DoTurn

; 1267 : 			{
; 1268 : 				if(pCityStrategy->GetCheckTriggerTurnCount() > 0)

	mov	edi, DWORD PTR [ebp+284]
	test	edi, edi
	jle	SHORT $LN422@DoTurn

; 1269 : 				{
; 1270 : 					// Is it a turn where we want to check to see if this Strategy is maintained?
; 1271 : 					if((GC.getGame().getGameTurn() - GetTurnCityStrategyAdopted(eCityStrategy)) % pCityStrategy->GetCheckTriggerTurnCount() == 0)

	mov	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR _iCityStrategiesLoop$[esp+76]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edx+eax*4]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, ebx
	cdq
	idiv	edi
	test	edx, edx
	jne	SHORT $LN422@DoTurn

; 1272 : 					{
; 1273 : 						bTestCityStrategyEnd = true;
; 1274 : 					}
; 1275 : 				}
; 1276 : 
; 1277 : 				if(bTestCityStrategyEnd && pCityStrategy->GetMinimumNumTurnsExecuted() > 0)

	mov	edi, DWORD PTR [ebp+280]
	mov	BYTE PTR _bTestCityStrategyEnd$226455[esp+76], 1
	test	edi, edi
	jle	SHORT $LN422@DoTurn

; 1278 : 				{
; 1279 : 					// Has the minimum # of turns passed for this Strategy?
; 1280 : 					if(GC.getGame().getGameTurn() < GetTurnCityStrategyAdopted(eCityStrategy) + pCityStrategy->GetMinimumNumTurnsExecuted())

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR _iCityStrategiesLoop$[esp+76]
	mov	ebx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebx, edi
	cmp	eax, ebx
	jge	SHORT $LN422@DoTurn

; 1281 : 					{
; 1282 : 						bTestCityStrategyEnd = false;

	mov	BYTE PTR _bTestCityStrategyEnd$226455[esp+76], 0
$LN422@DoTurn:

; 1283 : 					}
; 1284 : 				}
; 1285 : 			}
; 1286 : 		}
; 1287 : 
; 1288 : 		// Check CityStrategy Triggers
; 1289 : 		// Functionality and existence of specific CityStrategies is hardcoded here, but data is stored in XML so it's easier to modify
; 1290 : 
; 1291 : 		if(bTestCityStrategyStart || bTestCityStrategyEnd)

	cmp	BYTE PTR _bTestCityStrategyStart$226448[esp+76], 0
	jne	SHORT $LN119@DoTurn
	cmp	BYTE PTR _bTestCityStrategyEnd$226455[esp+76], 0
	je	$LN133@DoTurn
$LN119@DoTurn:

; 1292 : 		{
; 1293 : 			bool bStrategyShouldBeActive = false;
; 1294 : 
; 1295 : 			// Has the Tech which obsoletes this Strategy? If so, Strategy should be deactivated regardless of other factors
; 1296 : 			if(pCityStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetCity()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pCityStrategy->GetTechObsolete()))

	mov	edi, DWORD PTR [ebp+276]
	xor	bl, bl
	cmp	edi, -1
	je	SHORT $LN118@DoTurn
	mov	ecx, DWORD PTR [esi+12]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 1297 : 			{
; 1298 : 				bStrategyShouldBeActive = false;
; 1299 : 			}
; 1300 : 			// Strategy isn't obsolete, so test triggers as normal
; 1301 : 			else

	jne	$LN420@DoTurn
$LN118@DoTurn:

; 1302 : 			{
; 1303 : 				CvString strStrategyName = (CvString) pCityStrategy->GetType();

	lea	ecx, DWORD PTR [ebp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN212@DoTurn
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN212@DoTurn:
	push	eax
	lea	ecx, DWORD PTR _strStrategyName$226468[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1304 : 
; 1305 : 				// Check all of the CityStrategy Triggers
; 1306 : 				if(strStrategyName == "AICITYSTRATEGY_TINY_CITY")

	mov	edi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226472
	push	eax
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN116@DoTurn

; 1307 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_TinyCity(GetCity());

	mov	ecx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2320
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, edi
	setl	bl
	jmp	$LN419@DoTurn
$LN116@DoTurn:

; 1308 : 				else if(strStrategyName == "AICITYSTRATEGY_SMALL_CITY")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226475
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN114@DoTurn

; 1309 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_SmallCity(GetCity());

	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2320
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, ebx
	jl	SHORT $LN223@DoTurn
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2324
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, ebx
	jge	SHORT $LN223@DoTurn
	mov	bl, 1
	jmp	$LN419@DoTurn
$LN223@DoTurn:
	xor	bl, bl
	jmp	$LN419@DoTurn
$LN114@DoTurn:

; 1310 : 				else if(strStrategyName == "AICITYSTRATEGY_MEDIUM_CITY")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226478
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN112@DoTurn

; 1311 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_MediumCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_MediumCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCity
	jmp	$LN430@DoTurn
$LN112@DoTurn:

; 1312 : 				else if(strStrategyName == "AICITYSTRATEGY_LARGE_CITY")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226481
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN110@DoTurn

; 1313 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_LargeCity(GetCity());

	mov	ecx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2328
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, edi
	setge	bl
	jmp	$LN419@DoTurn
$LN110@DoTurn:

; 1314 : 				else if(strStrategyName == "AICITYSTRATEGY_LANDLOCKED")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226484
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN108@DoTurn

; 1315 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_Landlocked(GetCity());

	mov	ecx, DWORD PTR [esi+12]
	push	-1
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	sete	bl
	jmp	$LN419@DoTurn
$LN108@DoTurn:

; 1316 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_TILE_IMPROVERS")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226487
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN106@DoTurn

; 1317 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers(eCityStrategy, GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	eax, DWORD PTR _iCityStrategiesLoop$[esp+80]
	push	eax
	call	?IsTestCityStrategy_NeedTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTileImprovers
	add	esp, 8
	jmp	$LN431@DoTurn
$LN106@DoTurn:

; 1318 : 				else if(strStrategyName == "AICITYSTRATEGY_WANT_TILE_IMPROVERS")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226490
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN104@DoTurn

; 1319 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers(eCityStrategy, GetCity());

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR _iCityStrategiesLoop$[esp+76]
	push	eax
	push	edx
	call	?IsTestCityStrategy_WantTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_WantTileImprovers
	add	esp, 8
	jmp	$LN431@DoTurn
$LN104@DoTurn:

; 1320 : 				else if(strStrategyName == "AICITYSTRATEGY_ENOUGH_TILE_IMPROVERS")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226493
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN102@DoTurn

; 1321 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers(eCityStrategy, GetCity());

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _iCityStrategiesLoop$[esp+76]
	push	eax
	push	ecx
	call	?IsTestCityStrategy_EnoughTileImprovers@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughTileImprovers
	add	esp, 8
	jmp	$LN431@DoTurn
$LN102@DoTurn:

; 1322 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_NAVAL_GROWTH")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226496
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN100@DoTurn

; 1323 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth(eCityStrategy, GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	eax, DWORD PTR _iCityStrategiesLoop$[esp+80]
	push	eax
	call	?IsTestCityStrategy_NeedNavalGrowth@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalGrowth
	add	esp, 8
	jmp	$LN431@DoTurn
$LN100@DoTurn:

; 1324 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226499
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN98@DoTurn

; 1325 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_NeedNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedNavalTileImprovement
	jmp	$LN430@DoTurn
$LN98@DoTurn:

; 1326 : 				else if(strStrategyName == "AICITYSTRATEGY_ENOUGH_NAVAL_TILE_IMPROVEMENT")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226502
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN96@DoTurn

; 1327 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_EnoughNavalTileImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_EnoughNavalTileImprovement
	jmp	$LN430@DoTurn
$LN96@DoTurn:

; 1328 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_IMPROVEMENT_FOOD")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226505
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN94@DoTurn

; 1329 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement(GetCity(), YIELD_FOOD);

	mov	eax, DWORD PTR [esi+12]
	push	0
	push	eax
	call	?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
	add	esp, 8
	jmp	$LN431@DoTurn
$LN94@DoTurn:

; 1330 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_IMPROVEMENT_PRODUCTION")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226508
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN92@DoTurn

; 1331 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement(GetCity(), YIELD_PRODUCTION);

	mov	eax, DWORD PTR [esi+12]
	push	1
	push	eax
	call	?IsTestCityStrategy_NeedImprovement@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4YieldTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedImprovement
	add	esp, 8
	jmp	$LN431@DoTurn
$LN92@DoTurn:

; 1332 : 				else if(strStrategyName == "AICITYSTRATEGY_HAVE_TRAINING_FACILITY")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226511
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN90@DoTurn

; 1333 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_HaveTrainingFacility@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HaveTrainingFacility
	jmp	$LN430@DoTurn
$LN90@DoTurn:

; 1334 : 				else if(strStrategyName == "AICITYSTRATEGY_CAPITAL_NEED_SETTLER")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226514
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN88@DoTurn

; 1335 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler(eCityStrategy, GetCity());

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _iCityStrategiesLoop$[esp+76]
	push	eax
	push	ecx
	call	?IsTestCityStrategy_CapitalNeedSettler@CityStrategyAIHelpers@@YA_NW4AICityStrategyTypes@@PAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalNeedSettler
	add	esp, 8
	jmp	$LN431@DoTurn
$LN88@DoTurn:

; 1336 : 				else if(strStrategyName == "AICITYSTRATEGY_CAPITAL_UNDER_THREAT")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226517
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN86@DoTurn

; 1337 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_CapitalUnderThreat@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CapitalUnderThreat
	jmp	$LN430@DoTurn
$LN86@DoTurn:

; 1338 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_CULTURE_BUILDING_EMERGENCY")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226520
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN84@DoTurn

; 1339 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_FirstCultureBuildingEmergency@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuildingEmergency
	jmp	$LN430@DoTurn
$LN84@DoTurn:

; 1340 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_CULTURE_BUILDING")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226523
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN82@DoTurn

; 1341 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_FirstCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstCultureBuilding
	jmp	$LN430@DoTurn
$LN82@DoTurn:

; 1342 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_SCIENCE_BUILDING")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226526
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN80@DoTurn

; 1343 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_FirstScienceBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstScienceBuilding
	jmp	$LN430@DoTurn
$LN80@DoTurn:

; 1344 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_GOLD_BUILDING")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226529
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN78@DoTurn

; 1345 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_FirstGoldBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstGoldBuilding
	jmp	$LN430@DoTurn
$LN78@DoTurn:

; 1346 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_FAITH_BUILDING")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226532
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN76@DoTurn

; 1347 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_FirstFaithBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstFaithBuilding
	jmp	$LN430@DoTurn
$LN76@DoTurn:

; 1348 : 				else if(strStrategyName == "AICITYSTRATEGY_FIRST_PRODUCTION_BUILDING")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226535
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN74@DoTurn

; 1349 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_FirstProductionBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_FirstProductionBuilding
	jmp	$LN430@DoTurn
$LN74@DoTurn:

; 1350 : 				else if(strStrategyName == "AICITYSTRATEGY_UNDER_BLOCKADE")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226538
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN72@DoTurn

; 1351 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_UnderBlockade@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_UnderBlockade
	jmp	$LN430@DoTurn
$LN72@DoTurn:

; 1352 : 				else if(strStrategyName == "AICITYSTRATEGY_IS_PUPPET")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226541
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN70@DoTurn

; 1353 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_IsPuppet(GetCity());

	mov	ecx, DWORD PTR [esi+12]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	setne	bl
	jmp	$LN419@DoTurn
$LN70@DoTurn:

; 1354 : 				else if(strStrategyName == "AICITYSTRATEGY_MEDIUM_CITY_HIGH_DIFFICULTY")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226544
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN68@DoTurn

; 1355 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_MediumCityHighDifficulty@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MediumCityHighDifficulty
	jmp	$LN430@DoTurn
$LN68@DoTurn:

; 1356 : 				else if(strStrategyName == "AICITYSTRATEGY_ORIGINAL_CAPITAL")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226547
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN66@DoTurn

; 1357 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_OriginalCapital(GetCity());

	mov	ecx, DWORD PTR [esi+12]
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	test	al, al
	setne	bl
	jmp	$LN419@DoTurn
$LN66@DoTurn:

; 1358 : 
; 1359 : 				else if(strStrategyName == "AICITYSTRATEGY_RIVER_CITY")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226550
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN64@DoTurn

; 1360 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_RiverCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_RiverCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_RiverCity
	jmp	$LN430@DoTurn
$LN64@DoTurn:

; 1361 : 				else if(strStrategyName == "AICITYSTRATEGY_MOUNTAIN_CITY")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226553
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN62@DoTurn

; 1362 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_MountainCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_MountainCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_MountainCity
	jmp	$LN430@DoTurn
$LN62@DoTurn:

; 1363 : 				else if(strStrategyName == "AICITYSTRATEGY_FOREST_CITY")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226556
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN60@DoTurn

; 1364 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_ForestCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_ForestCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ForestCity
	jmp	$LN430@DoTurn
$LN60@DoTurn:

; 1365 : 				else if(strStrategyName == "AICITYSTRATEGY_HILL_CITY")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226559
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN58@DoTurn

; 1366 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_HillCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_HillCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_HillCity
	jmp	$LN430@DoTurn
$LN58@DoTurn:

; 1367 : 				else if(strStrategyName == "AICITYSTRATEGY_JUNGLE_CITY")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226562
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN56@DoTurn

; 1368 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_JungleCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_JungleCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_JungleCity
	jmp	$LN430@DoTurn
$LN56@DoTurn:

; 1369 : 				else if(strStrategyName == "AICITYSTRATEGY_COAST_CITY")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226565
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN54@DoTurn

; 1370 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_CoastCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_CoastCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_CoastCity
	jmp	$LN430@DoTurn
$LN54@DoTurn:

; 1371 : 				else if(strStrategyName == "AICITYSTRATEGY_MANY_TECHS_STOLEN")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226568
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN52@DoTurn

; 1372 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_ManyTechsStolen@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_ManyTechsStolen
	jmp	$LN430@DoTurn
$LN52@DoTurn:

; 1373 : 				else if(strStrategyName == "AICITYSTRATEGY_KEY_SCIENCE_CITY")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226571
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN50@DoTurn

; 1374 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_KeyScienceCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_KeyScienceCity
	jmp	$LN430@DoTurn
$LN50@DoTurn:

; 1375 : 				else if(strStrategyName == "AICITYSTRATEGY_GOOD_GP_CITY")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226574
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN48@DoTurn

; 1376 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_GoodGPCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodGPCity
	jmp	$LN430@DoTurn
$LN48@DoTurn:

; 1377 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_INTERNATIONAL_LAND_TRADE_ROUTE")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226577
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN46@DoTurn

; 1378 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute(GetCity(), DOMAIN_LAND);

	mov	eax, DWORD PTR [esi+12]
	push	2
	push	eax
	call	?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
	add	esp, 8
	jmp	$LN431@DoTurn
$LN46@DoTurn:

; 1379 : 				else if(strStrategyName == "AICITYSTRATEGY_NO_NEED_INTERNATIONAL_LAND_TRADE_ROUTE")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226580
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN44@DoTurn

; 1380 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute(GetCity(), DOMAIN_LAND);

	mov	eax, DWORD PTR [esi+12]
	push	2
	push	eax
	call	?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
	add	esp, 8
	jmp	$LN431@DoTurn
$LN44@DoTurn:

; 1381 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_INTERNATIONAL_SEA_TRADE_ROUTE")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226583
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN42@DoTurn

; 1382 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute(GetCity(), DOMAIN_SEA);

	mov	eax, DWORD PTR [esi+12]
	push	0
	push	eax
	call	?IsTestCityStrategy_NeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedInternationalTradeRoute
	add	esp, 8
	jmp	$LN431@DoTurn
$LN42@DoTurn:

; 1383 : 				else if(strStrategyName == "AICITYSTRATEGY_NO_NEED_INTERNATIONAL_SEA_TRADE_ROUTE")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226586
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN40@DoTurn

; 1384 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute(GetCity(), DOMAIN_SEA);

	mov	eax, DWORD PTR [esi+12]
	push	0
	push	eax
	call	?IsTestCityStrategy_NoNeedInternationalTradeRoute@CityStrategyAIHelpers@@YA_NPAVCvCity@@W4DomainTypes@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NoNeedInternationalTradeRoute
	add	esp, 8
	jmp	$LN431@DoTurn
$LN40@DoTurn:

; 1385 : 				else if(strStrategyName == "AICITYSTRATEGY_INTERNATIONAL_TRADE_DESTINATION")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226589
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN38@DoTurn

; 1386 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_IsInternationalTradeDestination@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeDestination
	jmp	SHORT $LN430@DoTurn
$LN38@DoTurn:

; 1387 : 				else if(strStrategyName == "AICITYSTRATEGY_INTERNATIONAL_TRADE_ORIGIN")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226592
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN36@DoTurn

; 1388 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_IsInternationalTradeOrigin@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_IsInternationalTradeOrigin
	jmp	SHORT $LN430@DoTurn
$LN36@DoTurn:

; 1389 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_CULTURE_BUILDING")

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226595
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN34@DoTurn

; 1390 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_NeedCultureBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedCultureBuilding
	jmp	SHORT $LN430@DoTurn
$LN34@DoTurn:

; 1391 : 				else if(strStrategyName == "AICITYSTRATEGY_NEED_TOURISM_BUILDING")

	lea	edx, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226598
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN32@DoTurn

; 1392 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_NeedTourismBuilding@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_NeedTourismBuilding
	jmp	SHORT $LN430@DoTurn
$LN32@DoTurn:

; 1393 : 				else if(strStrategyName == "AICITYSTRATEGY_GOOD_AIRLIFT_CITY")

	lea	eax, DWORD PTR _strStrategyName$226468[esp+76]
	push	OFFSET $SG226601
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN419@DoTurn

; 1394 : 					bStrategyShouldBeActive = CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity(GetCity());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	?IsTestCityStrategy_GoodAirliftCity@CityStrategyAIHelpers@@YA_NPAVCvCity@@@Z ; CityStrategyAIHelpers::IsTestCityStrategy_GoodAirliftCity
$LN430@DoTurn:
	add	esp, 4
$LN431@DoTurn:
	mov	bl, al
$LN419@DoTurn:

; 1395 : 
; 1396 : 				// Check Lua hook
; 1397 : 				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	edi, eax

; 1398 : 				if(pkScriptSystem && bStrategyShouldBeActive)

	test	edi, edi
	je	$LN29@DoTurn
	test	bl, bl
	je	SHORT $LN29@DoTurn

; 1399 : 				{
; 1400 : 					CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226604[esp+76]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 1401 : 					args->Push(iCityStrategiesLoop);

	mov	ecx, DWORD PTR _args$226604[esp+76]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iCityStrategiesLoop$[esp+76]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	edx

; 1402 : 					args->Push(GetCity()->getOwner());

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _args$226604[esp+76]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1403 : 					args->Push(GetCity()->GetID());

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _args$226604[esp+76]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1404 : 
; 1405 : 					// Attempt to execute the game events.
; 1406 : 					// Will return false if there are no registered listeners.
; 1407 : 					bool bResult = false;
; 1408 : 					if(LuaSupport::CallTestAll(pkScriptSystem, "CityStrategyCanActivate", args.get(), bResult))

	mov	edx, DWORD PTR _args$226604[esp+76]
	lea	ecx, DWORD PTR _bResult$226605[esp+76]
	push	ecx
	push	edx
	push	OFFSET $SG226607
	push	edi
	mov	BYTE PTR _bResult$226605[esp+92], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN27@DoTurn

; 1409 : 					{
; 1410 : 						// Check the result.
; 1411 : 						if(bResult == false)

	cmp	BYTE PTR _bResult$226605[esp+76], 0
	jne	SHORT $LN27@DoTurn

; 1412 : 						{
; 1413 : 							bStrategyShouldBeActive = false;

	xor	bl, bl
$LN27@DoTurn:

; 1414 : 						}
; 1415 : 					}
; 1416 : 				}

	lea	ecx, DWORD PTR _args$226604[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN29@DoTurn:

; 1417 : 			}

	lea	ecx, DWORD PTR _strStrategyName$226468[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1418 : 
; 1419 : 			// This variable keeps track of whether or not we should be doing something (i.e. Strategy is active now but should be turned off, OR Strategy is inactive and should be enabled)
; 1420 : 			bool bAdoptOrEndStrategy = false;
; 1421 : 
; 1422 : 			// Strategy should be on, and if it's not, turn it on
; 1423 : 			if(bStrategyShouldBeActive)

	test	bl, bl
	je	$LN420@DoTurn

; 1424 : 			{
; 1425 : 				if(bTestCityStrategyStart)

	cmp	BYTE PTR _bTestCityStrategyStart$226448[esp+76], 0

; 1426 : 				{
; 1427 : 					bAdoptOrEndStrategy = true;

	je	$LN133@DoTurn

; 1442 : 				{
; 1443 : 					bAdoptOrEndStrategy = true;
; 1444 : 				}
; 1445 : 			}
; 1446 : 
; 1447 : 			// Flavor propagation
; 1448 : 			if(bAdoptOrEndStrategy)
; 1449 : 			{
; 1450 : 				int iFlavorLoop;
; 1451 : 
; 1452 : 				// We should adopt this CityStrategy
; 1453 : 				if(bTestCityStrategyStart)
; 1454 : 				{
; 1455 : 					SetUsingCityStrategy(eCityStrategy, true);

	mov	eax, DWORD PTR [esi+28]
	mov	edi, DWORD PTR _iCityStrategiesLoop$[esp+76]
	add	eax, edi
	cmp	BYTE PTR [eax], 1
	je	SHORT $LN355@DoTurn
	mov	BYTE PTR [eax], 1
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+32]
	cmp	DWORD PTR [ecx+edi*4], eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	je	SHORT $LN360@DoTurn
	mov	DWORD PTR [ecx], eax
$LN360@DoTurn:
	push	1
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
$LN355@DoTurn:

; 1456 : 
; 1457 : 					const int iFlavorMinValue = /*-1000*/ GC.getFLAVOR_MIN_VALUE();
; 1458 : 					const int iFlavorMaxValue = /*1000*/ GC.getFLAVOR_MAX_VALUE();
; 1459 : 
; 1460 : 					const int iNumFlavors = GC.getNumFlavorTypes();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1876
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1880

; 1461 : 					for(iFlavorLoop = 0; iFlavorLoop < iNumFlavors; iFlavorLoop++)

	xor	edi, edi
	mov	DWORD PTR _iNumFlavors$226623[esp+76], ecx
	test	ecx, ecx
	jle	$LN5@DoTurn
$LL426@DoTurn:

; 1462 : 					{
; 1463 : 						if(pCityStrategy->GetFlavorValue(iFlavorLoop) != 0)

	mov	edx, DWORD PTR _pCityStrategy$226446[esp+76]
	mov	eax, DWORD PTR [edx+260]
	test	eax, eax
	je	$LN378@DoTurn
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	$LN15@DoTurn

; 1464 : 						{
; 1465 : 							m_piLatestFlavorValues[iFlavorLoop] += pCityStrategy->GetFlavorValue(iFlavorLoop);

	mov	ecx, eax
	jmp	$LN379@DoTurn
$LN420@DoTurn:

; 1428 : 				}
; 1429 : 				else if(bTestCityStrategyEnd)
; 1430 : 				{
; 1431 : 					bAdoptOrEndStrategy = false;
; 1432 : 				}
; 1433 : 			}
; 1434 : 			// Strategy should be off, and if it's not, turn it off
; 1435 : 			else
; 1436 : 			{
; 1437 : 				if(bTestCityStrategyStart)

	cmp	BYTE PTR _bTestCityStrategyStart$226448[esp+76], 0

; 1438 : 				{
; 1439 : 					bAdoptOrEndStrategy = false;

	jne	$LN133@DoTurn

; 1440 : 				}
; 1441 : 				else if(bTestCityStrategyEnd)

	cmp	BYTE PTR _bTestCityStrategyEnd$226455[esp+76], 0
	je	$LN133@DoTurn

; 1481 : 				}
; 1482 : 				// End the CityStrategy
; 1483 : 				else if(bTestCityStrategyEnd)
; 1484 : 				{
; 1485 : 					SetUsingCityStrategy(eCityStrategy, false);

	mov	edx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR _iCityStrategiesLoop$[esp+76]
	cmp	BYTE PTR [ecx+edx], 0
	lea	eax, DWORD PTR [ecx+edx]
	je	SHORT $LN382@DoTurn
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax+ecx*4], -1
	lea	eax, DWORD PTR [eax+ecx*4]
	je	SHORT $LN390@DoTurn
	mov	DWORD PTR [eax], -1
$LN390@DoTurn:
	push	0
	push	ecx
	mov	ecx, esi
	call	?LogStrategy@CvCityStrategyAI@@AAEXW4AICityStrategyTypes@@_N@Z ; CvCityStrategyAI::LogStrategy
$LN382@DoTurn:

; 1486 : 
; 1487 : 					const int iFlavorMinValue = /*-1000*/ GC.getFLAVOR_MIN_VALUE();
; 1488 : 					const int iFlavorMaxValue = /*1000*/ GC.getFLAVOR_MAX_VALUE();
; 1489 : 
; 1490 : 					const int iNumFlavors = GC.getNumFlavorTypes();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1876
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1880

; 1491 : 					for(iFlavorLoop = 0; iFlavorLoop < iNumFlavors; iFlavorLoop++)

	xor	edi, edi
	mov	DWORD PTR _iNumFlavors$226636[esp+76], ecx
	test	ecx, ecx
	jle	$LN5@DoTurn
	npad	4
$LL427@DoTurn:

; 1492 : 					{
; 1493 : 						if(pCityStrategy->GetFlavorValue(iFlavorLoop) != 0)

	mov	edx, DWORD PTR _pCityStrategy$226446[esp+76]
	mov	eax, DWORD PTR [edx+260]
	test	eax, eax
	je	SHORT $LN405@DoTurn
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	$LN6@DoTurn

; 1494 : 						{
; 1495 : 							m_piLatestFlavorValues[iFlavorLoop] -= pCityStrategy->GetFlavorValue(iFlavorLoop);

	mov	ecx, eax
	jmp	SHORT $LN406@DoTurn

; 1464 : 						{
; 1465 : 							m_piLatestFlavorValues[iFlavorLoop] += pCityStrategy->GetFlavorValue(iFlavorLoop);

$LN378@DoTurn:
	or	ecx, -1
$LN379@DoTurn:
	mov	eax, DWORD PTR [esi+8]
	add	DWORD PTR [eax+edi*4], ecx

; 1466 : 
; 1467 : 							if(m_piLatestFlavorValues[iFlavorLoop] < iFlavorMinValue)

	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx+edi*4], ebx
	lea	eax, DWORD PTR [eax+edi*4]
	jge	SHORT $LN12@DoTurn

; 1468 : 							{
; 1469 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMinValue;

	mov	edx, ecx
	mov	DWORD PTR [edx+edi*4], ebx
	jmp	SHORT $LN10@DoTurn
$LN12@DoTurn:

; 1461 : 					for(iFlavorLoop = 0; iFlavorLoop < iNumFlavors; iFlavorLoop++)

	mov	eax, DWORD PTR [esi+8]

; 1470 : 							}
; 1471 : 							else if(m_piLatestFlavorValues[iFlavorLoop] > iFlavorMaxValue)

	cmp	DWORD PTR [eax+edi*4], ebp
	lea	eax, DWORD PTR [eax+edi*4]
	jle	SHORT $LN10@DoTurn

; 1472 : 							{
; 1473 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMaxValue;

	mov	DWORD PTR [eax], ebp
$LN10@DoTurn:

; 1474 : 							}
; 1475 : 
; 1476 : 							LogFlavors((FlavorTypes) iFlavorLoop);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	edi
	mov	ecx, esi
	call	eax
	mov	ecx, DWORD PTR _iNumFlavors$226623[esp+76]
$LN15@DoTurn:
	inc	edi
	cmp	edi, ecx
	jl	$LL426@DoTurn

; 1477 : 						}
; 1478 : 					}
; 1479 : 
; 1480 : 					FlavorUpdate();

	jmp	SHORT $LN5@DoTurn

; 1494 : 						{
; 1495 : 							m_piLatestFlavorValues[iFlavorLoop] -= pCityStrategy->GetFlavorValue(iFlavorLoop);

$LN405@DoTurn:
	or	ecx, -1
$LN406@DoTurn:
	mov	eax, DWORD PTR [esi+8]
	sub	DWORD PTR [eax+edi*4], ecx

; 1496 : 
; 1497 : 							if(m_piLatestFlavorValues[iFlavorLoop] < iFlavorMinValue)

	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx+edi*4], ebx
	lea	eax, DWORD PTR [eax+edi*4]
	jge	SHORT $LN3@DoTurn

; 1498 : 							{
; 1499 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMinValue;

	mov	edx, ecx
	mov	DWORD PTR [edx+edi*4], ebx
	jmp	SHORT $LN1@DoTurn
$LN3@DoTurn:

; 1491 : 					for(iFlavorLoop = 0; iFlavorLoop < iNumFlavors; iFlavorLoop++)

	mov	eax, DWORD PTR [esi+8]

; 1500 : 							}
; 1501 : 							else if(m_piLatestFlavorValues[iFlavorLoop] > iFlavorMaxValue)

	cmp	DWORD PTR [eax+edi*4], ebp
	lea	eax, DWORD PTR [eax+edi*4]
	jle	SHORT $LN1@DoTurn

; 1502 : 							{
; 1503 : 								m_piLatestFlavorValues[iFlavorLoop] = iFlavorMaxValue;

	mov	DWORD PTR [eax], ebp
$LN1@DoTurn:

; 1504 : 							}
; 1505 : 
; 1506 : 							LogFlavors((FlavorTypes) iFlavorLoop);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	edi
	mov	ecx, esi
	call	eax
	mov	ecx, DWORD PTR _iNumFlavors$226636[esp+76]
$LN6@DoTurn:
	inc	edi
	cmp	edi, ecx
	jl	$LL427@DoTurn
$LN5@DoTurn:

; 1507 : 						}
; 1508 : 					}
; 1509 : 
; 1510 : 					FlavorUpdate();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
$LN133@DoTurn:
	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _iCityStrategiesLoop$[esp+76]
	inc	ecx
	sar	edx, 2
	cmp	ecx, edx
	mov	DWORD PTR _iCityStrategiesLoop$[esp+76], ecx
	jl	$LL423@DoTurn
	pop	edi
	pop	ebp
$LN132@DoTurn:

; 1511 : 				}
; 1512 : 			}
; 1513 : 		}
; 1514 : 	}
; 1515 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strStrategyName$226468[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvCityStrategyAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _args$226604[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoTurn@CvCityStrategyAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvCityStrategyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvCityStrategyAI@@QAEXXZ ENDP			; CvCityStrategyAI::DoTurn
PUBLIC	??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEXXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@2:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEIABUCvCityBuildable@@H@Z ; CvWeightedVector<CvCityBuildable,225,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEIABUCvCityBuildable@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEIABUCvCityBuildable@@H@Z PROC ; CvWeightedVector<CvCityBuildable,225,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR [eax+8]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+3612], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN7@push_back@2
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
$LN7@push_back@2:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN10@push_back@2
	mov	ecx, DWORD PTR _iWeight$[esp+12]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN10@push_back@2:
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi
	pop	ebp
	pop	ebx

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEIABUCvCityBuildable@@H@Z ENDP ; CvWeightedVector<CvCityBuildable,225,1>::push_back
_TEXT	ENDS
PUBLIC	??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN33@operator@5
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@5

; 572  : 				clear();	// new sequence empty, erase existing sequence

	call	?clear@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::clear
	pop	ebp
	pop	ebx
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@5:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@5

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@5:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN24@operator@5
	xor	ebx, ebx
	jmp	SHORT $LN25@operator@5
$LN24@operator@5:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN25@operator@5:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@5

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAPAVCvCitySpecializationXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvCitySpecializationXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCitySpecializationXMLEntry * *,CvCitySpecializationXMLEntry * *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAPAVCvCitySpecializationXMLEntry@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@PAPAV2@00@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<CvCitySpecializationXMLEntry * *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@5:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN28@operator@5

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@operator@5:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Buy
	test	al, al
	je	SHORT $LN32@operator@5

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAPAVCvCitySpecializationXMLEntry@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@PAPAV2@00@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<CvCitySpecializationXMLEntry * *>
	mov	DWORD PTR [esi+8], eax
$LN32@operator@5:
	pop	ebp
	pop	ebx
$LN33@operator@5:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@1@0PAPAV2@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
$T239290 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239293 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$239293[esp]
	mov	BYTE PTR $T239290[esp+4], 0
	mov	eax, DWORD PTR $T239290[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Ucopy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> > >
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__Firstn$229232 = -28					; size = 4
__Midn$229256 = -24					; size = 4
$T239303 = -20						; size = 20
$T239301 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv378 = 20						; size = 4
$T239405 = 20						; size = 1
$T239302 = 20						; size = 4
$T239300 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	esi, DWORD PTR __Count1$[esp+36]
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+40]
	lea	eax, DWORD PTR [esi+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edx, DWORD PTR __First$[esp+40]
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	al, BYTE PTR [edx]
	mov	cl, BYTE PTR [esi]
	cmp	cl, al
	jbe	$LN3@Buffered_m

; 2893 : 			std::iter_swap(_First, _Mid);

	cmp	edx, esi
	je	$LN3@Buffered_m
	mov	BYTE PTR [edx], cl
	mov	BYTE PTR [esi], al

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN9@Buffered_m:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	esi, edi
	mov	ebp, DWORD PTR __Tempbuf$[esp+40]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN6@Buffered_m

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [ebp+16]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	edi, DWORD PTR __First$[esp+40]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR $T239300[esp+60], esp
	push	esi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T239301[esp+68]
	push	edi
	push	eax
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	mov	eax, DWORD PTR $T239301[esp+76]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN37@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Buffered_m:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	ebp, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+4]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	edi
	push	edx
	push	esi
	push	eax
	push	ecx
	call	??$unchecked_merge@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 24					; 00000018H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN6@Buffered_m:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	edi, eax
	jg	SHORT $LN4@Buffered_m

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Last$[esp+40]
	mov	edi, DWORD PTR __Mid$[esp+40]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T239302[esp+60], esp
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR [ebp+16]
	lea	edx, DWORD PTR $T239303[esp+68]
	push	edi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	mov	eax, DWORD PTR $T239303[esp+76]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_m:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	mov	ebp, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [ebp+4]
	mov	BYTE PTR $T239405[esp+40], bl
	mov	eax, DWORD PTR $T239405[esp+40]
	push	eax
	mov	eax, DWORD PTR [ebp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+48]
	push	esi
	push	edx
	push	eax
	push	edi
	push	ecx
	call	??$_Merge_backward@PAEPAEPAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0000UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<unsigned char *,unsigned char *,unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN4@Buffered_m:

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, esi

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	push	0
	push	ecx
	jge	SHORT $LN2@Buffered_m
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+48]
	mov	edi, eax
	sar	edi, 1
	lea	eax, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR __Last$[esp+48]
	push	eax
	mov	DWORD PTR __Firstn$229232[esp+56], eax
	mov	eax, DWORD PTR __Mid$[esp+52]
	push	edx
	push	eax
	call	??$_Lower_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Lower_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	mov	ebx, eax

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);
; 2918 : 			}
; 2919 : 		else

	mov	eax, DWORD PTR __Firstn$229232[esp+64]
	mov	esi, ebx
	add	esp, 20					; 00000014H
	sub	esi, DWORD PTR __Mid$[esp+40]
	jmp	SHORT $LN95@Buffered_m
$LN2@Buffered_m:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx

; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	edx, DWORD PTR __First$[esp+48]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+48]
	sar	esi, 1
	lea	ebx, DWORD PTR [esi+eax]
	push	ebx
	push	eax
	push	edx
	call	??$_Upper_bound@PAEEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAPAEPAE0ABEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@PAH@Z ; std::_Upper_bound<unsigned char *,unsigned char,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, eax
	add	esp, 20					; 00000014H
	sub	edi, DWORD PTR __First$[esp+40]
	mov	DWORD PTR __Firstn$229232[esp+44], eax
$LN95@Buffered_m:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Count1$[esp+40]
	push	ebp
	sub	ecx, edi
	push	esi
	push	ecx
	mov	DWORD PTR tv378[esp+52], ecx
	mov	ecx, DWORD PTR __Mid$[esp+52]
	push	ebx
	push	ecx
	push	eax
	call	??$_Buffered_rotate@PAEHE@std@@YAPAEPAE00HHAAV?$_Temp_iterator@E@0@@Z ; std::_Buffered_rotate<unsigned char *,int,unsigned char>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	edx, DWORD PTR __Pred$[esp+64]
	mov	ecx, DWORD PTR __First$[esp+64]
	push	edx
	push	ebp
	push	esi
	push	edi
	push	eax
	mov	DWORD PTR __Midn$229256[esp+88], eax
	mov	eax, DWORD PTR __Firstn$229232[esp+88]
	push	eax
	push	ecx
	call	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+92]
	mov	eax, DWORD PTR __Count2$[esp+92]
	mov	ecx, DWORD PTR __Last$[esp+92]
	push	edx
	mov	edx, DWORD PTR __Midn$229256[esp+100]
	push	ebp
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR tv378[esp+104]
	push	eax
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 80					; 00000050H
$LN3@Buffered_m:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
$T239527 = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2214 : 	{	// order heap by repeatedly popping, using operator<

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	esi, DWORD PTR __Last$[esp+24]
	push	edi
	mov	edi, DWORD PTR __First$[esp+28]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 4
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 16					; 00000010H
	add	esi, -16				; fffffff0H
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR $T239527[esp+44], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR $T239527[esp+60]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR [ebx+esi-16]
	sar	edx, 4
	push	edx
	push	0
	push	edi
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 28					; 0000001cH
$LN2@Sort_heap:
	sub	esi, 16					; 00000010H
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 4
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::_Unchecked_chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T239564 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::_Unchecked_chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T239564[esp+4], 0
	mov	eax, DWORD PTR $T239564[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::_Unchecked_chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T239568 = -4						; size = 1
$T239574 = -4						; size = 4
$T239570 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T239569 = 48						; size = 1
__Pred$ = 48						; size = 1
??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx
	push	ebx
	push	esi

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	xor	ebx, ebx
	mov	DWORD PTR $T239574[esp+12], ebx
	mov	ecx, DWORD PTR $T239569[esp+8]
	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	BYTE PTR $T239568[esp+12], bl
	mov	eax, DWORD PTR $T239568[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T239570[esp+44], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+44]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First2$[esp+44]
	mov	ecx, DWORD PTR __Last1$[esp+44]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@E@0@PAE000V10@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@8:
	mov	eax, esi

; 5160 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??0CvAICityStrategies@@QAE@XZ			; CvAICityStrategies::CvAICityStrategies
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ??0CvAICityStrategies@@QAE@XZ
_TEXT	SEGMENT
??0CvAICityStrategies@@QAE@XZ PROC			; CvAICityStrategies::CvAICityStrategies, COMDAT
; _this$ = ecx

; 186  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 187  : 
; 188  : }

	ret	0
??0CvAICityStrategies@@QAE@XZ ENDP			; CvAICityStrategies::CvAICityStrategies
_TEXT	ENDS
PUBLIC	?DeleteArray@CvAICityStrategies@@QAEXXZ		; CvAICityStrategies::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvAICityStrategies@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvAICityStrategies@@QAEXXZ PROC		; CvAICityStrategies::DeleteArray, COMDAT
; _this$ = ecx

; 210  : {

	push	esi
	push	edi
	mov	edi, ecx

; 211  : 	for(std::vector<CvAICityStrategyEntry*>::iterator it = m_paAICityStrategyEntries.begin(); it != m_paAICityStrategyEntries.end(); ++it)

	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@DeleteArra
	npad	4
$LL14@DeleteArra:

; 212  : 	{
; 213  : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@DeleteArra
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 214  : 	}
; 215  : 
; 216  : 	m_paAICityStrategyEntries.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@DeleteArra:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@DeleteArra:
	pop	edi
	pop	esi

; 217  : }

	ret	0
?DeleteArray@CvAICityStrategies@@QAEXXZ ENDP		; CvAICityStrategies::DeleteArray
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T240156 = 8						; size = 1
__Cat$240160 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@3
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@3
	call	?_Xlen@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Xlen
$LN54@vector@3:
$LN22@vector@3:
	push	eax
	push	edi
	call	??$_Allocate@PAVCvCitySpecializationXMLEntry@@@std@@YAPAPAVCvCitySpecializationXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvCitySpecializationXMLEntry *>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T240156[ebp], 0
	mov	edx, DWORD PTR $T240156[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$240160[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@PAPAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@2@@std@@YAPAPAVCvCitySpecializationXMLEntry@@V?$_Vector_const_iterator@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCitySpecializationXMLEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >,CvCitySpecializationXMLEntry * *,std::allocator<CvCitySpecializationXMLEntry *> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@3:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@3:
$LN53@vector@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240189 = -20						; size = 20
$T240187 = -20						; size = 20
$T240185 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T240184 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T240188 = 40						; size = 4
$T240186 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	eax, ecx
	jg	SHORT $LN3@Chunked_me@2
	npad	4
$LL5@Chunked_me@2:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edx+edi]
	mov	DWORD PTR $T240184[esp+56], esp
	lea	esi, DWORD PTR [ecx+edi]
	push	esi
	push	ecx
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+84]
	push	edx
	lea	ecx, DWORD PTR $T240185[esp+76]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	call	??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T240185[esp+80]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+48], edx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	sub	ecx, eax
	cmp	ecx, eax

; 3443 : 		_First = _Mid2;

	mov	edx, esi
	mov	DWORD PTR __Count$[esp+32], ecx
	jge	SHORT $LL5@Chunked_me@2
$LN3@Chunked_me@2:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	ecx, edi
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T240186[esp+52], esp
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T240187[esp+64]
	push	ecx
	call	??$unchecked_copy@PAEV?$_Temp_iterator@E@std@@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE0V12@@Z ; stdext::unchecked_copy<unsigned char *,std::_Temp_iterator<unsigned char> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN99@Chunked_me@2
$LN2@Chunked_me@2:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR $T240188[esp+56], esp
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	lea	ecx, DWORD PTR [edx+edi]
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T240189[esp+76]
	push	ecx
	call	??$unchecked_merge@PAEPAEV?$_Temp_iterator@E@std@@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YA?AV?$_Temp_iterator@E@std@@PAE000V12@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::unchecked_merge<unsigned char *,unsigned char *,std::_Temp_iterator<unsigned char>,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 44					; 0000002cH
$LN99@Chunked_me@2:
	mov	eax, DWORD PTR $T240189[esp+36]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@2:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??1CvAICityStrategies@@QAE@XZ			; CvAICityStrategies::~CvAICityStrategies
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvAICityStrategies@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAICityStrategies@@QAE@XZ$0
__ehfuncinfo$??1CvAICityStrategies@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvAICityStrategies@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvAICityStrategies@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAICityStrategies@@QAE@XZ PROC			; CvAICityStrategies::~CvAICityStrategies, COMDAT
; _this$ = ecx

; 192  : {

	push	-1
	push	__ehhandler$??1CvAICityStrategies@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 193  : 	DeleteArray();

	call	?DeleteArray@CvAICityStrategies@@QAEXXZ	; CvAICityStrategies::DeleteArray

; 194  : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvAICitySt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvAICitySt:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAICityStrategies@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::~vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >
__ehhandler$??1CvAICityStrategies@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvAICityStrategies@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAICityStrategies@@QAE@XZ ENDP			; CvAICityStrategies::~CvAICityStrategies
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z
_TEXT	SEGMENT
__Mid$228600 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 4
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$228600[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$228600[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$228600[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -16				; fffffff0H
	and	edx, -16				; fffffff0H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$228600[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 4
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -16				; fffffff0H
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int,CvWeightedVector<CvCityBuildable,225,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T240432 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T240433 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T240432[esp+8], bl
	mov	eax, DWORD PTR $T240432[esp+8]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+8]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T240433[esp+40], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@stdext@@YAXPAE0V?$_Temp_iterator@E@std@@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; stdext::_Unchecked_chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ; std::sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z PROC ; std::sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 4
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
$T240583 = -8						; size = 1
$T240554 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T240553 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@2
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@2:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ebx
	push	ecx
	lea	esi, DWORD PTR [eax+32]
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@2
$LN4@Buffered_m@2:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@2
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
	npad	5
$LL3@Buffered_m@2:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T240553[esp+20], bl
	mov	eax, DWORD PTR $T240553[esp+20]
	push	eax
	push	edx
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	DWORD PTR $T240554[esp+60], esp
	push	eax
	push	ecx
	call	??$_Chunked_merge@PAEV?$_Temp_iterator@E@std@@HUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0V?$_Temp_iterator@E@0@HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,std::_Temp_iterator<unsigned char>,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR $T240583[esp+68], bl
	mov	edx, DWORD PTR $T240583[esp+68]
	push	edx
	mov	edx, DWORD PTR __First$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAEPAEHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<unsigned char *,unsigned char *,int,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esi, esi
	add	esp, 72					; 00000048H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@2
$LN1@Buffered_m@2:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ ; CvWeightedVector<CvCityBuildable,225,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ PROC ; CvWeightedVector<CvCityBuildable,225,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	shl	eax, 4
	add	eax, edx
	mov	ecx, eax
	sub	ecx, edx
	sar	ecx, 4
	push	ecx
	push	eax
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEXXZ ENDP ; CvWeightedVector<CvCityBuildable,225,1>::SortItems
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	edi

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@E@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@0@Z ; std::_Insertion_sort1<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort,unsigned char>
	add	esp, 16					; 00000010H
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [esi+eax]
	call	?_Maxlen@?$_Temp_iterator@E@std@@QAEHXZ	; std::_Temp_iterator<unsigned char>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	ebx
	push	edx
	call	??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN17@Stable_sor
$LN2@Stable_sor:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+12]
	mov	eax, DWORD PTR __First$[esp+12]
	push	edx
	push	ebp
	push	esi
	push	ebx
	push	eax
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Last$[esp+32]
	push	ecx
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
$LN17@Stable_sor:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	eax, DWORD PTR __Pred$[esp+52]
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	eax
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE00HHAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Buffered_merge<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z ; CvCityStrategyAI::ChooseProduction
EXTRN	?CommitToBuildingUnitForOperation@CvCity@@QAE_NXZ:PROC ; CvCity::CommitToBuildingUnitForOperation
EXTRN	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z:PROC ; CvCity::pushOrder
EXTRN	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::GetCityProductionNumOptions
EXTRN	?GetWeight@CvProcessProductionAI@@QAEHW4ProcessTypes@@@Z:PROC ; CvProcessProductionAI::GetWeight
EXTRN	?canMaintain@CvCity@@QBE_NW4ProcessTypes@@_N@Z:PROC ; CvCity::canMaintain
EXTRN	?getNumProcessInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumProcessInfos
EXTRN	?getBaseYieldRateModifier@CvCity@@QBEHW4YieldTypes@@HPAVCvString@@@Z:PROC ; CvCity::getBaseYieldRateModifier
EXTRN	?getBaseYieldRate@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getBaseYieldRate
EXTRN	?GetWeight@CvProjectProductionAI@@QAEHW4ProjectTypes@@@Z:PROC ; CvProjectProductionAI::GetWeight
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4ProjectTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?canCreate@CvCity@@QBE_NW4ProjectTypes@@_N1@Z:PROC ; CvCity::canCreate
EXTRN	?isWorldProject@@YA_NW4ProjectTypes@@@Z:PROC	; isWorldProject
EXTRN	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ:PROC ; CvProjectXMLEntries::GetNumProjects
EXTRN	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getUnitsPerPlayer
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?waterArea@CvCity@@QBEPAVCvArea@@XZ:PROC	; CvCity::waterArea
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?canTrain@CvCity@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvCity::canTrain
EXTRN	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ:PROC	; CvUnitXMLEntries::GetNumUnits
EXTRN	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetGoldMaintenance
EXTRN	?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetDomainFreeExperience
EXTRN	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isLimitedWonderClass
EXTRN	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isNationalWonderClass
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ:PROC ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForDiploVictory
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC ; CvTeam::GetLiberatedByTeam
EXTRN	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ:PROC ; CvGame::GetVotesNeededForDiploVictory
EXTRN	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsDiplomaticVoting
EXTRN	?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z:PROC ; CvBuildingProductionAI::GetWeight
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4BuildingTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
EXTRN	?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z:PROC ; CvMilitaryAI::GetUnitForArmy
EXTRN	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z:PROC	; CvPlayer::GetBestSettleAreas
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z:PROC ; CvUnitProductionAI::GetWeight
EXTRN	?IsOperationUnitProvider@CvCitySpecializationXMLEntry@@QBE_NXZ:PROC ; CvCitySpecializationXMLEntry::IsOperationUnitProvider
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?GetUnitForOperation@CvCity@@QAE?AW4UnitTypes@@XZ:PROC ; CvCity::GetUnitForOperation
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?getAsyncRandNum@CvGame@@QAEHHPBD@Z:PROC	; CvGame::getAsyncRandNum
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
;	COMDAT ?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
$T240639 = -64						; size = 4
_iTempWeight$ = -64					; size = 4
_kPlayer$ = -60						; size = 4
_pkBuildingInfo$226316 = -56				; size = 4
$T240638 = -56						; size = 4
$T240909 = -52						; size = 4
_iBldgLoop$ = -52					; size = 4
_pDiploAI$ = -48					; size = 4
$T240916 = -44						; size = 4
$T240641 = -44						; size = 4
_myTeamID$226322 = -44					; size = 4
_iBestArea$226297 = -44					; size = 4
_iBestArea$226369 = -40					; size = 4
$T240640 = -40						; size = 4
_myPlayerID$226323 = -40				; size = 4
_iSecondBestArea$226298 = -40				; size = 4
_fcn$ = -36						; size = 8
$T240642 = -28						; size = 12
_selection$ = -28					; size = 12
_buildable$ = -28					; size = 12
_weightedElem$241255 = -16				; size = 16
_weightedElem$241166 = -16				; size = 16
_bRush$226414 = 8					; size = 1
_rtnValue$241307 = 8					; size = 4
_bEnoughSettlers$ = 8					; size = 1
_bUseAsyncRandom$ = 8					; size = 1
_iSecondBestArea$226370 = 12				; size = 4
_eIgnoreBldg$ = 12					; size = 4
_eIgnoreUnit$ = 16					; size = 4
?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z PROC ; CvCityStrategyAI::ChooseProduction, COMDAT
; _this$ = ecx

; 763  : {

	sub	esp, 64					; 00000040H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 764  : 	RandomNumberDelegate fcn;
; 765  : #ifdef AUI_WARNING_FIXES
; 766  : 	uint iBldgLoop, iUnitLoop, iProjectLoop, iProcessLoop;
; 767  : 	int iTempWeight;
; 768  : #else
; 769  : 	int iBldgLoop, iUnitLoop, iProjectLoop, iProcessLoop, iTempWeight;
; 770  : #endif
; 771  : 	CvCityBuildable buildable;
; 772  : 	CvCityBuildable selection;
; 773  : 	UnitTypes eUnitForOperation;
; 774  : 	UnitTypes eUnitForArmy;
; 775  : 
; 776  : 	CvPlayerAI& kPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR [eax+84]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx

; 777  : 	CvDiplomacyAI* pDiploAI = kPlayer.GetDiplomacyAI();

	mov	ecx, edi
	mov	DWORD PTR _buildable$[esp+80], ebx
	mov	DWORD PTR _buildable$[esp+84], ebx
	mov	DWORD PTR _buildable$[esp+88], ebx
	mov	DWORD PTR _kPlayer$[esp+80], edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pDiploAI$[esp+80], eax

; 778  : 
; 779  : 	//int iSettlersOnMap = kPlayer.GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);
; 780  : 
; 781  : 	// Use the asynchronous random number generate if "no random" is set
; 782  : 	if(bUseAsyncRandom)

	cmp	BYTE PTR _bUseAsyncRandom$[esp+76], bl
	je	SHORT $LN76@ChooseProd

; 783  : 	{
; 784  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getAsyncRandNum);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _fcn$[esp+84], OFFSET ?getAsyncRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getAsyncRandNum
	mov	DWORD PTR _fcn$[esp+80], ecx

; 785  : 	}
; 786  : 	else

	jmp	SHORT $LN141@ChooseProd
$LN76@ChooseProd:

; 787  : 	{
; 788  : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _fcn$[esp+84], OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	DWORD PTR _fcn$[esp+80], edx
$LN141@ChooseProd:

; 789  : 	}
; 790  : 
; 791  : 	// Reset vector holding items we can currently build
; 792  : 	m_Buildables.clear();
; 793  : 
; 794  : 	EconomicAIStrategyTypes eStrategyEnoughSettlers = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_ENOUGH_EXPANSION");

	push	ebx
	push	OFFSET $SG226285
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+60], ebx
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 795  : 	bool bEnoughSettlers = kPlayer.GetEconomicAI()->IsUsingStrategy(eStrategyEnoughSettlers);

	push	eax
	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy

; 796  : 
; 797  : 	// Check units for operations first
; 798  : 	eUnitForOperation = m_pCity->GetUnitForOperation();

	mov	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR _bEnoughSettlers$[esp+76], al
	call	?GetUnitForOperation@CvCity@@QAE?AW4UnitTypes@@XZ ; CvCity::GetUnitForOperation
	mov	edi, eax

; 799  : 	if(eUnitForOperation != NO_UNIT)

	cmp	edi, -1
	je	$LN385@ChooseProd

; 800  : 	{
; 801  : 		buildable.m_eBuildableType = CITY_BUILDABLE_UNIT_FOR_OPERATION;
; 802  : 		buildable.m_iIndex = (int)eUnitForOperation;
; 803  : 		buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft(eUnitForOperation, 0);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	edi
	mov	DWORD PTR _buildable$[esp+88], 5
	mov	DWORD PTR _buildable$[esp+92], edi
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft

; 804  : 		iTempWeight = GC.getAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT();
; 805  : 		int iOffenseFlavor = kPlayer.GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE")) + kPlayer.GetMilitaryAI()->GetNumberOfTimesOpsBuildSkippedOver();

	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2364
	mov	DWORD PTR _buildable$[esp+88], eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ebx, DWORD PTR [eax+48]
	push	0
	push	OFFSET $SG226291
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 806  : 		iTempWeight += (GC.getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER() * iOffenseFlavor);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2368
	add	eax, ebx
	imul	ecx, eax

; 807  : 
; 808  : 		if(GetSpecialization() != NO_CITY_SPECIALIZATION && GC.getCitySpecializationInfo(GetSpecialization())->IsOperationUnitProvider())

	mov	eax, DWORD PTR [esi+20]
	add	ebp, ecx
	cmp	eax, -1
	je	SHORT $LN382@ChooseProd
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	ecx, eax
	call	?IsOperationUnitProvider@CvCitySpecializationXMLEntry@@QBE_NXZ ; CvCitySpecializationXMLEntry::IsOperationUnitProvider
	test	al, al
	je	SHORT $LN382@ChooseProd

; 809  : 		{
; 810  : 			iTempWeight *= 5;

	lea	ebp, DWORD PTR [ebp+ebp*4]
$LN382@ChooseProd:

; 811  : 		}
; 812  : 
; 813  : 		// add in the weight of this unit as if I were deciding to build it without having a reason
; 814  : 		iTempWeight += m_pUnitProductionAI->GetWeight(eUnitForOperation);

	mov	ecx, DWORD PTR [esi+44]
	push	edi
	call	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight

; 815  : 
; 816  : 		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnitForOperation);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	ebp, eax
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 817  : 		if(pkUnitEntry && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_SETTLE)

	test	eax, eax
	je	SHORT $LN383@ChooseProd
	mov	ecx, eax
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 1
	jne	SHORT $LN383@ChooseProd

; 818  : 		{
; 819  : 			if(bEnoughSettlers)

	cmp	BYTE PTR _bEnoughSettlers$[esp+76], 0

; 820  : 			{
; 821  : 				iTempWeight = 0;
; 822  : 			}
; 823  : 			else

	jne	SHORT $LN385@ChooseProd

; 824  : 			{
; 825  : 				int iBestArea, iSecondBestArea;
; 826  : 				int iNumGoodAreas = kPlayer.GetBestSettleAreas(kPlayer.GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	edi, DWORD PTR _kPlayer$[esp+80]
	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+48]
	lea	edx, DWORD PTR _iSecondBestArea$226298[esp+80]
	push	edx
	lea	ecx, DWORD PTR _iBestArea$226297[esp+84]
	push	ecx
	push	eax
	mov	ecx, edi
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 827  : 				if(iNumGoodAreas == 0)

	test	eax, eax
	je	SHORT $LN385@ChooseProd
$LN383@ChooseProd:

; 828  : 				{
; 829  : 					iTempWeight = 0;
; 830  : 				}
; 831  : 			}
; 832  : 		}
; 833  : 
; 834  : 		if (iTempWeight > 0)

	test	ebp, ebp
	jle	SHORT $LN385@ChooseProd

; 835  : 		{
; 836  : 			m_Buildables.push_back(buildable, iTempWeight);

	push	ebp
	lea	edx, DWORD PTR _buildable$[esp+84]
	push	edx
	lea	ecx, DWORD PTR [esi+56]
	call	?push_back@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEIABUCvCityBuildable@@H@Z ; CvWeightedVector<CvCityBuildable,225,1>::push_back

; 837  : 			kPlayer.GetMilitaryAI()->BumpNumberOfTimesOpsBuildSkippedOver();

	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	inc	DWORD PTR [eax+48]
$LN385@ChooseProd:

; 838  : 		}
; 839  : 
; 840  : 	}
; 841  : 
; 842  : 	// Next units for sneak attack armies
; 843  : 	eUnitForArmy = kPlayer.GetMilitaryAI()->GetUnitForArmy(GetCity());

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	push	eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z ; CvMilitaryAI::GetUnitForArmy
	mov	edi, eax

; 844  : 	if(eUnitForArmy != NO_UNIT)

	cmp	edi, -1
	je	$LN391@ChooseProd

; 845  : 	{
; 846  : 		buildable.m_eBuildableType = CITY_BUILDABLE_UNIT_FOR_ARMY;
; 847  : 		buildable.m_iIndex = (int)eUnitForArmy;
; 848  : 		buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft(eUnitForArmy, 0);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	edi
	mov	DWORD PTR _buildable$[esp+88], 6
	mov	DWORD PTR _buildable$[esp+92], edi
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft

; 849  : 		iTempWeight = GC.getAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2372

; 850  : 		int iOffenseFlavor = kPlayer.GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));

	push	0
	push	OFFSET $SG226306
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _buildable$[esp+96], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 851  : 		int iBonusMultiplier = max(1,GC.getGame().getHandicapInfo().GetID() - 5); // more at the higher difficulties

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	eax, DWORD PTR [eax+4]
	sub	eax, 5
	cmp	eax, 1
	mov	DWORD PTR $T240638[esp+80], eax
	mov	DWORD PTR $T240639[esp+80], 1
	jle	SHORT $LN181@ChooseProd
	lea	eax, DWORD PTR $T240638[esp+80]
	mov	DWORD PTR $T240909[esp+80], eax
	jmp	SHORT $LN182@ChooseProd
$LN181@ChooseProd:
	lea	ecx, DWORD PTR $T240639[esp+80]
	mov	DWORD PTR $T240909[esp+80], ecx
$LN182@ChooseProd:

; 852  : 		iTempWeight += (GC.getAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER() * iOffenseFlavor * iBonusMultiplier);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2368

; 853  : 		// add in the weight of this unit as if I were deciding to build it without having a reason
; 854  : 		iTempWeight += m_pUnitProductionAI->GetWeight(eUnitForArmy);

	mov	ecx, DWORD PTR [esi+44]
	push	edi
	mov	DWORD PTR $T240916[esp+84], edx
	call	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight
	mov	ecx, DWORD PTR $T240909[esp+80]
	mov	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR $T240916[esp+80]
	imul	edx, ebx
	add	edx, ebp
	add	eax, edx

; 855  : 
; 856  : 		if (iTempWeight > 0)

	test	eax, eax
	jle	SHORT $LN391@ChooseProd

; 857  : 		{
; 858  : 			m_Buildables.push_back(buildable, iTempWeight);

	push	eax
	lea	eax, DWORD PTR _buildable$[esp+84]
	push	eax
	lea	ecx, DWORD PTR [esi+56]
	call	?push_back@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAEIABUCvCityBuildable@@H@Z ; CvWeightedVector<CvCityBuildable,225,1>::push_back
$LN391@ChooseProd:

; 859  : 		}
; 860  : 	}
; 861  : 
; 862  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_SLIDING_LOGISTIC_MAINTENANCE_SCALE
; 863  : 	bool bCapitolConnectedHasHarbor = false;
; 864  : 	if (GetCity()->IsPuppet() && !GetCity()->IsRouteToCapitalConnected())
; 865  : 	{
; 866  : 		int iLoop;
; 867  : 		const CvPlayer* pPlayer = GetCity()->GetPlayer();
; 868  : 		const CvCity* pLoopCity;
; 869  : 		for (uint uiBuildingTypes = 0; uiBuildingTypes < GC.GetGameBuildings()->GetNumBuildings(); uiBuildingTypes++)
; 870  : 		{
; 871  : 			const BuildingTypes eHarborBuilding = static_cast<BuildingTypes>(uiBuildingTypes);
; 872  : 			CvBuildingEntry* pkHarborBuildingInfo = GC.getBuildingInfo(eHarborBuilding);
; 873  : 			if (pkHarborBuildingInfo && pkHarborBuildingInfo->AllowsWaterRoutes())
; 874  : 			{
; 875  : 				for (pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))
; 876  : 				{
; 877  : 					if (pLoopCity->IsRouteToCapitalConnected() && pLoopCity->GetCityBuildings()->GetNumActiveBuilding(eHarborBuilding) > 0)
; 878  : 					{
; 879  : 						bCapitolConnectedHasHarbor = true;
; 880  : 						goto EndHarborLoop;
; 881  : 					}
; 882  : 				}
; 883  : 			}
; 884  : 		}
; 885  : 	}
; 886  : EndHarborLoop:;
; 887  : #endif
; 888  : 
; 889  : 	// Loop through adding the available buildings
; 890  : 	for(iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBldgLoop$[esp+80], edi
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	test	eax, eax
	jle	$LN63@ChooseProd
	npad	8
$LL393@ChooseProd:

; 891  : 	{
; 892  : 		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iBldgLoop);
; 893  : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eLoopBuilding);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax
	mov	DWORD PTR _pkBuildingInfo$226316[esp+80], ebx

; 894  : 
; 895  : 		//Skip if null
; 896  : 		if(pkBuildingInfo == NULL)

	test	ebx, ebx
	je	$LN64@ChooseProd

; 897  : 			continue;
; 898  : 
; 899  : 		// Make sure this building can be built now
; 900  : #ifdef AUI_WARNING_FIXES
; 901  : 		if (iBldgLoop != uint(eIgnoreBldg) && m_pCity->canConstruct(eLoopBuilding))
; 902  : #else
; 903  : 		if(iBldgLoop != eIgnoreBldg && m_pCity->canConstruct(eLoopBuilding))

	cmp	edi, DWORD PTR _eIgnoreBldg$[esp+76]
	je	$LN64@ChooseProd
	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	0
	push	0
	push	0
	push	edi
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	test	al, al
	je	$LN64@ChooseProd

; 904  : #endif
; 905  : 		{
; 906  : 			buildable.m_eBuildableType = CITY_BUILDABLE_BUILDING;
; 907  : 			buildable.m_iIndex = iBldgLoop;
; 908  : 			buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft(eLoopBuilding, 0);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	edi
	call	?getProductionTurnsLeft@CvCity@@QBEHW4BuildingTypes@@H@Z ; CvCity::getProductionTurnsLeft

; 909  : 
; 910  : 			iTempWeight = m_pBuildingProductionAI->GetWeight(eLoopBuilding);

	mov	ecx, DWORD PTR [esi+40]
	push	edi
	mov	DWORD PTR _buildable$[esp+92], eax
	call	?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z ; CvBuildingProductionAI::GetWeight

; 911  : 
; 912  : 			// Don't build the UN if you aren't going for the diplo victory
; 913  : 			if(pkBuildingInfo->IsDiplomaticVoting())

	mov	ecx, ebx
	mov	DWORD PTR _iTempWeight$[esp+80], eax
	call	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsDiplomaticVoting
	test	al, al
	je	$LN51@ChooseProd

; 914  : 			{
; 915  : 				int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ ; CvGame::GetVotesNeededForDiploVictory

; 916  : 				int iSecuredVotes = 0;
; 917  : 				TeamTypes myTeamID = kPlayer.getTeam();

	mov	edi, DWORD PTR _kPlayer$[esp+80]
	mov	ecx, edi
	mov	ebx, eax
	xor	ebp, ebp
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 918  : 				PlayerTypes myPlayerID = kPlayer.GetID();

	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR _myTeamID$226322[esp+80], eax
	mov	DWORD PTR _myPlayerID$226323[esp+80], ecx
	xor	edi, edi
	npad	2
$LL59@ChooseProd:

; 924  : 				{
; 925  : 					eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 926  : 
; 927  : 					if(GET_PLAYER(eLoopPlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+eax+2256], 0
	je	SHORT $LN58@ChooseProd

; 928  : 					{
; 929  : 						eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

	mov	eax, DWORD PTR [edi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN205@ChooseProd
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN206@ChooseProd
$LN205@ChooseProd:
	or	eax, -1
$LN206@ChooseProd:

; 930  : 
; 931  : 						// Liberated?
; 932  : 						if(GET_TEAM(eLoopTeam).GetLiberatedByTeam() == myTeamID)

	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, DWORD PTR _myTeamID$226322[esp+80]

; 933  : 						{
; 934  : 							iSecuredVotes++;

	je	SHORT $LN399@ChooseProd

; 935  : 						}
; 936  : 
; 937  : 						// Minor civ?
; 938  : 						else if(GET_PLAYER(eLoopPlayer).isMinorCiv())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN58@ChooseProd

; 939  : 						{
; 940  : 							// Best Relations?
; 941  : 							if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly() == myPlayerID)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _myPlayerID$226323[esp+80]
	jne	SHORT $LN58@ChooseProd
$LN399@ChooseProd:

; 942  : 							{
; 943  : 								iSecuredVotes++;

	inc	ebp
$LN58@ChooseProd:

; 919  : 
; 920  : 				// Loop through Players to see if they'll vote for this player
; 921  : 				PlayerTypes eLoopPlayer;
; 922  : 				TeamTypes eLoopTeam;
; 923  : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL59@ChooseProd

; 944  : 							}
; 945  : 						}
; 946  : 					}
; 947  : 				}
; 948  : 
; 949  : 				int iNumberOfPlayersWeNeedToBuyOff = MAX(0, iVotesNeededToWin - iSecuredVotes);

	sub	ebx, ebp
	mov	eax, ebx
	mov	DWORD PTR $T240640[esp+80], eax
	mov	DWORD PTR $T240641[esp+80], 0
	lea	edi, DWORD PTR $T240640[esp+80]
	test	eax, eax
	jg	SHORT $LN219@ChooseProd
	lea	edi, DWORD PTR $T240641[esp+80]
$LN219@ChooseProd:

; 950  : 
; 951  : 				if(!pDiploAI  || !pDiploAI->IsGoingForDiploVictory() || kPlayer.GetTreasury()->GetGold() < iNumberOfPlayersWeNeedToBuyOff * 500)

	cmp	DWORD PTR _pDiploAI$[esp+80], 0
	je	SHORT $LN50@ChooseProd
	mov	ecx, DWORD PTR _pDiploAI$[esp+80]
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	test	al, al
	je	SHORT $LN50@ChooseProd
	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ecx, DWORD PTR [edi]
	imul	ecx, 500				; 000001f4H
	cmp	eax, ecx
	jge	SHORT $LN51@ChooseProd
$LN50@ChooseProd:

; 952  : 				{
; 953  : 					iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[esp+80], 0
$LN51@ChooseProd:

; 954  : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 955  : 					continue;
; 956  : #endif
; 957  : 				}
; 958  : 			}
; 959  : 
; 960  : #ifdef NQM_AI_GIMP_NO_WORLD_WONDERS
; 961  : 			if (GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_WORLD_WONDER") && isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG226342
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN49@ChooseProd
	mov	ecx, DWORD PTR _pkBuildingInfo$226316[esp+80]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	jne	$LN64@ChooseProd
$LN49@ChooseProd:

; 962  : 			{
; 963  : 				iTempWeight = 0;
; 964  : 				continue;
; 965  : 			}
; 966  : #endif
; 967  : 
; 968  : 			// If the City is a puppet, it avoids Wonders (because the human can't change it if he wants to build it somewhere else!)
; 969  : 			if(GetCity()->IsPuppet())

	mov	ecx, DWORD PTR [esi+12]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	je	$LN395@ChooseProd

; 970  : 			{
; 971  : 				const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();

	mov	ebp, DWORD PTR _pkBuildingInfo$226316[esp+80]
	mov	ecx, ebp
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	mov	edi, eax

; 972  : 
; 973  : 				if(isWorldWonderClass(kBuildingClassInfo) || isTeamWonderClass(kBuildingClassInfo) || isNationalWonderClass(kBuildingClassInfo) || isLimitedWonderClass(kBuildingClassInfo))

	push	edi
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	jne	SHORT $LN46@ChooseProd
	push	edi
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	test	al, al
	jne	SHORT $LN46@ChooseProd
	push	edi
	call	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isNationalWonderClass
	add	esp, 4
	test	al, al
	jne	SHORT $LN46@ChooseProd
	push	edi
	call	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isLimitedWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN394@ChooseProd
$LN46@ChooseProd:

; 974  : 				{
; 975  : 					iTempWeight = 0;

	xor	ebx, ebx
	mov	DWORD PTR _iTempWeight$[esp+80], ebx
	jmp	SHORT $LN47@ChooseProd
$LN394@ChooseProd:
	mov	ebx, DWORD PTR _iTempWeight$[esp+80]
$LN47@ChooseProd:

; 976  : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 977  : 					continue;
; 978  : #endif
; 979  : 				}
; 980  : #ifndef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_PUPPETS_NULLIFY_BARRACKS
; 981  : 				// it also avoids military training buildings - since it can't build units
; 982  : 				if(pkBuildingInfo->GetDomainFreeExperience(DOMAIN_LAND))

	push	2
	mov	ecx, ebp
	call	?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainFreeExperience
	test	eax, eax
	je	SHORT $LN396@ChooseProd

; 983  : 				{
; 984  : 					iTempWeight = 0;

	xor	ebx, ebx
	mov	DWORD PTR _iTempWeight$[esp+80], ebx
$LN396@ChooseProd:

; 985  : 				}
; 986  : #endif
; 987  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_SLIDING_LOGISTIC_MAINTENANCE_SCALE
; 988  : 				int iEffectiveMaintenanceT100 = pkBuildingInfo->GetGoldMaintenance() * (100 + GetCity()->GetPlayer()->GetBuildingGoldMaintenanceMod());
; 989  : 				int iBonusGoldFromYield = pkBuildingInfo->GetYieldChange(YIELD_GOLD) + GetCity()->getPopulation() * pkBuildingInfo->GetYieldChangePerPop(YIELD_GOLD);
; 990  : 				iBonusGoldFromYield += GetCity()->GetCityBuildings()->GetBuildingYieldChange((BuildingClassTypes)pkBuildingInfo->GetBuildingClassType(), YIELD_GOLD);
; 991  : 				iBonusGoldFromYield *= GetCity()->getYieldRateModifier(YIELD_GOLD) + pkBuildingInfo->GetYieldModifier(YIELD_GOLD);
; 992  : 				iEffectiveMaintenanceT100 -= iBonusGoldFromYield;
; 993  : 
; 994  : 				int iBonusGoldFromModifier = GetCity()->getBaseYieldRate(YIELD_GOLD) * 100;
; 995  : 				iBonusGoldFromModifier += GetCity()->GetYieldPerPopTimes100(YIELD_GOLD) * GetCity()->getPopulation();
; 996  : 				iBonusGoldFromModifier += GetCity()->GetYieldPerReligionTimes100(YIELD_GOLD) * GetCity()->GetCityReligions()->GetNumReligionsWithFollowers();
; 997  : 				iBonusGoldFromModifier *= pkBuildingInfo->GetYieldModifier(YIELD_GOLD);
; 998  : 				iEffectiveMaintenanceT100 -= iBonusGoldFromModifier;
; 999  : 
; 1000 : 				if (bCapitolConnectedHasHarbor && pkBuildingInfo->AllowsWaterRoutes())
; 1001 : 				{
; 1002 : 					iEffectiveMaintenanceT100 -= GetCity()->GetPlayer()->GetTreasury()->GetCityConnectionRouteGoldTimes100(GetCity());
; 1003 : 				}
; 1004 : 				
; 1005 : 				iTempWeight *= int(2.0 / (1.0 + exp(double(iEffectiveMaintenanceT100) / 200.0)) + 0.5);
; 1006 : #else
; 1007 : 				// they also like stuff that won't burden the empire with maintenance costs
; 1008 : 				if(pkBuildingInfo->GetGoldMaintenance() == 0)

	mov	ecx, ebp
	call	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGoldMaintenance
	test	eax, eax
	jne	SHORT $LN44@ChooseProd

; 1009 : 				{
; 1010 : 					iTempWeight *= 2;

	add	ebx, ebx
	mov	DWORD PTR _iTempWeight$[esp+80], ebx
$LN44@ChooseProd:

; 1011 : 				}
; 1012 : #endif
; 1013 : 				// and they avoid any buildings that require resources
; 1014 : 				int iNumResources = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebp, eax

; 1015 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResources; iResourceLoop++)

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN41@ChooseProd
$LL43@ChooseProd:

; 1016 : 				{
; 1017 : 					if(pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	ecx, DWORD PTR _pkBuildingInfo$226316[esp+80]
	push	edi
	call	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN42@ChooseProd

; 1018 : 					{
; 1019 : 						iTempWeight = 0;

	xor	ebx, ebx
$LN42@ChooseProd:

; 1015 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResources; iResourceLoop++)

	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL43@ChooseProd

; 1018 : 					{
; 1019 : 						iTempWeight = 0;

	mov	DWORD PTR _iTempWeight$[esp+80], ebx

; 1015 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResources; iResourceLoop++)

	jmp	SHORT $LN41@ChooseProd
$LN395@ChooseProd:
	mov	ebx, DWORD PTR _iTempWeight$[esp+80]
$LN41@ChooseProd:

; 1020 : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 1021 : 						break;
; 1022 : #endif
; 1023 : 					}
; 1024 : 				}
; 1025 : #ifdef AUI_CITYSTRATEGY_PUPPETS_ALLOW_BAD_BUILDS_IF_NO_OTHER_CHOICE
; 1026 : 				iTempWeight += 1;
; 1027 : #endif
; 1028 : 			}
; 1029 : 			if(iTempWeight > 0)

	test	ebx, ebx
	jle	SHORT $LN64@ChooseProd

; 1030 : 				m_Buildables.push_back(buildable, iTempWeight);

	mov	eax, DWORD PTR [esi+64]
	lea	edi, DWORD PTR [esi+56]
	mov	BYTE PTR [edi+3612], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN230@ChooseProd
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
$LN230@ChooseProd:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN233@ChooseProd
	mov	edx, DWORD PTR _iBldgLoop$[esp+80]
	mov	ecx, 1
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _buildable$[esp+88]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _iTempWeight$[esp+80]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
$LN233@ChooseProd:
	inc	DWORD PTR [edi+4]
$LN64@ChooseProd:

; 859  : 		}
; 860  : 	}
; 861  : 
; 862  : #ifdef AUI_CITYSTRATEGY_FIX_CHOOSE_PRODUCTION_SLIDING_LOGISTIC_MAINTENANCE_SCALE
; 863  : 	bool bCapitolConnectedHasHarbor = false;
; 864  : 	if (GetCity()->IsPuppet() && !GetCity()->IsRouteToCapitalConnected())
; 865  : 	{
; 866  : 		int iLoop;
; 867  : 		const CvPlayer* pPlayer = GetCity()->GetPlayer();
; 868  : 		const CvCity* pLoopCity;
; 869  : 		for (uint uiBuildingTypes = 0; uiBuildingTypes < GC.GetGameBuildings()->GetNumBuildings(); uiBuildingTypes++)
; 870  : 		{
; 871  : 			const BuildingTypes eHarborBuilding = static_cast<BuildingTypes>(uiBuildingTypes);
; 872  : 			CvBuildingEntry* pkHarborBuildingInfo = GC.getBuildingInfo(eHarborBuilding);
; 873  : 			if (pkHarborBuildingInfo && pkHarborBuildingInfo->AllowsWaterRoutes())
; 874  : 			{
; 875  : 				for (pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))
; 876  : 				{
; 877  : 					if (pLoopCity->IsRouteToCapitalConnected() && pLoopCity->GetCityBuildings()->GetNumActiveBuilding(eHarborBuilding) > 0)
; 878  : 					{
; 879  : 						bCapitolConnectedHasHarbor = true;
; 880  : 						goto EndHarborLoop;
; 881  : 					}
; 882  : 				}
; 883  : 			}
; 884  : 		}
; 885  : 	}
; 886  : EndHarborLoop:;
; 887  : #endif
; 888  : 
; 889  : 	// Loop through adding the available buildings
; 890  : 	for(iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	edi, DWORD PTR _iBldgLoop$[esp+80]
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBldgLoop$[esp+80], edi
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	edi, eax
	jl	$LL393@ChooseProd
$LN63@ChooseProd:

; 1031 : 		}
; 1032 : 	}
; 1033 : 
; 1034 : 	// If the City is a puppet, it avoids training Units and projects
; 1035 : 	if(!GetCity()->IsPuppet())

	mov	ecx, DWORD PTR [esi+12]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	jne	$LN21@ChooseProd

; 1036 : 	{
; 1037 : 		// Loop through adding the available units
; 1038 : 		for(iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	test	eax, eax
	jle	$LN35@ChooseProd
$LL37@ChooseProd:

; 1039 : 		{
; 1040 : 			// Make sure this unit can be built now
; 1041 : #ifdef AUI_WARNING_FIXES
; 1042 : 			if (iUnitLoop != uint(eIgnoreUnit) &&
; 1043 : #else
; 1044 : 			if(iUnitLoop != eIgnoreUnit &&
; 1045 : #endif
; 1046 : 			        //GC.GetGameBuildings()->GetEntry(iUnitLoop)->GetAdvisorType() != eIgnoreAdvisor &&
; 1047 : 			        m_pCity->canTrain((UnitTypes)iUnitLoop))

	cmp	edi, DWORD PTR _eIgnoreUnit$[esp+76]
	je	$LN36@ChooseProd
	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	edi
	call	?canTrain@CvCity@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvCity::canTrain
	test	al, al
	je	$LN36@ChooseProd

; 1048 : 			{
; 1049 : 				buildable.m_eBuildableType = CITY_BUILDABLE_UNIT;
; 1050 : 				buildable.m_iIndex = iUnitLoop;
; 1051 : 				buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft((UnitTypes)iUnitLoop, 0);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	edi
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft

; 1052 : 
; 1053 : 				iTempWeight = m_pUnitProductionAI->GetWeight((UnitTypes)iUnitLoop);

	mov	ecx, DWORD PTR [esi+44]
	push	edi
	mov	DWORD PTR _buildable$[esp+92], eax
	call	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight
	mov	ebx, eax

; 1054 : 
; 1055 : 				CvUnitEntry* pkUnitEntry = GC.getUnitInfo((UnitTypes)iUnitLoop);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iTempWeight$[esp+84], ebx
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ebp, eax

; 1056 : 				if(pkUnitEntry && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_SETTLE)

	test	ebp, ebp
	je	$LN390@ChooseProd
	mov	ecx, ebp
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 1
	jne	SHORT $LN30@ChooseProd

; 1057 : 				{
; 1058 : 					if(bEnoughSettlers)

	cmp	BYTE PTR _bEnoughSettlers$[esp+76], 0

; 1059 : 					{
; 1060 : 						iTempWeight = 0;
; 1061 : 					}
; 1062 : 					else

	jne	SHORT $LN400@ChooseProd

; 1063 : 					{
; 1064 : 						int iBestArea, iSecondBestArea;
; 1065 : 						int iNumGoodAreas = kPlayer.GetBestSettleAreas(kPlayer.GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+48]
	lea	ecx, DWORD PTR _iSecondBestArea$226370[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$[esp+84]
	lea	edx, DWORD PTR _iBestArea$226369[esp+84]
	push	edx
	push	eax
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 1066 : 						if(iNumGoodAreas == 0)

	test	eax, eax
	jne	SHORT $LN30@ChooseProd
$LN400@ChooseProd:

; 1067 : 						{
; 1068 : 							iTempWeight = 0;

	xor	ebx, ebx
	mov	DWORD PTR _iTempWeight$[esp+80], ebx
$LN30@ChooseProd:

; 1069 : 						}
; 1070 : 					}
; 1071 : 				}
; 1072 : 
; 1073 : 				// sanity check for building ships on small inland seas (not lakes)
; 1074 : 				if (pkUnitEntry)
; 1075 : 				{
; 1076 : 					DomainTypes eDomain = (DomainTypes) pkUnitEntry->GetDomainType();

	mov	ecx, ebp
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType

; 1077 : 					if (eDomain == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() != UNITAI_WORKER_SEA) // if needed allow workboats...

	test	eax, eax
	jne	SHORT $LN390@ChooseProd
	mov	ecx, ebp
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 17					; 00000011H
	je	SHORT $LN390@ChooseProd

; 1078 : 					{
; 1079 : 						CvArea* pBiggestNearbyBodyOfWater = m_pCity->waterArea();

	mov	ecx, DWORD PTR [esi+12]
	call	?waterArea@CvCity@@QBEPAVCvArea@@XZ	; CvCity::waterArea
	mov	ebp, eax

; 1080 : 						if (pBiggestNearbyBodyOfWater)

	test	ebp, ebp
	je	SHORT $LN36@ChooseProd

; 1081 : 						{
; 1082 : 							int iWaterTiles = pBiggestNearbyBodyOfWater->getNumTiles();

	mov	ecx, ebp
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	ebx, eax

; 1083 : 							int iNumUnitsofMine = pBiggestNearbyBodyOfWater->getUnitsPerPlayer(m_pCity->getOwner());

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+84]
	push	eax
	mov	ecx, ebp
	call	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer

; 1084 : 							if (iNumUnitsofMine * 5 > iWaterTiles)

	lea	ecx, DWORD PTR [eax+eax*4]
	cmp	ecx, ebx

; 1085 : 							{
; 1086 : 								iTempWeight = 0;
; 1087 : 							}
; 1088 : 						}
; 1089 : 						else // this should never happen, but...

	jg	SHORT $LN36@ChooseProd
	mov	ebx, DWORD PTR _iTempWeight$[esp+80]
$LN390@ChooseProd:

; 1090 : 						{
; 1091 : 							iTempWeight = 0;
; 1092 : 						}
; 1093 : 					}
; 1094 : 				}
; 1095 : 
; 1096 : 
; 1097 : 				if(iTempWeight > 0)

	test	ebx, ebx
	jle	SHORT $LN36@ChooseProd

; 1098 : 					m_Buildables.push_back(buildable, iTempWeight);

	mov	eax, DWORD PTR [esi+64]
	lea	ebp, DWORD PTR [esi+56]
	mov	BYTE PTR [ebp+3612], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN256@ChooseProd
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
$LN256@ChooseProd:
	mov	eax, DWORD PTR [ebp+4]
	shl	eax, 4
	add	eax, DWORD PTR [ebp]
	je	SHORT $LN259@ChooseProd
	mov	edx, DWORD PTR _buildable$[esp+88]
	mov	ecx, 2
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ebx
$LN259@ChooseProd:
	inc	DWORD PTR [ebp+4]
$LN36@ChooseProd:

; 1036 : 	{
; 1037 : 		// Loop through adding the available units
; 1038 : 		for(iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	edi, eax
	jl	$LL37@ChooseProd
$LN35@ChooseProd:

; 1099 : 			}
; 1100 : 		}
; 1101 : 
; 1102 : 		// Loop through adding the available projects
; 1103 : 		for(iProjectLoop = 0; iProjectLoop < GC.GetGameProjects()->GetNumProjects(); iProjectLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ; CvProjectXMLEntries::GetNumProjects
	test	eax, eax
	jle	$LN21@ChooseProd
	npad	10
$LL397@ChooseProd:

; 1104 : 		{
; 1105 : #ifdef NQM_AI_GIMP_NO_WORLD_WONDERS
; 1106 : 			if (GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_WORLD_WONDER") && isWorldProject((ProjectTypes)iProjectLoop))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG226389
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN20@ChooseProd
	push	ebp
	call	?isWorldProject@@YA_NW4ProjectTypes@@@Z	; isWorldProject
	add	esp, 4
	test	al, al
	jne	SHORT $LN22@ChooseProd
$LN20@ChooseProd:

; 1107 : 				continue;
; 1108 : #endif
; 1109 : 			if(m_pCity->canCreate((ProjectTypes)iProjectLoop))

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	0
	push	ebp
	call	?canCreate@CvCity@@QBE_NW4ProjectTypes@@_N1@Z ; CvCity::canCreate
	test	al, al
	je	SHORT $LN22@ChooseProd

; 1110 : 			{
; 1111 : 				buildable.m_eBuildableType = CITY_BUILDABLE_PROJECT;
; 1112 : 				buildable.m_iIndex = iProjectLoop;
; 1113 : 				buildable.m_iTurnsToConstruct = GetCity()->getProductionTurnsLeft((ProjectTypes)iProjectLoop, 0);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	ebp
	mov	ebx, 3
	call	?getProductionTurnsLeft@CvCity@@QBEHW4ProjectTypes@@H@Z ; CvCity::getProductionTurnsLeft

; 1114 : 				m_Buildables.push_back(buildable, m_pProjectProductionAI->GetWeight((ProjectTypes)iProjectLoop));

	mov	ecx, DWORD PTR [esi+48]
	push	ebp
	mov	DWORD PTR _buildable$[esp+92], eax
	lea	edi, DWORD PTR [esi+56]
	call	?GetWeight@CvProjectProductionAI@@QAEHW4ProjectTypes@@@Z ; CvProjectProductionAI::GetWeight
	mov	DWORD PTR _weightedElem$241166[esp+92], eax
	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+3612], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN276@ChooseProd
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
$LN276@ChooseProd:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN279@ChooseProd
	mov	ecx, DWORD PTR _buildable$[esp+88]
	mov	edx, DWORD PTR _weightedElem$241166[esp+92]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
$LN279@ChooseProd:
	inc	DWORD PTR [edi+4]
$LN22@ChooseProd:

; 1099 : 			}
; 1100 : 		}
; 1101 : 
; 1102 : 		// Loop through adding the available projects
; 1103 : 		for(iProjectLoop = 0; iProjectLoop < GC.GetGameProjects()->GetNumProjects(); iProjectLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
	mov	ecx, eax
	call	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ; CvProjectXMLEntries::GetNumProjects
	cmp	ebp, eax
	jl	$LL397@ChooseProd
$LN21@ChooseProd:

; 1115 : 			}
; 1116 : 		}
; 1117 : 	}
; 1118 : 
; 1119 : 	// Normally, a puppeted city cannot run processes, but as Venice they are allowed to.
; 1120 : 	bool bIsVenice = kPlayer.GetPlayerTraits()->IsNoAnnexing();

	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 1121 : 	if (!GetCity()->IsPuppet() || bIsVenice)

	mov	ecx, DWORD PTR [esi+12]
	mov	bl, BYTE PTR [eax+343]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	je	SHORT $LN17@ChooseProd
	test	bl, bl
	je	$LN12@ChooseProd
$LN17@ChooseProd:

; 1122 : 	{	
; 1123 : 		// Loop through adding available processes
; 1124 : 		if (!GET_PLAYER(m_pCity->getOwner()).isMinorCiv())

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN12@ChooseProd

; 1125 : 		{
; 1126 : 			//I cannot use the yield rate since it adds in set process yield, which is what I am trying to set...
; 1127 : 			int iBaseYield = GetCity()->getBaseYieldRate(YIELD_PRODUCTION) * 100;

	mov	ecx, DWORD PTR [esi+12]
	push	1
	call	?getBaseYieldRate@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getBaseYieldRate

; 1128 : 			iBaseYield += (GetCity()->GetYieldPerPopTimes100(YIELD_PRODUCTION) * GetCity()->getPopulation());

	mov	ebp, DWORD PTR [esi+12]
	mov	edi, eax
	push	1
	imul	edi, 100				; 00000064H
	mov	ecx, ebp
	call	?GetYieldPerPopTimes100@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::GetYieldPerPopTimes100
	mov	ecx, ebp
	mov	ebx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	ebx, eax

; 1129 : 			int iModifiedYield = iBaseYield * GetCity()->getBaseYieldRateModifier(YIELD_PRODUCTION);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	0
	push	1
	add	edi, ebx
	call	?getBaseYieldRateModifier@CvCity@@QBEHW4YieldTypes@@HPAVCvString@@@Z ; CvCity::getBaseYieldRateModifier
	mov	ecx, eax
	imul	ecx, edi

; 1130 : 			iModifiedYield /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1131 : 
; 1132 : 			if (iModifiedYield >= 8)

	cmp	ecx, 8
	jl	$LN12@ChooseProd

; 1133 : 			{
; 1134 : 				for (iProcessLoop = 0; iProcessLoop < GC.getNumProcessInfos(); iProcessLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumProcessInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProcessInfos
	test	eax, eax
	jle	SHORT $LN12@ChooseProd
	npad	1
$LL398@ChooseProd:

; 1135 : 				{
; 1136 : 					ProcessTypes eProcess = (ProcessTypes)iProcessLoop;
; 1137 : 					if (m_pCity->canMaintain(eProcess))

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	ebp
	call	?canMaintain@CvCity@@QBE_NW4ProcessTypes@@_N@Z ; CvCity::canMaintain
	test	al, al
	je	SHORT $LN13@ChooseProd

; 1138 : 					{
; 1139 : 						iTempWeight = m_pProcessProductionAI->GetWeight((ProcessTypes)iProcessLoop);

	mov	ecx, DWORD PTR [esi+52]
	push	ebp

; 1140 : 						buildable.m_eBuildableType = CITY_BUILDABLE_PROCESS;

	mov	ebx, 4

; 1141 : 						buildable.m_iIndex = iProcessLoop;
; 1142 : 						buildable.m_iTurnsToConstruct = 1;
; 1143 : 						m_Buildables.push_back(buildable, iTempWeight);

	lea	edi, DWORD PTR [esi+56]
	call	?GetWeight@CvProcessProductionAI@@QAEHW4ProcessTypes@@@Z ; CvProcessProductionAI::GetWeight
	mov	DWORD PTR _weightedElem$241255[esp+92], eax
	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+3612], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN310@ChooseProd
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@$0OB@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement,225,1,0,0>::GrowSize
$LN310@ChooseProd:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN313@ChooseProd
	mov	edx, DWORD PTR _weightedElem$241255[esp+92]
	mov	DWORD PTR [eax], ebx
	mov	ecx, 1
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
$LN313@ChooseProd:
	inc	DWORD PTR [edi+4]
$LN13@ChooseProd:

; 1133 : 			{
; 1134 : 				for (iProcessLoop = 0; iProcessLoop < GC.getNumProcessInfos(); iProcessLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumProcessInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProcessInfos
	cmp	ebp, eax
	jl	SHORT $LL398@ChooseProd
$LN12@ChooseProd:

; 1144 : 					}
; 1145 : 				}
; 1146 : 			}
; 1147 : 		}
; 1148 : 	}
; 1149 : 
; 1150 : 	ReweightByCost();

	mov	ecx, esi
	xor	ebp, ebp
	xor	ebx, ebx
	call	?ReweightByCost@CvCityStrategyAI@@AAEXXZ ; CvCityStrategyAI::ReweightByCost

; 1151 : 
; 1152 : 	m_Buildables.SortItems();

	mov	ecx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [esi+60]
	lea	edi, DWORD PTR [esi+56]
	shl	eax, 4
	add	eax, ecx
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 4
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCityBuildable,225,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 1153 : 
; 1154 : 	LogPossibleBuilds();

	mov	ecx, esi
	call	?LogPossibleBuilds@CvCityStrategyAI@@AAEXXZ ; CvCityStrategyAI::LogPossibleBuilds
	mov	ecx, DWORD PTR [edi+4]

; 1155 : 
; 1156 : 	if(m_Buildables.GetTotalWeight() > 0)

	xor	eax, eax
	xor	edx, edx
	cmp	ecx, 2
	mov	DWORD PTR _rtnValue$241307[esp+76], eax
	jl	SHORT $LC378@ChooseProd
	mov	eax, DWORD PTR [edi]
	add	ecx, -2					; fffffffeH
	shr	ecx, 1
	add	eax, 28					; 0000001cH
	inc	ecx
	lea	edx, DWORD PTR [ecx+ecx]
	npad	5
$LL379@ChooseProd:
	add	ebp, DWORD PTR [eax-16]
	add	ebx, DWORD PTR [eax]
	add	eax, 32					; 00000020H
	sub	ecx, 1
	jne	SHORT $LL379@ChooseProd
	mov	eax, DWORD PTR _rtnValue$241307[esp+76]
$LC378@ChooseProd:
	cmp	edx, DWORD PTR [edi+4]
	jae	SHORT $LN377@ChooseProd
	mov	eax, DWORD PTR [edi]
	shl	edx, 4
	mov	eax, DWORD PTR [edx+eax+12]
$LN377@ChooseProd:
	add	eax, ebp
	add	eax, ebx
	test	eax, eax
	jle	$LN7@ChooseProd

; 1157 : 	{
; 1158 : 		// Choose from the best options (currently 2)
; 1159 : 		int iNumChoices = GC.getGame().getHandicapInfo().GetCityProductionNumOptions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetCityProductionNumOptions

; 1160 : 		selection = m_Buildables.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing city build from Top Choices");

	push	OFFSET $SG226411
	lea	ecx, DWORD PTR _fcn$[esp+84]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T240642[esp+92]
	push	edx
	mov	ecx, edi
	call	?ChooseFromTopChoices@?$CvWeightedVector@UCvCityBuildable@@$0OB@$00@@QAE?AUCvCityBuildable@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvCityBuildable,225,1>::ChooseFromTopChoices

; 1161 : 		int iRushIfMoreThanXTurns = GC.getAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD();
; 1162 : 		if(GET_PLAYER(m_pCity->getOwner()).isMinorCiv())

	mov	ecx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [ecx+84]
	mov	ebp, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1808
	mov	DWORD PTR _selection$[esp+88], eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN9@ChooseProd

; 1163 : 		{
; 1164 : 			iRushIfMoreThanXTurns *= GC.getMINOR_CIV_PRODUCTION_PERCENT();

	imul	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7292

; 1165 : 			iRushIfMoreThanXTurns /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
$LN9@ChooseProd:

; 1166 : 		}
; 1167 : 
; 1168 : 		bool bRush = selection.m_iTurnsToConstruct > iRushIfMoreThanXTurns;

	mov	ecx, DWORD PTR _selection$[esp+88]
	cmp	ecx, ebx
	setg	dl
	mov	BYTE PTR _bRush$226414[esp+76], dl

; 1169 : 		LogCityProduction(selection, bRush);

	mov	ebx, DWORD PTR _bRush$226414[esp+76]
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, esi
	call	?LogCityProduction@CvCityStrategyAI@@QAEXUCvCityBuildable@@_N@Z ; CvCityStrategyAI::LogCityProduction

; 1170 : 
; 1171 : 		switch(selection.m_eBuildableType)

	dec	ebp
	cmp	ebp, 5
	ja	$LN7@ChooseProd
	jmp	DWORD PTR $LN401@ChooseProd[ebp*4]
$LN6@ChooseProd:

; 1172 : 		{
; 1173 : 		case CITY_BUILDABLE_UNIT:
; 1174 : 		case CITY_BUILDABLE_UNIT_FOR_ARMY:
; 1175 : 		{
; 1176 : 			UnitTypes eUnitType = (UnitTypes) selection.m_iIndex;
; 1177 : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 1178 : 			if(pkUnitInfo)

	test	eax, eax
	je	$LN7@ChooseProd

; 1179 : 			{
; 1180 : 				UnitAITypes eUnitAI = (UnitAITypes) pkUnitInfo->GetDefaultUnitAIType();

	mov	ecx, eax
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType

; 1181 : 				GetCity()->pushOrder(ORDER_TRAIN, eUnitType, eUnitAI, false, true, false, bRush);

	mov	ecx, DWORD PTR [esi+12]
	push	ebx
	push	0
	push	1
	push	0
	push	eax
	push	edi
	push	0
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 1210 : 		}
; 1211 : 		break;
; 1212 : 		}
; 1213 : 
; 1214 : 	}
; 1215 : 
; 1216 : 	return;
; 1217 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 64					; 00000040H
	ret	12					; 0000000cH
$LN4@ChooseProd:

; 1182 : 			}
; 1183 : 		}
; 1184 : 		break;
; 1185 : 
; 1186 : 		case CITY_BUILDABLE_BUILDING:
; 1187 : 		{
; 1188 : 			BuildingTypes eBuildingType = (BuildingTypes) selection.m_iIndex;
; 1189 : 			GetCity()->pushOrder(ORDER_CONSTRUCT, eBuildingType, -1, false, true, false, bRush);

	mov	ecx, DWORD PTR [esi+12]
	push	ebx
	push	0
	push	1
	push	0
	push	-1
	push	edi
	push	1
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 1210 : 		}
; 1211 : 		break;
; 1212 : 		}
; 1213 : 
; 1214 : 	}
; 1215 : 
; 1216 : 	return;
; 1217 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 64					; 00000040H
	ret	12					; 0000000cH
$LN3@ChooseProd:

; 1190 : 		}
; 1191 : 		break;
; 1192 : 
; 1193 : 		case CITY_BUILDABLE_PROJECT:
; 1194 : 		{
; 1195 : 			ProjectTypes eProjectType = (ProjectTypes) selection.m_iIndex;
; 1196 : 			GetCity()->pushOrder(ORDER_CREATE, eProjectType, -1, false, true, false, bRush);

	mov	ecx, DWORD PTR [esi+12]
	push	ebx
	push	0
	push	1
	push	0
	push	-1
	push	edi
	push	2
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 1210 : 		}
; 1211 : 		break;
; 1212 : 		}
; 1213 : 
; 1214 : 	}
; 1215 : 
; 1216 : 	return;
; 1217 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 64					; 00000040H
	ret	12					; 0000000cH
$LN2@ChooseProd:

; 1197 : 		}
; 1198 : 		break;
; 1199 : 
; 1200 : 		case CITY_BUILDABLE_PROCESS:
; 1201 : 		{
; 1202 : 			ProcessTypes eProcessType = (ProcessTypes)selection.m_iIndex;
; 1203 : 			GetCity()->pushOrder(ORDER_MAINTAIN, eProcessType, -1, false, true, false, false); // ignoring rush because we can't rush a process

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	edi
	push	4
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder
$LN381@ChooseProd:

; 1204 : 		}
; 1205 : 
; 1206 : 		case CITY_BUILDABLE_UNIT_FOR_OPERATION:
; 1207 : 		{
; 1208 : 			GetCity()->CommitToBuildingUnitForOperation();

	mov	ecx, DWORD PTR [esi+12]
	call	?CommitToBuildingUnitForOperation@CvCity@@QAE_NXZ ; CvCity::CommitToBuildingUnitForOperation

; 1209 : 			kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();

	mov	ecx, DWORD PTR _kPlayer$[esp+80]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR [eax+48], 0
$LN7@ChooseProd:

; 1210 : 		}
; 1211 : 		break;
; 1212 : 		}
; 1213 : 
; 1214 : 	}
; 1215 : 
; 1216 : 	return;
; 1217 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 64					; 00000040H
	ret	12					; 0000000cH
$LN401@ChooseProd:
	DD	$LN4@ChooseProd
	DD	$LN6@ChooseProd
	DD	$LN3@ChooseProd
	DD	$LN2@ChooseProd
	DD	$LN381@ChooseProd
	DD	$LN6@ChooseProd
?ChooseProduction@CvCityStrategyAI@@QAEX_NW4BuildingTypes@@W4UnitTypes@@@Z ENDP ; CvCityStrategyAI::ChooseProduction
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0
__ehfuncinfo$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0HAAV?$_Temp_iterator@E@0@UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@E@std@@QAE@XZ	; std::_Temp_iterator<unsigned char>::~_Temp_iterator<unsigned char>
__ehhandler$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
PUBLIC	??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z PROC ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H
$LN1@stable_sor:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@PAEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ENDP ; std::stable_sort<unsigned char *,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
_TEXT	ENDS
PUBLIC	?UpdateBestYields@CvCityStrategyAI@@QAEXXZ	; CvCityStrategyAI::UpdateBestYields
EXTRN	?GetYieldTargetTimes100@CvCitySpecializationXMLEntry@@QBEHW4YieldTypes@@@Z:PROC ; CvCitySpecializationXMLEntry::GetYieldTargetTimes100
EXTRN	?IsDefault@CvCitySpecializationXMLEntry@@QBE_NXZ:PROC ; CvCitySpecializationXMLEntry::IsDefault
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:PROC
EXTRN	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ:PROC ; CvGlobals::getCitySpecializationInfo
EXTRN	?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ:PROC ; CvCityCitizens::GetFocusType
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?GetYieldChange@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetYieldChange
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?getMinCity@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getMinCity
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z:PROC ; CvCityCitizens::GetCityPlotFromIndex
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$2
__ehfuncinfo$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_eSpecialization$ = -72					; size = 4
_iSlotsToEvaluate$ = -72				; size = 4
_uiPlotsEvaluated$ = -72				; size = 4
_this$ = -68						; size = 4
$T241478 = -64						; size = 1
_pCityBuildings$226724 = -64				; size = 4
$T241479 = -64						; size = 4
_iPlotLoop$226680 = -64					; size = 4
$T241477 = -64						; size = 4
_iYield$226711 = -60					; size = 4
$T241476 = -60						; size = 4
_iPopulationToEvaluate$ = -60				; size = 4
_m_aCitySpecializations$226765 = -56			; size = 16
_aCitySpecializations$226752 = -56			; size = 16
_strLookup$226738 = -40					; size = 28
__$EHRec$ = -12						; size = 12
?UpdateBestYields@CvCityStrategyAI@@QAEXXZ PROC		; CvCityStrategyAI::UpdateBestYields, COMDAT
; _this$ = ecx

; 1531 : {

	push	-1
	push	__ehhandler$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[esp+88], ebx

; 1532 : 	m_eFocusYield = (YieldTypes)NO_YIELD;

	mov	DWORD PTR [ebx+3696], -1

; 1533 : 
; 1534 : 	ResetBestYields();

	call	?ResetBestYields@CvCityStrategyAI@@QAEXXZ ; CvCityStrategyAI::ResetBestYields

; 1535 : 
; 1536 : 	int iPopulationToEvaluate = min(m_pCity->getPopulation() + 2, NUM_CITY_PLOTS);

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR $T241476[esp+88], 37		; 00000025H
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	eax, 2
	mov	DWORD PTR $T241477[esp+88], eax
	cmp	eax, 37					; 00000025H
	lea	eax, DWORD PTR $T241476[esp+88]
	jg	SHORT $LN56@UpdateBest
	lea	eax, DWORD PTR $T241477[esp+88]
$LN56@UpdateBest:
	mov	eax, DWORD PTR [eax]

; 1537 : 	CvPlot* pPlot = NULL;
; 1538 : 	uint uiPlotsEvaluated = 0;

	xor	edi, edi

; 1539 : 
; 1540 : 	struct ReverseSort
; 1541 : 	{
; 1542 : 		bool operator()(unsigned char ucA, unsigned char ucB)
; 1543 : 		{
; 1544 : 			return ucA > ucB;
; 1545 : 		}
; 1546 : 	};
; 1547 : 
; 1548 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	esi, esi
	mov	DWORD PTR _iPopulationToEvaluate$[esp+88], eax
	mov	DWORD PTR _uiPlotsEvaluated$[esp+88], edi
	mov	DWORD PTR _iPlotLoop$226680[esp+88], esi
$LL47@UpdateBest:

; 1549 : 	{
; 1550 : 		// we want to evaluate the city plot
; 1551 : 		//if (iPlotLoop == CITY_HOME_PLOT)
; 1552 : 		//{
; 1553 : 		//	continue;
; 1554 : 		//}
; 1555 : 
; 1556 : 		pPlot = m_pCity->GetCityCitizens()->GetCityPlotFromIndex(iPlotLoop);

	mov	ecx, DWORD PTR [ebx+12]
	push	esi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
	mov	ebp, eax

; 1557 : 		if(!pPlot)

	test	ebp, ebp
	je	SHORT $LN46@UpdateBest

; 1558 : 		{
; 1559 : 			continue;
; 1560 : 		}
; 1561 : 
; 1562 : 		CvCity* pWorkingCity = pPlot->getWorkingCity();

	mov	ecx, ebp
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity

; 1563 : 		if(!pWorkingCity || pWorkingCity->GetID() != m_pCity->GetID())

	test	eax, eax
	je	SHORT $LN46@UpdateBest
	mov	eax, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [ecx+120]
	jne	SHORT $LN46@UpdateBest

; 1564 : 		{
; 1565 : 			continue;
; 1566 : 		}
; 1567 : 
; 1568 : 		for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	xor	esi, esi
	lea	edi, DWORD PTR ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA[edi]
	npad	5
$LL41@UpdateBest:

; 1569 : 		{
; 1570 : 			YieldTypes eYield = (YieldTypes)iYield;
; 1571 : 			int iYieldAmount = pPlot->getYield(eYield);

	push	esi
	mov	ecx, ebp
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield

; 1572 : 
; 1573 : 			m_acBestYields[iYield][uiPlotsEvaluated] = iYieldAmount;

	mov	BYTE PTR [edi], al
	inc	esi
	add	edi, 37					; 00000025H
	cmp	esi, 6
	jl	SHORT $LL41@UpdateBest

; 1574 : 		}
; 1575 : 		uiPlotsEvaluated++;

	inc	DWORD PTR _uiPlotsEvaluated$[esp+88]
	mov	esi, DWORD PTR _iPlotLoop$226680[esp+88]
	mov	edi, DWORD PTR _uiPlotsEvaluated$[esp+88]
$LN46@UpdateBest:
	inc	esi
	cmp	esi, 37					; 00000025H
	mov	DWORD PTR _iPlotLoop$226680[esp+88], esi
	jl	SHORT $LL47@UpdateBest

; 1576 : 	}
; 1577 : 
; 1578 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	esi, OFFSET ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA ; CvCityStrategyAI::m_acBestYields
	npad	2
$LL38@UpdateBest:

; 1579 : 	{
; 1580 : 		std::stable_sort(m_acBestYields[iYield], m_acBestYields[iYield] + uiPlotsEvaluated, ReverseSort());

	lea	eax, DWORD PTR [esi+edi]
	mov	BYTE PTR $T241478[esp+88], 0
	cmp	esi, eax
	je	SHORT $LN37@UpdateBest
	mov	edx, DWORD PTR $T241478[esp+88]
	push	edx
	push	0
	push	0
	push	eax
	push	esi
	call	??$_Stable_sort@PAEHEUReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@std@@YAXPAE0PAH0UReverseSort@?1??UpdateBestYields@CvCityStrategyAI@@QAEXXZ@@Z ; std::_Stable_sort<unsigned char *,int,unsigned char,`CvCityStrategyAI::UpdateBestYields'::`2'::ReverseSort>
	add	esp, 20					; 00000014H
$LN37@UpdateBest:
	add	esi, 37					; 00000025H
	cmp	esi, OFFSET ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA+222
	jl	SHORT $LL38@UpdateBest

; 1581 : 	}
; 1582 : 
; 1583 : 	int iSlotsToEvaluate = MIN((int)uiPlotsEvaluated, iPopulationToEvaluate);

	cmp	DWORD PTR _iPopulationToEvaluate$[esp+88], edi
	mov	DWORD PTR $T241479[esp+88], edi
	lea	eax, DWORD PTR _iPopulationToEvaluate$[esp+88]
	jl	SHORT $LN75@UpdateBest
	lea	eax, DWORD PTR $T241479[esp+88]
$LN75@UpdateBest:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _iSlotsToEvaluate$[esp+88], edi

; 1584 : 	CvAssertMsg(iSlotsToEvaluate > 0, "iSlotsToEvaluate is zero, trying to div by 0");
; 1585 : 	if(iSlotsToEvaluate <= 0)

	test	edi, edi
	jle	$LN48@UpdateBest

; 1586 : 	{
; 1587 : 		return;
; 1588 : 	}
; 1589 : 
; 1590 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	xor	esi, esi
	mov	DWORD PTR _iYield$226711[esp+88], esi
$LL186@UpdateBest:

; 1591 : 	{
; 1592 : 		int iYieldSum = 0;

	xor	ebx, ebx

; 1593 : 		for(int iSlot = 0; iSlot < iSlotsToEvaluate; iSlot++)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN29@UpdateBest
	mov	ecx, esi
	imul	ecx, 37					; 00000025H
	lea	ecx, DWORD PTR ?m_acBestYields@CvCityStrategyAI@@0PAY0CF@EA[ecx]
$LL31@UpdateBest:

; 1594 : 		{
; 1595 : 			iYieldSum += (m_acBestYields[iYield][iSlot] * 100);

	movzx	edx, BYTE PTR [ecx+eax]
	imul	edx, 100				; 00000064H
	inc	eax
	add	ebx, edx
	cmp	eax, edi
	jl	SHORT $LL31@UpdateBest
$LN29@UpdateBest:

; 1596 : 		}
; 1597 : 
; 1598 : 		// add in additional food from the city plot and the city buildings that provide food
; 1599 : 		if(iYield == YIELD_FOOD)

	test	esi, esi
	jne	$LN188@UpdateBest

; 1600 : 		{
; 1601 : 			int iCityYieldSum = 0;
; 1602 : 			iCityYieldSum = m_pCity->plot()->getYield(YIELD_FOOD);

	push	esi
	mov	esi, DWORD PTR _this$[esp+92]
	mov	ecx, DWORD PTR [esi+12]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield

; 1603 : 			CvYieldInfo* pYield = GC.getYieldInfo(YIELD_FOOD);

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo

; 1604 : 			if(pYield)

	test	eax, eax
	je	SHORT $LN27@UpdateBest

; 1605 : 			{
; 1606 : 				iCityYieldSum -= pYield->getMinCity();

	mov	ecx, eax
	call	?getMinCity@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMinCity
	sub	ebp, eax
$LN27@UpdateBest:

; 1607 : 			}
; 1608 : 
; 1609 : 			CvCityBuildings* pCityBuildings = m_pCity->GetCityBuildings();

	mov	ecx, DWORD PTR [esi+12]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings

; 1610 : 			BuildingTypes eBuilding;
; 1611 : #ifdef AUI_WARNING_FIXES
; 1612 : 			for (uint iI = 0; iI < GC.getNumBuildingInfos(); iI++)
; 1613 : #else
; 1614 : 			for(int iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _pCityBuildings$226724[esp+88], eax
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN24@UpdateBest
$LL187@UpdateBest:

; 1615 : #endif
; 1616 : 			{
; 1617 : 				eBuilding = (BuildingTypes) iI;
; 1618 : 				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 1619 : 				if(pkBuildingInfo)

	test	edi, edi
	je	SHORT $LN25@UpdateBest

; 1620 : 				{
; 1621 : 					if(pCityBuildings->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _pCityBuildings$226724[esp+88]
	push	esi
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN25@UpdateBest

; 1622 : 					{
; 1623 : 						iCityYieldSum += pkBuildingInfo->GetYieldChange(iYield);

	push	0
	mov	ecx, edi
	call	?GetYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChange
	add	ebp, eax
$LN25@UpdateBest:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL187@UpdateBest

; 1610 : 			BuildingTypes eBuilding;
; 1611 : #ifdef AUI_WARNING_FIXES
; 1612 : 			for (uint iI = 0; iI < GC.getNumBuildingInfos(); iI++)
; 1613 : #else
; 1614 : 			for(int iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	edi, DWORD PTR _iSlotsToEvaluate$[esp+88]
$LN24@UpdateBest:

; 1624 : 					}
; 1625 : 				}
; 1626 : 			}
; 1627 : 
; 1628 : 			iYieldSum += iCityYieldSum * 100;

	mov	esi, DWORD PTR _iYield$226711[esp+88]
	imul	ebp, 100				; 00000064H
	add	ebx, ebp
$LN188@UpdateBest:

; 1629 : 		}
; 1630 : 
; 1631 : 		m_asBestYieldAverageTimes100[iYield] = iYieldSum / iSlotsToEvaluate;

	mov	eax, ebx
	cdq
	idiv	edi
	mov	ecx, DWORD PTR _this$[esp+88]
	inc	esi
	cmp	esi, 6
	mov	DWORD PTR _iYield$226711[esp+88], esi
	mov	WORD PTR [ecx+esi*2+3670], ax
	jl	$LL186@UpdateBest

; 1632 : 
; 1633 : 		CvAssertMsg(m_asBestYieldAverageTimes100[iYield] < 750, "Crazy high yield");
; 1634 : 	}
; 1635 : 
; 1636 : 	CitySpecializationTypes eSpecialization = m_pCity->GetCityStrategyAI()->GetSpecialization();

	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+12]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ebx, DWORD PTR [eax+20]
	mov	DWORD PTR _eSpecialization$[esp+88], ebx

; 1637 : 	if(eSpecialization == NO_CITY_SPECIALIZATION)

	cmp	ebx, -1
	jne	$LN185@UpdateBest

; 1638 : 	{
; 1639 : 		if(m_pCity->GetPlayer()->isHuman())

	mov	ecx, DWORD PTR [esi+12]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN184@UpdateBest

; 1640 : 		{
; 1641 : 			// find a specialization type according to the citizen focus type
; 1642 : 			CityAIFocusTypes eCityAIFocusTypes = m_pCity->GetCityCitizens()->GetFocusType();

	mov	ecx, DWORD PTR [esi+12]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ ; CvCityCitizens::GetFocusType

; 1643 : 
; 1644 : 			CvString strLookup;

	lea	ecx, DWORD PTR _strLookup$226738[esp+88]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edi, edi

; 1645 : 			switch(eCityAIFocusTypes)

	mov	eax, esi
	sub	eax, edi
	mov	DWORD PTR __$EHRec$[esp+96], edi
	je	SHORT $LN17@UpdateBest
	sub	eax, 2
	jne	SHORT $LN81@UpdateBest

; 1649 : 				break;
; 1650 : 			case CITY_AI_FOCUS_TYPE_GOLD:
; 1651 : 				strLookup = "CITYSPECIALIZATION_COMMERCE";

	push	OFFSET $SG226746

; 1652 : 				break;

	jmp	SHORT $LN192@UpdateBest
$LN17@UpdateBest:

; 1646 : 			{
; 1647 : 			case CITY_AI_FOCUS_TYPE_FOOD:
; 1648 : 				strLookup = "CITYSPECIALIZATION_SETTLER_PUMP";

	push	OFFSET $SG226744
$LN192@UpdateBest:
	lea	ecx, DWORD PTR _strLookup$226738[esp+92]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN81@UpdateBest:

; 1653 : 			}
; 1654 : 
; 1655 : 			if(!strLookup.IsEmpty())

	lea	ecx, DWORD PTR _strLookup$226738[esp+88]
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	jne	$LN183@UpdateBest
	lea	ecx, DWORD PTR _strLookup$226738[esp+88]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	je	SHORT $LN183@UpdateBest

; 1656 : 			{
; 1657 : 				std::vector<CvCitySpecializationXMLEntry*> aCitySpecializations = GC.getCitySpecializationInfo();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvGlobals::getCitySpecializationInfo
	push	eax
	lea	ecx, DWORD PTR _aCitySpecializations$226752[esp+92]
	call	??0?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >

; 1658 : 				for(uint ui = 0; ui < aCitySpecializations.size(); ui++)

	mov	esi, DWORD PTR _aCitySpecializations$226752[esp+96]
	mov	ebp, DWORD PTR _aCitySpecializations$226752[esp+92]
	sub	esi, ebp
	sar	esi, 2
	mov	BYTE PTR __$EHRec$[esp+96], 1
	test	esi, esi
	jbe	SHORT $LN12@UpdateBest
	mov	ebx, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	npad	4
$LL14@UpdateBest:

; 1659 : 				{
; 1660 : 					CvCitySpecializationXMLEntry* pEntry = aCitySpecializations[ui];

	mov	eax, DWORD PTR [ebp+edi*4]

; 1661 : 					if(pEntry->GetType() == strLookup)

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edx, DWORD PTR _strLookup$226738[esp+88]
	push	edx
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN168@UpdateBest
	inc	edi
	cmp	edi, esi
	jb	SHORT $LL14@UpdateBest

; 1676 : 			{
; 1677 : 				if(m_aCitySpecializations[ui]->IsDefault())

	jmp	SHORT $LN193@UpdateBest
$LN168@UpdateBest:

; 1662 : 					{
; 1663 : 						eSpecialization = (CitySpecializationTypes)ui;

	mov	DWORD PTR _eSpecialization$[esp+88], edi
$LN193@UpdateBest:
	mov	ebx, DWORD PTR _eSpecialization$[esp+88]
$LN12@UpdateBest:

; 1664 : 						break;
; 1665 : 					}
; 1666 : 				}
; 1667 : 			}

	test	ebp, ebp
	je	SHORT $LN183@UpdateBest
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN183@UpdateBest:

; 1668 : 		}

	lea	ecx, DWORD PTR _strLookup$226738[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1669 : 
; 1670 : 		// if the human did not have a city ai specialization
; 1671 : 		if(eSpecialization == NO_CITY_SPECIALIZATION)

	cmp	ebx, -1
	jne	SHORT $LN185@UpdateBest
$LN184@UpdateBest:

; 1672 : 		{
; 1673 : 			std::vector<CvCitySpecializationXMLEntry*> m_aCitySpecializations;

	xor	edi, edi
	mov	DWORD PTR _m_aCitySpecializations$226765[esp+92], edi
	mov	DWORD PTR _m_aCitySpecializations$226765[esp+96], edi
	mov	DWORD PTR _m_aCitySpecializations$226765[esp+100], edi

; 1674 : 			m_aCitySpecializations = GC.getCitySpecializationInfo();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+96], 2
	call	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvGlobals::getCitySpecializationInfo
	push	eax
	lea	ecx, DWORD PTR _m_aCitySpecializations$226765[esp+92]
	call	??4?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator=

; 1675 : 			for(uint ui = 0; ui < m_aCitySpecializations.size(); ui++)

	mov	esi, DWORD PTR _m_aCitySpecializations$226765[esp+96]
	mov	ebp, DWORD PTR _m_aCitySpecializations$226765[esp+92]
	sub	esi, ebp
	sar	esi, 2
	test	esi, esi
	jbe	SHORT $LN7@UpdateBest
	npad	3
$LL9@UpdateBest:

; 1676 : 			{
; 1677 : 				if(m_aCitySpecializations[ui]->IsDefault())

	mov	ecx, DWORD PTR [ebp+edi*4]
	call	?IsDefault@CvCitySpecializationXMLEntry@@QBE_NXZ ; CvCitySpecializationXMLEntry::IsDefault
	test	al, al
	jne	SHORT $LN169@UpdateBest
	inc	edi
	cmp	edi, esi
	jb	SHORT $LL9@UpdateBest
	jmp	SHORT $LN7@UpdateBest
$LN169@UpdateBest:

; 1678 : 				{
; 1679 : 					eSpecialization = (CitySpecializationTypes)ui;

	mov	DWORD PTR _eSpecialization$[esp+88], edi
	mov	ebx, edi
$LN7@UpdateBest:

; 1680 : 					break;
; 1681 : 				}
; 1682 : 			}
; 1683 : 		}

	mov	DWORD PTR __$EHRec$[esp+96], -1
	test	ebp, ebp
	je	SHORT $LN157@UpdateBest
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN157@UpdateBest:

; 1684 : 	}
; 1685 : 
; 1686 : 	CvCitySpecializationXMLEntry* pEntry = NULL;
; 1687 : 	if(eSpecialization != NO_CITY_SPECIALIZATION)

	cmp	ebx, -1
	je	SHORT $LN48@UpdateBest
$LN185@UpdateBest:

; 1688 : 	{
; 1689 : 		pEntry = GC.getCitySpecializationInfo(eSpecialization);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	ebp, eax

; 1690 : 	}
; 1691 : 
; 1692 : 	if(!pEntry)

	test	ebp, ebp
	je	SHORT $LN48@UpdateBest

; 1693 : 	{
; 1694 : 		return;
; 1695 : 	}
; 1696 : 
; 1697 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	edi, DWORD PTR _this$[esp+88]
	xor	esi, esi
	add	edi, 3684				; 00000e64H
$LL3@UpdateBest:

; 1698 : 	{
; 1699 : 		m_asYieldDeltaTimes100[iYield] = m_asBestYieldAverageTimes100[iYield] - pEntry->GetYieldTargetTimes100((YieldTypes)iYield);

	push	esi
	mov	ecx, ebp
	call	?GetYieldTargetTimes100@CvCitySpecializationXMLEntry@@QBEHW4YieldTypes@@@Z ; CvCitySpecializationXMLEntry::GetYieldTargetTimes100
	mov	cx, WORD PTR [edi-12]
	sub	cx, ax
	mov	WORD PTR [edi], cx
	inc	esi
	add	edi, 2
	cmp	esi, 6
	jl	SHORT $LL3@UpdateBest

; 1700 : 	}
; 1701 : 
; 1702 : 	m_eFocusYield = pEntry->GetYieldType();

	mov	ecx, ebp
	call	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ ; CvCitySpecializationXMLEntry::GetYieldType
	mov	edx, DWORD PTR _this$[esp+88]
	mov	DWORD PTR [edx+3696], eax
$LN48@UpdateBest:

; 1703 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strLookup$226738[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _aCitySpecializations$226752[ebp]
	jmp	??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
__unwindfunclet$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _m_aCitySpecializations$226765[ebp]
	jmp	??1?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::~vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >
__ehhandler$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdateBestYields@CvCityStrategyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateBestYields@CvCityStrategyAI@@QAEXXZ ENDP		; CvCityStrategyAI::UpdateBestYields
END
