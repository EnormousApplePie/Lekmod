; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCultureClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG223112 DB	00H
$SG223142 DB	00H
$SG223150 DB	00H
$SG223161 DB	00H
$SG223118 DB	'[NEWLINE]', 00H
$SG223169 DB	00H
$SG225635 DB	00H
$SG223120 DB	'[NEWLINE]', 00H
$SG225642 DB	00H
$SG225650 DB	00H
$SG223121 DB	'[NEWLINE]', 00H
$SG226183 DB	00H
$SG226356 DB	00H
$SG223122 DB	' (', 00H
$SG226357 DB	00H
$SG223123 DB	')', 00H
$SG226375 DB	00H
$SG226377 DB	00H
$SG223124 DB	'[NEWLINE]', 00H
$SG226379 DB	00H
$SG226381 DB	00H
$SG223128 DB	'+%d [ICON_CULTURE], +%d [ICON_TOURISM]', 00H
$SG226387 DB	00H
$SG223153 DB	' (', 00H
$SG226398 DB	00H
$SG223154 DB	')', 00H
$SG226409 DB	00H
$SG226715 DB	00H
$SG223264 DB	'GREAT_WORK_LITERATURE', 00H
$SG226732 DB	00H
$SG226749 DB	00H
$SG223267 DB	'GREAT_WORK_ART', 00H
$SG226883 DB	00H
$SG223270 DB	'GREAT_WORK_ARTIFACT', 00H
$SG223273 DB	'GREAT_WORK_MUSIC', 00H
$SG226886 DB	00H
$SG227128 DB	00H
$SG227131 DB	00H
$SG223597 DB	'GREAT_WORK_LITERATURE', 00H
$SG227133 DB	00H
$SG227135 DB	00H
$SG223600 DB	'GREAT_WORK_ART', 00H
$SG227137 DB	00H
$SG223603 DB	'GREAT_WORK_ARTIFACT', 00H
$SG223606 DB	'GREAT_WORK_MUSIC', 00H
$SG227139 DB	00H
$SG227141 DB	00H
$SG227143 DB	00H
$SG225572 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
$SG227385 DB	00H
$SG225612 DB	'GREAT_WORK_ARTIFACT', 00H
$SG225621 DB	'IMPROVEMENT_LANDMARK', 00H
$SG227405 DB	00H
$SG227470 DB	00H
$SG227472 DB	00H
$SG225651 DB	'GREAT_WORK_LITERATURE', 00H
$SG227474 DB	00H
	ORG $+1
$SG225675 DB	'VICTORY_CULTURAL', 00H
	ORG $+3
$SG225680 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL'
	DB	00H
	ORG $+3
$SG225683 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL'
	DB	'_ACTIVE_PLAYER_TT', 00H
	ORG $+2
$SG225686 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL'
	DB	'_TT', 00H
$SG225689 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_UNMET_INFLUENTIAL_T'
	DB	'T', 00H
	ORG $+2
$SG225712 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_NO_LONGER_INFLUENTI'
	DB	'AL', 00H
	ORG $+1
$SG225714 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_NO_LONGER_INFLUENTI'
	DB	'AL_TT', 00H
	ORG $+2
$SG225719 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_ACTIVE_P'
	DB	'LAYER', 00H
	ORG $+2
$SG225722 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_ACTIVE_P'
	DB	'LAYER_TT', 00H
	ORG $+3
$SG225725 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO', 00H
$SG225728 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_TT', 00H
	ORG $+1
$SG225731 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_UNMET_TT'
	DB	00H
	ORG $+3
$SG225752 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_ACTIVE_P'
	DB	'LAYER', 00H
	ORG $+6
$SG225755 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_ACTIVE_P'
	DB	'LAYER_TT', 00H
	ORG $+3
$SG225758 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE', 00H
$SG225761 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_TT', 00H
	ORG $+1
$SG225764 DB	'TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_UNMET_TT'
	DB	00H
	ORG $+3
$SG225841 DB	'BUILDING_BROADCAST_TOWER', 00H
	ORG $+3
$SG226115 DB	'TXT_KEY_EO_SPY_RANK_TT', 00H
	ORG $+1
$SG226127 DB	'TXT_KEY_SPY_BONUS_CITY_STATE', 00H
	ORG $+3
$SG226131 DB	'TXT_KEY_SPY_BONUS_MAJOR_CIV', 00H
$SG226192 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226193 DB	'TXT_KEY_CO_PLAYER_TOURISM_OPEN_BORDERS', 00H
	ORG $+1
$SG226194 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226199 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226200 DB	'TXT_KEY_CO_PLAYER_TOURISM_TRADE_ROUTE', 00H
	ORG $+2
$SG226201 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226207 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226208 DB	'TXT_KEY_CO_PLAYER_TOURISM_RELIGION_NOTE', 00H
$SG226209 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226215 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226216 DB	'TXT_KEY_CO_PLAYER_TOURISM_PROPAGANDA', 00H
	ORG $+3
$SG226217 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226224 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226225 DB	'TXT_KEY_CO_PLAYER_TOURISM_SHARED_IDEOLOGY', 00H
	ORG $+2
$SG226226 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226244 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226245 DB	'TXT_KEY_CO_PLAYER_TOURISM_COMMON_FOE', 00H
	ORG $+3
$SG226246 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226253 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226254 DB	'TXT_KEY_CO_PLAYER_TOURISM_LESS_HAPPY', 00H
	ORG $+3
$SG226255 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226260 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226261 DB	'TXT_KEY_CO_PLAYER_TOURISM_CARNIVAL', 00H
	ORG $+1
$SG226262 DB	'[COLOR_POSITIVE_TEXT]', 00H
	ORG $+2
$SG226267 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226268 DB	'TXT_KEY_CO_PLAYER_TOURISM_OPEN_BORDERS', 00H
	ORG $+1
$SG226269 DB	'[COLOR_GREY]', 00H
	ORG $+3
$SG226274 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226275 DB	'TXT_KEY_CO_PLAYER_TOURISM_TRADE_ROUTE', 00H
	ORG $+2
$SG226276 DB	'[COLOR_GREY]', 00H
	ORG $+3
$SG226282 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226283 DB	'TXT_KEY_CO_PLAYER_TOURISM_RELIGION_NOTE', 00H
$SG226284 DB	'[COLOR_GREY]', 00H
	ORG $+3
$SG226290 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226291 DB	'TXT_KEY_CO_PLAYER_TOURISM_PROPAGANDA', 00H
	ORG $+3
$SG226292 DB	'[COLOR_GREY]', 00H
	ORG $+3
$SG226297 DB	'[ENDCOLOR]', 00H
	ORG $+1
$SG226298 DB	'TXT_KEY_CO_PLAYER_TOURISM_DIFFERENT_IDEOLOGIES', 00H
	ORG $+1
$SG226299 DB	'[COLOR_NEGATIVE_TEXT]', 00H
	ORG $+2
$SG226368 DB	'TXT_KEY_CO_OPINION_TT_OVERVIEW', 00H
	ORG $+1
$SG226385 DB	'TXT_KEY_CO_OPINION_TT_FOR_FREEDOM', 00H
	ORG $+2
$SG226392 DB	'[ICON_IDEOLOGY_FREEDOM]', 00H
$SG226396 DB	'TXT_KEY_CO_OPINION_TT_FOR_AUTOCRACY', 00H
$SG226403 DB	'[ICON_IDEOLOGY_AUTOCRACY]', 00H
	ORG $+2
$SG226407 DB	'TXT_KEY_CO_OPINION_TT_FOR_ORDER', 00H
$SG226414 DB	'[ICON_IDEOLOGY_ORDER]', 00H
	ORG $+2
$SG226429 DB	', ', 00H
	ORG $+1
$SG226434 DB	'[ICON_IDEOLOGY_FREEDOM]', 00H
$SG226438 DB	', ', 00H
	ORG $+1
$SG226443 DB	'[ICON_IDEOLOGY_AUTOCRACY]', 00H
	ORG $+2
$SG226446 DB	', ', 00H
	ORG $+1
$SG226451 DB	'[ICON_IDEOLOGY_ORDER]', 00H
	ORG $+2
$SG226498 DB	'TXT_KEY_CO_OPINION_TT_FOR_FREEDOM', 00H
	ORG $+2
$SG226502 DB	'TXT_KEY_CO_OPINION_TT_FOR_AUTOCRACY', 00H
$SG226506 DB	'TXT_KEY_CO_OPINION_TT_FOR_ORDER', 00H
$SG226510 DB	'TXT_KEY_CO_OPINION_TT_INFLUENCED_WORLD_IDEOLOGY', 00H
$SG226511 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG226515 DB	'TXT_KEY_CO_OPINION_TT_NOT_INFLUENCED', 00H
	ORG $+3
$SG226519 DB	'TXT_KEY_CO_OPINION_TT_INFLUENCED_BY', 00H
$SG226525 DB	'TXT_KEY_CO_OPINION_TT_PREFERRED_IDEOLOGY', 00H
	ORG $+3
$SG226530 DB	'TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE1', 00H
$SG226532 DB	'TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE2', 00H
$SG226534 DB	'TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE3', 00H
$SG226536 DB	'TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE4', 00H
$SG226539 DB	'TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE5', 00H
$SG226672 DB	'Civ Name', 00H
	ORG $+3
$SG226674 DB	'Turn', 00H
	ORG $+3
$SG226676 DB	'# Cities', 00H
	ORG $+3
$SG226679 DB	'TECH_DRAMA', 00H
	ORG $+1
$SG226682 DB	'TECH_GUILDS', 00H
$SG226685 DB	'TECH_ACOUSTICS', 00H
	ORG $+1
$SG226688 DB	'BUILDINGCLASS_WRITERS_GUILD', 00H
$SG226691 DB	'BUILDINGCLASS_ARTISTS_GUILD', 00H
$SG226694 DB	'BUILDINGCLASS_MUSICIANS_GUILD', 00H
	ORG $+2
$SG226697 DB	'BUILDING_WRITERS_GUILD', 00H
	ORG $+1
$SG226700 DB	'BUILDING_ARTISTS_GUILD', 00H
	ORG $+1
$SG226703 DB	'BUILDING_MUSICIANS_GUILD', 00H
	ORG $+3
$SG226707 DB	'yes', 00H
$SG226708 DB	'no', 00H
	ORG $+1
$SG226709 DB	'Drama', 00H
	ORG $+2
$SG226716 DB	'Writers'' Guild', 00H
	ORG $+1
$SG226718 DB	'Spclsts', 00H
$SG226720 DB	'Slots', 00H
	ORG $+2
$SG226724 DB	'yes', 00H
$SG226725 DB	'no', 00H
	ORG $+1
$SG226726 DB	'Guilds', 00H
	ORG $+1
$SG226733 DB	'Artists'' Guild', 00H
	ORG $+1
$SG226735 DB	'Spclsts', 00H
$SG226737 DB	'Slots', 00H
	ORG $+2
$SG226741 DB	'yes', 00H
$SG226742 DB	'no', 00H
	ORG $+1
$SG226743 DB	'Acoustics', 00H
	ORG $+2
$SG226750 DB	'Musicians'' Guild', 00H
	ORG $+3
$SG226752 DB	'Spclsts', 00H
$SG226754 DB	'Slots', 00H
	ORG $+2
$SG226756 DB	'Great Works', 00H
$SG226758 DB	'Tourism', 00H
$SG226760 DB	'Theming Bonuses', 00H
$SG226775 DB	',', 00H
	ORG $+2
$SG226776 DB	',', 00H
	ORG $+2
$SG226784 DB	',', 00H
	ORG $+2
$SG226786 DB	'%d,', 00H
$SG226794 DB	',', 00H
	ORG $+2
$SG226796 DB	'%.2f,', 00H
	ORG $+2
$SG226814 DB	', %d,', 00H
	ORG $+2
$SG226815 DB	', Bonus: %d', 00H
$SG226823 DB	', ', 00H
	ORG $+1
$SG226824 DB	'Themed Building in, ', 00H
	ORG $+3
$SG226839 DB	'Acquired Work from Player: %d, Discarded: %d, Acquired: '
	DB	'%d', 00H
	ORG $+1
$SG226841 DB	', %d,', 00H
	ORG $+2
$SG226853 DB	'.csv', 00H
	ORG $+3
$SG226854 DB	'CultureAILog_', 00H
	ORG $+2
$SG226856 DB	'CultureAILog.csv', 00H
	ORG $+3
$SG227159 DB	'TXT_KEY_CO_CITY_TOURISM_GREAT_WORKS', 00H
$SG227177 DB	'TXT_KEY_CO_CITY_TOURISM_GREAT_WORKS', 00H
$SG227180 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227182 DB	'TXT_KEY_CO_CITY_TOURISM_THEMING_BONUSES', 00H
$SG227190 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227192 DB	'TXT_KEY_CO_CITY_TOURISM_TILES', 00H
	ORG $+2
$SG227196 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227198 DB	'TXT_KEY_CO_TOURISM_PER_CITY', 00H
$SG227207 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227209 DB	'TXT_KEY_CO_CITY_TOURISM_FAITH_BUILDINGS', 00H
$SG227224 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227226 DB	'TXT_KEY_CO_CITY_TOURISM_RELIGIOUS_ART', 00H
	ORG $+2
$SG227244 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227246 DB	'TXT_KEY_CO_CITY_TOURISM_TECH_ENHANCED', 00H
	ORG $+2
$SG227262 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227272 DB	'TXT_KEY_CO_CITY_TOURISM_BUILDING_BONUS', 00H
	ORG $+1
$SG227289 DB	', ', 00H
	ORG $+1
$SG227293 DB	', ', 00H
	ORG $+1
$SG227297 DB	', ', 00H
	ORG $+1
$SG227301 DB	', ', 00H
	ORG $+1
$SG227318 DB	', ', 00H
	ORG $+1
$SG227321 DB	', ', 00H
	ORG $+1
$SG227324 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227326 DB	'TXT_KEY_CO_CITY_TOURISM_RELIGION_BONUS', 00H
	ORG $+1
$SG227330 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227332 DB	'TXT_KEY_CO_CITY_TOURISM_OPEN_BORDERS_BONUS', 00H
	ORG $+1
$SG227336 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227338 DB	'TXT_KEY_CO_CITY_TOURISM_TRADE_ROUTE_BONUS', 00H
	ORG $+2
$SG227342 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227344 DB	'TXT_KEY_CO_CITY_TOURISM_LESS_HAPPY_BONUS', 00H
	ORG $+3
$SG227348 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227350 DB	'TXT_KEY_CO_CITY_TOURISM_COMMON_FOE_BONUS', 00H
	ORG $+3
$SG227353 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227355 DB	'TXT_KEY_CO_CITY_TOURISM_SHARED_IDEOLOGY_BONUS', 00H
	ORG $+2
$SG227359 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227361 DB	'TXT_KEY_CO_CITY_TOURISM_DIFFERENT_IDEOLOGY_PENALTY', 00H
	ORG $+1
$SG227366 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227368 DB	'TXT_KEY_CO_CITY_TOURISM_TECH_BONUS', 00H
	ORG $+1
$SG227372 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227374 DB	'TXT_KEY_CO_CITY_TOURISM_LEAGUES_BONUS', 00H
	ORG $+2
$SG227377 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227379 DB	'TXT_KEY_CO_CITY_TOURISM_CARNIVAL_BONUS', 00H
	ORG $+1
$SG227399 DB	'TXT_KEY_CO_GREAT_WORK_TT', 00H
	ORG $+3
$SG227419 DB	'TXT_KEY_CO_GREAT_WORK_SLOTS_TT_ENTRY', 00H
	ORG $+3
$SG227421 DB	'TXT_KEY_CO_GREAT_WORK_SLOTS_TT_ENTRY', 00H
	ORG $+3
$SG227423 DB	'TXT_KEY_CO_GREAT_WORK_SLOTS_TT_ENTRY', 00H
	ORG $+3
$SG227434 DB	'TXT_KEY_CO_GREAT_WORK_SLOTS_TT', 00H
	ORG $+1
$SG227482 DB	'+%d: ', 00H
	ORG $+2
$SG227487 DB	'BUILDINGCLASS_LOUVRE', 00H
	ORG $+3
$SG227488 DB	'BUILDINGCLASS_HERMITAGE', 00H
$SG227504 DB	'TXT_KEY_CO_WORLD_MUSEUM', 00H
$SG227524 DB	'TXT_KEY_CO_WORLD_MUSEUM', 00H
$SG227531 DB	'TXT_KEY_CO_NO_THEME', 00H
$SG227532 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG227597 DB	', ', 00H
	ORG $+1
$SG227611 DB	'%d, ', 00H
	ORG $+7
$SG227647 DB	'SELECT gw.ID FROM GreatWorks as gw left outer join Eras '
	DB	'on gw.EraType == Eras.Type inner join GreatWorkArtifactClasse'
	DB	's on gw.ArtifactClassType == GreatWorkArtifactClasses.Type wh'
	DB	'ere gw.GreatWorkClassType = ''GREAT_WORK_ARTIFACT'' and Eras.'
	DB	'ID is ? and GreatWorkArtifactClasses.ID == ? order by Random('
	DB	') limit 1;', 00H
	ORG $+3
$SG227649 DB	'select 1 from GreatWorks as gw inner join Eras on gw.Era'
	DB	'Type == Eras.Type inner join GreatWorkArtifactClasses on gw.A'
	DB	'rtifactClassType == GreatWorkArtifactClasses.Type where gw.Gr'
	DB	'eatWorkClassType = ''GREAT_WORK_ARTIFACT'' and Eras.ID = ? an'
	DB	'd GreatWorkArtifactClasses.ID == ? Limit 1;', 00H
	ORG $+7
$SG227671 DB	'SELECT GreatWorkClasses.ID from GreatWorkClasses inner j'
	DB	'oin GreatWorks on GreatWorkClassType = GreatWorkClasses.Type '
	DB	'where GreatWorks.ID = ?', 00H
	ORG $+3
$SG227684 DB	'SELECT Description FROM GreatWorks WHERE ID = ?', 00H
$SG227695 DB	'SELECT Audio FROM GreatWorks WHERE ID = ?', 00H
	ORG $+6
$SG227704 DB	'SELECT GreatWorkSlots.ID from GreatWorks inner join Grea'
	DB	'tWorkClasses  on GreatWorks.GreatWorkClassType == GreatWorkCl'
	DB	'asses .Type inner join GreatWorkSlots on GreatWorkClasses.Slo'
	DB	'tType == GreatWorkSlots.Type where GreatWorks .ID = ? LIMIT 1'
	DB	00H
$SG227733 DB	'GREAT_WORK_ARTIFACT', 00H
$SG227736 DB	'GREAT_WORK_ART', 00H
	ORG $+1
$SG228048 DB	'TXT_KEY_NOTIFICATION_SUMMARY_GREAT_WORK_SWAP', 00H
	ORG $+3
$SG228064 DB	'TXT_KEY_NOTIFICATION_GREAT_WORK_ART_SWAP', 00H
	ORG $+3
$SG228070 DB	'TXT_KEY_NOTIFICATION_ARTIFACT_SWAP', 00H
	ORG $+1
$SG228076 DB	'TXT_KEY_NOTIFICATION_GREAT_WORK_WRITING_SWAP', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ	; CvEconomicAI::GetVisibleAntiquitySites
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.h
;	COMDAT ?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ
_TEXT	SEGMENT
?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ PROC	; CvEconomicAI::GetVisibleAntiquitySites, COMDAT
; _this$ = ecx

; 236  : 		return m_iVisibleAntiquitySites;

	mov	eax, DWORD PTR [ecx+44]

; 237  : 	};

	ret	0
?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ ENDP	; CvEconomicAI::GetVisibleAntiquitySites
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvGreatWorkInMyEmpire@@QAE@XZ		; CvGreatWorkInMyEmpire::CvGreatWorkInMyEmpire
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
;	COMDAT ??0CvGreatWorkInMyEmpire@@QAE@XZ
_TEXT	SEGMENT
??0CvGreatWorkInMyEmpire@@QAE@XZ PROC			; CvGreatWorkInMyEmpire::CvGreatWorkInMyEmpire, COMDAT
; _this$ = ecx

; 714  : {

	mov	eax, ecx
	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 715  : }

	ret	0
??0CvGreatWorkInMyEmpire@@QAE@XZ ENDP			; CvGreatWorkInMyEmpire::CvGreatWorkInMyEmpire
_TEXT	ENDS
PUBLIC	??0CvGreatWorkInMyEmpire@@QAE@HHW4BuildingTypes@@HW4PlayerTypes@@W4EraTypes@@@Z ; CvGreatWorkInMyEmpire::CvGreatWorkInMyEmpire
; Function compile flags: /Ogtpy
;	COMDAT ??0CvGreatWorkInMyEmpire@@QAE@HHW4BuildingTypes@@HW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iCityID$ = 12						; size = 4
_eBuilding$ = 16					; size = 4
_iSlot$ = 20						; size = 4
_ePlayer$ = 24						; size = 4
_eEra$ = 28						; size = 4
??0CvGreatWorkInMyEmpire@@QAE@HHW4BuildingTypes@@HW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvGreatWorkInMyEmpire::CvGreatWorkInMyEmpire, COMDAT
; _this$ = ecx

; 729  : {

	mov	edx, DWORD PTR _iCityID$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _eBuilding$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _iSlot$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _eEra$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx

; 730  : }

	ret	24					; 00000018H
??0CvGreatWorkInMyEmpire@@QAE@HHW4BuildingTypes@@HW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvGreatWorkInMyEmpire::CvGreatWorkInMyEmpire
_TEXT	ENDS
PUBLIC	??0CvGreatWorkBuildingInMyEmpire@@QAE@XZ	; CvGreatWorkBuildingInMyEmpire::CvGreatWorkBuildingInMyEmpire
; Function compile flags: /Ogtpy
;	COMDAT ??0CvGreatWorkBuildingInMyEmpire@@QAE@XZ
_TEXT	SEGMENT
??0CvGreatWorkBuildingInMyEmpire@@QAE@XZ PROC		; CvGreatWorkBuildingInMyEmpire::CvGreatWorkBuildingInMyEmpire, COMDAT
; _this$ = ecx

; 739  : {

	mov	eax, ecx

; 740  : 	m_bThemed = false;

	xor	cl, cl
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	BYTE PTR [eax+8], cl

; 741  : 	m_bEndangered = false;

	mov	BYTE PTR [eax+9], cl

; 742  : }

	ret	0
??0CvGreatWorkBuildingInMyEmpire@@QAE@XZ ENDP		; CvGreatWorkBuildingInMyEmpire::CvGreatWorkBuildingInMyEmpire
_TEXT	ENDS
PUBLIC	??0CvGreatWorkBuildingInMyEmpire@@QAE@HW4BuildingTypes@@@Z ; CvGreatWorkBuildingInMyEmpire::CvGreatWorkBuildingInMyEmpire
; Function compile flags: /Ogtpy
;	COMDAT ??0CvGreatWorkBuildingInMyEmpire@@QAE@HW4BuildingTypes@@@Z
_TEXT	SEGMENT
_iCityID$ = 8						; size = 4
_eBuilding$ = 12					; size = 4
??0CvGreatWorkBuildingInMyEmpire@@QAE@HW4BuildingTypes@@@Z PROC ; CvGreatWorkBuildingInMyEmpire::CvGreatWorkBuildingInMyEmpire, COMDAT
; _this$ = ecx

; 748  : {

	mov	edx, DWORD PTR _eBuilding$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _iCityID$[esp-4]
	mov	DWORD PTR [eax], ecx

; 749  : 	m_bThemed = false;

	xor	cl, cl
	mov	DWORD PTR [eax+4], edx
	mov	BYTE PTR [eax+8], cl

; 750  : 	m_bEndangered = false;

	mov	BYTE PTR [eax+9], cl

; 751  : }

	ret	8
??0CvGreatWorkBuildingInMyEmpire@@QAE@HW4BuildingTypes@@@Z ENDP ; CvGreatWorkBuildingInMyEmpire::CvGreatWorkBuildingInMyEmpire
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z ; CvPlayerCulture::HasAvailableGreatWorkSlot
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z:PROC ; CvCityBuildings::HasAvailableGreatWorkSlot
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
;	COMDAT ?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_eGreatWorkSlot$ = 8					; size = 4
?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z PROC ; CvPlayerCulture::HasAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 798  : {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 799  : 	int iLoop;
; 800  : 	for (CvCity* pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN2@HasAvailab
	mov	edi, DWORD PTR _eGreatWorkSlot$[esp+8]
	npad	1
$LL4@HasAvailab:

; 801  : 	{
; 802  : 		if (pCity->GetCityBuildings()->HasAvailableGreatWorkSlot(eGreatWorkSlot))

	push	edi
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z ; CvCityBuildings::HasAvailableGreatWorkSlot
	test	al, al
	jne	SHORT $LN8@HasAvailab
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL4@HasAvailab
$LN2@HasAvailab:
	pop	edi

; 805  : 		}
; 806  : 	}
; 807  : 	return false;

	xor	al, al
	pop	esi

; 808  : }

	pop	ecx
	ret	4
$LN8@HasAvailab:
	pop	edi

; 803  : 		{
; 804  : 			return true;

	mov	al, 1
	pop	esi

; 808  : }

	pop	ecx
	ret	4
?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z ENDP ; CvPlayerCulture::HasAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
EXTRN	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z:PROC ; CvCityBuildings::GetNumAvailableGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_eGreatWorkSlot$ = 8					; size = 4
?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvPlayerCulture::GetNumAvailableGreatWorkSlots, COMDAT
; _this$ = ecx

; 818  : {

	push	ecx
	push	esi
	push	edi

; 819  : 	int iLoop;
; 820  : 	int iCount = 0;

	xor	edi, edi
	mov	esi, ecx

; 821  : #endif
; 822  : 
; 823  : 	for (CvCity* pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN8@GetNumAvai
	push	ebx
	mov	ebx, DWORD PTR _eGreatWorkSlot$[esp+12]
$LL3@GetNumAvai:

; 824  : 	{
; 825  : 		iCount += pCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eGreatWorkSlot);

	push	ebx
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetNumAvai
	pop	ebx
$LN8@GetNumAvai:

; 826  : 	}
; 827  : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi

; 828  : }

	pop	ecx
	ret	4
?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
_TEXT	ENDS
PUBLIC	?ControlsGreatWork@CvPlayerCulture@@QAE_NH@Z	; CvPlayerCulture::ControlsGreatWork
EXTRN	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z:PROC ; CvCityBuildings::GetBuildingGreatWork
EXTRN	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetGreatWorkCount
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?ControlsGreatWork@CvPlayerCulture@@QAE_NH@Z
_TEXT	SEGMENT
_iLoop$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?ControlsGreatWork@CvPlayerCulture@@QAE_NH@Z PROC	; CvPlayerCulture::ControlsGreatWork, COMDAT
; _this$ = ecx

; 937  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx

; 938  : 	CvCity* pLoopCity = NULL;
; 939  : 	int iLoop = 0;
; 940  : 
; 941  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx+292]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+28]
	push	eax
	mov	DWORD PTR _this$[esp+32], ebx
	mov	DWORD PTR _iLoop$[esp+32], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN11@ControlsGr
$LL13@ControlsGr:

; 942  : 	{
; 943  : #ifdef AUI_WARNING_FIXES
; 944  : 		for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 945  : #else
; 946  : 		for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN12@ControlsGr
$LL10@ControlsGr:

; 947  : #endif
; 948  : 		{
; 949  : 			CvCivilizationInfo& playerCivilizationInfo = m_pPlayer->getCivilizationInfo();

	mov	ecx, DWORD PTR [ebx+292]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 950  : 			BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 951  : 			if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN9@ControlsGr

; 952  : 			{
; 953  : 				CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax

; 954  : 				if (pkBuilding)

	test	ebx, ebx
	je	SHORT $LN23@ControlsGr

; 955  : 				{
; 956  : 					if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	esi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN23@ControlsGr

; 957  : 					{
; 958  : 						int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, ebx
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ebx, eax

; 959  : 						for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN23@ControlsGr
$LL4@ControlsGr:

; 960  : 						{
; 961  : 							int iGreatWorkIndex = pLoopCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	push	esi
	push	edi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 962  : 							if (iGreatWorkIndex == iIndex)

	cmp	eax, DWORD PTR _iIndex$[esp+20]
	je	SHORT $LN19@ControlsGr
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL4@ControlsGr
$LN23@ControlsGr:

; 959  : 						for (int iI = 0; iI < iNumSlots; iI++)

	mov	ebx, DWORD PTR _this$[esp+24]
$LN9@ControlsGr:

; 942  : 	{
; 943  : #ifdef AUI_WARNING_FIXES
; 944  : 		for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 945  : #else
; 946  : 		for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL10@ControlsGr
$LN12@ControlsGr:

; 938  : 	CvCity* pLoopCity = NULL;
; 939  : 	int iLoop = 0;
; 940  : 
; 941  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL13@ControlsGr
$LN11@ControlsGr:
	pop	edi
	pop	esi
	pop	ebp

; 965  : 							}
; 966  : 						}
; 967  : 					}
; 968  : 				}
; 969  : 			}
; 970  : 		}
; 971  : 	}
; 972  : 
; 973  : 	return false;	

	xor	al, al
	pop	ebx

; 974  : }

	add	esp, 8
	ret	4
$LN19@ControlsGr:
	pop	edi
	pop	esi
	pop	ebp

; 963  : 							{
; 964  : 								return true;

	mov	al, 1
	pop	ebx

; 974  : }

	add	esp, 8
	ret	4
?ControlsGreatWork@CvPlayerCulture@@QAE_NH@Z ENDP	; CvPlayerCulture::ControlsGreatWork
_TEXT	ENDS
PUBLIC	?GetSwappableWritingIndex@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetSwappableWritingIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetSwappableWritingIndex@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetSwappableWritingIndex@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetSwappableWritingIndex, COMDAT
; _this$ = ecx

; 1922 : 	return m_iSwappableWritingIndex;

	mov	eax, DWORD PTR [ecx+276]

; 1923 : }

	ret	0
?GetSwappableWritingIndex@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetSwappableWritingIndex
_TEXT	ENDS
PUBLIC	?GetSwappableArtIndex@CvPlayerCulture@@QBEHXZ	; CvPlayerCulture::GetSwappableArtIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetSwappableArtIndex@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetSwappableArtIndex@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetSwappableArtIndex, COMDAT
; _this$ = ecx

; 1927 : 	return m_iSwappableArtIndex;

	mov	eax, DWORD PTR [ecx+280]

; 1928 : }

	ret	0
?GetSwappableArtIndex@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetSwappableArtIndex
_TEXT	ENDS
PUBLIC	?GetSwappableArtifactIndex@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetSwappableArtifactIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetSwappableArtifactIndex@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetSwappableArtifactIndex@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetSwappableArtifactIndex, COMDAT
; _this$ = ecx

; 1932 : 	return m_iSwappableArtifactIndex;

	mov	eax, DWORD PTR [ecx+284]

; 1933 : }

	ret	0
?GetSwappableArtifactIndex@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetSwappableArtifactIndex
_TEXT	ENDS
PUBLIC	?GetSwappableMusicIndex@CvPlayerCulture@@QBEHXZ	; CvPlayerCulture::GetSwappableMusicIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetSwappableMusicIndex@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetSwappableMusicIndex@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetSwappableMusicIndex, COMDAT
; _this$ = ecx

; 1937 : 	return m_iSwappableMusicIndex;

	mov	eax, DWORD PTR [ecx+288]

; 1938 : }

	ret	0
?GetSwappableMusicIndex@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetSwappableMusicIndex
_TEXT	ENDS
PUBLIC	?SetSwappableWritingIndex@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::SetSwappableWritingIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetSwappableWritingIndex@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?SetSwappableWritingIndex@CvPlayerCulture@@QAEXH@Z PROC	; CvPlayerCulture::SetSwappableWritingIndex, COMDAT
; _this$ = ecx

; 1942 : 	m_iSwappableWritingIndex = iIndex;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [ecx+276], eax

; 1943 : }

	ret	4
?SetSwappableWritingIndex@CvPlayerCulture@@QAEXH@Z ENDP	; CvPlayerCulture::SetSwappableWritingIndex
_TEXT	ENDS
PUBLIC	?SetSwappableArtIndex@CvPlayerCulture@@QAEXH@Z	; CvPlayerCulture::SetSwappableArtIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetSwappableArtIndex@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?SetSwappableArtIndex@CvPlayerCulture@@QAEXH@Z PROC	; CvPlayerCulture::SetSwappableArtIndex, COMDAT
; _this$ = ecx

; 1947 : 	m_iSwappableArtIndex = iIndex;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [ecx+280], eax

; 1948 : }

	ret	4
?SetSwappableArtIndex@CvPlayerCulture@@QAEXH@Z ENDP	; CvPlayerCulture::SetSwappableArtIndex
_TEXT	ENDS
PUBLIC	?SetSwappableArtifactIndex@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::SetSwappableArtifactIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetSwappableArtifactIndex@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?SetSwappableArtifactIndex@CvPlayerCulture@@QAEXH@Z PROC ; CvPlayerCulture::SetSwappableArtifactIndex, COMDAT
; _this$ = ecx

; 1952 : 	m_iSwappableArtifactIndex = iIndex;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [ecx+284], eax

; 1953 : }

	ret	4
?SetSwappableArtifactIndex@CvPlayerCulture@@QAEXH@Z ENDP ; CvPlayerCulture::SetSwappableArtifactIndex
_TEXT	ENDS
PUBLIC	?SetSwappableMusicIndex@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::SetSwappableMusicIndex
; Function compile flags: /Ogtpy
;	COMDAT ?SetSwappableMusicIndex@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?SetSwappableMusicIndex@CvPlayerCulture@@QAEXH@Z PROC	; CvPlayerCulture::SetSwappableMusicIndex, COMDAT
; _this$ = ecx

; 1957 : 	m_iSwappableMusicIndex = iIndex;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [ecx+288], eax

; 1958 : }

	ret	4
?SetSwappableMusicIndex@CvPlayerCulture@@QAEXH@Z ENDP	; CvPlayerCulture::SetSwappableMusicIndex
_TEXT	ENDS
PUBLIC	?GetLastTurnLifetimeCulture@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetLastTurnLifetimeCulture
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastTurnLifetimeCulture@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetLastTurnLifetimeCulture@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetLastTurnLifetimeCulture, COMDAT
; _this$ = ecx

; 2554 : 	return m_iLastTurnLifetimeCulture;

	mov	eax, DWORD PTR [ecx+16]

; 2555 : }

	ret	0
?GetLastTurnLifetimeCulture@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetLastTurnLifetimeCulture
_TEXT	ENDS
PUBLIC	?SetLastTurnLifetimeCulture@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::SetLastTurnLifetimeCulture
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastTurnLifetimeCulture@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetLastTurnLifetimeCulture@CvPlayerCulture@@QAEXH@Z PROC ; CvPlayerCulture::SetLastTurnLifetimeCulture, COMDAT
; _this$ = ecx

; 2560 : 	m_iLastTurnLifetimeCulture = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 2561 : }

	ret	4
?SetLastTurnLifetimeCulture@CvPlayerCulture@@QAEXH@Z ENDP ; CvPlayerCulture::SetLastTurnLifetimeCulture
_TEXT	ENDS
PUBLIC	?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceOn
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceOn, COMDAT
; _this$ = ecx

; 2566 : 	CvAssertMsg (ePlayer >= 0, "Invalid player index");
; 2567 : 	CvAssertMsg (ePlayer < MAX_MAJOR_CIVS, "Invalid player index");
; 2568 : 
; 2569 : 	int iIndex = (int)ePlayer;
; 2570 : 	if (iIndex < 0 || iIndex >= MAX_MAJOR_CIVS) return 0;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@GetInfluen
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN1@GetInfluen

; 2571 : 	return m_aiCulturalInfluence[iIndex];

	mov	eax, DWORD PTR [ecx+eax*4+20]

; 2572 : }

	ret	4
$LN1@GetInfluen:

; 2566 : 	CvAssertMsg (ePlayer >= 0, "Invalid player index");
; 2567 : 	CvAssertMsg (ePlayer < MAX_MAJOR_CIVS, "Invalid player index");
; 2568 : 
; 2569 : 	int iIndex = (int)ePlayer;
; 2570 : 	if (iIndex < 0 || iIndex >= MAX_MAJOR_CIVS) return 0;

	xor	eax, eax

; 2572 : }

	ret	4
?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceOn
_TEXT	ENDS
PUBLIC	?ChangeInfluenceOn@CvPlayerCulture@@QAEXW4PlayerTypes@@H@Z ; CvPlayerCulture::ChangeInfluenceOn
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeInfluenceOn@CvPlayerCulture@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iValue$ = 12						; size = 4
?ChangeInfluenceOn@CvPlayerCulture@@QAEXW4PlayerTypes@@H@Z PROC ; CvPlayerCulture::ChangeInfluenceOn, COMDAT
; _this$ = ecx

; 2577 : 	CvAssertMsg (ePlayer >= 0, "Invalid player index");
; 2578 : 	CvAssertMsg (ePlayer < MAX_MAJOR_CIVS, "Invalid player index");
; 2579 : 
; 2580 : 	int iIndex = (int)ePlayer;
; 2581 : 	if (iIndex < 0 || iIndex >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@ChangeInfl
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN1@ChangeInfl

; 2582 : 	m_aiCulturalInfluence[iIndex] = m_aiCulturalInfluence[iIndex] + iValue;

	mov	edx, DWORD PTR _iValue$[esp-4]
	add	DWORD PTR [ecx+eax*4+20], edx
$LN1@ChangeInfl:

; 2583 : }

	ret	8
?ChangeInfluenceOn@CvPlayerCulture@@QAEXW4PlayerTypes@@H@Z ENDP ; CvPlayerCulture::ChangeInfluenceOn
_TEXT	ENDS
PUBLIC	?GetLastTurnInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetLastTurnInfluenceOn
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastTurnInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetLastTurnInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetLastTurnInfluenceOn, COMDAT
; _this$ = ecx

; 2588 : 	CvAssertMsg (ePlayer >= 0, "Invalid player index");
; 2589 : 	CvAssertMsg (ePlayer < MAX_MAJOR_CIVS, "Invalid player index");
; 2590 : 
; 2591 : 	int iIndex = (int)ePlayer;
; 2592 : 	if (iIndex < 0 || iIndex >= MAX_MAJOR_CIVS) return 0;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@GetLastTur
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN1@GetLastTur

; 2593 : 	return m_aiLastTurnCulturalInfluence[iIndex];

	mov	eax, DWORD PTR [ecx+eax*4+108]

; 2594 : }

	ret	4
$LN1@GetLastTur:

; 2588 : 	CvAssertMsg (ePlayer >= 0, "Invalid player index");
; 2589 : 	CvAssertMsg (ePlayer < MAX_MAJOR_CIVS, "Invalid player index");
; 2590 : 
; 2591 : 	int iIndex = (int)ePlayer;
; 2592 : 	if (iIndex < 0 || iIndex >= MAX_MAJOR_CIVS) return 0;

	xor	eax, eax

; 2594 : }

	ret	4
?GetLastTurnInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetLastTurnInfluenceOn
_TEXT	ENDS
PUBLIC	?GetPublicOpinionType@CvPlayerCulture@@QBE?AW4PublicOpinionTypes@@XZ ; CvPlayerCulture::GetPublicOpinionType
; Function compile flags: /Ogtpy
;	COMDAT ?GetPublicOpinionType@CvPlayerCulture@@QBE?AW4PublicOpinionTypes@@XZ
_TEXT	SEGMENT
?GetPublicOpinionType@CvPlayerCulture@@QBE?AW4PublicOpinionTypes@@XZ PROC ; CvPlayerCulture::GetPublicOpinionType, COMDAT
; _this$ = ecx

; 3360 : 	return m_eOpinion;

	mov	eax, DWORD PTR [ecx+200]

; 3361 : }

	ret	0
?GetPublicOpinionType@CvPlayerCulture@@QBE?AW4PublicOpinionTypes@@XZ ENDP ; CvPlayerCulture::GetPublicOpinionType
_TEXT	ENDS
PUBLIC	?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerCulture::GetPublicOpinionPreferredIdeology
; Function compile flags: /Ogtpy
;	COMDAT ?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerCulture::GetPublicOpinionPreferredIdeology, COMDAT
; _this$ = ecx

; 3366 : 	return m_ePreferredIdeology;

	mov	eax, DWORD PTR [ecx+212]

; 3367 : }

	ret	0
?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerCulture::GetPublicOpinionPreferredIdeology
_TEXT	ENDS
PUBLIC	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetPublicOpinionUnhappiness, COMDAT
; _this$ = ecx

; 3378 : 	return m_iOpinionUnhappiness;

	mov	eax, DWORD PTR [ecx+216]

; 3379 : }

	ret	0
?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetPublicOpinionUnhappiness
_TEXT	ENDS
PUBLIC	?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ ; CvPlayerCulture::GetPublicOpinionBiggestInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlayerCulture::GetPublicOpinionBiggestInfluence, COMDAT
; _this$ = ecx

; 3390 : 	return m_eOpinionBiggestInfluence;

	mov	eax, DWORD PTR [ecx+204]

; 3391 : }

	ret	0
?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlayerCulture::GetPublicOpinionBiggestInfluence
_TEXT	ENDS
PUBLIC	?GetTurnIdeologySwitch@CvPlayerCulture@@QBEHXZ	; CvPlayerCulture::GetTurnIdeologySwitch
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnIdeologySwitch@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetTurnIdeologySwitch@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetTurnIdeologySwitch, COMDAT
; _this$ = ecx

; 3396 : 	return m_iTurnIdeologySwitch;

	mov	eax, DWORD PTR [ecx+208]

; 3397 : }

	ret	0
?GetTurnIdeologySwitch@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetTurnIdeologySwitch
_TEXT	ENDS
PUBLIC	?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z	; CvPlayerCulture::SetTurnIdeologySwitch
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z PROC	; CvPlayerCulture::SetTurnIdeologySwitch, COMDAT
; _this$ = ecx

; 3400 : 	m_iTurnIdeologySwitch = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+208], eax

; 3401 : }

	ret	4
?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z ENDP	; CvPlayerCulture::SetTurnIdeologySwitch
_TEXT	ENDS
PUBLIC	?GetTotalThemingBonuses@CvPlayerCulture@@QBEHXZ	; CvPlayerCulture::GetTotalThemingBonuses
EXTRN	?GetThemingBonuses@CvCityBuildings@@QBEHXZ:PROC	; CvCityBuildings::GetThemingBonuses
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalThemingBonuses@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetTotalThemingBonuses@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetTotalThemingBonuses, COMDAT
; _this$ = ecx

; 3927 : {

	push	ecx
	push	esi
	push	edi

; 3928 : 	int iRtnValue = 0;

	xor	edi, edi
	mov	esi, ecx

; 3929 : 
; 3930 : 	CvCity *pCity;
; 3931 : 	int iLoop;
; 3932 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN8@GetTotalTh
	npad	4
$LL3@GetTotalTh:

; 3933 : 	{
; 3934 : 		iRtnValue += pCity->GetCityBuildings()->GetThemingBonuses();;

	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetThemingBonuses@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetThemingBonuses
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetTotalTh
$LN8@GetTotalTh:

; 3935 : 	}
; 3936 : 
; 3937 : 	return iRtnValue;

	mov	eax, edi
	pop	edi
	pop	esi

; 3938 : }

	pop	ecx
	ret	0
?GetTotalThemingBonuses@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetTotalThemingBonuses
_TEXT	ENDS
PUBLIC	??0CvCityCulture@@QAE@XZ			; CvCityCulture::CvCityCulture
; Function compile flags: /Ogtpy
;	COMDAT ??0CvCityCulture@@QAE@XZ
_TEXT	SEGMENT
??0CvCityCulture@@QAE@XZ PROC				; CvCityCulture::CvCityCulture, COMDAT
; _this$ = ecx

; 4341 : {

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 4342 : }

	ret	0
??0CvCityCulture@@QAE@XZ ENDP				; CvCityCulture::CvCityCulture
_TEXT	ENDS
PUBLIC	??1CvCityCulture@@QAE@XZ			; CvCityCulture::~CvCityCulture
; Function compile flags: /Ogtpy
;	COMDAT ??1CvCityCulture@@QAE@XZ
_TEXT	SEGMENT
??1CvCityCulture@@QAE@XZ PROC				; CvCityCulture::~CvCityCulture, COMDAT
; _this$ = ecx

; 4347 : }

	ret	0
??1CvCityCulture@@QAE@XZ ENDP				; CvCityCulture::~CvCityCulture
_TEXT	ENDS
PUBLIC	?Init@CvCityCulture@@QAEXPAVCvCity@@@Z		; CvCityCulture::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvCityCulture@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?Init@CvCityCulture@@QAEXPAVCvCity@@@Z PROC		; CvCityCulture::Init, COMDAT
; _this$ = ecx

; 4352 : 	m_pCity = pCity;

	mov	eax, DWORD PTR _pCity$[esp-4]
	mov	DWORD PTR [ecx], eax

; 4353 : }

	ret	4
?Init@CvCityCulture@@QAEXPAVCvCity@@@Z ENDP		; CvCityCulture::Init
_TEXT	ENDS
PUBLIC	?GetNumGreatWorks@CvCityCulture@@QBEHXZ		; CvCityCulture::GetNumGreatWorks
EXTRN	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ:PROC	; CvCityBuildings::GetNumGreatWorks
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorks@CvCityCulture@@QBEHXZ
_TEXT	SEGMENT
?GetNumGreatWorks@CvCityCulture@@QBEHXZ PROC		; CvCityCulture::GetNumGreatWorks, COMDAT
; _this$ = ecx

; 4362 : 	return m_pCity->GetCityBuildings()->GetNumGreatWorks();

	mov	ecx, DWORD PTR [ecx]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	jmp	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
?GetNumGreatWorks@CvCityCulture@@QBEHXZ ENDP		; CvCityCulture::GetNumGreatWorks
_TEXT	ENDS
PUBLIC	?GetNumGreatWorkSlots@CvCityCulture@@QBEHXZ	; CvCityCulture::GetNumGreatWorkSlots
EXTRN	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ:PROC ; CvCityBuildings::GetNumAvailableGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorkSlots@CvCityCulture@@QBEHXZ
_TEXT	SEGMENT
?GetNumGreatWorkSlots@CvCityCulture@@QBEHXZ PROC	; CvCityCulture::GetNumGreatWorkSlots, COMDAT
; _this$ = ecx

; 4371 : {

	push	esi
	mov	esi, ecx

; 4372 : 	return (m_pCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots() + GetNumGreatWorks());

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	add	eax, edi
	pop	edi
	pop	esi

; 4373 : }

	ret	0
?GetNumGreatWorkSlots@CvCityCulture@@QBEHXZ ENDP	; CvCityCulture::GetNumGreatWorkSlots
_TEXT	ENDS
PUBLIC	?GetNumAvailableGreatWorkSlots@CvCityCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvCityCulture::GetNumAvailableGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAvailableGreatWorkSlots@CvCityCulture@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_eSlotType$ = 8						; size = 4
?GetNumAvailableGreatWorkSlots@CvCityCulture@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvCityCulture::GetNumAvailableGreatWorkSlots, COMDAT
; _this$ = ecx

; 4382 : 	return (m_pCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eSlotType));

	mov	eax, DWORD PTR _eSlotType$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots

; 4383 : }

	ret	4
?GetNumAvailableGreatWorkSlots@CvCityCulture@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvCityCulture::GetNumAvailableGreatWorkSlots
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvGreatWork@@$0A@@@QAEAAVCvGreatWork@@I@Z ; BaseVector<CvGreatWork,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvGreatWork@@$0A@@@QAEAAVCvGreatWork@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvGreatWork@@$0A@@@QAEAAVCvGreatWork@@I@Z PROC ; BaseVector<CvGreatWork,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvGreatWork@@$0A@@@QAEAAVCvGreatWork@@I@Z ENDP ; BaseVector<CvGreatWork,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvGreatWork@@$0A@@@QBEABVCvGreatWork@@I@Z ; BaseVector<CvGreatWork,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvGreatWork@@$0A@@@QBEABVCvGreatWork@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvGreatWork@@$0A@@@QBEABVCvGreatWork@@I@Z PROC ; BaseVector<CvGreatWork,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 137  : 	};

	ret	4
??A?$BaseVector@VCvGreatWork@@$0A@@@QBEABVCvGreatWork@@I@Z ENDP ; BaseVector<CvGreatWork,0>::operator[]
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ ; BaseVector<CvGreatWork,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ PROC ; BaseVector<CvGreatWork,0>::begin, COMDAT
; _this$ = ecx

; 201  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 202  :     };

	ret	0
?begin@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ ENDP ; BaseVector<CvGreatWork,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ ; BaseVector<CvGreatWork,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ PROC ; BaseVector<CvGreatWork,0>::end, COMDAT
; _this$ = ecx

; 204  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 205  :     };

	ret	0
?end@?$BaseVector@VCvGreatWork@@$0A@@@QBEPBVCvGreatWork@@XZ ENDP ; BaseVector<CvGreatWork,0>::end
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@I@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@I@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@I@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAW4PlayerTypes@@I@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAW4PlayerTypes@@I@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAW4PlayerTypes@@I@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAVCvGreatWorkInMyEmpire@@I@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAVCvGreatWorkInMyEmpire@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAVCvGreatWorkInMyEmpire@@I@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 786  : 		}

	ret	4
??A?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAVCvGreatWorkInMyEmpire@@I@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkBuildingInMyEmpire@@XZ ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkBuildingInMyEmpire@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkBuildingInMyEmpire@@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkBuildingInMyEmpire@@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkBuildingInMyEmpire@@XZ ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkBuildingInMyEmpire@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkBuildingInMyEmpire@@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator->, COMDAT
; _this$ = ecx

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkBuildingInMyEmpire@@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator->
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkInMyEmpire@@XZ ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkInMyEmpire@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkInMyEmpire@@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEABVCvGreatWorkInMyEmpire@@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkInMyEmpire@@XZ ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkInMyEmpire@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkInMyEmpire@@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator->, COMDAT
; _this$ = ecx

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPBVCvGreatWorkInMyEmpire@@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator->
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkInMyEmpire@@XZ ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkInMyEmpire@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkInMyEmpire@@XZ PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkInMyEmpire@@XZ ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkInMyEmpire@@XZ ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkInMyEmpire@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkInMyEmpire@@XZ PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator->, COMDAT
; _this$ = ecx

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkInMyEmpire@@XZ ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator->
_TEXT	ENDS
PUBLIC	?size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAW4EraTypes@@I@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAW4EraTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAW4EraTypes@@I@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAW4EraTypes@@I@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEPAVCvGreatWork@@I@Z ; FStaticVector<CvGreatWork,22,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEPAVCvGreatWork@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEPAVCvGreatWork@@I@Z PROC ; FStaticVector<CvGreatWork,22,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 22			; 00000016H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEPAVCvGreatWork@@I@Z ENDP ; FStaticVector<CvGreatWork,22,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvGreatWork@@$0A@@@QAE@XZ	; BaseVector<CvGreatWork,0>::~BaseVector<CvGreatWork,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvGreatWork@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvGreatWork@@$0A@@@QAE@XZ PROC		; BaseVector<CvGreatWork,0>::~BaseVector<CvGreatWork,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvGreatWork@@$0A@@@QAE@XZ ENDP		; BaseVector<CvGreatWork,0>::~BaseVector<CvGreatWork,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvGreatWork@@$0A@@@IAE@XZ	; BaseVector<CvGreatWork,0>::BaseVector<CvGreatWork,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvGreatWork@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvGreatWork@@$0A@@@IAE@XZ PROC		; BaseVector<CvGreatWork,0>::BaseVector<CvGreatWork,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvGreatWork@@$0A@@@IAE@XZ ENDP		; BaseVector<CvGreatWork,0>::BaseVector<CvGreatWork,0>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >::~_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >::~_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >::~_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@XZ ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocator<CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@XZ PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocator<CvGreatWorkBuildingInMyEmpire>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@XZ ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocator<CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@XZ		; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ PROC		; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ ENDP		; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4PlayerTypes@@@std@@QAE@XZ	; std::allocator<enum PlayerTypes>::allocator<enum PlayerTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4PlayerTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4PlayerTypes@@@std@@QAE@XZ PROC		; std::allocator<enum PlayerTypes>::allocator<enum PlayerTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4PlayerTypes@@@std@@QAE@XZ ENDP		; std::allocator<enum PlayerTypes>::allocator<enum PlayerTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@I@Z ; std::allocator<enum PlayerTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@I@Z PROC ; std::allocator<enum PlayerTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@I@Z ENDP ; std::allocator<enum PlayerTypes>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@4

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >::~_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >::~_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >::~_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@XZ ; std::allocator<CvGreatWorkInMyEmpire>::allocator<CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@XZ PROC ; std::allocator<CvGreatWorkInMyEmpire>::allocator<CvGreatWorkInMyEmpire>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@XZ ENDP ; std::allocator<CvGreatWorkInMyEmpire>::allocator<CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@I@Z ; std::allocator<CvGreatWorkInMyEmpire>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@I@Z PROC ; std::allocator<CvGreatWorkInMyEmpire>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@I@Z ENDP ; std::allocator<CvGreatWorkInMyEmpire>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkBuildingInMyEmpire@@XZ ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkBuildingInMyEmpire@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkBuildingInMyEmpire@@XZ PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEAAVCvGreatWorkBuildingInMyEmpire@@XZ ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator==
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 24			; 00000018H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator==
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 24			; 00000018H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@5
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4EraTypes@@@std@@QAE@XZ		; std::allocator<enum EraTypes>::allocator<enum EraTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4EraTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4EraTypes@@@std@@QAE@XZ PROC		; std::allocator<enum EraTypes>::allocator<enum EraTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4EraTypes@@@std@@QAE@XZ ENDP		; std::allocator<enum EraTypes>::allocator<enum EraTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@I@Z ; std::allocator<enum EraTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@I@Z PROC ; std::allocator<enum EraTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@I@Z ENDP ; std::allocator<enum EraTypes>::deallocate
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator==
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233099 = -80						; size = 28
$T233098 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233099[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233098[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233099[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233098[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233098[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233098[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233098[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233099[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233098[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@ABV01@@Z ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocator<CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocator<CvGreatWorkBuildingInMyEmpire>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocator<CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@I@Z ; std::allocator<CvGreatWorkBuildingInMyEmpire>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@I@Z PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@I@Z ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233145 = -80						; size = 28
$T233144 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233145[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233144[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233145[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233144[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233144[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233144[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233144[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233145[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233144[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z	; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z ; std::allocator<CvPlot *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z PROC ; std::allocator<CvPlot *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z ENDP ; std::allocator<CvPlot *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233179 = -80						; size = 28
$T233178 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233179[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233178[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233179[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233178[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233178[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233178[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233178[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233179[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233178[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4PlayerTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum PlayerTypes>::allocator<enum PlayerTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4PlayerTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4PlayerTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum PlayerTypes>::allocator<enum PlayerTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4PlayerTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum PlayerTypes>::allocator<enum PlayerTypes>
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233210 = -80						; size = 28
$T233209 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233210[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233209[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233210[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233209[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233209[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233209[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233209[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233210[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233209[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >::_Container_base_aux_alloc_empty<std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@ABV01@@Z ; std::allocator<CvGreatWorkInMyEmpire>::allocator<CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvGreatWorkInMyEmpire>::allocator<CvGreatWorkInMyEmpire>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvGreatWorkInMyEmpire>::allocator<CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator-
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233256 = -80						; size = 28
$T233255 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233256[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233255[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233256[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233255[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233255[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233255[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233255[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233256[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233255[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4EraTypes@@@std@@QAE@ABV01@@Z	; std::allocator<enum EraTypes>::allocator<enum EraTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4EraTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4EraTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum EraTypes>::allocator<enum EraTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4EraTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum EraTypes>::allocator<enum EraTypes>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QBEIXZ ; std::allocator<CvGreatWorkBuildingInMyEmpire>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QBEIXZ PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QBEIXZ ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ	; std::allocator<CvPlot *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ PROC	; std::allocator<CvPlot *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ ENDP	; std::allocator<CvPlot *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4PlayerTypes@@@std@@QBEIXZ ; std::allocator<enum PlayerTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4PlayerTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4PlayerTypes@@@std@@QBEIXZ PROC	; std::allocator<enum PlayerTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4PlayerTypes@@@std@@QBEIXZ ENDP	; std::allocator<enum PlayerTypes>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QBEIXZ ; std::allocator<CvGreatWorkInMyEmpire>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QBEIXZ PROC ; std::allocator<CvGreatWorkInMyEmpire>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QBEIXZ ENDP ; std::allocator<CvGreatWorkInMyEmpire>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4EraTypes@@@std@@QBEIXZ	; std::allocator<enum EraTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4EraTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4EraTypes@@@std@@QBEIXZ PROC	; std::allocator<enum EraTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4EraTypes@@@std@@QBEIXZ ENDP	; std::allocator<enum EraTypes>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z ; FDataStream::operator<<<enum GreatWorkType>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z
_TEXT	SEGMENT
$T233347 = 8						; size = 4
_kData$ = 8						; size = 4
??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z PROC ; FDataStream::operator<<<enum GreatWorkType>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T233347[esp]
	mov	DWORD PTR $T233347[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z ENDP ; FDataStream::operator<<<enum GreatWorkType>
_TEXT	ENDS
PUBLIC	??$?6W4GreatWorkClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkClass@@@Z ; FDataStream::operator<<<enum GreatWorkClass>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6W4GreatWorkClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkClass@@@Z
_TEXT	SEGMENT
$T233351 = 8						; size = 4
_kData$ = 8						; size = 4
??$?6W4GreatWorkClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkClass@@@Z PROC ; FDataStream::operator<<<enum GreatWorkClass>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T233351[esp]
	mov	DWORD PTR $T233351[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6W4GreatWorkClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkClass@@@Z ENDP ; FDataStream::operator<<<enum GreatWorkClass>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z ; operator<<<CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z PROC ; operator<<<CvString>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	ecx, DWORD PTR _val$[esp-4]
	push	esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR _s$[esp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z ENDP ; operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$?6W4PublicOpinionTypes@@@FDataStream@@QAEAAV0@ABW4PublicOpinionTypes@@@Z ; FDataStream::operator<<<enum PublicOpinionTypes>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6W4PublicOpinionTypes@@@FDataStream@@QAEAAV0@ABW4PublicOpinionTypes@@@Z
_TEXT	SEGMENT
$T233373 = 8						; size = 4
_kData$ = 8						; size = 4
??$?6W4PublicOpinionTypes@@@FDataStream@@QAEAAV0@ABW4PublicOpinionTypes@@@Z PROC ; FDataStream::operator<<<enum PublicOpinionTypes>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T233373[esp]
	mov	DWORD PTR $T233373[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6W4PublicOpinionTypes@@@FDataStream@@QAEAAV0@ABW4PublicOpinionTypes@@@Z ENDP ; FDataStream::operator<<<enum PublicOpinionTypes>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkBuildingInMyEmpire>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z
_TEXT	SEGMENT
$T233377 = -12						; size = 12
$T233381 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z PROC ; std::_Allocate<CvGreatWorkBuildingInMyEmpire>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233381[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233377[esp+16]
	mov	DWORD PTR $T233381[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233377[esp+16]
	push	ecx
	mov	DWORD PTR $T233377[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z ENDP ; std::_Allocate<CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z
_TEXT	SEGMENT
$T233387 = -12						; size = 12
$T233391 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z PROC ; std::_Allocate<CvPlot *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233391[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233387[esp+16]
	mov	DWORD PTR $T233391[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233387[esp+16]
	push	ecx
	mov	DWORD PTR $T233387[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z ; std::_Allocate<enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T233397 = -12						; size = 12
$T233401 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z PROC ; std::_Allocate<enum PlayerTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233401[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233397[esp+16]
	mov	DWORD PTR $T233401[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233397[esp+16]
	push	ecx
	mov	DWORD PTR $T233397[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z
_TEXT	SEGMENT
$T233407 = -12						; size = 12
$T233411 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z PROC ; std::_Allocate<CvGreatWorkInMyEmpire>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233411[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233407[esp+16]
	mov	DWORD PTR $T233411[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233407[esp+16]
	push	ecx
	mov	DWORD PTR $T233407[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z ENDP ; std::_Allocate<CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z ; std::_Allocate<enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T233417 = -12						; size = 12
$T233421 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z PROC ; std::_Allocate<enum EraTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233421[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233417[esp+16]
	mov	DWORD PTR $T233421[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233417[esp+16]
	push	ecx
	mov	DWORD PTR $T233417[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum EraTypes>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z ; std::_Iter_random<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z PROC ; std::_Iter_random<CvPlot * *,CvPlot * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z ENDP ; std::_Iter_random<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z ; std::_Ptr_cat<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z PROC ; std::_Ptr_cat<CvPlot * *,CvPlot * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z ENDP ; std::_Ptr_cat<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4PlayerTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PlayerTypes@@0@Z ; std::_Iter_random<enum PlayerTypes *,enum PlayerTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4PlayerTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PlayerTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4PlayerTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PlayerTypes@@0@Z PROC ; std::_Iter_random<enum PlayerTypes *,enum PlayerTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4PlayerTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PlayerTypes@@0@Z ENDP ; std::_Iter_random<enum PlayerTypes *,enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4PlayerTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PlayerTypes@@0@Z ; std::_Ptr_cat<enum PlayerTypes *,enum PlayerTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4PlayerTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PlayerTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4PlayerTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PlayerTypes@@0@Z PROC ; std::_Ptr_cat<enum PlayerTypes *,enum PlayerTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4PlayerTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PlayerTypes@@0@Z ENDP ; std::_Ptr_cat<enum PlayerTypes *,enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkInMyEmpire@@0@Z ; std::_Iter_random<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkInMyEmpire@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkInMyEmpire@@0@Z PROC ; std::_Iter_random<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkInMyEmpire@@0@Z ENDP ; std::_Iter_random<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkInMyEmpire@@0@Z ; std::_Ptr_cat<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkInMyEmpire@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkInMyEmpire@@0@Z PROC ; std::_Ptr_cat<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvGreatWorkInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkInMyEmpire@@0@Z ENDP ; std::_Ptr_cat<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@3
	push	esi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@3
	pop	esi
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4EraTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4EraTypes@@0@Z ; std::_Iter_random<enum EraTypes *,enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4EraTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4EraTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4EraTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4EraTypes@@0@Z PROC ; std::_Iter_random<enum EraTypes *,enum EraTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4EraTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4EraTypes@@0@Z ENDP ; std::_Iter_random<enum EraTypes *,enum EraTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4EraTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4EraTypes@@0@Z ; std::_Ptr_cat<enum EraTypes *,enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4EraTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4EraTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4EraTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4EraTypes@@0@Z PROC ; std::_Ptr_cat<enum EraTypes *,enum EraTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4EraTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4EraTypes@@0@Z ENDP ; std::_Ptr_cat<enum EraTypes *,enum EraTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@4
	push	esi
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@4
	pop	esi
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkBuildingInMyEmpire@@0@Z ; std::_Ptr_cat<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkBuildingInMyEmpire@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkBuildingInMyEmpire@@0@Z PROC ; std::_Ptr_cat<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvGreatWorkBuildingInMyEmpire@@0@Z ENDP ; std::_Ptr_cat<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlot *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z ; std::_Fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z PROC ; std::_Fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z ENDP ; std::_Fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@0@Z ; std::_Iter_random<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@0@Z PROC ; std::_Iter_random<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@0@Z ENDP ; std::_Iter_random<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvGreatWorkBuildingInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@@Z ; std::_Move_cat<CvGreatWorkBuildingInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvGreatWorkBuildingInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvGreatWorkBuildingInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::_Move_cat<CvGreatWorkBuildingInMyEmpire *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvGreatWorkBuildingInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::_Move_cat<CvGreatWorkBuildingInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::_Fill<CvPlot * *,CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z PROC ; std::_Fill<CvPlot * *,CvPlot *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ENDP ; std::_Fill<CvPlot * *,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z ; std::_Move_cat<CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z PROC ; std::_Move_cat<CvPlot * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z ENDP ; std::_Move_cat<CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z ; std::_Fill<enum PlayerTypes *,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z PROC ; std::_Fill<enum PlayerTypes *,enum PlayerTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z ENDP ; std::_Fill<enum PlayerTypes *,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4PlayerTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PlayerTypes@@@Z ; std::_Move_cat<enum PlayerTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4PlayerTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PlayerTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4PlayerTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PlayerTypes@@@Z PROC ; std::_Move_cat<enum PlayerTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4PlayerTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PlayerTypes@@@Z ENDP ; std::_Move_cat<enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ; std::_Fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z PROC ; std::_Fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	eax, 24					; 00000018H
	cmp	eax, edx
	jne	SHORT $LL3@Fill@4
	pop	esi
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ENDP ; std::_Fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvGreatWorkInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkInMyEmpire@@@Z ; std::_Move_cat<CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvGreatWorkInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvGreatWorkInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkInMyEmpire@@@Z PROC ; std::_Move_cat<CvGreatWorkInMyEmpire *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvGreatWorkInMyEmpire@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvGreatWorkInMyEmpire@@@Z ENDP ; std::_Move_cat<CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z ; std::_Fill<enum EraTypes *,enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z PROC ; std::_Fill<enum EraTypes *,enum EraTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@5
	pop	esi
$LN1@Fill@5:

; 3160 : 	}

	ret	0
??$_Fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z ENDP ; std::_Fill<enum EraTypes *,enum EraTypes>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4EraTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4EraTypes@@@Z ; std::_Move_cat<enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4EraTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4EraTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4EraTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4EraTypes@@@Z PROC ; std::_Move_cat<enum EraTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4EraTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4EraTypes@@@Z ENDP ; std::_Move_cat<enum EraTypes *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEABW4EraTypes@@XZ ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEABW4EraTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEABW4EraTypes@@XZ PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEABW4EraTypes@@XZ ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEABW4PlayerTypes@@XZ ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEABW4PlayerTypes@@XZ PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEABW4PlayerTypes@@XZ ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator++
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@3
	push	esi
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@3
	pop	esi
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@4
	push	esi
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-24]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR [eax-24], esi
	mov	esi, DWORD PTR [ecx+4]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@4
	pop	esi
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@5
	push	esi
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@5
	pop	esi
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@ABV1@@Z ; std::_Construct<CvGreatWorkBuildingInMyEmpire,CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@ABV1@@Z PROC ; std::_Construct<CvGreatWorkBuildingInMyEmpire,CvGreatWorkBuildingInMyEmpire>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@VCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@ABV1@@Z ENDP ; std::_Construct<CvGreatWorkBuildingInMyEmpire,CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@@Z ; std::_Destroy<CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::_Destroy<CvGreatWorkBuildingInMyEmpire>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::_Destroy<CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Construct@W4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@ABW41@@Z ; std::_Construct<enum PlayerTypes,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@ABW41@@Z PROC ; std::_Construct<enum PlayerTypes,enum PlayerTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@W4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@ABW41@@Z ENDP ; std::_Construct<enum PlayerTypes,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4PlayerTypes@@@std@@YAXPAW4PlayerTypes@@@Z ; std::_Destroy<enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4PlayerTypes@@@std@@YAXPAW4PlayerTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4PlayerTypes@@@std@@YAXPAW4PlayerTypes@@@Z PROC ; std::_Destroy<enum PlayerTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4PlayerTypes@@@std@@YAXPAW4PlayerTypes@@@Z ENDP ; std::_Destroy<enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@ABV1@@Z ; std::_Construct<CvGreatWorkInMyEmpire,CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@ABV1@@Z PROC ; std::_Construct<CvGreatWorkInMyEmpire,CvGreatWorkInMyEmpire>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@VCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@ABV1@@Z ENDP ; std::_Construct<CvGreatWorkInMyEmpire,CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvGreatWorkInMyEmpire@@@std@@YAXPAVCvGreatWorkInMyEmpire@@@Z ; std::_Destroy<CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvGreatWorkInMyEmpire@@@std@@YAXPAVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvGreatWorkInMyEmpire@@@std@@YAXPAVCvGreatWorkInMyEmpire@@@Z PROC ; std::_Destroy<CvGreatWorkInMyEmpire>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvGreatWorkInMyEmpire@@@std@@YAXPAVCvGreatWorkInMyEmpire@@@Z ENDP ; std::_Destroy<CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Construct@W4EraTypes@@W41@@std@@YAXPAW4EraTypes@@ABW41@@Z ; std::_Construct<enum EraTypes,enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4EraTypes@@W41@@std@@YAXPAW4EraTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4EraTypes@@W41@@std@@YAXPAW4EraTypes@@ABW41@@Z PROC ; std::_Construct<enum EraTypes,enum EraTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@W4EraTypes@@W41@@std@@YAXPAW4EraTypes@@ABW41@@Z ENDP ; std::_Construct<enum EraTypes,enum EraTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4EraTypes@@@std@@YAXPAW4EraTypes@@@Z ; std::_Destroy<enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4EraTypes@@@std@@YAXPAW4EraTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4EraTypes@@@std@@YAXPAW4EraTypes@@@Z PROC	; std::_Destroy<enum EraTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4EraTypes@@@std@@YAXPAW4EraTypes@@@Z ENDP	; std::_Destroy<enum EraTypes>
_TEXT	ENDS
PUBLIC	??M?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator<
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator<, COMDAT
; _this$ = ecx

; 221  : 
; 222  :  #if _HAS_ITERATOR_DEBUGGING
; 223  : 		_Compat(_Right);
; 224  :  #else
; 225  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 226  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 227  : 
; 228  : 		return (_Myptr < _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 229  : 		}

	ret	4
??M?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@0@Z ; std::pair<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >::pair<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >::pair<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >::pair<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -12			; fffffff4H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator--
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z ; std::_Iter_cat<CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z PROC ; std::_Iter_cat<CvPlot * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z ENDP ; std::_Iter_cat<CvPlot * *>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	??$swap@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXAAVCvGreatWorkBuildingInMyEmpire@@0@Z ; std::swap<CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXAAVCvGreatWorkBuildingInMyEmpire@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXAAVCvGreatWorkBuildingInMyEmpire@@0@Z PROC ; std::swap<CvGreatWorkBuildingInMyEmpire>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvGreatWorkBuildingInMyEmpire@@@std@@YAXAAVCvGreatWorkBuildingInMyEmpire@@0@Z ENDP ; std::swap<CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	?getLANDMARK_MINOR_FRIENDSHIP_CHANGE@CvGlobals@@QAEHXZ ; CvGlobals::getLANDMARK_MINOR_FRIENDSHIP_CHANGE
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getLANDMARK_MINOR_FRIENDSHIP_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getLANDMARK_MINOR_FRIENDSHIP_CHANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getLANDMARK_MINOR_FRIENDSHIP_CHANGE, COMDAT
; _this$ = ecx

; 6196 : 		return m_iLANDMARK_MINOR_FRIENDSHIP_CHANGE;

	mov	eax, DWORD PTR [ecx+7120]

; 6197 : 	}

	ret	0
?getLANDMARK_MINOR_FRIENDSHIP_CHANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getLANDMARK_MINOR_FRIENDSHIP_CHANGE
_TEXT	ENDS
PUBLIC	?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ ; CvGlobals::getBASE_CULTURE_PER_GREAT_WORK
; Function compile flags: /Ogtpy
;	COMDAT ?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBASE_CULTURE_PER_GREAT_WORK, COMDAT
; _this$ = ecx

; 7511 : 		return m_iBASE_CULTURE_PER_GREAT_WORK;

	mov	eax, DWORD PTR [ecx+8208]

; 7512 : 	}

	ret	0
?getBASE_CULTURE_PER_GREAT_WORK@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBASE_CULTURE_PER_GREAT_WORK
_TEXT	ENDS
PUBLIC	?getBASE_TOURISM_PER_GREAT_WORK@CvGlobals@@QAEHXZ ; CvGlobals::getBASE_TOURISM_PER_GREAT_WORK
; Function compile flags: /Ogtpy
;	COMDAT ?getBASE_TOURISM_PER_GREAT_WORK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBASE_TOURISM_PER_GREAT_WORK@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBASE_TOURISM_PER_GREAT_WORK, COMDAT
; _this$ = ecx

; 7515 : 		return m_iBASE_TOURISM_PER_GREAT_WORK;

	mov	eax, DWORD PTR [ecx+8212]

; 7516 : 	}

	ret	0
?getBASE_TOURISM_PER_GREAT_WORK@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBASE_TOURISM_PER_GREAT_WORK
_TEXT	ENDS
PUBLIC	?getTOURISM_MODIFIER_SHARED_RELIGION@CvGlobals@@QAEHXZ ; CvGlobals::getTOURISM_MODIFIER_SHARED_RELIGION
; Function compile flags: /Ogtpy
;	COMDAT ?getTOURISM_MODIFIER_SHARED_RELIGION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTOURISM_MODIFIER_SHARED_RELIGION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTOURISM_MODIFIER_SHARED_RELIGION, COMDAT
; _this$ = ecx

; 7519 : 		return m_iTOURISM_MODIFIER_SHARED_RELIGION;

	mov	eax, DWORD PTR [ecx+8216]

; 7520 : 	}

	ret	0
?getTOURISM_MODIFIER_SHARED_RELIGION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTOURISM_MODIFIER_SHARED_RELIGION
_TEXT	ENDS
PUBLIC	?getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES@CvGlobals@@QAEHXZ ; CvGlobals::getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES
; Function compile flags: /Ogtpy
;	COMDAT ?getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES, COMDAT
; _this$ = ecx

; 7531 : 		return m_iTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES;

	mov	eax, DWORD PTR [ecx+8228]

; 7532 : 	}

	ret	0
?getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES
_TEXT	ENDS
PUBLIC	?getTOURISM_MODIFIER_DIPLOMAT@CvGlobals@@QAEHXZ	; CvGlobals::getTOURISM_MODIFIER_DIPLOMAT
; Function compile flags: /Ogtpy
;	COMDAT ?getTOURISM_MODIFIER_DIPLOMAT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTOURISM_MODIFIER_DIPLOMAT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getTOURISM_MODIFIER_DIPLOMAT, COMDAT
; _this$ = ecx

; 7535 : 		return m_iTOURISM_MODIFIER_DIPLOMAT;

	mov	eax, DWORD PTR [ecx+8232]

; 7536 : 	}

	ret	0
?getTOURISM_MODIFIER_DIPLOMAT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getTOURISM_MODIFIER_DIPLOMAT
_TEXT	ENDS
PUBLIC	?getMINIUMUM_TOURISM_BLAST_STRENGTH@CvGlobals@@QAEHXZ ; CvGlobals::getMINIUMUM_TOURISM_BLAST_STRENGTH
; Function compile flags: /Ogtpy
;	COMDAT ?getMINIUMUM_TOURISM_BLAST_STRENGTH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINIUMUM_TOURISM_BLAST_STRENGTH@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINIUMUM_TOURISM_BLAST_STRENGTH, COMDAT
; _this$ = ecx

; 7539 : 		return m_iMINIUMUM_TOURISM_BLAST_STRENGTH;

	mov	eax, DWORD PTR [ecx+8236]

; 7540 : 	}

	ret	0
?getMINIUMUM_TOURISM_BLAST_STRENGTH@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINIUMUM_TOURISM_BLAST_STRENGTH
_TEXT	ENDS
PUBLIC	?getCULTURE_LEVEL_EXOTIC@CvGlobals@@QAEHXZ	; CvGlobals::getCULTURE_LEVEL_EXOTIC
; Function compile flags: /Ogtpy
;	COMDAT ?getCULTURE_LEVEL_EXOTIC@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCULTURE_LEVEL_EXOTIC@CvGlobals@@QAEHXZ PROC		; CvGlobals::getCULTURE_LEVEL_EXOTIC, COMDAT
; _this$ = ecx

; 7543 : 		return m_iCULTURE_LEVEL_EXOTIC;

	mov	eax, DWORD PTR [ecx+8240]

; 7544 : 	}

	ret	0
?getCULTURE_LEVEL_EXOTIC@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getCULTURE_LEVEL_EXOTIC
_TEXT	ENDS
PUBLIC	?getCULTURE_LEVEL_FAMILIAR@CvGlobals@@QAEHXZ	; CvGlobals::getCULTURE_LEVEL_FAMILIAR
; Function compile flags: /Ogtpy
;	COMDAT ?getCULTURE_LEVEL_FAMILIAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCULTURE_LEVEL_FAMILIAR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCULTURE_LEVEL_FAMILIAR, COMDAT
; _this$ = ecx

; 7547 : 		return m_iCULTURE_LEVEL_FAMILIAR;

	mov	eax, DWORD PTR [ecx+8244]

; 7548 : 	}

	ret	0
?getCULTURE_LEVEL_FAMILIAR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCULTURE_LEVEL_FAMILIAR
_TEXT	ENDS
PUBLIC	?getCULTURE_LEVEL_POPULAR@CvGlobals@@QAEHXZ	; CvGlobals::getCULTURE_LEVEL_POPULAR
; Function compile flags: /Ogtpy
;	COMDAT ?getCULTURE_LEVEL_POPULAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCULTURE_LEVEL_POPULAR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCULTURE_LEVEL_POPULAR, COMDAT
; _this$ = ecx

; 7551 : 		return m_iCULTURE_LEVEL_POPULAR;

	mov	eax, DWORD PTR [ecx+8248]

; 7552 : 	}

	ret	0
?getCULTURE_LEVEL_POPULAR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCULTURE_LEVEL_POPULAR
_TEXT	ENDS
PUBLIC	?getCULTURE_LEVEL_INFLUENTIAL@CvGlobals@@QAEHXZ	; CvGlobals::getCULTURE_LEVEL_INFLUENTIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getCULTURE_LEVEL_INFLUENTIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCULTURE_LEVEL_INFLUENTIAL@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCULTURE_LEVEL_INFLUENTIAL, COMDAT
; _this$ = ecx

; 7555 : 		return m_iCULTURE_LEVEL_INFLUENTIAL;

	mov	eax, DWORD PTR [ecx+8252]

; 7556 : 	}

	ret	0
?getCULTURE_LEVEL_INFLUENTIAL@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCULTURE_LEVEL_INFLUENTIAL
_TEXT	ENDS
PUBLIC	?getCULTURE_LEVEL_DOMINANT@CvGlobals@@QAEHXZ	; CvGlobals::getCULTURE_LEVEL_DOMINANT
; Function compile flags: /Ogtpy
;	COMDAT ?getCULTURE_LEVEL_DOMINANT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCULTURE_LEVEL_DOMINANT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCULTURE_LEVEL_DOMINANT, COMDAT
; _this$ = ecx

; 7559 : 		return m_iCULTURE_LEVEL_DOMINANT;

	mov	eax, DWORD PTR [ecx+8256]

; 7560 : 	}

	ret	0
?getCULTURE_LEVEL_DOMINANT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCULTURE_LEVEL_DOMINANT
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_FREEDOM
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_FREEDOM, COMDAT
; _this$ = ecx

; 7599 : 		return m_iPOLICY_BRANCH_FREEDOM;

	mov	eax, DWORD PTR [ecx+8376]

; 7600 : 	}

	ret	0
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_FREEDOM
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY, COMDAT
; _this$ = ecx

; 7603 : 		return m_iPOLICY_BRANCH_AUTOCRACY;

	mov	eax, DWORD PTR [ecx+8380]

; 7604 : 	}

	ret	0
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_ORDER
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPOLICY_BRANCH_ORDER, COMDAT
; _this$ = ecx

; 7607 : 		return m_iPOLICY_BRANCH_ORDER;

	mov	eax, DWORD PTR [ecx+8384]

; 7608 : 	}

	ret	0
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPOLICY_BRANCH_ORDER
_TEXT	ENDS
PUBLIC	?getTEMPORARY_TOURISM_BOOST_MOD@CvGlobals@@QAEHXZ ; CvGlobals::getTEMPORARY_TOURISM_BOOST_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getTEMPORARY_TOURISM_BOOST_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTEMPORARY_TOURISM_BOOST_MOD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getTEMPORARY_TOURISM_BOOST_MOD, COMDAT
; _this$ = ecx

; 7658 : 		return m_iTEMPORARY_TOURISM_BOOST_MOD;

	mov	eax, DWORD PTR [ecx+8304]

; 7659 : 	}

	ret	0
?getTEMPORARY_TOURISM_BOOST_MOD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getTEMPORARY_TOURISM_BOOST_MOD
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9745 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9746 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?GetBonus@CvThemingBonusInfo@@QAEHXZ		; CvThemingBonusInfo::GetBonus
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
;	COMDAT ?GetBonus@CvThemingBonusInfo@@QAEHXZ
_TEXT	SEGMENT
?GetBonus@CvThemingBonusInfo@@QAEHXZ PROC		; CvThemingBonusInfo::GetBonus, COMDAT
; _this$ = ecx

; 41   : 	int GetBonus() {return m_iBonus;};

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetBonus@CvThemingBonusInfo@@QAEHXZ ENDP		; CvThemingBonusInfo::GetBonus
_TEXT	ENDS
PUBLIC	?IsSameEra@CvThemingBonusInfo@@QAE_NXZ		; CvThemingBonusInfo::IsSameEra
; Function compile flags: /Ogtpy
;	COMDAT ?IsSameEra@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsSameEra@CvThemingBonusInfo@@QAE_NXZ PROC		; CvThemingBonusInfo::IsSameEra, COMDAT
; _this$ = ecx

; 43   : 	bool IsSameEra() {return m_bSameEra;};

	mov	al, BYTE PTR [ecx+32]
	ret	0
?IsSameEra@CvThemingBonusInfo@@QAE_NXZ ENDP		; CvThemingBonusInfo::IsSameEra
_TEXT	ENDS
PUBLIC	?IsUniqueEras@CvThemingBonusInfo@@QAE_NXZ	; CvThemingBonusInfo::IsUniqueEras
; Function compile flags: /Ogtpy
;	COMDAT ?IsUniqueEras@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsUniqueEras@CvThemingBonusInfo@@QAE_NXZ PROC		; CvThemingBonusInfo::IsUniqueEras, COMDAT
; _this$ = ecx

; 44   : 	bool IsUniqueEras() {return m_bUniqueEras;};

	mov	al, BYTE PTR [ecx+33]
	ret	0
?IsUniqueEras@CvThemingBonusInfo@@QAE_NXZ ENDP		; CvThemingBonusInfo::IsUniqueEras
_TEXT	ENDS
PUBLIC	?IsMustBeArt@CvThemingBonusInfo@@QAE_NXZ	; CvThemingBonusInfo::IsMustBeArt
; Function compile flags: /Ogtpy
;	COMDAT ?IsMustBeArt@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsMustBeArt@CvThemingBonusInfo@@QAE_NXZ PROC		; CvThemingBonusInfo::IsMustBeArt, COMDAT
; _this$ = ecx

; 45   : 	bool IsMustBeArt() {return m_bMustBeArt;};

	mov	al, BYTE PTR [ecx+34]
	ret	0
?IsMustBeArt@CvThemingBonusInfo@@QAE_NXZ ENDP		; CvThemingBonusInfo::IsMustBeArt
_TEXT	ENDS
PUBLIC	?IsMustBeArtifact@CvThemingBonusInfo@@QAE_NXZ	; CvThemingBonusInfo::IsMustBeArtifact
; Function compile flags: /Ogtpy
;	COMDAT ?IsMustBeArtifact@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsMustBeArtifact@CvThemingBonusInfo@@QAE_NXZ PROC	; CvThemingBonusInfo::IsMustBeArtifact, COMDAT
; _this$ = ecx

; 46   : 	bool IsMustBeArtifact() {return m_bMustBeArtifact;};

	mov	al, BYTE PTR [ecx+35]
	ret	0
?IsMustBeArtifact@CvThemingBonusInfo@@QAE_NXZ ENDP	; CvThemingBonusInfo::IsMustBeArtifact
_TEXT	ENDS
PUBLIC	?IsMustBeEqualArtArtifact@CvThemingBonusInfo@@QAE_NXZ ; CvThemingBonusInfo::IsMustBeEqualArtArtifact
; Function compile flags: /Ogtpy
;	COMDAT ?IsMustBeEqualArtArtifact@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsMustBeEqualArtArtifact@CvThemingBonusInfo@@QAE_NXZ PROC ; CvThemingBonusInfo::IsMustBeEqualArtArtifact, COMDAT
; _this$ = ecx

; 47   : 	bool IsMustBeEqualArtArtifact() {return m_bMustBeEqualArtArtifact;};

	mov	al, BYTE PTR [ecx+36]
	ret	0
?IsMustBeEqualArtArtifact@CvThemingBonusInfo@@QAE_NXZ ENDP ; CvThemingBonusInfo::IsMustBeEqualArtArtifact
_TEXT	ENDS
PUBLIC	?IsRequiresOwner@CvThemingBonusInfo@@QAE_NXZ	; CvThemingBonusInfo::IsRequiresOwner
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresOwner@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsRequiresOwner@CvThemingBonusInfo@@QAE_NXZ PROC	; CvThemingBonusInfo::IsRequiresOwner, COMDAT
; _this$ = ecx

; 48   : 	bool IsRequiresOwner() {return m_bRequiresOwner;};

	mov	al, BYTE PTR [ecx+37]
	ret	0
?IsRequiresOwner@CvThemingBonusInfo@@QAE_NXZ ENDP	; CvThemingBonusInfo::IsRequiresOwner
_TEXT	ENDS
PUBLIC	?IsRequiresAnyButOwner@CvThemingBonusInfo@@QAE_NXZ ; CvThemingBonusInfo::IsRequiresAnyButOwner
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresAnyButOwner@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsRequiresAnyButOwner@CvThemingBonusInfo@@QAE_NXZ PROC	; CvThemingBonusInfo::IsRequiresAnyButOwner, COMDAT
; _this$ = ecx

; 49   : 	bool IsRequiresAnyButOwner() {return m_bRequiresAnyButOwner;};

	mov	al, BYTE PTR [ecx+38]
	ret	0
?IsRequiresAnyButOwner@CvThemingBonusInfo@@QAE_NXZ ENDP	; CvThemingBonusInfo::IsRequiresAnyButOwner
_TEXT	ENDS
PUBLIC	?IsRequiresSamePlayer@CvThemingBonusInfo@@QAE_NXZ ; CvThemingBonusInfo::IsRequiresSamePlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresSamePlayer@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsRequiresSamePlayer@CvThemingBonusInfo@@QAE_NXZ PROC	; CvThemingBonusInfo::IsRequiresSamePlayer, COMDAT
; _this$ = ecx

; 50   : 	bool IsRequiresSamePlayer() {return m_bRequiresSamePlayer;};

	mov	al, BYTE PTR [ecx+39]
	ret	0
?IsRequiresSamePlayer@CvThemingBonusInfo@@QAE_NXZ ENDP	; CvThemingBonusInfo::IsRequiresSamePlayer
_TEXT	ENDS
PUBLIC	?IsRequiresUniquePlayers@CvThemingBonusInfo@@QAE_NXZ ; CvThemingBonusInfo::IsRequiresUniquePlayers
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresUniquePlayers@CvThemingBonusInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsRequiresUniquePlayers@CvThemingBonusInfo@@QAE_NXZ PROC ; CvThemingBonusInfo::IsRequiresUniquePlayers, COMDAT
; _this$ = ecx

; 51   : 	bool IsRequiresUniquePlayers() {return m_bRequiresUniquePlayers;};

	mov	al, BYTE PTR [ecx+40]
	ret	0
?IsRequiresUniquePlayers@CvThemingBonusInfo@@QAE_NXZ ENDP ; CvThemingBonusInfo::IsRequiresUniquePlayers
_TEXT	ENDS
PUBLIC	?GetAIPriority@CvThemingBonusInfo@@QAEHXZ	; CvThemingBonusInfo::GetAIPriority
; Function compile flags: /Ogtpy
;	COMDAT ?GetAIPriority@CvThemingBonusInfo@@QAEHXZ
_TEXT	SEGMENT
?GetAIPriority@CvThemingBonusInfo@@QAEHXZ PROC		; CvThemingBonusInfo::GetAIPriority, COMDAT
; _this$ = ecx

; 52   : 	int GetAIPriority() {return m_iAIPriority;};

	mov	eax, DWORD PTR [ecx+44]
	ret	0
?GetAIPriority@CvThemingBonusInfo@@QAEHXZ ENDP		; CvThemingBonusInfo::GetAIPriority
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetNumThemingBonuses@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumThemingBonuses
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumThemingBonuses@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumThemingBonuses@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNumThemingBonuses, COMDAT
; _this$ = ecx

; 324  : 	int GetNumThemingBonuses() const {return m_iNumThemingBonuses;};

	mov	eax, DWORD PTR [ecx+1008]
	ret	0
?GetNumThemingBonuses@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNumThemingBonuses
_TEXT	ENDS
PUBLIC	?GetCapitalThemingBonusModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetCapitalThemingBonusModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetCapitalThemingBonusModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalThemingBonusModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetCapitalThemingBonusModifier, COMDAT
; _this$ = ecx

; 557  : 		return m_iCapitalThemingBonusModifier;

	mov	eax, DWORD PTR [ecx+148]

; 558  : 	}

	ret	0
?GetCapitalThemingBonusModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetCapitalThemingBonusModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGoldenAgeTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGoldenAgeTourismModifier, COMDAT
; _this$ = ecx

; 593  : 		return m_iGoldenAgeTourismModifier;

	mov	eax, DWORD PTR [ecx+184]

; 594  : 	};

	ret	0
?GetGoldenAgeTourismModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGoldenAgeTourismModifier
_TEXT	ENDS
PUBLIC	?GetFaithBuildingTourism@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetFaithBuildingTourism
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.h
;	COMDAT ?GetFaithBuildingTourism@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
?GetFaithBuildingTourism@CvReligionBeliefs@@QBEHXZ PROC	; CvReligionBeliefs::GetFaithBuildingTourism, COMDAT
; _this$ = ecx

; 467  : 		return m_iFaithBuildingTourism;

	mov	eax, DWORD PTR [ecx+120]

; 468  : 	}

	ret	0
?GetFaithBuildingTourism@CvReligionBeliefs@@QBEHXZ ENDP	; CvReligionBeliefs::GetFaithBuildingTourism
_TEXT	ENDS
PUBLIC	?GetReportedSomeoneInfluential@CvGameCulture@@QBE_NXZ ; CvGameCulture::GetReportedSomeoneInfluential
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.h
;	COMDAT ?GetReportedSomeoneInfluential@CvGameCulture@@QBE_NXZ
_TEXT	SEGMENT
?GetReportedSomeoneInfluential@CvGameCulture@@QBE_NXZ PROC ; CvGameCulture::GetReportedSomeoneInfluential, COMDAT
; _this$ = ecx

; 92   : 		return m_bReportedSomeoneInfluential;

	mov	al, BYTE PTR [ecx+1072]

; 93   : 	};

	ret	0
?GetReportedSomeoneInfluential@CvGameCulture@@QBE_NXZ ENDP ; CvGameCulture::GetReportedSomeoneInfluential
_TEXT	ENDS
PUBLIC	?SetReportedSomeoneInfluential@CvGameCulture@@QAEX_N@Z ; CvGameCulture::SetReportedSomeoneInfluential
; Function compile flags: /Ogtpy
;	COMDAT ?SetReportedSomeoneInfluential@CvGameCulture@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetReportedSomeoneInfluential@CvGameCulture@@QAEX_N@Z PROC ; CvGameCulture::SetReportedSomeoneInfluential, COMDAT
; _this$ = ecx

; 96   : 		m_bReportedSomeoneInfluential = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [ecx+1072], al

; 97   : 	};

	ret	4
?SetReportedSomeoneInfluential@CvGameCulture@@QAEX_N@Z ENDP ; CvGameCulture::SetReportedSomeoneInfluential
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvGreatWork@@$0A@@@QBEIXZ	; BaseVector<CvGreatWork,0>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@VCvGreatWork@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvGreatWork@@$0A@@@QBEIXZ PROC	; BaseVector<CvGreatWork,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvGreatWork@@$0A@@@QBEIXZ ENDP	; BaseVector<CvGreatWork,0>::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233831 = -80						; size = 28
$T233830 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233831[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233830[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233831[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233830[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233830[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233830[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233830[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233831[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233830[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T233896 = -12						; size = 12
$T233900 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233900[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233896[esp+16]
	mov	DWORD PTR $T233900[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233896[esp+16]
	push	ecx
	mov	DWORD PTR $T233896[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@5

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@5:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@6
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@6:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@6
	pop	esi
$LN1@Fill@6:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@6

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@6:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@2:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T234171 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T234171[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T234171[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T234171[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T234171[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??0CvGreatWork@@QAE@XZ				; CvGreatWork::CvGreatWork
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
;	COMDAT ??0CvGreatWork@@QAE@XZ
_TEXT	SEGMENT
??0CvGreatWork@@QAE@XZ PROC				; CvGreatWork::CvGreatWork, COMDAT
; _this$ = ecx

; 31   : {

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	or	eax, -1
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax

; 32   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvGreatWork@@QAE@XZ ENDP				; CvGreatWork::CvGreatWork
_TEXT	ENDS
PUBLIC	??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z ; CvGreatWork::CvGreatWork
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z$1
__ehfuncinfo$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_szGreatPersonName$ = 8					; size = 28
_eType$ = 36						; size = 4
_eClassType$ = 40					; size = 4
_iTurn$ = 44						; size = 4
_eEra$ = 48						; size = 4
_ePlayer$ = 52						; size = 4
??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z PROC ; CvGreatWork::CvGreatWork, COMDAT
; _this$ = ecx

; 42   : {

	push	-1
	push	__ehhandler$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	eax, DWORD PTR _szGreatPersonName$[esp+16]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _eType$[esp+16]
	mov	edx, DWORD PTR _eClassType$[esp+16]
	mov	eax, DWORD PTR _iTurn$[esp+16]
	mov	DWORD PTR [esi+28], ecx
	mov	ecx, DWORD PTR _eEra$[esp+16]
	mov	DWORD PTR [esi+32], edx
	mov	edx, DWORD PTR _ePlayer$[esp+16]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], edx

; 43   : 	m_iTurnFounded = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 44   : }

	lea	ecx, DWORD PTR _szGreatPersonName$[esp+16]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	48					; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _szGreatPersonName$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGreatWork@@QAE@VCvString@@W4GreatWorkType@@W4GreatWorkClass@@HW4EraTypes@@W4PlayerTypes@@@Z ENDP ; CvGreatWork::CvGreatWork
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvGreatWork@@@Z	; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvGreatWork@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T234231 = 8						; size = 4
$T234226 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvGreatWork@@@Z PROC	; operator<<, COMDAT

; 84   : {

	push	ecx
	push	esi

; 85   : 	uint uiVersion = 3;
; 86   : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 3
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 87   : 
; 88   : 	saveTo << readFrom.m_szGreatPersonName;

	mov	edi, DWORD PTR _readFrom$[esp+8]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 89   : 
; 90   : 	saveTo << readFrom.m_eType;

	mov	ecx, DWORD PTR [edi+28]
	lea	edx, DWORD PTR $T234226[esp+8]
	mov	DWORD PTR $T234226[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 91   : 	saveTo << readFrom.m_eClassType;

	mov	eax, DWORD PTR [edi+32]
	lea	ecx, DWORD PTR $T234231[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T234231[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 92   : 	
; 93   : 	saveTo << readFrom.m_iTurnFounded;

	lea	edx, DWORD PTR [edi+36]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 94   : 	saveTo << readFrom.m_eEra;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<

; 95   : 	saveTo << readFrom.m_ePlayer;

	add	edi, 44					; 0000002cH
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 16					; 00000010H
	pop	edi

; 96   : 
; 97   : 	return saveTo;

	mov	eax, esi
	pop	esi

; 98   : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvGreatWork@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??1CvGreatWork@@QAE@XZ				; CvGreatWork::~CvGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ??1CvGreatWork@@QAE@XZ
_TEXT	SEGMENT
??1CvGreatWork@@QAE@XZ PROC				; CvGreatWork::~CvGreatWork, COMDAT
; _this$ = ecx
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvGreatWork@@QAE@XZ ENDP				; CvGreatWork::~CvGreatWork
_TEXT	ENDS
PUBLIC	?GetGreatWorkType@CvGameCulture@@QBE?AW4GreatWorkType@@H@Z ; CvGameCulture::GetGreatWorkType
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkType@CvGameCulture@@QBE?AW4GreatWorkType@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetGreatWorkType@CvGameCulture@@QBE?AW4GreatWorkType@@H@Z PROC ; CvGameCulture::GetGreatWorkType, COMDAT
; _this$ = ecx

; 150  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 151  : 	const CvGreatWork* pWork = &m_CurrentGreatWorks[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]

; 152  : 	return pWork->m_eType;

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	mov	eax, DWORD PTR [eax+ecx+28]

; 153  : }

	ret	4
?GetGreatWorkType@CvGameCulture@@QBE?AW4GreatWorkType@@H@Z ENDP ; CvGameCulture::GetGreatWorkType
_TEXT	ENDS
PUBLIC	?GetGreatWorkClass@CvGameCulture@@QBE?AW4GreatWorkClass@@H@Z ; CvGameCulture::GetGreatWorkClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkClass@CvGameCulture@@QBE?AW4GreatWorkClass@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetGreatWorkClass@CvGameCulture@@QBE?AW4GreatWorkClass@@H@Z PROC ; CvGameCulture::GetGreatWorkClass, COMDAT
; _this$ = ecx

; 157  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 158  : 	const CvGreatWork* pWork = &m_CurrentGreatWorks[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]

; 159  : 	return pWork->m_eClassType;

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	mov	eax, DWORD PTR [eax+ecx+32]

; 160  : }

	ret	4
?GetGreatWorkClass@CvGameCulture@@QBE?AW4GreatWorkClass@@H@Z ENDP ; CvGameCulture::GetGreatWorkClass
_TEXT	ENDS
PUBLIC	?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkArtist
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z$0
__ehfuncinfo$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z
_TEXT	SEGMENT
$T234260 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z PROC ; CvGameCulture::GetGreatWorkArtist, COMDAT
; _this$ = ecx

; 223  : {

	push	-1
	push	__ehhandler$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR $T234260[esp+24], 0

; 224  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 225  : 	CvString szArtist = "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	edi, ecx
	push	OFFSET $SG223142
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 226  : 
; 227  : 	const CvGreatWork *pWork = &m_CurrentGreatWorks[iIndex];
; 228  : 	szArtist = pWork->m_szGreatPersonName;
; 229  : 
; 230  : 	return szArtist;

	mov	eax, DWORD PTR _iIndex$[esp+20]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	mov	ecx, esi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR $T234260[esp+28], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 231  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z$0:
	mov	eax, DWORD PTR $T234260[ebp]
	and	eax, 1
	je	$LN4@GetGreatWo
	and	DWORD PTR $T234260[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetGreatWo:
	ret	0
__ehhandler$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkArtist@CvGameCulture@@QBE?AVCvString@@H@Z ENDP ; CvGameCulture::GetGreatWorkArtist
PUBLIC	?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkEra
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	?setDateStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z:PROC ; CvGameTextMgr::setDateStr
EXTRN	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ:PROC ; CvGame::getCalendar
EXTRN	?getStartYear@CvGame@@QBEHXZ:PROC		; CvGame::getStartYear
EXTRN	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ:PROC ; CvGame::getGameSpeedType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z$1
__ehfuncinfo$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z
_TEXT	SEGMENT
$T234286 = -44						; size = 4
_strYearString$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z PROC ; CvGameCulture::GetGreatWorkEra, COMDAT
; _this$ = ecx

; 235  : {

	push	-1
	push	__ehhandler$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T234286[esp+60], edi

; 236  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 237  : 	CvString szEra = "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+56]
	mov	ebp, ecx
	push	OFFSET $SG223150
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+72], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 238  : 
; 239  : 	const CvGreatWork *pWork = &m_CurrentGreatWorks[iIndex];
; 240  : 
; 241  : 	CvString strYearString;
; 242  : 	CvGameTextMgr::setDateStr(strYearString,
; 243  : 		pWork->m_iTurnFounded,
; 244  : 		false /*bSave*/,
; 245  : 		GC.getGame().getCalendar(),
; 246  : 		GC.getGame().getStartYear(),
; 247  : 		GC.getGame().getGameSpeedType());
; 248  : 
; 249  : 	szEra += GC.getEraInfo(pWork->m_eEra)->GetDescription();
; 250  : 	szEra += " (";
; 251  : 	szEra += strYearString;
; 252  : 	szEra += ")";
; 253  : 
; 254  : 	return szEra;

	mov	eax, DWORD PTR _iIndex$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+68], edi
	lea	edi, DWORD PTR [eax+eax*2]
	mov	ebx, 1
	shl	edi, 4
	add	edi, DWORD PTR [ebp]
	lea	ecx, DWORD PTR _strYearString$[esp+60]
	mov	DWORD PTR $T234286[esp+60], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	mov	ebp, ecx
	mov	ebx, ecx
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	push	eax
	mov	ecx, ebp
	call	?getStartYear@CvGame@@QBEHXZ		; CvGame::getStartYear
	push	eax
	mov	ecx, ebx
	call	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ ; CvGame::getCalendar
	push	eax
	mov	eax, DWORD PTR [edi+36]
	push	0
	push	eax
	lea	ecx, DWORD PTR _strYearString$[esp+80]
	push	ecx
	call	?setDateStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z ; CvGameTextMgr::setDateStr
	mov	edx, DWORD PTR [edi+40]
	add	esp, 24					; 00000018H
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	push	OFFSET $SG223153
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	lea	eax, DWORD PTR _strYearString$[esp+60]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	push	OFFSET $SG223154
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	lea	ecx, DWORD PTR _strYearString$[esp+60]
	mov	BYTE PTR __$EHRec$[esp+68], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 255  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z$0:
	mov	eax, DWORD PTR $T234286[ebp]
	and	eax, 1
	je	$LN4@GetGreatWo@2
	and	DWORD PTR $T234286[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetGreatWo@2:
	ret	0
__unwindfunclet$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z$1:
	lea	ecx, DWORD PTR _strYearString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkEra@CvGameCulture@@QBE?AVCvString@@H@Z ENDP ; CvGameCulture::GetGreatWorkEra
PUBLIC	?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkEraAbbreviation
EXTRN	?getAbbreviation@CvEraInfo@@QBEPBDXZ:PROC	; CvEraInfo::getAbbreviation
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z$0
__ehfuncinfo$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z
_TEXT	SEGMENT
$T234334 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z PROC ; CvGameCulture::GetGreatWorkEraAbbreviation, COMDAT
; _this$ = ecx

; 258  : {

	push	-1
	push	__ehhandler$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR $T234334[esp+24], 0

; 259  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 260  : 	CvString szEra = "";

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	esi, ecx
	push	OFFSET $SG223161
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 264  : 
; 265  : 	return szEra;	

	mov	eax, DWORD PTR _iIndex$[esp+20]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	eax, DWORD PTR [eax+40]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR $T234334[esp+28], 1
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getAbbreviation@CvEraInfo@@QBEPBDXZ	; CvEraInfo::getAbbreviation
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN13@GetGreatWo@3
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, edi
	pop	edi
	pop	esi

; 266  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8

; 261  : 
; 262  : 	const CvGreatWork *pWork = &m_CurrentGreatWorks[iIndex];
; 263  : 	szEra = GC.getEraInfo(pWork->m_eEra)->getAbbreviation();

$LN13@GetGreatWo@3:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 266  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z$0:
	mov	eax, DWORD PTR $T234334[ebp]
	and	eax, 1
	je	$LN4@GetGreatWo@3
	and	DWORD PTR $T234334[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetGreatWo@3:
	ret	0
__ehhandler$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkEraAbbreviation@CvGameCulture@@QBE?AVCvString@@H@Z ENDP ; CvGameCulture::GetGreatWorkEraAbbreviation
PUBLIC	?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkEraShort
EXTRN	?getShortDesc@CvEraInfo@@QBEPBDXZ:PROC		; CvEraInfo::getShortDesc
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z$0
__ehfuncinfo$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z
_TEXT	SEGMENT
$T234364 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z PROC ; CvGameCulture::GetGreatWorkEraShort, COMDAT
; _this$ = ecx

; 269  : {

	push	-1
	push	__ehhandler$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR $T234364[esp+24], 0

; 270  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 271  : 	CvString szEra = "";

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	esi, ecx
	push	OFFSET $SG223169
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 275  : 
; 276  : 	return szEra;	

	mov	eax, DWORD PTR _iIndex$[esp+20]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	eax, DWORD PTR [eax+40]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR $T234364[esp+28], 1
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getShortDesc@CvEraInfo@@QBEPBDXZ	; CvEraInfo::getShortDesc
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN13@GetGreatWo@4
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, edi
	pop	edi
	pop	esi

; 277  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8

; 272  : 
; 273  : 	const CvGreatWork *pWork = &m_CurrentGreatWorks[iIndex];
; 274  : 	szEra = GC.getEraInfo(pWork->m_eEra)->getShortDesc();

$LN13@GetGreatWo@4:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 277  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z$0:
	mov	eax, DWORD PTR $T234364[ebp]
	and	eax, 1
	je	$LN4@GetGreatWo@4
	and	DWORD PTR $T234364[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetGreatWo@4:
	ret	0
__ehhandler$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkEraShort@CvGameCulture@@QBE?AVCvString@@H@Z ENDP ; CvGameCulture::GetGreatWorkEraShort
PUBLIC	?GetGreatWorkCreator@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z ; CvGameCulture::GetGreatWorkCreator
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkCreator@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetGreatWorkCreator@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z PROC ; CvGameCulture::GetGreatWorkCreator, COMDAT
; _this$ = ecx

; 281  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 282  : 	const CvGreatWork *pWork = &m_CurrentGreatWorks[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]

; 283  : 	return pWork->m_ePlayer;

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	mov	eax, DWORD PTR [eax+ecx+44]

; 284  : }

	ret	4
?GetGreatWorkCreator@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z ENDP ; CvGameCulture::GetGreatWorkCreator
_TEXT	ENDS
PUBLIC	?GetGreatWorkController@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z ; CvGameCulture::GetGreatWorkController
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkController@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_uiPlayer$223180 = -12					; size = 4
tv240 = -8						; size = 4
_iCityLoop$223186 = -4					; size = 4
_iIndex$ = 8						; size = 4
?GetGreatWorkController@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z PROC ; CvGameCulture::GetGreatWorkController, COMDAT
; _this$ = ecx

; 287  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 288  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 289  : 	
; 290  : 	// for each player
; 291  : 	//   for each building
; 292  : 	//     for each slot
; 293  : 	//       check to see if it holds this work
; 294  : 
; 295  : 	for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _uiPlayer$223180[esp+28], 0
	mov	DWORD PTR tv240[esp+28], ebx
$LL16@GetGreatWo@5:

; 296  : 	{
; 297  : 		PlayerTypes ePlayer = (PlayerTypes)uiPlayer;
; 298  : 
; 299  : 		int iCityLoop;
; 300  : 		CvCity* pCity = NULL;
; 301  : 		for (pCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pCity != NULL; pCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop$223186[esp+32]
	lea	ecx, DWORD PTR [ebx+eax]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN15@GetGreatWo@5
$LL13@GetGreatWo@5:

; 302  : 		{
; 303  : #ifdef AUI_WARNING_FIXES
; 304  : 			for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 305  : #else
; 306  : 			for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN12@GetGreatWo@5
$LL10@GetGreatWo@5:

; 307  : #endif
; 308  : 			{
; 309  : 				CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 310  : 				BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 311  : 				if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN9@GetGreatWo@5

; 312  : 				{
; 313  : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax

; 314  : 					if (pkBuilding)

	test	ebx, ebx
	je	SHORT $LN34@GetGreatWo@5

; 315  : 					{
; 316  : 						if (pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	esi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN34@GetGreatWo@5

; 317  : 						{
; 318  : 							int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, ebx
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ebx, eax

; 319  : 							for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN34@GetGreatWo@5
$LL4@GetGreatWo@5:

; 320  : 							{
; 321  : 								int iGreatWorkIndex = pCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	push	esi
	push	edi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 322  : 								if (iGreatWorkIndex == iIndex)

	cmp	eax, DWORD PTR _iIndex$[esp+24]
	je	SHORT $LN29@GetGreatWo@5
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL4@GetGreatWo@5
$LN34@GetGreatWo@5:

; 319  : 							for (int iI = 0; iI < iNumSlots; iI++)

	mov	ebx, DWORD PTR tv240[esp+28]
$LN9@GetGreatWo@5:

; 302  : 		{
; 303  : #ifdef AUI_WARNING_FIXES
; 304  : 			for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 305  : #else
; 306  : 			for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL10@GetGreatWo@5
$LN12@GetGreatWo@5:

; 296  : 	{
; 297  : 		PlayerTypes ePlayer = (PlayerTypes)uiPlayer;
; 298  : 
; 299  : 		int iCityLoop;
; 300  : 		CvCity* pCity = NULL;
; 301  : 		for (pCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pCity != NULL; pCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop$223186[esp+32]
	add	ecx, ebx
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL13@GetGreatWo@5
$LN15@GetGreatWo@5:

; 288  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 289  : 	
; 290  : 	// for each player
; 291  : 	//   for each building
; 292  : 	//     for each slot
; 293  : 	//       check to see if it holds this work
; 294  : 
; 295  : 	for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	inc	DWORD PTR _uiPlayer$223180[esp+28]
	add	ebx, 63236				; 0000f704H
	mov	DWORD PTR tv240[esp+28], ebx
	cmp	ebx, 1391192				; 00153a58H
	jb	$LL16@GetGreatWo@5
	pop	edi
	pop	esi
	pop	ebp

; 325  : 								}
; 326  : 							}
; 327  : 						}
; 328  : 					}
; 329  : 				}
; 330  : 			}
; 331  : 		}
; 332  : 	}
; 333  : 
; 334  : 	return NO_PLAYER;

	or	eax, -1
	pop	ebx

; 335  : }

	add	esp, 12					; 0000000cH
	ret	4
$LN29@GetGreatWo@5:

; 323  : 								{
; 324  : 									return ePlayer;

	mov	eax, DWORD PTR _uiPlayer$223180[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 335  : }

	add	esp, 12					; 0000000cH
	ret	4
?GetGreatWorkController@CvGameCulture@@QBE?AW4PlayerTypes@@H@Z ENDP ; CvGameCulture::GetGreatWorkController
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvGameCulture@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvGameCulture@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T234425 = 8						; size = 1
$T234424 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvGameCulture@@@Z PROC	; operator<<, COMDAT

; 679  : {

	push	ecx
	push	ebx

; 680  : 	uint uiVersion = 2;
; 681  : 	saveTo << uiVersion;

	mov	ebx, DWORD PTR _saveTo$[esp+4]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _uiVersion$[esp+20], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 682  : 
; 683  : 	GreatWorkList::const_iterator it;
; 684  : 	saveTo << readFrom.m_CurrentGreatWorks.size();

	mov	edi, DWORD PTR _readFrom$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR $T234424[esp+12]
	mov	DWORD PTR $T234424[esp+12], ecx
	push	edx
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 685  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 686  : 	for (it = readFrom.m_CurrentGreatWorks.begin(); it != readFrom.m_CurrentGreatWorks.end(); ++it)
; 687  : #else
; 688  : 	for(it = readFrom.m_CurrentGreatWorks.begin(); it != readFrom.m_CurrentGreatWorks.end(); it++)

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, esi
	cmp	esi, eax
	je	SHORT $LN1@operator@2
$LL3@operator@2:

; 689  : #endif
; 690  : 	{
; 691  : 		saveTo << *it;

	push	esi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABVCvGreatWork@@@Z ; operator<<
	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi]
	add	esi, 48					; 00000030H
	add	esp, 8
	cmp	esi, ecx
	jne	SHORT $LL3@operator@2
$LN1@operator@2:

; 692  : 	}
; 693  : 
; 694  : 	saveTo << readFrom.GetReportedSomeoneInfluential();

	mov	dl, BYTE PTR [edi+1072]
	lea	eax, DWORD PTR $T234425[esp+12]
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR $T234425[esp+16], dl
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 695  : 
; 696  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 697  : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvGameCulture@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?GetNumGreatWorks@CvPlayerCulture@@QBEHXZ	; CvPlayerCulture::GetNumGreatWorks
EXTRN	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ:PROC ; CvCity::GetCityCulture
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorks@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetNumGreatWorks@CvPlayerCulture@@QBEHXZ PROC		; CvPlayerCulture::GetNumGreatWorks, COMDAT
; _this$ = ecx

; 872  : {

	push	ecx
	push	esi
	push	edi

; 873  : 	CvCity* pLoopCity = NULL;
; 874  : 	int iLoop = 0;
; 875  : #ifdef AUI_WARNING_FIXES
; 876  : 	uint iRtnValue = 0;
; 877  : #else
; 878  : 	int iRtnValue = 0;

	xor	edi, edi
	mov	esi, ecx

; 879  : #endif
; 880  : 
; 881  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	mov	DWORD PTR _iLoop$[esp+20], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN10@GetNumGrea
$LL3@GetNumGrea:

; 882  : 	{
; 883  : 		iRtnValue += pLoopCity->GetCityCulture()->GetNumGreatWorks();

	mov	ecx, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, DWORD PTR [eax]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetNumGrea
$LN10@GetNumGrea:

; 884  : 	}
; 885  : 
; 886  : 	return iRtnValue;

	mov	eax, edi
	pop	edi
	pop	esi

; 887  : }

	pop	ecx
	ret	0
?GetNumGreatWorks@CvPlayerCulture@@QBEHXZ ENDP		; CvPlayerCulture::GetNumGreatWorks
_TEXT	ENDS
PUBLIC	?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHXZ	; CvPlayerCulture::GetNumGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetNumGreatWorkSlots, COMDAT
; _this$ = ecx

; 895  : {

	push	ecx
	push	ebx
	push	ebp

; 896  : 	CvCity* pLoopCity = NULL;
; 897  : 	int iLoop = 0;

	xor	ebp, ebp
	mov	ebx, ecx

; 898  : #ifdef AUI_WARNING_FIXES
; 899  : 	uint iRtnValue = 0;
; 900  : #else
; 901  : 	int iRtnValue = 0;
; 902  : #endif
; 903  : 
; 904  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx+292]
	push	ebp
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	mov	DWORD PTR _iLoop$[esp+20], ebp
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	cmp	eax, ebp
	je	SHORT $LN12@GetNumGrea@2
	push	esi
	push	edi
$LL3@GetNumGrea@2:

; 905  : 	{
; 906  : 		iRtnValue += pLoopCity->GetCityCulture()->GetNumGreatWorkSlots();

	mov	ecx, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	esi, eax
	mov	ecx, DWORD PTR [esi]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+24]
	add	eax, edi
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	add	ebp, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetNumGrea@2
	pop	edi
	pop	esi
$LN12@GetNumGrea@2:

; 907  : 	}
; 908  : 
; 909  : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 910  : }

	pop	ecx
	ret	0
?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetNumGreatWorkSlots
_TEXT	ENDS
PUBLIC	?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumGreatWorkSlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_eSlotType$ = 8						; size = 4
?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvPlayerCulture::GetNumGreatWorkSlots, COMDAT
; _this$ = ecx

; 918  : {

	push	ecx
	push	esi
	push	edi

; 919  : 	CvCity* pLoopCity = NULL;
; 920  : 	int iLoop = 0;
; 921  : #ifdef AUI_WARNING_FIXES
; 922  : 	uint iRtnValue = 0;
; 923  : #else
; 924  : 	int iRtnValue = 0;

	xor	edi, edi
	mov	esi, ecx

; 925  : #endif
; 926  : 
; 927  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	mov	DWORD PTR _iLoop$[esp+20], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN10@GetNumGrea@3
	push	ebx
	mov	ebx, DWORD PTR _eSlotType$[esp+12]
	npad	7
$LL3@GetNumGrea@3:

; 928  : 	{
; 929  : 		iRtnValue += pLoopCity->GetCityCulture()->GetNumAvailableGreatWorkSlots(eSlotType);

	mov	ecx, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, DWORD PTR [eax]
	push	ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetNumGrea@3
	pop	ebx
$LN10@GetNumGrea@3:

; 930  : 	}
; 931  : 
; 932  : 	return iRtnValue;

	mov	eax, edi
	pop	edi
	pop	esi

; 933  : }

	pop	ecx
	ret	4
?GetNumGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvPlayerCulture::GetNumGreatWorkSlots
_TEXT	ENDS
EXTRN	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z:PROC ; CvBuildingEntry::GetThemingBonusInfo
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?SortThemingBonus@@YA_NABVCvGreatWorkBuildingInMyEmpire@@0@Z
_TEXT	SEGMENT
_kEntry1$ = 8						; size = 4
_kEntry2$ = 12						; size = 4
?SortThemingBonus@@YA_NABVCvGreatWorkBuildingInMyEmpire@@0@Z PROC ; SortThemingBonus, COMDAT

; 1132 : 	CvBuildingEntry *pEntry1 = GC.GetGameBuildings()->GetEntry(kEntry1.m_eBuilding);

	mov	eax, DWORD PTR _kEntry1$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	push	edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 1133 : 	CvBuildingEntry *pEntry2 = GC.GetGameBuildings()->GetEntry(kEntry2.m_eBuilding);

	mov	edx, DWORD PTR _kEntry2$[esp+4]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	edi, eax

; 1134 : 
; 1135 : 	if (pEntry1 && pEntry2)

	test	esi, esi
	je	SHORT $LN1@SortThemin
	test	edi, edi
	je	SHORT $LN1@SortThemin

; 1136 : 	{
; 1137 : 		CvThemingBonusInfo *pBonus1 = pEntry1->GetThemingBonusInfo(0);

	push	0
	mov	ecx, esi
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo

; 1138 : 		CvThemingBonusInfo *pBonus2 = pEntry2->GetThemingBonusInfo(0);

	push	0
	mov	ecx, edi
	mov	esi, eax
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo

; 1139 : 
; 1140 : 		if (pBonus1 && pBonus2)

	test	esi, esi
	je	SHORT $LN1@SortThemin
	test	eax, eax
	je	SHORT $LN3@SortThemin

; 1141 : 		{
; 1142 : 			return (pBonus1->GetAIPriority() > pBonus2->GetAIPriority());

	mov	ecx, DWORD PTR [esi+44]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+44]
	pop	edi
	setg	dl
	mov	al, dl
	pop	esi

; 1151 : }

	ret	0
$LN3@SortThemin:
	pop	edi

; 1143 : 		}
; 1144 : 		else if (pBonus1)
; 1145 : 		{
; 1146 : 			return true;

	mov	al, 1
	pop	esi

; 1151 : }

	ret	0
$LN1@SortThemin:
	pop	edi

; 1147 : 		}
; 1148 : 	}
; 1149 : 
; 1150 : 	return false;

	xor	al, al
	pop	esi

; 1151 : }

	ret	0
?SortThemingBonus@@YA_NABVCvGreatWorkBuildingInMyEmpire@@0@Z ENDP ; SortThemingBonus
_TEXT	ENDS
PUBLIC	?GetNextDigCompletePlot@CvPlayerCulture@@QBEPAVCvPlot@@XZ ; CvPlayerCulture::GetNextDigCompletePlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextDigCompletePlot@CvPlayerCulture@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetNextDigCompletePlot@CvPlayerCulture@@QBEPAVCvPlot@@XZ PROC ; CvPlayerCulture::GetNextDigCompletePlot, COMDAT
; _this$ = ecx

; 1997 : 	CvPlot *pRtnValue = NULL;
; 1998 : 
; 1999 : 	if (m_aDigCompletePlots.size() > 0)

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, edx
	sar	ecx, 2
	xor	eax, eax
	test	ecx, ecx
	jbe	SHORT $LN1@GetNextDig

; 2000 : 	{
; 2001 : 		pRtnValue = m_aDigCompletePlots[0];
; 2002 : 	}
; 2003 : 
; 2004 : 	return pRtnValue;

	mov	eax, DWORD PTR [edx]
$LN1@GetNextDig:

; 2005 : }

	ret	0
?GetNextDigCompletePlot@CvPlayerCulture@@QBEPAVCvPlot@@XZ ENDP ; CvPlayerCulture::GetNextDigCompletePlot
_TEXT	ENDS
PUBLIC	?GetWrittenArtifactCulture@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetWrittenArtifactCulture
EXTRN	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getCulturePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?GetCultureYieldFromPreviousTurns@CvPlayer@@QAEHHH@Z:PROC ; CvPlayer::GetCultureYieldFromPreviousTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetWrittenArtifactCulture@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetWrittenArtifactCulture@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetWrittenArtifactCulture, COMDAT
; _this$ = ecx

; 2059 : {

	push	esi
	mov	esi, ecx

; 2060 : 	// Culture boost based on 8 previous turns; same as GREAT_WRITER; move to XML?
; 2061 : 	int iValue = m_pPlayer->GetCultureYieldFromPreviousTurns(GC.getGame().getGameTurn(), 8 /*iPreviousTurnsToCount */);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	8
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+292]
	push	eax
	call	?GetCultureYieldFromPreviousTurns@CvPlayer@@QAEHHH@Z ; CvPlayer::GetCultureYieldFromPreviousTurns

; 2062 : 
; 2063 : 	// Modify based on game speed
; 2064 : 	iValue *= GC.getGame().getGameSpeedInfo().getCulturePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	mov	ecx, eax
	imul	ecx, esi

; 2065 : 	iValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 2066 : 
; 2067 : 	return iValue;
; 2068 : }

	ret	0
?GetWrittenArtifactCulture@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetWrittenArtifactCulture
_TEXT	ENDS
PUBLIC	?GetInfluenceTrend@CvPlayerCulture@@QBE?AW4InfluenceLevelTrend@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceTrend
EXTRN	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetJONSCultureEverGenerated
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceTrend@CvPlayerCulture@@QBE?AW4InfluenceLevelTrend@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?GetInfluenceTrend@CvPlayerCulture@@QBE?AW4InfluenceLevelTrend@@W4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceTrend, COMDAT
; _this$ = ecx

; 2735 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2736 : 	InfluenceLevelTrend eRtnValue = INFLUENCE_TREND_STATIC;
; 2737 : 
; 2738 : 	CvPlayer &kOtherPlayer = GET_PLAYER(ePlayer);

	mov	edi, DWORD PTR _ePlayer$[esp+16]
	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _this$[esp+20], ecx

; 2739 : 
; 2740 : 	// PctTurn1 = InfluenceT1 / LifetimeCultureT1
; 2741 : 	// PctTurn2 = InfluenceT2 / LifetimeCultureT2
; 2742 : 	
; 2743 : 	// So if looking at is PctT2 > PctT1, can see if  (InfluenceT2 * LifetimeCultureT1) > (InfluenceT1 * LifetimeCultureT2)
; 2744 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2745 : 	int iOtherPlayerLastTurnLifetimeCulture = kOtherPlayer.GetCulture()->GetLastTurnLifetimeCulture();
; 2746 : 	int iOtherPlayerThisTurnLifetimeCulture = kOtherPlayer.GetJONSCultureEverGenerated();
; 2747 : #ifdef AUI_GAME_BETTER_HYBRID_MODE
; 2748 : 	if (kOtherPlayer.getTurnOrder() > m_pPlayer->getTurnOrder())
; 2749 : #else
; 2750 : 	if (ePlayer > m_pPlayer->GetID())
; 2751 : #endif
; 2752 : 	{
; 2753 : 		iOtherPlayerLastTurnLifetimeCulture = iOtherPlayerThisTurnLifetimeCulture;
; 2754 : 		iOtherPlayerThisTurnLifetimeCulture += m_pPlayer->GetTotalJONSCulturePerTurn();
; 2755 : 	}
; 2756 : 	int iLHS = GetInfluenceOn(ePlayer) * iOtherPlayerLastTurnLifetimeCulture;
; 2757 : 	int iRHS = GetLastTurnInfluenceOn(ePlayer) * iOtherPlayerThisTurnLifetimeCulture;
; 2758 : #else
; 2759 : 	int iLHS = GetInfluenceOn(ePlayer) * kOtherPlayer.GetCulture()->GetLastTurnLifetimeCulture();

	test	edi, edi
	jl	SHORT $LN9@GetInfluen@2
	cmp	edi, 22					; 00000016H
	jge	SHORT $LN9@GetInfluen@2
	mov	ebx, DWORD PTR [ecx+edi*4+20]
	jmp	SHORT $LN11@GetInfluen@2
$LN9@GetInfluen@2:
	xor	ebx, ebx
$LN11@GetInfluen@2:
	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ebp, DWORD PTR [eax+16]
	imul	ebp, ebx

; 2760 : 	int iRHS = GetLastTurnInfluenceOn(ePlayer) * kOtherPlayer.GetJONSCultureEverGenerated();

	test	edi, edi
	jl	SHORT $LN15@GetInfluen@2
	cmp	edi, 22					; 00000016H
	jge	SHORT $LN15@GetInfluen@2
	mov	eax, DWORD PTR _this$[esp+20]
	mov	edi, DWORD PTR [eax+edi*4+108]
	jmp	SHORT $LN17@GetInfluen@2
$LN15@GetInfluen@2:
	xor	edi, edi
$LN17@GetInfluen@2:
	mov	ecx, esi
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	mov	ebx, eax

; 2761 : #endif
; 2762 : 
; 2763 : 	if (kOtherPlayer.GetCulture()->GetLastTurnLifetimeCulture() > 0 && kOtherPlayer.GetJONSCultureEverGenerated() > 0)

	mov	ecx, esi
	imul	ebx, edi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	cmp	DWORD PTR [eax+16], 0
	jle	SHORT $LN23@GetInfluen@2
	mov	ecx, esi
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	test	eax, eax
	jle	SHORT $LN23@GetInfluen@2

; 2764 : 	{
; 2765 : 		if (iLHS > iRHS)

	cmp	ebp, ebx
	jle	SHORT $LN24@GetInfluen@2
	pop	edi
	pop	esi
	pop	ebp

; 2766 : 		{
; 2767 : 			eRtnValue = INFLUENCE_TREND_RISING;

	mov	eax, 1
	pop	ebx

; 2776 : }

	pop	ecx
	ret	4
$LN24@GetInfluen@2:

; 2768 : 		}
; 2769 : 		else if (iLHS < iRHS)

	jge	SHORT $LN23@GetInfluen@2
	pop	edi
	pop	esi
	pop	ebp

; 2770 : 		{
; 2771 : 			eRtnValue = INFLUENCE_TREND_FALLING;

	or	eax, -1
	pop	ebx

; 2776 : }

	pop	ecx
	ret	4
$LN23@GetInfluen@2:
	pop	edi
	pop	esi
	pop	ebp

; 2772 : 		}
; 2773 : 	}
; 2774 : 		
; 2775 : 	return eRtnValue;

	xor	eax, eax
	pop	ebx

; 2776 : }

	pop	ecx
	ret	4
?GetInfluenceTrend@CvPlayerCulture@@QBE?AW4InfluenceLevelTrend@@W4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceTrend
_TEXT	ENDS
PUBLIC	?GetTourismModifierSharedReligion@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetTourismModifierSharedReligion
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismModifierSharedReligion@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetTourismModifierSharedReligion@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetTourismModifierSharedReligion, COMDAT
; _this$ = ecx

; 3342 : 	return GC.getTOURISM_MODIFIER_SHARED_RELIGION() + m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_SHARED_RELIGION_TOURISM_MODIFIER);

	mov	ecx, DWORD PTR [ecx+292]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	55					; 00000037H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, esi
	pop	esi

; 3343 : }

	ret	0
?GetTourismModifierSharedReligion@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetTourismModifierSharedReligion
_TEXT	ENDS
PUBLIC	?GetTourismModifierTradeRoute@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetTourismModifierTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismModifierTradeRoute@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetTourismModifierTradeRoute@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetTourismModifierTradeRoute, COMDAT
; _this$ = ecx

; 3348 : 	return GC.getTOURISM_MODIFIER_SHARED_RELIGION() + m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TRADE_ROUTE_TOURISM_MODIFIER);

	mov	ecx, DWORD PTR [ecx+292]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	56					; 00000038H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, esi
	pop	esi

; 3349 : }

	ret	0
?GetTourismModifierTradeRoute@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetTourismModifierTradeRoute
_TEXT	ENDS
PUBLIC	?GetTourismModifierOpenBorders@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetTourismModifierOpenBorders
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismModifierOpenBorders@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetTourismModifierOpenBorders@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetTourismModifierOpenBorders, COMDAT
; _this$ = ecx

; 3354 : 	return GC.getTOURISM_MODIFIER_SHARED_RELIGION() + m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_OPEN_BORDERS_TOURISM_MODIFIER);

	mov	ecx, DWORD PTR [ecx+292]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	57					; 00000039H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, esi
	pop	esi

; 3355 : }

	ret	0
?GetTourismModifierOpenBorders@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetTourismModifierOpenBorders
_TEXT	ENDS
PUBLIC	?GetPublicOpinionTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ ; CvPlayerCulture::GetPublicOpinionTooltip
; Function compile flags: /Ogtpy
;	COMDAT ?GetPublicOpinionTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T234579 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPublicOpinionTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ PROC ; CvPlayerCulture::GetPublicOpinionTooltip, COMDAT
; _this$ = ecx

; 3371 : {

	push	ecx
	push	esi

; 3372 : 	return m_strOpinionTooltip;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T234579[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi

; 3373 : }

	pop	ecx
	ret	4
?GetPublicOpinionTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ ENDP ; CvPlayerCulture::GetPublicOpinionTooltip
_TEXT	ENDS
PUBLIC	?GetPublicOpinionUnhappinessTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ ; CvPlayerCulture::GetPublicOpinionUnhappinessTooltip
; Function compile flags: /Ogtpy
;	COMDAT ?GetPublicOpinionUnhappinessTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T234589 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPublicOpinionUnhappinessTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ PROC ; CvPlayerCulture::GetPublicOpinionUnhappinessTooltip, COMDAT
; _this$ = ecx

; 3383 : {

	push	ecx
	push	esi

; 3384 : 	return m_strOpinionUnhappinessTooltip;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 248				; 000000f8H
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T234589[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi

; 3385 : }

	pop	ecx
	ret	4
?GetPublicOpinionUnhappinessTooltip@CvPlayerCulture@@QBE?AVCvString@@XZ ENDP ; CvPlayerCulture::GetPublicOpinionUnhappinessTooltip
_TEXT	ENDS
PUBLIC	?ComputePublicOpinionUnhappiness@CvPlayerCulture@@AAEHHAAH0H@Z ; CvPlayerCulture::ComputePublicOpinionUnhappiness
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?getTotalPopulation@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getTotalPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?ComputePublicOpinionUnhappiness@CvPlayerCulture@@AAEHHAAH0H@Z
_TEXT	SEGMENT
_iDissatisfaction$ = 8					; size = 4
$T234598 = 12						; size = 4
_iPerCityUnhappy$ = 12					; size = 4
$T234599 = 16						; size = 4
_iUnhappyPerXPop$ = 16					; size = 4
_iUnhappinessModifier$ = 20				; size = 4
?ComputePublicOpinionUnhappiness@CvPlayerCulture@@AAEHHAAH0H@Z PROC ; CvPlayerCulture::ComputePublicOpinionUnhappiness, COMDAT
; _this$ = ecx

; 3949 : 	if (iDissatisfaction < 3)

	mov	eax, DWORD PTR _iDissatisfaction$[esp-4]
	cmp	eax, 3
	push	ebx
	push	esi

; 3950 : 	{
; 3951 : 		iPerCityUnhappy = 1;

	mov	esi, DWORD PTR _iPerCityUnhappy$[esp+4]
	push	edi

; 3952 : 		iUnhappyPerXPop = 10;

	mov	edi, DWORD PTR _iUnhappyPerXPop$[esp+8]
	mov	ebx, ecx
	jge	SHORT $LN5@ComputePub
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [edi], 10			; 0000000aH
	jmp	SHORT $LN2@ComputePub
$LN5@ComputePub:

; 3953 : 	}
; 3954 : 	else if (iDissatisfaction < 5)

	cmp	eax, 5
	jge	SHORT $LN3@ComputePub

; 3955 : 	{
; 3956 : 		iPerCityUnhappy = 2;

	mov	DWORD PTR [esi], 2

; 3957 : 		iUnhappyPerXPop = 5;

	mov	DWORD PTR [edi], 5

; 3958 : 	}
; 3959 : 	else

	jmp	SHORT $LN2@ComputePub
$LN3@ComputePub:

; 3960 : 	{
; 3961 : 		iPerCityUnhappy = 4;

	mov	DWORD PTR [esi], 4

; 3962 : 		iUnhappyPerXPop = 3;

	mov	DWORD PTR [edi], 3
$LN2@ComputePub:

; 3963 : 	}
; 3964 : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 3965 : 	int totalUnhappiness = max(m_pPlayer->getNumCities() * iPerCityUnhappy, m_pPlayer->getTotalPopulation() / iUnhappyPerXPop);

	mov	ecx, DWORD PTR [ebx+292]
	call	?getTotalPopulation@CvPlayer@@QBEHXZ	; CvPlayer::getTotalPopulation
	cdq
	idiv	DWORD PTR [edi]
	mov	ecx, DWORD PTR [ebx+292]
	mov	edi, eax
	mov	DWORD PTR $T234598[esp+8], edi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	imul	eax, DWORD PTR [esi]
	cmp	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR $T234599[esp], eax
	pop	ebx
	lea	eax, DWORD PTR $T234598[esp-4]
	jl	SHORT $LN11@ComputePub
	lea	eax, DWORD PTR $T234599[esp-4]
$LN11@ComputePub:

; 3966 : 	if (iUnhappinessModifier != 0)

	mov	ecx, DWORD PTR _iUnhappinessModifier$[esp-4]
	mov	eax, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@ComputePub

; 3967 : 	{
; 3968 : 		totalUnhappiness *= (100 + iUnhappinessModifier);

	add	ecx, 100				; 00000064H
	imul	ecx, eax

; 3969 : 		totalUnhappiness /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN1@ComputePub:

; 3970 : 	}
; 3971 : 	return totalUnhappiness;
; 3972 : #else
; 3973 : 	return max(m_pPlayer->getNumCities() * iPerCityUnhappy, m_pPlayer->getTotalPopulation() / iUnhappyPerXPop);
; 3974 : #endif
; 3975 : }

	ret	16					; 00000010H
?ComputePublicOpinionUnhappiness@CvPlayerCulture@@AAEHHAAH0H@Z ENDP ; CvPlayerCulture::ComputePublicOpinionUnhappiness
_TEXT	ENDS
PUBLIC	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z$1
__ehfuncinfo$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_strValue$ = 44						; size = 28
?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z PROC ; CvPlayerCulture::AppendToLog, COMDAT
; _this$ = ecx

; 4096 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 4097 : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+12]
	lea	eax, DWORD PTR _strHeaderValue$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4098 : 	strHeader += ",";

	push	OFFSET $SG226775
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4099 : 	strLog += strValue;

	mov	esi, DWORD PTR _strLog$[esp+12]
	lea	ecx, DWORD PTR _strValue$[esp+12]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4100 : 	strLog += ",";

	push	OFFSET $SG226776
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4101 : }

	lea	ecx, DWORD PTR _strHeaderValue$[esp+12]
	mov	BYTE PTR __$EHRec$[esp+24], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strValue$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z$0:
	lea	ecx, DWORD PTR _strValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z$1:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ENDP ; CvPlayerCulture::AppendToLog
PUBLIC	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z$1
__ehfuncinfo$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z
_TEXT	SEGMENT
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_iValue$ = 44						; size = 4
?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z PROC ; CvPlayerCulture::AppendToLog, COMDAT
; _this$ = ecx

; 4104 : {

	push	-1
	push	__ehhandler$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 4105 : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+40]
	lea	eax, DWORD PTR _strHeaderValue$[esp+40]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4106 : 	strHeader += ",";

	push	OFFSET $SG226784
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4107 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4108 : 	str.Format("%d,", iValue);

	mov	ecx, DWORD PTR _iValue$[esp+40]
	push	ecx
	lea	edx, DWORD PTR _str$[esp+48]
	push	OFFSET $SG226786
	push	edx
	mov	BYTE PTR __$EHRec$[esp+64], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4109 : 	strLog += str;

	mov	ecx, DWORD PTR _strLog$[esp+52]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _str$[esp+44]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4110 : }

	lea	ecx, DWORD PTR _str$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeaderValue$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ENDP ; CvPlayerCulture::AppendToLog
PUBLIC	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z ; CvPlayerCulture::AppendToLog
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z$1
__ehfuncinfo$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z
_TEXT	SEGMENT
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_fValue$ = 44						; size = 4
?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z PROC ; CvPlayerCulture::AppendToLog, COMDAT
; _this$ = ecx

; 4113 : {

	push	-1
	push	__ehhandler$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 4114 : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+40]
	lea	eax, DWORD PTR _strHeaderValue$[esp+40]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4115 : 	strHeader += ",";

	push	OFFSET $SG226794
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4116 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4117 : 	str.Format("%.2f,", fValue);

	fld	DWORD PTR _fValue$[esp+40]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR _str$[esp+52]
	push	OFFSET $SG226796
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+68], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4118 : 	strLog += str;

	mov	ecx, DWORD PTR _strLog$[esp+56]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _str$[esp+44]
	push	edx
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4119 : }

	lea	ecx, DWORD PTR _str$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeaderValue$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@M@Z ENDP ; CvPlayerCulture::AppendToLog
PUBLIC	?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z ; CvPlayerCulture::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
$T234682 = -72						; size = 4
$T234680 = -68						; size = 28
$T234679 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z PROC ; CvPlayerCulture::GetLogFileName, COMDAT
; _this$ = ecx

; 4170 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T234682[esp+80], ebx

; 4171 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4181 : 	}
; 4182 : 
; 4183 : 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T234682[esp+80], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T234679[esp+84]
	push	OFFSET $SG226854
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG226853
	push	eax
	lea	edx, DWORD PTR $T234680[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234680[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234679[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	pop	ebx

; 4184 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN2@GetLogFile:

; 4172 : 
; 4173 : 	// Open the log file
; 4174 : 	if(GC.getPlayerAndCityAILogSplit())
; 4175 : 	{
; 4176 : 		strLogName = "CultureAILog_" + playerName + ".csv";
; 4177 : 	}
; 4178 : 	else
; 4179 : 	{
; 4180 : 		strLogName = "CultureAILog.csv";

	push	OFFSET $SG226856
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 4184 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z$0:
	mov	eax, DWORD PTR $T234682[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T234682[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T234679[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T234680[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z ENDP ; CvPlayerCulture::GetLogFileName
PUBLIC	??0CvGreatWork@@QAE@ABV0@@Z			; CvGreatWork::CvGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ??0CvGreatWork@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvGreatWork@@QAE@ABV0@@Z PROC			; CvGreatWork::CvGreatWork, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
	mov	edx, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], edx
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax
	mov	ecx, DWORD PTR [edi+44]
	pop	edi
	mov	DWORD PTR [esi+44], ecx
	mov	eax, esi
	pop	esi
	ret	4
??0CvGreatWork@@QAE@ABV0@@Z ENDP			; CvGreatWork::CvGreatWork
_TEXT	ENDS
PUBLIC	?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z ; CvCityCulture::LogGreatWorks
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$3
__ehfuncinfo$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z
_TEXT	SEGMENT
_strMsg$ = -96						; size = 28
_strTemp$227610 = -68					; size = 28
$T234718 = -68						; size = 28
$T234717 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pLog$ = 8						; size = 4
?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z PROC	; CvCityCulture::LogGreatWorks, COMDAT
; _this$ = ecx

; 5482 : {

	push	-1
	push	__ehhandler$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 5483 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5484 : 	strMsg = m_pCity->getName() + ", ";

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR $T234717[esp+104]
	xor	ebp, ebp
	push	eax
	mov	DWORD PTR __$EHRec$[esp+116], ebp
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	OFFSET $SG227597
	push	eax
	lea	ecx, DWORD PTR $T234718[esp+112]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+112], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+108]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234718[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234717[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5485 : #ifdef AUI_WARNING_FIXES
; 5486 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 5487 : #else
; 5488 : 	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN5@LogGreatWo
	push	esi
	push	edi
$LL37@LogGreatWo:

; 5489 : #endif
; 5490 : 	{
; 5491 : 		BuildingClassTypes eBldgClass = (BuildingClassTypes)iI;
; 5492 : 		
; 5493 : 		for (int jJ = 0; jJ < 4; jJ++)

	xor	edi, edi
	npad	7
$LL4@LogGreatWo:

; 5494 : 		{
; 5495 : 			int iIndex = m_pCity->GetCityBuildings()->GetBuildingGreatWork(eBldgClass, jJ);

	mov	ecx, DWORD PTR [ebx]
	push	edi
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	mov	esi, eax

; 5496 : 			if (iIndex != -1)

	cmp	esi, -1
	je	SHORT $LN3@LogGreatWo

; 5497 : 			{
; 5498 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227610[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5499 : 				strTemp.Format("%d, ", iIndex);

	push	esi
	lea	edx, DWORD PTR _strTemp$227610[esp+116]
	push	OFFSET $SG227611
	push	edx
	mov	BYTE PTR __$EHRec$[esp+132], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5500 : 				strMsg += strTemp;

	lea	eax, DWORD PTR _strTemp$227610[esp+112]
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+116]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5501 : 			}

	lea	ecx, DWORD PTR _strTemp$227610[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@LogGreatWo:
	inc	edi
	cmp	edi, 4
	jl	SHORT $LL4@LogGreatWo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	SHORT $LL37@LogGreatWo
	pop	edi
	pop	esi
$LN5@LogGreatWo:

; 5502 : 		}
; 5503 : 	}
; 5504 : 	pLog->Msg(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+104]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$[esp+100]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	add	esp, 8

; 5505 : }

	lea	ecx, DWORD PTR _strMsg$[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$1:
	lea	ecx, DWORD PTR $T234717[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$2:
	lea	ecx, DWORD PTR $T234718[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z$3:
	lea	ecx, DWORD PTR _strTemp$227610[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z ENDP	; CvCityCulture::LogGreatWorks
PUBLIC	?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z ; CultureHelpers::GetArtifact
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?BindNULL@Results@Database@@QAE_NH@Z:PROC
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	?getARTIFACT_WRITING@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ:PROC ; CvTypes::getARTIFACT_WRITING
EXTRN	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ:PROC ; CvPlot::GetArchaeologicalRecord
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z$1
__ehfuncinfo$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_eGreatWork$ = -164					; size = 4
_archData$ = -160					; size = 20
_kQuery$ = -140						; size = 64
_kEraItemsExistQ$227653 = -76				; size = 64
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z PROC ; CultureHelpers::GetArtifact, COMDAT

; 5555 : {

	mov	eax, DWORD PTR fs:0

; 5556 : 	CvArchaeologyData archData = pPlot->GetArchaeologicalRecord();

	mov	ecx, DWORD PTR _pPlot$[esp-4]
	push	-1
	push	__ehhandler$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 152				; 00000098H
	lea	eax, DWORD PTR _archData$[esp+164]
	push	eax
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord

; 5557 : 
; 5558 : 	// Writing?  If so we already know which one it is
; 5559 : 	if (archData.m_eArtifactType == CvTypes::getARTIFACT_WRITING())

	call	?getARTIFACT_WRITING@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_WRITING
	cmp	DWORD PTR _archData$[esp+164], eax
	jne	SHORT $LN8@GetArtifac

; 5560 : 	{
; 5561 : 		return archData.m_eWork;

	mov	eax, DWORD PTR _archData$[esp+180]

; 5620 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	mov	DWORD PTR fs:0, ecx
	add	esp, 164				; 000000a4H
	ret	0
$LN8@GetArtifac:
	push	ebx
	push	ebp

; 5562 : 	}
; 5563 : 
; 5564 : 	// Otherwise normal retrieval of Great Work
; 5565 : 	GreatWorkType eGreatWork = NO_GREAT_WORK;
; 5566 : 
; 5567 : 	//Developer Note:
; 5568 : 	//This could probably be shrunk down into a single SQL query but for now I'll leave it as 2.
; 5569 : 	//The idea here is that we grab all possible items for a specific era and then pick 1 at random.
; 5570 : 	//If there are no items for that era, we use NULL and grab those items.
; 5571 : 	//Since era-agnostic and era-specific items are mutually exclusive, we must first check for the the 
; 5572 : 	//existence of era-specific items.
; 5573 : 	const char* szSql = "SELECT gw.ID FROM GreatWorks as gw "
; 5574 : 						"left outer join Eras on gw.EraType == Eras.Type "
; 5575 : 						"inner join GreatWorkArtifactClasses on gw.ArtifactClassType == GreatWorkArtifactClasses.Type "
; 5576 : 						"where gw.GreatWorkClassType = 'GREAT_WORK_ARTIFACT' and Eras.ID is ? and GreatWorkArtifactClasses.ID == ? "
; 5577 : 						"order by Random() limit 1;";
; 5578 : 
; 5579 : 	const char* szExistsSQL =	"select 1 from GreatWorks as gw "
; 5580 : 								"inner join Eras on gw.EraType == Eras.Type "
; 5581 : 								"inner join GreatWorkArtifactClasses on gw.ArtifactClassType == GreatWorkArtifactClasses.Type "
; 5582 : 								"where gw.GreatWorkClassType = 'GREAT_WORK_ARTIFACT' and Eras.ID = ? and GreatWorkArtifactClasses.ID == ? Limit 1;";
; 5583 : 
; 5584 : 	Database::Connection* db = GC.GetGameDatabase();
; 5585 : 
; 5586 : 	bool bHasEraSpecificItems = false;
; 5587 : 
; 5588 : 	if(archData.m_eEra != NO_ERA)

	mov	ebp, DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	or	eax, -1
	xor	bl, bl
	push	edi
	mov	edi, DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	mov	DWORD PTR _eGreatWork$[esp+180], eax
	cmp	DWORD PTR _archData$[esp+184], eax
	je	SHORT $LN16@GetArtifac

; 5589 : 	{
; 5590 : 		Database::Results kEraItemsExistQ;

	push	0
	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[esp+184]
	call	edi

; 5591 : 		if(db->Execute(kEraItemsExistQ, szExistsSQL))

	push	-1
	push	OFFSET $SG227649
	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[esp+188]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+200], 0
	call	ebp
	test	al, al
	je	SHORT $LN15@GetArtifac

; 5592 : 		{
; 5593 : 			kEraItemsExistQ.Bind(1, archData.m_eEra);

	mov	edx, DWORD PTR _archData$[esp+184]
	push	edx
	push	1
	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[esp+188]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 5594 : 			kEraItemsExistQ.Bind(2, archData.m_eArtifactType);

	mov	eax, DWORD PTR _archData$[esp+180]
	push	eax
	push	2
	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[esp+188]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 5595 : 
; 5596 : 			if(kEraItemsExistQ.Step())

	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[esp+180]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN15@GetArtifac

; 5597 : 			{
; 5598 : 				bHasEraSpecificItems = true;	

	mov	bl, 1
$LN15@GetArtifac:

; 5599 : 			}
; 5600 : 		}
; 5601 : 	}

	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[esp+180]
	mov	DWORD PTR __$EHRec$[esp+188], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN16@GetArtifac:

; 5602 : 
; 5603 : 	Database::Results kQuery;

	push	0
	lea	ecx, DWORD PTR _kQuery$[esp+184]
	call	edi

; 5604 : 	if(db->Execute(kQuery, szSql))

	push	-1
	push	OFFSET $SG227647
	lea	ecx, DWORD PTR _kQuery$[esp+188]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+200], 1
	call	ebp
	test	al, al
	je	SHORT $LN17@GetArtifac

; 5605 : 	{
; 5606 : 		if(bHasEraSpecificItems == true)
; 5607 : 			kQuery.Bind(1, archData.m_eEra);

	lea	ecx, DWORD PTR _kQuery$[esp+180]
	cmp	bl, 1
	jne	SHORT $LN3@GetArtifac
	mov	edx, DWORD PTR _archData$[esp+184]
	push	edx
	push	1
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 5608 : 		else

	jmp	SHORT $LN2@GetArtifac
$LN3@GetArtifac:

; 5609 : 			kQuery.BindNULL(1);

	push	1
	call	DWORD PTR __imp_?BindNULL@Results@Database@@QAE_NH@Z
$LN2@GetArtifac:

; 5610 : 
; 5611 : 		kQuery.Bind(2, archData.m_eArtifactType);

	mov	eax, DWORD PTR _archData$[esp+180]
	push	eax
	push	2
	lea	ecx, DWORD PTR _kQuery$[esp+188]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 5612 : 
; 5613 : 		if(kQuery.Step())

	lea	ecx, DWORD PTR _kQuery$[esp+180]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN17@GetArtifac

; 5614 : 		{
; 5615 : 			eGreatWork = static_cast<GreatWorkType>(kQuery.GetInt(0));

	push	0
	lea	ecx, DWORD PTR _kQuery$[esp+184]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	esi, eax
	jmp	SHORT $LN1@GetArtifac
$LN17@GetArtifac:
	mov	esi, DWORD PTR _eGreatWork$[esp+180]
$LN1@GetArtifac:

; 5616 : 		}
; 5617 : 	}
; 5618 : 
; 5619 : 	return eGreatWork;

	lea	ecx, DWORD PTR _kQuery$[esp+180]
	mov	DWORD PTR __$EHRec$[esp+188], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 5620 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+180]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 164				; 000000a4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _kEraItemsExistQ$227653[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _kQuery$[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z ENDP ; CultureHelpers::GetArtifact
PUBLIC	?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkClass
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z$0
__ehfuncinfo$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z
_TEXT	SEGMENT
_kQuery$227669 = -76					; size = 64
__$EHRec$ = -12						; size = 12
_eGreatWork$ = 8					; size = 4
?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z PROC ; CultureHelpers::GetGreatWorkClass, COMDAT

; 5623 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	esi

; 5624 : 	GreatWorkClass eClass = NO_GREAT_WORK_CLASS;
; 5625 : 
; 5626 : 	Database::Connection* db = GC.GetGameDatabase();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	edi
	or	edi, -1

; 5627 : 	if(db != NULL)

	test	esi, esi
	je	SHORT $LN9@GetGreatWo@6

; 5628 : 	{
; 5629 : 		Database::Results kQuery;

	push	0
	lea	ecx, DWORD PTR _kQuery$227669[esp+88]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 5630 : 		const char* szSQL = "SELECT GreatWorkClasses.ID from GreatWorkClasses inner join GreatWorks on GreatWorkClassType = GreatWorkClasses.Type where GreatWorks.ID = ?";
; 5631 : 		if(db->Execute(kQuery, szSQL))

	push	edi
	push	OFFSET $SG227671
	lea	eax, DWORD PTR _kQuery$227669[esp+92]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN1@GetGreatWo@6

; 5632 : 		{
; 5633 : 			kQuery.Bind(1, eGreatWork);

	mov	ecx, DWORD PTR _eGreatWork$[esp+80]
	push	ecx
	push	1
	lea	ecx, DWORD PTR _kQuery$227669[esp+92]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 5634 : 
; 5635 : 			if(kQuery.Step())

	lea	ecx, DWORD PTR _kQuery$227669[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@GetGreatWo@6

; 5636 : 			{
; 5637 : 				eClass = static_cast<GreatWorkClass>(kQuery.GetInt(0));

	push	0
	lea	ecx, DWORD PTR _kQuery$227669[esp+88]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	edi, eax
$LN1@GetGreatWo@6:

; 5638 : 			}
; 5639 : 		}
; 5640 : 	}

	lea	ecx, DWORD PTR _kQuery$227669[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN9@GetGreatWo@6:

; 5641 : 
; 5642 : 	return eClass;
; 5643 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z$0:
	lea	ecx, DWORD PTR _kQuery$227669[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z ENDP ; CultureHelpers::GetGreatWorkClass
PUBLIC	?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkName
EXTRN	__imp_?GetText@Results@Database@@QAEPBDH@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$1
__ehfuncinfo$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
_TEXT	SEGMENT
$T234798 = -80						; size = 4
_kQuery$227682 = -76					; size = 64
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eGreatWork$ = 12					; size = 4
?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z PROC ; CultureHelpers::GetGreatWorkName, COMDAT

; 5646 : {

	push	-1
	push	__ehhandler$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T234798[esp+92], ebx

; 5647 : 	CvString strGreatWorkName;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5663 : 
; 5664 : 	return strGreatWorkName;

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	mov	DWORD PTR $T234798[esp+92], 1
	cmp	esi, ebx
	je	SHORT $LN18@GetGreatWo@7
	push	ebx
	lea	ecx, DWORD PTR _kQuery$227682[esp+96]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	push	-1
	push	OFFSET $SG227684
	lea	eax, DWORD PTR _kQuery$227682[esp+100]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN14@GetGreatWo@7
	mov	ecx, DWORD PTR _eGreatWork$[esp+88]
	push	ecx
	push	1
	lea	ecx, DWORD PTR _kQuery$227682[esp+100]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z
	lea	ecx, DWORD PTR _kQuery$227682[esp+92]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN14@GetGreatWo@7
	push	ebx
	lea	ecx, DWORD PTR _kQuery$227682[esp+96]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	mov	ecx, edi
	cmp	eax, ebx
	je	SHORT $LN15@GetGreatWo@7
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@GetGreatWo@7

; 5648 : 
; 5649 : 	Database::Connection* db = GC.GetGameDatabase();
; 5650 : 	if(db != NULL)
; 5651 : 	{
; 5652 : 		Database::Results kQuery;
; 5653 : 		if(db->Execute(kQuery, "SELECT Description FROM GreatWorks WHERE ID = ?"))
; 5654 : 		{
; 5655 : 			kQuery.Bind(1, eGreatWork);
; 5656 : 
; 5657 : 			if(kQuery.Step())
; 5658 : 			{
; 5659 : 				strGreatWorkName = kQuery.GetText(0);

$LN15@GetGreatWo@7:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@GetGreatWo@7:

; 5660 : 			}
; 5661 : 		}
; 5662 : 	}

	lea	ecx, DWORD PTR _kQuery$227682[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN18@GetGreatWo@7:

; 5665 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$0:
	mov	eax, DWORD PTR $T234798[ebp]
	and	eax, 1
	je	$LN7@GetGreatWo@7
	and	DWORD PTR $T234798[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN7@GetGreatWo@7:
	ret	0
__unwindfunclet$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$1:
	lea	ecx, DWORD PTR _kQuery$227682[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z ENDP ; CultureHelpers::GetGreatWorkName
PUBLIC	?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkAudio
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$1
__ehfuncinfo$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
_TEXT	SEGMENT
$T234825 = -80						; size = 4
_kQuery$227693 = -76					; size = 64
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eGreatWorkType$ = 12					; size = 4
?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z PROC ; CultureHelpers::GetGreatWorkAudio, COMDAT

; 5668 : {

	push	-1
	push	__ehhandler$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T234825[esp+92], ebx

; 5669 : 	CvString strGreatWorkAudio;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5685 : 
; 5686 : 	return strGreatWorkAudio;

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	mov	DWORD PTR $T234825[esp+92], 1
	cmp	esi, ebx
	je	SHORT $LN18@GetGreatWo@8
	push	ebx
	lea	ecx, DWORD PTR _kQuery$227693[esp+96]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	push	-1
	push	OFFSET $SG227695
	lea	eax, DWORD PTR _kQuery$227693[esp+100]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN14@GetGreatWo@8
	mov	ecx, DWORD PTR _eGreatWorkType$[esp+88]
	push	ecx
	push	1
	lea	ecx, DWORD PTR _kQuery$227693[esp+100]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z
	lea	ecx, DWORD PTR _kQuery$227693[esp+92]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN14@GetGreatWo@8
	push	ebx
	lea	ecx, DWORD PTR _kQuery$227693[esp+96]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	mov	ecx, edi
	cmp	eax, ebx
	je	SHORT $LN15@GetGreatWo@8
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@GetGreatWo@8

; 5670 : 
; 5671 : 	Database::Connection* db = GC.GetGameDatabase();
; 5672 : 	if(db != NULL)
; 5673 : 	{
; 5674 : 		Database::Results kQuery;
; 5675 : 		if(db->Execute(kQuery, "SELECT Audio FROM GreatWorks WHERE ID = ?"))
; 5676 : 		{
; 5677 : 			kQuery.Bind(1, eGreatWorkType);
; 5678 : 
; 5679 : 			if(kQuery.Step())
; 5680 : 			{
; 5681 : 				strGreatWorkAudio = kQuery.GetText(0);

$LN15@GetGreatWo@8:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@GetGreatWo@8:

; 5682 : 			}
; 5683 : 		}
; 5684 : 	}

	lea	ecx, DWORD PTR _kQuery$227693[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN18@GetGreatWo@8:

; 5687 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$0:
	mov	eax, DWORD PTR $T234825[ebp]
	and	eax, 1
	je	$LN7@GetGreatWo@8
	and	DWORD PTR $T234825[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN7@GetGreatWo@8:
	ret	0
__unwindfunclet$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z$1:
	lea	ecx, DWORD PTR _kQuery$227693[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkAudio@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z ENDP ; CultureHelpers::GetGreatWorkAudio
PUBLIC	?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkSlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z$0
__ehfuncinfo$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z
_TEXT	SEGMENT
_kResults$227705 = -76					; size = 64
__$EHRec$ = -12						; size = 12
_eType$ = 8						; size = 4
?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z PROC ; CultureHelpers::GetGreatWorkSlot, COMDAT

; 5690 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	esi

; 5691 : 	GreatWorkSlotType eSlot = NO_GREAT_WORK_SLOT;
; 5692 : 	Database::Connection* db = GC.GetGameDatabase();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	edi
	or	edi, -1

; 5693 : 	if(db != NULL)

	test	esi, esi
	je	SHORT $LN9@GetGreatWo@9

; 5694 : 	{
; 5695 : 		const char* szSQL = "SELECT GreatWorkSlots.ID from GreatWorks "
; 5696 : 							"inner join GreatWorkClasses  on GreatWorks.GreatWorkClassType == GreatWorkClasses .Type "
; 5697 : 							"inner join GreatWorkSlots on GreatWorkClasses.SlotType == GreatWorkSlots.Type where GreatWorks .ID = ? LIMIT 1";
; 5698 : 
; 5699 : 		Database::Results kResults;

	push	0
	lea	ecx, DWORD PTR _kResults$227705[esp+88]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 5700 : 		if(db->Execute(kResults, szSQL))

	push	edi
	push	OFFSET $SG227704
	lea	eax, DWORD PTR _kResults$227705[esp+92]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN1@GetGreatWo@9

; 5701 : 		{
; 5702 : 			kResults.Bind(1, eType);

	mov	ecx, DWORD PTR _eType$[esp+80]
	push	ecx
	push	1
	lea	ecx, DWORD PTR _kResults$227705[esp+92]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 5703 : 
; 5704 : 			if(kResults.Step())

	lea	ecx, DWORD PTR _kResults$227705[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@GetGreatWo@9

; 5705 : 			{
; 5706 : 				eSlot = static_cast<GreatWorkSlotType>(kResults.GetInt(0));

	push	0
	lea	ecx, DWORD PTR _kResults$227705[esp+88]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	edi, eax
$LN1@GetGreatWo@9:

; 5707 : 			}
; 5708 : 		}
; 5709 : 	}

	lea	ecx, DWORD PTR _kResults$227705[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN9@GetGreatWo@9:

; 5710 : 
; 5711 : 	return eSlot;
; 5712 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z$0:
	lea	ecx, DWORD PTR _kResults$227705[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z ENDP ; CultureHelpers::GetGreatWorkSlot
PUBLIC	??0?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvGreatWork,22,0,297,0>::FStaticVector<CvGreatWork,22,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvGreatWork,22,0,297,0>::FStaticVector<CvGreatWork,22,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvGreatWork,22,0,297,0>::FStaticVector<CvGreatWork,22,0,297,0>
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkBuildingInMyEmpire@@XZ ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkBuildingInMyEmpire@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkBuildingInMyEmpire@@XZ PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator->, COMDAT
; _this$ = ecx

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEPAVCvGreatWorkBuildingInMyEmpire@@XZ ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator->
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 24					; 00000018H
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 24					; 00000018H
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >::~_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >::~_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >::~_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z ; std::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z PROC ; std::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@1@@Z ENDP ; std::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_val<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z ; std::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z PROC ; std::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE@V?$allocator@W4PlayerTypes@@@1@@Z ENDP ; std::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_val<enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z ; std::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z PROC ; std::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE@V?$allocator@VCvGreatWorkInMyEmpire@@@1@@Z ENDP ; std::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_val<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 12			; 0000000cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@PAVCvGreatWorkInMyEmpire@@@Z ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z ; std::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z PROC ; std::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE@V?$allocator@W4EraTypes@@@1@@Z ENDP ; std::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_val<enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z PROC ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@PAW4EraTypes@@@Z ENDP ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z PROC ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@PAW4PlayerTypes@@@Z ENDP ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??_GCvGreatWork@@QAEPAXI@Z			; CvGreatWork::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvGreatWork@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvGreatWork@@QAEPAXI@Z PROC				; CvGreatWork::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvGreatWork@@QAEPAXI@Z ENDP				; CvGreatWork::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEPAVCvGreatWorkBuildingInMyEmpire@@I@Z ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEPAVCvGreatWorkBuildingInMyEmpire@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEPAVCvGreatWorkBuildingInMyEmpire@@I@Z PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkBuildingInMyEmpire>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEPAVCvGreatWorkBuildingInMyEmpire@@I@Z ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z ; std::allocator<CvPlot *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z PROC ; std::allocator<CvPlot *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z ENDP ; std::allocator<CvPlot *>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4PlayerTypes@@@std@@QAEPAW4PlayerTypes@@I@Z ; std::allocator<enum PlayerTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4PlayerTypes@@@std@@QAEPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4PlayerTypes@@@std@@QAEPAW4PlayerTypes@@I@Z PROC ; std::allocator<enum PlayerTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z ; std::_Allocate<enum PlayerTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4PlayerTypes@@@std@@QAEPAW4PlayerTypes@@I@Z ENDP ; std::allocator<enum PlayerTypes>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEPAVCvGreatWorkInMyEmpire@@I@Z ; std::allocator<CvGreatWorkInMyEmpire>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEPAVCvGreatWorkInMyEmpire@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEPAVCvGreatWorkInMyEmpire@@I@Z PROC ; std::allocator<CvGreatWorkInMyEmpire>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkInMyEmpire>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEPAVCvGreatWorkInMyEmpire@@I@Z ENDP ; std::allocator<CvGreatWorkInMyEmpire>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4EraTypes@@@std@@QAEPAW4EraTypes@@I@Z ; std::allocator<enum EraTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4EraTypes@@@std@@QAEPAW4EraTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4EraTypes@@@std@@QAEPAW4EraTypes@@I@Z PROC ; std::allocator<enum EraTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z ; std::_Allocate<enum EraTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4EraTypes@@@std@@QAEPAW4EraTypes@@I@Z ENDP ; std::allocator<enum EraTypes>::allocate
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z ; GetLocalizedText<CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z$0
__ehfuncinfo$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235282 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z PROC ; GetLocalizedText<CvString,CvString>, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235282[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 	text << arg1 << arg2;

	mov	ecx, DWORD PTR _arg1$[esp+108]
	mov	DWORD PTR __$EHRec$[esp+120], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 517  : 
; 518  : 	size_t bytes = 0;
; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 520  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 521  : 	str.assign(szComposedString, bytes);
; 522  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235282[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z$1:
	mov	eax, DWORD PTR $T235282[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T235282[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z ENDP ; GetLocalizedText<CvString,CvString>
PUBLIC	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z	; GetLocalizedText<int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$0
__ehfuncinfo$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235315 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z PROC	; GetLocalizedText<int>, COMDAT

; 501  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235315[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 503  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 504  : 
; 505  : 	size_t bytes = 0;
; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 507  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 508  : 	str.assign(szComposedString, bytes);
; 509  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235315[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$1:
	mov	eax, DWORD PTR $T235315[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T235315[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ENDP	; GetLocalizedText<int>
PUBLIC	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$0
__ehfuncinfo$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235335 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z PROC	; GetLocalizedText<int,int>, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235335[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 517  : 
; 518  : 	size_t bytes = 0;
; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 520  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 521  : 	str.assign(szComposedString, bytes);
; 522  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235335[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$1:
	mov	eax, DWORD PTR $T235335[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@4
	and	DWORD PTR $T235335[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@4:
	ret	0
__ehhandler$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ENDP	; GetLocalizedText<int,int>
PUBLIC	??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z ; GetLocalizedText<int,int,int,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z$0
__ehfuncinfo$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235358 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z PROC ; GetLocalizedText<int,int,int,int>, COMDAT

; 540  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 541  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235358[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 542  : 	text << arg1 << arg2 << arg3 << arg4;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 543  : 
; 544  : 	size_t bytes = 0;
; 545  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 546  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 547  : 	str.assign(szComposedString, bytes);
; 548  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235358[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 549  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z$1:
	mov	eax, DWORD PTR $T235358[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@5
	and	DWORD PTR $T235358[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@5:
	ret	0
__ehhandler$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z ENDP ; GetLocalizedText<int,int,int,int>
PUBLIC	??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z ; GetLocalizedText<int,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z$0
__ehfuncinfo$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235387 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z PROC ; GetLocalizedText<int,char const *>, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235387[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 517  : 
; 518  : 	size_t bytes = 0;
; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 520  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 521  : 	str.assign(szComposedString, bytes);
; 522  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235387[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z$1:
	mov	eax, DWORD PTR $T235387[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@6
	and	DWORD PTR $T235387[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@6:
	ret	0
__ehhandler$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z ENDP ; GetLocalizedText<int,char const *>
PUBLIC	??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z ; GetLocalizedText<int,int,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z$0
__ehfuncinfo$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235410 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z PROC	; GetLocalizedText<int,int,int>, COMDAT

; 527  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 528  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235410[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 529  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 530  : 
; 531  : 	size_t bytes = 0;
; 532  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 533  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 534  : 	str.assign(szComposedString, bytes);
; 535  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235410[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z$1:
	mov	eax, DWORD PTR $T235410[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@7
	and	DWORD PTR $T235410[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@7:
	ret	0
__ehhandler$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z ENDP	; GetLocalizedText<int,int,int>
PUBLIC	??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z ; GetLocalizedText<CvString,CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z$0
__ehfuncinfo$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235436 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z PROC ; GetLocalizedText<CvString,CvString,CvString>, COMDAT

; 527  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 528  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235436[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 529  : 	text << arg1 << arg2 << arg3;

	mov	ecx, DWORD PTR _arg1$[esp+108]
	mov	DWORD PTR __$EHRec$[esp+120], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	ecx, DWORD PTR _arg3$[esp+108]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 530  : 
; 531  : 	size_t bytes = 0;
; 532  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 533  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 534  : 	str.assign(szComposedString, bytes);
; 535  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235436[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z$1:
	mov	eax, DWORD PTR $T235436[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@8
	and	DWORD PTR $T235436[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@8:
	ret	0
__ehhandler$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z ENDP ; GetLocalizedText<CvString,CvString,CvString>
PUBLIC	??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z ; GetLocalizedText<CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z$1
__ehfuncinfo$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235478 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 28
??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z PROC ; GetLocalizedText<CvString>, COMDAT

; 501  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	esi
	xor	esi, esi
	push	edi
	mov	DWORD PTR $T235478[esp+108], esi

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+104]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+112]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 503  : 	text << arg1;

	lea	ecx, DWORD PTR _arg1$[esp+104]
	mov	BYTE PTR __$EHRec$[esp+116], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$[esp+112]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 504  : 
; 505  : 	size_t bytes = 0;
; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR _bytes$[esp+116], esi
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 507  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+104]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 508  : 	str.assign(szComposedString, bytes);
; 509  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+108]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235478[esp+116], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _arg1$[esp+104]
	mov	BYTE PTR __$EHRec$[esp+116], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z$0:
	lea	ecx, DWORD PTR _arg1$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z$1:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z$2:
	mov	eax, DWORD PTR $T235478[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@9
	and	DWORD PTR $T235478[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@9:
	ret	0
__ehhandler$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z ENDP ; GetLocalizedText<CvString>
PUBLIC	??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z ; GetLocalizedText<char const *,CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235507 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z PROC ; GetLocalizedText<char const *,CvString,CvString>, COMDAT

; 527  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 528  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235507[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 529  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	ecx, DWORD PTR _arg3$[esp+108]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 530  : 
; 531  : 	size_t bytes = 0;
; 532  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[esp+116]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 533  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 534  : 	str.assign(szComposedString, bytes);
; 535  : 	return str;

	mov	edx, DWORD PTR _bytes$[esp+112]
	push	edx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235507[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z$1:
	mov	eax, DWORD PTR $T235507[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@10
	and	DWORD PTR $T235507[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@10:
	ret	0
__ehhandler$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z ENDP ; GetLocalizedText<char const *,CvString,CvString>
PUBLIC	??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPlot * *,CvPlot * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum PlayerTypes *,enum PlayerTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum PlayerTypes *,enum PlayerTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL9@unchecked_@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum PlayerTypes *,enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z ; stdext::unchecked_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z
_TEXT	SEGMENT
$T235593 = -4						; size = 1
__Cat$235599 = -4					; size = 1
$T235595 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T235593[esp+4], 0
	mov	eax, DWORD PTR $T235593[esp+4]
	mov	ecx, DWORD PTR __Cat$235599[esp+4]
	mov	edx, DWORD PTR $T235595[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum EraTypes *,enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum EraTypes *,enum EraTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum EraTypes *,enum EraTypes *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z ; std::_Destroy_range<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlot *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z ; std::fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z PROC ; std::fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z ENDP ; std::fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z PROC ; std::fill<CvPlot * *,CvPlot *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ENDP ; std::fill<CvPlot * *,CvPlot *>
_TEXT	ENDS
PUBLIC	??$fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z ; std::fill<enum PlayerTypes *,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z PROC ; std::fill<enum PlayerTypes *,enum PlayerTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z ENDP ; std::fill<enum PlayerTypes *,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ; std::fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z PROC ; std::fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ; std::_Fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
??$fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ENDP ; std::fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
_TEXT	ENDS
PUBLIC	??$fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z ; std::fill<enum EraTypes *,enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z PROC ; std::fill<enum EraTypes *,enum EraTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@4
	pop	esi
$LN3@fill@4:

; 3188 : 	}

	ret	0
??$fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z ENDP ; std::fill<enum EraTypes *,enum EraTypes>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@3
	push	esi
$LL6@Move_backw@3:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@3
	pop	esi
$LN5@Move_backw@3:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4PlayerTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum PlayerTypes *,enum PlayerTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T235758 = -4						; size = 1
__Cat$235762 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T235758[esp+4], 0
	mov	eax, DWORD PTR $T235758[esp+4]
	mov	ecx, DWORD PTR __Cat$235762[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@4
	push	esi
$LL6@Move_backw@4:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@4
	pop	esi
$LN5@Move_backw@4:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4EraTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum EraTypes *,enum EraTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@ABV3@@Z ; std::allocator<CvGreatWorkBuildingInMyEmpire>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@ABV3@@Z PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@ABV3@@Z ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@@Z ; std::allocator<CvGreatWorkBuildingInMyEmpire>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::allocator<CvGreatWorkBuildingInMyEmpire>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@QAEXPAVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::allocator<CvGreatWorkBuildingInMyEmpire>::destroy
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@ABW43@@Z ; std::allocator<enum PlayerTypes>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@ABW43@@Z PROC ; std::allocator<enum PlayerTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@ABW43@@Z ENDP ; std::allocator<enum PlayerTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@@Z ; std::allocator<enum PlayerTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@@Z PROC ; std::allocator<enum PlayerTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4PlayerTypes@@@std@@QAEXPAW4PlayerTypes@@@Z ENDP ; std::allocator<enum PlayerTypes>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@ABV3@@Z ; std::allocator<CvGreatWorkInMyEmpire>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@ABV3@@Z PROC ; std::allocator<CvGreatWorkInMyEmpire>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@ABV3@@Z ENDP ; std::allocator<CvGreatWorkInMyEmpire>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@@Z ; std::allocator<CvGreatWorkInMyEmpire>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@@Z PROC ; std::allocator<CvGreatWorkInMyEmpire>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvGreatWorkInMyEmpire@@@std@@QAEXPAVCvGreatWorkInMyEmpire@@@Z ENDP ; std::allocator<CvGreatWorkInMyEmpire>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@ABW43@@Z ; std::allocator<enum EraTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@ABW43@@Z PROC ; std::allocator<enum EraTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@4:

; 156  : 		}

	ret	8
?construct@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@ABW43@@Z ENDP ; std::allocator<enum EraTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@@Z ; std::allocator<enum EraTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@@Z PROC ; std::allocator<enum EraTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4EraTypes@@@std@@QAEXPAW4EraTypes@@@Z ENDP ; std::allocator<enum EraTypes>::destroy
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEAAW4EraTypes@@XZ ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEAAW4EraTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEAAW4EraTypes@@XZ PROC ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBEAAW4EraTypes@@XZ ENDP ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEAAW4PlayerTypes@@XZ ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEAAW4PlayerTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEAAW4PlayerTypes@@XZ PROC ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBEAAW4PlayerTypes@@XZ ENDP ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator++
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@3:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
$LN5@Uninit_cop@4:
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
$LL6@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@5:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -12			; fffffff4H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator--
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-=
; Function compile flags: /Ogtpy
;	COMDAT ??Z?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	mov	eax, ecx

; 387  : 		return (*this += -_Off);

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	sub	edx, ecx
	neg	edx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 388  : 		}

	ret	4
??Z?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-=
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, ecx
	cmp	ecx, eax
	je	SHORT $LN11@iter_swap
	push	ebx
	mov	ebx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+8], ecx
	pop	ebx
$LN11@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@3
	pop	esi
$LN3@Fill_n@3:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 3157 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp]
	push	ebp
	push	esi
	push	edi
	push	eax
	push	ecx
	call	ebx

; 3158 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __Mid$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN24@Med3
	mov	eax, DWORD PTR __First$[esp+12]
	mov	edx, ecx
	cmp	ecx, eax
	je	SHORT $LN24@Med3
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Mid$[esp+12]
$LN24@Med3:

; 3159 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+12]
	push	ecx
	push	edx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN70@Med3

; 3160 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[esp+12]
	mov	eax, DWORD PTR __Mid$[esp+12]
	mov	edx, ecx
	cmp	ecx, eax
	je	SHORT $LN70@Med3
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ecx
$LN70@Med3:

; 3161 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __First$[esp+12]
	mov	ecx, DWORD PTR __Mid$[esp+12]
	push	eax
	push	ecx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN66@Med3

; 3162 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __Mid$[esp+12]
	mov	eax, DWORD PTR __First$[esp+12]
	mov	edx, ecx
	cmp	ecx, eax
	je	SHORT $LN66@Med3
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ecx
$LN66@Med3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3163 : 	}

	ret	0
??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@6
	push	esi
$LL6@Uninit_cop@6:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@6
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop@6:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@6
	pop	esi
$LN4@Uninit_cop@6:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@7
	npad	6
$LL2@Copy_backw@7:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR __Last$[esp-4], eax
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@7

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@7:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::random_access_iterator_tag>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
;	COMDAT ?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
$T236551 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ PROC ; CvThemingBonusInfo::GetDescription, COMDAT
; _this$ = ecx

; 42   : 	CvString GetDescription() {return m_strDescription;};

	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 4
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T236551[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ENDP ; CvThemingBonusInfo::GetDescription
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@5
	pop	esi
$LN3@fill@5:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@5
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@5:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@4
	pop	esi
$LN3@Fill_n@4:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z	; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z$0
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z
_TEXT	SEGMENT
_uiVersion$ = -44					; size = 4
_oldGreatWorkName$223026 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_iTemp$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z PROC	; operator>>, COMDAT

; 48   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi

; 49   : 	int iTemp;
; 50   : 
; 51   : 	uint uiVersion;
; 52   : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+44]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+52]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 53   : 
; 54   : 	if(uiVersion == 1)

	cmp	DWORD PTR _uiVersion$[esp+52], 1
	jne	SHORT $LN3@operator@3

; 55   : 	{
; 56   : 		CvString oldGreatWorkName;

	lea	ecx, DWORD PTR _oldGreatWorkName$223026[esp+52]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 57   : 		loadFrom >> oldGreatWorkName;

	lea	ecx, DWORD PTR _oldGreatWorkName$223026[esp+52]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 58   : 	}

	lea	ecx, DWORD PTR _oldGreatWorkName$223026[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@operator@3:

; 59   : 
; 60   : 	loadFrom >> writeTo.m_szGreatPersonName;

	mov	edi, DWORD PTR _writeTo$[esp+48]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 61   : 
; 62   : 	loadFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+48]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 63   : 	writeTo.m_eType = (GreatWorkType)iTemp;
; 64   : 
; 65   : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[esp+52], 3
	mov	eax, DWORD PTR _iTemp$[esp+48]
	mov	DWORD PTR [edi+28], eax
	jb	SHORT $LN2@operator@3

; 66   : 	{
; 67   : 		loadFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+48]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 68   : 		writeTo.m_eClassType = (GreatWorkClass)iTemp;

	mov	ecx, DWORD PTR _iTemp$[esp+48]
	mov	DWORD PTR [edi+32], ecx

; 69   : 	}
; 70   : 	else

	jmp	SHORT $LN1@operator@3
$LN2@operator@3:

; 71   : 	{
; 72   : 		writeTo.m_eClassType = CultureHelpers::GetGreatWorkClass(writeTo.m_eType);

	push	eax
	call	?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkClass
	add	esp, 4
	mov	DWORD PTR [edi+32], eax
$LN1@operator@3:

; 73   : 	}
; 74   : 
; 75   : 	loadFrom >> writeTo.m_iTurnFounded;

	lea	edx, DWORD PTR [edi+36]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 76   : 	loadFrom >> writeTo.m_eEra;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>

; 77   : 	loadFrom >> writeTo.m_ePlayer;

	add	edi, 44					; 0000002cH
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 78   : 
; 79   : 	return loadFrom;
; 80   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	add	esp, 16					; 00000010H
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z$0:
	lea	ecx, DWORD PTR _oldGreatWorkName$223026[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z ENDP	; operator>>
PUBLIC	?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z ; CvGameCulture::GetGreatWorkTooltip
EXTRN	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetGreatWorkYieldChange
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T236752 = -184						; size = 4
tv155 = -180						; size = 4
_cultureString$ = -176					; size = 28
_strYearString$ = -148					; size = 28
$T236750 = -120						; size = 28
_strGreatWorkName$ = -92				; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_eOwner$ = 16						; size = 4
?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z PROC ; CvGameCulture::GetGreatWorkTooltip, COMDAT
; _this$ = ecx

; 164  : {

	push	-1
	push	__ehhandler$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T236752[esp+200], edi

; 165  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 166  : 	CvString szTooltip = "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+196]
	mov	ebx, ecx
	push	OFFSET $SG223112
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+212], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 208  : 
; 209  : 	return szTooltip;

	mov	DWORD PTR __$EHRec$[esp+208], edi
	mov	edi, DWORD PTR _iIndex$[esp+196]
	lea	edi, DWORD PTR [edi+edi*2]
	mov	ebp, 1
	shl	edi, 4
	add	edi, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _strYearString$[esp+200]
	mov	DWORD PTR $T236752[esp+200], ebp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR __$EHRec$[esp+208], ebp
	mov	ebx, ecx
	mov	ebp, ecx
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	push	eax
	mov	ecx, ebx
	call	?getStartYear@CvGame@@QBEHXZ		; CvGame::getStartYear
	push	eax
	mov	ecx, ebp
	call	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ ; CvGame::getCalendar
	push	eax
	mov	eax, DWORD PTR [edi+36]
	push	0
	push	eax
	lea	ecx, DWORD PTR _strYearString$[esp+220]
	push	ecx
	call	?setDateStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z ; CvGameTextMgr::setDateStr
	mov	edx, DWORD PTR [edi+28]
	push	edx
	lea	eax, DWORD PTR $T236750[esp+228]
	push	eax
	call	?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkName
	add	esp, 32					; 00000020H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+208], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strGreatWorkName$[esp+204]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	lea	ecx, DWORD PTR $T236750[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strGreatWorkName$[esp+200]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, esi
	test	eax, eax
	je	SHORT $LN32@GetGreatWo@10
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@GetGreatWo@10

; 167  : 
; 168  : 	const CvGreatWork *pWork = &m_CurrentGreatWorks[iIndex];
; 169  : 
; 170  : 	CvString strYearString;
; 171  : 	CvGameTextMgr::setDateStr(strYearString,
; 172  : 		pWork->m_iTurnFounded,
; 173  : 		false /*bSave*/,
; 174  : 		GC.getGame().getCalendar(),
; 175  : 		GC.getGame().getStartYear(),
; 176  : 		GC.getGame().getGameSpeedType());
; 177  : 
; 178  : 	Localization::String strGreatWorkName = Localization::Lookup(CultureHelpers::GetGreatWorkName(pWork->m_eType));
; 179  : 
; 180  : 	szTooltip = strGreatWorkName.toUTF8();

$LN32@GetGreatWo@10:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@GetGreatWo@10:

; 181  : 	szTooltip += "[NEWLINE]";

	push	OFFSET $SG223118
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 182  : 
; 183  : #ifdef AUI_WARNING_FIXES
; 184  : 	if (pWork->m_szGreatPersonName[0] != '\0')
; 185  : #else
; 186  : 	if (strlen(pWork->m_szGreatPersonName) > 0)

	mov	ecx, edi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL58@GetGreatWo@10:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL58@GetGreatWo@10
	sub	eax, edx
	je	SHORT $LN1@GetGreatWo@10

; 187  : #endif
; 188  : 	{
; 189  : 		szTooltip += pWork->m_szGreatPersonName;

	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 190  : 		szTooltip += "[NEWLINE]";

	push	OFFSET $SG223120
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@GetGreatWo@10:

; 191  : 	}
; 192  : 	szTooltip += GET_PLAYER(pWork->m_ePlayer).getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi+44]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 193  : 	szTooltip += "[NEWLINE]";

	push	OFFSET $SG223121
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 194  : 	szTooltip += GC.getEraInfo(pWork->m_eEra)->GetDescription();

	mov	edx, DWORD PTR [edi+40]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 195  : 	szTooltip += " (";

	push	OFFSET $SG223122
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 196  : 	szTooltip += strYearString;

	lea	eax, DWORD PTR _strYearString$[esp+200]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 197  : 	szTooltip += ")";

	push	OFFSET $SG223123
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 198  : 	szTooltip += "[NEWLINE]";

	push	OFFSET $SG223124
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 199  : 	CvString cultureString;

	lea	ecx, DWORD PTR _cultureString$[esp+200]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 200  : 	int iCulturePerWork = GC.getBASE_CULTURE_PER_GREAT_WORK();
; 201  : 	iCulturePerWork += GET_PLAYER(eOwner).GetGreatWorkYieldChange(YIELD_CULTURE);

	mov	edi, DWORD PTR _eOwner$[esp+196]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edi, 63236				; 0000f704H
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8208
	add	ecx, edi
	push	4
	mov	BYTE PTR __$EHRec$[esp+212], 5
	call	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetGreatWorkYieldChange

; 202  : 	int iTourismPerWork = GC.getBASE_TOURISM_PER_GREAT_WORK();
; 203  : 	iTourismPerWork += GET_PLAYER(eOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_TOURISM_PER_GREAT_WORK); // NQMP GJS - Cultural Exchange

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8212
	lea	ecx, DWORD PTR [edi+edx]
	push	63					; 0000003fH
	add	ebp, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	ebx, eax

; 204  : 
; 205  : 
; 206  : 	cultureString.Format ("+%d [ICON_CULTURE], +%d [ICON_TOURISM]", iCulturePerWork, iTourismPerWork);

	push	ebx
	push	ebp
	lea	eax, DWORD PTR _cultureString$[esp+208]
	push	OFFSET $SG223128
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 207  : 	szTooltip += cultureString;

	lea	ecx, DWORD PTR _cultureString$[esp+200]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 208  : 
; 209  : 	return szTooltip;

	lea	ecx, DWORD PTR _cultureString$[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strGreatWorkName$[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strYearString$[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 210  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+200]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 184				; 000000b8H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$0:
	mov	eax, DWORD PTR $T236752[ebp]
	and	eax, 1
	je	$LN5@GetGreatWo@10
	and	DWORD PTR $T236752[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetGreatWo@10:
	ret	0
__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strYearString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR $T236750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strGreatWorkName$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _cultureString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGreatWorkTooltip@CvGameCulture@@QBE?AVCvString@@HW4PlayerTypes@@@Z ENDP ; CvGameCulture::GetGreatWorkTooltip
PUBLIC	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z
_TEXT	SEGMENT
$T236848 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z PROC ; CvGameCulture::GetGreatWorkName, COMDAT
; _this$ = ecx

; 214  : {

	push	ecx

; 215  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 216  : 	const CvGreatWork* pWork = &m_CurrentGreatWorks[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp]

; 217  : 
; 218  : 	return CultureHelpers::GetGreatWorkName(pWork->m_eType);

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	mov	edx, DWORD PTR [eax+ecx+28]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	edx
	push	esi
	mov	DWORD PTR $T236848[esp+16], 0
	call	?GetGreatWorkName@CultureHelpers@@YA?AVCvString@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkName
	add	esp, 8
	mov	eax, esi
	pop	esi

; 219  : }

	pop	ecx
	ret	8
?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ENDP ; CvGameCulture::GetGreatWorkName
_TEXT	ENDS
PUBLIC	?SwapGreatWorks@CvGameCulture@@QAE_NW4PlayerTypes@@H0H@Z ; CvGameCulture::SwapGreatWorks
EXTRN	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z:PROC ; CvCityBuildings::SetBuildingGreatWork
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
; Function compile flags: /Ogtpy
;	COMDAT ?SwapGreatWorks@CvGameCulture@@QAE_NW4PlayerTypes@@H0H@Z
_TEXT	SEGMENT
_ui$223310 = -36					; size = 4
_eMusicClass$ = -36					; size = 4
_eBuildingClass1$ = -32					; size = 4
_eArtifactsClass$ = -32					; size = 4
_pCity1$ = -28						; size = 4
_eArtClass$ = -28					; size = 4
tv455 = -24						; size = 4
_pCity2$ = -20						; size = 4
_eBuildingClass2$ = -16					; size = 4
_iSwapIndex1$ = -12					; size = 4
_iSwapIndex2$ = -8					; size = 4
_iCityLoop$ = -4					; size = 4
_ePlayer1$ = 8						; size = 4
_iWork1$ = 12						; size = 4
_ePlayer2$ = 16						; size = 4
_iWork2$ = 20						; size = 4
?SwapGreatWorks@CvGameCulture@@QAE_NW4PlayerTypes@@H0H@Z PROC ; CvGameCulture::SwapGreatWorks, COMDAT
; _this$ = ecx

; 392  : 	if (ePlayer1 == NO_PLAYER || ePlayer2 == NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer1$[esp-4]
	sub	esp, 36					; 00000024H
	push	ebx
	mov	ebx, ecx
	or	ecx, -1
	push	esi
	cmp	eax, ecx
	je	$LN58@SwapGreatW
	mov	esi, DWORD PTR _ePlayer2$[esp+40]
	cmp	esi, ecx
	je	$LN58@SwapGreatW

; 393  : 	{
; 394  : 		return false;
; 395  : 	}
; 396  : 
; 397  : 	if (iWork1 == -1 || iWork2 == -1)

	cmp	DWORD PTR _iWork1$[esp+40], ecx
	je	$LN58@SwapGreatW
	cmp	DWORD PTR _iWork2$[esp+40], ecx
	je	$LN58@SwapGreatW

; 400  : 	}
; 401  : 	
; 402  : 	if (!GET_PLAYER(ePlayer1).isAlive() || !GET_PLAYER(ePlayer2).isAlive())

	mov	ecx, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ecx, 63236				; 0000f704H
	add	ecx, eax
	cmp	BYTE PTR [ecx+2256], 0
	je	$LN58@SwapGreatW
	imul	esi, 63236				; 0000f704H
	cmp	BYTE PTR [esi+eax+2256], 0
	je	$LN58@SwapGreatW
	push	ebp
	push	edi

; 403  : 	{
; 404  : 		return false;
; 405  : 	}
; 406  : 
; 407  : 	CvPlayerCulture* pCulture1 = GET_PLAYER(ePlayer1).GetCulture();

	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture

; 408  : 	CvPlayerCulture* pCulture2 = GET_PLAYER(ePlayer2).GetCulture();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	mov	edi, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture

; 409  : 
; 410  : 	GreatWorkClass eWritingClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_LITERATURE");

	push	0
	push	OFFSET $SG223264
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 411  : 	GreatWorkClass eArtClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ART");

	push	0
	push	OFFSET $SG223267
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 412  : 	GreatWorkClass eArtifactsClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ARTIFACT");

	push	0
	push	OFFSET $SG223270
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eArtClass$[esp+60], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 413  : 	GreatWorkClass eMusicClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_MUSIC");

	push	0
	push	OFFSET $SG223273
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eArtifactsClass$[esp+60], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 414  : 
; 415  : 	GreatWorkClass eClass1 = GetGreatWorkClass(iWork1);

	mov	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _iWork1$[esp+48]
	mov	DWORD PTR _eMusicClass$[esp+52], eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 4
	mov	edx, DWORD PTR [eax+ecx+32]

; 416  : 	GreatWorkClass eClass2 = GetGreatWorkClass(iWork2);

	mov	eax, DWORD PTR _iWork2$[esp+48]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	mov	ecx, DWORD PTR [eax+ecx+32]

; 417  : 
; 418  : 	if (eClass1 != eClass2)

	cmp	edx, ecx

; 419  : 	{
; 420  : 		return false;

	jne	$LN5@SwapGreatW

; 421  : 	}
; 422  : 	
; 423  : 	// We can't trade things that aren't in our swappable slots
; 424  : 	bool bFoundSwappable = false;
; 425  : 	if (eClass1 == eWritingClass)

	cmp	edx, ebp
	jne	SHORT $LN54@SwapGreatW

; 426  : 	{
; 427  : 		if (pCulture1->GetSwappableWritingIndex() == iWork1)

	cmp	DWORD PTR [edi+276], ebx
	jne	$LN5@SwapGreatW

; 428  : 		{
; 429  : 			pCulture1->SetSwappableWritingIndex(-1);

	or	eax, -1
	mov	DWORD PTR [edi+276], eax

; 430  : 			bFoundSwappable = true;
; 431  : 		}
; 432  : 	}

	jmp	SHORT $LN43@SwapGreatW
$LN54@SwapGreatW:

; 433  : 	else if (eClass1 == eArtClass)

	cmp	edx, DWORD PTR _eArtClass$[esp+52]
	jne	SHORT $LN51@SwapGreatW

; 434  : 	{
; 435  : 		if (pCulture1->GetSwappableArtIndex() == iWork1)

	cmp	DWORD PTR [edi+280], ebx
	jne	$LN5@SwapGreatW

; 436  : 		{
; 437  : 			pCulture1->SetSwappableArtIndex(-1);

	mov	DWORD PTR [edi+280], -1

; 438  : 			bFoundSwappable = true;
; 439  : 		}
; 440  : 	}

	jmp	SHORT $LN146@SwapGreatW
$LN51@SwapGreatW:

; 441  : 	else if (eClass1 == eArtifactsClass)

	cmp	edx, DWORD PTR _eArtifactsClass$[esp+52]
	jne	SHORT $LN48@SwapGreatW

; 442  : 	{
; 443  : 		if (pCulture1->GetSwappableArtifactIndex() == iWork1)

	cmp	DWORD PTR [edi+284], ebx
	jne	$LN5@SwapGreatW

; 444  : 		{
; 445  : 			pCulture1->SetSwappableArtifactIndex(-1);

	mov	DWORD PTR [edi+284], -1

; 446  : 			bFoundSwappable = true;
; 447  : 		}
; 448  : 	}

	jmp	SHORT $LN146@SwapGreatW
$LN48@SwapGreatW:

; 449  : 	else if (eClass1 == eMusicClass)

	cmp	edx, DWORD PTR _eMusicClass$[esp+52]
	jne	$LN5@SwapGreatW

; 450  : 	{
; 451  : 		if (pCulture1->GetSwappableMusicIndex() == iWork1)

	cmp	DWORD PTR [edi+288], ebx
	jne	$LN5@SwapGreatW

; 452  : 		{
; 453  : 			pCulture1->SetSwappableMusicIndex(-1);

	mov	DWORD PTR [edi+288], -1
$LN146@SwapGreatW:

; 446  : 			bFoundSwappable = true;
; 447  : 		}
; 448  : 	}

	or	eax, -1
$LN43@SwapGreatW:

; 454  : 			bFoundSwappable = true;
; 455  : 		}
; 456  : 	}
; 457  : 
; 458  : 	if (!bFoundSwappable)
; 459  : 	{
; 460  : 		return false;
; 461  : 	}
; 462  : 
; 463  : 	bFoundSwappable = false;
; 464  : 	if (eClass2 == eWritingClass)

	cmp	ecx, ebp
	jne	SHORT $LN42@SwapGreatW

; 465  : 	{
; 466  : 		if (pCulture2->GetSwappableWritingIndex() == iWork2)

	mov	ecx, DWORD PTR _iWork2$[esp+48]
	cmp	DWORD PTR [esi+276], ecx
	jne	$LN5@SwapGreatW

; 467  : 		{
; 468  : 			pCulture2->SetSwappableWritingIndex(-1);

	mov	DWORD PTR [esi+276], eax

; 469  : 			bFoundSwappable = true;
; 470  : 		}
; 471  : 	}

	jmp	SHORT $LN31@SwapGreatW
$LN42@SwapGreatW:

; 472  : 	else if (eClass2 == eArtClass)

	cmp	ecx, DWORD PTR _eArtClass$[esp+52]
	jne	SHORT $LN39@SwapGreatW

; 473  : 	{
; 474  : 		if (pCulture2->GetSwappableArtIndex() == iWork2)

	mov	edx, DWORD PTR _iWork2$[esp+48]
	cmp	DWORD PTR [esi+280], edx
	jne	$LN5@SwapGreatW

; 475  : 		{
; 476  : 			pCulture2->SetSwappableArtIndex(-1);

	mov	DWORD PTR [esi+280], eax

; 477  : 			bFoundSwappable = true;
; 478  : 		}
; 479  : 	}

	jmp	SHORT $LN31@SwapGreatW
$LN39@SwapGreatW:

; 480  : 	else if (eClass2 == eArtifactsClass)

	cmp	ecx, DWORD PTR _eArtifactsClass$[esp+52]
	jne	SHORT $LN36@SwapGreatW

; 481  : 	{
; 482  : 		if (pCulture2->GetSwappableArtifactIndex() == iWork2)

	mov	ecx, DWORD PTR _iWork2$[esp+48]
	cmp	DWORD PTR [esi+284], ecx
	jne	$LN5@SwapGreatW

; 483  : 		{
; 484  : 			pCulture2->SetSwappableArtifactIndex(-1);

	mov	DWORD PTR [esi+284], eax

; 485  : 			bFoundSwappable = true;
; 486  : 		}
; 487  : 	}

	jmp	SHORT $LN31@SwapGreatW
$LN36@SwapGreatW:

; 488  : 	else if (eClass2 == eMusicClass)

	cmp	ecx, DWORD PTR _eMusicClass$[esp+52]
	jne	$LN5@SwapGreatW

; 489  : 	{
; 490  : 		if (pCulture2->GetSwappableMusicIndex() == iWork2)

	mov	edx, DWORD PTR _iWork2$[esp+48]
	cmp	DWORD PTR [esi+288], edx
	jne	$LN5@SwapGreatW

; 491  : 		{
; 492  : 			pCulture2->SetSwappableMusicIndex(-1);

	mov	DWORD PTR [esi+288], eax
$LN31@SwapGreatW:

; 493  : 			bFoundSwappable = true;
; 494  : 		}
; 495  : 	}
; 496  : 
; 497  : 	if (!bFoundSwappable)
; 498  : 	{
; 499  : 		return false;
; 500  : 	}
; 501  : 
; 502  : 	CvCity* pCity1 = NULL;

	xor	edi, edi

; 503  : 	BuildingClassTypes eBuildingClass1 = NO_BUILDINGCLASS;
; 504  : 	int iSwapIndex1 = -1;
; 505  : 
; 506  : 	CvCity* pCity2 = NULL;

	xor	ebp, ebp
	mov	DWORD PTR _pCity1$[esp+52], edi
	mov	DWORD PTR _eBuildingClass1$[esp+52], eax
	mov	DWORD PTR _iSwapIndex1$[esp+52], eax
	mov	DWORD PTR _pCity2$[esp+52], ebp

; 507  : 	BuildingClassTypes eBuildingClass2 = NO_BUILDINGCLASS;

	mov	DWORD PTR _eBuildingClass2$[esp+52], eax

; 508  : 	int iSwapIndex2 = -1;

	mov	DWORD PTR _iSwapIndex2$[esp+52], eax

; 509  : 
; 510  : 	int iCityLoop;
; 511  : 	CvCity* pCity = NULL;
; 512  : 	for (uint ui = 0; ui < 2; ui++)

	mov	DWORD PTR _ui$223310[esp+52], edi
	jmp	SHORT $LN30@SwapGreatW
	npad	5
$LL141@SwapGreatW:
	or	eax, -1
$LN30@SwapGreatW:

; 513  : 	{
; 514  : 		PlayerTypes eTempPlayer = NO_PLAYER;
; 515  : 		switch (ui)

	mov	ecx, edi
	sub	ecx, 0
	je	SHORT $LN25@SwapGreatW
	sub	ecx, 1
	jne	SHORT $LN26@SwapGreatW

; 519  : 			break;
; 520  : 		case 1:
; 521  : 			eTempPlayer = ePlayer2;

	mov	eax, DWORD PTR _ePlayer2$[esp+48]

; 522  : 			break;

	jmp	SHORT $LN26@SwapGreatW
$LN25@SwapGreatW:

; 516  : 		{
; 517  : 		case 0:
; 518  : 			eTempPlayer = ePlayer1;

	mov	eax, DWORD PTR _ePlayer1$[esp+48]
$LN26@SwapGreatW:

; 523  : 		}
; 524  : 
; 525  : 		for (pCity = GET_PLAYER(eTempPlayer).firstCity(&iCityLoop); pCity != NULL; pCity = GET_PLAYER(eTempPlayer).nextCity(&iCityLoop))

	mov	esi, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+56]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	mov	DWORD PTR tv455[esp+60], esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN29@SwapGreatW
$LL143@SwapGreatW:

; 526  : 		{
; 527  : #ifdef AUI_WARNING_FIXES
; 528  : 			for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 529  : #else
; 530  : 			for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN22@SwapGreatW
	npad	9
$LL20@SwapGreatW:

; 531  : #endif
; 532  : 			{
; 533  : 				CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(eTempPlayer).getCivilizationInfo();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 534  : 				BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 535  : 				if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN19@SwapGreatW

; 536  : 				{
; 537  : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebp, eax

; 538  : 					if (pkBuilding)

	test	ebp, ebp
	je	SHORT $LN19@SwapGreatW

; 539  : 					{
; 540  : 						if (pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	esi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN19@SwapGreatW

; 541  : 						{
; 542  : 							int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, ebp
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ebp, eax

; 543  : 							for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebp, ebp
	jle	SHORT $LN19@SwapGreatW
	npad	1
$LL14@SwapGreatW:

; 544  : 							{
; 545  : 								int iGreatWorkIndex = pCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	push	esi
	push	edi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 546  : 								if (ui == 0)

	mov	ecx, DWORD PTR _ui$223310[esp+52]
	test	ecx, ecx
	jne	SHORT $LN11@SwapGreatW

; 547  : 								{
; 548  : 									if (iGreatWorkIndex == iWork1)

	cmp	eax, DWORD PTR _iWork1$[esp+48]
	jne	SHORT $LN13@SwapGreatW

; 549  : 									{
; 550  : 										pCity1 = pCity;

	mov	DWORD PTR _pCity1$[esp+52], ebx

; 551  : 										eBuildingClass1 = (BuildingClassTypes)iBuildingClassLoop;

	mov	DWORD PTR _eBuildingClass1$[esp+52], edi

; 552  : 										iSwapIndex1 = iI;

	mov	DWORD PTR _iSwapIndex1$[esp+52], esi

; 553  : 										break;

	jmp	SHORT $LN19@SwapGreatW
$LN11@SwapGreatW:

; 554  : 									}
; 555  : 								}
; 556  : 								else if (ui == 1)

	cmp	ecx, 1
	jne	SHORT $LN13@SwapGreatW

; 557  : 								{
; 558  : 									if (iGreatWorkIndex == iWork2)

	cmp	eax, DWORD PTR _iWork2$[esp+48]
	je	SHORT $LN133@SwapGreatW
$LN13@SwapGreatW:

; 543  : 							for (int iI = 0; iI < iNumSlots; iI++)

	inc	esi
	cmp	esi, ebp
	jl	SHORT $LL14@SwapGreatW

; 557  : 								{
; 558  : 									if (iGreatWorkIndex == iWork2)

	jmp	SHORT $LN19@SwapGreatW
$LN133@SwapGreatW:

; 559  : 									{
; 560  : 										pCity2 = pCity;

	mov	DWORD PTR _pCity2$[esp+52], ebx

; 561  : 										eBuildingClass2 = (BuildingClassTypes)iBuildingClassLoop;

	mov	DWORD PTR _eBuildingClass2$[esp+52], edi

; 562  : 										iSwapIndex2 = iI;

	mov	DWORD PTR _iSwapIndex2$[esp+52], esi
$LN19@SwapGreatW:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	mov	esi, DWORD PTR tv455[esp+52]
	jl	$LL20@SwapGreatW
$LN22@SwapGreatW:

; 523  : 		}
; 524  : 
; 525  : 		for (pCity = GET_PLAYER(eTempPlayer).firstCity(&iCityLoop); pCity != NULL; pCity = GET_PLAYER(eTempPlayer).nextCity(&iCityLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+56]
	add	ecx, esi
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL143@SwapGreatW
	mov	edi, DWORD PTR _ui$223310[esp+52]
	mov	ebp, DWORD PTR _pCity2$[esp+52]
$LN29@SwapGreatW:
	inc	edi
	mov	DWORD PTR _ui$223310[esp+52], edi
	cmp	edi, 2
	jb	$LL141@SwapGreatW

; 563  : 										break;
; 564  : 									}
; 565  : 								}
; 566  : 							}
; 567  : 						}
; 568  : 					}
; 569  : 				}
; 570  : 			}
; 571  : 		}
; 572  : 	}
; 573  : 
; 574  : 	if (pCity1 == NULL || pCity2 == NULL)

	mov	ecx, DWORD PTR _pCity1$[esp+52]
	test	ecx, ecx
	je	$LN5@SwapGreatW
	test	ebp, ebp
	je	$LN5@SwapGreatW

; 577  : 	}
; 578  : 
; 579  : 	if (eBuildingClass1 == NO_BUILDINGCLASS || eBuildingClass2 == NO_BUILDINGCLASS)

	mov	eax, DWORD PTR _eBuildingClass1$[esp+52]
	cmp	eax, -1
	je	$LN5@SwapGreatW
	mov	ebx, DWORD PTR _eBuildingClass2$[esp+52]
	cmp	ebx, -1
	je	$LN5@SwapGreatW

; 580  : 	{
; 581  : 		return false;
; 582  : 	}
; 583  : 
; 584  : 	if (iSwapIndex1 == -1 || iSwapIndex2 == -1)

	mov	edi, DWORD PTR _iSwapIndex1$[esp+52]
	cmp	edi, -1
	je	SHORT $LN5@SwapGreatW
	mov	esi, DWORD PTR _iSwapIndex2$[esp+52]
	cmp	esi, -1
	je	SHORT $LN5@SwapGreatW

; 585  : 	{
; 586  : 		return false;
; 587  : 	}
; 588  : 
; 589  : 	// remove existing great works
; 590  : 	pCity1->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass1, iSwapIndex1, NO_GREAT_WORK);

	push	-1
	push	edi
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 591  : 	pCity2->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass2, iSwapIndex2, NO_GREAT_WORK);

	push	-1
	push	esi
	push	ebx
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 592  : 
; 593  : 	// add in new works
; 594  : 	pCity1->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass1, iSwapIndex1, iWork2);

	mov	eax, DWORD PTR _iWork2$[esp+48]
	mov	ecx, DWORD PTR _eBuildingClass1$[esp+52]
	push	eax
	push	edi
	push	ecx
	mov	ecx, DWORD PTR _pCity1$[esp+64]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 595  : 	pCity2->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass2, iSwapIndex2, iWork1);

	mov	edx, DWORD PTR _iWork1$[esp+48]
	push	edx
	push	esi
	push	ebx
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 596  : 	
; 597  : 	GC.GetEngineUserInterface()->setDirty(GreatWorksScreen_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	36					; 00000024H
	call	edx
	pop	edi
	pop	ebp
	pop	esi

; 598  : 
; 599  : 	return true;

	mov	al, 1
	pop	ebx

; 600  : }

	add	esp, 36					; 00000024H
	ret	16					; 00000010H
$LN5@SwapGreatW:
	pop	edi
	pop	ebp
	pop	esi

; 575  : 	{
; 576  : 		return false;

	xor	al, al
	pop	ebx

; 600  : }

	add	esp, 36					; 00000024H
	ret	16					; 00000010H
$LN58@SwapGreatW:
	pop	esi

; 398  : 	{
; 399  : 		return false;

	xor	al, al
	pop	ebx

; 600  : }

	add	esp, 36					; 00000024H
	ret	16					; 00000010H
?SwapGreatWorks@CvGameCulture@@QAE_NW4PlayerTypes@@H0H@Z ENDP ; CvGameCulture::SwapGreatWorks
_TEXT	ENDS
PUBLIC	?MoveGreatWorks@CvGameCulture@@QAEXW4PlayerTypes@@HHHHHH@Z ; CvGameCulture::MoveGreatWorks
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?MoveGreatWorks@CvGameCulture@@QAEXW4PlayerTypes@@HHHHHH@Z
_TEXT	SEGMENT
_workType1$ = 8						; size = 4
_ePlayer$ = 8						; size = 4
_iCity1$ = 12						; size = 4
_iBuildingClass1$ = 16					; size = 4
_iWorkIndex1$ = 20					; size = 4
_iCity2$ = 24						; size = 4
_iBuildingClass2$ = 28					; size = 4
_iWorkIndex2$ = 32					; size = 4
?MoveGreatWorks@CvGameCulture@@QAEXW4PlayerTypes@@HHHHHH@Z PROC ; CvGameCulture::MoveGreatWorks, COMDAT
; _this$ = ecx

; 605  : 	if(ePlayer == NO_PLAYER){

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, -1
	je	$LN1@MoveGreatW

; 606  : 		return;
; 607  : 	}
; 608  : 
; 609  : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, eax

; 610  : 	if (!kPlayer.isAlive()){

	cmp	BYTE PTR [edi+2256], 0
	je	$LN13@MoveGreatW

; 611  : 		return;
; 612  : 	}
; 613  : 
; 614  : 	CvCity* pCity1 = kPlayer.getCity(iCity1);

	mov	eax, DWORD PTR _iCity1$[esp]
	push	esi
	push	eax
	mov	ecx, edi
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 615  : 	CvCity* pCity2 = kPlayer.getCity(iCity2);

	mov	ecx, DWORD PTR _iCity2$[esp+4]
	push	ecx
	mov	ecx, edi
	mov	esi, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 616  : 	if(!pCity1 || !pCity2){

	test	esi, esi
	je	SHORT $LN14@MoveGreatW
	test	edi, edi
	je	SHORT $LN14@MoveGreatW
	push	ebx

; 617  : 		return;
; 618  : 	}
; 619  : 
; 620  : 	int workType1 = pCity1->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClass1, iWorkIndex1);

	mov	ebx, DWORD PTR _iWorkIndex1$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _iBuildingClass1$[esp+12]
	push	ebx
	push	ebp
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 621  : 	int workType2 = pCity2->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClass2, iWorkIndex2);

	mov	edx, DWORD PTR _iWorkIndex2$[esp+12]
	mov	DWORD PTR _workType1$[esp+12], eax
	mov	eax, DWORD PTR _iBuildingClass2$[esp+12]
	push	edx
	push	eax
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 622  : 	pCity1->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClass1, iWorkIndex1, workType2);

	push	eax
	push	ebx
	push	ebp
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 623  : 	pCity2->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClass2, iWorkIndex2, workType1);

	mov	ecx, DWORD PTR _workType1$[esp+12]
	mov	edx, DWORD PTR _iWorkIndex2$[esp+12]
	mov	eax, DWORD PTR _iBuildingClass2$[esp+12]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork
	pop	ebp
	pop	ebx
$LN14@MoveGreatW:
	pop	esi
$LN13@MoveGreatW:
	pop	edi
$LN1@MoveGreatW:

; 624  : }

	ret	28					; 0000001cH
?MoveGreatWorks@CvGameCulture@@QAEXW4PlayerTypes@@HHHHHH@Z ENDP ; CvGameCulture::MoveGreatWorks
_TEXT	ENDS
PUBLIC	?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ ; CvGameCulture::GetNumCivsInfluentialForWin
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ
_TEXT	SEGMENT
?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ PROC	; CvGameCulture::GetNumCivsInfluentialForWin, COMDAT
; _this$ = ecx

; 628  : {

	push	ebx
	push	esi
	push	edi

; 629  : 	// How many players are alive?
; 630  : 	int iAliveMajors = 0;

	xor	ebx, ebx
	xor	edi, edi
	npad	9
$LL4@GetNumCivs:

; 632  : 	{
; 633  : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iPlayerLoop);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 634  : 		if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN3@GetNumCivs
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN3@GetNumCivs
	mov	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN3@GetNumCivs

; 635  : 		{
; 636  : 			iAliveMajors++;

	inc	ebx
$LN3@GetNumCivs:

; 631  : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL4@GetNumCivs
	pop	edi
	pop	esi

; 637  : 		}
; 638  : 	}
; 639  : 
; 640  : 	return iAliveMajors - 1;  // Don't have to be influential over yourself

	lea	eax, DWORD PTR [ebx-1]
	pop	ebx

; 641  : }

	ret	0
?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ ENDP	; CvGameCulture::GetNumCivsInfluentialForWin
_TEXT	ENDS
PUBLIC	?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvPlayerCulture::GetClosestAvailableGreatWorkSlot
EXTRN	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z:PROC ; CvCityBuildings::GetNextAvailableGreatWorkSlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z
_TEXT	SEGMENT
_eBuildingClassReturned$ = -16				; size = 4
_iSlotReturned$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_this$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eGreatWorkSlot$ = 16					; size = 4
_eBuildingClass$ = 20					; size = 4
_iSlot$ = 24						; size = 4
?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z PROC ; CvPlayerCulture::GetClosestAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 836  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 837  : 	int iLoop;
; 838  : 	int iBestDistance = MAX_INT;
; 839  : 	CvCity *pBestCity = NULL;
; 840  : 	BuildingClassTypes eBuildingClassReturned = NO_BUILDINGCLASS; // Passed by reference below

	or	eax, -1
	push	esi
	xor	ebp, ebp
	mov	DWORD PTR _eBuildingClassReturned$[esp+28], eax

; 841  : #ifdef AUI_WARNING_FIXES
; 842  : 	uint iSlotReturned = MAX_UNSIGNED_INT; // Passed by reference below
; 843  : #else
; 844  : 	int iSlotReturned = -1; // Passed by reference below

	mov	DWORD PTR _iSlotReturned$[esp+28], eax

; 845  : #endif
; 846  : 
; 847  : 	for (CvCity* pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	push	ebp
	lea	eax, DWORD PTR _iLoop$[esp+32]
	mov	DWORD PTR _this$[esp+32], ecx
	mov	ecx, DWORD PTR [ecx+292]
	push	eax
	mov	ebx, 2147483647				; 7fffffffH
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN18@GetClosest
	push	edi
$LL5@GetClosest:

; 848  : 	{
; 849  : 		int iDistance = plotDistance (iX, iY, pCity->getX(), pCity->getY());

	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR _iY$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR _iX$[esp+32]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	edi, eax
	add	esp, 16					; 00000010H

; 850  : 
; 851  : 		if (iDistance < iBestDistance)

	cmp	edi, ebx
	jge	SHORT $LN4@GetClosest

; 852  : 		{
; 853  : 			if (pCity->GetCityBuildings()->GetNextAvailableGreatWorkSlot(eGreatWorkSlot, &eBuildingClassReturned, &iSlotReturned))

	mov	ecx, DWORD PTR _eGreatWorkSlot$[esp+28]
	lea	edx, DWORD PTR _iSlotReturned$[esp+32]
	push	edx
	lea	eax, DWORD PTR _eBuildingClassReturned$[esp+36]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot
	test	al, al
	je	SHORT $LN4@GetClosest

; 854  : 			{
; 855  : 				iBestDistance = iDistance;
; 856  : 				pBestCity = pCity;
; 857  : 				*eBuildingClass = eBuildingClassReturned;

	mov	edx, DWORD PTR _eBuildingClassReturned$[esp+32]
	mov	eax, DWORD PTR _eBuildingClass$[esp+28]

; 858  : 				*iSlot = iSlotReturned;

	mov	ecx, DWORD PTR _iSlotReturned$[esp+32]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _iSlot$[esp+28]
	mov	ebx, edi
	mov	ebp, esi
	mov	DWORD PTR [edx], ecx
$LN4@GetClosest:
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [ecx+292]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+36]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL5@GetClosest
	pop	edi
$LN18@GetClosest:
	pop	esi

; 859  : 			}
; 860  : 		}
; 861  : 	}
; 862  : 
; 863  : 	return pBestCity;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 864  : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ENDP ; CvPlayerCulture::GetClosestAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
_pLoopCity$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_this$ = -4						; size = 4
_iSearchIndex$ = 8					; size = 4
_iReturnCityID$ = 12					; size = 4
_eReturnBuilding$ = 16					; size = 4
_iReturnSlot$ = 20					; size = 4
?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z PROC ; CvPlayerCulture::GetGreatWorkLocation, COMDAT
; _this$ = ecx

; 981  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx

; 982  : 	CvCity* pLoopCity = NULL;
; 983  : 	int iLoop = 0;
; 984  : 
; 985  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx+292]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+32]
	push	eax
	mov	DWORD PTR _this$[esp+36], ebx
	mov	DWORD PTR _iLoop$[esp+36], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[esp+28], eax
	test	eax, eax
	je	$LN11@GetGreatWo@11
$LL27@GetGreatWo@11:

; 986  : 	{
; 987  : #ifdef AUI_WARNING_FIXES
; 988  : 		for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 989  : #else
; 990  : 		for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN12@GetGreatWo@11
	npad	9
$LL10@GetGreatWo@11:

; 991  : #endif
; 992  : 		{
; 993  : 			CvCivilizationInfo& playerCivilizationInfo = m_pPlayer->getCivilizationInfo();

	mov	ecx, DWORD PTR [ebx+292]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 994  : 			BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	ebp, eax

; 995  : 			if (eBuilding != NO_BUILDING)

	cmp	ebp, -1
	je	SHORT $LN9@GetGreatWo@11

; 996  : 			{
; 997  : 				CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 998  : 				if (pkBuilding)

	test	esi, esi
	je	SHORT $LN9@GetGreatWo@11

; 999  : 				{
; 1000 : 					if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _pLoopCity$[esp+28]
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN9@GetGreatWo@11

; 1001 : 					{
; 1002 : #ifdef AUI_WARNING_FIXES
; 1003 : 						for (uint iI = 0; iI < pkBuilding->GetGreatWorkCount(); iI++)
; 1004 : #else
; 1005 : 						int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, esi
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ebx, eax

; 1006 : 						for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN28@GetGreatWo@11
	npad	1
$LL4@GetGreatWo@11:

; 1007 : #endif
; 1008 : 						{
; 1009 : 							int iGreatWorkIndex = pLoopCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	mov	ecx, DWORD PTR _pLoopCity$[esp+28]
	push	esi
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 1010 : 							if (iGreatWorkIndex == iSearchIndex)

	cmp	eax, DWORD PTR _iSearchIndex$[esp+24]
	je	SHORT $LN23@GetGreatWo@11
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL4@GetGreatWo@11
$LN28@GetGreatWo@11:

; 1006 : 						for (int iI = 0; iI < iNumSlots; iI++)

	mov	ebx, DWORD PTR _this$[esp+28]
$LN9@GetGreatWo@11:

; 986  : 	{
; 987  : #ifdef AUI_WARNING_FIXES
; 988  : 		for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 989  : #else
; 990  : 		for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL10@GetGreatWo@11
$LN12@GetGreatWo@11:

; 982  : 	CvCity* pLoopCity = NULL;
; 983  : 	int iLoop = 0;
; 984  : 
; 985  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[esp+28], eax
	test	eax, eax
	jne	$LL27@GetGreatWo@11
$LN11@GetGreatWo@11:
	pop	edi
	pop	esi
	pop	ebp

; 1016 : 							}
; 1017 : 						}
; 1018 : 					}
; 1019 : 				}
; 1020 : 			}
; 1021 : 		}
; 1022 : 	}
; 1023 : 
; 1024 : 	return false;	

	xor	al, al
	pop	ebx

; 1025 : }

	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN23@GetGreatWo@11:

; 1011 : 							{
; 1012 : 								iReturnCityID = pLoopCity->GetID();

	mov	edx, DWORD PTR _pLoopCity$[esp+28]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _iReturnCityID$[esp+24]

; 1013 : 								eReturnBuilding = eBuilding;

	mov	edx, DWORD PTR _eReturnBuilding$[esp+24]
	mov	DWORD PTR [ecx], eax

; 1014 : 								iReturnSlot = iI;

	mov	eax, DWORD PTR _iReturnSlot$[esp+24]
	pop	edi
	mov	DWORD PTR [edx], ebp
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebp

; 1015 : 								return true;

	mov	al, 1
	pop	ebx

; 1025 : }

	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ENDP ; CvPlayerCulture::GetGreatWorkLocation
_TEXT	ENDS
PUBLIC	?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z ; CvPlayerCulture::MoveWorkIntoSlot
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
; Function compile flags: /Ogtpy
;	COMDAT ?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_iFromCityID$ = -8					; size = 4
_iFromSlot$ = -4					; size = 4
_kWork$ = 8						; size = 24
_iFromWork$225312 = 32					; size = 4
_iCityID$ = 32						; size = 4
_eFromBuildingClass$225314 = 36				; size = 4
_pkFromEntry$ = 36					; size = 4
_eFromBuildingType$ = 36				; size = 4
_eBuilding$ = 36					; size = 4
_iSlot$ = 40						; size = 4
?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z PROC ; CvPlayerCulture::MoveWorkIntoSlot, COMDAT
; _this$ = ecx

; 1893 : {

	sub	esp, 8

; 1894 : 	CvBuildingEntry *pkToEntry = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$[esp+4]
	push	ebx
	push	edi
	mov	ebx, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 1895 : 
; 1896 : 	int iFromCityID;
; 1897 : 	BuildingTypes eFromBuildingType;
; 1898 : #ifdef AUI_WARNING_FIXES
; 1899 : 	uint iFromSlot;
; 1900 : #else
; 1901 : 	int iFromSlot;
; 1902 : #endif
; 1903 : 	GetGreatWorkLocation(kWork.m_iGreatWorkIndex, iFromCityID, eFromBuildingType, iFromSlot);

	lea	ecx, DWORD PTR _iFromSlot$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR _kWork$[esp+16]
	lea	edx, DWORD PTR _eFromBuildingType$[esp+16]
	mov	edi, eax
	push	edx
	lea	eax, DWORD PTR _iFromCityID$[esp+24]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1904 : 
; 1905 : 	CvBuildingEntry *pkFromEntry = GC.getBuildingInfo(eFromBuildingType);

	mov	edx, DWORD PTR _eFromBuildingType$[esp+12]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkFromEntry$[esp+12], eax

; 1906 : 	if (pkToEntry && pkFromEntry)

	test	edi, edi
	je	$LN1@MoveWorkIn
	test	eax, eax
	je	$LN1@MoveWorkIn

; 1907 : 	{
; 1908 : 		CvCity *pToCity = m_pPlayer->getCity(iCityID);

	mov	eax, DWORD PTR _iCityID$[esp+12]
	mov	ecx, DWORD PTR [ebx+292]
	push	ebp
	push	esi
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1909 : 		BuildingClassTypes eToBuildingClass = (BuildingClassTypes)pkToEntry->GetBuildingClassType();

	mov	ecx, edi
	mov	esi, eax
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType

; 1910 : 
; 1911 : 		int iFromWork = pToCity->GetCityBuildings()->GetBuildingGreatWork(eToBuildingClass, iSlot);

	mov	ebp, DWORD PTR _iSlot$[esp+20]
	mov	edi, eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 1912 : 		CvCity *pFromCity = m_pPlayer->getCity(iFromCityID);

	mov	ecx, DWORD PTR _iFromCityID$[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	mov	DWORD PTR _iFromWork$225312[esp+24], eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1913 : 		BuildingClassTypes eFromBuildingClass = (BuildingClassTypes)pkFromEntry->GetBuildingClassType();

	mov	ecx, DWORD PTR _pkFromEntry$[esp+20]
	mov	ebx, eax
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType

; 1914 : 
; 1915 : 		pToCity->GetCityBuildings()->SetBuildingGreatWork(eToBuildingClass, iSlot, kWork.m_iGreatWorkIndex);

	mov	edx, DWORD PTR _kWork$[esp+20]
	push	edx
	push	ebp
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _eFromBuildingClass$225314[esp+32], eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 1916 : 		pFromCity->GetCityBuildings()->SetBuildingGreatWork(eFromBuildingClass, iFromSlot, iFromWork);

	mov	eax, DWORD PTR _iFromWork$225312[esp+20]
	mov	ecx, DWORD PTR _iFromSlot$[esp+24]
	mov	edx, DWORD PTR _eFromBuildingClass$225314[esp+20]
	push	eax
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork
	pop	esi
	pop	ebp
$LN1@MoveWorkIn:
	pop	edi
	pop	ebx

; 1917 : 	}
; 1918 : }

	add	esp, 8
	ret	36					; 00000024H
?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z ENDP ; CvPlayerCulture::MoveWorkIntoSlot
_TEXT	ENDS
PUBLIC	?GetNextDigCompleteArchaeologist@CvPlayerCulture@@QBEPAVCvUnit@@PAPAVCvPlot@@@Z ; CvPlayerCulture::GetNextDigCompleteArchaeologist
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextDigCompleteArchaeologist@CvPlayerCulture@@QBEPAVCvUnit@@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
_pRtnValue$ = -4					; size = 4
_iLoop$225528 = 8					; size = 4
_ppPlot$ = 8						; size = 4
?GetNextDigCompleteArchaeologist@CvPlayerCulture@@QBEPAVCvUnit@@PAPAVCvPlot@@@Z PROC ; CvPlayerCulture::GetNextDigCompleteArchaeologist, COMDAT
; _this$ = ecx

; 2009 : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx

; 2010 : 	CvUnit *pRtnValue = NULL;
; 2011 : 	CvPlot *pPlot = GetNextDigCompletePlot();

	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp+8]
	sub	edx, eax
	push	edi
	xor	ecx, ecx
	sar	edx, 2
	xor	edi, edi
	mov	DWORD PTR _pRtnValue$[esp+16], ecx
	test	edx, edx
	jbe	SHORT $LN10@GetNextDig@2
	mov	edi, DWORD PTR [eax]
$LN10@GetNextDig@2:

; 2012 : 	*ppPlot = pPlot;

	mov	eax, DWORD PTR _ppPlot$[esp+12]
	mov	DWORD PTR [eax], edi

; 2013 : 	int iClosestDistance = MAX_INT;

	mov	ebx, 2147483647				; 7fffffffH

; 2014 : 
; 2015 : 	if (pPlot)

	test	edi, edi
	je	SHORT $LN34@GetNextDig@2
	push	esi

; 2016 : 	{
; 2017 : 		int iLoop;
; 2018 : 		CvUnit *pLoopUnit;
; 2019 : 		for (pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$225528[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [ebp+292]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN32@GetNextDig@2
$LL6@GetNextDig@2:

; 2020 : 		{
; 2021 : 			if (pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN5@GetNextDig@2

; 2022 : 			{
; 2023 : 				int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	mov	ecx, DWORD PTR [esi+88]
	push	edx
	mov	edx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2024 : 				if (iDistance < iClosestDistance)

	cmp	eax, ebx
	jge	SHORT $LN35@GetNextDig@2

; 2025 : 				{
; 2026 : 					pRtnValue = pLoopUnit;

	mov	DWORD PTR _pRtnValue$[esp+20], esi

; 2027 : 					iClosestDistance = iDistance;

	mov	ebx, eax
$LN35@GetNextDig@2:

; 2028 : 				}
; 2029 : 				if (iDistance == 0) break;

	test	eax, eax
	je	SHORT $LN32@GetNextDig@2
$LN5@GetNextDig@2:

; 2016 : 	{
; 2017 : 		int iLoop;
; 2018 : 		CvUnit *pLoopUnit;
; 2019 : 		for (pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [ebp+292]
	push	0
	lea	eax, DWORD PTR _iLoop$225528[esp+20]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL6@GetNextDig@2
$LN32@GetNextDig@2:

; 2030 : 			}
; 2031 : 		}
; 2032 : 	}
; 2033 : 
; 2034 : 	return pRtnValue;

	mov	eax, DWORD PTR _pRtnValue$[esp+20]
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx

; 2035 : }

	pop	ecx
	ret	4
$LN34@GetNextDig@2:
	pop	edi
	pop	ebp

; 2030 : 			}
; 2031 : 		}
; 2032 : 	}
; 2033 : 
; 2034 : 	return pRtnValue;

	mov	eax, ecx
	pop	ebx

; 2035 : }

	pop	ecx
	ret	4
?GetNextDigCompleteArchaeologist@CvPlayerCulture@@QBEPAVCvUnit@@PAPAVCvPlot@@@Z ENDP ; CvPlayerCulture::GetNextDigCompleteArchaeologist
_TEXT	ENDS
PUBLIC	?HasDigCompleteHere@CvPlayerCulture@@QBE_NPAVCvPlot@@@Z ; CvPlayerCulture::HasDigCompleteHere
; Function compile flags: /Ogtpy
;	COMDAT ?HasDigCompleteHere@CvPlayerCulture@@QBE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?HasDigCompleteHere@CvPlayerCulture@@QBE_NPAVCvPlot@@@Z PROC ; CvPlayerCulture::HasDigCompleteHere, COMDAT
; _this$ = ecx

; 2040 : 	vector<CvPlot *>::const_iterator it;
; 2041 : 
; 2042 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2043 : 	for (it = m_aDigCompletePlots.begin(); it != m_aDigCompletePlots.end(); ++it)
; 2044 : #else
; 2045 : 	for (it = m_aDigCompletePlots.begin(); it != m_aDigCompletePlots.end(); it++)

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	eax, ecx
	je	SHORT $LN2@HasDigComp
	mov	edx, DWORD PTR _pPlot$[esp-4]
	npad	2
$LL15@HasDigComp:

; 2046 : #endif
; 2047 : 	{
; 2048 : 		if (*it == pPlot)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN28@HasDigComp
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL15@HasDigComp
$LN2@HasDigComp:

; 2051 : 		}
; 2052 : 	}
; 2053 : 
; 2054 : 	return false;

	xor	al, al

; 2055 : }

	ret	4
$LN28@HasDigComp:

; 2049 : 		{
; 2050 : 			return true;

	mov	al, 1

; 2055 : }

	ret	4
?HasDigCompleteHere@CvPlayerCulture@@QBE_NPAVCvPlot@@@Z ENDP ; CvPlayerCulture::HasDigCompleteHere
_TEXT	ENDS
PUBLIC	?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z ; CvPlayerCulture::GetArchaeologyChoice
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?HasWrittenArtifact@CvPlot@@QBE_NXZ:PROC	; CvPlot::HasWrittenArtifact
EXTRN	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ:PROC ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
; Function compile flags: /Ogtpy
;	COMDAT ?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_eArtArtifactSlot$ = -28				; size = 4
_iNumArchaeologists$225580 = -24			; size = 4
$T237187 = -20						; size = 20
$T237186 = -20						; size = 20
_iNumSites$225581 = 8					; size = 4
_pPlot$ = 8						; size = 4
?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z PROC ; CvPlayerCulture::GetArchaeologyChoice, COMDAT
; _this$ = ecx

; 2072 : {

	sub	esp, 28					; 0000001cH
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 2073 : 	ArchaeologyChoiceType eRtnValue = ARCHAEOLOGY_DO_NOTHING;
; 2074 : 
; 2075 : 	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT

; 2076 : 
; 2077 : 	if (pPlot->HasWrittenArtifact())

	mov	ebp, DWORD PTR _pPlot$[esp+36]
	mov	edi, eax
	mov	ecx, ebp
	mov	DWORD PTR _eArtArtifactSlot$[esp+40], edi
	call	?HasWrittenArtifact@CvPlot@@QBE_NXZ	; CvPlot::HasWrittenArtifact

; 2078 : 	{
; 2079 : 		eRtnValue = ARCHAEOLOGY_ARTIFACT_WRITING;
; 2080 : 	}
; 2081 : 	
; 2082 : 	// No slots? Definitely go for Landmark or Cultural Renaissance
; 2083 : 	if (!HasAvailableGreatWorkSlot(eArtArtifactSlot))

	push	edi
	mov	ecx, esi
	call	?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z ; CvPlayerCulture::HasAvailableGreatWorkSlot
	test	al, al
	jne	SHORT $LN19@GetArchaeo

; 2084 : 	{
; 2085 : 		if (pPlot->HasWrittenArtifact())

	mov	ecx, ebp
	call	?HasWrittenArtifact@CvPlot@@QBE_NXZ	; CvPlot::HasWrittenArtifact
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, 3
	pop	esi
	inc	eax
	pop	ebp

; 2160 : }

	add	esp, 28					; 0000001cH
	ret	4
$LN19@GetArchaeo:

; 2086 : 		{
; 2087 : 			eRtnValue = ARCHAEOLOGY_CULTURE_BOOST;
; 2088 : 		}
; 2089 : 		else
; 2090 : 		{
; 2091 : 			eRtnValue = ARCHAEOLOGY_LANDMARK;
; 2092 : 		}
; 2093 : 	}
; 2094 : 
; 2095 : 	// Outside territory? Go for artifact ...
; 2096 : 	else if (pPlot->getOwner() != m_pPlayer->GetID())

	mov	cl, BYTE PTR [ebp+4]
	mov	edx, DWORD PTR [esi+292]
	movsx	eax, cl
	push	ebx
	cmp	eax, DWORD PTR [edx+44]
	je	$LN15@GetArchaeo

; 2097 : 	{
; 2098 : 		eRtnValue = ARCHAEOLOGY_ARTIFACT_PLAYER1;

	mov	edi, 2

; 2099 : 
; 2100 : 		// ... unless this is a city state we want to influence to help with diplo victory
; 2101 : 		if (pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isMinorCiv())

	cmp	cl, -1
	je	$LN49@GetArchaeo
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN49@GetArchaeo

; 2102 : 		{
; 2103 : 			if (m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	mov	ecx, DWORD PTR [esi+292]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	push	0
	push	OFFSET $SG225572
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	$LN49@GetArchaeo

; 2104 : 			{
; 2105 : 				if (m_pPlayer->GetDiplomacyAI()->GetMinorCivApproach(pPlot->getOwner()) != MINOR_CIV_APPROACH_CONQUEST)

	movsx	eax, BYTE PTR [ebp+4]
	mov	ecx, DWORD PTR [esi+292]
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	cmp	eax, 3
	je	$LN49@GetArchaeo
$LN51@GetArchaeo:
	pop	ebx
	pop	edi
	pop	esi

; 2106 : 				{
; 2107 : 					eRtnValue = ARCHAEOLOGY_LANDMARK;

	mov	eax, 1
	pop	ebp

; 2160 : }

	add	esp, 28					; 0000001cH
	ret	4
$LN15@GetArchaeo:

; 2108 : 				}
; 2109 : 			}
; 2110 : 		}
; 2111 : 	}
; 2112 : 
; 2113 : 	// Not a tile a city can work?  Go for artifact
; 2114 : 	else if (pPlot->getWorkingCity() == NULL)

	mov	ecx, ebp
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	test	eax, eax

; 2115 : 	{
; 2116 : 		eRtnValue = ARCHAEOLOGY_ARTIFACT_PLAYER1;

	je	$LN6@GetArchaeo

; 2117 : 	}
; 2118 : 
; 2119 : 	// Otherwise go for Landmark if from Ancient Era, or if have enough other Archaeologists and Antiquity sites to fill all slots
; 2120 : 	else if (pPlot->GetArchaeologicalRecord().m_eEra == 0)

	lea	eax, DWORD PTR $T237186[esp+44]
	push	eax
	mov	ecx, ebp
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	cmp	DWORD PTR [eax+4], 0

; 2121 : 	{
; 2122 : 		eRtnValue = ARCHAEOLOGY_LANDMARK;
; 2123 : 	}
; 2124 : 
; 2125 : 	else

	je	SHORT $LN51@GetArchaeo

; 2126 : 	{
; 2127 : 		int iNumArchaeologists = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true) - 1 /* For this one that just completed work */;

	mov	ecx, DWORD PTR [esi+292]
	push	1
	push	1
	push	39					; 00000027H
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2128 : 		int iNumSites = m_pPlayer->GetEconomicAI()->GetVisibleAntiquitySites() - 1 /* For this one then just was completed */;

	mov	ecx, DWORD PTR [esi+292]
	mov	edi, eax
	dec	edi
	mov	DWORD PTR _iNumArchaeologists$225580[esp+44], edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ebx, DWORD PTR [eax+44]

; 2129 : 		int iNumGreatWorkSlots = m_pPlayer->GetCulture()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);

	mov	ecx, DWORD PTR _eArtArtifactSlot$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	dec	ebx
	mov	DWORD PTR _iNumSites$225581[esp+44], ebx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots

; 2130 : 		int iLimitingFactor = min(iNumArchaeologists, iNumSites);

	cmp	ebx, edi
	lea	ecx, DWORD PTR _iNumSites$225581[esp+40]
	jl	SHORT $LN42@GetArchaeo
	lea	ecx, DWORD PTR _iNumArchaeologists$225580[esp+44]
$LN42@GetArchaeo:

; 2131 : 
; 2132 : 		if (iNumGreatWorkSlots <= iLimitingFactor)

	cmp	eax, DWORD PTR [ecx]
	jg	SHORT $LN6@GetArchaeo

; 2133 : 		{
; 2134 : 			if (pPlot->HasWrittenArtifact())

	mov	ecx, ebp
	call	?HasWrittenArtifact@CvPlot@@QBE_NXZ	; CvPlot::HasWrittenArtifact
	movzx	eax, al
	neg	eax
	pop	ebx
	sbb	eax, eax
	pop	edi
	and	eax, 3
	pop	esi
	inc	eax
	pop	ebp

; 2160 : }

	add	esp, 28					; 0000001cH
	ret	4
$LN6@GetArchaeo:

; 2135 : 			{
; 2136 : 				eRtnValue = ARCHAEOLOGY_CULTURE_BOOST;
; 2137 : 			}
; 2138 : 			else
; 2139 : 			{
; 2140 : 				eRtnValue = ARCHAEOLOGY_LANDMARK;
; 2141 : 			}
; 2142 : 		}
; 2143 : 		else
; 2144 : 		{
; 2145 : 			eRtnValue = ARCHAEOLOGY_ARTIFACT_PLAYER1;

	mov	edi, 2
$LN49@GetArchaeo:

; 2146 : 		}
; 2147 : 	}
; 2148 : 
; 2149 : 	// If chose an artifact, would player 2's be better?
; 2150 : 	if (eRtnValue == ARCHAEOLOGY_ARTIFACT_PLAYER1)
; 2151 : 	{
; 2152 : 		if (pPlot->GetArchaeologicalRecord().m_ePlayer2 == m_pPlayer->GetID())

	mov	edx, DWORD PTR [esi+292]
	mov	esi, DWORD PTR [edx+44]
	lea	eax, DWORD PTR $T237187[esp+44]
	push	eax
	mov	ecx, ebp
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	cmp	DWORD PTR [eax+12], esi

; 2153 : 		{
; 2154 : 			// For now have AI player try to collect their own artifacts
; 2155 : 			eRtnValue = ARCHAEOLOGY_ARTIFACT_PLAYER2;

	mov	eax, 3
	je	SHORT $LN50@GetArchaeo

; 2156 : 		}
; 2157 : 	}
; 2158 : 
; 2159 : 	return eRtnValue;

	mov	eax, edi
$LN50@GetArchaeo:
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2160 : }

	add	esp, 28					; 0000001cH
	ret	4
?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z ENDP ; CvPlayerCulture::GetArchaeologyChoice
_TEXT	ENDS
PUBLIC	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceLevel, COMDAT
; _this$ = ecx

; 2685 : {

	push	ebx

; 2686 : 	InfluenceLevelTypes eRtnValue;
; 2687 : 
; 2688 : 	CvPlayer &kOtherPlayer = GET_PLAYER(ePlayer);

	mov	ebx, DWORD PTR _ePlayer$[esp]
	push	esi
	mov	esi, ebx
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 2689 : 	CvTeam &kOtherTeam = GET_TEAM(kOtherPlayer.getTeam());

	mov	eax, DWORD PTR [esi+44]
	mov	edi, ecx
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@GetInfluen@3
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN22@GetInfluen@3
$LN21@GetInfluen@3:
	or	eax, -1
$LN22@GetInfluen@3:

; 2690 : 
; 2691 : 	if (!kOtherTeam.isHasMet(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR [edi+292]
	imul	eax, 2984				; 00000ba8H
	mov	edx, DWORD PTR [edx+44]
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN32@GetInfluen@3
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN33@GetInfluen@3
$LN32@GetInfluen@3:
	or	edx, -1
$LN33@GetInfluen@3:
	push	edx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	jne	SHORT $LN12@GetInfluen@3
	pop	edi
	pop	esi

; 2692 : 	{
; 2693 : 		eRtnValue = NO_INFLUENCE_LEVEL;

	or	eax, -1
	pop	ebx

; 2731 : }

	ret	4
$LN12@GetInfluen@3:

; 2694 : 	}
; 2695 : 	else
; 2696 : 	{
; 2697 : 		int iInfluenceOn = GetInfluenceOn(ePlayer);

	test	ebx, ebx
	jl	SHORT $LN37@GetInfluen@3
	cmp	ebx, 22					; 00000016H
	jge	SHORT $LN37@GetInfluen@3
	mov	edi, DWORD PTR [edi+ebx*4+20]
	jmp	SHORT $LN39@GetInfluen@3
$LN37@GetInfluen@3:
	xor	edi, edi
$LN39@GetInfluen@3:

; 2698 : 		int iLifetimeCulture = kOtherPlayer.GetJONSCultureEverGenerated();

	mov	ecx, esi
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	mov	ecx, eax

; 2699 : 		int iPercent = 0;

	xor	eax, eax

; 2700 : 
; 2701 : 		if (iLifetimeCulture > 0)

	test	ecx, ecx
	jle	SHORT $LN10@GetInfluen@3

; 2702 : 		{
; 2703 : 			iPercent = iInfluenceOn * 100 / iLifetimeCulture;

	mov	eax, edi
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
$LN10@GetInfluen@3:

; 2704 : 		}
; 2705 : 
; 2706 : 		eRtnValue = INFLUENCE_LEVEL_UNKNOWN;

	xor	ecx, ecx

; 2707 : 
; 2708 : 		if (iPercent >= GC.getCULTURE_LEVEL_DOMINANT())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8256
	jl	SHORT $LN9@GetInfluen@3
	pop	edi
	pop	esi

; 2709 : 		{
; 2710 : 			eRtnValue = INFLUENCE_LEVEL_DOMINANT;

	lea	eax, DWORD PTR [ecx+5]
	pop	ebx

; 2731 : }

	ret	4
$LN9@GetInfluen@3:

; 2711 : 		}
; 2712 : 		else if (iPercent >= GC.getCULTURE_LEVEL_INFLUENTIAL())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8252
	jl	SHORT $LN7@GetInfluen@3
	pop	edi
	pop	esi

; 2713 : 		{
; 2714 : 			eRtnValue = INFLUENCE_LEVEL_INFLUENTIAL;

	mov	eax, 4
	pop	ebx

; 2731 : }

	ret	4
$LN7@GetInfluen@3:

; 2715 : 		}
; 2716 : 		else if (iPercent >= GC.getCULTURE_LEVEL_POPULAR())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8248
	jl	SHORT $LN5@GetInfluen@3
	pop	edi
	pop	esi

; 2717 : 		{
; 2718 : 			eRtnValue = INFLUENCE_LEVEL_POPULAR;

	mov	eax, 3
	pop	ebx

; 2731 : }

	ret	4
$LN5@GetInfluen@3:

; 2719 : 		}
; 2720 : 		else if (iPercent >= GC.getCULTURE_LEVEL_FAMILIAR())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8244
	jl	SHORT $LN3@GetInfluen@3
	pop	edi
	pop	esi

; 2721 : 		{
; 2722 : 			eRtnValue = INFLUENCE_LEVEL_FAMILIAR;

	mov	eax, 2
	pop	ebx

; 2731 : }

	ret	4
$LN3@GetInfluen@3:

; 2723 : 		}
; 2724 : 		else if (iPercent >= GC.getCULTURE_LEVEL_EXOTIC())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8240

; 2725 : 		{
; 2726 : 			eRtnValue = INFLUENCE_LEVEL_EXOTIC;

	mov	eax, 1
	jge	SHORT $LN1@GetInfluen@3

; 2727 : 		}
; 2728 : 	}
; 2729 : 
; 2730 : 	return eRtnValue;

	mov	eax, ecx
$LN1@GetInfluen@3:
	pop	edi
	pop	esi
	pop	ebx

; 2731 : }

	ret	4
?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceLevel
_TEXT	ENDS
PUBLIC	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
_iRtnValue$ = -4					; size = 4
?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ PROC	; CvPlayerCulture::GetNumCivsInfluentialOn, COMDAT
; _this$ = ecx

; 2822 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2823 : 	int iRtnValue = 0;

	xor	edi, edi
	mov	ebp, ecx
	mov	DWORD PTR _iRtnValue$[esp+20], edi

; 2824 : 
; 2825 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	ebx, ebx
	npad	1
$LL5@GetNumCivs@2:

; 2826 : 	{
; 2827 : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
; 2828 : 		if (iLoopPlayer != m_pPlayer->GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR [ebp+292]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	esi, DWORD PTR [edi+eax]
	cmp	ebx, DWORD PTR [ecx+44]
	je	SHORT $LN4@GetNumCivs@2
	cmp	BYTE PTR [esi+2256], 0
	je	SHORT $LN4@GetNumCivs@2
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN4@GetNumCivs@2

; 2829 : 		{
; 2830 : 			if (GetInfluenceLevel(kPlayer.GetID()) >= INFLUENCE_LEVEL_INFLUENTIAL)

	mov	esi, DWORD PTR [esi+44]
	push	esi
	mov	ecx, ebp
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	cmp	eax, 4
	jl	SHORT $LN4@GetNumCivs@2

; 2831 : 			{
; 2832 : 				iRtnValue++;

	inc	DWORD PTR _iRtnValue$[esp+20]
$LN4@GetNumCivs@2:

; 2824 : 
; 2825 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL5@GetNumCivs@2

; 2833 : 			}
; 2834 : 		}
; 2835 : 	}
; 2836 : 
; 2837 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2838 : }

	pop	ecx
	ret	0
?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ENDP	; CvPlayerCulture::GetNumCivsInfluentialOn
_TEXT	ENDS
PUBLIC	?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsToBeInfluentialOn
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetNumCivsToBeInfluentialOn, COMDAT
; _this$ = ecx

; 2842 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 2843 : 	int iRtnValue = 0;

	xor	ebp, ebp

; 2844 : 
; 2845 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	4
$LL4@GetNumCivs@3:

; 2846 : 	{
; 2847 : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
; 2848 : 		if (iLoopPlayer != m_pPlayer->GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())

	mov	edx, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	cmp	edi, DWORD PTR [edx+44]
	je	SHORT $LN3@GetNumCivs@3
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN3@GetNumCivs@3
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN3@GetNumCivs@3

; 2849 : 		{
; 2850 : 			iRtnValue++;

	inc	ebp
$LN3@GetNumCivs@3:

; 2844 : 
; 2845 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL4@GetNumCivs@3
	pop	edi
	pop	esi

; 2851 : 		}
; 2852 : 	}
; 2853 : 
; 2854 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2855 : }

	ret	0
?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetNumCivsToBeInfluentialOn
_TEXT	ENDS
PUBLIC	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z ; CvPlayerCulture::GetCivLowestInfluence
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv371 = -12						; size = 4
_iLowestPercent$ = -8					; size = 4
_eRtnValue$ = -4					; size = 4
_bCheckOpenBorders$ = 8					; size = 1
?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z PROC ; CvPlayerCulture::GetCivLowestInfluence, COMDAT
; _this$ = ecx

; 2859 : {

	sub	esp, 16					; 00000010H

; 2861 : 	int iLowestPercent = GC.getCULTURE_LEVEL_INFLUENTIAL();   // Don't want to target civs if already influential

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8252
	push	ebx
	push	ebp
	push	esi
	push	edi
	lea	edx, DWORD PTR [ecx+20]

; 2862 : 
; 2863 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	edi, edi
	mov	DWORD PTR _this$[esp+32], ecx
	mov	DWORD PTR _eRtnValue$[esp+32], -1
	mov	DWORD PTR _iLowestPercent$[esp+32], eax
	xor	ebx, ebx
	mov	DWORD PTR tv371[esp+32], edx
	jmp	SHORT $LN8@GetCivLowe
	npad	7
$LL59@GetCivLowe:

; 2860 : 	PlayerTypes eRtnValue = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[esp+32]
$LN8@GetCivLowe:

; 2864 : 	{
; 2865 : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ebp, DWORD PTR [ebx+eax]

; 2866 : 		CvTeam &kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR [ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@GetCivLowe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN20@GetCivLowe
$LN19@GetCivLowe:
	or	eax, -1
$LN20@GetCivLowe:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, eax

; 2867 : 		if (iLoopPlayer != m_pPlayer->GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kTeam.isAtWar(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ecx+292]
	cmp	edi, DWORD PTR [eax+44]
	je	$LN7@GetCivLowe
	cmp	BYTE PTR [ebp+2256], 0
	je	$LN7@GetCivLowe
	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN7@GetCivLowe
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	edx, DWORD PTR [ecx+292]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN38@GetCivLowe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN39@GetCivLowe
$LN38@GetCivLowe:
	or	eax, -1
$LN39@GetCivLowe:
	push	eax
	mov	ecx, esi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN7@GetCivLowe

; 2868 : 		{
; 2869 : 			if (!bCheckOpenBorders || kTeam.IsAllowsOpenBordersToTeam(m_pPlayer->getTeam()))

	cmp	BYTE PTR _bCheckOpenBorders$[esp+28], al
	je	SHORT $LN3@GetCivLowe
	mov	eax, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN47@GetCivLowe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN48@GetCivLowe
$LN47@GetCivLowe:
	or	eax, -1
$LN48@GetCivLowe:
	push	eax
	mov	ecx, esi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN7@GetCivLowe
$LN3@GetCivLowe:

; 2870 : 			{
; 2871 : 				int iInfluenceOn = GetInfluenceOn((PlayerTypes)iLoopPlayer);

	test	edi, edi
	jl	SHORT $LN52@GetCivLowe
	cmp	edi, 22					; 00000016H
	jge	SHORT $LN52@GetCivLowe
	mov	edx, DWORD PTR tv371[esp+32]
	mov	esi, DWORD PTR [edx]
	jmp	SHORT $LN54@GetCivLowe
$LN52@GetCivLowe:
	xor	esi, esi
$LN54@GetCivLowe:

; 2872 : 				int iLifetimeCulture = kPlayer.GetJONSCultureEverGenerated();

	mov	ecx, ebp
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	mov	ecx, eax

; 2873 : 				int iPercent = 0;

	xor	eax, eax

; 2874 : 
; 2875 : 				if (iLifetimeCulture > 0)

	test	ecx, ecx
	jle	SHORT $LN2@GetCivLowe

; 2876 : 				{
; 2877 : 					iPercent = iInfluenceOn * 100 / iLifetimeCulture;

	mov	eax, esi
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
$LN2@GetCivLowe:

; 2878 : 				}
; 2879 : 
; 2880 : 				if (iPercent < iLowestPercent)

	cmp	eax, DWORD PTR _iLowestPercent$[esp+32]
	jge	SHORT $LN7@GetCivLowe

; 2881 : 				{
; 2882 : 					iLowestPercent = iPercent;

	mov	DWORD PTR _iLowestPercent$[esp+32], eax

; 2883 : 					eRtnValue = (PlayerTypes)iLoopPlayer;

	mov	DWORD PTR _eRtnValue$[esp+32], edi
$LN7@GetCivLowe:
	add	DWORD PTR tv371[esp+32], 4
	add	ebx, 63236				; 0000f704H
	inc	edi
	cmp	ebx, 1391192				; 00153a58H
	jl	$LL59@GetCivLowe

; 2884 : 				}
; 2885 : 			}
; 2886 : 		}
; 2887 : 	}
; 2888 : 
; 2889 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2890 : }

	add	esp, 16					; 00000010H
	ret	4
?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z ENDP ; CvPlayerCulture::GetCivLowestInfluence
_TEXT	ENDS
PUBLIC	?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus, COMDAT
; _this$ = ecx

; 2897 : 	int iRtnValue = 0;
; 2898 : 
; 2899 : 	if (ePlayer < MAX_MAJOR_CIVS)

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	esi
	xor	esi, esi
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN5@GetInfluen@4

; 2900 : 	{
; 2901 : 		InfluenceLevelTypes eLevel = GetInfluenceLevel(ePlayer);

	push	eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 2902 : 		switch (eLevel)

	sub	eax, 2
	cmp	eax, 3
	ja	SHORT $LN5@GetInfluen@4
	jmp	DWORD PTR $LN10@GetInfluen@4[eax*4]
$LN4@GetInfluen@4:

; 2903 : 		{
; 2904 : 		case INFLUENCE_LEVEL_FAMILIAR:
; 2905 : 			iRtnValue = 1;

	mov	esi, 1

; 2915 : 			break;
; 2916 : 		}
; 2917 : 	}
; 2918 : 
; 2919 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2920 : }

	ret	4
$LN3@GetInfluen@4:

; 2906 : 			break;
; 2907 : 		case INFLUENCE_LEVEL_POPULAR:
; 2908 : 			iRtnValue = 2;

	mov	esi, 2

; 2915 : 			break;
; 2916 : 		}
; 2917 : 	}
; 2918 : 
; 2919 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2920 : }

	ret	4
$LN2@GetInfluen@4:

; 2909 : 			break;
; 2910 : 		case INFLUENCE_LEVEL_INFLUENTIAL:
; 2911 : 			iRtnValue = 3;

	mov	esi, 3

; 2915 : 			break;
; 2916 : 		}
; 2917 : 	}
; 2918 : 
; 2919 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2920 : }

	ret	4
$LN1@GetInfluen@4:

; 2912 : 			break;
; 2913 : 		case INFLUENCE_LEVEL_DOMINANT:
; 2914 : 			iRtnValue = 4;

	mov	esi, 4
$LN5@GetInfluen@4:

; 2915 : 			break;
; 2916 : 		}
; 2917 : 	}
; 2918 : 
; 2919 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2920 : }

	ret	4
	npad	3
$LN10@GetInfluen@4:
	DD	$LN4@GetInfluen@4
	DD	$LN3@GetInfluen@4
	DD	$LN2@GetInfluen@4
	DD	$LN1@GetInfluen@4
?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus
_TEXT	ENDS
PUBLIC	?GetInfluenceCityConquestReduction@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceCityConquestReduction
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceCityConquestReduction@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetInfluenceCityConquestReduction@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceCityConquestReduction, COMDAT
; _this$ = ecx

; 2925 : 	int iRtnValue = 0;
; 2926 : 
; 2927 : 	if (ePlayer < MAX_MAJOR_CIVS)

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	esi
	xor	esi, esi
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN5@GetInfluen@5

; 2928 : 	{
; 2929 : 		InfluenceLevelTypes eLevel = GetInfluenceLevel(ePlayer);

	push	eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 2930 : 		switch (eLevel)

	sub	eax, 2
	cmp	eax, 3
	ja	SHORT $LN5@GetInfluen@5
	jmp	DWORD PTR $LN10@GetInfluen@5[eax*4]
$LN4@GetInfluen@5:

; 2931 : 		{
; 2932 : 		case INFLUENCE_LEVEL_FAMILIAR:
; 2933 : 			iRtnValue = 25;

	mov	esi, 25					; 00000019H

; 2943 : 			break;
; 2944 : 		}
; 2945 : 	}
; 2946 : 	
; 2947 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2948 : }

	ret	4
$LN3@GetInfluen@5:

; 2934 : 			break;
; 2935 : 		case INFLUENCE_LEVEL_POPULAR:
; 2936 : 			iRtnValue = 50;

	mov	esi, 50					; 00000032H

; 2943 : 			break;
; 2944 : 		}
; 2945 : 	}
; 2946 : 	
; 2947 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2948 : }

	ret	4
$LN2@GetInfluen@5:

; 2937 : 			break;
; 2938 : 		case INFLUENCE_LEVEL_INFLUENTIAL:
; 2939 : 			iRtnValue = 75;

	mov	esi, 75					; 0000004bH

; 2943 : 			break;
; 2944 : 		}
; 2945 : 	}
; 2946 : 	
; 2947 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2948 : }

	ret	4
$LN1@GetInfluen@5:

; 2940 : 			break;
; 2941 : 		case INFLUENCE_LEVEL_DOMINANT:
; 2942 : 			iRtnValue = 100;

	mov	esi, 100				; 00000064H
$LN5@GetInfluen@5:

; 2943 : 			break;
; 2944 : 		}
; 2945 : 	}
; 2946 : 	
; 2947 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 2948 : }

	ret	4
	npad	3
$LN10@GetInfluen@5:
	DD	$LN4@GetInfluen@5
	DD	$LN3@GetInfluen@5
	DD	$LN2@GetInfluen@5
	DD	$LN1@GetInfluen@5
?GetInfluenceCityConquestReduction@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceCityConquestReduction
_TEXT	ENDS
PUBLIC	?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceSurveillanceTime
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceSurveillanceTime, COMDAT
; _this$ = ecx

; 2953 : 	int iRtnValue = 3;
; 2954 : 
; 2955 : 	if (ePlayer < MAX_MAJOR_CIVS)

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 22					; 00000016H
	push	ebx
	push	edi
	mov	edi, ecx
	mov	ebx, 3
	jge	SHORT $LN6@GetInfluen@6

; 2956 : 	{
; 2957 : 		InfluenceLevelTypes eLevel = GetInfluenceLevel(ePlayer);

	push	eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 2958 : 
; 2959 : 		if (eLevel >= INFLUENCE_LEVEL_FAMILIAR)

	cmp	eax, 2
	jl	SHORT $LN14@GetInfluen@6
	pop	edi

; 2960 : 		{
; 2961 : 			iRtnValue = 1;

	lea	eax, DWORD PTR [ebx-2]
	pop	ebx

; 2983 : }

	ret	4
$LN6@GetInfluen@6:

; 2962 : 		}
; 2963 : 	}
; 2964 : 	else
; 2965 : 	{
; 2966 : 		// Have a major power ally?
; 2967 : 		CvPlayer &kCityState = GET_PLAYER(ePlayer);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, eax

; 2968 : 		if (kCityState.isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN13@GetInfluen@6

; 2969 : 		{
; 2970 : 			PlayerTypes eAlly = kCityState.GetMinorCivAI()->GetAlly();

	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 2971 : 			if (eAlly != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN13@GetInfluen@6

; 2972 : 			{
; 2973 : 				InfluenceLevelTypes eLevel = GetInfluenceLevel(eAlly);

	push	eax
	mov	ecx, edi
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 2974 : 				if (eLevel >= INFLUENCE_LEVEL_FAMILIAR)

	cmp	eax, 2
	jl	SHORT $LN13@GetInfluen@6
	pop	esi
	pop	edi

; 2975 : 				{
; 2976 : 					iRtnValue = 1;

	mov	eax, 1
	pop	ebx

; 2983 : }

	ret	4
$LN13@GetInfluen@6:
	pop	esi
	pop	edi

; 2977 : 				}
; 2978 : 			}
; 2979 : 		}
; 2980 : 	}
; 2981 : 
; 2982 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 2983 : }

	ret	4
$LN14@GetInfluen@6:
	pop	edi

; 2977 : 				}
; 2978 : 			}
; 2979 : 		}
; 2980 : 	}
; 2981 : 
; 2982 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 2983 : }

	ret	4
?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceSurveillanceTime
_TEXT	ENDS
PUBLIC	?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eCityStatePlayer$ = 8					; size = 4
?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus, COMDAT
; _this$ = ecx

; 2987 : {

	push	ebx
	push	esi

; 2988 : 	int iRtnValue = 0;
; 2989 : 
; 2990 : 	// Have a major power ally?
; 2991 : 	CvPlayer &kCityState = GET_PLAYER(eCityStatePlayer);

	mov	esi, DWORD PTR _eCityStatePlayer$[esp+4]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, ecx

; 2992 : 	if (kCityState.isMinorCiv())

	mov	ecx, esi
	xor	ebx, ebx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN14@GetInfluen@7

; 2993 : 	{
; 2994 : 		PlayerTypes eAlly = kCityState.GetMinorCivAI()->GetAlly();

	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 2995 : 		if (eAlly != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN14@GetInfluen@7

; 2996 : 		{
; 2997 : 			InfluenceLevelTypes eLevel = GetInfluenceLevel(eAlly);

	push	eax
	mov	ecx, edi
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 2998 : 			switch (eLevel)

	sub	eax, 3
	je	SHORT $LN2@GetInfluen@7
	sub	eax, 1
	je	SHORT $LN2@GetInfluen@7
	sub	eax, 1
	jne	SHORT $LN14@GetInfluen@7
	pop	edi
	pop	esi

; 3005 : 				break;
; 3006 : 			case INFLUENCE_LEVEL_DOMINANT:
; 3007 : 				iRtnValue = 2;

	lea	eax, DWORD PTR [ebx+2]
	pop	ebx

; 3014 : }

	ret	4
$LN2@GetInfluen@7:
	pop	edi
	pop	esi

; 2999 : 			{
; 3000 : 			case INFLUENCE_LEVEL_POPULAR:
; 3001 : 				iRtnValue = 1;
; 3002 : 				break;
; 3003 : 			case INFLUENCE_LEVEL_INFLUENTIAL:
; 3004 : 				iRtnValue = 1;

	mov	eax, 1
	pop	ebx

; 3014 : }

	ret	4
$LN14@GetInfluen@7:
	pop	edi
	pop	esi

; 3008 : 				break;
; 3009 : 			}
; 3010 : 		}
; 3011 : 	}
; 3012 : 
; 3013 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 3014 : }

	ret	4
?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
_TEXT	ENDS
PUBLIC	?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceMajorCivSpyRankBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceMajorCivSpyRankBonus, COMDAT
; _this$ = ecx

; 3019 : 	int iRtnValue = 0;
; 3020 : 
; 3021 : 	InfluenceLevelTypes eLevel = GetInfluenceLevel(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	esi
	push	eax
	xor	esi, esi
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 3022 : 	switch (eLevel)

	sub	eax, 4
	je	SHORT $LN2@GetInfluen@8
	sub	eax, 1
	jne	SHORT $LN7@GetInfluen@8

; 3026 : 		break;
; 3027 : 	case INFLUENCE_LEVEL_DOMINANT:
; 3028 : 		iRtnValue = 2;

	lea	eax, DWORD PTR [esi+2]
	pop	esi

; 3033 : }

	ret	4
$LN2@GetInfluen@8:

; 3023 : 	{
; 3024 : 	case INFLUENCE_LEVEL_INFLUENTIAL:
; 3025 : 		iRtnValue = 1;

	mov	eax, 1
	pop	esi

; 3033 : }

	ret	4
$LN7@GetInfluen@8:

; 3029 : 		break;
; 3030 : 	}
; 3031 : 
; 3032 : 	return iRtnValue;

	mov	eax, esi
	pop	esi

; 3033 : }

	ret	4
?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceMajorCivSpyRankBonus
_TEXT	ENDS
PUBLIC	?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceSpyRankTooltip
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T237545 = -44						; size = 4
$T237541 = -40						; size = 28
$T237540 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szName$ = 12						; size = 28
_szRank$ = 40						; size = 28
_ePlayer$ = 68						; size = 4
?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluenceSpyRankTooltip, COMDAT
; _this$ = ecx

; 3037 : {

	push	-1
	push	__ehhandler$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T237545[esp+56], 0

; 3038 : 	CvString szRtnValue = GetLocalizedText("TXT_KEY_EO_SPY_RANK_TT", szName, szRank);

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+52]
	lea	eax, DWORD PTR _szRank$[esp+52]
	push	eax
	lea	ecx, DWORD PTR _szName$[esp+56]
	push	ecx
	push	OFFSET $SG226115
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+80], 2
	call	??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z ; GetLocalizedText<CvString,CvString>
	add	esp, 16					; 00000010H

; 3061 : 			}
; 3062 : 		}
; 3063 : 	}
; 3064 : 
; 3065 : 	return szRtnValue;

	mov	esi, DWORD PTR _ePlayer$[esp+52]
	mov	DWORD PTR $T237545[esp+56], 1
	cmp	esi, -1
	je	$LN1@GetInfluen@9
	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	push	esi
	mov	ecx, edi
	test	al, al
	je	SHORT $LN4@GetInfluen@9
	call	?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
	test	eax, eax
	jle	SHORT $LN1@GetInfluen@9
	push	eax
	lea	edx, DWORD PTR $T237540[esp+60]
	push	OFFSET $SG226127
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+64], 3
	jmp	SHORT $LN36@GetInfluen@9
$LN4@GetInfluen@9:

; 3039 : 
; 3040 : 	if (ePlayer != NO_PLAYER)
; 3041 : 	{
; 3042 : 		CvPlayer &kOtherPlayer = GET_PLAYER(ePlayer);
; 3043 : 
; 3044 : 		int iRankBonus = 0;
; 3045 : 		if (kOtherPlayer.isMinorCiv())
; 3046 : 		{
; 3047 : 			iRankBonus = GetInfluenceCityStateSpyRankBonus(ePlayer);
; 3048 : 
; 3049 : 			if (iRankBonus > 0)
; 3050 : 			{
; 3051 : 				szRtnValue += GetLocalizedText("TXT_KEY_SPY_BONUS_CITY_STATE", iRankBonus);
; 3052 : 			}
; 3053 : 		}
; 3054 : 		else
; 3055 : 		{
; 3056 : 			iRankBonus = GetInfluenceMajorCivSpyRankBonus(ePlayer);

	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	sub	eax, 4
	je	SHORT $LN20@GetInfluen@9
	sub	eax, 1
	jne	SHORT $LN1@GetInfluen@9
	mov	eax, 2
	jmp	SHORT $LN34@GetInfluen@9
$LN20@GetInfluen@9:
	mov	eax, 1
$LN34@GetInfluen@9:

; 3057 : 
; 3058 : 			if (iRankBonus > 0)
; 3059 : 			{
; 3060 : 				szRtnValue += GetLocalizedText("TXT_KEY_SPY_BONUS_MAJOR_CIV", iRankBonus);

	push	eax
	lea	eax, DWORD PTR $T237541[esp+60]
	push	OFFSET $SG226131
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+64], 4
$LN36@GetInfluen@9:
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237541[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@GetInfluen@9:

; 3061 : 			}
; 3062 : 		}
; 3063 : 	}
; 3064 : 
; 3065 : 	return szRtnValue;

	lea	ecx, DWORD PTR _szName$[esp+52]
	mov	BYTE PTR __$EHRec$[esp+64], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szRank$[esp+52]
	mov	BYTE PTR __$EHRec$[esp+64], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _szRank$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _szName$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$2:
	mov	eax, DWORD PTR $T237545[ebp]
	and	eax, 1
	je	$LN11@GetInfluen@9
	and	DWORD PTR $T237545[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN11@GetInfluen@9:
	ret	0
__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T237540[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR $T237541[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetInfluenceSpyRankTooltip@CvPlayerCulture@@QAE?AVCvString@@V2@0W4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluenceSpyRankTooltip
PUBLIC	?GetTourismModifierWith@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetTourismModifierWith
EXTRN	?HasReligionInMostCities@CvPlayerReligions@@QBE_NW4ReligionTypes@@@Z:PROC ; CvPlayerReligions::HasReligionInMostCities
EXTRN	?GetReligionInMostCities@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ:PROC ; CvPlayerReligions::GetReligionInMostCities
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?isGoldenAge@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isGoldenAge
EXTRN	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::IsPlayerValid
EXTRN	?GetMilitaryMight@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetMilitaryMight
EXTRN	?GetExcessHappiness@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetExcessHappiness
EXTRN	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvPlayerEspionage::IsMyDiplomatVisitingThem
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
EXTRN	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z:PROC ; CvGameTrade::IsPlayerConnectedToPlayer
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
EXTRN	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ:PROC ; CvPlayerPolicies::GetLateGamePolicyTree
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismModifierWith@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iMultiplier$ = -24					; size = 4
_kPlayer$ = -20						; size = 4
_eMyIdeology$ = -16					; size = 4
_eTheirIdeology$ = -12					; size = 4
_myStrength$226161 = -8					; size = 4
_iCommonFoeMod$ = -4					; size = 4
_rank$226159 = 8					; size = 4
_iLessHappyMod$ = 8					; size = 4
_ePlayer$ = 8						; size = 4
?GetTourismModifierWith@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetTourismModifierWith, COMDAT
; _this$ = ecx

; 3089 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 3090 : 	int iMultiplier = 0;
; 3091 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	edi, DWORD PTR _ePlayer$[esp+32]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx

; 3092 : 	CvTeam &kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR [edi+44]
	mov	esi, ecx
	mov	DWORD PTR _iMultiplier$[esp+36], ebx
	mov	DWORD PTR _kPlayer$[esp+36], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN26@GetTourism
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN27@GetTourism
$LN26@GetTourism:
	or	eax, -1
$LN27@GetTourism:

; 3093 : 	PolicyBranchTypes eMyIdeology = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, DWORD PTR [esi+292]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	mov	ebp, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 3094 : 	PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, edi
	mov	DWORD PTR _eMyIdeology$[esp+40], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eTheirIdeology$[esp+40], eax

; 3095 : 
; 3096 : 	// Open borders with this player
; 3097 : 	if (kTeam.IsAllowsOpenBordersToTeam(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [esi+292]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN37@GetTourism
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN38@GetTourism
$LN37@GetTourism:
	or	eax, -1
$LN38@GetTourism:
	push	eax
	mov	ecx, ebp
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN17@GetTourism

; 3098 : 	{
; 3099 : 		iMultiplier += GetTourismModifierOpenBorders();

	mov	ecx, DWORD PTR [esi+292]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	57					; 00000039H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebx
	mov	DWORD PTR _iMultiplier$[esp+40], eax
	mov	ebx, eax
$LN17@GetTourism:

; 3100 : 	}
; 3101 : 
; 3102 : 	// Trade route to one of this player's cities from here
; 3103 : 	if (GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), ePlayer))

	mov	eax, DWORD PTR [esi+292]
	mov	ecx, DWORD PTR _ePlayer$[esp+36]
	mov	eax, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	je	SHORT $LN16@GetTourism

; 3104 : 	{
; 3105 : 		iMultiplier += GetTourismModifierTradeRoute();

	mov	ecx, DWORD PTR [esi+292]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	56					; 00000038H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebp
	add	ebx, eax
	mov	DWORD PTR _iMultiplier$[esp+40], ebx
$LN16@GetTourism:

; 3106 : 	}
; 3107 : 
; 3108 : 	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology != eTheirIdeology)

	mov	ecx, DWORD PTR _eMyIdeology$[esp+40]
	cmp	ecx, -1
	je	SHORT $LN81@GetTourism
	mov	eax, DWORD PTR _eTheirIdeology$[esp+40]
	cmp	eax, -1
	je	SHORT $LN81@GetTourism
	cmp	ecx, eax
	je	SHORT $LN81@GetTourism

; 3109 : 	{
; 3110 : 		iMultiplier += GC.getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8228

; 3111 : 
; 3112 : 		if (m_pPlayer->GetEspionage()->IsMyDiplomatVisitingThem(ePlayer))

	mov	edx, DWORD PTR _ePlayer$[esp+36]
	mov	ecx, DWORD PTR [esi+292]
	push	0
	push	edx
	mov	DWORD PTR _iMultiplier$[esp+48], ebx
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
	test	al, al
	je	SHORT $LN81@GetTourism

; 3113 : 		{
; 3114 : 			iMultiplier += GC.getTOURISM_MODIFIER_DIPLOMAT();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8232
	mov	DWORD PTR _iMultiplier$[esp+40], ebx
$LN81@GetTourism:

; 3115 : 		}
; 3116 : 	}
; 3117 : 
; 3118 : 	int iLessHappyMod = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_LESS_HAPPY);

	mov	ecx, DWORD PTR [esi+292]
	push	29					; 0000001dH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	DWORD PTR _iLessHappyMod$[esp+36], eax

; 3119 : 	if (iLessHappyMod > 0)

	test	eax, eax
	jle	SHORT $LN80@GetTourism

; 3120 : 	{
; 3121 : 		if (m_pPlayer->GetExcessHappiness() > kPlayer.GetExcessHappiness())

	mov	ecx, edi
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	ecx, DWORD PTR [esi+292]
	mov	ebp, eax
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	cmp	eax, ebp
	jle	SHORT $LN80@GetTourism

; 3122 : 		{
; 3123 : 			iMultiplier += iLessHappyMod;

	add	ebx, DWORD PTR _iLessHappyMod$[esp+36]
	mov	DWORD PTR _iMultiplier$[esp+40], ebx
$LN80@GetTourism:

; 3124 : 		}
; 3125 : 	}
; 3126 : 	int iCommonFoeMod = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_COMMON_FOE);

	mov	ecx, DWORD PTR [esi+292]
	push	28					; 0000001cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 3127 : 	if (iCommonFoeMod > 0)

	xor	ebp, ebp
	cmp	eax, ebp
	mov	DWORD PTR _iCommonFoeMod$[esp+40], eax
	jle	SHORT $LN5@GetTourism

; 3128 : 	{
; 3129 : 		// NQMP GJS - new Cult of Personality BEGIN
; 3130 : 		int rank = 0;
; 3131 : 		int totalEnemies = 0;
; 3132 : 		int myStrength = m_pPlayer->GetMilitaryMight();

	mov	ecx, DWORD PTR [esi+292]
	mov	DWORD PTR _rank$226159[esp+36], ebp
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight

; 3133 : 
; 3134 : 		PlayerTypes eLoopPlayer;
; 3135 : 		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebx, ebx
	mov	DWORD PTR _myStrength$226161[esp+40], eax
	xor	edi, edi
	npad	2
$LL10@GetTourism:

; 3136 : 		{
; 3137 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3138 : 			if (eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [esi+292]
	cmp	ebx, DWORD PTR [ecx+44]
	je	SHORT $LN9@GetTourism
	push	0
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN9@GetTourism

; 3139 : 			{
; 3140 : 				totalEnemies++;
; 3141 : 				if (GET_PLAYER(eLoopPlayer).GetMilitaryMight() > myStrength)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	inc	ebp
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	cmp	eax, DWORD PTR _myStrength$226161[esp+40]
	jle	SHORT $LN9@GetTourism

; 3142 : 				{
; 3143 : 					rank++;

	inc	DWORD PTR _rank$226159[esp+36]
$LN9@GetTourism:

; 3133 : 
; 3134 : 		PlayerTypes eLoopPlayer;
; 3135 : 		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL10@GetTourism

; 3144 : 				}
; 3145 : 			}
; 3146 : 		}
; 3147 : 
; 3148 : 		// divide the tourism boost into chunks, so that lowest player gets 0%, highest gets 100%, and the rest are evenly distributed in between
; 3149 : 		// so for example in a 6 player game, based on the player being 6th/5th/4th/3rd/2nd/1st in military strength they get 0%/20%/40%/60%/80%/100% boost
; 3150 : 		if (totalEnemies > 0)
; 3151 : 		{
; 3152 : 			iCommonFoeMod = iCommonFoeMod * (totalEnemies - rank) / totalEnemies;
; 3153 : 			iMultiplier += iCommonFoeMod;

	mov	edi, DWORD PTR _kPlayer$[esp+40]
	test	ebp, ebp
	jle	SHORT $LN79@GetTourism
	mov	eax, ebp
	sub	eax, DWORD PTR _rank$226159[esp+36]
	imul	eax, DWORD PTR _iCommonFoeMod$[esp+40]
	cdq
	idiv	ebp
	add	DWORD PTR _iMultiplier$[esp+40], eax
$LN79@GetTourism:
	mov	ebx, DWORD PTR _iMultiplier$[esp+40]
$LN5@GetTourism:

; 3154 : 		}
; 3155 : 		/*
; 3156 : 		// old code
; 3157 : 		PlayerTypes eLoopPlayer;
; 3158 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 3159 : 		{
; 3160 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3161 : 
; 3162 : 			if (eLoopPlayer != ePlayer && eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
; 3163 : 			{
; 3164 : 				// Are they at war with me too?
; 3165 : 				if (GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && GET_TEAM(kPlayer.getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
; 3166 : 				{
; 3167 : 					iMultiplier += iCommonFoeMod;
; 3168 : 				}
; 3169 : 			}
; 3170 : 		}
; 3171 : 		*/
; 3172 : 		// NQMP GJS - new Cult of Personality END
; 3173 : 	}
; 3174 : 	int iSharedIdeologyMod = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_SHARED_IDEOLOGY);

	mov	ecx, DWORD PTR [esi+292]
	push	30					; 0000001eH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	pop	ebp

; 3175 : 	if (iSharedIdeologyMod > 0)

	test	eax, eax
	jle	SHORT $LN83@GetTourism

; 3176 : 	{
; 3177 : 		if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)

	mov	edx, DWORD PTR _eMyIdeology$[esp+36]
	cmp	edx, -1
	je	SHORT $LN83@GetTourism
	mov	ecx, DWORD PTR _eTheirIdeology$[esp+36]
	cmp	ecx, -1
	je	SHORT $LN83@GetTourism
	cmp	edx, ecx
	jne	SHORT $LN83@GetTourism

; 3178 : 		{
; 3179 : 			iMultiplier += iSharedIdeologyMod;

	add	ebx, eax
$LN83@GetTourism:

; 3180 : 		}
; 3181 : 	}
; 3182 : 
; 3183 : 	if (m_pPlayer->isGoldenAge() && m_pPlayer->GetPlayerTraits()->GetGoldenAgeTourismModifier())

	mov	ecx, DWORD PTR [esi+292]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN2@GetTourism
	mov	ecx, DWORD PTR [esi+292]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+184], 0
	je	SHORT $LN2@GetTourism

; 3184 : 	{
; 3185 : 		iMultiplier += m_pPlayer->GetPlayerTraits()->GetGoldenAgeTourismModifier();

	mov	ecx, DWORD PTR [esi+292]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	ebx, DWORD PTR [eax+184]
$LN2@GetTourism:

; 3186 : 	}
; 3187 : 
; 3188 : 	ReligionTypes ePlayerReligion = m_pPlayer->GetReligions()->GetReligionInMostCities();

	mov	ecx, DWORD PTR [esi+292]
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionInMostCities@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionInMostCities

; 3189 : 	if (ePlayerReligion != NO_RELIGION && kPlayer.GetReligions()->HasReligionInMostCities(ePlayerReligion))

	cmp	eax, -1
	je	SHORT $LN77@GetTourism
	push	eax
	mov	ecx, edi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasReligionInMostCities@CvPlayerReligions@@QBE_NW4ReligionTypes@@@Z ; CvPlayerReligions::HasReligionInMostCities
	test	al, al
	je	SHORT $LN77@GetTourism

; 3190 : 	{
; 3191 : 		iMultiplier += GetTourismModifierSharedReligion();

	mov	ecx, DWORD PTR [esi+292]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	55					; 00000037H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, edi
	add	ebx, eax
$LN77@GetTourism:
	pop	edi
	pop	esi

; 3192 : 	}
; 3193 : 
; 3194 : 	return iMultiplier;

	mov	eax, ebx
	pop	ebx

; 3195 : }

	add	esp, 24					; 00000018H
	ret	4
?GetTourismModifierWith@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetTourismModifierWith
_TEXT	ENDS
PUBLIC	?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetTourismModifierWithTooltip
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z DD 019930522H
	DD	028H
	DD	FLAT:__unwindtable$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$20
	DD	014H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$22
	DD	016H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$23
	DD	017H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$25
	DD	019H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$26
	DD	01aH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$27
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$28
	DD	01cH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$29
	DD	01dH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$30
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$31
	DD	01fH
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$32
	DD	020H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$33
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$34
	DD	022H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$35
	DD	023H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$36
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$37
	DD	025H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$38
	DD	026H
	DD	FLAT:__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$39
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T237914 = -148						; size = 4
$T237900 = -148						; size = 4
$T237873 = -148						; size = 4
_iPlayerLoop$226233 = -148				; size = 4
_eMyIdeology$ = -144					; size = 4
_eTheirIdeology$ = -140					; size = 4
_kPlayer$ = -136					; size = 4
_totalEnemies$226230 = -132				; size = 4
_rank$226229 = -128					; size = 4
_iLessHappyMod$ = -124					; size = 4
_iCommonFoeMod$ = -124					; size = 4
tv1258 = -120						; size = 4
$T237762 = -116						; size = 28
$T237759 = -116						; size = 28
$T237756 = -116						; size = 28
$T237753 = -116						; size = 28
$T237750 = -116						; size = 28
$T237747 = -116						; size = 28
$T237744 = -116						; size = 28
$T237741 = -116						; size = 28
$T237738 = -116						; size = 28
$T237735 = -116						; size = 28
$T237732 = -116						; size = 28
$T237729 = -116						; size = 28
$T237728 = -116						; size = 28
$T237764 = -88						; size = 28
$T237761 = -88						; size = 28
$T237758 = -88						; size = 28
$T237755 = -88						; size = 28
$T237752 = -88						; size = 28
$T237749 = -88						; size = 28
$T237746 = -88						; size = 28
$T237743 = -88						; size = 28
$T237740 = -88						; size = 28
$T237737 = -88						; size = 28
$T237734 = -88						; size = 28
$T237731 = -88						; size = 28
$T237726 = -88						; size = 28
$T237763 = -60						; size = 28
$T237760 = -60						; size = 28
$T237757 = -60						; size = 28
$T237754 = -60						; size = 28
$T237751 = -60						; size = 28
$T237748 = -60						; size = 28
$T237745 = -60						; size = 28
$T237742 = -60						; size = 28
$T237739 = -60						; size = 28
$T237736 = -60						; size = 28
$T237733 = -60						; size = 28
$T237730 = -60						; size = 28
$T237727 = -60						; size = 28
_this$ = -32						; size = 4
_myStrength$226231 = -28				; size = 4
$T237766 = -24						; size = 4
_ePlayerReligion$ = -20					; size = 4
_kTeam$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetTourismModifierWithTooltip, COMDAT
; _this$ = ecx

; 3199 : {

	push	-1
	push	__ehhandler$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T237766[esp+164], edi

; 3200 : 	CvString szRtnValue = "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+160]
	mov	ebx, ecx
	push	OFFSET $SG226183
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+168], ebx
	mov	DWORD PTR __$EHRec$[esp+176], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3334 : 	}
; 3335 : 
; 3336 : 	return szRtnValue;

	mov	DWORD PTR __$EHRec$[esp+172], edi
	mov	edi, DWORD PTR _ePlayer$[esp+160]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237766[esp+164], 1
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR _kPlayer$[esp+164], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN79@GetTourism@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN80@GetTourism@2

; 3201 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);
; 3202 : 	CvTeam &kTeam = GET_TEAM(kPlayer.getTeam());

$LN79@GetTourism@2:
	or	eax, -1
$LN80@GetTourism@2:

; 3203 : 	PolicyBranchTypes eMyIdeology = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, DWORD PTR [ebx+292]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebp, eax
	mov	DWORD PTR _kTeam$[esp+164], ebp
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 3204 : 	PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, edi
	mov	DWORD PTR _eMyIdeology$[esp+164], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eTheirIdeology$[esp+164], eax

; 3205 : 
; 3206 : 	// POSITIVE MODIFIERS
; 3207 : 
; 3208 : 	// Open borders with this player
; 3209 : 	if (kTeam.IsAllowsOpenBordersToTeam(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN90@GetTourism@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN91@GetTourism@2
$LN90@GetTourism@2:
	or	eax, -1
$LN91@GetTourism@2:
	push	eax
	mov	ecx, ebp
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	test	al, al
	je	$LN24@GetTourism@2

; 3210 : 	{
; 3211 : 		szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_OPEN_BORDERS", GetTourismModifierOpenBorders()) + "[ENDCOLOR]";

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	mov	ecx, DWORD PTR [ebx+292]
	push	57					; 00000039H
	mov	DWORD PTR $T237873[esp+168], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR $T237873[esp+164]
	lea	ecx, DWORD PTR $T237726[esp+164]
	push	eax
	push	OFFSET $SG226193
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	edx, DWORD PTR $T237727[esp+180]
	push	OFFSET $SG226194
	push	edx
	mov	DWORD PTR __$EHRec$[esp+196], 1
	call	ebp
	push	OFFSET $SG226192
	push	eax
	lea	eax, DWORD PTR $T237728[esp+196]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+208], 2
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 3
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237728[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237727[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237726[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN24@GetTourism@2:

; 3212 : 	}
; 3213 : 
; 3214 : 	// Trade route to one of this player's cities from here
; 3215 : 	if (GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), ePlayer))

	mov	ecx, DWORD PTR [ebx+292]
	mov	edx, DWORD PTR _ePlayer$[esp+160]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edx
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	je	$LN23@GetTourism@2

; 3216 : 	{
; 3217 : 		szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_TRADE_ROUTE", GetTourismModifierTradeRoute()) + "[ENDCOLOR]";

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	mov	ecx, DWORD PTR [ebx+292]
	push	56					; 00000038H
	mov	DWORD PTR $T237900[esp+168], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR $T237900[esp+164]
	lea	ecx, DWORD PTR $T237729[esp+164]
	push	eax
	push	OFFSET $SG226200
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	edx, DWORD PTR $T237730[esp+180]
	push	OFFSET $SG226201
	push	edx
	mov	DWORD PTR __$EHRec$[esp+196], 4
	call	ebp
	push	OFFSET $SG226199
	push	eax
	lea	eax, DWORD PTR $T237731[esp+196]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+208], 5
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237731[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237730[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237729[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN23@GetTourism@2:

; 3218 : 	}
; 3219 : 
; 3220 : 	ReligionTypes ePlayerReligion = m_pPlayer->GetReligions()->GetReligionInMostCities();

	mov	ecx, DWORD PTR [ebx+292]
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionInMostCities@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionInMostCities
	mov	DWORD PTR _ePlayerReligion$[esp+164], eax

; 3221 : 	if (ePlayerReligion != NO_RELIGION && kPlayer.GetReligions()->HasReligionInMostCities(ePlayerReligion))

	cmp	eax, -1
	je	$LN187@GetTourism@2
	mov	ecx, DWORD PTR _kPlayer$[esp+164]
	push	eax
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasReligionInMostCities@CvPlayerReligions@@QBE_NW4ReligionTypes@@@Z ; CvPlayerReligions::HasReligionInMostCities
	test	al, al
	je	$LN187@GetTourism@2

; 3222 : 	{
; 3223 : 		szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_RELIGION_NOTE", GetTourismModifierSharedReligion()) + "[ENDCOLOR]";

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	mov	DWORD PTR $T237914[esp+164], ecx
	mov	ecx, DWORD PTR [ebx+292]
	push	55					; 00000037H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR $T237914[esp+164]
	lea	edx, DWORD PTR $T237732[esp+164]
	push	eax
	push	OFFSET $SG226208
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	eax, DWORD PTR $T237733[esp+180]
	push	OFFSET $SG226209
	push	eax
	mov	DWORD PTR __$EHRec$[esp+196], 7
	call	ebp
	push	OFFSET $SG226207
	push	eax
	lea	ecx, DWORD PTR $T237734[esp+196]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+208], 8
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 9
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237734[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237733[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237732[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN187@GetTourism@2:

; 3224 : 	}
; 3225 : 
; 3226 : 	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology != eTheirIdeology)

	mov	ecx, DWORD PTR _eMyIdeology$[esp+164]
	cmp	ecx, -1
	je	$LN20@GetTourism@2
	mov	eax, DWORD PTR _eTheirIdeology$[esp+164]
	cmp	eax, -1
	je	$LN20@GetTourism@2
	cmp	ecx, eax
	je	$LN20@GetTourism@2

; 3227 : 	{
; 3228 : 		if (m_pPlayer->GetEspionage()->IsMyDiplomatVisitingThem(ePlayer))

	mov	edx, DWORD PTR _ePlayer$[esp+160]
	mov	ecx, DWORD PTR [ebx+292]
	push	0
	push	edx
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
	test	al, al
	je	$LN20@GetTourism@2

; 3229 : 		{
; 3230 : 			szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_PROPAGANDA", GC.getTOURISM_MODIFIER_DIPLOMAT()) + "[ENDCOLOR]";

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8232
	push	eax
	lea	ecx, DWORD PTR $T237735[esp+168]
	push	OFFSET $SG226216
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	edx, DWORD PTR $T237736[esp+180]
	push	OFFSET $SG226217
	push	edx
	mov	DWORD PTR __$EHRec$[esp+196], 10	; 0000000aH
	call	ebp
	push	OFFSET $SG226215
	push	eax
	lea	eax, DWORD PTR $T237737[esp+196]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+208], 11		; 0000000bH
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 12		; 0000000cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237737[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237736[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237735[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN20@GetTourism@2:

; 3231 : 		}
; 3232 : 	}
; 3233 : 
; 3234 : 	int iSharedIdeologyMod = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_SHARED_IDEOLOGY);

	mov	ecx, DWORD PTR [ebx+292]
	push	30					; 0000001eH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 3235 : 	if (iSharedIdeologyMod > 0)

	test	eax, eax
	jle	$LN18@GetTourism@2

; 3236 : 	{
; 3237 : 		if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)

	mov	edx, DWORD PTR _eMyIdeology$[esp+164]
	cmp	edx, -1
	je	$LN18@GetTourism@2
	mov	ecx, DWORD PTR _eTheirIdeology$[esp+164]
	cmp	ecx, -1
	je	$LN18@GetTourism@2
	cmp	edx, ecx
	jne	$LN18@GetTourism@2

; 3238 : 		{
; 3239 : 			szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_SHARED_IDEOLOGY", iSharedIdeologyMod) + "[ENDCOLOR]";

	push	eax
	lea	ecx, DWORD PTR $T237738[esp+168]
	push	OFFSET $SG226225
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	edx, DWORD PTR $T237739[esp+180]
	push	OFFSET $SG226226
	push	edx
	mov	DWORD PTR __$EHRec$[esp+196], 13	; 0000000dH
	call	ebp
	push	OFFSET $SG226224
	push	eax
	lea	eax, DWORD PTR $T237740[esp+196]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+208], 14		; 0000000eH
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 15		; 0000000fH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237740[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 14		; 0000000eH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237739[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237738[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@GetTourism@2:

; 3240 : 		}
; 3241 : 	}
; 3242 : 
; 3243 : 	int iCommonFoeMod = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_COMMON_FOE);

	mov	ecx, DWORD PTR [ebx+292]
	push	28					; 0000001cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 3244 : 	if (iCommonFoeMod > 0)

	xor	ecx, ecx
	cmp	eax, ecx
	mov	DWORD PTR _iCommonFoeMod$[esp+164], eax
	jle	$LN11@GetTourism@2

; 3245 : 	{
; 3246 : 		// NQMP GJS - new Cult of Personality BEGIN
; 3247 : 		int rank = 0;

	mov	DWORD PTR _rank$226229[esp+164], ecx

; 3248 : 		int totalEnemies = 0;

	mov	DWORD PTR _totalEnemies$226230[esp+164], ecx

; 3249 : 		int myStrength = m_pPlayer->GetMilitaryMight();

	mov	ecx, DWORD PTR [ebx+292]
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	mov	DWORD PTR _myStrength$226231[esp+164], eax

; 3250 : 
; 3251 : 		PlayerTypes eLoopPlayer;
; 3252 : 		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	eax, eax
	mov	DWORD PTR _iPlayerLoop$226233[esp+164], eax
	mov	DWORD PTR tv1258[esp+164], eax
$LL192@GetTourism@2:

; 3253 : 		{
; 3254 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3255 : 			if (eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [ebx+292]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN15@GetTourism@2
	push	0
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN15@GetTourism@2

; 3256 : 			{
; 3257 : 				totalEnemies++;
; 3258 : 				if (GET_PLAYER(eLoopPlayer).GetMilitaryMight() > myStrength)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv1258[esp+164]
	inc	DWORD PTR _totalEnemies$226230[esp+164]
	add	ecx, edx
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	cmp	eax, DWORD PTR _myStrength$226231[esp+164]
	jle	SHORT $LN15@GetTourism@2

; 3259 : 				{
; 3260 : 					rank++;

	inc	DWORD PTR _rank$226229[esp+164]
$LN15@GetTourism@2:

; 3250 : 
; 3251 : 		PlayerTypes eLoopPlayer;
; 3252 : 		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	ecx, DWORD PTR tv1258[esp+164]
	mov	eax, DWORD PTR _iPlayerLoop$226233[esp+164]
	add	ecx, 63236				; 0000f704H
	inc	eax
	cmp	ecx, 1391192				; 00153a58H
	mov	DWORD PTR _iPlayerLoop$226233[esp+164], eax
	mov	DWORD PTR tv1258[esp+164], ecx
	jl	SHORT $LL192@GetTourism@2

; 3261 : 				}
; 3262 : 			}
; 3263 : 		}
; 3264 : 
; 3265 : 		// divide the tourism boost into chunks, so that lowest player gets 0%, highest gets 100%, and the rest are evenly distributed in between
; 3266 : 		// so for example in a 6 player game, based on the player being 6th/5th/4th/3rd/2nd/1st in military strength they get 0%/20%/40%/60%/80%/100% boost
; 3267 : 		if (totalEnemies > 0)

	mov	ecx, DWORD PTR _totalEnemies$226230[esp+164]
	test	ecx, ecx
	jle	$LN11@GetTourism@2

; 3268 : 		{
; 3269 : 			iCommonFoeMod = iCommonFoeMod * (totalEnemies - rank) / totalEnemies;

	mov	eax, ecx
	sub	eax, DWORD PTR _rank$226229[esp+164]
	imul	eax, DWORD PTR _iCommonFoeMod$[esp+164]
	cdq
	idiv	ecx

; 3270 : 			szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_COMMON_FOE", iCommonFoeMod) + "[ENDCOLOR]";

	push	eax
	lea	eax, DWORD PTR $T237741[esp+168]
	push	OFFSET $SG226245
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	ecx, DWORD PTR $T237742[esp+180]
	push	OFFSET $SG226246
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+196], 16	; 00000010H
	call	ebp
	push	OFFSET $SG226244
	push	eax
	lea	edx, DWORD PTR $T237743[esp+196]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+208], 17		; 00000011H
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 18		; 00000012H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237743[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 17		; 00000011H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237742[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 16		; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237741[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@GetTourism@2:

; 3271 : 		}
; 3272 : 
; 3273 : 		/*
; 3274 : 		// old code
; 3275 : 		PlayerTypes eLoopPlayer;
; 3276 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 3277 : 		{
; 3278 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3279 : 
; 3280 : 			if (eLoopPlayer != ePlayer && eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
; 3281 : 			{
; 3282 : 				// Are they at war with me too?
; 3283 : 				if (GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && GET_TEAM(kPlayer.getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
; 3284 : 				{
; 3285 : 					szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_COMMON_FOE", iCommonFoeMod) + "[ENDCOLOR]";
; 3286 : 				}
; 3287 : 			}
; 3288 : 		}
; 3289 : 		*/
; 3290 : 		// NQMP GJS - new Cult of Personality END
; 3291 : 	}
; 3292 : 
; 3293 : 	int iLessHappyMod = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_LESS_HAPPY);

	mov	ecx, DWORD PTR [ebx+292]
	push	29					; 0000001dH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	DWORD PTR _iLessHappyMod$[esp+164], eax

; 3294 : 	if (iLessHappyMod > 0)

	test	eax, eax
	jle	$LN9@GetTourism@2

; 3295 : 	{
; 3296 : 		if (m_pPlayer->GetExcessHappiness() > kPlayer.GetExcessHappiness())

	mov	ecx, DWORD PTR [ebx+292]
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	ecx, DWORD PTR _kPlayer$[esp+164]
	mov	ebx, eax
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	cmp	ebx, eax
	jle	$LN186@GetTourism@2

; 3297 : 		{
; 3298 : 			szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_LESS_HAPPY", iLessHappyMod) + "[ENDCOLOR]";

	mov	eax, DWORD PTR _iLessHappyMod$[esp+164]
	push	eax
	lea	ecx, DWORD PTR $T237744[esp+168]
	push	OFFSET $SG226254
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	edx, DWORD PTR $T237745[esp+180]
	push	OFFSET $SG226255
	push	edx
	mov	DWORD PTR __$EHRec$[esp+196], 19	; 00000013H
	call	ebp
	push	OFFSET $SG226253
	push	eax
	lea	eax, DWORD PTR $T237746[esp+196]
	mov	bl, 20					; 00000014H
	push	eax
	mov	BYTE PTR __$EHRec$[esp+208], bl
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 21		; 00000015H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237746[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237745[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 19		; 00000013H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237744[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN186@GetTourism@2:
	mov	ebx, DWORD PTR _this$[esp+164]
$LN9@GetTourism@2:

; 3299 : 		}
; 3300 : 	}
; 3301 : 
; 3302 : 	if (m_pPlayer->isGoldenAge() && m_pPlayer->GetPlayerTraits()->GetGoldenAgeTourismModifier())

	mov	ecx, DWORD PTR [ebx+292]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	$LN8@GetTourism@2
	mov	ecx, DWORD PTR [ebx+292]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+184], 0
	je	$LN8@GetTourism@2

; 3303 : 	{
; 3304 : 		szRtnValue += "[COLOR_POSITIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_CARNIVAL", m_pPlayer->GetPlayerTraits()->GetGoldenAgeTourismModifier()) + "[ENDCOLOR]";

	mov	ecx, DWORD PTR [ebx+292]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+184]
	push	eax
	lea	ecx, DWORD PTR $T237747[esp+168]
	push	OFFSET $SG226261
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	edx, DWORD PTR $T237748[esp+180]
	push	OFFSET $SG226262
	push	edx
	mov	DWORD PTR __$EHRec$[esp+196], 22	; 00000016H
	call	ebp
	push	OFFSET $SG226260
	push	eax
	lea	eax, DWORD PTR $T237749[esp+196]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+208], 23		; 00000017H
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 24		; 00000018H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237749[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 23		; 00000017H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237748[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 22		; 00000016H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237747[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@GetTourism@2:

; 3305 : 	}
; 3306 : 
; 3307 : 	// NEUTRAL MODIFIERS
; 3308 : 	if (!kTeam.IsAllowsOpenBordersToTeam(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN153@GetTourism@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN154@GetTourism@2
$LN153@GetTourism@2:
	or	eax, -1
$LN154@GetTourism@2:
	mov	ecx, DWORD PTR _kTeam$[esp+164]
	push	eax
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	jne	$LN7@GetTourism@2

; 3309 : 	{
; 3310 : 		szRtnValue += "[COLOR_GREY]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_OPEN_BORDERS", 0) + "[ENDCOLOR]";		

	push	0
	lea	edx, DWORD PTR $T237750[esp+168]
	push	OFFSET $SG226268
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	eax, DWORD PTR $T237751[esp+180]
	push	OFFSET $SG226269
	push	eax
	mov	DWORD PTR __$EHRec$[esp+196], 25	; 00000019H
	call	ebp
	push	OFFSET $SG226267
	push	eax
	lea	ecx, DWORD PTR $T237752[esp+196]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+208], 26		; 0000001aH
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 27		; 0000001bH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237752[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 26		; 0000001aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237751[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 25		; 00000019H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237750[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@GetTourism@2:

; 3311 : 	}
; 3312 : 	if (!GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), ePlayer))

	mov	edx, DWORD PTR [ebx+292]
	mov	ecx, DWORD PTR _ePlayer$[esp+160]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	jne	$LN6@GetTourism@2

; 3313 : 	{
; 3314 : 		szRtnValue += "[COLOR_GREY]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_TRADE_ROUTE", 0) + "[ENDCOLOR]";		

	push	0
	lea	edx, DWORD PTR $T237753[esp+168]
	push	OFFSET $SG226275
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	eax, DWORD PTR $T237754[esp+180]
	push	OFFSET $SG226276
	push	eax
	mov	DWORD PTR __$EHRec$[esp+196], 28	; 0000001cH
	call	ebp
	push	OFFSET $SG226274
	push	eax
	lea	ecx, DWORD PTR $T237755[esp+196]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+208], 29		; 0000001dH
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 30		; 0000001eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237755[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 29		; 0000001dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237754[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 28		; 0000001cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237753[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@GetTourism@2:

; 3315 : 	}
; 3316 : 	if (ePlayerReligion == NO_RELIGION || !kPlayer.GetReligions()->HasReligionInMostCities(ePlayerReligion))

	mov	eax, DWORD PTR _ePlayerReligion$[esp+164]
	cmp	eax, -1
	je	SHORT $LN4@GetTourism@2
	mov	ecx, DWORD PTR _kPlayer$[esp+164]
	push	eax
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasReligionInMostCities@CvPlayerReligions@@QBE_NW4ReligionTypes@@@Z ; CvPlayerReligions::HasReligionInMostCities
	test	al, al
	jne	$LN5@GetTourism@2
$LN4@GetTourism@2:

; 3317 : 	{
; 3318 : 		szRtnValue += "[COLOR_GREY]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_RELIGION_NOTE", 0) + "[ENDCOLOR]";

	push	0
	lea	edx, DWORD PTR $T237756[esp+168]
	push	OFFSET $SG226283
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	eax, DWORD PTR $T237757[esp+180]
	push	OFFSET $SG226284
	push	eax
	mov	DWORD PTR __$EHRec$[esp+196], 31	; 0000001fH
	call	ebp
	push	OFFSET $SG226282
	push	eax
	lea	ecx, DWORD PTR $T237758[esp+196]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+208], 32		; 00000020H
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 33		; 00000021H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237758[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 32		; 00000020H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237757[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 31		; 0000001fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237756[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@GetTourism@2:

; 3319 : 	}
; 3320 : 	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology != eTheirIdeology)

	mov	ecx, DWORD PTR _eMyIdeology$[esp+164]
	cmp	ecx, -1
	je	$LN185@GetTourism@2
	mov	eax, DWORD PTR _eTheirIdeology$[esp+164]
	cmp	eax, -1
	je	$LN185@GetTourism@2
	cmp	ecx, eax
	je	$LN191@GetTourism@2

; 3321 : 	{
; 3322 : 		if (!m_pPlayer->GetEspionage()->IsMyDiplomatVisitingThem(ePlayer))

	mov	edx, DWORD PTR _ePlayer$[esp+160]
	mov	ecx, DWORD PTR [ebx+292]
	push	0
	push	edx
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
	test	al, al
	jne	$LN191@GetTourism@2

; 3323 : 		{
; 3324 : 			szRtnValue += "[COLOR_GREY]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_PROPAGANDA", 0) + "[ENDCOLOR]";

	push	0
	lea	eax, DWORD PTR $T237759[esp+168]
	push	OFFSET $SG226291
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	ecx, DWORD PTR $T237760[esp+180]
	push	OFFSET $SG226292
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+196], 34	; 00000022H
	call	ebp
	push	OFFSET $SG226290
	push	eax
	lea	edx, DWORD PTR $T237761[esp+196]
	mov	bl, 35					; 00000023H
	push	edx
	mov	BYTE PTR __$EHRec$[esp+208], bl
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 36		; 00000024H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237761[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237760[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 34		; 00000022H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237759[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN191@GetTourism@2:

; 3325 : 		}
; 3326 : #ifndef AUI_WARNING_FIXES
; 3327 : 	}
; 3328 : 
; 3329 : 	// NEGATIVE MODIFIERS
; 3330 : 	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology != eTheirIdeology)

	mov	eax, DWORD PTR _eTheirIdeology$[esp+164]
	cmp	DWORD PTR _eMyIdeology$[esp+164], eax
	je	$LN185@GetTourism@2

; 3331 : 	{
; 3332 : #endif
; 3333 : 		szRtnValue += "[COLOR_NEGATIVE_TEXT]" + GetLocalizedText("TXT_KEY_CO_PLAYER_TOURISM_DIFFERENT_IDEOLOGIES", GC.getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES()) + "[ENDCOLOR]";

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8228
	push	ecx
	lea	edx, DWORD PTR $T237762[esp+168]
	push	OFFSET $SG226298
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	push	eax
	lea	eax, DWORD PTR $T237763[esp+180]
	push	OFFSET $SG226299
	push	eax
	mov	DWORD PTR __$EHRec$[esp+196], 37	; 00000025H
	call	ebp
	push	OFFSET $SG226297
	push	eax
	lea	ecx, DWORD PTR $T237764[esp+196]
	mov	bl, 38					; 00000026H
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+208], bl
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+176], 39		; 00000027H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237764[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237763[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 37		; 00000025H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237762[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN185@GetTourism@2:

; 3337 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 148				; 00000094H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$0:
	mov	eax, DWORD PTR $T237766[ebp]
	and	eax, 1
	je	$LN28@GetTourism@2
	and	DWORD PTR $T237766[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN28@GetTourism@2:
	ret	0
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR $T237726[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR $T237727[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T237728[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR $T237729[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T237730[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T237731[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T237732[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$8:
	lea	ecx, DWORD PTR $T237733[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$9:
	lea	ecx, DWORD PTR $T237734[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$10:
	lea	ecx, DWORD PTR $T237735[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$11:
	lea	ecx, DWORD PTR $T237736[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$12:
	lea	ecx, DWORD PTR $T237737[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$13:
	lea	ecx, DWORD PTR $T237738[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$14:
	lea	ecx, DWORD PTR $T237739[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$15:
	lea	ecx, DWORD PTR $T237740[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$16:
	lea	ecx, DWORD PTR $T237741[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$17:
	lea	ecx, DWORD PTR $T237742[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$18:
	lea	ecx, DWORD PTR $T237743[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$19:
	lea	ecx, DWORD PTR $T237744[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$20:
	lea	ecx, DWORD PTR $T237745[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$21:
	lea	ecx, DWORD PTR $T237746[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$22:
	lea	ecx, DWORD PTR $T237747[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$23:
	lea	ecx, DWORD PTR $T237748[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$24:
	lea	ecx, DWORD PTR $T237749[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$25:
	lea	ecx, DWORD PTR $T237750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$26:
	lea	ecx, DWORD PTR $T237751[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$27:
	lea	ecx, DWORD PTR $T237752[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$28:
	lea	ecx, DWORD PTR $T237753[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$29:
	lea	ecx, DWORD PTR $T237754[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$30:
	lea	ecx, DWORD PTR $T237755[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$31:
	lea	ecx, DWORD PTR $T237756[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$32:
	lea	ecx, DWORD PTR $T237757[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$33:
	lea	ecx, DWORD PTR $T237758[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$34:
	lea	ecx, DWORD PTR $T237759[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$35:
	lea	ecx, DWORD PTR $T237760[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$36:
	lea	ecx, DWORD PTR $T237761[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$37:
	lea	ecx, DWORD PTR $T237762[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$38:
	lea	ecx, DWORD PTR $T237763[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z$39:
	lea	ecx, DWORD PTR $T237764[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTourismModifierWithTooltip@CvPlayerCulture@@QBE?AVCvString@@W4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetTourismModifierWithTooltip
PUBLIC	?AddTourismAllKnownCivs@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::AddTourismAllKnownCivs
; Function compile flags: /Ogtpy
;	COMDAT ?AddTourismAllKnownCivs@CvPlayerCulture@@QAEXH@Z
_TEXT	SEGMENT
_iTourism$ = 8						; size = 4
?AddTourismAllKnownCivs@CvPlayerCulture@@QAEXH@Z PROC	; CvPlayerCulture::AddTourismAllKnownCivs, COMDAT
; _this$ = ecx

; 3417 : {

	push	ebx
	push	ebp

; 3418 : 	PlayerTypes eLoopPlayer;
; 3419 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	ebp, DWORD PTR _iTourism$[esp+4]
	push	esi
	mov	ebx, ecx
	push	edi
	xor	esi, esi
	lea	edi, DWORD PTR [ebx+20]
	npad	1
$LL21@AddTourism:

; 3420 : 	{
; 3421 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3422 : 
; 3423 : 		if (eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [ebx+292]
	cmp	esi, DWORD PTR [ecx+44]
	je	SHORT $LN3@AddTourism
	push	0
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN3@AddTourism

; 3424 : 		{
; 3425 : 			ChangeInfluenceOn(eLoopPlayer, iTourism);

	test	esi, esi
	jl	SHORT $LN3@AddTourism
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN3@AddTourism
	add	DWORD PTR [edi], ebp
$LN3@AddTourism:

; 3418 : 	PlayerTypes eLoopPlayer;
; 3419 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	esi
	add	edi, 4
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL21@AddTourism
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3426 : 		}
; 3427 : 	}
; 3428 : }

	ret	4
?AddTourismAllKnownCivs@CvPlayerCulture@@QAEXH@Z ENDP	; CvPlayerCulture::AddTourismAllKnownCivs
_TEXT	ENDS
PUBLIC	?DoPublicOpinion@CvPlayerCulture@@QAEXXZ	; CvPlayerCulture::DoPublicOpinion
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
EXTRN	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z:PROC ; CvGameLeagues::GetPressureForIdeology
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ DD 019930522H
	DD	01aH
	DD	FLAT:__unwindtable$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$8
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$10
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$11
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$12
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$13
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$14
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$15
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$18
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$19
	DD	04H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$21
	DD	014H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$22
	DD	014H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$23
	DD	014H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$24
	DD	014H
	DD	FLAT:__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$25
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoPublicOpinion@CvPlayerCulture@@QAEXXZ
_TEXT	SEGMENT
_iUnhappyPerXPop$226473 = -464				; size = 4
_iLoopPlayer$226415 = -464				; size = 4
_iPerCityUnhappy$226472 = -460				; size = 4
_eOrderBranch$ = -460					; size = 4
_eAutocracyBranch$ = -456				; size = 4
tv1499 = -452						; size = 4
tv1486 = -452						; size = 4
tv1191 = -448						; size = 4
_iPressureForOrder$226373 = -444			; size = 4
_iPressureForAutocracy$226372 = -440			; size = 4
_iGreatestDominance$226480 = -436			; size = 4
_eFreedomBranch$ = -436					; size = 4
_iPressureForFreedom$226371 = -432			; size = 4
_locText$226528 = -428					; size = 80
_locText$226523 = -428					; size = 80
_locText$226517 = -428					; size = 80
_locText$226513 = -428					; size = 80
_locText$226508 = -428					; size = 80
_locText$226504 = -428					; size = 80
_locText$226500 = -428					; size = 80
_locText$226496 = -428					; size = 80
_sTemp$226405 = -428					; size = 80
_sTemp$226394 = -428					; size = 80
_sTemp$226383 = -428					; size = 80
tv1403 = -348						; size = 4
$T238079 = -344						; size = 28
_sIcons$226408 = -344					; size = 28
_sIcons$226397 = -344					; size = 28
_sIcons$226386 = -344					; size = 28
_eCurrentIdeology$ = -316				; size = 4
_strOrderPressureString$226380 = -312			; size = 28
_strAutocracyPressureString$226378 = -284		; size = 28
_strFreedomPressureString$226376 = -256			; size = 28
_strWorldIdeologyPressureString$226374 = -228		; size = 28
$T238085 = -200						; size = 80
$T238084 = -200						; size = 80
$T238083 = -200						; size = 80
$T238082 = -200						; size = 80
$T238081 = -200						; size = 80
$T238078 = -120						; size = 28
_locOverview$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
?DoPublicOpinion@CvPlayerCulture@@QAEXXZ PROC		; CvPlayerCulture::DoPublicOpinion, COMDAT
; _this$ = ecx

; 3434 : {

	push	-1
	push	__ehhandler$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 452				; 000001c4H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 3435 : 	m_eOpinion = NO_PUBLIC_OPINION;

	or	ebp, -1

; 3436 : 	m_ePreferredIdeology = NO_POLICY_BRANCH_TYPE;
; 3437 : 	m_iOpinionUnhappiness = 0;
; 3438 : 	m_strOpinionTooltip = "";

	lea	edi, DWORD PTR [esi+220]
	push	OFFSET $SG226356
	mov	ecx, edi
	mov	DWORD PTR [esi+200], ebp
	mov	DWORD PTR [esi+212], ebp
	mov	DWORD PTR [esi+216], 0
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 3439 : 	m_strOpinionUnhappinessTooltip = "";

	lea	ecx, DWORD PTR [esi+248]
	push	OFFSET $SG226357
	mov	DWORD PTR tv1191[esp+484], ecx
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 3440 : 	m_eOpinionBiggestInfluence = NO_PLAYER;

	mov	DWORD PTR [esi+204], ebp

; 3441 : 
; 3442 : 	PolicyBranchTypes eFreedomBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376

; 3443 : 	PolicyBranchTypes eAutocracyBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380

; 3444 : 	PolicyBranchTypes eOrderBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR _eFreedomBranch$[esp+480], ebx
	mov	DWORD PTR _eAutocracyBranch$[esp+480], eax
	mov	DWORD PTR _eOrderBranch$[esp+480], ecx

; 3445 : 
; 3446 : 	if (eFreedomBranch == NO_POLICY_BRANCH_TYPE || eAutocracyBranch == NO_POLICY_BRANCH_TYPE || eOrderBranch == NO_POLICY_BRANCH_TYPE)

	cmp	ebx, ebp
	je	$LN75@DoPublicOp
	cmp	eax, ebp
	je	$LN75@DoPublicOp
	cmp	ecx, ebp
	je	$LN75@DoPublicOp

; 3447 : 	{
; 3448 : 		return;
; 3449 : 	}
; 3450 : 
; 3451 : 	Localization::String locOverview = Localization::Lookup("TXT_KEY_CO_OPINION_TT_OVERVIEW");

	lea	edx, DWORD PTR _locOverview$[esp+480]
	push	OFFSET $SG226368
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 3452 : 	m_strOpinionTooltip += locOverview.toUTF8();

	lea	ecx, DWORD PTR _locOverview$[esp+480]
	mov	DWORD PTR __$EHRec$[esp+488], 0
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3453 : 
; 3454 : 	PolicyBranchTypes eCurrentIdeology = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, DWORD PTR [esi+292]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eCurrentIdeology$[esp+480], eax

; 3455 : 
; 3456 : 	// We have an ideology, so public opinion matters
; 3457 : 	if (eCurrentIdeology != NO_POLICY_BRANCH_TYPE)

	cmp	eax, ebp
	je	$LN287@DoPublicOp

; 3458 : 	{
; 3459 : 		int iPressureForFreedom = 0;
; 3460 : 		int iPressureForAutocracy = 0;
; 3461 : 		int iPressureForOrder = 0;
; 3462 : 		CvString strWorldIdeologyPressureString = "";

	push	OFFSET $SG226375
	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[esp+484]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3463 : 		CvString strFreedomPressureString = "";

	push	OFFSET $SG226377
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3464 : 		CvString strAutocracyPressureString = "";

	push	OFFSET $SG226379
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3465 : 		CvString strOrderPressureString = "";

	push	OFFSET $SG226381
	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 3466 : 
; 3467 : 		// Look at World Congress
; 3468 : 		iPressureForFreedom += GC.getGame().GetGameLeagues()->GetPressureForIdeology(m_pPlayer->GetID(), eFreedomBranch);

	mov	eax, DWORD PTR [esi+292]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+496], 4
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z ; CvGameLeagues::GetPressureForIdeology

; 3469 : 		if (iPressureForFreedom > 0)
; 3470 : 		{
; 3471 : 			Localization::String sTemp = Localization::Lookup("TXT_KEY_CO_OPINION_TT_FOR_FREEDOM");

	mov	ebp, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	edi, eax
	mov	DWORD PTR _iPressureForFreedom$226371[esp+480], edi
	test	edi, edi
	jle	$LN73@DoPublicOp
	lea	ecx, DWORD PTR _sTemp$226383[esp+480]
	push	OFFSET $SG226385
	push	ecx
	call	ebp
	add	esp, 8

; 3472 : 			CvString sIcons = "";

	push	OFFSET $SG226387
	lea	ecx, DWORD PTR _sIcons$226386[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 5
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	BYTE PTR __$EHRec$[esp+488], 6

; 3473 : 			for (int i = 0; i < iPressureForFreedom; i++)

	test	edi, edi
	jle	SHORT $LN70@DoPublicOp
$LL72@DoPublicOp:

; 3474 : 			{
; 3475 : 				sIcons += "[ICON_IDEOLOGY_FREEDOM]";

	push	OFFSET $SG226392
	lea	ecx, DWORD PTR _sIcons$226386[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	sub	edi, 1
	jne	SHORT $LL72@DoPublicOp
$LN70@DoPublicOp:

; 3476 : 			}
; 3477 : 			sTemp << sIcons;

	lea	ecx, DWORD PTR _sIcons$226386[esp+480]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sTemp$226383[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3478 : 			strWorldIdeologyPressureString += sTemp.toUTF8();

	lea	ecx, DWORD PTR _sTemp$226383[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3479 : 		}

	lea	ecx, DWORD PTR _sIcons$226386[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sTemp$226383[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN73@DoPublicOp:

; 3480 : 		iPressureForAutocracy += GC.getGame().GetGameLeagues()->GetPressureForIdeology(m_pPlayer->GetID(), eAutocracyBranch);

	mov	edx, DWORD PTR [esi+292]
	mov	ecx, DWORD PTR _eAutocracyBranch$[esp+480]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z ; CvGameLeagues::GetPressureForIdeology
	mov	edi, eax
	mov	DWORD PTR _iPressureForAutocracy$226372[esp+480], edi

; 3481 : 		if (iPressureForAutocracy > 0)

	test	edi, edi
	jle	$LN69@DoPublicOp

; 3482 : 		{
; 3483 : 			Localization::String sTemp = Localization::Lookup("TXT_KEY_CO_OPINION_TT_FOR_AUTOCRACY");

	lea	edx, DWORD PTR _sTemp$226394[esp+480]
	push	OFFSET $SG226396
	push	edx
	call	ebp
	add	esp, 8
	mov	bl, 7

; 3484 : 			CvString sIcons = "";

	push	OFFSET $SG226398
	lea	ecx, DWORD PTR _sIcons$226397[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+488], 8

; 3485 : 			for (int i = 0; i < iPressureForAutocracy; i++)

	test	edi, edi
	jle	SHORT $LN66@DoPublicOp
	npad	11
$LL68@DoPublicOp:

; 3486 : 			{
; 3487 : 				sIcons += "[ICON_IDEOLOGY_AUTOCRACY]";

	push	OFFSET $SG226403
	lea	ecx, DWORD PTR _sIcons$226397[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	sub	edi, 1
	jne	SHORT $LL68@DoPublicOp
$LN66@DoPublicOp:

; 3488 : 			}
; 3489 : 			sTemp << sIcons;

	lea	ecx, DWORD PTR _sIcons$226397[esp+480]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sTemp$226394[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3490 : 			strWorldIdeologyPressureString += sTemp.toUTF8();

	lea	ecx, DWORD PTR _sTemp$226394[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3491 : 		}

	lea	ecx, DWORD PTR _sIcons$226397[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sTemp$226394[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN69@DoPublicOp:

; 3492 : 		iPressureForOrder += GC.getGame().GetGameLeagues()->GetPressureForIdeology(m_pPlayer->GetID(), eOrderBranch);

	mov	eax, DWORD PTR [esi+292]
	mov	ecx, DWORD PTR _eOrderBranch$[esp+480]
	mov	eax, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z ; CvGameLeagues::GetPressureForIdeology
	mov	edi, eax
	mov	DWORD PTR _iPressureForOrder$226373[esp+480], edi

; 3493 : 		if (iPressureForOrder > 0)

	test	edi, edi
	jle	$LN65@DoPublicOp

; 3494 : 		{
; 3495 : 			Localization::String sTemp = Localization::Lookup("TXT_KEY_CO_OPINION_TT_FOR_ORDER");

	lea	edx, DWORD PTR _sTemp$226405[esp+480]
	push	OFFSET $SG226407
	push	edx
	call	ebp
	add	esp, 8
	mov	bl, 9

; 3496 : 			CvString sIcons = "";

	push	OFFSET $SG226409
	lea	ecx, DWORD PTR _sIcons$226408[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+488], 10		; 0000000aH

; 3497 : 			for (int i = 0; i < iPressureForOrder; i++)

	test	edi, edi
	jle	SHORT $LN62@DoPublicOp
$LL64@DoPublicOp:

; 3498 : 			{
; 3499 : 				sIcons += "[ICON_IDEOLOGY_ORDER]";

	push	OFFSET $SG226414
	lea	ecx, DWORD PTR _sIcons$226408[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	sub	edi, 1
	jne	SHORT $LL64@DoPublicOp
$LN62@DoPublicOp:

; 3500 : 			}
; 3501 : 			sTemp << sIcons;

	lea	ecx, DWORD PTR _sIcons$226408[esp+480]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sTemp$226405[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3502 : 			strWorldIdeologyPressureString += sTemp.toUTF8();

	lea	ecx, DWORD PTR _sTemp$226405[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3503 : 		}

	lea	ecx, DWORD PTR _sIcons$226408[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sTemp$226405[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN65@DoPublicOp:

; 3504 : 
; 3505 : 		// Look at each civ
; 3506 : 		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	eax, eax
	mov	DWORD PTR _iLoopPlayer$226415[esp+480], eax
	mov	DWORD PTR tv1486[esp+480], eax
	npad	7
$LL61@DoPublicOp:

; 3507 : 		{
; 3508 : 			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv1486[esp+480]

; 3509 : 			if (iLoopPlayer != m_pPlayer->GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())

	mov	edx, DWORD PTR [esi+292]
	lea	ebp, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _iLoopPlayer$226415[esp+480]
	cmp	eax, DWORD PTR [edx+44]
	je	$LN60@DoPublicOp
	cmp	BYTE PTR [ebp+2256], 0
	je	$LN60@DoPublicOp
	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN60@DoPublicOp

; 3510 : 			{
; 3511 : 				PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, ebp
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	ebx, eax

; 3512 : 				if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE)

	cmp	ebx, -1
	je	$LN60@DoPublicOp

; 3513 : 				{
; 3514 : 					int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - m_pPlayer->GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);

	mov	edx, DWORD PTR _iLoopPlayer$226415[esp+480]
	mov	ecx, DWORD PTR [esi+292]
	mov	edi, DWORD PTR [ecx+44]
	push	edx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR tv1403[esp+484], eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	mov	edi, eax
	mov	eax, DWORD PTR tv1403[esp+480]
	sub	edi, eax

; 3515 : 					if (iCulturalDominanceOverUs > 0)

	test	edi, edi
	jle	$LN60@DoPublicOp

; 3516 : 					{
; 3517 : 						if (eOtherCivIdeology == eFreedomBranch)

	cmp	ebx, DWORD PTR _eFreedomBranch$[esp+480]
	jne	SHORT $LN55@DoPublicOp

; 3518 : 						{
; 3519 : 							iPressureForFreedom += iCulturalDominanceOverUs;

	add	DWORD PTR _iPressureForFreedom$226371[esp+480], edi

; 3520 : 							if (strFreedomPressureString.size() > 0)

	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	jbe	SHORT $LN54@DoPublicOp

; 3521 : 							{
; 3522 : 								strFreedomPressureString += ", ";

	push	OFFSET $SG226429
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN54@DoPublicOp:

; 3523 : 							}
; 3524 : 							strFreedomPressureString += kPlayer.getCivilizationShortDescription();

	mov	ecx, ebp
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3525 : 							for (int iI = 0; iI < iCulturalDominanceOverUs; iI++)

	test	edi, edi
	jle	$LN60@DoPublicOp
$LL53@DoPublicOp:

; 3526 : 							{
; 3527 : 								strFreedomPressureString += "[ICON_IDEOLOGY_FREEDOM]";

	push	OFFSET $SG226434
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	sub	edi, 1
	jne	SHORT $LL53@DoPublicOp

; 3528 : 							}
; 3529 : 						}
; 3530 : 						else if (eOtherCivIdeology == eAutocracyBranch)

	jmp	$LN60@DoPublicOp
$LN55@DoPublicOp:
	cmp	ebx, DWORD PTR _eAutocracyBranch$[esp+480]
	jne	SHORT $LN49@DoPublicOp

; 3531 : 						{
; 3532 : 							iPressureForAutocracy += iCulturalDominanceOverUs;

	add	DWORD PTR _iPressureForAutocracy$226372[esp+480], edi

; 3533 : 							if (strAutocracyPressureString.size() > 0)

	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	jbe	SHORT $LN48@DoPublicOp

; 3534 : 							{
; 3535 : 								strAutocracyPressureString += ", ";

	push	OFFSET $SG226438
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN48@DoPublicOp:

; 3536 : 							}
; 3537 : 							strAutocracyPressureString += kPlayer.getCivilizationShortDescription();

	mov	ecx, ebp
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3538 : 							for (int iI = 0; iI < iCulturalDominanceOverUs; iI++)

	test	edi, edi
	jle	SHORT $LN60@DoPublicOp
$LL47@DoPublicOp:

; 3539 : 							{
; 3540 : 								strAutocracyPressureString += "[ICON_IDEOLOGY_AUTOCRACY]";

	push	OFFSET $SG226443
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	sub	edi, 1
	jne	SHORT $LL47@DoPublicOp

; 3541 : 							}
; 3542 : 						}
; 3543 : 						else

	jmp	SHORT $LN60@DoPublicOp
$LN49@DoPublicOp:

; 3544 : 						{
; 3545 : 							iPressureForOrder += iCulturalDominanceOverUs;

	add	DWORD PTR _iPressureForOrder$226373[esp+480], edi

; 3546 : 							if (strOrderPressureString.size() > 0)

	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	jbe	SHORT $LN43@DoPublicOp

; 3547 : 							{
; 3548 : 								strOrderPressureString += ", ";

	push	OFFSET $SG226446
	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN43@DoPublicOp:

; 3549 : 							}
; 3550 : 							strOrderPressureString += kPlayer.getCivilizationShortDescription();

	mov	ecx, ebp
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3551 : 							for (int iI = 0; iI < iCulturalDominanceOverUs; iI++)

	test	edi, edi
	jle	SHORT $LN60@DoPublicOp
	npad	4
$LL42@DoPublicOp:

; 3552 : 							{
; 3553 : 								strOrderPressureString += "[ICON_IDEOLOGY_ORDER]";

	push	OFFSET $SG226451
	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+484]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	sub	edi, 1
	jne	SHORT $LL42@DoPublicOp
$LN60@DoPublicOp:

; 3504 : 
; 3505 : 		// Look at each civ
; 3506 : 		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	mov	eax, DWORD PTR tv1486[esp+480]
	inc	DWORD PTR _iLoopPlayer$226415[esp+480]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv1486[esp+480], eax
	jl	$LL61@DoPublicOp

; 3554 : 							}
; 3555 : 						}
; 3556 : 					}
; 3557 : 				}
; 3558 : 			}
; 3559 : 		}
; 3560 : 
; 3561 : 		// Now compute satisfaction with this branch compared to two other ones
; 3562 : 		int iDissatisfaction = 0;
; 3563 : 		if (eCurrentIdeology == eFreedomBranch)

	mov	eax, DWORD PTR _eCurrentIdeology$[esp+480]
	mov	ebx, DWORD PTR _eFreedomBranch$[esp+480]
	xor	edi, edi
	cmp	eax, ebx
	jne	SHORT $LN39@DoPublicOp

; 3564 : 		{
; 3565 : 			if (iPressureForFreedom >= (iPressureForAutocracy + iPressureForOrder))

	mov	eax, DWORD PTR _iPressureForOrder$226373[esp+480]
	mov	ecx, DWORD PTR _iPressureForAutocracy$226372[esp+480]
	mov	edx, DWORD PTR _iPressureForFreedom$226371[esp+480]
	lea	ebx, DWORD PTR [eax+ecx]
	cmp	edx, ebx
	jl	SHORT $LN38@DoPublicOp

; 3566 : 			{
; 3567 : 				m_eOpinion = PUBLIC_OPINION_CONTENT;

	mov	DWORD PTR [esi+200], edi

; 3568 : 			}
; 3569 : 			else

	jmp	SHORT $LN24@DoPublicOp
$LN38@DoPublicOp:

; 3570 : 			{
; 3571 : 				if (iPressureForAutocracy > iPressureForOrder)

	cmp	ecx, eax

; 3572 : 				{
; 3573 : 					m_ePreferredIdeology = eAutocracyBranch;

	mov	edi, DWORD PTR _eAutocracyBranch$[esp+480]
	jg	SHORT $LN290@DoPublicOp
$LN281@DoPublicOp:

; 3574 : 				}
; 3575 : 				else if (iPressureForOrder >= iPressureForAutocracy)
; 3576 : 				{
; 3577 : 					m_ePreferredIdeology = eOrderBranch;

	mov	edi, DWORD PTR _eOrderBranch$[esp+480]

; 3578 : 				}
; 3579 : 				iDissatisfaction = (iPressureForAutocracy + iPressureForOrder) - iPressureForFreedom;
; 3580 : 			}

	jmp	SHORT $LN290@DoPublicOp
$LN39@DoPublicOp:

; 3581 : 		}
; 3582 : 		else if (eCurrentIdeology == eAutocracyBranch)
; 3583 : 		{
; 3584 : 			if (iPressureForAutocracy >= (iPressureForFreedom + iPressureForOrder))

	mov	ecx, DWORD PTR _iPressureForFreedom$226371[esp+480]
	cmp	eax, DWORD PTR _eAutocracyBranch$[esp+480]
	jne	SHORT $LN32@DoPublicOp
	mov	eax, DWORD PTR _iPressureForOrder$226373[esp+480]
	mov	edx, DWORD PTR _iPressureForAutocracy$226372[esp+480]
	lea	ebp, DWORD PTR [eax+ecx]
	cmp	edx, ebp
	jl	SHORT $LN31@DoPublicOp

; 3585 : 			{
; 3586 : 				m_eOpinion = PUBLIC_OPINION_CONTENT;

	mov	DWORD PTR [esi+200], 0

; 3587 : 			}
; 3588 : 			else

	jmp	SHORT $LN24@DoPublicOp
$LN31@DoPublicOp:

; 3589 : 			{
; 3590 : 				if (iPressureForFreedom >= iPressureForOrder)

	cmp	ecx, eax
	jl	SHORT $LN281@DoPublicOp

; 3591 : 				{
; 3592 : 					m_ePreferredIdeology = eFreedomBranch;

	mov	DWORD PTR [esi+212], ebx
	jmp	SHORT $LN21@DoPublicOp
$LN32@DoPublicOp:

; 3593 : 				}
; 3594 : 				else if (iPressureForOrder > iPressureForFreedom)
; 3595 : 				{
; 3596 : 					m_ePreferredIdeology = eOrderBranch;
; 3597 : 				}
; 3598 : 				iDissatisfaction = (iPressureForFreedom + iPressureForOrder) - iPressureForAutocracy;
; 3599 : 			}
; 3600 : 		}
; 3601 : 		else
; 3602 : 		{
; 3603 : 			if (iPressureForOrder >= (iPressureForFreedom + iPressureForAutocracy))

	mov	eax, DWORD PTR _iPressureForAutocracy$226372[esp+480]
	mov	edx, DWORD PTR _iPressureForOrder$226373[esp+480]
	lea	ebp, DWORD PTR [eax+ecx]
	cmp	edx, ebp
	jl	SHORT $LN25@DoPublicOp

; 3604 : 			{
; 3605 : 				m_eOpinion = PUBLIC_OPINION_CONTENT;

	mov	DWORD PTR [esi+200], 0

; 3606 : 			}
; 3607 : 			else

	jmp	SHORT $LN24@DoPublicOp
$LN25@DoPublicOp:

; 3608 : 			{
; 3609 : 				if (iPressureForFreedom > iPressureForAutocracy)

	cmp	ecx, eax
	jle	SHORT $LN280@DoPublicOp

; 3610 : 				{
; 3611 : 					m_ePreferredIdeology = eFreedomBranch;

	mov	DWORD PTR [esi+212], ebx
	jmp	SHORT $LN21@DoPublicOp
$LN280@DoPublicOp:

; 3612 : 				}
; 3613 : 				else if (iPressureForAutocracy >= iPressureForFreedom)
; 3614 : 				{
; 3615 : 					m_ePreferredIdeology = eAutocracyBranch;

	mov	edi, DWORD PTR _eAutocracyBranch$[esp+480]
$LN290@DoPublicOp:
	mov	DWORD PTR [esi+212], edi
$LN21@DoPublicOp:

; 3616 : 				}
; 3617 : 				iDissatisfaction = (iPressureForFreedom + iPressureForAutocracy) - iPressureForOrder;

	sub	eax, edx
	add	eax, ecx
	mov	edi, eax
$LN24@DoPublicOp:

; 3618 : 			}
; 3619 : 		}
; 3620 : 
; 3621 : 		// Compute effects of dissatisfaction
; 3622 : 		int iPerCityUnhappy = 1;
; 3623 : 		int iUnhappyPerXPop = 10;
; 3624 : 		if (m_eOpinion != PUBLIC_OPINION_CONTENT)

	cmp	DWORD PTR [esi+200], 0
	mov	DWORD PTR _iPerCityUnhappy$226472[esp+480], 1
	mov	DWORD PTR _iUnhappyPerXPop$226473[esp+480], 10 ; 0000000aH
	je	$LN13@DoPublicOp

; 3625 : 		{
; 3626 : 			if (iDissatisfaction < 3)

	cmp	edi, 3
	jge	SHORT $LN19@DoPublicOp

; 3627 : 			{
; 3628 : 				m_eOpinion = PUBLIC_OPINION_DISSIDENTS;

	mov	DWORD PTR [esi+200], 1
	jmp	SHORT $LN17@DoPublicOp
$LN19@DoPublicOp:

; 3629 : 			}
; 3630 : 			else if (iDissatisfaction < 5)

	xor	eax, eax
	cmp	edi, 5
	setge	al
	add	eax, 2
	mov	DWORD PTR [esi+200], eax
$LN17@DoPublicOp:

; 3631 : 			{
; 3632 : 				m_eOpinion = PUBLIC_OPINION_CIVIL_RESISTANCE;
; 3633 : 			}
; 3634 : 			else
; 3635 : 			{
; 3636 : 				m_eOpinion = PUBLIC_OPINION_REVOLUTIONARY_WAVE;
; 3637 : 			}
; 3638 : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 3639 : 			int iUnhappinessModifier = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER);

	mov	ecx, DWORD PTR [esi+292]
	push	66					; 00000042H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 3640 : 			m_iOpinionUnhappiness = ComputePublicOpinionUnhappiness(iDissatisfaction, iPerCityUnhappy, iUnhappyPerXPop, iUnhappinessModifier);

	push	eax
	lea	ecx, DWORD PTR _iUnhappyPerXPop$226473[esp+484]
	push	ecx
	lea	edx, DWORD PTR _iPerCityUnhappy$226472[esp+488]
	push	edx
	push	edi
	mov	ecx, esi
	call	?ComputePublicOpinionUnhappiness@CvPlayerCulture@@AAEHHAAH0H@Z ; CvPlayerCulture::ComputePublicOpinionUnhappiness

; 3641 : #else
; 3642 : 			m_iOpinionUnhappiness = ComputePublicOpinionUnhappiness(iDissatisfaction, iPerCityUnhappy, iUnhappyPerXPop);
; 3643 : #endif
; 3644 : 
; 3645 : 
; 3646 : 			// Find civ exerting greatest pressure
; 3647 : 			int iGreatestDominance = -1;
; 3648 : 			for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	ebp, ebp
	xor	edi, edi
	mov	DWORD PTR [esi+216], eax
	mov	DWORD PTR _iGreatestDominance$226480[esp+480], -1
	mov	DWORD PTR tv1499[esp+480], edi
$LL15@DoPublicOp:

; 3649 : 			{
; 3650 : 				CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3651 : 				if (iLoopPlayer != m_pPlayer->GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR [esi+292]
	add	edi, eax
	cmp	ebp, DWORD PTR [ecx+44]
	je	SHORT $LN14@DoPublicOp
	cmp	BYTE PTR [edi+2256], 0
	je	SHORT $LN14@DoPublicOp
	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN14@DoPublicOp

; 3652 : 				{
; 3653 : 					PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 3654 : 					if (eOtherCivIdeology == m_ePreferredIdeology)

	cmp	eax, DWORD PTR [esi+212]
	jne	SHORT $LN14@DoPublicOp

; 3655 : 					{
; 3656 : 						int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - m_pPlayer->GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);

	mov	ebx, DWORD PTR [esi+292]
	mov	eax, DWORD PTR [ebx+44]
	push	eax
	mov	ecx, edi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	push	ebp
	mov	ecx, ebx
	mov	edi, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	sub	edi, eax

; 3657 : 						if (iCulturalDominanceOverUs > 0)

	test	edi, edi
	jle	SHORT $LN14@DoPublicOp

; 3658 : 						{
; 3659 : 							if (iCulturalDominanceOverUs > iGreatestDominance)

	cmp	edi, DWORD PTR _iGreatestDominance$226480[esp+480]
	jle	SHORT $LN14@DoPublicOp

; 3660 : 							{
; 3661 : 								iGreatestDominance = iCulturalDominanceOverUs;

	mov	DWORD PTR _iGreatestDominance$226480[esp+480], edi

; 3662 : 								m_eOpinionBiggestInfluence = (PlayerTypes)iLoopPlayer;

	mov	DWORD PTR [esi+204], ebp
$LN14@DoPublicOp:
	mov	edi, DWORD PTR tv1499[esp+480]
	add	edi, 63236				; 0000f704H
	inc	ebp
	cmp	edi, 1391192				; 00153a58H
	mov	DWORD PTR tv1499[esp+480], edi
	jl	$LL15@DoPublicOp
$LN13@DoPublicOp:

; 3663 : 							}
; 3664 : 						}
; 3665 : 					}
; 3666 : 				}
; 3667 : 			}
; 3668 : 		}
; 3669 : 
; 3670 : 		// Build tooltip
; 3671 : 		if (strFreedomPressureString.size() > 0)

	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ

; 3672 : 		{
; 3673 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_FOR_FREEDOM");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	test	eax, eax
	jbe	SHORT $LN285@DoPublicOp
	lea	edx, DWORD PTR _locText$226496[esp+480]
	push	OFFSET $SG226498
	push	edx
	call	ebx
	add	esp, 8

; 3674 : 			locText << strFreedomPressureString;

	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locText$226496[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3675 : 			strFreedomPressureString = locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226496[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+480]
	test	eax, eax
	je	SHORT $LN221@DoPublicOp
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN220@DoPublicOp
$LN221@DoPublicOp:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN220@DoPublicOp:

; 3676 : 		}

	lea	ecx, DWORD PTR _locText$226496[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN285@DoPublicOp:
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ

; 3677 : 		if (strAutocracyPressureString.size() > 0)

	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	jbe	SHORT $LN288@DoPublicOp

; 3678 : 		{
; 3679 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_FOR_AUTOCRACY");

	lea	eax, DWORD PTR _locText$226500[esp+480]
	push	OFFSET $SG226502
	push	eax
	call	ebx
	add	esp, 8

; 3680 : 			locText << strAutocracyPressureString;

	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locText$226500[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3681 : 			strAutocracyPressureString = locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226500[esp+480]
	call	ebp
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	test	eax, eax
	je	SHORT $LN229@DoPublicOp
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN228@DoPublicOp
$LN229@DoPublicOp:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN228@DoPublicOp:

; 3682 : 		}

	lea	ecx, DWORD PTR _locText$226500[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN288@DoPublicOp:

; 3683 : 		if (strOrderPressureString.size() > 0)

	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	jbe	SHORT $LN6@DoPublicOp

; 3684 : 		{
; 3685 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_FOR_ORDER");

	lea	ecx, DWORD PTR _locText$226504[esp+480]
	push	OFFSET $SG226506
	push	ecx
	call	ebx
	add	esp, 8

; 3686 : 			locText << strOrderPressureString;

	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locText$226504[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3687 : 			strOrderPressureString = locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226504[esp+480]
	call	ebp
	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+480]
	test	eax, eax
	je	SHORT $LN237@DoPublicOp
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN236@DoPublicOp
$LN237@DoPublicOp:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN236@DoPublicOp:

; 3688 : 		}

	lea	ecx, DWORD PTR _locText$226504[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN6@DoPublicOp:

; 3689 : 
; 3690 : 		if (strWorldIdeologyPressureString.size() != 0)

	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	je	SHORT $LN5@DoPublicOp

; 3691 : 		{
; 3692 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_INFLUENCED_WORLD_IDEOLOGY");

	lea	edx, DWORD PTR _locText$226508[esp+480]
	push	OFFSET $SG226510
	push	edx
	call	ebx
	add	esp, 8

; 3693 : 			m_strOpinionTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226508[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 14		; 0000000eH
	call	ebp
	lea	edi, DWORD PTR [esi+220]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3694 : 			m_strOpinionTooltip += strWorldIdeologyPressureString;

	lea	eax, DWORD PTR _strWorldIdeologyPressureString$226374[esp+480]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3695 : 			m_strOpinionTooltip += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG226511
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3696 : 		}

	lea	ecx, DWORD PTR _locText$226508[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN5@DoPublicOp:

; 3697 : 
; 3698 : 		if ((strFreedomPressureString.size() + strAutocracyPressureString.size() + strOrderPressureString.size()) == 0)

	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+480]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	mov	edi, eax
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+480]
	add	edi, eax
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, edi
	jne	SHORT $LN4@DoPublicOp

; 3699 : 		{
; 3700 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_NOT_INFLUENCED");

	lea	ecx, DWORD PTR _locText$226513[esp+480]
	push	OFFSET $SG226515
	push	ecx
	call	ebx
	add	esp, 8

; 3701 : 			m_strOpinionTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226513[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 15		; 0000000fH
	call	ebp
	lea	edi, DWORD PTR [esi+220]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3702 : 		}

	lea	ecx, DWORD PTR _locText$226513[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3703 : 		else

	jmp	$LN3@DoPublicOp
$LN4@DoPublicOp:

; 3704 : 		{
; 3705 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_INFLUENCED_BY");

	lea	edx, DWORD PTR _locText$226517[esp+480]
	push	OFFSET $SG226519
	push	edx
	call	ebx
	add	esp, 8

; 3706 : 			m_strOpinionTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226517[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 16		; 00000010H
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	edi, DWORD PTR [esi+220]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3707 : 			m_strOpinionTooltip += strFreedomPressureString + strAutocracyPressureString + strOrderPressureString;

	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	eax, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	push	eax
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+484]
	push	ecx
	lea	edx, DWORD PTR $T238078[esp+488]
	push	edx
	call	ebp
	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+492]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T238079[esp+500]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+512], 17		; 00000011H
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+492], 18		; 00000012H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238079[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 17		; 00000011H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238078[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 16		; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3708 : 		}

	lea	ecx, DWORD PTR _locText$226517[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
$LN3@DoPublicOp:

; 3709 : 
; 3710 : 		if (m_ePreferredIdeology != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR [esi+212], -1
	je	SHORT $LN2@DoPublicOp

; 3711 : 		{
; 3712 : 			Localization::String locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_PREFERRED_IDEOLOGY");

	lea	eax, DWORD PTR _locText$226523[esp+480]
	push	OFFSET $SG226525
	push	eax
	call	ebx
	add	esp, 8

; 3713 : 			locText << GC.getPolicyBranchInfo(m_ePreferredIdeology)->GetDescription();

	mov	ecx, DWORD PTR [esi+212]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+492], 19		; 00000013H
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locText$226523[esp+484]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3714 : 			m_strOpinionTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226523[esp+480]
	call	ebp
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3715 : 		}

	lea	ecx, DWORD PTR _locText$226523[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN2@DoPublicOp:

; 3716 :  
; 3717 : 		if (m_iOpinionUnhappiness > 0)

	cmp	DWORD PTR [esi+216], 0
	jle	$LN1@DoPublicOp

; 3718 : 		{
; 3719 : 			Localization::String locText;

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 3720 : 			locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE1");

	lea	edx, DWORD PTR $T238081[esp+480]
	push	OFFSET $SG226530
	mov	bl, 20					; 00000014H
	push	edx
	mov	BYTE PTR __$EHRec$[esp+496], bl
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	edi, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 21		; 00000015H
	call	edi
	lea	ecx, DWORD PTR $T238081[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3721 : 			locText << m_iOpinionUnhappiness;

	mov	eax, DWORD PTR [esi+216]
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	call	ebp

; 3722 : 			m_strOpinionUnhappinessTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR tv1191[esp+480]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3723 : 
; 3724 : 			locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE2");

	lea	ecx, DWORD PTR $T238082[esp+480]
	push	OFFSET $SG226532
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 22		; 00000016H
	call	edi
	lea	ecx, DWORD PTR $T238082[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3725 : 			m_strOpinionUnhappinessTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR tv1191[esp+480]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3726 : 
; 3727 : 			locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE3");

	lea	edx, DWORD PTR $T238083[esp+480]
	push	OFFSET $SG226534
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 23		; 00000017H
	call	edi
	lea	ecx, DWORD PTR $T238083[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3728 : 			locText << iPerCityUnhappy;

	mov	eax, DWORD PTR _iPerCityUnhappy$226472[esp+480]
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	call	ebp

; 3729 : 			m_strOpinionUnhappinessTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR tv1191[esp+480]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3730 : 
; 3731 : 			locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE4");

	lea	ecx, DWORD PTR $T238084[esp+480]
	push	OFFSET $SG226536
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 24		; 00000018H
	call	edi
	mov	BYTE PTR __$EHRec$[esp+488], bl
	lea	ecx, DWORD PTR $T238084[esp+480]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3732 : 			locText << iUnhappyPerXPop;

	mov	edx, DWORD PTR _iUnhappyPerXPop$226473[esp+480]
	push	edx
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	call	ebp

; 3733 : 			m_strOpinionUnhappinessTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR tv1191[esp+480]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3734 : 
; 3735 : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 3736 : 			int iUnhappinessModifier = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER);

	mov	ecx, DWORD PTR [esi+292]
	push	66					; 00000042H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	esi, eax

; 3737 : 			locText = Localization::Lookup("TXT_KEY_CO_OPINION_TT_UNHAPPINESS_LINE5");

	lea	eax, DWORD PTR $T238085[esp+480]
	push	OFFSET $SG226539
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	mov	BYTE PTR __$EHRec$[esp+492], 25		; 00000019H
	call	edi
	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T238085[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], bl
	call	edi

; 3738 : 			locText << -iUnhappinessModifier;

	neg	esi
	push	esi
	lea	ecx, DWORD PTR _locText$226528[esp+484]
	call	ebp

; 3739 : 			m_strOpinionUnhappinessTooltip += locText.toUTF8();

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR tv1191[esp+480]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3740 : #endif
; 3741 : 		}

	lea	ecx, DWORD PTR _locText$226528[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 4
	call	edi
$LN1@DoPublicOp:

; 3742 : 	}

	lea	ecx, DWORD PTR _strOrderPressureString$226380[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[esp+480]
	mov	BYTE PTR __$EHRec$[esp+488], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	or	ebp, -1
$LN287@DoPublicOp:

; 3743 : }

	lea	ecx, DWORD PTR _locOverview$[esp+480]
	mov	DWORD PTR __$EHRec$[esp+488], ebp
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN75@DoPublicOp:
	mov	ecx, DWORD PTR __$EHRec$[esp+480]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 464				; 000001d0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$0:
	lea	ecx, DWORD PTR _locOverview$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strWorldIdeologyPressureString$226374[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strFreedomPressureString$226376[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strAutocracyPressureString$226378[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$4:
	lea	ecx, DWORD PTR _strOrderPressureString$226380[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$5:
	lea	ecx, DWORD PTR _sTemp$226383[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$6:
	lea	ecx, DWORD PTR _sIcons$226386[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$7:
	lea	ecx, DWORD PTR _sTemp$226394[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$8:
	lea	ecx, DWORD PTR _sIcons$226397[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$9:
	lea	ecx, DWORD PTR _sTemp$226405[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$10:
	lea	ecx, DWORD PTR _sIcons$226408[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$11:
	lea	ecx, DWORD PTR _locText$226496[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$12:
	lea	ecx, DWORD PTR _locText$226500[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$13:
	lea	ecx, DWORD PTR _locText$226504[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$14:
	lea	ecx, DWORD PTR _locText$226508[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$15:
	lea	ecx, DWORD PTR _locText$226513[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$16:
	lea	ecx, DWORD PTR _locText$226517[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$17:
	lea	ecx, DWORD PTR $T238078[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$18:
	lea	ecx, DWORD PTR $T238079[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$19:
	lea	ecx, DWORD PTR _locText$226523[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$20:
	lea	ecx, DWORD PTR _locText$226528[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$21:
	lea	ecx, DWORD PTR $T238081[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$22:
	lea	ecx, DWORD PTR $T238082[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$23:
	lea	ecx, DWORD PTR $T238083[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$24:
	lea	ecx, DWORD PTR $T238084[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ$25:
	lea	ecx, DWORD PTR $T238085[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoPublicOpinion@CvPlayerCulture@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoPublicOpinion@CvPlayerCulture@@QAEXXZ ENDP		; CvPlayerCulture::DoPublicOpinion
PUBLIC	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
; Function compile flags: /Ogtpy
;	COMDAT ?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_iPressureForOrder$ = -36				; size = 4
_iPressureForAutocracy$ = -32				; size = 4
_iPressureForFreedom$ = -28				; size = 4
_iDissatisfaction$ = -24				; size = 4
_eAutocracyBranch$ = -20				; size = 4
tv358 = -16						; size = 4
_eFreedomBranch$ = -12					; size = 4
_eOrderBranch$ = -8					; size = 4
_iPerCityUnhappy$ = -4					; size = 4
_eOtherCivIdeology$226564 = -4				; size = 4
_iUnhappyPerXPop$ = 8					; size = 4
_eBranch$ = 8						; size = 4
?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z PROC ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness, COMDAT
; _this$ = ecx

; 3747 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi

; 3748 : 	int iDissatisfaction = 0;
; 3749 : 
; 3750 : 	PolicyBranchTypes eFreedomBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();
; 3751 : 	PolicyBranchTypes eAutocracyBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	mov	ebx, ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	push	edi

; 3752 : 	PolicyBranchTypes eOrderBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	xor	ebp, ebp
	mov	DWORD PTR _iDissatisfaction$[esp+52], ebp
	mov	DWORD PTR _eFreedomBranch$[esp+52], ecx
	mov	DWORD PTR _eAutocracyBranch$[esp+52], esi
	mov	DWORD PTR _eOrderBranch$[esp+52], edi

; 3753 : 
; 3754 : 	if (eFreedomBranch == NO_POLICY_BRANCH_TYPE || eAutocracyBranch == NO_POLICY_BRANCH_TYPE || eOrderBranch == NO_POLICY_BRANCH_TYPE)

	cmp	ecx, -1
	je	$LN29@ComputeHyp
	cmp	esi, -1
	je	$LN29@ComputeHyp
	cmp	edi, -1
	je	$LN29@ComputeHyp

; 3757 : 	}
; 3758 : 
; 3759 : 	// Start with World Congress
; 3760 : 	int iPressureForFreedom = GC.getGame().GetGameLeagues()->GetPressureForIdeology(m_pPlayer->GetID(), eFreedomBranch);

	mov	eax, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z ; CvGameLeagues::GetPressureForIdeology

; 3761 : 	int iPressureForAutocracy = GC.getGame().GetGameLeagues()->GetPressureForIdeology(m_pPlayer->GetID(), eAutocracyBranch);

	mov	ecx, DWORD PTR [ebx+292]
	mov	DWORD PTR _iPressureForFreedom$[esp+52], eax
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z ; CvGameLeagues::GetPressureForIdeology

; 3762 : 	int iPressureForOrder = GC.getGame().GetGameLeagues()->GetPressureForIdeology(m_pPlayer->GetID(), eOrderBranch);

	mov	edx, DWORD PTR [ebx+292]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _iPressureForAutocracy$[esp+52], eax
	mov	eax, DWORD PTR [edx+44]
	push	edi
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetPressureForIdeology@CvGameLeagues@@QAEHW4PlayerTypes@@W4PolicyBranchTypes@@@Z ; CvGameLeagues::GetPressureForIdeology
	mov	edi, eax
	xor	esi, esi
	mov	DWORD PTR _iPressureForOrder$[esp+52], edi
	mov	DWORD PTR tv358[esp+52], esi
$LL28@ComputeHyp:

; 3766 : 	{
; 3767 : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3768 : 		if (iLoopPlayer != m_pPlayer->GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR [ebx+292]
	add	esi, eax
	cmp	ebp, DWORD PTR [ecx+44]
	je	$LN27@ComputeHyp
	cmp	BYTE PTR [esi+2256], 0
	je	SHORT $LN27@ComputeHyp
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN27@ComputeHyp

; 3769 : 		{
; 3770 : 			PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eOtherCivIdeology$226564[esp+52], eax

; 3771 : 			if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	je	SHORT $LN27@ComputeHyp

; 3772 : 			{
; 3773 : 				int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(m_pPlayer->GetID()) - m_pPlayer->GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);

	mov	edi, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [edi+44]
	push	eax
	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	push	ebp
	mov	ecx, edi
	mov	esi, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	sub	esi, eax

; 3774 : 				if (iCulturalDominanceOverUs > 0)

	test	esi, esi
	jle	SHORT $LN77@ComputeHyp

; 3775 : 				{
; 3776 : 					if (eOtherCivIdeology == eFreedomBranch)

	mov	eax, DWORD PTR _eOtherCivIdeology$226564[esp+52]
	cmp	eax, DWORD PTR _eFreedomBranch$[esp+52]
	jne	SHORT $LN22@ComputeHyp

; 3777 : 					{
; 3778 : 						iPressureForFreedom += iCulturalDominanceOverUs;

	add	DWORD PTR _iPressureForFreedom$[esp+52], esi
	jmp	SHORT $LN77@ComputeHyp
$LN22@ComputeHyp:

; 3779 : 					}
; 3780 : 					else if (eOtherCivIdeology == eAutocracyBranch)

	cmp	eax, DWORD PTR _eAutocracyBranch$[esp+52]
	jne	SHORT $LN20@ComputeHyp

; 3781 : 					{
; 3782 : 						iPressureForAutocracy += iCulturalDominanceOverUs;

	add	DWORD PTR _iPressureForAutocracy$[esp+52], esi

; 3783 : 					}
; 3784 : 					else

	jmp	SHORT $LN77@ComputeHyp
$LN20@ComputeHyp:

; 3785 : 					{
; 3786 : 						iPressureForOrder += iCulturalDominanceOverUs;

	add	DWORD PTR _iPressureForOrder$[esp+52], esi
$LN77@ComputeHyp:
	mov	edi, DWORD PTR _iPressureForOrder$[esp+52]
$LN27@ComputeHyp:

; 3763 : 
; 3764 : 	// Look at each civ
; 3765 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	mov	esi, DWORD PTR tv358[esp+52]
	add	esi, 63236				; 0000f704H
	inc	ebp
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv358[esp+52], esi
	jl	$LL28@ComputeHyp

; 3787 : 					}
; 3788 : 				}
; 3789 : 			}
; 3790 : 		}
; 3791 : 	}
; 3792 : 
; 3793 : 	if (eBranch == eFreedomBranch)

	mov	eax, DWORD PTR _eBranch$[esp+48]
	mov	esi, DWORD PTR _eFreedomBranch$[esp+52]
	cmp	eax, esi
	jne	SHORT $LN18@ComputeHyp

; 3794 : 	{
; 3795 : 		if (iPressureForFreedom < (iPressureForAutocracy + iPressureForOrder))

	mov	eax, DWORD PTR _iPressureForAutocracy$[esp+52]
	mov	ecx, DWORD PTR _iPressureForFreedom$[esp+52]
	lea	edx, DWORD PTR [edi+eax]
	cmp	ecx, edx
	jge	SHORT $LN6@ComputeHyp

; 3796 : 		{
; 3797 : 			if (iPressureForAutocracy > iPressureForOrder)

	cmp	eax, edi

; 3798 : 			{
; 3799 : 				m_ePreferredIdeology = eAutocracyBranch;

	mov	edx, DWORD PTR _eAutocracyBranch$[esp+52]
	jg	SHORT $LN78@ComputeHyp
$LN74@ComputeHyp:

; 3800 : 			}
; 3801 : 			else if (iPressureForOrder >= iPressureForAutocracy)
; 3802 : 			{
; 3803 : 				m_ePreferredIdeology = eOrderBranch;

	mov	edx, DWORD PTR _eOrderBranch$[esp+52]
$LN78@ComputeHyp:

; 3804 : 			}
; 3805 : 			iDissatisfaction = (iPressureForAutocracy + iPressureForOrder) - iPressureForFreedom;

	sub	edi, ecx
	add	edi, eax
	mov	DWORD PTR [ebx+212], edx
	mov	DWORD PTR _iDissatisfaction$[esp+52], edi

; 3806 : 		}
; 3807 : 	}

	jmp	SHORT $LN6@ComputeHyp
$LN18@ComputeHyp:

; 3808 : 	else if (eBranch == eAutocracyBranch)

	mov	edx, DWORD PTR _eAutocracyBranch$[esp+52]
	cmp	eax, edx
	jne	SHORT $LN12@ComputeHyp

; 3809 : 	{
; 3810 : 		if (iPressureForAutocracy < (iPressureForFreedom + iPressureForOrder))

	mov	eax, DWORD PTR _iPressureForFreedom$[esp+52]
	mov	ecx, DWORD PTR _iPressureForAutocracy$[esp+52]
	lea	edx, DWORD PTR [edi+eax]
	cmp	ecx, edx
	jge	SHORT $LN6@ComputeHyp

; 3811 : 		{
; 3812 : 			if (iPressureForFreedom >= iPressureForOrder)

	cmp	eax, edi
	jl	SHORT $LN74@ComputeHyp
	sub	edi, ecx
	add	edi, eax

; 3813 : 			{
; 3814 : 				m_ePreferredIdeology = eFreedomBranch;

	mov	DWORD PTR [ebx+212], esi
	mov	DWORD PTR _iDissatisfaction$[esp+52], edi
	jmp	SHORT $LN6@ComputeHyp
$LN12@ComputeHyp:

; 3815 : 			}
; 3816 : 			else if (iPressureForOrder > iPressureForFreedom)
; 3817 : 			{
; 3818 : 				m_ePreferredIdeology = eOrderBranch;
; 3819 : 			}
; 3820 : 			iDissatisfaction = (iPressureForFreedom + iPressureForOrder) - iPressureForAutocracy;
; 3821 : 		}
; 3822 : 	}
; 3823 : 	else
; 3824 : 	{
; 3825 : 		if (iPressureForOrder < (iPressureForFreedom + iPressureForAutocracy))

	mov	eax, DWORD PTR _iPressureForAutocracy$[esp+52]
	mov	ecx, DWORD PTR _iPressureForFreedom$[esp+52]
	lea	ebp, DWORD PTR [eax+ecx]
	cmp	edi, ebp
	jge	SHORT $LN6@ComputeHyp

; 3826 : 		{
; 3827 : 			if (iPressureForFreedom > iPressureForAutocracy)

	cmp	ecx, eax
	jle	SHORT $LN73@ComputeHyp

; 3828 : 			{
; 3829 : 				m_ePreferredIdeology = eFreedomBranch;

	mov	DWORD PTR [ebx+212], esi
	jmp	SHORT $LN3@ComputeHyp
$LN73@ComputeHyp:

; 3830 : 			}
; 3831 : 			else if (iPressureForAutocracy >= iPressureForFreedom)
; 3832 : 			{
; 3833 : 				m_ePreferredIdeology = eAutocracyBranch;

	mov	DWORD PTR [ebx+212], edx
$LN3@ComputeHyp:

; 3834 : 			}
; 3835 : 			iDissatisfaction = (iPressureForFreedom + iPressureForAutocracy) - iPressureForOrder;

	sub	eax, edi
	add	eax, ecx
	mov	DWORD PTR _iDissatisfaction$[esp+52], eax
$LN6@ComputeHyp:

; 3836 : 		}
; 3837 : 	}
; 3838 : 
; 3839 : 	int iPerCityUnhappy = 1;
; 3840 : 	int iUnhappyPerXPop = 10;
; 3841 : 
; 3842 : 	if (iDissatisfaction == 0)

	mov	esi, DWORD PTR _iDissatisfaction$[esp+52]
	mov	DWORD PTR _iPerCityUnhappy$[esp+52], 1
	mov	DWORD PTR _iUnhappyPerXPop$[esp+48], 10	; 0000000aH
	test	esi, esi

; 3843 : 	{
; 3844 : 		return 0;

	je	SHORT $LN29@ComputeHyp

; 3845 : 	}
; 3846 : 	else
; 3847 : 	{
; 3848 : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 3849 : 		int iUnhappinessModifier = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER);

	mov	ecx, DWORD PTR [ebx+292]
	push	66					; 00000042H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 3850 : 		return ComputePublicOpinionUnhappiness(iDissatisfaction, iPerCityUnhappy, iUnhappyPerXPop, iUnhappinessModifier);

	push	eax
	lea	eax, DWORD PTR _iUnhappyPerXPop$[esp+52]
	push	eax
	lea	ecx, DWORD PTR _iPerCityUnhappy$[esp+60]
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?ComputePublicOpinionUnhappiness@CvPlayerCulture@@AAEHHAAH0H@Z ; CvPlayerCulture::ComputePublicOpinionUnhappiness
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3851 : #else
; 3852 : 		return ComputePublicOpinionUnhappiness(iDissatisfaction, iPerCityUnhappy, iUnhappyPerXPop);
; 3853 : #endif
; 3854 : 	}
; 3855 : }

	add	esp, 36					; 00000024H
	ret	4
$LN29@ComputeHyp:
	pop	edi
	pop	esi
	pop	ebp

; 3755 : 	{
; 3756 : 		return 0;

	xor	eax, eax
	pop	ebx

; 3851 : #else
; 3852 : 		return ComputePublicOpinionUnhappiness(iDissatisfaction, iPerCityUnhappy, iUnhappyPerXPop);
; 3853 : #endif
; 3854 : 	}
; 3855 : }

	add	esp, 36					; 00000024H
	ret	4
?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ENDP ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
_TEXT	ENDS
PUBLIC	?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z ; CvPlayerCulture::WantsDiplomatDoingPropaganda
; Function compile flags: /Ogtpy
;	COMDAT ?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eFirstPlayer$ = -12					; size = 4
tv222 = -8						; size = 4
_this$ = -4						; size = 4
_eTargetPlayer$ = 8					; size = 4
?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlayerCulture::WantsDiplomatDoingPropaganda, COMDAT
; _this$ = ecx

; 3858 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 3859 : 	// only return the top two
; 3860 : 	int iFirstValue = NO_INFLUENCE_LEVEL;

	or	ebp, -1
	push	esi

; 3861 : 	int iSecondValue = NO_INFLUENCE_LEVEL;
; 3862 : 	PlayerTypes eFirstPlayer = NO_PLAYER;
; 3863 : 	PlayerTypes eSecondPlayer = NO_PLAYER;
; 3864 : 
; 3865 : 	// only do this if everybody is exotic
; 3866 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	esi, esi
	xor	eax, eax
	push	edi
	mov	DWORD PTR _this$[esp+28], ecx
	mov	ebx, ebp
	mov	edi, ebp
	mov	DWORD PTR _eFirstPlayer$[esp+28], ebp
	mov	DWORD PTR tv222[esp+28], eax
	jmp	SHORT $LN10@WantsDiplo
$LL30@WantsDiplo:

; 3859 : 	// only return the top two
; 3860 : 	int iFirstValue = NO_INFLUENCE_LEVEL;

	mov	ecx, DWORD PTR _this$[esp+28]
$LN10@WantsDiplo:

; 3867 : 	{
; 3868 : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 3869 : 		if (ePlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ecx+292]
	cmp	esi, DWORD PTR [edx+44]
	je	SHORT $LN9@WantsDiplo

; 3870 : 		{
; 3871 : 			continue;
; 3872 : 		}
; 3873 : 
; 3874 : 		if (!GET_PLAYER(ePlayer).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [eax+edx+2256], 0
	je	SHORT $LN9@WantsDiplo

; 3875 : 		{
; 3876 : 			continue;
; 3877 : 		}
; 3878 : 
; 3879 : 		int iInfluenceLevel = GetInfluenceLevel(ePlayer);

	push	esi
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel

; 3880 : 		if (iInfluenceLevel < INFLUENCE_LEVEL_EXOTIC)

	cmp	eax, 1
	jl	SHORT $LN26@WantsDiplo

; 3883 : 		}
; 3884 : 		else if (iInfluenceLevel > iFirstValue && iInfluenceLevel > iSecondValue)

	cmp	eax, ebx
	jle	SHORT $LN3@WantsDiplo
	cmp	eax, edi
	jle	SHORT $LN9@WantsDiplo

; 3885 : 		{
; 3886 : 			iSecondValue = iFirstValue;
; 3887 : 			eSecondPlayer = eFirstPlayer;

	mov	ebp, DWORD PTR _eFirstPlayer$[esp+28]
	mov	edi, ebx

; 3888 : 			iFirstValue = iInfluenceLevel;

	mov	ebx, eax

; 3889 : 			eFirstPlayer = ePlayer;

	mov	DWORD PTR _eFirstPlayer$[esp+28], esi
	jmp	SHORT $LN9@WantsDiplo
$LN3@WantsDiplo:

; 3890 : 		}
; 3891 : 		else if (iInfluenceLevel > iSecondValue)

	cmp	eax, edi
	jle	SHORT $LN9@WantsDiplo

; 3892 : 		{
; 3893 : 			iSecondValue = iInfluenceLevel;

	mov	edi, eax

; 3894 : 			eSecondPlayer = ePlayer;

	mov	ebp, esi
$LN9@WantsDiplo:
	mov	eax, DWORD PTR tv222[esp+28]
	add	eax, 63236				; 0000f704H
	inc	esi
	mov	DWORD PTR tv222[esp+28], eax
	cmp	eax, 1391192				; 00153a58H
	jb	SHORT $LL30@WantsDiplo

; 3895 : 		}
; 3896 : 	}
; 3897 : 
; 3898 : 	return (eFirstPlayer == eTargetPlayer || eSecondPlayer == eTargetPlayer);

	mov	eax, DWORD PTR _eTargetPlayer$[esp+24]
	cmp	DWORD PTR _eFirstPlayer$[esp+28], eax
	je	SHORT $LN13@WantsDiplo
	cmp	ebp, eax
	je	SHORT $LN13@WantsDiplo
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 3899 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN26@WantsDiplo:
	pop	edi
	pop	esi
	pop	ebp

; 3881 : 		{
; 3882 : 			return false;

	xor	al, al
	pop	ebx

; 3899 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN13@WantsDiplo:
	pop	edi
	pop	esi
	pop	ebp

; 3895 : 		}
; 3896 : 	}
; 3897 : 
; 3898 : 	return (eFirstPlayer == eTargetPlayer || eSecondPlayer == eTargetPlayer);

	mov	eax, 1
	pop	ebx

; 3899 : }

	add	esp, 12					; 0000000cH
	ret	4
?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::WantsDiplomatDoingPropaganda
_TEXT	ENDS
PUBLIC	?GetMaxPropagandaDiplomatsWanted@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetMaxPropagandaDiplomatsWanted
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxPropagandaDiplomatsWanted@CvPlayerCulture@@QBEHXZ
_TEXT	SEGMENT
?GetMaxPropagandaDiplomatsWanted@CvPlayerCulture@@QBEHXZ PROC ; CvPlayerCulture::GetMaxPropagandaDiplomatsWanted, COMDAT
; _this$ = ecx

; 3903 : {

	push	ebx
	push	esi
	push	edi

; 3904 : 	int iRtnValue = 0;

	xor	ebx, ebx
	mov	edi, ecx

; 3905 : 
; 3906 : 	// determine which civs have run out of techs to steal
; 3907 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	esi, esi
	npad	7
$LL5@GetMaxProp:

; 3908 : 	{
; 3909 : 		PlayerTypes eOtherPlayer = (PlayerTypes)ui;
; 3910 : 
; 3911 : 		if (m_pPlayer->GetID() == eOtherPlayer)

	mov	eax, DWORD PTR [edi+292]
	cmp	DWORD PTR [eax+44], esi
	je	SHORT $LN4@GetMaxProp

; 3912 : 		{
; 3913 : 			continue;
; 3914 : 		}
; 3915 : 		
; 3916 : 		if (WantsDiplomatDoingPropaganda(eOtherPlayer))

	push	esi
	mov	ecx, edi
	call	?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z ; CvPlayerCulture::WantsDiplomatDoingPropaganda
	test	al, al
	je	SHORT $LN4@GetMaxProp

; 3917 : 		{
; 3918 : 			iRtnValue++;

	inc	ebx
$LN4@GetMaxProp:

; 3905 : 
; 3906 : 	// determine which civs have run out of techs to steal
; 3907 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	inc	esi
	cmp	esi, 22					; 00000016H
	jb	SHORT $LL5@GetMaxProp
	pop	edi
	pop	esi

; 3919 : 		}
; 3920 : 	}
; 3921 : 
; 3922 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 3923 : }

	ret	0
?GetMaxPropagandaDiplomatsWanted@CvPlayerCulture@@QBEHXZ ENDP ; CvPlayerCulture::GetMaxPropagandaDiplomatsWanted
_TEXT	ENDS
PUBLIC	?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z ; CvPlayerCulture::LogThemedBuilding
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z
_TEXT	SEGMENT
tv245 = -380						; size = 4
tv237 = -380						; size = 4
_strTurn$ = -376					; size = 28
_strLine$ = -348					; size = 28
_strBonus$ = -320					; size = 28
_strPlayerName$ = -292					; size = 28
$T238571 = -264						; size = 28
$T238568 = -236						; size = 28
$T238567 = -208						; size = 28
$T238570 = -180						; size = 28
$T238566 = -152						; size = 28
$T238564 = -124						; size = 28
$T238565 = -96						; size = 28
$T238569 = -68						; size = 28
_strLog$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_iCityID$ = 8						; size = 4
_eBuilding$ = 12					; size = 4
_iBonus$ = 16						; size = 4
?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z PROC ; CvPlayerCulture::LogThemedBuilding, COMDAT
; _this$ = ecx

; 4122 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 368				; 00000170H
	push	edi
	mov	edi, ecx

; 4123 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@LogThemedB
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN2@LogThemedB

; 4124 : 	{
; 4125 : 		return;
; 4126 : 	}
; 4127 : 
; 4128 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+384]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4129 : 	FILogFile* pLog;
; 4130 : 	CvString strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi+292]
	mov	DWORD PTR __$EHRec$[esp+392], 0
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN25@LogThemedB
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN25@LogThemedB:
	push	ebx
	push	ebp
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$[esp+400]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+404], 1

; 4131 : 	pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _strPlayerName$[esp+396]
	push	eax
	lea	ecx, DWORD PTR $T238564[esp+400]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z ; CvPlayerCulture::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+404], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T238564[esp+396]
	mov	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+404], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4132 : 
; 4133 : 	CvString strLine;

	lea	ecx, DWORD PTR _strLine$[esp+396]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4134 : 	CvString strTurn;

	lea	ecx, DWORD PTR _strTurn$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4135 : 	CvString strBonus;

	lea	ecx, DWORD PTR _strBonus$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4136 : 	CvBuildingEntry *pkBldg = GC.getBuildingInfo(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$[esp+392]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+408], 5
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax

; 4137 : 	if (pkBldg)

	test	ebx, ebx
	je	$LN1@LogThemedB

; 4138 : 	{
; 4139 : 		strTurn.Format (", %d,", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTurn$[esp+400]
	push	OFFSET $SG226814
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4140 : 		strBonus.Format (", Bonus: %d", iBonus);

	mov	eax, DWORD PTR _iBonus$[esp+404]
	push	eax
	lea	ecx, DWORD PTR _strBonus$[esp+412]
	push	OFFSET $SG226815
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4141 : 		strLine = strPlayerName + strTurn + "Themed Building in, " + m_pPlayer->getCity(iCityID)->getName() + ", " + pkBldg->GetDescription() + strBonus;

	mov	eax, DWORD PTR _iCityID$[esp+416]
	mov	ecx, DWORD PTR [edi+292]
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR $T238565[esp+396]
	push	edx
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv237[esp+396], eax
	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	ecx, DWORD PTR _strTurn$[esp+396]
	push	ecx
	lea	edx, DWORD PTR _strPlayerName$[esp+400]
	push	edx
	lea	eax, DWORD PTR $T238566[esp+404]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+416], 6
	call	esi
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG226824
	push	eax
	lea	ecx, DWORD PTR $T238567[esp+416]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+428], 7
	call	edi
	mov	edx, DWORD PTR tv237[esp+420]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T238568[esp+428]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+440], 8
	call	esi
	push	OFFSET $SG226823
	push	eax
	lea	ecx, DWORD PTR $T238569[esp+440]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+452], 9
	call	edi
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv245[esp+396], eax
	lea	ecx, DWORD PTR [ebx+36]
	mov	BYTE PTR __$EHRec$[esp+404], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR tv245[esp+396]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T238570[esp+404]
	push	eax
	call	edi
	lea	ecx, DWORD PTR _strBonus$[esp+408]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T238571[esp+416]
	mov	bl, 11					; 0000000bH
	push	edx
	mov	BYTE PTR __$EHRec$[esp+428], bl
	call	esi
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+404], 12		; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLine$[esp+400]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T238571[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238570[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238569[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238568[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238567[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238566[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238565[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4142 : 
; 4143 : 		pLog->Msg(strLine);

	lea	ecx, DWORD PTR _strLine$[esp+396]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	add	esp, 8
$LN1@LogThemedB:

; 4144 : 	}
; 4145 : }

	lea	ecx, DWORD PTR _strBonus$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTurn$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLine$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+396]
	mov	DWORD PTR __$EHRec$[esp+404], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
	pop	ebx
$LN2@LogThemedB:
	mov	ecx, DWORD PTR __$EHRec$[esp+384]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 380				; 0000017cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$0:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$1:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$2:
	lea	ecx, DWORD PTR $T238564[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$3:
	lea	ecx, DWORD PTR _strLine$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$4:
	lea	ecx, DWORD PTR _strTurn$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$5:
	lea	ecx, DWORD PTR _strBonus$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$6:
	lea	ecx, DWORD PTR $T238565[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$7:
	lea	ecx, DWORD PTR $T238566[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$8:
	lea	ecx, DWORD PTR $T238567[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$9:
	lea	ecx, DWORD PTR $T238568[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$10:
	lea	ecx, DWORD PTR $T238569[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$11:
	lea	ecx, DWORD PTR $T238570[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z$12:
	lea	ecx, DWORD PTR $T238571[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z ENDP ; CvPlayerCulture::LogThemedBuilding
PUBLIC	?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z ; CvPlayerCulture::LogSwapWorks
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_strLine$ = -208					; size = 28
_strTurn$ = -180					; size = 28
_strPlayerName$ = -152					; size = 28
$T238668 = -124						; size = 28
$T238669 = -96						; size = 28
$T238670 = -68						; size = 28
_strLog$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eOtherPlayer$ = 8					; size = 4
_iWorkDiscarded$ = 12					; size = 4
_iWorkAcquired$ = 16					; size = 4
?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z PROC ; CvPlayerCulture::LogSwapWorks, COMDAT
; _this$ = ecx

; 4148 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 4149 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogSwapWor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogSwapWor

; 4150 : 	{
; 4151 : 		return;
; 4152 : 	}
; 4153 : 
; 4154 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+212]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4155 : 	FILogFile* pLog;
; 4156 : 	CvString strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi+292]
	mov	DWORD PTR __$EHRec$[esp+220], 0
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN18@LogSwapWor
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN18@LogSwapWor:
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+224], 1

; 4157 : 	pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _strPlayerName$[esp+216]
	push	eax
	lea	ecx, DWORD PTR $T238668[esp+220]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z ; CvPlayerCulture::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+224], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T238668[esp+216]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4158 : 
; 4159 : 	CvString strLine;

	lea	ecx, DWORD PTR _strLine$[esp+216]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4160 : 	strLine.Format ("Acquired Work from Player: %d, Discarded: %d, Acquired: %d", (int)eOtherPlayer, iWorkDiscarded, iWorkAcquired);

	mov	ecx, DWORD PTR _iWorkAcquired$[esp+212]
	mov	edx, DWORD PTR _iWorkDiscarded$[esp+212]
	mov	eax, DWORD PTR _eOtherPlayer$[esp+212]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLine$[esp+228]
	push	OFFSET $SG226839
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+244], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4161 : 	CvString strTurn;

	lea	ecx, DWORD PTR _strTurn$[esp+216]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4162 : 	strTurn.Format (", %d,", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+224], 4
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTurn$[esp+220]
	push	OFFSET $SG226841
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4163 : 	strLine = strPlayerName + strTurn + strLine;

	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	eax, DWORD PTR _strTurn$[esp+228]
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$[esp+232]
	push	ecx
	lea	edx, DWORD PTR $T238669[esp+236]
	push	edx
	call	edi
	lea	ecx, DWORD PTR _strLine$[esp+240]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T238670[esp+248]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	edi
	add	esp, 36					; 00000024H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+224], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLine$[esp+220]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+224], 5
	lea	ecx, DWORD PTR $T238670[esp+216]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T238669[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4164 : 
; 4165 : 	pLog->Msg(strLine);

	lea	ecx, DWORD PTR _strLine$[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 4166 : }

	lea	ecx, DWORD PTR _strTurn$[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLine$[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
$LN1@LogSwapWor:
	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$1:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$2:
	lea	ecx, DWORD PTR $T238668[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$3:
	lea	ecx, DWORD PTR _strLine$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$4:
	lea	ecx, DWORD PTR _strTurn$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$5:
	lea	ecx, DWORD PTR $T238669[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z$6:
	lea	ecx, DWORD PTR $T238670[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z ENDP ; CvPlayerCulture::LogSwapWorks
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvPlayerCulture@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PolicyBranchTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvPlayerCulture@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T238835 = 8						; size = 4
$T238751 = 8						; size = 4
$T238750 = 8						; size = 4
$T238749 = 8						; size = 4
$T238745 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerCulture@@@Z PROC	; operator<<, COMDAT

; 4286 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 4287 : 	uint uiVersion = 6;
; 4288 : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 6
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4289 : 
; 4290 : 	vector<CvPlot *>::const_iterator it;
; 4291 : 	saveTo << readFrom.m_aDigCompletePlots.size();

	mov	edi, DWORD PTR _readFrom$[esp+16]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR $T238745[esp+16]
	sar	ecx, 2
	mov	DWORD PTR $T238745[esp+16], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4292 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 4293 : 	for (it = readFrom.m_aDigCompletePlots.begin(); it != readFrom.m_aDigCompletePlots.end(); ++it)
; 4294 : #else
; 4295 : 	for(it = readFrom.m_aDigCompletePlots.begin(); it != readFrom.m_aDigCompletePlots.end(); it++)

	mov	ebx, DWORD PTR [edi+4]
	cmp	ebx, DWORD PTR [edi+8]
	je	SHORT $LN4@operator@4
$LL23@operator@4:

; 4296 : #endif
; 4297 : 	{
; 4298 : 		CvPlot *pPlot = *it;

	mov	ebp, DWORD PTR [ebx]

; 4299 : 		saveTo << pPlot->getX();

	movsx	eax, WORD PTR [ebp]
	lea	ecx, DWORD PTR $T238749[esp+16]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T238749[esp+20], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4300 : 		saveTo << pPlot->getY();

	movsx	edx, WORD PTR [ebp+2]
	lea	eax, DWORD PTR $T238750[esp+16]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T238750[esp+20], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	cmp	ebx, DWORD PTR [edi+8]
	jne	SHORT $LL23@operator@4
$LN4@operator@4:

; 4301 : 	}
; 4302 : 
; 4303 : 	saveTo << readFrom.m_iLastTurnLifetimeCulture;

	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4304 : 	saveTo << MAX_MAJOR_CIVS;

	lea	edx, DWORD PTR $T238751[esp+16]
	mov	ebp, 22					; 00000016H
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T238751[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ebx, DWORD PTR [edi+108]
$LL3@operator@4:

; 4305 : 	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
; 4306 : 	{
; 4307 : 		saveTo << readFrom.m_aiCulturalInfluence[iI];

	lea	eax, DWORD PTR [ebx-88]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4308 : 		saveTo << readFrom.m_aiLastTurnCulturalInfluence[iI];

	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL3@operator@4

; 4309 : 	}
; 4310 : 
; 4311 : 	saveTo << readFrom.m_bReportedTwoCivsAway;

	lea	ecx, DWORD PTR [edi+196]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 4312 : 	saveTo << readFrom.m_bReportedOneCivAway;

	lea	edx, DWORD PTR [edi+197]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 4313 : 
; 4314 : 	saveTo << readFrom.m_eOpinion;

	mov	eax, DWORD PTR [edi+200]
	lea	ecx, DWORD PTR $T238835[esp+16]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T238835[esp+20], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4315 : 	saveTo << readFrom.m_ePreferredIdeology;

	lea	edx, DWORD PTR [edi+212]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PolicyBranchTypes@@@Z ; operator<<
	add	esp, 8

; 4316 : 	saveTo << readFrom.m_iOpinionUnhappiness;

	lea	eax, DWORD PTR [edi+216]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4317 : 	saveTo << readFrom.m_strOpinionTooltip;

	lea	ecx, DWORD PTR [edi+220]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 4318 : 	saveTo << readFrom.m_strOpinionUnhappinessTooltip;

	lea	edx, DWORD PTR [edi+248]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 4319 : 	saveTo << readFrom.m_eOpinionBiggestInfluence;

	lea	eax, DWORD PTR [edi+204]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 4320 : 	saveTo << readFrom.m_iTurnIdeologySwitch;

	lea	ecx, DWORD PTR [edi+208]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4321 : 
; 4322 : 	saveTo << readFrom.m_iSwappableWritingIndex;

	lea	edx, DWORD PTR [edi+276]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4323 : 	saveTo << readFrom.m_iSwappableArtIndex;

	lea	eax, DWORD PTR [edi+280]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4324 : 	saveTo << readFrom.m_iSwappableArtifactIndex;

	lea	ecx, DWORD PTR [edi+284]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4325 : 	saveTo << readFrom.m_iSwappableMusicIndex;

	add	edi, 288				; 00000120H
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 4326 : 
; 4327 : 	return saveTo;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 4328 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerCulture@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?ClearGreatWorks@CvCityCulture@@QAEXXZ		; CvCityCulture::ClearGreatWorks
; Function compile flags: /Ogtpy
;	COMDAT ?ClearGreatWorks@CvCityCulture@@QAEXXZ
_TEXT	SEGMENT
_kCityPlayer$ = -4					; size = 4
?ClearGreatWorks@CvCityCulture@@QAEXXZ PROC		; CvCityCulture::ClearGreatWorks, COMDAT
; _this$ = ecx

; 4387 : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx

; 4388 : 	CvPlayer &kCityPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ebp]
	mov	ebx, DWORD PTR [eax+84]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 4389 : #ifdef AUI_WARNING_FIXES
; 4390 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4391 : #else
; 4392 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _kCityPlayer$[esp+16], ebx
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN7@ClearGreat
	push	esi
$LL9@ClearGreat:

; 4393 : #endif
; 4394 : 	{
; 4395 : 		CvCivilizationInfo& playerCivilizationInfo = kCityPlayer.getCivilizationInfo();

	mov	ecx, ebx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4396 : 		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 4397 : 		if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN8@ClearGreat

; 4398 : 		{
; 4399 : 			CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax

; 4400 : 			if (pkBuilding)

	test	ebx, ebx
	je	SHORT $LN22@ClearGreat

; 4401 : 			{
; 4402 : 				if (m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN22@ClearGreat

; 4403 : 				{
; 4404 : #ifdef AUI_WARNING_FIXES
; 4405 : 					for (uint iI = 0; iI < pkBuilding->GetGreatWorkCount(); iI++)
; 4406 : #else
; 4407 : 					int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, ebx
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ebx, eax

; 4408 : 					for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN22@ClearGreat
	npad	5
$LL3@ClearGreat:

; 4409 : #endif
; 4410 : 					{
; 4411 : 						m_pCity->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI, -1);

	mov	ecx, DWORD PTR [ebp]
	push	-1
	push	esi
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL3@ClearGreat
$LN22@ClearGreat:

; 4408 : 					for (int iI = 0; iI < iNumSlots; iI++)

	mov	ebx, DWORD PTR _kCityPlayer$[esp+20]
$LN8@ClearGreat:

; 4389 : #ifdef AUI_WARNING_FIXES
; 4390 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4391 : #else
; 4392 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL9@ClearGreat
	pop	esi
$LN7@ClearGreat:
	pop	edi
	pop	ebp
	pop	ebx

; 4412 : 					}
; 4413 : 				}
; 4414 : 			}
; 4415 : 		}
; 4416 : 	}
; 4417 : }

	pop	ecx
	ret	0
?ClearGreatWorks@CvCityCulture@@QAEXXZ ENDP		; CvCityCulture::ClearGreatWorks
_TEXT	ENDS
PUBLIC	?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding
EXTRN	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ:PROC ; CvBuildingEntry::GetGreatWorkSlotType
EXTRN	?GetProductionCost@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetProductionCost
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iCheapest$ = -8					; size = 4
_eRtnValue$ = -4					; size = 4
?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ PROC ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding, COMDAT
; _this$ = ecx

; 4421 : {

	sub	esp, 12					; 0000000cH

; 4422 : 	int iCheapest = MAX_INT;
; 4423 : 	GreatWorkSlotType eRtnValue = NO_GREAT_WORK_SLOT;
; 4424 : 	CvPlayer &kCityPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ecx]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax+84]
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	DWORD PTR _this$[esp+24], ecx
	or	esi, -1

; 4425 : 
; 4426 : #ifdef AUI_WARNING_FIXES
; 4427 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4428 : #else
; 4429 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iCheapest$[esp+24], 2147483647 ; 7fffffffH
	mov	DWORD PTR _eRtnValue$[esp+24], esi
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN19@GetSlotTyp
	push	edi
	npad	1
$LL21@GetSlotTyp:

; 4430 : #endif
; 4431 : 	{
; 4432 : 		CvCivilizationInfo& playerCivilizationInfo = kCityPlayer.getCivilizationInfo();

	mov	ecx, ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4433 : 		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	ebx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 4434 : 		if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	$LN7@GetSlotTyp

; 4435 : 		{
; 4436 : 			CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 4437 : 			CvBuildingClassInfo *pkBuildingClass = GC.getBuildingClassInfo((BuildingClassTypes)iBuildingClassLoop);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 4438 : 			if (pkBuilding && pkBuildingClass && !isWorldWonderClass(*pkBuildingClass))

	test	edi, edi
	je	SHORT $LN7@GetSlotTyp
	test	eax, eax
	je	SHORT $LN7@GetSlotTyp
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	jne	SHORT $LN7@GetSlotTyp

; 4439 : 			{
; 4440 : 				int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, edi
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 4441 : 				if (iNumSlots > 0 && m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) == 0)

	test	eax, eax
	jle	SHORT $LN7@GetSlotTyp
	mov	ecx, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [ecx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jne	SHORT $LN7@GetSlotTyp

; 4442 : 				{
; 4443 : 					if (m_pCity->canConstruct(eBuilding))

	mov	edx, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [edx]
	push	eax
	push	eax
	push	eax
	push	eax
	push	esi
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	test	al, al
	je	SHORT $LN7@GetSlotTyp

; 4444 : 					{
; 4445 : 						int iCost = pkBuilding->GetProductionCost();

	mov	ecx, edi
	call	?GetProductionCost@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetProductionCost

; 4446 : 						if (iCost < iCheapest)

	cmp	eax, DWORD PTR _iCheapest$[esp+28]
	jge	SHORT $LN7@GetSlotTyp

; 4447 : 						{
; 4448 : 							iCheapest = iCost;
; 4449 : 							eRtnValue = pkBuilding->GetGreatWorkSlotType();

	mov	ecx, edi
	mov	DWORD PTR _iCheapest$[esp+28], eax
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	mov	DWORD PTR _eRtnValue$[esp+28], eax
$LN7@GetSlotTyp:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	$LL21@GetSlotTyp

; 4450 : 						}
; 4451 : 					}
; 4452 : 				}
; 4453 : 			}
; 4454 : 		}
; 4455 : 	}
; 4456 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4457 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN19@GetSlotTyp:

; 4450 : 						}
; 4451 : 					}
; 4452 : 				}
; 4453 : 			}
; 4454 : 		}
; 4455 : 	}
; 4456 : 	return eRtnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 4457 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetSlotTypeFirstAvailableCultureBuilding@CvCityCulture@@QBE?AW4GreatWorkSlotType@@XZ ENDP ; CvCityCulture::GetSlotTypeFirstAvailableCultureBuilding
_TEXT	ENDS
PUBLIC	?GetTourismMultiplier@CvCityCulture@@QBEHW4PlayerTypes@@_N1111@Z ; CvCityCulture::GetTourismMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismMultiplier@CvCityCulture@@QBEHW4PlayerTypes@@_N1111@Z
_TEXT	SEGMENT
_iMultiplier$ = -20					; size = 4
_this$ = -16						; size = 4
_eMyIdeology$ = -12					; size = 4
_eTheirIdeology$ = -8					; size = 4
_kTeam$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
tv503 = 12						; size = 4
_rank$227108 = 12					; size = 4
_bIgnoreReligion$ = 12					; size = 1
_myStrength$227110 = 16					; size = 4
_bIgnoreOpenBorders$ = 16				; size = 1
_iCommonFoeMod$227106 = 20				; size = 4
_bIgnoreTrade$ = 20					; size = 1
_bIgnorePolicies$ = 24					; size = 1
_bIgnoreIdeologies$ = 28				; size = 1
?GetTourismMultiplier@CvCityCulture@@QBEHW4PlayerTypes@@_N1111@Z PROC ; CvCityCulture::GetTourismMultiplier, COMDAT
; _this$ = ecx

; 4638 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4639 : 	int iMultiplier = 0;
; 4640 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	edi, DWORD PTR _ePlayer$[esp+32]
	imul	edi, 63236				; 0000f704H
	mov	ebp, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 4641 : 	CvTeam &kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR [edi+ecx+44]
	add	edi, ecx
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+36], ebp
	mov	DWORD PTR _iMultiplier$[esp+36], ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@GetTourism@3
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN31@GetTourism@3
$LN30@GetTourism@3:
	or	eax, -1
$LN31@GetTourism@3:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$[esp+36], eax

; 4642 : 	CvPlayer &kCityPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ebp]
	mov	esi, DWORD PTR [eax+84]
	imul	esi, 63236				; 0000f704H
	add	esi, ecx

; 4643 : 	PolicyBranchTypes eMyIdeology = kCityPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 4644 : 	PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, edi
	mov	DWORD PTR _eMyIdeology$[esp+36], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eTheirIdeology$[esp+36], eax

; 4645 : 
; 4646 : 	if (!bIgnoreReligion)

	cmp	BYTE PTR _bIgnoreReligion$[esp+32], bl
	jne	SHORT $LN91@GetTourism@3

; 4647 : 	{
; 4648 : 		// City shares religion with this player
; 4649 : 		ReligionTypes ePlayerReligion = kCityPlayer.GetReligions()->GetReligionInMostCities();

	mov	ecx, esi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionInMostCities@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionInMostCities

; 4650 : 		if (ePlayerReligion != NO_RELIGION && kPlayer.GetReligions()->HasReligionInMostCities(ePlayerReligion))

	cmp	eax, -1
	je	SHORT $LN91@GetTourism@3
	push	eax
	mov	ecx, edi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasReligionInMostCities@CvPlayerReligions@@QBE_NW4ReligionTypes@@@Z ; CvPlayerReligions::HasReligionInMostCities
	test	al, al
	je	SHORT $LN91@GetTourism@3

; 4651 : 		{
; 4652 : 			iMultiplier += kCityPlayer.GetCulture()->GetTourismModifierSharedReligion();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, DWORD PTR [eax+292]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	55					; 00000037H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebx
	mov	DWORD PTR _iMultiplier$[esp+36], eax
	mov	ebx, eax
$LN91@GetTourism@3:

; 4653 : 		}
; 4654 : 	}
; 4655 : 
; 4656 : 	if (!bIgnoreOpenBorders)

	cmp	BYTE PTR _bIgnoreOpenBorders$[esp+32], 0
	jne	SHORT $LN94@GetTourism@3

; 4657 : 	{
; 4658 : 		// Open borders with this player
; 4659 : 		if (kTeam.IsAllowsOpenBordersToTeam(kCityPlayer.getTeam()))

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN51@GetTourism@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN52@GetTourism@3
$LN51@GetTourism@3:
	or	eax, -1
$LN52@GetTourism@3:
	mov	ecx, DWORD PTR _kTeam$[esp+36]
	push	eax
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN94@GetTourism@3

; 4660 : 		{
; 4661 : 			iMultiplier += kCityPlayer.GetCulture()->GetTourismModifierOpenBorders();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, DWORD PTR [eax+292]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	57					; 00000039H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebp
	mov	ebp, DWORD PTR _this$[esp+36]
	add	ebx, eax
	mov	DWORD PTR _iMultiplier$[esp+36], ebx
$LN94@GetTourism@3:

; 4662 : 		}
; 4663 : 	}
; 4664 : 
; 4665 : 	if (!bIgnoreTrade)

	cmp	BYTE PTR _bIgnoreTrade$[esp+32], 0
	jne	SHORT $LN95@GetTourism@3

; 4666 : 	{
; 4667 : 		// Trade route to one of this player's cities from here
; 4668 : 		if (GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pCity->getOwner(), ePlayer))

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR _ePlayer$[esp+32]
	mov	eax, DWORD PTR [eax+84]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	je	SHORT $LN95@GetTourism@3

; 4669 : 		{
; 4670 : 			iMultiplier += kCityPlayer.GetCulture()->GetTourismModifierTradeRoute();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, DWORD PTR [eax+292]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	56					; 00000038H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebp
	add	ebx, eax
	mov	DWORD PTR _iMultiplier$[esp+36], ebx
$LN95@GetTourism@3:

; 4671 : 		}
; 4672 : 	}
; 4673 : 
; 4674 : 	if (!bIgnoreIdeologies)

	cmp	BYTE PTR _bIgnoreIdeologies$[esp+32], 0
	jne	SHORT $LN13@GetTourism@3

; 4675 : 	{
; 4676 : 		if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology != eTheirIdeology)

	mov	eax, DWORD PTR _eMyIdeology$[esp+36]
	cmp	eax, -1
	je	SHORT $LN13@GetTourism@3
	mov	ecx, DWORD PTR _eTheirIdeology$[esp+36]
	cmp	ecx, -1
	je	SHORT $LN13@GetTourism@3
	cmp	eax, ecx
	je	SHORT $LN13@GetTourism@3

; 4677 : 		{
; 4678 : 			iMultiplier += GC.getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8228

; 4679 : 
; 4680 : 			if (kCityPlayer.GetEspionage()->IsMyDiplomatVisitingThem(ePlayer))

	mov	edx, DWORD PTR _ePlayer$[esp+32]
	push	0
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _iMultiplier$[esp+44], ebx
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
	test	al, al
	je	SHORT $LN13@GetTourism@3

; 4681 : 			{
; 4682 : 				iMultiplier += GC.getTOURISM_MODIFIER_DIPLOMAT();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8232
	mov	DWORD PTR _iMultiplier$[esp+36], ebx
$LN13@GetTourism@3:

; 4683 : 			}
; 4684 : 		}
; 4685 : 	}
; 4686 : 
; 4687 : 	if (!bIgnorePolicies)

	cmp	BYTE PTR _bIgnorePolicies$[esp+32], 0
	jne	$LN86@GetTourism@3

; 4688 : 	{
; 4689 : 		int iLessHappyMod = kCityPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_LESS_HAPPY);

	push	29					; 0000001dH
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ebp, eax

; 4690 : 		if (iLessHappyMod > 0)

	test	ebp, ebp
	jle	SHORT $LN10@GetTourism@3

; 4691 : 		{
; 4692 : 			if (kCityPlayer.GetExcessHappiness() > kPlayer.GetExcessHappiness())

	mov	ecx, esi
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	ecx, edi
	mov	DWORD PTR tv503[esp+32], eax
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	ecx, DWORD PTR tv503[esp+32]
	cmp	ecx, eax
	jle	SHORT $LN10@GetTourism@3

; 4693 : 			{
; 4694 : 				iMultiplier += iLessHappyMod;

	add	ebx, ebp
	mov	DWORD PTR _iMultiplier$[esp+36], ebx
$LN10@GetTourism@3:

; 4695 : 			}
; 4696 : 		}
; 4697 : 		int iCommonFoeMod = kCityPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_COMMON_FOE);

	push	28					; 0000001cH
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 4698 : 		if (iCommonFoeMod > 0)

	xor	ebp, ebp
	cmp	eax, ebp
	mov	DWORD PTR _iCommonFoeMod$227106[esp+32], eax
	jle	SHORT $LN3@GetTourism@3

; 4699 : 		{
; 4700 : 			// NQMP GJS - new Cult of Personality BEGIN
; 4701 : 			int rank = 0;
; 4702 : 			int totalEnemies = 0;
; 4703 : 			int myStrength = kCityPlayer.GetMilitaryMight();

	mov	ecx, esi
	mov	DWORD PTR _rank$227108[esp+32], ebp
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight

; 4704 : 
; 4705 : 			PlayerTypes eLoopPlayer;
; 4706 : 			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebx, ebx
	mov	DWORD PTR _myStrength$227110[esp+32], eax
	xor	edi, edi
	npad	5
$LL97@GetTourism@3:

; 4707 : 			{
; 4708 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 4709 : 				if(eLoopPlayer != m_pCity->getOwner() && kCityPlayer.GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	eax, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [eax]
	cmp	ebx, DWORD PTR [ecx+84]
	je	SHORT $LN7@GetTourism@3
	push	0
	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN7@GetTourism@3

; 4710 : 				{
; 4711 : 					totalEnemies++;
; 4712 : 					if (GET_PLAYER(eLoopPlayer).GetMilitaryMight() > myStrength)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	inc	ebp
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	cmp	eax, DWORD PTR _myStrength$227110[esp+32]
	jle	SHORT $LN7@GetTourism@3

; 4713 : 					{
; 4714 : 						rank++;

	inc	DWORD PTR _rank$227108[esp+32]
$LN7@GetTourism@3:

; 4704 : 
; 4705 : 			PlayerTypes eLoopPlayer;
; 4706 : 			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL97@GetTourism@3

; 4715 : 					}
; 4716 : 				}
; 4717 : 			}
; 4718 : 
; 4719 : 			// divide the tourism boost into chunks, so that lowest player gets 0%, highest gets 100%, and the rest are evenly distributed in between
; 4720 : 			// so for example in a 6 player game, based on the player being 6th/5th/4th/3rd/2nd/1st in military strength they get 0%/20%/40%/60%/80%/100% boost
; 4721 : 			if (totalEnemies > 0)

	test	ebp, ebp
	jle	SHORT $LN90@GetTourism@3

; 4722 : 			{
; 4723 : 				iCommonFoeMod = iCommonFoeMod * (totalEnemies - rank) / totalEnemies;

	mov	eax, ebp
	sub	eax, DWORD PTR _rank$227108[esp+32]
	imul	eax, DWORD PTR _iCommonFoeMod$227106[esp+32]
	cdq
	idiv	ebp

; 4724 : 				iMultiplier += iCommonFoeMod;

	add	DWORD PTR _iMultiplier$[esp+36], eax
$LN90@GetTourism@3:
	mov	ebx, DWORD PTR _iMultiplier$[esp+36]
$LN3@GetTourism@3:

; 4725 : 			}
; 4726 : 
; 4727 : 			/*
; 4728 : 			// old code
; 4729 : 			PlayerTypes eLoopPlayer;
; 4730 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 4731 : 			{
; 4732 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 4733 : 
; 4734 : 				if(eLoopPlayer != ePlayer && eLoopPlayer != m_pCity->getOwner() && kCityPlayer.GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
; 4735 : 				{
; 4736 : 					// Are they at war with me too?
; 4737 : 					if (GET_TEAM(kCityPlayer.getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && GET_TEAM(kPlayer.getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
; 4738 : 					{
; 4739 : 						iMultiplier += iCommonFoeMod;
; 4740 : 					}
; 4741 : 				}
; 4742 : 			}
; 4743 : 			*/
; 4744 : 			// NQMP GJS - new Cult of Personality END
; 4745 : 		}
; 4746 : 
; 4747 : 		int iSharedIdeologyMod = kCityPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_SHARED_IDEOLOGY);

	push	30					; 0000001eH
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 4748 : 		if (iSharedIdeologyMod > 0)

	test	eax, eax
	jle	SHORT $LN86@GetTourism@3

; 4749 : 		{
; 4750 : 			if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)

	mov	edx, DWORD PTR _eMyIdeology$[esp+36]
	cmp	edx, -1
	je	SHORT $LN86@GetTourism@3
	mov	ecx, DWORD PTR _eTheirIdeology$[esp+36]
	cmp	ecx, -1
	je	SHORT $LN86@GetTourism@3
	cmp	edx, ecx
	jne	SHORT $LN86@GetTourism@3

; 4751 : 			{
; 4752 : 				iMultiplier += iSharedIdeologyMod;

	add	ebx, eax
$LN86@GetTourism@3:
	pop	edi
	pop	esi
	pop	ebp

; 4753 : 			}
; 4754 : 		}
; 4755 : 	}
; 4756 : 
; 4757 : 	// LATER add top science city and research agreement with this player???
; 4758 : 
; 4759 : 	return iMultiplier;

	mov	eax, ebx
	pop	ebx

; 4760 : }

	add	esp, 20					; 00000014H
	ret	24					; 00000018H
?GetTourismMultiplier@CvCityCulture@@QBEHW4PlayerTypes@@_N1111@Z ENDP ; CvCityCulture::GetTourismMultiplier
_TEXT	ENDS
PUBLIC	?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ ; CvCityCulture::GetFilledSlotsTooltip
EXTRN	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ:PROC ; CvTypes::getGREAT_WORK_SLOT_MUSIC
EXTRN	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z:PROC ; CvCityBuildings::GetNumGreatWorks
EXTRN	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ:PROC ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$1
__ehfuncinfo$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
$T239061 = -56						; size = 4
_iGWMusic$ = -52					; size = 4
_iGWArt$ = -48						; size = 4
_iGWWriting$ = -44					; size = 4
$T239059 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ PROC ; CvCityCulture::GetFilledSlotsTooltip, COMDAT
; _this$ = ecx

; 5182 : {

	push	-1
	push	__ehhandler$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T239061[esp+68], ebx

; 5183 : 	CvString szRtnValue = "";

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+64]
	mov	esi, ecx
	push	OFFSET $SG227385
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+80], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 5184 : #ifdef AUI_WARNING_FIXES
; 5185 : 	const CvCityBuildings* pCityBuildings = m_pCity->GetCityBuildings();
; 5186 : 	const int iGWWriting = pCityBuildings->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_LITERATURE());
; 5187 : 	const int iGWArt = pCityBuildings->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT());
; 5188 : 	const int iGWMusic = pCityBuildings->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_MUSIC());
; 5189 : #else
; 5190 : 	const int iGWWriting = m_pCity->GetCityBuildings()->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_LITERATURE());
; 5191 : 	const int iGWArt = m_pCity->GetCityBuildings()->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT());
; 5192 : 	const int iGWMusic = m_pCity->GetCityBuildings()->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_MUSIC());
; 5193 : #endif
; 5194 : 	szRtnValue = GetLocalizedText("TXT_KEY_CO_GREAT_WORK_TT", iGWWriting, iGWArt, iGWMusic);
; 5195 : 
; 5196 : 	return szRtnValue;

	mov	DWORD PTR __$EHRec$[esp+76], ebx
	mov	DWORD PTR $T239061[esp+68], 1
	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
	mov	DWORD PTR _iGWWriting$[esp+68], eax
	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
	mov	DWORD PTR _iGWArt$[esp+68], eax
	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
	mov	DWORD PTR _iGWMusic$[esp+68], eax
	lea	eax, DWORD PTR _iGWMusic$[esp+68]
	push	eax
	lea	ecx, DWORD PTR _iGWArt$[esp+72]
	push	ecx
	lea	edx, DWORD PTR _iGWWriting$[esp+76]
	push	edx
	lea	eax, DWORD PTR $T239059[esp+80]
	push	OFFSET $SG227399
	push	eax
	call	??$GetLocalizedText@HHH@@YA?AVCvString@@PBDABH11@Z ; GetLocalizedText<int,int,int>
	add	esp, 20					; 00000014H
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+80], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239059[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5197 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T239061[ebp]
	and	eax, 1
	je	$LN4@GetFilledS
	and	DWORD PTR $T239061[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetFilledS:
	ret	0
__unwindfunclet$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR $T239059[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFilledSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ ENDP ; CvCityCulture::GetFilledSlotsTooltip
PUBLIC	?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ ; CvCityCulture::GetTotalSlotsTooltip
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
_iFilledArt$ = -152					; size = 4
_iFilledWriting$ = -148					; size = 4
_iFilledMusic$ = -144					; size = 4
_iGWArt$ = -140						; size = 4
$T239094 = -136						; size = 4
_iGWMusic$ = -132					; size = 4
_iGWWriting$ = -128					; size = 4
$T239092 = -124						; size = 28
$T239091 = -124						; size = 28
$T239090 = -124						; size = 28
$T239089 = -124						; size = 28
_szTemp3$ = -96						; size = 28
_szTemp1$ = -68						; size = 28
_szTemp2$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ PROC ; CvCityCulture::GetTotalSlotsTooltip, COMDAT
; _this$ = ecx

; 5201 : {

	push	-1
	push	__ehhandler$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	ebp
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T239094[esp+168], ebx

; 5202 : 	CvString szRtnValue = "";

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+164]
	mov	esi, ecx
	push	OFFSET $SG227405
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+180], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 5203 : 	CvString szTemp1, szTemp2, szTemp3;
; 5204 : 	
; 5205 : 	GreatWorkSlotType eLiteratureSlot = CvTypes::getGREAT_WORK_SLOT_LITERATURE();
; 5206 : #ifdef AUI_WARNING_FIXES
; 5207 : 	const CvCityBuildings* pCityBuildings = m_pCity->GetCityBuildings();
; 5208 : 	int iFilledWriting = pCityBuildings->GetNumGreatWorks(eLiteratureSlot);
; 5209 : 	int iGWWriting = iFilledWriting + pCityBuildings->GetNumAvailableGreatWorkSlots(eLiteratureSlot);
; 5210 : 
; 5211 : 	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();
; 5212 : 	int iFilledArt = pCityBuildings->GetNumGreatWorks(eArtArtifactSlot);
; 5213 : 	int iGWArt = iFilledArt + pCityBuildings->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);
; 5214 : 
; 5215 : 	GreatWorkSlotType eMusicSlot = CvTypes::getGREAT_WORK_SLOT_MUSIC();
; 5216 : 	int iFilledMusic = pCityBuildings->GetNumGreatWorks(eMusicSlot);
; 5217 : 	int iGWMusic = iFilledMusic + pCityBuildings->GetNumAvailableGreatWorkSlots(eMusicSlot);
; 5218 : #else
; 5219 : 	int iFilledWriting = m_pCity->GetCityBuildings()->GetNumGreatWorks(eLiteratureSlot);
; 5220 : 	int iGWWriting = iFilledWriting + m_pCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eLiteratureSlot);
; 5221 : 
; 5222 : 	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();
; 5223 : 	int iFilledArt = m_pCity->GetCityBuildings()->GetNumGreatWorks(eArtArtifactSlot);
; 5224 : 	int iGWArt = iFilledArt + m_pCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);
; 5225 : 
; 5226 : 	GreatWorkSlotType eMusicSlot = CvTypes::getGREAT_WORK_SLOT_MUSIC();
; 5227 : 	int iFilledMusic = m_pCity->GetCityBuildings()->GetNumGreatWorks(eMusicSlot);
; 5228 : 	int iGWMusic = iFilledMusic + m_pCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eMusicSlot);
; 5229 : #endif
; 5230 : 
; 5231 : 	szTemp1 = GetLocalizedText("TXT_KEY_CO_GREAT_WORK_SLOTS_TT_ENTRY", iFilledWriting, iGWWriting);
; 5232 : 	szTemp2 = GetLocalizedText("TXT_KEY_CO_GREAT_WORK_SLOTS_TT_ENTRY", iFilledArt, iGWArt);
; 5233 : 	szTemp3 = GetLocalizedText("TXT_KEY_CO_GREAT_WORK_SLOTS_TT_ENTRY", iFilledMusic, iGWMusic);
; 5234 : 	szRtnValue = GetLocalizedText("TXT_KEY_CO_GREAT_WORK_SLOTS_TT", szTemp1, szTemp2, szTemp3);
; 5235 : 
; 5236 : 	return szRtnValue;

	mov	DWORD PTR __$EHRec$[esp+176], ebx
	mov	ebx, 1
	lea	ecx, DWORD PTR _szTemp1$[esp+168]
	mov	DWORD PTR $T239094[esp+168], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp2$[esp+168]
	mov	DWORD PTR __$EHRec$[esp+176], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp3$[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 3
	mov	BYTE PTR __$EHRec$[esp+176], bl
	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
	mov	ecx, DWORD PTR [esi]
	mov	ebp, eax
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
	mov	ecx, DWORD PTR [esi]
	push	ebp
	mov	DWORD PTR _iFilledWriting$[esp+172], eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	add	eax, DWORD PTR _iFilledWriting$[esp+168]
	mov	DWORD PTR _iGWWriting$[esp+168], eax
	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	mov	ecx, DWORD PTR [esi]
	mov	ebp, eax
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
	mov	ecx, DWORD PTR [esi]
	push	ebp
	mov	DWORD PTR _iFilledArt$[esp+172], eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	add	eax, DWORD PTR _iFilledArt$[esp+168]
	mov	DWORD PTR _iGWArt$[esp+168], eax
	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	mov	ecx, DWORD PTR [esi]
	mov	ebp, eax
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
	mov	ecx, DWORD PTR [esi]
	push	ebp
	mov	DWORD PTR _iFilledMusic$[esp+172], eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
	add	eax, DWORD PTR _iFilledMusic$[esp+168]
	lea	ecx, DWORD PTR _iFilledWriting$[esp+168]
	mov	DWORD PTR _iGWMusic$[esp+168], eax
	lea	eax, DWORD PTR _iGWWriting$[esp+168]
	push	eax
	push	ecx
	push	OFFSET $SG227419
	lea	edx, DWORD PTR $T239089[esp+180]
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szTemp1$[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239089[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	eax, DWORD PTR _iGWArt$[esp+168]
	push	eax
	lea	ecx, DWORD PTR _iFilledArt$[esp+172]
	push	ecx
	lea	edx, DWORD PTR $T239090[esp+176]
	push	OFFSET $SG227421
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szTemp2$[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239090[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	eax, DWORD PTR _iGWMusic$[esp+168]
	push	eax
	lea	ecx, DWORD PTR _iFilledMusic$[esp+172]
	push	ecx
	lea	edx, DWORD PTR $T239091[esp+176]
	push	OFFSET $SG227423
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szTemp3$[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239091[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	eax, DWORD PTR _szTemp3$[esp+168]
	push	eax
	lea	ecx, DWORD PTR _szTemp2$[esp+172]
	push	ecx
	lea	edx, DWORD PTR _szTemp1$[esp+176]
	push	edx
	lea	eax, DWORD PTR $T239092[esp+180]
	push	OFFSET $SG227434
	push	eax
	call	??$GetLocalizedText@VCvString@@V1@V1@@@YA?AVCvString@@PBDABV0@11@Z ; GetLocalizedText<CvString,CvString,CvString>
	add	esp, 20					; 00000014H
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+180], 7
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239092[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp3$[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp2$[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp1$[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5237 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+168]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 152				; 00000098H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T239094[ebp]
	and	eax, 1
	je	$LN4@GetTotalSl
	and	DWORD PTR $T239094[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetTotalSl:
	ret	0
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR _szTemp1$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$2:
	lea	ecx, DWORD PTR _szTemp2$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$3:
	lea	ecx, DWORD PTR _szTemp3$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$4:
	lea	ecx, DWORD PTR $T239089[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$5:
	lea	ecx, DWORD PTR $T239090[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$6:
	lea	ecx, DWORD PTR $T239091[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ$7:
	lea	ecx, DWORD PTR $T239092[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTotalSlotsTooltip@CvCityCulture@@QAE?AVCvString@@XZ ENDP ; CvCityCulture::GetTotalSlotsTooltip
PUBLIC	?IsThemingBonusPossible@CvCityCulture@@QBE_NW4BuildingClassTypes@@@Z ; CvCityCulture::IsThemingBonusPossible
; Function compile flags: /Ogtpy
;	COMDAT ?IsThemingBonusPossible@CvCityCulture@@QBE_NW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?IsThemingBonusPossible@CvCityCulture@@QBE_NW4BuildingClassTypes@@@Z PROC ; CvCityCulture::IsThemingBonusPossible, COMDAT
; _this$ = ecx

; 5242 : 	CvPlayer &kPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+84]

; 5243 : 	BuildingTypes eBuilding = (BuildingTypes)kPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 5244 : 	CvBuildingEntry *pkBuilding = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 5245 : 	if (pkBuilding)

	test	eax, eax
	je	SHORT $LN1@IsThemingB

; 5246 : 	{
; 5247 : 		if (pkBuilding->GetThemingBonusInfo(0) != NULL)

	push	0
	mov	ecx, eax
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	test	eax, eax
	je	SHORT $LN1@IsThemingB

; 5248 : 		{
; 5249 : 			return true;

	mov	al, 1

; 5254 : }

	ret	4
$LN1@IsThemingB:

; 5250 : 		}
; 5251 : 	}
; 5252 : 
; 5253 : 	return false;

	xor	al, al

; 5254 : }

	ret	4
?IsThemingBonusPossible@CvCityCulture@@QBE_NW4BuildingClassTypes@@@Z ENDP ; CvCityCulture::IsThemingBonusPossible
_TEXT	ENDS
PUBLIC	?GetCultureFromWonders@CvCityCulture@@QBEHXZ	; CvCityCulture::GetCultureFromWonders
EXTRN	?GetWorldWonderYieldChange@CvGameLeagues@@QAEHW4PlayerTypes@@W4YieldTypes@@@Z:PROC ; CvGameLeagues::GetWorldWonderYieldChange
EXTRN	?GetYieldChange@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetYieldChange
EXTRN	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ:PROC ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromWonders@CvCityCulture@@QBEHXZ
_TEXT	SEGMENT
_pkCivInfo$ = -8					; size = 4
_iNumBuildingClassInfos$227545 = -4			; size = 4
?GetCultureFromWonders@CvCityCulture@@QBEHXZ PROC	; CvCityCulture::GetCultureFromWonders, COMDAT
; _this$ = ecx

; 5370 : {

	sub	esp, 8
	push	ebp
	mov	ebp, ecx

; 5371 : 	int iRtnValue = 0;
; 5372 : 	CvPlayer &kPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	xor	edi, edi

; 5373 : 
; 5374 : 	CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(kPlayer.getCivilizationType());

	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	esi, eax
	mov	DWORD PTR _pkCivInfo$[esp+20], esi

; 5375 : 	if (pkCivInfo)

	test	esi, esi
	je	$LN26@GetCulture
	push	ebx

; 5376 : 	{
; 5377 : 		int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos

; 5378 : 
; 5379 : 		for(int iI = 0; iI < iNumBuildingClassInfos; iI++)

	xor	ebx, ebx
	mov	DWORD PTR _iNumBuildingClassInfos$227545[esp+24], eax
	test	eax, eax
	jle	$LN25@GetCulture
	jmp	SHORT $LN7@GetCulture
$LL27@GetCulture:
	mov	esi, DWORD PTR _pkCivInfo$[esp+24]
$LN7@GetCulture:

; 5380 : 		{
; 5381 : 			BuildingTypes eWonderBuilding = ((BuildingTypes)(pkCivInfo->getCivilizationBuildings(iI)));

	push	ebx
	mov	ecx, esi
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 5382 : 			if (eWonderBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN6@GetCulture

; 5383 : 			{
; 5384 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eWonderBuilding) > 0)

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN6@GetCulture

; 5385 : 				{
; 5386 : 					CvBuildingEntry *pkBuildingInfo = GC.getBuildingInfo(eWonderBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 5387 : 					if (pkBuildingInfo)

	test	esi, esi
	je	SHORT $LN6@GetCulture

; 5388 : 					{
; 5389 : 						if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))

	mov	ecx, esi
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN6@GetCulture

; 5390 : 						{
; 5391 : 							iRtnValue += pkBuildingInfo->GetYieldChange(YIELD_CULTURE);

	push	4
	mov	ecx, esi
	call	?GetYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChange

; 5392 : 							iRtnValue += GC.getGame().GetGameLeagues()->GetWorldWonderYieldChange(m_pCity->getOwner(), YIELD_CULTURE);

	mov	ecx, DWORD PTR [ebp]
	add	edi, eax
	mov	eax, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	4
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetWorldWonderYieldChange@CvGameLeagues@@QAEHW4PlayerTypes@@W4YieldTypes@@@Z ; CvGameLeagues::GetWorldWonderYieldChange
	add	edi, eax
$LN6@GetCulture:
	inc	ebx
	cmp	ebx, DWORD PTR _iNumBuildingClassInfos$227545[esp+24]
	jl	SHORT $LL27@GetCulture
$LN25@GetCulture:
	pop	ebx

; 5393 : 						}
; 5394 : 					}
; 5395 : 				}
; 5396 : 			}
; 5397 : 		}
; 5398 : 	}
; 5399 : 
; 5400 : 	return iRtnValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 5401 : }

	add	esp, 8
	ret	0
$LN26@GetCulture:

; 5393 : 						}
; 5394 : 					}
; 5395 : 				}
; 5396 : 			}
; 5397 : 		}
; 5398 : 	}
; 5399 : 
; 5400 : 	return iRtnValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 5401 : }

	add	esp, 8
	ret	0
?GetCultureFromWonders@CvCityCulture@@QBEHXZ ENDP	; CvCityCulture::GetCultureFromWonders
_TEXT	ENDS
PUBLIC	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromNaturalWonders
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
EXTRN	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z:PROC ; CvCityCitizens::GetCityPlotFromIndex
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ
_TEXT	SEGMENT
?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ PROC ; CvCityCulture::GetCultureFromNaturalWonders, COMDAT
; _this$ = ecx

; 5405 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 5406 : 	int iRtnValue = 0;

	xor	ebp, ebp
	mov	ebx, ecx

; 5407 : 	CvPlot* pLoopPlot;
; 5408 : 
; 5409 : 	// Look at all workable Plots
; 5410 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	edi, edi
	npad	6
$LL30@GetCulture@2:

; 5411 : 	{
; 5412 : 		if(iPlotLoop != CITY_HOME_PLOT)

	test	edi, edi
	je	SHORT $LN7@GetCulture@2

; 5413 : 		{
; 5414 : 			pLoopPlot = m_pCity->GetCityCitizens()->GetCityPlotFromIndex(iPlotLoop);

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
	mov	esi, eax

; 5415 : 
; 5416 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	SHORT $LN7@GetCulture@2

; 5417 : 			{
; 5418 : 				// Is this a Plot this City controls?
; 5419 : 				if(pLoopPlot->getWorkingCity() != NULL && pLoopPlot->getWorkingCity()->GetID() == m_pCity->GetID())

	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	test	eax, eax
	je	SHORT $LN7@GetCulture@2
	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+120]
	cmp	eax, DWORD PTR [ecx+120]
	jne	SHORT $LN7@GetCulture@2

; 5420 : 				{
; 5421 : 					// Working the Plot?
; 5422 : 					if (m_pCity->GetCityCitizens()->IsWorkingPlot(pLoopPlot))

	push	esi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	je	SHORT $LN7@GetCulture@2

; 5423 : 					{
; 5424 : 						if(pLoopPlot->getFeatureType() != NO_FEATURE && GC.getFeatureInfo(pLoopPlot->getFeatureType())->IsNaturalWonder())

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN7@GetCulture@2
	movsx	ecx, al
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	SHORT $LN7@GetCulture@2

; 5425 : 						{
; 5426 : 							iRtnValue += pLoopPlot->getYield(YIELD_CULTURE);

	push	4
	mov	ecx, esi
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	add	ebp, eax
$LN7@GetCulture@2:
	inc	edi
	cmp	edi, 37					; 00000025H
	jl	SHORT $LL30@GetCulture@2
	pop	edi
	pop	esi

; 5427 : 						}
; 5428 : 					}
; 5429 : 				}
; 5430 : 			}
; 5431 : 		}
; 5432 : 	}
; 5433 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5434 : }

	ret	0
?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ ENDP ; CvCityCulture::GetCultureFromNaturalWonders
_TEXT	ENDS
PUBLIC	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromImprovements
EXTRN	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvPlot::ComputeCultureFromAdjacentImprovement
EXTRN	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureAdjacentSameType
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z:PROC ; CvPlot::calculateYield
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromImprovements@CvCityCulture@@QBEHXZ
_TEXT	SEGMENT
_iPlotLoop$227576 = -8					; size = 4
_this$ = -4						; size = 4
?GetCultureFromImprovements@CvCityCulture@@QBEHXZ PROC	; CvCityCulture::GetCultureFromImprovements, COMDAT
; _this$ = ecx

; 5438 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 5439 : 	int iRtnValue = 0;

	xor	ebp, ebp
	mov	ebx, ecx

; 5440 : 	CvPlot* pLoopPlot;
; 5441 : 
; 5442 : 	// Look at all workable Plots
; 5443 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	edi, edi
	mov	DWORD PTR _this$[esp+24], ebx
	mov	DWORD PTR _iPlotLoop$227576[esp+24], edi
	jmp	SHORT $LN10@GetCulture@3
	npad	9
$LL25@GetCulture@3:
	mov	ebx, DWORD PTR _this$[esp+24]
$LN10@GetCulture@3:

; 5444 : 	{
; 5445 : 		if(iPlotLoop != CITY_HOME_PLOT)

	test	edi, edi
	je	$LN9@GetCulture@3

; 5446 : 		{
; 5447 : 			pLoopPlot = m_pCity->GetCityCitizens()->GetCityPlotFromIndex(iPlotLoop);

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
	mov	esi, eax

; 5448 : 
; 5449 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	$LN9@GetCulture@3

; 5450 : 			{
; 5451 : 				// Is this a Plot this City controls?
; 5452 : 				if(pLoopPlot->getWorkingCity() != NULL && pLoopPlot->getWorkingCity()->GetID() == m_pCity->GetID())

	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	test	eax, eax
	je	SHORT $LN9@GetCulture@3
	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+120]
	cmp	eax, DWORD PTR [ecx+120]
	jne	SHORT $LN9@GetCulture@3

; 5453 : 				{
; 5454 : 					// Working the Plot?
; 5455 : 					if (m_pCity->GetCityCitizens()->IsWorkingPlot(pLoopPlot))

	push	esi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	je	SHORT $LN9@GetCulture@3

; 5456 : 					{
; 5457 : 						ImprovementTypes eImprovement = pLoopPlot->getImprovementType();

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	ebx, eax

; 5458 : 						if (eImprovement != NO_IMPROVEMENT)

	cmp	ebx, -1
	je	SHORT $LN9@GetCulture@3

; 5459 : 						{
; 5460 : 							iRtnValue += pLoopPlot->calculateYield(YIELD_CULTURE);

	push	0
	push	4
	mov	ecx, esi
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield

; 5461 : 
; 5462 : 							CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	ebp, eax
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 5463 : 							if(pImprovement && pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	test	edi, edi
	je	SHORT $LN23@GetCulture@3
	push	4
	mov	ecx, edi
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN23@GetCulture@3

; 5464 : 							{
; 5465 : 								int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, edi
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType

; 5466 : 								if(iAdjacentCulture > 0)

	test	eax, eax
	jle	SHORT $LN23@GetCulture@3

; 5467 : 								{
; 5468 : 									iRtnValue += pLoopPlot->ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	add	ebp, eax
$LN23@GetCulture@3:
	mov	edi, DWORD PTR _iPlotLoop$227576[esp+24]
$LN9@GetCulture@3:

; 5440 : 	CvPlot* pLoopPlot;
; 5441 : 
; 5442 : 	// Look at all workable Plots
; 5443 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	inc	edi
	cmp	edi, 37					; 00000025H
	mov	DWORD PTR _iPlotLoop$227576[esp+24], edi
	jl	$LL25@GetCulture@3
	pop	edi
	pop	esi

; 5469 : 								}
; 5470 : 							}
; 5471 : 						}
; 5472 : 					}
; 5473 : 				}
; 5474 : 			}
; 5475 : 		}
; 5476 : 	}
; 5477 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5478 : }

	add	esp, 8
	ret	0
?GetCultureFromImprovements@CvCityCulture@@QBEHXZ ENDP	; CvCityCulture::GetCultureFromImprovements
_TEXT	ENDS
PUBLIC	?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z ; CultureHelpers::SendArtSwapNotification
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ:PROC ; CvPlayer::getLeaderInfo
EXTRN	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ:PROC ; CvGame::GetGameCulture
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z
_TEXT	SEGMENT
$T239307 = -156						; size = 4
$T239303 = -156						; size = 4
$T239299 = -156						; size = 4
$T239308 = -152						; size = 28
$T239304 = -152						; size = 28
$T239297 = -152						; size = 28
$T239305 = -124						; size = 28
$T239301 = -124						; size = 28
$T239300 = -124						; size = 28
_strBuffer$ = -96					; size = 28
$T239306 = -68						; size = 28
$T239302 = -68						; size = 28
$T239298 = -68						; size = 28
_strSummary$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eType$ = 8						; size = 4
_bArt$ = 12						; size = 1
_eOriginator$ = 16					; size = 4
_eReceipient$ = 20					; size = 4
_iWorkFromOriginator$ = 24				; size = 4
_iWorkFromRecipient$ = 28				; size = 4
?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z PROC ; CultureHelpers::SendArtSwapNotification, COMDAT

; 5940 : {

	push	-1
	push	__ehhandler$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 144				; 00000090H

; 5941 : 	CvGameCulture *pkGameCulture = GC.getGame().GetGameCulture();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	ebp
	push	esi
	push	edi
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture

; 5942 : 	CvPlayer &kOriginator = GET_PLAYER(eOriginator);

	mov	edi, DWORD PTR _eOriginator$[esp+168]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5943 : 
; 5944 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+172]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5945 : 	CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_WORK_SWAP");

	lea	eax, DWORD PTR _strSummary$[esp+172]
	push	OFFSET $SG228048
	push	eax
	mov	DWORD PTR __$EHRec$[esp+188], 0
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+180], 1

; 5946 : 	if (eType == CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT())

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT

; 5947 : 	{
; 5948 : 		if (bArt)
; 5949 : 		{
; 5950 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_GREAT_WORK_ART_SWAP", kOriginator.getLeaderInfo().GetDescription(),
; 5951 : 				pkGameCulture->GetGreatWorkName(iWorkFromRecipient), pkGameCulture->GetGreatWorkName(iWorkFromOriginator));

	mov	ecx, edi
	cmp	DWORD PTR _eType$[esp+168], eax
	jne	$LN4@SendArtSwa
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	cmp	BYTE PTR _bArt$[esp+168], 0
	mov	ebp, DWORD PTR _iWorkFromOriginator$[esp+168]
	mov	DWORD PTR $T239299[esp+172], eax
	push	ebp
	je	$LN3@SendArtSwa
	lea	ecx, DWORD PTR $T239297[esp+176]
	push	ecx
	mov	ecx, esi
	call	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
	mov	ebx, eax
	mov	edx, DWORD PTR _iWorkFromRecipient$[esp+168]
	push	edx
	lea	eax, DWORD PTR $T239298[esp+176]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+188], 2
	call	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
	push	ebx
	push	eax
	lea	ecx, DWORD PTR $T239299[esp+180]
	push	ecx
	lea	edx, DWORD PTR $T239300[esp+184]
	push	OFFSET $SG228064
	push	edx
	mov	BYTE PTR __$EHRec$[esp+200], 3
	call	??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z ; GetLocalizedText<char const *,CvString,CvString>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239300[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T239298[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T239297[esp+172]

; 5952 : 		}
; 5953 : 		else

	jmp	$LN81@SendArtSwa
$LN3@SendArtSwa:

; 5954 : 		{
; 5955 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ARTIFACT_SWAP", kOriginator.getLeaderInfo().GetDescription(),
; 5956 : 				pkGameCulture->GetGreatWorkName(iWorkFromRecipient), pkGameCulture->GetGreatWorkName(iWorkFromOriginator));

	lea	eax, DWORD PTR $T239301[esp+176]
	push	eax
	mov	ecx, esi
	call	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
	mov	ebx, eax
	mov	ecx, DWORD PTR _iWorkFromRecipient$[esp+168]
	push	ecx
	lea	edx, DWORD PTR $T239302[esp+176]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+188], 5
	call	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T239303[esp+180]
	push	eax
	lea	ecx, DWORD PTR $T239304[esp+184]
	push	OFFSET $SG228070
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+200], 6
	call	??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z ; GetLocalizedText<char const *,CvString,CvString>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 7
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239304[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+180], 5

; 5957 : 		}
; 5958 : 	}
; 5959 : 	else

	jmp	$LN82@SendArtSwa
$LN4@SendArtSwa:

; 5960 : 	{
; 5961 : 		strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_GREAT_WORK_WRITING_SWAP", kOriginator.getLeaderInfo().GetDescription(),
; 5962 : 			pkGameCulture->GetGreatWorkName(iWorkFromRecipient), pkGameCulture->GetGreatWorkName(iWorkFromOriginator));

	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, DWORD PTR _iWorkFromOriginator$[esp+168]
	push	ebp
	lea	edx, DWORD PTR $T239305[esp+176]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T239307[esp+180], eax
	call	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
	mov	ebx, eax
	mov	eax, DWORD PTR _iWorkFromRecipient$[esp+168]
	push	eax
	lea	ecx, DWORD PTR $T239306[esp+176]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+188], 8
	call	?GetGreatWorkName@CvGameCulture@@QBE?AVCvString@@H@Z ; CvGameCulture::GetGreatWorkName
	push	ebx
	push	eax
	lea	edx, DWORD PTR $T239307[esp+180]
	push	edx
	lea	eax, DWORD PTR $T239308[esp+184]
	push	OFFSET $SG228076
	push	eax
	mov	BYTE PTR __$EHRec$[esp+200], 9
	call	??$GetLocalizedText@PBDVCvString@@V1@@@YA?AVCvString@@PBDABQBDABV0@2@Z ; GetLocalizedText<char const *,CvString,CvString>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 10		; 0000000aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239308[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+180], 8
$LN82@SendArtSwa:
	lea	ecx, DWORD PTR $T239306[esp+172]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T239305[esp+172]
$LN81@SendArtSwa:
	mov	BYTE PTR __$EHRec$[esp+180], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5963 : 	}
; 5964 : 	GET_PLAYER(eReceipient).GetNotifications()->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strBuffer, strSummary, -1, -1, iWorkFromOriginator, kOriginator.GetID());

	mov	edi, DWORD PTR [edi+44]
	lea	ecx, DWORD PTR _strSummary$[esp+172]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strBuffer$[esp+172]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _eReceipient$[esp+168]
	push	edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	-1
	push	-1
	push	esi
	push	eax
	push	-273578033				; efb187cfH
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 5965 : }

	lea	ecx, DWORD PTR _strSummary$[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$[esp+172]
	mov	DWORD PTR __$EHRec$[esp+180], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+172]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 156				; 0000009cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$2:
	lea	ecx, DWORD PTR $T239297[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$3:
	lea	ecx, DWORD PTR $T239298[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$4:
	lea	ecx, DWORD PTR $T239300[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$5:
	lea	ecx, DWORD PTR $T239301[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$6:
	lea	ecx, DWORD PTR $T239302[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$7:
	lea	ecx, DWORD PTR $T239304[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$8:
	lea	ecx, DWORD PTR $T239305[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$9:
	lea	ecx, DWORD PTR $T239306[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z$10:
	lea	ecx, DWORD PTR $T239308[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z ENDP ; CultureHelpers::SendArtSwapNotification
PUBLIC	?begin@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@XZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@XZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@XZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::end
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 12					; 0000000cH
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator++
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@XZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::end
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvGreatWork@@$0A@@@IAEXPAVCvGreatWork@@I@Z ; BaseVector<CvGreatWork,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@VCvGreatWork@@$0A@@@IAEXPAVCvGreatWork@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvGreatWork@@$0A@@@IAEXPAVCvGreatWork@@I@Z PROC ; BaseVector<CvGreatWork,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	npad	2
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 48					; 00000030H
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvGreatWork@@$0A@@@IAEXPAVCvGreatWork@@I@Z ENDP ; BaseVector<CvGreatWork,0>::Destroy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE_NI@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkBuildingInMyEmpire>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z ; std::_Allocate<enum PlayerTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE_NI@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkInMyEmpire>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z ; std::_Allocate<enum EraTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Buy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator+
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Ucopy
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Ucopy:
	pop	edi
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	12					; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum PlayerTypes *,enum PlayerTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum PlayerTypes *,enum PlayerTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@3
	push	esi
$LL12@Unchecked_@3:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@3
	pop	esi
$LN11@Unchecked_@3:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum PlayerTypes *,enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z
_TEXT	SEGMENT
$T239944 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239947 = 16					; size = 1
$T239927 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$239947[esp]
	mov	edx, DWORD PTR $T239927[esp]
	mov	BYTE PTR $T239944[esp+4], 0
	mov	eax, DWORD PTR $T239944[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum EraTypes *,enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum EraTypes *,enum EraTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@4
	push	esi
$LL12@Unchecked_@4:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@4
	pop	esi
$LN11@Unchecked_@4:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum EraTypes *,enum EraTypes *>
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::_Find<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z PROC ; std::_Find<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN23@Find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@Find:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN23@Find
	add	ecx, 4
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL9@Find
$LN23@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ENDP ; std::_Find<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z ; std::_Find<std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >,enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z PROC ; std::_Find<std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >,enum EraTypes>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN23@Find@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@Find@2:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN23@Find@2
	add	ecx, 4
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL9@Find@2
$LN23@Find@2:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z ENDP ; std::_Find<std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >,enum EraTypes>
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z ; std::_Find<std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z PROC ; std::_Find<std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >,enum PlayerTypes>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN23@Find@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@Find@3:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN23@Find@3
	add	ecx, 4
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL9@Find@3
$LN23@Find@3:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z ENDP ; std::_Find<std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z
_TEXT	SEGMENT
$T240101 = -4						; size = 1
__Cat$240105 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240101[esp+4], 0
	mov	eax, DWORD PTR $T240101[esp+4]
	mov	ecx, DWORD PTR __Cat$240105[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z
_TEXT	SEGMENT
$T240110 = -4						; size = 1
__Cat$240114 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240110[esp+4], 0
	mov	eax, DWORD PTR $T240110[esp+4]
	mov	ecx, DWORD PTR __Cat$240114[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z
_TEXT	SEGMENT
$T240119 = -4						; size = 1
__Cat$240123 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240119[esp+4], 0
	mov	eax, DWORD PTR $T240119[esp+4]
	mov	ecx, DWORD PTR __Cat$240123[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum PlayerTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	edx, DWORD PTR __Count$[esp-4]
	test	edx, edx
	jbe	SHORT $LN4@Uninit_fil@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@3:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
$LN5@Uninit_fil@3:
	dec	edx
	add	eax, 24					; 00000018H
	test	edx, edx
	ja	SHORT $LL6@Uninit_fil@3
	pop	esi
$LN4@Uninit_fil@3:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum EraTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@4
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@4:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@4
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil@4:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@4
	pop	esi
$LN4@Uninit_fil@4:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@7
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@7:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@7
	pop	esi
$LN7@unchecked_@7:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240376 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240379 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$240379[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240376[esp+4], 0
	mov	eax, DWORD PTR $T240376[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240395 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240398 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$240398[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240395[esp+4], 0
	mov	eax, DWORD PTR $T240395[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240414 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240417 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$240417[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240414[esp+4], 0
	mov	eax, DWORD PTR $T240414[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-, COMDAT
; _this$ = ecx

; 392  : 		_Myt _Tmp = *this;
; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	sub	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 394  : 		}

	ret	8
??G?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::operator-
_TEXT	ENDS
PUBLIC	??$_Median@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Median<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Median@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::_Median<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 3169 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	edx, esi
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3170 : 		{	// median of nine
; 3171 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx

; 3172 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

	mov	ebx, DWORD PTR __Pred$[esp+4]
	push	edi
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	lea	edi, DWORD PTR [eax+eax*2]
	add	edi, edi
	lea	esi, DWORD PTR [eax+eax*2]
	add	edi, edi
	add	edi, edi
	add	esi, esi
	push	ebx
	lea	edx, DWORD PTR [edi+ecx]
	add	esi, esi
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 3173 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	ecx, DWORD PTR __Mid$[esp+24]
	push	ebx
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	mov	eax, ecx
	sub	eax, esi
	push	ecx
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 3174 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

	mov	edx, DWORD PTR __Last$[esp+40]
	push	ebx
	mov	eax, edx
	push	edx
	sub	eax, esi
	mov	ecx, edx
	sub	ecx, edi
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 3175 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	edx, DWORD PTR __Mid$[esp+56]
	push	ebx
	sub	eax, esi
	push	eax
	add	ecx, esi
	push	edx
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 64					; 00000040H
	pop	edi
	pop	ebx
	pop	esi

; 3179 : 	}

	ret	0
$LN2@Median:

; 3176 : 		}
; 3177 : 	else
; 3178 : 		std::_Med3(_First, _Mid, _Last, _Pred);

	mov	eax, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Mid$[esp]
	push	eax
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Med3<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 16					; 00000010H
	pop	esi

; 3179 : 	}

	ret	0
??$_Median@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::_Median<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z
_TEXT	SEGMENT
$T240633 = -4						; size = 1
__Cat$240637 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240633[esp+4], 0
	mov	eax, DWORD PTR $T240633[esp+4]
	mov	ecx, DWORD PTR __Cat$240637[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T240642 = -4						; size = 1
__Cat$240648 = 8					; size = 1
$T240644 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240648[esp]
	mov	edx, DWORD PTR $T240644[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240642[esp+8], 0
	mov	eax, DWORD PTR $T240642[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> > >
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ; std::_Push_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 12
__Pred$ = 32						; size = 4
??$_Push_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2013 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp

; 2014 : 	for (_Diff _Idx = (_Hole - 1) / 2;
; 2015 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2016 : 		_Idx = (_Hole - 1) / 2)

	mov	ebp, DWORD PTR __Top$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Hole$[esp+8]
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	cmp	ebp, edi
	jge	SHORT $LN1@Push_heap
	push	ebx
	npad	6
$LL3@Push_heap:
	mov	eax, DWORD PTR __First$[esp+12]
	lea	ebx, DWORD PTR [esi+esi*2]
	add	ebx, ebx
	lea	ecx, DWORD PTR __Val$[esp+12]
	add	ebx, ebx
	add	eax, ebx
	push	ecx
	push	eax
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN48@Push_heap

; 2017 : 		{	// move _Hole up to parent
; 2018 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	ecx, DWORD PTR __First$[esp+12]
	lea	eax, DWORD PTR [ebx+ecx]
	lea	edx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx

; 2019 : 		_Hole = _Idx;

	mov	edi, esi
	sar	eax, 1
	cmp	ebp, edi
	mov	esi, eax
	jl	SHORT $LL3@Push_heap
$LN48@Push_heap:
	pop	ebx
$LN1@Push_heap:

; 2020 : 		}
; 2021 : 
; 2022 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	edx, DWORD PTR __First$[esp+8]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$[esp+12]
	pop	edi
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$[esp+12]
	pop	esi
	mov	DWORD PTR [eax+8], ecx
	pop	ebp

; 2023 : 	}

	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@6
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@6:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@5:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@8
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@8:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@8
	pop	esi
$LN7@unchecked_@8:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?GetBaseTourismBeforeModifiers@CvCityCulture@@QAEHXZ ; CvCityCulture::GetBaseTourismBeforeModifiers
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetEnhancedYieldTech
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTechEnhancedTourism
EXTRN	?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvReligionBeliefs::GetBuildingClassTourism
EXTRN	?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ:PROC ; CvCityBuildings::GetNumBuildingsFromFaith
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ:PROC ; CvCityReligions::GetReligiousMajority
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ:PROC ; CvCityBuildings::GetLandmarksTourismPercent
EXTRN	?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ:PROC ; CvCityBuildings::GetGreatWorksTourismModifier
EXTRN	?getNumWorldWonders@CvCity@@QBEHXZ:PROC		; CvCity::getNumWorldWonders
EXTRN	?IsRazing@CvCity@@QBE_NXZ:PROC			; CvCity::IsRazing
EXTRN	?IsResistance@CvCity@@QBE_NXZ:PROC		; CvCity::IsResistance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
;	COMDAT ?GetBaseTourismBeforeModifiers@CvCityCulture@@QAEHXZ
_TEXT	SEGMENT
_jJ$227033 = -8						; size = 4
_iFromNaturalWonders$227013 = -8			; size = 4
_iTourism$227047 = -4					; size = 4
?GetBaseTourismBeforeModifiers@CvCityCulture@@QAEHXZ PROC ; CvCityCulture::GetBaseTourismBeforeModifiers, COMDAT
; _this$ = ecx

; 4465 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 4466 : 	// If we're in Resistance, then no Tourism!
; 4467 : 	if(m_pCity->IsResistance() || m_pCity->IsRazing())

	mov	ecx, DWORD PTR [esi]
	call	?IsResistance@CvCity@@QBE_NXZ		; CvCity::IsResistance
	test	al, al
	jne	$LN17@GetBaseTou
	mov	ecx, DWORD PTR [esi]
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	test	al, al
	jne	$LN17@GetBaseTou

; 4470 : 	}
; 4471 : 
; 4472 : 	int iBonusTourismPerGreatWork = GET_PLAYER(m_pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_TOURISM_PER_GREAT_WORK); // NQMP GJS - Cultural Exchange

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	edi
	push	63					; 0000003fH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 4473 : 
; 4474 : 	int iBonusTourismPerWonder = GET_PLAYER(m_pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_PER_WONDER); // NQMP GJS - Flourishing of the Arts

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	64					; 00000040H
	mov	edi, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 4475 : 	int iTotalBonusTourismForWonders = m_pCity->getNumWorldWonders() * iBonusTourismPerWonder;

	mov	ecx, DWORD PTR [esi]
	mov	ebp, eax
	call	?getNumWorldWonders@CvCity@@QBEHXZ	; CvCity::getNumWorldWonders

; 4476 : 
; 4477 : 	int iBase = GetNumGreatWorks() * (GC.getBASE_TOURISM_PER_GREAT_WORK() + iBonusTourismPerGreatWork) + iTotalBonusTourismForWonders; // NQMP GJS - Cultural Exchange

	mov	ecx, DWORD PTR [esi]
	mov	ebx, eax
	imul	ebx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8212

; 4478 : 
; 4479 : 	int iBonus = (m_pCity->GetCityBuildings()->GetGreatWorksTourismModifier() * iBase / 100);

	mov	ecx, DWORD PTR [esi]
	add	edi, edx
	imul	edi, eax
	add	edi, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetGreatWorksTourismModifier
	mov	ecx, eax
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 4480 : 	iBase += iBonus;
; 4481 : 
; 4482 : 	iBase += m_pCity->GetCityBuildings()->GetThemingBonuses();

	mov	ecx, DWORD PTR [esi]
	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetThemingBonuses@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetThemingBonuses

; 4483 : 
; 4484 : 	int iPercent = m_pCity->GetCityBuildings()->GetLandmarksTourismPercent();

	mov	ecx, DWORD PTR [esi]
	add	eax, ebx
	add	edi, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetLandmarksTourismPercent
	mov	ebx, eax

; 4485 : 	if (iPercent > 0)

	test	ebx, ebx
	jle	SHORT $LN16@GetBaseTou

; 4486 : 	{
; 4487 : 		int iFromWonders = GetCultureFromWonders();

	mov	ecx, esi
	call	?GetCultureFromWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromWonders

; 4488 : 		int iFromNaturalWonders = GetCultureFromNaturalWonders();

	mov	ecx, esi
	mov	ebp, eax
	call	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromNaturalWonders

; 4489 : 		int iFromImprovements = GetCultureFromImprovements();

	mov	ecx, esi
	mov	DWORD PTR _iFromNaturalWonders$227013[esp+24], eax
	call	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromImprovements
	mov	ecx, eax

; 4490 : 		iBase += ((iFromWonders + iFromNaturalWonders + iFromImprovements) * iPercent / 100);

	add	ecx, DWORD PTR _iFromNaturalWonders$227013[esp+24]
	mov	eax, 1374389535				; 51eb851fH
	add	ecx, ebp
	imul	ecx, ebx
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	edi, eax
$LN16@GetBaseTou:

; 4491 : 	}
; 4492 : 
; 4493 : 	ReligionTypes eMajority = m_pCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, DWORD PTR [esi]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority

; 4494 : 	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, m_pCity->getOwner());

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	ebp, eax

; 4495 : 	if(pReligion)

	test	ebp, ebp
	je	$LN69@GetBaseTou

; 4496 : 	{
; 4497 : 		int iFaithBuildingTourism = pReligion->m_Beliefs.GetFaithBuildingTourism();

	mov	ebx, DWORD PTR [ebp+272]

; 4498 : 		if (iFaithBuildingTourism > 0)

	test	ebx, ebx
	jle	SHORT $LN14@GetBaseTou

; 4499 : 		{
; 4500 : 			iBase += m_pCity->GetCityBuildings()->GetNumBuildingsFromFaith() * iFaithBuildingTourism;

	mov	ecx, DWORD PTR [esi]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumBuildingsFromFaith
	imul	eax, ebx
	add	edi, eax
$LN14@GetBaseTou:

; 4501 : 		}
; 4502 : 
; 4503 : 		// Buildings
; 4504 : #ifdef AUI_WARNING_FIXES
; 4505 : 		for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 4506 : #else
; 4507 : 		for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN69@GetBaseTou
$LL13@GetBaseTou:

; 4508 : #endif
; 4509 : 		{
; 4510 : 			BuildingClassTypes eBuildingClass = (BuildingClassTypes)jJ;
; 4511 : 
; 4512 : 			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 4513 : 			if(!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN12@GetBaseTou

; 4514 : 			{
; 4515 : 				continue;
; 4516 : 			}
; 4517 : 
; 4518 : 			CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(m_pCity->getOwner()).getCivilizationInfo();

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4519 : 			BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);

	push	ebx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 4520 : 
; 4521 : 			if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN12@GetBaseTou

; 4522 : 			{
; 4523 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN12@GetBaseTou

; 4524 : 				{
; 4525 : 					iBase += pReligion->m_Beliefs.GetBuildingClassTourism(eBuildingClass);

	push	ebx
	lea	ecx, DWORD PTR [ebp+152]
	call	?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z ; CvReligionBeliefs::GetBuildingClassTourism
	add	edi, eax
$LN12@GetBaseTou:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	SHORT $LL13@GetBaseTou
$LN69@GetBaseTou:

; 4526 : 				}
; 4527 : 			}
; 4528 : 		}
; 4529 : 	}
; 4530 : 
; 4531 : 	// Tech enhanced Tourism
; 4532 : #ifdef AUI_WARNING_FIXES
; 4533 : 	for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 4534 : #else
; 4535 : 	for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	xor	ebp, ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _jJ$227033[esp+24], ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN5@GetBaseTou
	npad	5
$LL7@GetBaseTou:

; 4536 : #endif
; 4537 : 	{
; 4538 : 		BuildingClassTypes eBuildingClass = (BuildingClassTypes)jJ;
; 4539 : 
; 4540 : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 4541 : 		if(!pkBuildingClassInfo)

	test	eax, eax
	je	$LN6@GetBaseTou

; 4542 : 		{
; 4543 : 			continue;
; 4544 : 		}
; 4545 : 
; 4546 : 		CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(m_pCity->getOwner()).getCivilizationInfo();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4547 : 		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);

	push	ebp
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	ebx, eax

; 4548 : 
; 4549 : 		if(eBuilding != NO_BUILDING)

	cmp	ebx, -1
	je	SHORT $LN6@GetBaseTou

; 4550 : 		{
; 4551 : 			CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebp, eax

; 4552 : 			if(pkEntry && m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	test	ebp, ebp
	je	SHORT $LN70@GetBaseTou
	mov	ecx, DWORD PTR [esi]
	push	ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN70@GetBaseTou

; 4553 : 			{
; 4554 : 				int iTourism = pkEntry->GetTechEnhancedTourism();

	mov	ecx, ebp
	call	?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTechEnhancedTourism
	mov	DWORD PTR _iTourism$227047[esp+24], eax

; 4555 : 				if (iTourism > 0 && GET_TEAM(m_pCity->getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEntry->GetEnhancedYieldTech()))

	test	eax, eax
	jle	SHORT $LN70@GetBaseTou
	mov	ecx, DWORD PTR [esi]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetEnhancedYieldTech
	push	eax
	mov	ecx, ebx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN70@GetBaseTou

; 4556 : 				{
; 4557 : 					iBase += iTourism;

	add	edi, DWORD PTR _iTourism$227047[esp+24]
$LN70@GetBaseTou:
	mov	ebp, DWORD PTR _jJ$227033[esp+24]
$LN6@GetBaseTou:

; 4526 : 				}
; 4527 : 			}
; 4528 : 		}
; 4529 : 	}
; 4530 : 
; 4531 : 	// Tech enhanced Tourism
; 4532 : #ifdef AUI_WARNING_FIXES
; 4533 : 	for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 4534 : #else
; 4535 : 	for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _jJ$227033[esp+24], ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	$LL7@GetBaseTou
$LN5@GetBaseTou:

; 4558 : 				}
; 4559 : 			}
; 4560 : 		}
; 4561 : 	}
; 4562 : 
; 4563 : #ifdef NQ_TOURISM_PER_CITY
; 4564 : 	iBase += GET_PLAYER(m_pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_PER_CITY);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	65					; 00000041H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, edi
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 4565 : #endif
; 4566 : 
; 4567 : 	return iBase;
; 4568 : }

	add	esp, 8
	ret	0
$LN17@GetBaseTou:

; 4468 : 	{
; 4469 : 		return 0;

	xor	eax, eax
	pop	esi

; 4565 : #endif
; 4566 : 
; 4567 : 	return iBase;
; 4568 : }

	add	esp, 8
	ret	0
?GetBaseTourismBeforeModifiers@CvCityCulture@@QAEHXZ ENDP ; CvCityCulture::GetBaseTourismBeforeModifiers
_TEXT	ENDS
PUBLIC	?GetBaseTourism@CvCityCulture@@QAEHXZ		; CvCityCulture::GetBaseTourism
EXTRN	?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z:PROC ; CvPlayerPolicies::GetBuildingClassTourismModifier
EXTRN	?GetCityTourismModifier@CvGameLeagues@@QAEHW4PlayerTypes@@PBVCvCity@@@Z:PROC ; CvGameLeagues::GetCityTourismModifier
EXTRN	?GetTourismBonusTurns@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetTourismBonusTurns
EXTRN	?GetInfluenceSpreadModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetInfluenceSpreadModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseTourism@CvCityCulture@@QAEHXZ
_TEXT	SEGMENT
_iModifier$ = -12					; size = 4
_this$ = -8						; size = 4
_iBase$ = -4						; size = 4
?GetBaseTourism@CvCityCulture@@QAEHXZ PROC		; CvCityCulture::GetBaseTourism, COMDAT
; _this$ = ecx

; 4576 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+28], edi

; 4577 : 	int iBase = GetBaseTourismBeforeModifiers();

	call	?GetBaseTourismBeforeModifiers@CvCityCulture@@QAEHXZ ; CvCityCulture::GetBaseTourismBeforeModifiers
	mov	ebp, eax

; 4578 : 
; 4579 : 	int iModifier = 0;
; 4580 : 
; 4581 : 	CvPlayer &kPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+84]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _iBase$[esp+28], ebp

; 4582 : 	int iTechSpreadModifier = kPlayer.GetInfluenceSpreadModifier();

	mov	ecx, esi
	mov	DWORD PTR _iModifier$[esp+28], 0
	call	?GetInfluenceSpreadModifier@CvPlayer@@QBEHXZ ; CvPlayer::GetInfluenceSpreadModifier

; 4583 : 	if (iTechSpreadModifier > 0)

	test	eax, eax
	jle	SHORT $LN11@GetBaseTou@2

; 4584 : 	{
; 4585 : 		iModifier += iTechSpreadModifier;

	mov	DWORD PTR _iModifier$[esp+28], eax
$LN11@GetBaseTou@2:

; 4586 : 	}
; 4587 : 
; 4588 : 	if (kPlayer.GetTourismBonusTurns() > 0)

	mov	ecx, esi
	call	?GetTourismBonusTurns@CvPlayer@@QBEHXZ	; CvPlayer::GetTourismBonusTurns

; 4589 : 	{
; 4590 : 		iModifier += GC.getTEMPORARY_TOURISM_BOOST_MOD();

	mov	ebx, DWORD PTR _iModifier$[esp+28]
	test	eax, eax
	jle	SHORT $LN10@GetBaseTou@2
	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8304
	mov	DWORD PTR _iModifier$[esp+28], ebx
$LN10@GetBaseTou@2:

; 4591 : 	}
; 4592 : 
; 4593 : 	int iLeagueCityModifier = GC.getGame().GetGameLeagues()->GetCityTourismModifier(m_pCity->getOwner(), m_pCity);

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetCityTourismModifier@CvGameLeagues@@QAEHW4PlayerTypes@@PBVCvCity@@@Z ; CvGameLeagues::GetCityTourismModifier

; 4594 : 	if (iLeagueCityModifier > 0)

	test	eax, eax
	jle	SHORT $LN9@GetBaseTou@2

; 4595 : 	{
; 4596 : 		iModifier += iLeagueCityModifier;

	add	ebx, eax
	mov	DWORD PTR _iModifier$[esp+28], ebx
$LN9@GetBaseTou@2:

; 4597 : 	}
; 4598 : 
; 4599 : 	if (kPlayer.isGoldenAge())

	mov	ecx, esi
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN8@GetBaseTou@2

; 4600 : 	{
; 4601 : 		iModifier += kPlayer.GetPlayerTraits()->GetGoldenAgeTourismModifier();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	ebx, DWORD PTR [eax+184]
	mov	DWORD PTR _iModifier$[esp+28], ebx
$LN8@GetBaseTou@2:

; 4602 : 	}
; 4603 : 	
; 4604 : 
; 4605 : 	int iBuildingMod = 0;
; 4606 : #ifdef AUI_WARNING_FIXES
; 4607 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4608 : #else
; 4609 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN5@GetBaseTou@2
$LL7@GetBaseTou@2:

; 4610 : #endif
; 4611 : 	{
; 4612 : 		CvCivilizationInfo& playerCivilizationInfo = kPlayer.getCivilizationInfo();

	mov	ecx, esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4613 : 		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	ebx, eax

; 4614 : 		if (eBuilding != NO_BUILDING)

	cmp	ebx, -1
	je	SHORT $LN6@GetBaseTou@2

; 4615 : 		{
; 4616 : 			CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 4617 : 			if (pkEntry)

	test	eax, eax
	je	SHORT $LN6@GetBaseTou@2

; 4618 : 			{
; 4619 : 				iBuildingMod = kPlayer.GetPlayerPolicies()->GetBuildingClassTourismModifier((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassTourismModifier
	mov	ebp, eax

; 4620 : 				if (iBuildingMod != 0 && m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	test	ebp, ebp
	je	SHORT $LN6@GetBaseTou@2
	mov	ecx, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN6@GetBaseTou@2

; 4621 : 				{
; 4622 : 					iModifier += iBuildingMod;

	add	DWORD PTR _iModifier$[esp+28], ebp
$LN6@GetBaseTou@2:

; 4602 : 	}
; 4603 : 	
; 4604 : 
; 4605 : 	int iBuildingMod = 0;
; 4606 : #ifdef AUI_WARNING_FIXES
; 4607 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4608 : #else
; 4609 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL7@GetBaseTou@2
	mov	ebx, DWORD PTR _iModifier$[esp+28]
	mov	ebp, DWORD PTR _iBase$[esp+28]
$LN5@GetBaseTou@2:

; 4623 : 				}
; 4624 : 			}
; 4625 : 		}
; 4626 : 	}
; 4627 : 
; 4628 : 	if (iModifier > 0)

	test	ebx, ebx
	jle	SHORT $LN32@GetBaseTou@2

; 4629 : 	{
; 4630 : 		iBase = iBase * (100 + iModifier) / 100;

	lea	ecx, DWORD PTR [ebx+100]
	imul	ecx, ebp
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebp
	add	eax, edx
	pop	ebx

; 4634 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN32@GetBaseTou@2:
	pop	edi
	pop	esi

; 4631 : 	}
; 4632 : 
; 4633 : 	return iBase;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 4634 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetBaseTourism@CvCityCulture@@QAEHXZ ENDP		; CvCityCulture::GetBaseTourism
_TEXT	ENDS
PUBLIC	?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ ; CvCityCulture::GetTourismTooltip
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ DD 019930522H
	DD	022H
	DD	FLAT:__unwindtable$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$10
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$11
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$12
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$13
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$14
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$15
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$16
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$17
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$18
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$19
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$20
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$21
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$22
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$23
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$24
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$25
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$26
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$27
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$28
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$29
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$30
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$31
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$32
	DD	08H
	DD	FLAT:__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$33
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
$T241396 = -324						; size = 4
_iSharedIdeologyMod$ = -324				; size = 4
$T241109 = -324						; size = 4
_pkEntry$227257 = -324					; size = 4
_iFaithBuildingTourism$227204 = -324			; size = 4
_iFromNaturalWonders$227187 = -324			; size = 4
_iNumWorldWonders$ = -324				; size = 4
$T241099 = -324						; size = 4
_iCommonFoeMod$ = -320					; size = 4
_jJ$227227 = -320					; size = 4
_iReligiousArtTourism$ = -320				; size = 4
_kCityPlayer$ = -316					; size = 4
_iLessHappyMod$ = -312					; size = 4
_iBuildingMod$ = -312					; size = 4
_iTechEnhancedTourism$227240 = -312			; size = 4
_pReligion$ = -312					; size = 4
_iTotalBonusTourismForWonders$ = -312			; size = 4
_kPlayer$227282 = -308					; size = 4
_iBuildingClassLoop$227248 = -308			; size = 4
_eTheirIdeology$227284 = -304				; size = 4
_iPercent$ = -304					; size = 4
_iGWTourism$ = -304					; size = 4
tv2525 = -300						; size = 4
_iTileTourism$ = -300					; size = 4
$T241126 = -296						; size = 28
$T241125 = -296						; size = 28
$T241124 = -296						; size = 28
$T241123 = -296						; size = 28
$T241122 = -296						; size = 28
$T241121 = -296						; size = 28
$T241120 = -296						; size = 28
$T241119 = -296						; size = 28
$T241118 = -296						; size = 28
$T241117 = -296						; size = 28
$T241116 = -296						; size = 28
$T241115 = -296						; size = 28
$T241114 = -296						; size = 28
$T241113 = -296						; size = 28
$T241112 = -296						; size = 28
$T241111 = -296						; size = 28
$T241110 = -296						; size = 28
$T241108 = -296						; size = 28
$T241107 = -296						; size = 28
$T241106 = -296						; size = 28
$T241105 = -296						; size = 28
$T241104 = -296						; size = 28
$T241103 = -296						; size = 28
$T241102 = -296						; size = 28
$T241100 = -296						; size = 28
_rank$227303 = -268					; size = 4
$T241101 = -268						; size = 4
_iLoopPlayer$227278 = -264				; size = 4
_eMyIdeology$ = -260					; size = 4
_totalEnemies$227304 = -256				; size = 4
_szTemp$ = -252						; size = 28
$T241128 = -224						; size = 4
_ePlayerReligion$ = -220				; size = 4
_eTeam$ = -216						; size = 4
_myStrength$227305 = -212				; size = 4
_lessHappyCivs$ = -208					; size = 28
_openBordersCivs$ = -180				; size = 28
_sharedReligionCivs$ = -152				; size = 28
_tradeRouteCivs$ = -124					; size = 28
_sharedIdeologyCivs$ = -96				; size = 28
_differentIdeologyCivs$ = -68				; size = 28
_commonFoeCivs$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ PROC ; CvCityCulture::GetTourismTooltip, COMDAT
; _this$ = ecx

; 4764 : {

	push	-1
	push	__ehhandler$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T241128[esp+340], edi

; 4765 : 	CvString szRtnValue = "";

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+336]
	mov	esi, ecx
	push	OFFSET $SG227128
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+352], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 5175 : 	}
; 5176 : 
; 5177 : 	return szRtnValue;

	mov	DWORD PTR __$EHRec$[esp+348], edi
	mov	edi, 1
	lea	ecx, DWORD PTR _szTemp$[esp+340]
	mov	DWORD PTR $T241128[esp+340], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	push	OFFSET $SG227131
	lea	ecx, DWORD PTR _sharedReligionCivs$[esp+344]
	mov	DWORD PTR __$EHRec$[esp+352], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG227133
	lea	ecx, DWORD PTR _openBordersCivs$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG227135
	lea	ecx, DWORD PTR _tradeRouteCivs$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG227137
	lea	ecx, DWORD PTR _lessHappyCivs$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG227139
	lea	ecx, DWORD PTR _commonFoeCivs$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG227141
	lea	ecx, DWORD PTR _sharedIdeologyCivs$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG227143
	lea	ecx, DWORD PTR _differentIdeologyCivs$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR _eTeam$[esp+340], eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, eax
	mov	ecx, edi
	mov	DWORD PTR _kCityPlayer$[esp+340], edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	ecx, edi
	mov	DWORD PTR _eMyIdeology$[esp+340], eax
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionInMostCities@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionInMostCities
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _ePlayerReligion$[esp+340], eax
	mov	eax, DWORD PTR [ecx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	63					; 0000003fH
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8212
	mov	ecx, DWORD PTR [esi]
	lea	ebx, DWORD PTR [edx+edi]
	imul	ebx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetGreatWorksTourismModifier
	mov	ecx, eax
	imul	ecx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR [esi]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	ebx, eax
	mov	DWORD PTR _iGWTourism$[esp+340], ebx
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, DWORD PTR [eax]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	lea	ecx, DWORD PTR $T241099[esp+340]
	push	ecx
	lea	edx, DWORD PTR _iGWTourism$[esp+344]
	push	edx
	mov	DWORD PTR $T241099[esp+348], eax
	lea	eax, DWORD PTR $T241100[esp+348]
	push	OFFSET $SG227159
	push	eax
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 9
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241100[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	64					; 00000040H
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	call	?getNumWorldWonders@CvCity@@QBEHXZ	; CvCity::getNumWorldWonders
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _iNumWorldWonders$[esp+340], eax
	imul	eax, edi
	mov	edi, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetGreatWorksTourismModifier
	mov	ecx, eax
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR [esi]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	edi, eax
	mov	DWORD PTR _iTotalBonusTourismForWonders$[esp+340], edi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, DWORD PTR [eax]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	lea	ecx, DWORD PTR _iNumWorldWonders$[esp+340]
	push	ecx
	lea	edx, DWORD PTR _iTotalBonusTourismForWonders$[esp+344]
	push	edx
	mov	DWORD PTR $T241101[esp+348], eax
	lea	eax, DWORD PTR $T241101[esp+348]
	push	eax
	lea	ecx, DWORD PTR _iGWTourism$[esp+352]
	push	ecx
	lea	edx, DWORD PTR $T241102[esp+356]
	push	OFFSET $SG227177
	push	edx
	call	??$GetLocalizedText@HHHH@@YA?AVCvString@@PBDABH111@Z ; GetLocalizedText<int,int,int,int>
	add	esp, 24					; 00000018H
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 10		; 0000000aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241102[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR [esi]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetThemingBonuses@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetThemingBonuses
	mov	edi, eax
	test	edi, edi
	jle	SHORT $LN77@GetTourism@4
	push	OFFSET $SG227180
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	push	edi
	lea	eax, DWORD PTR $T241103[esp+344]
	push	OFFSET $SG227182
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 11		; 0000000bH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241103[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN77@GetTourism@4:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _iTileTourism$[esp+340], 0
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetLandmarksTourismPercent
	mov	DWORD PTR _iPercent$[esp+340], eax
	test	eax, eax
	jle	$LN76@GetTourism@4
	mov	ecx, esi
	call	?GetCultureFromWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromWonders
	mov	ecx, esi
	mov	edi, eax
	call	?GetCultureFromNaturalWonders@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromNaturalWonders
	mov	ecx, esi
	mov	DWORD PTR _iFromNaturalWonders$227187[esp+340], eax
	call	?GetCultureFromImprovements@CvCityCulture@@QBEHXZ ; CvCityCulture::GetCultureFromImprovements
	mov	ecx, DWORD PTR _iFromNaturalWonders$227187[esp+340]
	add	ecx, eax
	add	ecx, edi
	imul	ecx, DWORD PTR _iPercent$[esp+340]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR [ebp+20], 0
	mov	DWORD PTR _iTileTourism$[esp+340], eax
	jbe	SHORT $LN75@GetTourism@4
	push	OFFSET $SG227190
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN75@GetTourism@4:
	lea	edx, DWORD PTR _iPercent$[esp+340]
	push	edx
	lea	eax, DWORD PTR _iTileTourism$[esp+344]
	push	eax
	lea	ecx, DWORD PTR $T241104[esp+348]
	push	OFFSET $SG227192
	push	ecx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 12		; 0000000cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241104[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN76@GetTourism@4:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	65					; 00000041H
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	edi, eax
	test	edi, edi
	jle	SHORT $LN74@GetTourism@4

; 4766 : 	CvString szTemp;
; 4767 :  	CvString sharedReligionCivs = "";
; 4768 : 	CvString openBordersCivs = "";
; 4769 : 	CvString tradeRouteCivs = "";
; 4770 : 	CvString lessHappyCivs = "";
; 4771 : 	CvString commonFoeCivs = "";
; 4772 : 	CvString sharedIdeologyCivs = "";
; 4773 : 	CvString differentIdeologyCivs = "";
; 4774 : 	TeamTypes eTeam = m_pCity->getTeam();
; 4775 : 	CvPlayer &kCityPlayer = GET_PLAYER(m_pCity->getOwner());
; 4776 : 	PolicyBranchTypes eMyIdeology = kCityPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
; 4777 : 	ReligionTypes ePlayerReligion = kCityPlayer.GetReligions()->GetReligionInMostCities();
; 4778 : 
; 4779 : 	// Great Works
; 4780 : 	int iBonusTourismPerGreatWork = GET_PLAYER(m_pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_TOURISM_PER_GREAT_WORK); // NQMP GJS - Cultural Exchange
; 4781 : #ifdef AUI_WARNING_FIXES
; 4782 : 	int iGWTourism = (int)GetNumGreatWorks() * (GC.getBASE_TOURISM_PER_GREAT_WORK() + iBonusTourismPerGreatWork); // NQMP GJS - Cultural Exchange
; 4783 : 	iGWTourism += (m_pCity->GetCityBuildings()->GetGreatWorksTourismModifier() * iGWTourism / 100);
; 4784 : 	szRtnValue = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_GREAT_WORKS", iGWTourism, (int)m_pCity->GetCityCulture()->GetNumGreatWorks());
; 4785 : #else
; 4786 : 	int iGWTourism = GetNumGreatWorks() * (GC.getBASE_TOURISM_PER_GREAT_WORK() + iBonusTourismPerGreatWork); // NQMP GJS - Cultural Exchange
; 4787 : 	iGWTourism += (m_pCity->GetCityBuildings()->GetGreatWorksTourismModifier() * iGWTourism / 100);
; 4788 : 	szRtnValue = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_GREAT_WORKS", iGWTourism, m_pCity->GetCityCulture()->GetNumGreatWorks());
; 4789 : #endif
; 4790 : 
; 4791 : 	// NQMP GJS - Flourishing of the Arts BEGIN
; 4792 : 	int iBonusTourismPerWonder = GET_PLAYER(m_pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_PER_WONDER);
; 4793 : 	int iNumWorldWonders = m_pCity->getNumWorldWonders();
; 4794 : 	int iTotalBonusTourismForWonders = iNumWorldWonders * iBonusTourismPerWonder; 
; 4795 : 	iTotalBonusTourismForWonders += (m_pCity->GetCityBuildings()->GetGreatWorksTourismModifier() * iTotalBonusTourismForWonders / 100);
; 4796 : 	szRtnValue = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_GREAT_WORKS", iGWTourism, (int)m_pCity->GetCityCulture()->GetNumGreatWorks(), iTotalBonusTourismForWonders, iNumWorldWonders); // edited
; 4797 : 	// NQMP GJS - Flourishing of the Arts END
; 4798 : 
; 4799 : 	int iThemingBonuses = m_pCity->GetCityBuildings()->GetThemingBonuses();
; 4800 : 	if (iThemingBonuses > 0)
; 4801 : 	{
; 4802 : 		szRtnValue += "[NEWLINE][NEWLINE]";
; 4803 : 		szRtnValue += GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_THEMING_BONUSES", iThemingBonuses);
; 4804 : 	}
; 4805 : 
; 4806 : 	// Landmarks, Wonders, Natural Wonders, Improvements
; 4807 : 	int iTileTourism = 0;
; 4808 : 	int iPercent = m_pCity->GetCityBuildings()->GetLandmarksTourismPercent();
; 4809 : 	if (iPercent > 0)
; 4810 : 	{
; 4811 : 		int iFromWonders = GetCultureFromWonders();
; 4812 : 		int iFromNaturalWonders = GetCultureFromNaturalWonders();
; 4813 : 		int iFromImprovements = GetCultureFromImprovements();
; 4814 : 		iTileTourism = ((iFromWonders + iFromNaturalWonders + iFromImprovements) * iPercent / 100);
; 4815 : 		if (szRtnValue.length() > 0)
; 4816 : 		{
; 4817 : 			szRtnValue += "[NEWLINE][NEWLINE]";
; 4818 : 		}
; 4819 : 		szRtnValue += GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_TILES", iTileTourism, iPercent);
; 4820 : 	}
; 4821 : 
; 4822 : #ifdef NQ_TOURISM_PER_CITY
; 4823 : 	int iFromTourismPerCity = GET_PLAYER(m_pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_PER_CITY);
; 4824 : 	if (iFromTourismPerCity > 0)
; 4825 : 	{
; 4826 : 		if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN73@GetTourism@4

; 4827 : 		{
; 4828 : 			szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227196
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN73@GetTourism@4:

; 4829 : 		}
; 4830 : 		szRtnValue += GetLocalizedText("TXT_KEY_CO_TOURISM_PER_CITY", iFromTourismPerCity);

	push	edi
	lea	eax, DWORD PTR $T241105[esp+344]
	push	OFFSET $SG227198
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 13		; 0000000dH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241105[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN74@GetTourism@4:

; 4831 : 	}
; 4832 : #endif
; 4833 : 
; 4834 : 	// Beliefs
; 4835 : 	int iSacredSitesTourism = 0;
; 4836 : 	int iReligiousArtTourism = 0;
; 4837 : 	ReligionTypes eMajority = m_pCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, DWORD PTR [esi]
	xor	edi, edi
	mov	DWORD PTR _iReligiousArtTourism$[esp+340], edi
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority

; 4838 : 	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, m_pCity->getOwner());

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$[esp+340], eax

; 4839 : 	if(pReligion)

	test	eax, eax
	je	$LN460@GetTourism@4

; 4840 : 	{
; 4841 : 		int iFaithBuildingTourism = pReligion->m_Beliefs.GetFaithBuildingTourism();

	mov	eax, DWORD PTR [eax+272]
	mov	DWORD PTR _iFaithBuildingTourism$227204[esp+340], eax

; 4842 : 		if (iFaithBuildingTourism > 0)

	test	eax, eax
	jle	SHORT $LN71@GetTourism@4

; 4843 : 		{
; 4844 : 			iSacredSitesTourism = m_pCity->GetCityBuildings()->GetNumBuildingsFromFaith() * iFaithBuildingTourism;

	mov	ecx, DWORD PTR [esi]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumBuildingsFromFaith
	mov	edi, eax
	imul	edi, DWORD PTR _iFaithBuildingTourism$227204[esp+340]
$LN71@GetTourism@4:

; 4845 : 		}
; 4846 : 		if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN70@GetTourism@4

; 4847 : 		{
; 4848 : 			szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227207
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN70@GetTourism@4:

; 4849 : 		}
; 4850 : 		szRtnValue += GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_FAITH_BUILDINGS", iSacredSitesTourism);

	push	edi
	lea	edx, DWORD PTR $T241106[esp+344]
	push	OFFSET $SG227209
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 14		; 0000000eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241106[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4851 : 
; 4852 : #ifdef AUI_WARNING_FIXES
; 4853 : 		for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 4854 : #else
; 4855 : 		for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN459@GetTourism@4
	npad	6
$LL69@GetTourism@4:

; 4856 : #endif
; 4857 : 		{
; 4858 : 			BuildingClassTypes eBuildingClass = (BuildingClassTypes)jJ;
; 4859 : 
; 4860 : 			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 4861 : 			if(!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN68@GetTourism@4

; 4862 : 			{
; 4863 : 				continue;
; 4864 : 			}
; 4865 : 
; 4866 : 			CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(m_pCity->getOwner()).getCivilizationInfo();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4867 : 			BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 4868 : 
; 4869 : 			if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN68@GetTourism@4

; 4870 : 			{
; 4871 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN68@GetTourism@4

; 4872 : 				{
; 4873 : 					iReligiousArtTourism += pReligion->m_Beliefs.GetBuildingClassTourism(eBuildingClass);

	mov	ecx, DWORD PTR _pReligion$[esp+340]
	push	edi
	add	ecx, 152				; 00000098H
	call	?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z ; CvReligionBeliefs::GetBuildingClassTourism
	add	DWORD PTR _iReligiousArtTourism$[esp+340], eax
$LN68@GetTourism@4:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL69@GetTourism@4
$LN459@GetTourism@4:

; 4874 : 				}
; 4875 : 			}
; 4876 : 		}
; 4877 : 		if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN63@GetTourism@4

; 4878 : 		{
; 4879 : 			szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227224
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN63@GetTourism@4:

; 4880 : 		}
; 4881 : 		szRtnValue += GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_RELIGIOUS_ART", iReligiousArtTourism);

	mov	ecx, DWORD PTR _iReligiousArtTourism$[esp+340]
	push	ecx
	lea	edx, DWORD PTR $T241107[esp+344]
	push	OFFSET $SG227226
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 15		; 0000000fH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241107[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN460@GetTourism@4:

; 4882 : 	}
; 4883 : 
; 4884 : 	// Tech enhanced Tourism
; 4885 : #ifdef AUI_WARNING_FIXES
; 4886 : 	for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 4887 : #else
; 4888 : 	for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _jJ$227227[esp+340], edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN60@GetTourism@4
	npad	1
$LL62@GetTourism@4:

; 4889 : #endif
; 4890 : 	{
; 4891 : 		BuildingClassTypes eBuildingClass = (BuildingClassTypes)jJ;
; 4892 : 
; 4893 : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 4894 : 		if(!pkBuildingClassInfo)

	test	eax, eax
	je	$LN61@GetTourism@4

; 4895 : 		{
; 4896 : 			continue;
; 4897 : 		}
; 4898 : 
; 4899 : 		CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(m_pCity->getOwner()).getCivilizationInfo();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4900 : 		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);

	mov	ecx, DWORD PTR _jJ$227227[esp+340]
	push	ecx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	edi, eax

; 4901 : 
; 4902 : 		if(eBuilding != NO_BUILDING)

	cmp	edi, -1
	je	$LN61@GetTourism@4

; 4903 : 		{
; 4904 : 			if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN61@GetTourism@4

; 4905 : 			{
; 4906 : 				int iTechEnhancedTourism = GC.getBuildingInfo(eBuilding)->GetTechEnhancedTourism();

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTechEnhancedTourism
	mov	DWORD PTR _iTechEnhancedTourism$227240[esp+340], eax

; 4907 : 				if (iTechEnhancedTourism > 0 && GET_TEAM(m_pCity->getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildingInfo(eBuilding)->GetEnhancedYieldTech()))

	test	eax, eax
	jle	$LN61@GetTourism@4
	mov	ecx, DWORD PTR [esi]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR $T241396[esp+344], eax
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetEnhancedYieldTech
	mov	ecx, DWORD PTR $T241396[esp+340]
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN61@GetTourism@4

; 4908 : 				{
; 4909 : 					if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN55@GetTourism@4

; 4910 : 					{
; 4911 : 						szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227244
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN55@GetTourism@4:

; 4912 : 					}
; 4913 : 					szRtnValue += GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_TECH_ENHANCED", iTechEnhancedTourism);

	mov	edx, DWORD PTR _iTechEnhancedTourism$227240[esp+340]
	push	edx
	lea	eax, DWORD PTR $T241108[esp+344]
	push	OFFSET $SG227246
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 16		; 00000010H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241108[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN61@GetTourism@4:
	mov	edi, DWORD PTR _jJ$227227[esp+340]
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _jJ$227227[esp+340], edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	$LL62@GetTourism@4
$LN60@GetTourism@4:

; 4914 : 				}
; 4915 : 			}
; 4916 : 		}
; 4917 : 	}
; 4918 : 
; 4919 : 	int iBuildingMod = 0;
; 4920 : #ifdef AUI_WARNING_FIXES
; 4921 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4922 : #else
; 4923 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildingClassLoop$227248[esp+340], 0
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN461@GetTourism@4
$LL54@GetTourism@4:

; 4924 : #endif
; 4925 : 	{
; 4926 : 		CvCivilizationInfo& playerCivilizationInfo = kCityPlayer.getCivilizationInfo();

	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 4927 : 		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	mov	ecx, DWORD PTR _iBuildingClassLoop$227248[esp+340]
	push	ecx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	edi, eax

; 4928 : 		if (eBuilding != NO_BUILDING)

	cmp	edi, -1
	je	$LN53@GetTourism@4

; 4929 : 		{
; 4930 : 			CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkEntry$227257[esp+340], eax

; 4931 : 			if (pkEntry)

	test	eax, eax
	je	$LN53@GetTourism@4

; 4932 : 			{
; 4933 : 				iBuildingMod = kCityPlayer.GetPlayerPolicies()->GetBuildingClassTourismModifier((BuildingClassTypes)iBuildingClassLoop);

	mov	edx, DWORD PTR _iBuildingClassLoop$227248[esp+340]
	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	push	edx
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassTourismModifier
	mov	DWORD PTR _iBuildingMod$[esp+340], eax

; 4934 : 				if (iBuildingMod != 0 && m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	test	eax, eax
	je	$LN53@GetTourism@4
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN53@GetTourism@4

; 4935 : 				{
; 4936 : 					if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN48@GetTourism@4

; 4937 : 					{
; 4938 : 						szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227262
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN48@GetTourism@4:

; 4939 : 					}
; 4940 : 					szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_BUILDING_BONUS", iBuildingMod, pkEntry->GetDescription());

	mov	ecx, DWORD PTR _pkEntry$227257[esp+340]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241109[esp+340], eax
	lea	eax, DWORD PTR $T241109[esp+340]
	push	eax
	lea	ecx, DWORD PTR _iBuildingMod$[esp+344]
	push	ecx
	lea	edx, DWORD PTR $T241110[esp+348]
	push	OFFSET $SG227272
	push	edx
	call	??$GetLocalizedText@HPBD@@YA?AVCvString@@PBDABHABQBD@Z ; GetLocalizedText<int,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 17		; 00000011H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241110[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4941 : 					szRtnValue += szTemp;

	lea	eax, DWORD PTR _szTemp$[esp+340]
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN53@GetTourism@4:
	mov	edi, DWORD PTR _iBuildingClassLoop$227248[esp+340]
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildingClassLoop$227248[esp+340], edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	$LL54@GetTourism@4
$LN461@GetTourism@4:

; 4914 : 				}
; 4915 : 			}
; 4916 : 		}
; 4917 : 	}
; 4918 : 
; 4919 : 	int iBuildingMod = 0;
; 4920 : #ifdef AUI_WARNING_FIXES
; 4921 : 	for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 4922 : #else
; 4923 : 	for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	edi, DWORD PTR _kCityPlayer$[esp+340]

; 4942 : 				}
; 4943 : 			}
; 4944 : 		}
; 4945 : 	}
; 4946 : 
; 4947 : 	// Get policy bonuses
; 4948 : 	int iLessHappyMod = kCityPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_LESS_HAPPY);

	push	29					; 0000001dH
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 4949 : 	int iCommonFoeMod = kCityPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_COMMON_FOE);

	push	28					; 0000001cH
	mov	ecx, edi
	mov	DWORD PTR _iLessHappyMod$[esp+344], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 4950 : 	int iSharedIdeologyMod = kCityPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_TOURISM_MOD_SHARED_IDEOLOGY);

	push	30					; 0000001eH
	mov	ecx, edi
	mov	DWORD PTR _iCommonFoeMod$[esp+344], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	DWORD PTR _iSharedIdeologyMod$[esp+340], eax

; 4951 : 
; 4952 : 	// If generating any, itemize which players we have bonuses with
; 4953 : 	if (iGWTourism > 0 || iTileTourism > 0)

	xor	eax, eax
	cmp	ebx, eax
	jg	SHORT $LN46@GetTourism@4
	cmp	DWORD PTR _iTileTourism$[esp+340], eax
	jle	$LN8@GetTourism@4
$LN46@GetTourism@4:

; 4954 : 	{
; 4955 : 		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	mov	DWORD PTR _iLoopPlayer$227278[esp+340], eax
	mov	DWORD PTR tv2525[esp+340], eax
	npad	9
$LL45@GetTourism@4:

; 4956 : 		{
; 4957 : 			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv2525[esp+340]
	lea	edi, DWORD PTR [ecx+edx]

; 4958 : 			PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, edi
	mov	DWORD PTR _kPlayer$227282[esp+340], edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 4959 : 			if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && iLoopPlayer != m_pCity->getOwner() && GET_TEAM(kCityPlayer.getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iLoopPlayer).getTeam()))

	cmp	BYTE PTR [edi+2256], 0
	mov	DWORD PTR _eTheirIdeology$227284[esp+340], eax
	je	$LN44@GetTourism@4
	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN44@GetTourism@4
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _iLoopPlayer$227278[esp+340]
	cmp	ecx, DWORD PTR [eax+84]
	je	$LN44@GetTourism@4
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv2525[esp+340]
	mov	eax, DWORD PTR [edx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN275@GetTourism@4
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN276@GetTourism@4
$LN275@GetTourism@4:
	or	edi, -1
$LN276@GetTourism@4:
	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN44@GetTourism@4

; 4960 : 			{
; 4961 : 				// City shares religion with this player
; 4962 : 				if (kPlayer.GetReligions()->HasReligionInMostCities(ePlayerReligion))

	mov	eax, DWORD PTR _ePlayerReligion$[esp+340]
	mov	edi, DWORD PTR _kPlayer$227282[esp+340]
	push	eax
	mov	ecx, edi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?HasReligionInMostCities@CvPlayerReligions@@QBE_NW4ReligionTypes@@@Z ; CvPlayerReligions::HasReligionInMostCities
	test	al, al
	je	SHORT $LN464@GetTourism@4

; 4963 : 				{
; 4964 : 					if (sharedReligionCivs.length() > 0)

	cmp	DWORD PTR _sharedReligionCivs$[esp+360], 0
	jbe	SHORT $LN40@GetTourism@4

; 4965 : 					{
; 4966 : 						sharedReligionCivs += ", ";

	push	OFFSET $SG227289
	lea	ecx, DWORD PTR _sharedReligionCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN40@GetTourism@4:

; 4967 : 					}
; 4968 : 					sharedReligionCivs += kPlayer.getCivilizationShortDescription();

	mov	ecx, edi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _sharedReligionCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN464@GetTourism@4:

; 4969 : 				}
; 4970 : 
; 4971 : 				// Open borders with this player
; 4972 : 				CvTeam &kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN288@GetTourism@4
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN289@GetTourism@4
$LN288@GetTourism@4:
	or	eax, -1
$LN289@GetTourism@4:

; 4973 : 				if (kTeam.IsAllowsOpenBordersToTeam(eTeam))

	mov	ecx, DWORD PTR _eTeam$[esp+340]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN469@GetTourism@4

; 4974 : 				{
; 4975 : 					if (openBordersCivs.length() > 0)

	cmp	DWORD PTR _openBordersCivs$[esp+360], 0
	jbe	SHORT $LN38@GetTourism@4

; 4976 : 					{
; 4977 : 						openBordersCivs += ", ";

	push	OFFSET $SG227293
	lea	ecx, DWORD PTR _openBordersCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN38@GetTourism@4:

; 4978 : 					}
; 4979 : 					openBordersCivs += kPlayer.getCivilizationShortDescription();

	mov	ecx, edi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _openBordersCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN469@GetTourism@4:

; 4980 : 				}
; 4981 : 
; 4982 : 				// Trade route with this player
; 4983 : 				if (GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pCity->getOwner(), (PlayerTypes)iLoopPlayer))

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR _iLoopPlayer$227278[esp+340]
	mov	eax, DWORD PTR [edx+84]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	je	SHORT $LN470@GetTourism@4

; 4984 : 				{
; 4985 : 					if (tradeRouteCivs.length() > 0)

	cmp	DWORD PTR _tradeRouteCivs$[esp+360], 0
	jbe	SHORT $LN36@GetTourism@4

; 4986 : 					{
; 4987 : 						tradeRouteCivs += ", ";

	push	OFFSET $SG227297
	lea	ecx, DWORD PTR _tradeRouteCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN36@GetTourism@4:

; 4988 : 					}
; 4989 : 					tradeRouteCivs += kPlayer.getCivilizationShortDescription();

	mov	ecx, edi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _tradeRouteCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN470@GetTourism@4:

; 4990 : 				}
; 4991 : 
; 4992 : 				// POLICY BONUSES
; 4993 : 				if (iLessHappyMod > 0)

	cmp	DWORD PTR _iLessHappyMod$[esp+340], 0
	jle	SHORT $LN468@GetTourism@4

; 4994 : 				{
; 4995 : 					if (kCityPlayer.GetExcessHappiness() > kPlayer.GetExcessHappiness())

	mov	ecx, edi
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	mov	ebx, eax
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	cmp	eax, ebx
	jle	SHORT $LN468@GetTourism@4

; 4996 : 					{
; 4997 : 						if (lessHappyCivs.length() > 0)

	cmp	DWORD PTR _lessHappyCivs$[esp+360], 0
	jbe	SHORT $LN33@GetTourism@4

; 4998 : 						{
; 4999 : 							lessHappyCivs += ", ";

	push	OFFSET $SG227301
	lea	ecx, DWORD PTR _lessHappyCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN33@GetTourism@4:

; 5000 : 						}
; 5001 : 						lessHappyCivs += kPlayer.getCivilizationShortDescription();

	mov	ecx, edi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _lessHappyCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN468@GetTourism@4:

; 5002 : 					}
; 5003 : 				}
; 5004 : 				if (iCommonFoeMod > 0)

	cmp	DWORD PTR _iCommonFoeMod$[esp+340], 0
	jle	$LN466@GetTourism@4

; 5005 : 				{
; 5006 : 					// NQMP GJS - new Cult of Personality BEGIN
; 5007 : 					int rank = 0;
; 5008 : 					int totalEnemies = 0;
; 5009 : 					int myStrength = kCityPlayer.GetMilitaryMight();

	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	xor	edi, edi
	mov	DWORD PTR _rank$227303[esp+340], edi
	mov	DWORD PTR _totalEnemies$227304[esp+340], edi
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	mov	DWORD PTR _myStrength$227305[esp+340], eax
	xor	ebx, ebx
$LL31@GetTourism@4:

; 5013 : 					{
; 5014 : 						eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 5015 : 						if(eLoopPlayer != m_pCity->getOwner() && kCityPlayer.GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [edx+84]
	je	SHORT $LN30@GetTourism@4
	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	push	0
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN30@GetTourism@4

; 5016 : 						{
; 5017 : 							totalEnemies++;
; 5018 : 							if (GET_PLAYER(eLoopPlayer).GetMilitaryMight() > myStrength)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	inc	DWORD PTR _totalEnemies$227304[esp+340]
	lea	ecx, DWORD PTR [eax+ebx]
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	cmp	eax, DWORD PTR _myStrength$227305[esp+340]
	jle	SHORT $LN30@GetTourism@4

; 5019 : 							{
; 5020 : 								rank++;

	inc	DWORD PTR _rank$227303[esp+340]
$LN30@GetTourism@4:

; 5010 : 
; 5011 : 					PlayerTypes eLoopPlayer;
; 5012 : 					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	ebx, 63236				; 0000f704H
	inc	edi
	cmp	ebx, 1391192				; 00153a58H
	jl	SHORT $LL31@GetTourism@4

; 5021 : 							}
; 5022 : 						}
; 5023 : 					}
; 5024 : 
; 5025 : 					// divide the tourism boost into chunks, so that lowest player gets 0%, highest gets 100%, and the rest are evenly distributed in between
; 5026 : 					// so for example in a 6 player game, based on the player being 6th/5th/4th/3rd/2nd/1st in military strength they get 0%/20%/40%/60%/80%/100% boost
; 5027 : 					if (totalEnemies > 0)

	mov	ecx, DWORD PTR _totalEnemies$227304[esp+340]
	test	ecx, ecx
	jle	SHORT $LN466@GetTourism@4

; 5028 : 					{
; 5029 : 						iCommonFoeMod = iCommonFoeMod * (totalEnemies - rank) / totalEnemies;

	mov	eax, ecx
	sub	eax, DWORD PTR _rank$227303[esp+340]
	imul	eax, DWORD PTR _iCommonFoeMod$[esp+340]
	cdq
	idiv	ecx
	mov	DWORD PTR _iCommonFoeMod$[esp+340], eax
$LN466@GetTourism@4:

; 5030 : 					}
; 5031 : 
; 5032 : 					/*
; 5033 : 					// old code
; 5034 : 					PlayerTypes eLoopPlayer;
; 5035 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 5036 : 					{
; 5037 : 						eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 5038 : 						if(eLoopPlayer !=(PlayerTypes) iLoopPlayer && eLoopPlayer != m_pCity->getOwner() && kCityPlayer.GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
; 5039 : 						{
; 5040 : 							// Are they at war with me too?
; 5041 : 							if (GET_TEAM(kCityPlayer.getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()) && GET_TEAM(kPlayer.getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
; 5042 : 							{
; 5043 : 								if (commonFoeCivs.length() > 0)
; 5044 : 								{
; 5045 : 									commonFoeCivs += ", ";
; 5046 : 								}
; 5047 : 								commonFoeCivs += kPlayer.getCivilizationShortDescription();
; 5048 : 							}
; 5049 : 						}
; 5050 : 					}
; 5051 : 					*/
; 5052 : 					// NQMP GJS - new Cult of Personality END
; 5053 : 				}
; 5054 : 
; 5055 : 				// Shared ideology bonus (comes from a policy)
; 5056 : 				if (iSharedIdeologyMod > 0)

	cmp	DWORD PTR _iSharedIdeologyMod$[esp+340], 0

; 5057 : 				{
; 5058 : 					if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)

	mov	ecx, DWORD PTR _eMyIdeology$[esp+340]
	jle	SHORT $LN467@GetTourism@4
	cmp	ecx, -1
	je	$LN44@GetTourism@4
	mov	eax, DWORD PTR _eTheirIdeology$227284[esp+340]
	cmp	eax, -1
	je	SHORT $LN24@GetTourism@4
	cmp	ecx, eax
	jne	SHORT $LN24@GetTourism@4

; 5059 : 					{
; 5060 : 						if (sharedIdeologyCivs.length() > 0)

	cmp	DWORD PTR _sharedIdeologyCivs$[esp+360], 0
	jbe	SHORT $LN23@GetTourism@4

; 5061 : 						{
; 5062 : 							sharedIdeologyCivs += ", ";

	push	OFFSET $SG227318
	lea	ecx, DWORD PTR _sharedIdeologyCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN23@GetTourism@4:

; 5063 : 						}
; 5064 : 						sharedIdeologyCivs += kPlayer.getCivilizationShortDescription();

	mov	ecx, DWORD PTR _kPlayer$227282[esp+340]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _sharedIdeologyCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	mov	ecx, DWORD PTR _eMyIdeology$[esp+340]
$LN467@GetTourism@4:
	mov	eax, DWORD PTR _eTheirIdeology$227284[esp+340]
$LN24@GetTourism@4:

; 5065 : 					}
; 5066 : 				}
; 5067 : 
; 5068 : 				// Different ideology penalty (applies all the time)
; 5069 : 				if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology != eTheirIdeology)

	cmp	ecx, -1
	je	SHORT $LN44@GetTourism@4
	cmp	eax, -1
	je	SHORT $LN44@GetTourism@4
	cmp	ecx, eax
	je	SHORT $LN44@GetTourism@4

; 5070 : 				{
; 5071 : 					if (differentIdeologyCivs.length() > 0)

	cmp	DWORD PTR _differentIdeologyCivs$[esp+360], 0
	jbe	SHORT $LN21@GetTourism@4

; 5072 : 					{
; 5073 : 						differentIdeologyCivs += ", ";

	push	OFFSET $SG227321
	lea	ecx, DWORD PTR _differentIdeologyCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN21@GetTourism@4:

; 5074 : 					}
; 5075 : 					differentIdeologyCivs += kPlayer.getCivilizationShortDescription();

	mov	ecx, DWORD PTR _kPlayer$227282[esp+340]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _differentIdeologyCivs$[esp+344]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN44@GetTourism@4:
	mov	eax, DWORD PTR tv2525[esp+340]
	inc	DWORD PTR _iLoopPlayer$227278[esp+340]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv2525[esp+340], eax
	jl	$LL45@GetTourism@4

; 5076 : 				}
; 5077 : 			}
; 5078 : 		}
; 5079 : 
; 5080 : 		// Build the strings
; 5081 : 		if (sharedReligionCivs.length() > 0)

	cmp	DWORD PTR _sharedReligionCivs$[esp+360], 0
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	jbe	$LN20@GetTourism@4

; 5082 : 		{
; 5083 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN19@GetTourism@4

; 5084 : 			{
; 5085 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227324
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN19@GetTourism@4:

; 5086 : 			}
; 5087 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_RELIGION_BONUS", kCityPlayer.GetCulture()->GetTourismModifierSharedReligion());

	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, DWORD PTR [eax+292]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	55					; 00000037H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebx
	push	eax
	lea	ecx, DWORD PTR $T241111[esp+344]
	push	OFFSET $SG227326
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 18		; 00000012H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241111[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5088 : 			szRtnValue += szTemp + sharedReligionCivs;

	lea	edx, DWORD PTR _sharedReligionCivs$[esp+340]
	push	edx
	lea	eax, DWORD PTR _szTemp$[esp+344]
	push	eax
	lea	ecx, DWORD PTR $T241112[esp+348]
	push	ecx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 19		; 00000013H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241112[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN20@GetTourism@4:

; 5089 : 		}
; 5090 : 		if (openBordersCivs.length() > 0)

	cmp	DWORD PTR _openBordersCivs$[esp+360], 0
	jbe	$LN18@GetTourism@4

; 5091 : 		{
; 5092 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN17@GetTourism@4

; 5093 : 			{
; 5094 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227330
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN17@GetTourism@4:

; 5095 : 			}
; 5096 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_OPEN_BORDERS_BONUS", kCityPlayer.GetCulture()->GetTourismModifierOpenBorders());

	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, DWORD PTR [eax+292]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	57					; 00000039H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebx
	push	eax
	lea	edx, DWORD PTR $T241113[esp+344]
	push	OFFSET $SG227332
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 20		; 00000014H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241113[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5097 : 			szRtnValue += szTemp + openBordersCivs;

	lea	eax, DWORD PTR _openBordersCivs$[esp+340]
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	push	ecx
	lea	edx, DWORD PTR $T241114[esp+348]
	push	edx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 21		; 00000015H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241114[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@GetTourism@4:

; 5098 : 		}
; 5099 : 		if (tradeRouteCivs.length() > 0)

	cmp	DWORD PTR _tradeRouteCivs$[esp+360], 0
	jbe	$LN16@GetTourism@4

; 5100 : 		{
; 5101 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN15@GetTourism@4

; 5102 : 			{
; 5103 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227336
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN15@GetTourism@4:

; 5104 : 			}
; 5105 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_TRADE_ROUTE_BONUS", kCityPlayer.GetCulture()->GetTourismModifierTradeRoute());

	mov	ecx, DWORD PTR _kCityPlayer$[esp+340]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, DWORD PTR [eax+292]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8216
	push	56					; 00000038H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, ebx
	push	eax
	lea	eax, DWORD PTR $T241115[esp+344]
	push	OFFSET $SG227338
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 22		; 00000016H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241115[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5106 : 			szRtnValue += szTemp + tradeRouteCivs;

	lea	ecx, DWORD PTR _tradeRouteCivs$[esp+340]
	push	ecx
	lea	edx, DWORD PTR _szTemp$[esp+344]
	push	edx
	lea	eax, DWORD PTR $T241116[esp+348]
	push	eax
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 23		; 00000017H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241116[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@GetTourism@4:

; 5107 : 		}
; 5108 : 		if (lessHappyCivs.length() > 0)

	cmp	DWORD PTR _lessHappyCivs$[esp+360], 0
	jbe	$LN14@GetTourism@4

; 5109 : 		{
; 5110 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN13@GetTourism@4

; 5111 : 			{
; 5112 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227342
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN13@GetTourism@4:

; 5113 : 			}
; 5114 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_LESS_HAPPY_BONUS", iLessHappyMod);

	mov	ecx, DWORD PTR _iLessHappyMod$[esp+340]
	push	ecx
	lea	edx, DWORD PTR $T241117[esp+344]
	push	OFFSET $SG227344
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 24		; 00000018H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241117[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5115 : 			szRtnValue += szTemp + lessHappyCivs;

	lea	eax, DWORD PTR _lessHappyCivs$[esp+340]
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	push	ecx
	lea	edx, DWORD PTR $T241118[esp+348]
	push	edx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 25		; 00000019H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241118[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@GetTourism@4:

; 5116 : 		}
; 5117 : 		if (commonFoeCivs.length() > 0)

	cmp	DWORD PTR _commonFoeCivs$[esp+360], 0
	jbe	SHORT $LN12@GetTourism@4

; 5118 : 		{
; 5119 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN11@GetTourism@4

; 5120 : 			{
; 5121 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227348
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN11@GetTourism@4:

; 5122 : 			}
; 5123 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_COMMON_FOE_BONUS", iCommonFoeMod);

	mov	eax, DWORD PTR _iCommonFoeMod$[esp+340]
	push	eax
	lea	ecx, DWORD PTR $T241119[esp+344]
	push	OFFSET $SG227350
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 26		; 0000001aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241119[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5124 : 			szRtnValue += szTemp /*+ commonFoeCivs*/; // NQMP GJS - new Cult of Personality - commented out this bit

	lea	edx, DWORD PTR _szTemp$[esp+340]
	push	edx
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN12@GetTourism@4:

; 5125 : 		}
; 5126 : 		if (sharedIdeologyCivs.length() > 0)

	cmp	DWORD PTR _sharedIdeologyCivs$[esp+360], 0
	jbe	$LN10@GetTourism@4

; 5127 : 		{
; 5128 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN9@GetTourism@4

; 5129 : 			{
; 5130 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227353
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN9@GetTourism@4:

; 5131 : 			}
; 5132 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_SHARED_IDEOLOGY_BONUS", iSharedIdeologyMod);

	mov	eax, DWORD PTR _iSharedIdeologyMod$[esp+340]
	push	eax
	lea	ecx, DWORD PTR $T241120[esp+344]
	push	OFFSET $SG227355
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 27		; 0000001bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241120[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5133 : 			szRtnValue += szTemp + sharedIdeologyCivs;

	lea	edx, DWORD PTR _sharedIdeologyCivs$[esp+340]
	push	edx
	lea	eax, DWORD PTR _szTemp$[esp+344]
	push	eax
	lea	ecx, DWORD PTR $T241121[esp+348]
	push	ecx
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 28		; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241121[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@GetTourism@4:

; 5134 : 		}
; 5135 : 		if (differentIdeologyCivs.length() > 0)

	cmp	DWORD PTR _differentIdeologyCivs$[esp+360], 0
	jbe	$LN8@GetTourism@4

; 5136 : 		{
; 5137 : 			if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN7@GetTourism@4

; 5138 : 			{
; 5139 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227359
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN7@GetTourism@4:

; 5140 : 			}
; 5141 : 			szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_DIFFERENT_IDEOLOGY_PENALTY", GC.getTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8228
	push	edx
	lea	eax, DWORD PTR $T241122[esp+344]
	push	OFFSET $SG227361
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 29		; 0000001dH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241122[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5142 : 			szRtnValue += szTemp + differentIdeologyCivs;

	lea	ecx, DWORD PTR _differentIdeologyCivs$[esp+340]
	push	ecx
	lea	edx, DWORD PTR _szTemp$[esp+344]
	push	edx
	lea	eax, DWORD PTR $T241123[esp+348]
	push	eax
	call	edi
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+352], 30		; 0000001eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241123[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@GetTourism@4:

; 5143 : 		}
; 5144 : 	}
; 5145 : 
; 5146 : 	int iTechSpreadModifier = kCityPlayer.GetInfluenceSpreadModifier();

	mov	ebx, DWORD PTR _kCityPlayer$[esp+340]
	mov	ecx, ebx
	call	?GetInfluenceSpreadModifier@CvPlayer@@QBEHXZ ; CvPlayer::GetInfluenceSpreadModifier
	mov	edi, eax

; 5147 : 	if (iTechSpreadModifier > 0)

	test	edi, edi
	jle	SHORT $LN6@GetTourism@4

; 5148 : 	{
; 5149 : 		if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN5@GetTourism@4

; 5150 : 		{
; 5151 : 			szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227366
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN5@GetTourism@4:

; 5152 : 		}
; 5153 : 		szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_TECH_BONUS", iTechSpreadModifier);

	push	edi
	lea	ecx, DWORD PTR $T241124[esp+344]
	push	OFFSET $SG227368
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 31		; 0000001fH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241124[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5154 : 		szRtnValue += szTemp;

	lea	edx, DWORD PTR _szTemp$[esp+340]
	push	edx
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN6@GetTourism@4:

; 5155 : 	}
; 5156 : 	int iLeagueCityModifier = GC.getGame().GetGameLeagues()->GetCityTourismModifier(m_pCity->getOwner(), m_pCity);

	mov	esi, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetCityTourismModifier@CvGameLeagues@@QAEHW4PlayerTypes@@PBVCvCity@@@Z ; CvGameLeagues::GetCityTourismModifier
	mov	esi, eax

; 5157 : 	if (iLeagueCityModifier > 0)

	test	esi, esi
	jle	SHORT $LN4@GetTourism@4

; 5158 : 	{
; 5159 : 		if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN3@GetTourism@4

; 5160 : 		{
; 5161 : 			szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227372
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN3@GetTourism@4:

; 5162 : 		}
; 5163 : 		szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_LEAGUES_BONUS", iLeagueCityModifier);

	push	esi
	lea	eax, DWORD PTR $T241125[esp+344]
	push	OFFSET $SG227374
	push	eax
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 32		; 00000020H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241125[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5164 : 		szRtnValue += szTemp;

	lea	ecx, DWORD PTR _szTemp$[esp+340]
	push	ecx
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN4@GetTourism@4:

; 5165 : 	}
; 5166 : 
; 5167 : 	if (kCityPlayer.isGoldenAge() && kCityPlayer.GetPlayerTraits()->GetGoldenAgeTourismModifier())

	mov	ecx, ebx
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN2@GetTourism@4
	mov	ecx, ebx
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+184], 0
	je	SHORT $LN2@GetTourism@4

; 5168 : 	{
; 5169 : 		if (szRtnValue.length() > 0)

	cmp	DWORD PTR [ebp+20], 0
	jbe	SHORT $LN1@GetTourism@4

; 5170 : 		{
; 5171 : 			szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227377
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@GetTourism@4:

; 5172 : 		}
; 5173 : 		szTemp = GetLocalizedText("TXT_KEY_CO_CITY_TOURISM_CARNIVAL_BONUS", kCityPlayer.GetPlayerTraits()->GetGoldenAgeTourismModifier());

	mov	ecx, ebx
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+184]
	push	eax
	lea	edx, DWORD PTR $T241126[esp+344]
	push	OFFSET $SG227379
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szTemp$[esp+344]
	mov	BYTE PTR __$EHRec$[esp+352], 33		; 00000021H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241126[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5174 : 		szRtnValue += szTemp;

	lea	eax, DWORD PTR _szTemp$[esp+340]
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN2@GetTourism@4:

; 5175 : 	}
; 5176 : 
; 5177 : 	return szRtnValue;

	lea	ecx, DWORD PTR _differentIdeologyCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sharedIdeologyCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _commonFoeCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _lessHappyCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _tradeRouteCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _openBordersCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sharedReligionCivs$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5178 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+340]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 324				; 00000144H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T241128[ebp]
	and	eax, 1
	je	$LN81@GetTourism@4
	and	DWORD PTR $T241128[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN81@GetTourism@4:
	ret	0
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR _szTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$2:
	lea	ecx, DWORD PTR _sharedReligionCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$3:
	lea	ecx, DWORD PTR _openBordersCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$4:
	lea	ecx, DWORD PTR _tradeRouteCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$5:
	lea	ecx, DWORD PTR _lessHappyCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$6:
	lea	ecx, DWORD PTR _commonFoeCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$7:
	lea	ecx, DWORD PTR _sharedIdeologyCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$8:
	lea	ecx, DWORD PTR _differentIdeologyCivs$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$9:
	lea	ecx, DWORD PTR $T241100[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$10:
	lea	ecx, DWORD PTR $T241102[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$11:
	lea	ecx, DWORD PTR $T241103[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$12:
	lea	ecx, DWORD PTR $T241104[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$13:
	lea	ecx, DWORD PTR $T241105[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$14:
	lea	ecx, DWORD PTR $T241106[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$15:
	lea	ecx, DWORD PTR $T241107[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$16:
	lea	ecx, DWORD PTR $T241108[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$17:
	lea	ecx, DWORD PTR $T241110[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$18:
	lea	ecx, DWORD PTR $T241111[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$19:
	lea	ecx, DWORD PTR $T241112[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$20:
	lea	ecx, DWORD PTR $T241113[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$21:
	lea	ecx, DWORD PTR $T241114[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$22:
	lea	ecx, DWORD PTR $T241115[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$23:
	lea	ecx, DWORD PTR $T241116[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$24:
	lea	ecx, DWORD PTR $T241117[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$25:
	lea	ecx, DWORD PTR $T241118[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$26:
	lea	ecx, DWORD PTR $T241119[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$27:
	lea	ecx, DWORD PTR $T241120[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$28:
	lea	ecx, DWORD PTR $T241121[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$29:
	lea	ecx, DWORD PTR $T241122[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$30:
	lea	ecx, DWORD PTR $T241123[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$31:
	lea	ecx, DWORD PTR $T241124[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$32:
	lea	ecx, DWORD PTR $T241125[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ$33:
	lea	ecx, DWORD PTR $T241126[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTourismTooltip@CvCityCulture@@QAE?AVCvString@@XZ ENDP ; CvCityCulture::GetTourismTooltip
PUBLIC	?clear@?$BaseVector@VCvGreatWork@@$0A@@@QAEXXZ	; BaseVector<CvGreatWork,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@VCvGreatWork@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvGreatWork@@$0A@@@QAEXXZ PROC	; BaseVector<CvGreatWork,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	ebx
	mov	ebx, ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	mov	esi, DWORD PTR [ebx]
	test	eax, eax
	jbe	SHORT $LN20@clear
	push	edi
	mov	edi, eax
$LL5@clear:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 48					; 00000030H
	sub	edi, 1
	jne	SHORT $LL5@clear
	pop	edi
$LN20@clear:
	pop	esi

; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ebx+4], 0
	pop	ebx

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvGreatWork@@$0A@@@QAEXXZ ENDP	; BaseVector<CvGreatWork,0>::clear
_TEXT	ENDS
PUBLIC	??0?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx+4]
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN9@erase
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	mov	edx, DWORD PTR __Where$[esp+16]
	add	esp, 16					; 00000010H
$LN9@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [esi+8], -4			; fffffffcH
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase
_TEXT	ENDS
PUBLIC	??0?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::vector<enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::vector<enum EraTypes,std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::vector<enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAVCvGreatWork@@I@Z ; FStaticVector<CvGreatWork,22,0,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAVCvGreatWork@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAVCvGreatWork@@I@Z PROC ; FStaticVector<CvGreatWork,22,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	ebx, DWORD PTR _pVal$[esp]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _uiNumElements$[esp+8]
	mov	ebp, ecx
	test	edi, edi
	jbe	SHORT $LN5@Free
	push	esi
	mov	esi, ebx
$LL7@Free:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 48					; 00000030H
	sub	edi, 1
	jne	SHORT $LL7@Free
	pop	esi
$LN5@Free:

; 811  : 		if( pVal != (T*)m_aData )

	add	ebp, 12					; 0000000cH
	cmp	ebx, ebp
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free:
	pop	edi
	pop	ebp
	pop	ebx

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAVCvGreatWork@@I@Z ENDP ; FStaticVector<CvGreatWork,22,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@0@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@0@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@0@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase
_TEXT	ENDS
PUBLIC	??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z PROC ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN25@find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL11@find:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN25@find
	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL11@find
$LN25@find:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ENDP ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z ; std::find<std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >,enum EraTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z PROC ; std::find<std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >,enum EraTypes>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN25@find@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL11@find@2:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN25@find@2
	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL11@find@2
$LN25@find@2:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4EraTypes@@@std@@YA?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@0@V10@0ABW4EraTypes@@@Z ENDP ; std::find<std::_Vector_iterator<enum EraTypes,std::allocator<enum EraTypes> >,enum EraTypes>
_TEXT	ENDS
PUBLIC	??$find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z ; std::find<std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z PROC ; std::find<std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >,enum PlayerTypes>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN25@find@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL11@find@3:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN25@find@3
	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL11@find@3
$LN25@find@3:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@W4PlayerTypes@@@std@@YA?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@0@V10@0ABW4PlayerTypes@@@Z ENDP ; std::find<std::_Vector_iterator<enum PlayerTypes,std::allocator<enum PlayerTypes> >,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ucopy<enum PlayerTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T242738 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242742 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ucopy<enum PlayerTypes *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$242742[esp]
	mov	BYTE PTR $T242738[esp+4], 0
	mov	eax, DWORD PTR $T242738[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ucopy<enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ucopy<CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z
_TEXT	SEGMENT
$T242757 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242761 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ucopy<CvGreatWorkInMyEmpire *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$242761[esp]
	mov	BYTE PTR $T242757[esp+4], 0
	mov	eax, DWORD PTR $T242757[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ucopy<CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ucopy<enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T242776 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242780 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ucopy<enum EraTypes *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$242780[esp]
	mov	BYTE PTR $T242776[esp+4], 0
	mov	eax, DWORD PTR $T242776[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ucopy<enum EraTypes *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z
_TEXT	SEGMENT
$T242787 = -4						; size = 1
__Cat$242792 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242787[esp+4], 0
	mov	eax, DWORD PTR $T242787[esp+4]
	mov	ecx, DWORD PTR __Cat$242792[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum PlayerTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@0AAV?$allocator@W4PlayerTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@std@@@Z
_TEXT	SEGMENT
$T242804 = -4						; size = 1
__Cat$242809 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242804[esp+4], 0
	mov	eax, DWORD PTR $T242804[esp+4]
	mov	ecx, DWORD PTR __Cat$242809[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@@Z ; std::_Destroy_range<std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@0AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z
_TEXT	SEGMENT
$T242821 = -4						; size = 1
__Cat$242826 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242821[esp+4], 0
	mov	eax, DWORD PTR $T242821[esp+4]
	mov	ecx, DWORD PTR __Cat$242826[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum EraTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@0AAV?$allocator@W4EraTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@std@@@Z
_TEXT	SEGMENT
$T242838 = -4						; size = 1
__Cat$242843 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242838[esp+4], 0
	mov	eax, DWORD PTR $T242838[esp+4]
	mov	ecx, DWORD PTR __Cat$242843[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@@Z ; std::_Destroy_range<std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@5
	pop	esi
$LN9@Uninit_fil@5:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z
_TEXT	SEGMENT
$T242988 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242991 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242991[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242988[esp+4], 0
	mov	eax, DWORD PTR $T242988[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@stdext@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z
_TEXT	SEGMENT
$T243025 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243028 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$243028[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T243025[esp+4], 0
	mov	eax, DWORD PTR $T243025[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z
_TEXT	SEGMENT
$T243062 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243065 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$243065[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T243062[esp+4], 0
	mov	eax, DWORD PTR $T243062[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@stdext@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YA?AU?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YA?AU?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__Glast$ = -88						; size = 4
__Tmp$243701 = -84					; size = 12
__Tmp$243390 = -72					; size = 12
__Tmp$243879 = -60					; size = 12
__Tmp$243560 = -48					; size = 12
__Tmp$243620 = -36					; size = 12
__Tmp$243768 = -24					; size = 12
__Tmp$243816 = -12					; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YA?AU?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 3185 : 	{	// partition [_First, _Last), using _Pred

	sub	esp, 88					; 00000058H
	push	ebx

; 3186 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	mov	ebx, DWORD PTR __Last$[esp+88]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+100]

; 3187 : 	std::_Median(_First, _Mid, _Last - 1, _Pred);

	mov	ebp, DWORD PTR __Pred$[esp+100]
	mov	ecx, ebx
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	eax, DWORD PTR [eax+eax*2]
	lea	esi, DWORD PTR [edi+eax*4]
	push	ebp
	lea	eax, DWORD PTR [ebx-12]
	push	eax
	push	esi
	push	edi
	call	??$_Median@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Median<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 16					; 00000010H

; 3188 : 	_RanIt _Pfirst = _Mid;
; 3189 : 	_RanIt _Plast = _Pfirst + 1;

	lea	ebx, DWORD PTR [esi+12]

; 3190 : 
; 3191 : 	while (_First < _Pfirst
; 3192 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3193 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	cmp	DWORD PTR __First$[esp+100], esi
	jae	SHORT $LN352@Unguarded_
	npad	6
$LL27@Unguarded_:
	lea	edi, DWORD PTR [esi-12]
	push	esi
	push	edi
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN352@Unguarded_
	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN352@Unguarded_

; 3194 : 		--_Pfirst;

	mov	esi, edi
	cmp	DWORD PTR __First$[esp+100], esi
	jb	SHORT $LL27@Unguarded_
$LN352@Unguarded_:

; 3195 : 	while (_Plast < _Last
; 3196 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3197 : 		&& !_Pred(*_Pfirst, *_Plast))

	cmp	ebx, DWORD PTR __Last$[esp+100]
	jae	SHORT $LN353@Unguarded_
$LL25@Unguarded_:
	push	esi
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN353@Unguarded_
	push	ebx
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN353@Unguarded_

; 3198 : 		++_Plast;

	add	ebx, 12					; 0000000cH
	cmp	ebx, DWORD PTR __Last$[esp+100]
	jb	SHORT $LL25@Unguarded_
$LN353@Unguarded_:

; 3199 : 
; 3200 : 	_RanIt _Gfirst = _Plast;
; 3201 : 	_RanIt _Glast = _Pfirst;

	mov	edi, esi
	mov	ebp, ebx
	mov	DWORD PTR __Glast$[esp+104], edi
	npad	2
$LL23@Unguarded_:

; 3202 : 
; 3203 : 	for (; ; )
; 3204 : 		{	// partition
; 3205 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	ebp, DWORD PTR __Last$[esp+100]
	jae	SHORT $LN355@Unguarded_
$LL116@Unguarded_:

; 3206 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

	push	ebp
	push	esi
	call	DWORD PTR __Pred$[esp+108]
	add	esp, 8
	test	al, al
	jne	SHORT $LN20@Unguarded_

; 3207 : 				;
; 3208 : 			else if (_Pred(*_Gfirst, *_Pfirst))

	push	esi
	push	ebp
	call	DWORD PTR __Pred$[esp+108]
	add	esp, 8
	test	al, al
	jne	SHORT $LN355@Unguarded_

; 3209 : 				break;
; 3210 : 			else
; 3211 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, ebx
	add	ebx, 12					; 0000000cH
	cmp	eax, ebp
	je	SHORT $LN20@Unguarded_
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$243390[esp+108], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$243390[esp+112], edx
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR __Tmp$243390[esp+108]
	mov	DWORD PTR [ebp], ecx
	mov	ecx, DWORD PTR __Tmp$243390[esp+112]
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], ecx
$LN20@Unguarded_:
	add	ebp, 12					; 0000000cH
	cmp	ebp, DWORD PTR __Last$[esp+100]
	jb	SHORT $LL116@Unguarded_
$LN355@Unguarded_:

; 3212 : 		for (; _First < _Glast; --_Glast)

	cmp	edi, DWORD PTR __First$[esp+100]
	jbe	SHORT $LN361@Unguarded_
	add	edi, -12				; fffffff4H
$LL157@Unguarded_:

; 3213 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

	push	esi
	push	edi
	call	DWORD PTR __Pred$[esp+108]
	add	esp, 8
	test	al, al
	jne	SHORT $LN13@Unguarded_

; 3214 : 				;
; 3215 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

	push	edi
	push	esi
	call	DWORD PTR __Pred$[esp+108]
	add	esp, 8
	test	al, al
	jne	SHORT $LN358@Unguarded_

; 3216 : 				break;
; 3217 : 			else
; 3218 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	esi, 12					; 0000000cH
	cmp	esi, edi
	je	SHORT $LN13@Unguarded_
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Tmp$243560[esp+112], edx
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __Tmp$243560[esp+112]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], eax
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[esp+104]
	sub	eax, 12					; 0000000cH
	sub	edi, 12					; 0000000cH
	mov	DWORD PTR __Glast$[esp+104], eax
	cmp	DWORD PTR __First$[esp+100], eax
	jb	SHORT $LL157@Unguarded_
$LN358@Unguarded_:

; 3212 : 		for (; _First < _Glast; --_Glast)

	mov	edi, DWORD PTR __Glast$[esp+104]

; 3219 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	edi, DWORD PTR __First$[esp+100]
$LN361@Unguarded_:
	jne	$LN6@Unguarded_
	cmp	ebp, DWORD PTR __Last$[esp+100]
	je	$LN347@Unguarded_

; 3221 : 
; 3222 : 		if (_Glast == _First)
; 3223 : 			{	// no room at bottom, rotate pivot upward
; 3224 : 			if (_Plast != _Gfirst)

	cmp	ebx, ebp
	je	SHORT $LN240@Unguarded_

; 3225 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	esi, ebx
	je	SHORT $LN240@Unguarded_
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Tmp$243620[esp+112], edx
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR __Tmp$243620[esp+112]
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], eax
$LN240@Unguarded_:

; 3226 : 			++_Plast;
; 3227 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, ebp
	mov	ecx, esi
	add	ebx, 12					; 0000000cH
	add	ebp, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	ecx, eax
	je	$LL23@Unguarded_
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$243701[esp+104], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$243701[esp+108], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$243701[esp+112], edx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	ecx, DWORD PTR __Tmp$243701[esp+104]
	mov	edx, DWORD PTR __Tmp$243701[esp+108]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Tmp$243701[esp+112]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3228 : 			}
; 3229 : 		else if (_Gfirst == _Last)
; 3230 : 			{	// no room at top, rotate pivot downward
; 3231 : 			if (--_Glast != --_Pfirst)

	sub	edi, 12					; 0000000cH
	mov	DWORD PTR __Glast$[esp+104], edi
	cmp	ebp, DWORD PTR __Last$[esp+100]
	jne	SHORT $LN3@Unguarded_
	sub	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN296@Unguarded_

; 3232 : 				std::iter_swap(_Glast, _Pfirst);

	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$243768[esp+112], edx
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Tmp$243768[esp+112]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], eax
$LN296@Unguarded_:

; 3233 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	ebx, 12					; 0000000cH
	cmp	esi, ebx
	je	$LL23@Unguarded_
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Tmp$243816[esp+112], edx
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR __Tmp$243816[esp+112]
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], eax

; 3234 : 			}
; 3235 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3236 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, ebp
	add	ebp, 12					; 0000000cH
	cmp	eax, edi
	je	$LL23@Unguarded_
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$243879[esp+108], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$243879[esp+112], edx
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR __Tmp$243879[esp+108]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR __Tmp$243879[esp+112]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], ecx

; 3237 : 		}

	jmp	$LL23@Unguarded_
$LN347@Unguarded_:

; 3220 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+100]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+4], ebx
	pop	ebx

; 3238 : 	}

	add	esp, 88					; 00000058H
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YA?AU?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T243919 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243923 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$243923[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T243919[esp+4], 0
	mov	eax, DWORD PTR $T243919[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@ZV3@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &),CvGreatWorkBuildingInMyEmpire>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@ZV3@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z
_TEXT	SEGMENT
$T243993 = -20						; size = 1
$T243929 = -16						; size = 4
__Val$231436 = -12					; size = 12
__Cat$243998 = 8					; size = 1
$T243995 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@ZV3@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &),CvGreatWorkBuildingInMyEmpire>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	eax, ecx
	je	$LN6@Insertion_
	push	ebp

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebp, DWORD PTR [eax+12]
	cmp	ebp, ecx
	je	$LN69@Insertion_
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	esi
	push	edi
	jmp	SHORT $LN7@Insertion_
	npad	8
$LL68@Insertion_:
	mov	eax, DWORD PTR __First$[esp+32]
$LN7@Insertion_:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR __Val$231436[esp+40], edx
	mov	DWORD PTR __Val$231436[esp+36], ecx
	mov	ecx, DWORD PTR [ebp+8]

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	push	eax
	lea	edx, DWORD PTR __Val$231436[esp+40]
	push	edx
	mov	edi, ebp
	mov	DWORD PTR __Val$231436[esp+52], ecx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Cat$243998[esp+32]
	mov	BYTE PTR $T243993[esp+36], 0
	mov	ecx, DWORD PTR $T243993[esp+36]
	push	ecx
	mov	ecx, DWORD PTR $T243995[esp+36]
	push	edx
	mov	edx, DWORD PTR __First$[esp+40]
	push	ecx
	lea	eax, DWORD PTR [ebp+12]
	push	eax
	push	ebp
	push	edx
	lea	eax, DWORD PTR $T243929[esp+60]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,std::random_access_iterator_tag>

; 3133 : 				*_First = _Val;

	mov	ecx, DWORD PTR __Val$231436[esp+64]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR __Val$231436[esp+68]
	mov	ecx, DWORD PTR __First$[esp+60]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$231436[esp+72]
	mov	eax, DWORD PTR __First$[esp+60]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [eax+8], edx

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	lea	esi, DWORD PTR [ebp-12]
	lea	ecx, DWORD PTR __Val$231436[esp+36]
	push	esi
	push	ecx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN1@Insertion_
	npad	7
$LL3@Insertion_:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], ecx
	mov	edi, esi
	sub	esi, 12					; 0000000cH
	lea	edx, DWORD PTR __Val$231436[esp+36]
	push	esi
	push	edx
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	eax, DWORD PTR __Val$231436[esp+36]
	mov	ecx, DWORD PTR __Val$231436[esp+40]
	mov	edx, DWORD PTR __Val$231436[esp+44]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], edx
$LN4@Insertion_:
	add	ebp, 12					; 0000000cH
	cmp	ebp, DWORD PTR __Last$[esp+32]
	jne	$LL68@Insertion_
	pop	edi
	pop	esi
	pop	ebx
$LN69@Insertion_:
	pop	ebp
$LN6@Insertion_:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@ZV3@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &),CvGreatWorkBuildingInMyEmpire>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ; std::_Adjust_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Top$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 12
__Pred$ = 32						; size = 4
??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2108 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

	push	ebx

; 2110 : 	_Diff _Idx = 2 * _Hole + 2;
; 2111 : 
; 2112 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ebx, DWORD PTR __Bottom$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Hole$[esp+12]
	lea	esi, DWORD PTR [edi+edi+2]
	cmp	esi, ebx
	mov	DWORD PTR __Top$[esp+12], edi
	jge	SHORT $LN70@Adjust_hea
	npad	4
$LL5@Adjust_hea:

; 2109 : 	_Diff _Top = _Hole;

	mov	ecx, DWORD PTR __First$[esp+12]

; 2113 : 		{	// move _Hole down to larger child
; 2114 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [eax-12]
	push	ecx
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN2@Adjust_hea

; 2115 : 			--_Idx;

	dec	esi
$LN2@Adjust_hea:

; 2116 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __First$[esp+12]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	lea	edx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	edi, esi
	lea	esi, DWORD PTR [esi+esi+2]
	cmp	esi, ebx
	mov	DWORD PTR [ecx+8], eax
	jl	SHORT $LL5@Adjust_hea
$LN70@Adjust_hea:

; 2117 : 		}
; 2118 : 
; 2119 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2120 : 		{	// only child at bottom, move _Hole down to it
; 2121 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	ecx, DWORD PTR __First$[esp+12]
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4-12]
	lea	edx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2122 : 		_Hole = _Bottom - 1;

	lea	edi, DWORD PTR [ebx-1]
$LN1@Adjust_hea:

; 2123 : 		}
; 2124 : 	std::_Push_heap(_First, _Hole, _Top, _Val, _Pred);

	mov	ecx, DWORD PTR __Val$[esp+12]
	mov	edx, DWORD PTR __Val$[esp+16]
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Top$[esp+28]
	push	edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR __First$[esp+32]
	push	edi
	push	eax
	call	??$_Push_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ; std::_Push_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 28					; 0000001cH

; 2125 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00VCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@ZPAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00VCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 12
__Pred$ = 32						; size = 4
___formal$ = 36						; size = 4
??$_Pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00VCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@ZPAH@Z PROC ; std::_Pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2134 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]

; 2135 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2136 : 		_Val, _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	push	edx
	mov	edx, DWORD PTR __Val$[esp+8]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Val$[esp+24]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Last$[esp+16]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	0
	push	esi
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ; std::_Adjust_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 28					; 0000001cH

; 2137 : 	}

	pop	esi
	ret	0
??$_Pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00VCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@ZPAH@Z ENDP ; std::_Pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@3
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@3:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@6
	pop	esi
$LN9@Uninit_fil@6:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@7
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@7:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0CvPlayerCulture@@QAE@XZ			; CvPlayerCulture::CvPlayerCulture
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvPlayerCulture@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerCulture@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlayerCulture@@QAE@XZ$1
__ehfuncinfo$??0CvPlayerCulture@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvPlayerCulture@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlayerCulture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerCulture@@QAE@XZ PROC				; CvPlayerCulture::CvPlayerCulture, COMDAT
; _this$ = ecx

; 759  : {

	push	-1
	push	__ehhandler$??0CvPlayerCulture@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	lea	ecx, DWORD PTR [esi+220]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+248]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 760  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+292], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerCulture@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
__unwindfunclet$??0CvPlayerCulture@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 220				; 000000dcH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvPlayerCulture@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerCulture@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerCulture@@QAE@XZ ENDP				; CvPlayerCulture::CvPlayerCulture
PUBLIC	??1CvPlayerCulture@@QAE@XZ			; CvPlayerCulture::~CvPlayerCulture
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvPlayerCulture@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerCulture@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerCulture@@QAE@XZ$1
__ehfuncinfo$??1CvPlayerCulture@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvPlayerCulture@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlayerCulture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerCulture@@QAE@XZ PROC				; CvPlayerCulture::~CvPlayerCulture, COMDAT
; _this$ = ecx

; 764  : {

	push	-1
	push	__ehhandler$??1CvPlayerCulture@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi

; 765  : }

	lea	ecx, DWORD PTR [esi+248]
	mov	DWORD PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+220]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	je	SHORT $LN17@CvPlayerCu
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@CvPlayerCu:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerCulture@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
__unwindfunclet$??1CvPlayerCulture@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 220				; 000000dcH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvPlayerCulture@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerCulture@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerCulture@@QAE@XZ ENDP				; CvPlayerCulture::~CvPlayerCulture
PUBLIC	?RemoveDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ; CvPlayerCulture::RemoveDigCompletePlot
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?RemoveDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z PROC ; CvPlayerCulture::RemoveDigCompletePlot, COMDAT
; _this$ = ecx

; 1971 : {

	push	esi
	mov	esi, ecx

; 1972 : 	vector<CvPlot *>::const_iterator it;
; 1973 : 
; 1974 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1975 : 	for (it = m_aDigCompletePlots.begin(); it != m_aDigCompletePlots.end(); ++it)
; 1976 : #else
; 1977 : 	for (it = m_aDigCompletePlots.begin(); it != m_aDigCompletePlots.end(); it++)

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN2@RemoveDigC
	mov	edx, DWORD PTR _pPlot$[esp]
$LL17@RemoveDigC:

; 1978 : #endif
; 1979 : 	{
; 1980 : 		if (*it == pPlot)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN49@RemoveDigC
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL17@RemoveDigC
	pop	esi

; 1983 : 			break;
; 1984 : 		}
; 1985 : 	}
; 1986 : }

	ret	4
$LN49@RemoveDigC:

; 1981 : 		{
; 1982 : 			m_aDigCompletePlots.erase(it);

	lea	edx, DWORD PTR [eax+4]
	sub	ecx, edx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN39@RemoveDigC
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN39@RemoveDigC:
	add	DWORD PTR [esi+8], -4			; fffffffcH
$LN2@RemoveDigC:
	pop	esi

; 1983 : 			break;
; 1984 : 		}
; 1985 : 	}
; 1986 : }

	ret	4
?RemoveDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ENDP ; CvPlayerCulture::RemoveDigCompletePlot
_TEXT	ENDS
PUBLIC	?GetInfluencePerTurn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluencePerTurn
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::NullifyInfluenceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluencePerTurn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iRtnValue$ = -24					; size = 4
_iLoopCity$225897 = -20					; size = 4
_kOtherPlayer$ = -16					; size = 4
_this$ = -12						; size = 4
_iModifier$ = -8					; size = 4
_iTechSpreadModifier$225899 = -4			; size = 4
_bTargetHasGreatFirewall$225896 = 8			; size = 1
_kOtherTeam$ = 8					; size = 4
_ePlayer$ = 8						; size = 4
?GetInfluencePerTurn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetInfluencePerTurn, COMDAT
; _this$ = ecx

; 2598 : {

	sub	esp, 24					; 00000018H

; 2599 : 	int iRtnValue = 0;
; 2600 : 	int iModifier = 0;
; 2601 : 
; 2602 : 	CvPlayer &kOtherPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _ePlayer$[esp+32]
	mov	ebx, ecx
	imul	ebx, 63236				; 0000f704H
	push	edi
	lea	edi, DWORD PTR [ebx+eax]

; 2603 : 	CvTeam &kOtherTeam = GET_TEAM(kOtherPlayer.getTeam());

	mov	eax, DWORD PTR [edi+44]
	xor	ebp, ebp
	mov	DWORD PTR _this$[esp+40], esi
	mov	DWORD PTR _iRtnValue$[esp+40], ebp
	mov	DWORD PTR _iModifier$[esp+40], ebp
	mov	DWORD PTR _kOtherPlayer$[esp+40], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@GetInfluen@10
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@GetInfluen@10
$LN27@GetInfluen@10:
	or	eax, -1
$LN28@GetInfluen@10:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kOtherTeam$[esp+36], eax

; 2604 : 
; 2605 : 	if ((int)ePlayer != m_pPlayer->GetID() && kOtherPlayer.isAlive() && !kOtherPlayer.isMinorCiv() && kOtherTeam.isHasMet(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [esi+292]
	cmp	ecx, DWORD PTR [eax+44]
	je	$LN74@GetInfluen@10
	cmp	BYTE PTR [edi+2256], 0
	je	$LN74@GetInfluen@10
	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN74@GetInfluen@10
	mov	ecx, DWORD PTR [esi+292]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN46@GetInfluen@10
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN47@GetInfluen@10
$LN46@GetInfluen@10:
	or	eax, -1
$LN47@GetInfluen@10:
	mov	ecx, DWORD PTR _kOtherTeam$[esp+36]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN74@GetInfluen@10

; 2606 : 	{
; 2607 : 		// check to see if the other player has the Great Firewall
; 2608 : 		bool bTargetHasGreatFirewall = false;
; 2609 : 
; 2610 : 		int iLoopCity;
; 2611 : 		CvCity *pLoopCity;
; 2612 : 
; 2613 : 		// only check for firewall if the internet influence spread modifier is > 0
; 2614 : 		int iTechSpreadModifier = m_pPlayer->GetInfluenceSpreadModifier();

	mov	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR _bTargetHasGreatFirewall$225896[esp+36], 0
	call	?GetInfluenceSpreadModifier@CvPlayer@@QBEHXZ ; CvPlayer::GetInfluenceSpreadModifier
	mov	DWORD PTR _iTechSpreadModifier$225899[esp+40], eax

; 2615 : 		if (iTechSpreadModifier > 0) 

	test	eax, eax
	jle	$LN14@GetInfluen@10

; 2616 : 		{
; 2617 : 			for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoopCity))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoopCity$225897[esp+44]
	lea	ecx, DWORD PTR [ebx+edx]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN78@GetInfluen@10
	npad	1
$LL75@GetInfluen@10:

; 2618 : 			{
; 2619 : 				// Buildings
; 2620 : #ifdef AUI_WARNING_FIXES
; 2621 : 				for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 2622 : #else
; 2623 : 				for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN15@GetInfluen@10
$LL13@GetInfluen@10:

; 2624 : #endif
; 2625 : 				{
; 2626 : 					BuildingClassTypes eBuildingClass = (BuildingClassTypes)jJ;
; 2627 : 
; 2628 : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 2629 : 					if(!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN12@GetInfluen@10

; 2630 : 					{
; 2631 : 						continue;
; 2632 : 					}
; 2633 : 
; 2634 : 					CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(pLoopCity->getOwner()).getCivilizationInfo();

	mov	ecx, DWORD PTR [ebp+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 2635 : 					BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 2636 : 					if(eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN12@GetInfluen@10

; 2637 : 					{
; 2638 : 
; 2639 : 						CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 2640 : 						if (!pBuildingEntry || !pBuildingEntry->NullifyInfluenceModifier())

	test	eax, eax
	je	SHORT $LN12@GetInfluen@10
	mov	ecx, eax
	call	?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::NullifyInfluenceModifier
	test	al, al
	je	SHORT $LN12@GetInfluen@10

; 2641 : 						{
; 2642 : 							continue;
; 2643 : 						}
; 2644 : 
; 2645 : 						if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	esi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN12@GetInfluen@10

; 2646 : 						{
; 2647 : 							bTargetHasGreatFirewall = true;				

	mov	BYTE PTR _bTargetHasGreatFirewall$225896[esp+36], 1
$LN12@GetInfluen@10:

; 2618 : 			{
; 2619 : 				// Buildings
; 2620 : #ifdef AUI_WARNING_FIXES
; 2621 : 				for (uint jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
; 2622 : #else
; 2623 : 				for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL13@GetInfluen@10
$LN15@GetInfluen@10:

; 2616 : 		{
; 2617 : 			for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoopCity))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoopCity$225897[esp+44]
	add	ecx, ebx
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL75@GetInfluen@10
	mov	esi, DWORD PTR _this$[esp+40]
	mov	edi, DWORD PTR _kOtherPlayer$[esp+40]
$LN78@GetInfluen@10:
	mov	ebp, DWORD PTR _iRtnValue$[esp+40]
$LN14@GetInfluen@10:

; 2648 : 						}
; 2649 : 					}
; 2650 : 				}
; 2651 : 			}
; 2652 : 		}
; 2653 : 
; 2654 : 		// Loop through each of our cities
; 2655 : 		for (pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [esi+292]
	push	0
	lea	eax, DWORD PTR _iLoopCity$225897[esp+44]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN3@GetInfluen@10
	jmp	SHORT $LN5@GetInfluen@10
	npad	10
$LL77@GetInfluen@10:
	mov	edi, DWORD PTR _kOtherPlayer$[esp+40]
$LN5@GetInfluen@10:

; 2656 : 		{
; 2657 : 			// Design has changed so modifier is always player-to-player so only need to get it once and can apply it at the end
; 2658 : 			if (pLoopCity->isCapital())

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN2@GetInfluen@10

; 2659 : 			{
; 2660 : 				iModifier = pLoopCity->GetCityCulture()->GetTourismMultiplier(kOtherPlayer.GetID(), false, false, false, false, false);

	mov	eax, DWORD PTR [edi+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	eax
	mov	ecx, esi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetTourismMultiplier@CvCityCulture@@QBEHW4PlayerTypes@@_N1111@Z ; CvCityCulture::GetTourismMultiplier
	mov	DWORD PTR _iModifier$[esp+40], eax
$LN2@GetInfluen@10:

; 2661 : 			}
; 2662 : 
; 2663 : 			int iInfluenceToAdd = pLoopCity->GetCityCulture()->GetBaseTourism();

	mov	ecx, esi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetBaseTourism@CvCityCulture@@QAEHXZ	; CvCityCulture::GetBaseTourism

; 2664 : 
; 2665 : 			// if we have the internet online, check to see if the opponent has the firewall
; 2666 : 			// if they have the firewall, deduct the internet bonus from them
; 2667 : 			if (iTechSpreadModifier > 0 && bTargetHasGreatFirewall)

	mov	ebx, DWORD PTR _iTechSpreadModifier$225899[esp+40]
	mov	edi, eax
	test	ebx, ebx
	jle	SHORT $LN1@GetInfluen@10
	cmp	BYTE PTR _bTargetHasGreatFirewall$225896[esp+36], 0
	je	SHORT $LN1@GetInfluen@10

; 2668 : 			{
; 2669 : 				int iInfluenceWithoutModifier = pLoopCity->GetCityCulture()->GetBaseTourismBeforeModifiers();

	mov	ecx, esi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetBaseTourismBeforeModifiers@CvCityCulture@@QAEHXZ ; CvCityCulture::GetBaseTourismBeforeModifiers
	mov	ecx, eax

; 2670 : 				int iInfluenceWithTechModifier = iInfluenceWithoutModifier * iTechSpreadModifier;

	imul	ecx, ebx

; 2671 : 				iInfluenceToAdd -= (iInfluenceWithTechModifier / 100);

	mov	eax, -1374389535			; ae147ae1H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	edi, ecx
$LN1@GetInfluen@10:
	mov	eax, DWORD PTR _this$[esp+40]
	mov	ecx, DWORD PTR [eax+292]

; 2672 : 			}
; 2673 : 			
; 2674 : 			iRtnValue += iInfluenceToAdd;

	add	DWORD PTR _iRtnValue$[esp+40], edi
	push	0
	lea	edx, DWORD PTR _iLoopCity$225897[esp+44]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL77@GetInfluen@10

; 2648 : 						}
; 2649 : 					}
; 2650 : 				}
; 2651 : 			}
; 2652 : 		}
; 2653 : 
; 2654 : 		// Loop through each of our cities
; 2655 : 		for (pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ebp, DWORD PTR _iRtnValue$[esp+40]
$LN3@GetInfluen@10:

; 2675 : 		}
; 2676 : 		iRtnValue = iRtnValue * (100 + iModifier) / 100;

	mov	ecx, DWORD PTR _iModifier$[esp+40]
	add	ecx, 100				; 00000064H
	imul	ecx, ebp
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebp
	add	eax, edx
	pop	ebx

; 2680 : 
; 2681 : }

	add	esp, 24					; 00000018H
	ret	4
$LN74@GetInfluen@10:
	pop	edi
	pop	esi

; 2677 : 	}
; 2678 : 
; 2679 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2680 : 
; 2681 : }

	add	esp, 24					; 00000018H
	ret	4
?GetInfluencePerTurn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetInfluencePerTurn
_TEXT	ENDS
PUBLIC	?GetTurnsToInfluential@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetTurnsToInfluential
EXTRN	?GetTotalJONSCulturePerTurnTimes100@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetTotalJONSCulturePerTurnTimes100
EXTRN	?GetJONSCultureEverGeneratedTimes100@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetJONSCultureEverGeneratedTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnsToInfluential@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iCultPerTurn$225974 = -4				; size = 4
_iRtnValue$ = 8						; size = 4
_ePlayer$ = 8						; size = 4
?GetTurnsToInfluential@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z PROC ; CvPlayerCulture::GetTurnsToInfluential, COMDAT
; _this$ = ecx

; 2780 : {

	push	ecx
	push	ebp
	push	esi

; 2781 : 	CvPlayer &kOtherPlayer = GET_PLAYER(ePlayer);

	mov	esi, DWORD PTR _ePlayer$[esp+8]
	push	edi
	mov	edi, esi
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2782 : 	int iRtnValue = 999;
; 2783 : 
; 2784 : 	if (GetInfluenceLevel(ePlayer) >= INFLUENCE_LEVEL_INFLUENTIAL)

	push	esi
	mov	ebp, ecx
	mov	DWORD PTR _iRtnValue$[esp+16], 999	; 000003e7H
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	cmp	eax, 4
	jl	SHORT $LN5@GetTurnsTo
	pop	edi
	pop	esi

; 2785 : 	{
; 2786 : 		return 0;

	xor	eax, eax
	pop	ebp

; 2818 : }

	pop	ecx
	ret	4
$LN5@GetTurnsTo:

; 2787 : 	}
; 2788 : 	else if (GetInfluenceTrend(ePlayer) == INFLUENCE_TREND_RISING)

	push	esi
	mov	ecx, ebp
	call	?GetInfluenceTrend@CvPlayerCulture@@QBE?AW4InfluenceLevelTrend@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceTrend
	cmp	eax, 1
	jne	$LN18@GetTurnsTo
	push	ebx

; 2789 : 	{
; 2790 : 		int iInfluence = GetInfluenceOn(ePlayer);

	test	esi, esi
	jl	SHORT $LN10@GetTurnsTo
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN10@GetTurnsTo
	mov	ebx, DWORD PTR [ebp+esi*4+20]
	jmp	SHORT $LN12@GetTurnsTo
$LN10@GetTurnsTo:
	xor	ebx, ebx
$LN12@GetTurnsTo:

; 2791 : 		int iInflPerTurn = GetInfluencePerTurn(ePlayer);

	push	esi
	mov	ecx, ebp
	call	?GetInfluencePerTurn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluencePerTurn
	mov	esi, eax

; 2792 : #ifdef AUI_PLAYER_FIX_JONS_CULTURE_IS_T100
; 2793 : 		iInfluence *= 100;
; 2794 : 		iInflPerTurn *= 100;
; 2795 : 		int iCulture = kOtherPlayer.GetJONSCultureEverGeneratedTimes100();

	mov	ecx, edi
	imul	esi, 100				; 00000064H
	call	?GetJONSCultureEverGeneratedTimes100@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGeneratedTimes100

; 2796 : 		int iCultPerTurn = kOtherPlayer.GetTotalJONSCulturePerTurnTimes100();

	mov	ecx, edi
	mov	ebp, eax
	call	?GetTotalJONSCulturePerTurnTimes100@CvPlayer@@QBEHXZ ; CvPlayer::GetTotalJONSCulturePerTurnTimes100
	imul	ebx, 100				; 00000064H

; 2797 : #else
; 2798 : 		int iCulture = kOtherPlayer.GetJONSCultureEverGenerated();
; 2799 : 		int iCultPerTurn = kOtherPlayer.GetTotalJONSCulturePerTurn();
; 2800 : #endif
; 2801 : 
; 2802 : 		int iNumerator = (GC.getCULTURE_LEVEL_INFLUENTIAL() * iCulture / 100) -  iInfluence;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8252
	mov	edx, ecx
	imul	edx, ebp
	mov	DWORD PTR _iCultPerTurn$225974[esp+20], eax

; 2803 : 		int iDivisor = iInflPerTurn - (GC.getCULTURE_LEVEL_INFLUENTIAL() * iCultPerTurn / 100);

	imul	ecx, DWORD PTR _iCultPerTurn$225974[esp+20]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	sub	edi, ebx
	sub	esi, ecx
	pop	ebx

; 2804 : 
; 2805 : 		if (iDivisor > 0)

	test	esi, esi
	jle	SHORT $LN18@GetTurnsTo

; 2806 : 		{
; 2807 : 			iRtnValue = iNumerator / iDivisor;

	mov	eax, edi
	cdq
	idiv	esi
	mov	DWORD PTR _iRtnValue$[esp+12], eax

; 2808 : 
; 2809 : 			// Round up
; 2810 : 			if (iNumerator % iDivisor != 0)

	test	edx, edx
	je	SHORT $LN18@GetTurnsTo

; 2811 : 			{
; 2812 : 				iRtnValue++;

	inc	DWORD PTR _iRtnValue$[esp+12]
$LN18@GetTurnsTo:

; 2813 : 			}
; 2814 : 		}
; 2815 : 	}
; 2816 : 
; 2817 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+12]
	pop	edi
	pop	esi
	pop	ebp

; 2818 : }

	pop	ecx
	ret	4
?GetTurnsToInfluential@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlayerCulture::GetTurnsToInfluential
_TEXT	ENDS
PUBLIC	?GetTourism@CvPlayerCulture@@QAEHXZ		; CvPlayerCulture::GetTourism
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourism@CvPlayerCulture@@QAEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetTourism@CvPlayerCulture@@QAEHXZ PROC		; CvPlayerCulture::GetTourism, COMDAT
; _this$ = ecx

; 3074 : {

	push	ecx
	push	esi
	push	edi

; 3075 : 	int iRtnValue = 0;

	xor	edi, edi
	mov	esi, ecx

; 3076 : 
; 3077 : 	CvCity *pCity;
; 3078 : 	int iLoop;
; 3079 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN8@GetTourism@5
	npad	4
$LL3@GetTourism@5:

; 3080 : 	{
; 3081 : 		iRtnValue += pCity->GetCityCulture()->GetBaseTourism();

	mov	ecx, eax
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetBaseTourism@CvCityCulture@@QAEHXZ	; CvCityCulture::GetBaseTourism
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetTourism@5
$LN8@GetTourism@5:

; 3082 : 	}
; 3083 : 
; 3084 : 	return iRtnValue;

	mov	eax, edi
	pop	edi
	pop	esi

; 3085 : }

	pop	ecx
	ret	0
?GetTourism@CvPlayerCulture@@QAEHXZ ENDP		; CvPlayerCulture::GetTourism
_TEXT	ENDS
PUBLIC	?GetTourismBlastStrength@CvPlayerCulture@@QAEHH@Z ; CvPlayerCulture::GetTourismBlastStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismBlastStrength@CvPlayerCulture@@QAEHH@Z
_TEXT	SEGMENT
_iStrength$ = -4					; size = 4
$T245045 = 8						; size = 4
_iMultiplier$ = 8					; size = 4
?GetTourismBlastStrength@CvPlayerCulture@@QAEHH@Z PROC	; CvPlayerCulture::GetTourismBlastStrength, COMDAT
; _this$ = ecx

; 3405 : {

	push	ecx
	push	esi

; 3406 : 	int iStrength = iMultiplier * GetTourism();

	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism

; 3407 : 	
; 3408 : 	// Scale by game speed
; 3409 : 	iStrength *= GC.getGame().getGameSpeedInfo().getCulturePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	imul	esi, DWORD PTR _iMultiplier$[esp+4]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	mov	ecx, eax
	imul	ecx, esi

; 3410 : 	iStrength /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3411 : 
; 3412 : 	return max(iStrength, GC.getMINIUMUM_TOURISM_BLAST_STRENGTH());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8236
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iStrength$[esp+8], eax
	cmp	eax, ecx
	mov	DWORD PTR $T245045[esp+4], ecx
	pop	esi
	lea	eax, DWORD PTR $T245045[esp]
	jl	SHORT $LN11@GetTourism@6
	lea	eax, DWORD PTR _iStrength$[esp+4]
$LN11@GetTourism@6:
	mov	eax, DWORD PTR [eax]

; 3413 : }

	pop	ecx
	ret	4
?GetTourismBlastStrength@CvPlayerCulture@@QAEHH@Z ENDP	; CvPlayerCulture::GetTourismBlastStrength
_TEXT	ENDS
PUBLIC	?LogCultureData@CvPlayerCulture@@AAEXXZ		; CvPlayerCulture::LogCultureData
EXTRN	?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityCitizens::GetNumSpecialistsInBuilding
EXTRN	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z:PROC ; CvPlayer::GetFirstCityWithBuildingClass
;	COMDAT ?bFirstRun@?4??LogCultureData@CvPlayerCulture@@AAEXXZ@4_NA
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_DATA	SEGMENT
?bFirstRun@?4??LogCultureData@CvPlayerCulture@@AAEXXZ@4_NA DB 01H ; `CvPlayerCulture::LogCultureData'::`5'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCultureData@CvPlayerCulture@@AAEXXZ DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?LogCultureData@CvPlayerCulture@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCultureData@CvPlayerCulture@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$11
	DD	07H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$12
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$13
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$17
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$19
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$20
	DD	0cH
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$21
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$25
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$27
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$28
	DD	010H
	DD	FLAT:__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$29
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogCultureData@CvPlayerCulture@@AAEXXZ
_TEXT	SEGMENT
$T245119 = -264						; size = 4
$T245118 = -264						; size = 4
$T245117 = -264						; size = 4
$T245116 = -264						; size = 4
$T245115 = -264						; size = 4
$T245106 = -264						; size = 4
$T245102 = -264						; size = 4
$T245101 = -264						; size = 4
$T245100 = -264						; size = 4
$T245091 = -264						; size = 4
$T245087 = -264						; size = 4
$T245086 = -264						; size = 4
$T245085 = -264						; size = 4
$T245076 = -264						; size = 4
$T245075 = -264						; size = 4
$T245131 = -260						; size = 4
_bBuildHeader$ = -253					; size = 1
$T245112 = -252						; size = 4
$T245105 = -252						; size = 4
$T245097 = -252						; size = 4
$T245090 = -252						; size = 4
$T245082 = -252						; size = 4
$T245072 = -252						; size = 4
_eTechAcoustics$ = -248					; size = 4
$T245071 = -248						; size = 4
$T245070 = -248						; size = 4
$T245068 = -248						; size = 4
_pTeam$ = -244						; size = 4
_eWritersGuild$ = -240					; size = 4
_eMusiciansGuild$ = -236				; size = 4
_strLog$ = -232						; size = 28
_pLog$ = -204						; size = 4
_strHeader$ = -200					; size = 28
_eMusiciansGuildClass$ = -172				; size = 4
$T245069 = -172						; size = 4
_eTechGuilds$ = -168					; size = 4
_eArtistsGuildClass$ = -164				; size = 4
_eArtistsGuild$ = -160					; size = 4
_iLoop$ = -156						; size = 4
$T245109 = -152						; size = 28
$T245094 = -152						; size = 28
$T245078 = -152						; size = 28
$T245108 = -124						; size = 28
$T245093 = -124						; size = 28
$T245079 = -124						; size = 28
_strPlayerName$ = -96					; size = 28
$T245067 = -68						; size = 28
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogCultureData@CvPlayerCulture@@AAEXXZ PROC		; CvPlayerCulture::LogCultureData, COMDAT
; _this$ = ecx

; 3981 : {

	push	-1
	push	__ehhandler$?LogCultureData@CvPlayerCulture@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	ebp
	push	esi
	xor	ebx, ebx
	mov	esi, ecx

; 3982 : 	CvTeam &pTeam = GET_TEAM(m_pPlayer->getTeam());

	mov	DWORD PTR $T245131[esp+276], ebx
	mov	eax, DWORD PTR [esi+292]
	mov	eax, DWORD PTR [eax+44]
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN84@LogCulture
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN85@LogCulture
$LN84@LogCulture:
	or	eax, -1
$LN85@LogCulture:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 3983 : 
; 3984 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _pTeam$[esp+280], eax
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN10@LogCulture
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN10@LogCulture

; 3985 : 	{
; 3986 : 		return;
; 3987 : 	}
; 3988 : 
; 3989 : 	static bool bFirstRun = true;
; 3990 : 	bool bBuildHeader = false;
; 3991 : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[esp+280]
	mov	BYTE PTR _bBuildHeader$[esp+280], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3992 : 	if(bFirstRun)

	cmp	BYTE PTR ?bFirstRun@?4??LogCultureData@CvPlayerCulture@@AAEXXZ@4_NA, 0
	mov	DWORD PTR __$EHRec$[esp+288], ebx
	je	SHORT $LN9@LogCulture

; 3993 : 	{
; 3994 : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?4??LogCultureData@CvPlayerCulture@@AAEXXZ@4_NA, 0

; 3995 : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[esp+280], 1
$LN9@LogCulture:

; 3996 : 	}
; 3997 : 
; 3998 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+280]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3999 : 	FILogFile* pLog;
; 4000 : 	CvString strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	cmp	eax, ebx
	jne	SHORT $LN100@LogCulture
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN100@LogCulture:
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$[esp+284]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+288], 2

; 4001 : 	pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	lea	eax, DWORD PTR _strPlayerName$[esp+280]
	push	eax
	lea	ecx, DWORD PTR $T245067[esp+284]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvPlayerCulture@@ABE?AVCvString@@AAV2@@Z ; CvPlayerCulture::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	ebx
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T245067[esp+280]
	mov	DWORD PTR _pLog$[esp+280], eax
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4002 : 
; 4003 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+280]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4004 : 	CvCity *pCity;
; 4005 : 	int iSpecialists = 0;
; 4006 : 
; 4007 : 	// civ name
; 4008 : 	AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strPlayerName$[esp+308]
	mov	DWORD PTR $T245068[esp+308], esp
	mov	ecx, esp
	push	edx
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245069[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226672
	mov	BYTE PTR __$EHRec$[esp+348], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+336]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+340]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 4
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog

; 4009 : 
; 4010 : 	// turn
; 4011 : 	AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245070[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226674
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+312]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+316]
	push	eax
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4012 : 
; 4013 : 	// # cities
; 4014 : 	AppendToLog(strHeader, strLog, "# Cities", m_pPlayer->getNumCities());

	mov	ecx, DWORD PTR [esi+292]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245071[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226676
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+312]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+316]
	push	edx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4015 : 
; 4016 : 	// Guilds
; 4017 : 	TechTypes eTechDrama = (TechTypes)GC.getInfoTypeForString("TECH_DRAMA", true);

	push	1
	push	OFFSET $SG226679
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4018 : 	TechTypes eTechGuilds = (TechTypes)GC.getInfoTypeForString("TECH_GUILDS", true);

	push	1
	push	OFFSET $SG226682
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4019 : 	TechTypes eTechAcoustics = (TechTypes)GC.getInfoTypeForString("TECH_ACOUSTICS", true);

	push	1
	push	OFFSET $SG226685
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eTechGuilds$[esp+288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4020 : 	BuildingClassTypes eWritersGuildClass = (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_WRITERS_GUILD", true);

	push	1
	push	OFFSET $SG226688
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eTechAcoustics$[esp+288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4021 : 	BuildingClassTypes eArtistsGuildClass = (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_ARTISTS_GUILD", true);

	push	1
	push	OFFSET $SG226691
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4022 : 	BuildingClassTypes eMusiciansGuildClass = (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_MUSICIANS_GUILD", true);

	push	1
	push	OFFSET $SG226694
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eArtistsGuildClass$[esp+288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4023 : 	BuildingTypes eWritersGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_WRITERS_GUILD", true);

	push	1
	push	OFFSET $SG226697
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eMusiciansGuildClass$[esp+288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4024 : 	BuildingTypes eArtistsGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_ARTISTS_GUILD", true);

	push	1
	push	OFFSET $SG226700
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eWritersGuild$[esp+288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4025 : 	BuildingTypes eMusiciansGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MUSICIANS_GUILD", true);

	push	1
	push	OFFSET $SG226703
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eArtistsGuild$[esp+288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eMusiciansGuild$[esp+280], eax

; 4026 : 
; 4027 : 	if (eWritersGuildClass != NO_BUILDINGCLASS && eWritersGuild != NO_BUILDING)

	cmp	edi, -1
	je	$LN8@LogCulture
	cmp	DWORD PTR _eWritersGuild$[esp+280], -1
	je	$LN8@LogCulture

; 4028 : 	{
; 4029 : 		AppendToLog(strHeader, strLog, "Drama", pTeam.GetTeamTechs()->HasTech(eTechDrama) ? "yes" : "no");

	mov	ecx, DWORD PTR _pTeam$[esp+280]
	push	ebp
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	mov	eax, OFFSET $SG226707
	jne	SHORT $LN15@LogCulture
	mov	eax, OFFSET $SG226708
$LN15@LogCulture:
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T245072[esp+308], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245075[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226709
	mov	BYTE PTR __$EHRec$[esp+348], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+336]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+340]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 4
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog

; 4030 : 		pCity = m_pPlayer->GetFirstCityWithBuildingClass(eWritersGuildClass);

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	mov	edi, eax

; 4031 : 		AppendToLog(strHeader, strLog, "Writers' Guild", (pCity != NULL ? pCity->getName() : ""));

	test	edi, edi
	je	SHORT $LN16@LogCulture
	lea	edx, DWORD PTR $T245078[esp+280]
	push	edx
	mov	ecx, edi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[esp+288], 7
	mov	ebx, 1
	jmp	SHORT $LN257@LogCulture
$LN16@LogCulture:
	push	OFFSET $SG226715
	lea	ecx, DWORD PTR $T245079[esp+284]
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	DWORD PTR __$EHRec$[esp+288], 8
	mov	ebx, 2
$LN257@LogCulture:
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245076[esp+308], esp
	mov	ecx, esp
	push	eax
	mov	DWORD PTR $T245131[esp+312], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245082[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226716
	mov	DWORD PTR __$EHRec$[esp+348], 9
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+336]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+340]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 8
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog
	mov	DWORD PTR __$EHRec$[esp+288], 7
	test	bl, 2
	je	SHORT $LN49@LogCulture
	and	ebx, -3					; fffffffdH
	lea	ecx, DWORD PTR $T245079[esp+280]
	mov	DWORD PTR $T245131[esp+280], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN49@LogCulture:
	mov	DWORD PTR __$EHRec$[esp+288], 4
	test	bl, 1
	je	SHORT $LN50@LogCulture
	and	ebx, -2					; fffffffeH
	lea	ecx, DWORD PTR $T245078[esp+280]
	mov	DWORD PTR $T245131[esp+280], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN50@LogCulture:

; 4032 : 		iSpecialists = (pCity != NULL) ? pCity->GetCityCitizens()->GetNumSpecialistsInBuilding(eWritersGuild) : 0;

	test	edi, edi
	je	SHORT $LN18@LogCulture
	mov	edx, DWORD PTR _eWritersGuild$[esp+280]
	push	edx
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ; CvCityCitizens::GetNumSpecialistsInBuilding
	jmp	SHORT $LN19@LogCulture
$LN18@LogCulture:
	xor	eax, eax
$LN19@LogCulture:

; 4033 : 		AppendToLog(strHeader, strLog, "Spclsts", iSpecialists);

	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245085[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226718
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+312]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+316]
	push	ecx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4034 : #ifdef AUI_WARNING_FIXES
; 4035 : 		AppendToLog(strHeader, strLog, "Slots", (int)GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_LITERATURE()));
; 4036 : #else
; 4037 : 		AppendToLog(strHeader, strLog, "Slots", GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_LITERATURE()));

	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
	push	eax
	mov	ecx, esi
	call	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245086[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226720
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+312]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+316]
	push	eax
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog
$LN8@LogCulture:

; 4038 : #endif
; 4039 : 	}
; 4040 : 
; 4041 : 	if (eArtistsGuildClass != NO_BUILDINGCLASS && eArtistsGuild != NO_BUILDING)

	mov	edi, DWORD PTR _eArtistsGuildClass$[esp+280]
	cmp	edi, -1
	je	$LN7@LogCulture
	mov	ebp, DWORD PTR _eArtistsGuild$[esp+280]
	cmp	ebp, -1
	je	$LN7@LogCulture

; 4042 : 	{
; 4043 : 		AppendToLog(strHeader, strLog, "Guilds", pTeam.GetTeamTechs()->HasTech(eTechGuilds) ? "yes" : "no");

	mov	ecx, DWORD PTR _eTechGuilds$[esp+280]
	push	ecx
	mov	ecx, DWORD PTR _pTeam$[esp+284]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	mov	eax, OFFSET $SG226724
	jne	SHORT $LN21@LogCulture
	mov	eax, OFFSET $SG226725
$LN21@LogCulture:
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T245087[esp+308], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245090[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226726
	mov	BYTE PTR __$EHRec$[esp+348], 10		; 0000000aH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+336]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+340]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 4
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog

; 4044 : 		pCity = m_pPlayer->GetFirstCityWithBuildingClass(eArtistsGuildClass);

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	mov	edi, eax

; 4045 : 		AppendToLog(strHeader, strLog, "Artists' Guild", (pCity != NULL ? pCity->getName() : ""));

	test	edi, edi
	je	SHORT $LN22@LogCulture
	lea	ecx, DWORD PTR $T245093[esp+280]
	push	ecx
	mov	ecx, edi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[esp+288], 11		; 0000000bH
	or	ebx, 4
	jmp	SHORT $LN258@LogCulture
$LN22@LogCulture:
	push	OFFSET $SG226732
	lea	ecx, DWORD PTR $T245094[esp+284]
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	DWORD PTR __$EHRec$[esp+288], 12	; 0000000cH
	or	ebx, 8
$LN258@LogCulture:
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245091[esp+308], esp
	mov	ecx, esp
	push	eax
	mov	DWORD PTR $T245131[esp+312], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245097[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226733
	mov	DWORD PTR __$EHRec$[esp+348], 13	; 0000000dH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+336]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+340]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 12		; 0000000cH
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog
	mov	DWORD PTR __$EHRec$[esp+288], 11	; 0000000bH
	test	bl, 8
	je	SHORT $LN61@LogCulture
	and	ebx, -9					; fffffff7H
	lea	ecx, DWORD PTR $T245094[esp+280]
	mov	DWORD PTR $T245131[esp+280], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN61@LogCulture:
	mov	DWORD PTR __$EHRec$[esp+288], 4
	test	bl, 4
	je	SHORT $LN62@LogCulture
	and	ebx, -5					; fffffffbH
	lea	ecx, DWORD PTR $T245093[esp+280]
	mov	DWORD PTR $T245131[esp+280], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN62@LogCulture:

; 4046 : 		iSpecialists = (pCity != NULL) ? pCity->GetCityCitizens()->GetNumSpecialistsInBuilding(eArtistsGuild) : 0;

	test	edi, edi
	je	SHORT $LN24@LogCulture
	push	ebp
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ; CvCityCitizens::GetNumSpecialistsInBuilding
	jmp	SHORT $LN25@LogCulture
$LN24@LogCulture:
	xor	eax, eax
$LN25@LogCulture:

; 4047 : 		AppendToLog(strHeader, strLog, "Spclsts", iSpecialists);

	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245100[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226735
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+312]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+316]
	push	edx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4048 : #ifdef AUI_WARNING_FIXES
; 4049 : 		AppendToLog(strHeader, strLog, "Slots", (int)GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT()));
; 4050 : #else
; 4051 : 		AppendToLog(strHeader, strLog, "Slots", GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT()));

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	push	eax
	mov	ecx, esi
	call	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245101[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226737
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+312]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+316]
	push	ecx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog
$LN7@LogCulture:

; 4052 : #endif
; 4053 : 	}
; 4054 : 
; 4055 : 	if (eMusiciansGuildClass != NO_BUILDINGCLASS && eMusiciansGuild != NO_BUILDING)

	mov	edi, DWORD PTR _eMusiciansGuildClass$[esp+280]
	cmp	edi, -1
	je	$LN6@LogCulture
	cmp	DWORD PTR _eMusiciansGuild$[esp+280], -1
	je	$LN6@LogCulture

; 4056 : 	{
; 4057 : 		AppendToLog(strHeader, strLog, "Acoustics", pTeam.GetTeamTechs()->HasTech(eTechAcoustics) ? "yes" : "no");

	mov	edx, DWORD PTR _eTechAcoustics$[esp+280]
	mov	ecx, DWORD PTR _pTeam$[esp+280]
	push	edx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	mov	eax, OFFSET $SG226741
	jne	SHORT $LN27@LogCulture
	mov	eax, OFFSET $SG226742
$LN27@LogCulture:
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T245102[esp+308], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245105[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226743
	mov	BYTE PTR __$EHRec$[esp+348], 14		; 0000000eH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+336]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+340]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 4
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog

; 4058 : 		pCity = m_pPlayer->GetFirstCityWithBuildingClass(eMusiciansGuildClass);

	mov	ecx, DWORD PTR [esi+292]
	push	edi
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	mov	edi, eax

; 4059 : 		AppendToLog(strHeader, strLog, "Musicians' Guild", (pCity != NULL ? pCity->getName() : ""));

	test	edi, edi
	je	SHORT $LN28@LogCulture
	lea	edx, DWORD PTR $T245108[esp+280]
	push	edx
	mov	ecx, edi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[esp+288], 15		; 0000000fH
	or	ebx, 16					; 00000010H
	jmp	SHORT $LN259@LogCulture
$LN28@LogCulture:
	push	OFFSET $SG226749
	lea	ecx, DWORD PTR $T245109[esp+284]
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	DWORD PTR __$EHRec$[esp+288], 16	; 00000010H
	or	ebx, 32					; 00000020H
$LN259@LogCulture:
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245106[esp+308], esp
	mov	ecx, esp
	push	eax
	mov	DWORD PTR $T245131[esp+312], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245112[esp+336], esp
	mov	ecx, esp
	push	OFFSET $SG226750
	mov	DWORD PTR __$EHRec$[esp+348], 17	; 00000011H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+336]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+340]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+352], 16		; 00000010H
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@1@Z ; CvPlayerCulture::AppendToLog
	mov	DWORD PTR __$EHRec$[esp+288], 15	; 0000000fH
	test	bl, 32					; 00000020H
	je	SHORT $LN73@LogCulture
	and	ebx, -33				; ffffffdfH
	lea	ecx, DWORD PTR $T245109[esp+280]
	mov	DWORD PTR $T245131[esp+280], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN73@LogCulture:
	mov	DWORD PTR __$EHRec$[esp+288], 4
	test	bl, 16					; 00000010H
	je	SHORT $LN74@LogCulture
	lea	ecx, DWORD PTR $T245108[esp+280]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN74@LogCulture:

; 4060 : 		iSpecialists = (pCity != NULL) ? pCity->GetCityCitizens()->GetNumSpecialistsInBuilding(eMusiciansGuild) : 0;

	test	edi, edi
	je	SHORT $LN30@LogCulture
	mov	edx, DWORD PTR _eMusiciansGuild$[esp+280]
	push	edx
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ; CvCityCitizens::GetNumSpecialistsInBuilding
	jmp	SHORT $LN31@LogCulture
$LN30@LogCulture:
	xor	eax, eax
$LN31@LogCulture:

; 4061 : 		AppendToLog(strHeader, strLog, "Spclsts", iSpecialists);

	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245115[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226752
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+312]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+316]
	push	ecx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4062 : #ifdef AUI_WARNING_FIXES
; 4063 : 		AppendToLog(strHeader, strLog, "Slots", (int)GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_MUSIC()));
; 4064 : #else
; 4065 : 		AppendToLog(strHeader, strLog, "Slots", GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_MUSIC()));

	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	push	eax
	mov	ecx, esi
	call	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245116[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226754
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+312]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+316]
	push	eax
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog
$LN6@LogCulture:

; 4066 : #endif
; 4067 : 	}
; 4068 : 
; 4069 : #ifdef AUI_WARNING_FIXES
; 4070 : 	AppendToLog(strHeader, strLog, "Great Works", (int)GetNumGreatWorks());
; 4071 : #else
; 4072 : 	AppendToLog(strHeader, strLog, "Great Works", GetNumGreatWorks());

	mov	ecx, esi
	call	?GetNumGreatWorks@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumGreatWorks
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245117[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226756
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+312]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+316]
	push	edx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4073 : #endif
; 4074 : 	AppendToLog(strHeader, strLog, "Tourism", GetTourism());

	mov	ecx, esi
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245118[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226758
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+312]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+316]
	push	ecx
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4075 : 	AppendToLog(strHeader, strLog, "Theming Bonuses", GetTotalThemingBonuses());

	mov	ecx, esi
	call	?GetTotalThemingBonuses@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetTotalThemingBonuses
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T245119[esp+312], esp
	mov	ecx, esp
	push	OFFSET $SG226760
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+312]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+316]
	push	eax
	mov	ecx, esi
	call	?AppendToLog@CvPlayerCulture@@AAEXAAVCvString@@0V2@H@Z ; CvPlayerCulture::AppendToLog

; 4076 : 
; 4077 : 	if(bBuildHeader)

	cmp	BYTE PTR _bBuildHeader$[esp+280], 0
	je	SHORT $LN253@LogCulture

; 4078 : 	{
; 4079 : 		pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[esp+280]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebx, DWORD PTR _pLog$[esp+280]
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebx
	call	edx
	add	esp, 8
	jmp	SHORT $LN5@LogCulture
$LN253@LogCulture:
	mov	ebx, DWORD PTR _pLog$[esp+280]
$LN5@LogCulture:

; 4080 : 	}
; 4081 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+280]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebx
	call	edx

; 4082 : 
; 4083 : 	CvCity *pLoopCity;
; 4084 : 	int iLoop;
; 4085 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+292]
	add	esp, 8
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+284]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN2@LogCulture
$LL4@LogCulture:

; 4086 : 	{
; 4087 : 		if (pLoopCity->GetCityCulture()->GetNumGreatWorks() > 0)

	mov	ecx, edi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, DWORD PTR [eax]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumGreatWorks
	test	eax, eax
	jle	SHORT $LN3@LogCulture

; 4088 : 		{
; 4089 : 			pLoopCity->GetCityCulture()->LogGreatWorks(pLog);

	push	ebx
	mov	ecx, edi
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?LogGreatWorks@CvCityCulture@@QAEXPAVFILogFile@@@Z ; CvCityCulture::LogGreatWorks
$LN3@LogCulture:
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+284]
	push	ecx
	mov	ecx, DWORD PTR [esi+292]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@LogCulture
$LN2@LogCulture:

; 4090 : 		}
; 4091 : 	}
; 4092 : }

	lea	ecx, DWORD PTR _str$[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeader$[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@LogCulture:
	mov	ecx, DWORD PTR __$EHRec$[esp+280]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 264				; 00000108H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T245067[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$4:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$5:
	mov	ecx, DWORD PTR $T245068[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$9:
	mov	ecx, DWORD PTR $T245072[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$11:
	mov	eax, DWORD PTR $T245131[ebp]
	and	eax, 1
	je	$LN44@LogCulture
	and	DWORD PTR $T245131[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T245078[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN44@LogCulture:
	ret	0
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$12:
	mov	eax, DWORD PTR $T245131[ebp]
	and	eax, 2
	je	$LN46@LogCulture
	and	DWORD PTR $T245131[ebp], -3		; fffffffdH
	lea	ecx, DWORD PTR $T245079[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN46@LogCulture:
	ret	0
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$13:
	mov	ecx, DWORD PTR $T245076[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$17:
	mov	ecx, DWORD PTR $T245087[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$19:
	mov	eax, DWORD PTR $T245131[ebp]
	and	eax, 4
	je	$LN56@LogCulture
	and	DWORD PTR $T245131[ebp], -5		; fffffffbH
	lea	ecx, DWORD PTR $T245093[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN56@LogCulture:
	ret	0
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$20:
	mov	eax, DWORD PTR $T245131[ebp]
	and	eax, 8
	je	$LN58@LogCulture
	and	DWORD PTR $T245131[ebp], -9		; fffffff7H
	lea	ecx, DWORD PTR $T245094[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN58@LogCulture:
	ret	0
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$21:
	mov	ecx, DWORD PTR $T245091[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$25:
	mov	ecx, DWORD PTR $T245102[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$27:
	mov	eax, DWORD PTR $T245131[ebp]
	and	eax, 16					; 00000010H
	je	$LN68@LogCulture
	and	DWORD PTR $T245131[ebp], -17		; ffffffefH
	lea	ecx, DWORD PTR $T245108[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN68@LogCulture:
	ret	0
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$28:
	mov	eax, DWORD PTR $T245131[ebp]
	and	eax, 32					; 00000020H
	je	$LN70@LogCulture
	and	DWORD PTR $T245131[ebp], -33		; ffffffdfH
	lea	ecx, DWORD PTR $T245109[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN70@LogCulture:
	ret	0
__unwindfunclet$?LogCultureData@CvPlayerCulture@@AAEXXZ$29:
	mov	ecx, DWORD PTR $T245106[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogCultureData@CvPlayerCulture@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogCultureData@CvPlayerCulture@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCultureData@CvPlayerCulture@@AAEXXZ ENDP		; CvPlayerCulture::LogCultureData
PUBLIC	?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ; CultureHelpers::IsValidForThemingBonus
; Function compile flags: /Ogtpy
;	COMDAT ?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z
_TEXT	SEGMENT
_pBonusInfo$ = 8					; size = 4
_eEra$ = 12						; size = 4
_aErasSeen$ = 16					; size = 4
_ePlayer$ = 20						; size = 4
_aPlayersSeen$ = 24					; size = 4
_eOwner$ = 28						; size = 4
?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z PROC ; CultureHelpers::IsValidForThemingBonus, COMDAT

; 5875 : 	bool bValid = true;
; 5876 : 
; 5877 : 	// Can we rule this out based on era?
; 5878 : 	if (bValid && pBonusInfo->IsSameEra())

	mov	ecx, DWORD PTR _aErasSeen$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pBonusInfo$[esp]
	cmp	BYTE PTR [esi+32], 0
	push	edi
	mov	edi, DWORD PTR _eEra$[esp+4]
	mov	al, 1
	je	SHORT $LN121@IsValidFor

; 5879 : 	{
; 5880 : 		if (eEra != aErasSeen[0])

	mov	edx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx]

; 5881 : 		{
; 5882 : 			bValid = false;
; 5883 : 		}
; 5884 : 	}
; 5885 : 	if (bValid && pBonusInfo->IsUniqueEras())

	jne	SHORT $LN130@IsValidFor
$LN121@IsValidFor:
	cmp	BYTE PTR [esi+33], 0
	je	SHORT $LN122@IsValidFor

; 5886 : 	{
; 5887 : 		if (std::find(aErasSeen.begin(), aErasSeen.end(), eEra) != aErasSeen.end())

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, edx
	je	SHORT $LN122@IsValidFor
	npad	3
$LL49@IsValidFor:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN117@IsValidFor
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL49@IsValidFor
$LN117@IsValidFor:
	cmp	ecx, edx

; 5888 : 		{
; 5889 : 			bValid = false;
; 5890 : 		}
; 5891 : 	}
; 5892 : 
; 5893 : 	// Can we rule this out based on player?
; 5894 : 	if (bValid && pBonusInfo->IsRequiresOwner())

	jne	SHORT $LN130@IsValidFor
$LN122@IsValidFor:
	cmp	BYTE PTR [esi+37], 0
	mov	ecx, DWORD PTR _eOwner$[esp+4]
	mov	edi, DWORD PTR _ePlayer$[esp+4]
	je	SHORT $LN123@IsValidFor

; 5895 : 	{
; 5896 : 		if (ePlayer != eOwner)

	cmp	edi, ecx

; 5897 : 		{
; 5898 : 			bValid = false;
; 5899 : 		}
; 5900 : 	}
; 5901 : 	if (bValid && pBonusInfo->IsRequiresAnyButOwner())

	jne	SHORT $LN130@IsValidFor
$LN123@IsValidFor:
	cmp	BYTE PTR [esi+38], 0
	je	SHORT $LN124@IsValidFor

; 5902 : 	{
; 5903 : 		if (ePlayer == eOwner)

	cmp	edi, ecx

; 5904 : 		{
; 5905 : 			bValid = false;
; 5906 : 		}
; 5907 : 	}
; 5908 : 	if (bValid && pBonusInfo->IsRequiresSamePlayer())

	je	SHORT $LN130@IsValidFor
$LN124@IsValidFor:
	cmp	BYTE PTR [esi+39], 0
	mov	ecx, DWORD PTR _aPlayersSeen$[esp+4]
	je	SHORT $LN125@IsValidFor

; 5909 : 	{
; 5910 : 		if (ePlayer != aPlayersSeen[0])

	mov	edx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx]

; 5911 : 		{
; 5912 : 			bValid = false;
; 5913 : 		}
; 5914 : 
; 5915 : 	}
; 5916 : 	if (bValid && pBonusInfo->IsRequiresUniquePlayers())

	jne	SHORT $LN130@IsValidFor
$LN125@IsValidFor:
	cmp	BYTE PTR [esi+40], 0
	je	SHORT $LN1@IsValidFor

; 5917 : 	{
; 5918 : 		if (std::find(aPlayersSeen.begin(), aPlayersSeen.end(), ePlayer) != aPlayersSeen.end())

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, edx
	je	SHORT $LN1@IsValidFor
	npad	4
$LL101@IsValidFor:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN118@IsValidFor
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL101@IsValidFor
$LN118@IsValidFor:
	cmp	ecx, edx
	je	SHORT $LN1@IsValidFor
$LN130@IsValidFor:

; 5919 : 		{
; 5920 : 			bValid = false;

	xor	al, al
$LN1@IsValidFor:
	pop	edi
	pop	esi

; 5921 : 		}
; 5922 : 	}
; 5923 : 
; 5924 : 	return bValid;
; 5925 : }

	ret	0
?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ENDP ; CultureHelpers::IsValidForThemingBonus
_TEXT	ENDS
PUBLIC	?FindWorkNotChosen@CultureHelpers@@YAHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z ; CultureHelpers::FindWorkNotChosen
; Function compile flags: /Ogtpy
;	COMDAT ?FindWorkNotChosen@CultureHelpers@@YAHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z
_TEXT	SEGMENT
tv229 = 8						; size = 4
_aWorks$ = 8						; size = 4
_aWorksChosen$ = 12					; size = 4
?FindWorkNotChosen@CultureHelpers@@YAHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z PROC ; CultureHelpers::FindWorkNotChosen, COMDAT

; 5929 : 	for (unsigned int iI = 0; iI < aWorks.size(); iI++)

	mov	eax, DWORD PTR _aWorks$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	push	ebx
	mov	ebx, DWORD PTR [eax+4]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	ebp
	push	esi
	sar	edx, 2
	mov	esi, edx
	push	edi
	shr	esi, 31					; 0000001fH
	xor	edi, edi
	add	esi, edx
	mov	DWORD PTR tv229[esp+12], ebx
	je	SHORT $LN2@FindWorkNo

; 5930 : 	{
; 5931 : 		if (find (aWorksChosen.begin(), aWorksChosen.end(), aWorks[iI].m_iGreatWorkIndex) == aWorksChosen.end())

	mov	eax, DWORD PTR _aWorksChosen$[esp+12]
	mov	ebp, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
$LL4@FindWorkNo:
	mov	eax, ebp
	cmp	ebp, ecx
	je	SHORT $LN55@FindWorkNo
	mov	edx, DWORD PTR [ebx]
	npad	5
$LL39@FindWorkNo:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN55@FindWorkNo
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL39@FindWorkNo
$LN55@FindWorkNo:
	cmp	eax, ecx
	je	SHORT $LN56@FindWorkNo
	inc	edi
	add	ebx, 24					; 00000018H
	cmp	edi, esi
	jb	SHORT $LL4@FindWorkNo
$LN2@FindWorkNo:
	pop	edi
	pop	esi
	pop	ebp

; 5934 : 		}
; 5935 : 	}
; 5936 : 	return NO_GREAT_WORK;

	or	eax, -1
	pop	ebx

; 5937 : }

	ret	0
$LN56@FindWorkNo:

; 5932 : 		{
; 5933 : 			return aWorks[iI].m_iGreatWorkIndex;

	mov	ecx, DWORD PTR tv229[esp+12]
	lea	eax, DWORD PTR [edi+edi*2]
	mov	eax, DWORD PTR [ecx+eax*8]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5937 : }

	ret	0
?FindWorkNotChosen@CultureHelpers@@YAHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z ENDP ; CultureHelpers::FindWorkNotChosen
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvGreatWork,22,0,297,0>::~FStaticVector<CvGreatWork,22,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvGreatWork,22,0,297,0>::~FStaticVector<CvGreatWork,22,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	?Free@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAVCvGreatWork@@I@Z ; FStaticVector<CvGreatWork,22,0,297,0>::Free

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvGreatWork,22,0,297,0>::~FStaticVector<CvGreatWork,22,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@2:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::clear
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvGreatWork,22,0,297,0>::GrowSize
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_i$228475 = -24						; size = 4
_pTemp$ = -20						; size = 4
$T246098 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T246176 = 8						; size = 4
_pRet$246104 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvGreatWork,22,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN54@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN54@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+32]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN49@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN49@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebx, DWORD PTR [esi+8]
	cmp	ebx, 22					; 00000016H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$246104[esp+32], edi
	mov	DWORD PTR [esi+8], ebx
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _pRet$246104[esp+32], ecx
	mov	DWORD PTR [esi+8], 22			; 00000016H
	mov	edi, ecx
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR _pTemp$[esp+40], edi
	mov	DWORD PTR _i$228475[esp+40], ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN1@GrowSize
$LL3@GrowSize:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 4
	lea	ebp, DWORD PTR [eax+edi]
	mov	DWORD PTR $T246098[esp+40], ebp
	mov	DWORD PTR __$EHRec$[esp+48], 0
	test	ebp, ebp
	je	SHORT $LN12@GrowSize
	mov	edi, DWORD PTR [esi]
	add	edi, eax
	push	edi
	mov	ecx, ebp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR [edi+28]
	mov	DWORD PTR [ebp+28], edx
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [ebp+32], eax
	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [ebp+36], ecx
	mov	edx, DWORD PTR [edi+40]
	mov	DWORD PTR [ebp+40], edx
	mov	eax, DWORD PTR [edi+44]
	mov	edi, DWORD PTR _pRet$246104[esp+36]
	mov	DWORD PTR [ebp+44], eax
$LN12@GrowSize:
	inc	ebx
	mov	DWORD PTR __$EHRec$[esp+48], -1
	mov	DWORD PTR _i$228475[esp+40], ebx
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize
$LN1@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR $T246176[esp+36], ebx
	test	eax, eax
	jbe	SHORT $LN31@GrowSize
	mov	ebp, eax
$LL33@GrowSize:
	mov	ecx, ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	ebx, 48					; 00000030H
	sub	ebp, 1
	jne	SHORT $LL33@GrowSize
	mov	ebx, DWORD PTR $T246176[esp+36]
$LN31@GrowSize:
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	ebx, ecx
	je	SHORT $LN53@GrowSize
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN53@GrowSize:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;
; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR [esi], edi
	pop	edi
	mov	BYTE PTR [esi+1068], 1
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$228475[ebp]
	imul	eax, 48					; 00000030H
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246098[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvGreatWork,22,0,297,0>::GrowSize
PUBLIC	?_Ufill@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV3@IABV3@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T246205 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$246208 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV3@IABV3@@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$246208[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T246205[esp+12], 0
	mov	eax, DWORD PTR $T246205[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV3@IABV3@@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXPAW4PlayerTypes@@0@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXPAW4PlayerTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXPAW4PlayerTypes@@0@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXPAW4PlayerTypes@@0@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW43@IABW43@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T246233 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$246236 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$246236[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T246233[esp+12], 0
	mov	eax, DWORD PTR $T246233[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkInMyEmpire@@0@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkInMyEmpire@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkInMyEmpire@@0@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkInMyEmpire@@0@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXXZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV3@IABV3@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T246262 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$246265 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV3@IABV3@@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$246265[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T246262[esp+12], 0
	mov	eax, DWORD PTR $T246262[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV3@IABV3@@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXPAW4EraTypes@@0@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXPAW4EraTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXPAW4EraTypes@@0@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXPAW4EraTypes@@0@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW43@IABW43@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T246291 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$246294 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$246294[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T246291[esp+12], 0
	mov	eax, DWORD PTR $T246291[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkBuildingInMyEmpire@@0@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkBuildingInMyEmpire@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkBuildingInMyEmpire@@0@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXPAVCvGreatWorkBuildingInMyEmpire@@0@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@9
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@9:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@9
	pop	esi
$LN13@unchecked_@9:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Umove<enum PlayerTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T246505 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246508 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Umove<enum PlayerTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$246508[esp]
	mov	BYTE PTR $T246505[esp+4], 0
	mov	eax, DWORD PTR $T246505[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Umove<enum PlayerTypes *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Umove<CvGreatWorkInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z
_TEXT	SEGMENT
$T246560 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246563 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Umove<CvGreatWorkInMyEmpire *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$246563[esp]
	mov	BYTE PTR $T246560[esp+4], 0
	mov	eax, DWORD PTR $T246560[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Umove<CvGreatWorkInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Umove<enum EraTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T246615 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246618 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Umove<enum EraTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$246618[esp]
	mov	BYTE PTR $T246615[esp+4], 0
	mov	eax, DWORD PTR $T246615[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Umove<enum EraTypes *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z
_TEXT	SEGMENT
$T246651 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246654 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$246654[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T246651[esp+4], 0
	mov	eax, DWORD PTR $T246651[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Insertion_sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@ZV3@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &),CvGreatWorkBuildingInMyEmpire>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAHPAV2@@Z ; std::_Make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAHPAV2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAHPAV2@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2191 : 	_Diff _Bottom = _Last - _First;

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	push	ebx
	sar	edx, 1
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 2192 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	push	ebp
	push	esi
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	push	edi
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	mov	ebp, DWORD PTR __Pred$[esp+12]
	lea	edi, DWORD PTR [esi+esi*2]
	add	edi, edi
	add	edi, edi
	jmp	SHORT $LN2@Make_heap
	npad	8
$LL21@Make_heap:

; 2191 : 	_Diff _Bottom = _Last - _First;

	mov	ecx, DWORD PTR __First$[esp+12]
$LN2@Make_heap:

; 2193 : 		{	// reheap top half, bottom to top
; 2194 : 		--_Hole;
; 2195 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2196 : 			_Ty(*(_First + _Hole)), _Pred);

	mov	edx, DWORD PTR [edi+ecx-12]
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	sub	edi, 12					; 0000000cH
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [edi+ecx+4]
	push	ebx
	dec	esi
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+ecx+8]
	push	esi
	push	ecx
	mov	DWORD PTR [eax+8], edx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ; std::_Adjust_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 28					; 0000001cH
	test	esi, esi
	jg	SHORT $LL21@Make_heap
$LN1@Make_heap:

; 2197 : 		}
; 2198 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAHPAV2@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@VCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@VCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@VCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2144 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2145 : 		_Ty(*(_Last - 1)), _Pred, _Dist_type(_First));

	mov	ecx, DWORD PTR __Pred$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [eax-12]
	push	0
	push	ecx
	add	eax, -12				; fffffff4H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	push	eax
	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	mov	DWORD PTR [ecx+8], edx
	call	??$_Pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00VCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@ZPAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 32					; 00000020H

; 2146 : 	}

	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@VCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@3
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@3:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@3:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@10
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@10
	pop	esi
$LN13@unchecked_@10:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??0CvGameCulture@@QAE@XZ			; CvGameCulture::CvGameCulture
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvGameCulture@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGameCulture@@QAE@XZ$0
__ehfuncinfo$??0CvGameCulture@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvGameCulture@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvGameCulture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGameCulture@@QAE@XZ PROC				; CvGameCulture::CvGameCulture, COMDAT
; _this$ = ecx

; 105  : {

	push	-1
	push	__ehhandler$??0CvGameCulture@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	xor	edx, edx
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 106  : 	m_CurrentGreatWorks.clear();
; 107  : 
; 108  : 	m_bReportedSomeoneInfluential = false;
; 109  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+4], edx
	mov	BYTE PTR [eax+1072], dl
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGameCulture@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvGreatWork,22,0,297,0>::~FStaticVector<CvGreatWork,22,0,297,0>
__ehhandler$??0CvGameCulture@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvGameCulture@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGameCulture@@QAE@XZ ENDP				; CvGameCulture::CvGameCulture
PUBLIC	??1CvGameCulture@@QAE@XZ			; CvGameCulture::~CvGameCulture
; Function compile flags: /Ogtpy
;	COMDAT ??1CvGameCulture@@QAE@XZ
_TEXT	SEGMENT
??1CvGameCulture@@QAE@XZ PROC				; CvGameCulture::~CvGameCulture, COMDAT
; _this$ = ecx

; 114  : }

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	?Free@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAVCvGreatWork@@I@Z ; FStaticVector<CvGreatWork,22,0,297,0>::Free
	ret	0
??1CvGameCulture@@QAE@XZ ENDP				; CvGameCulture::~CvGameCulture
_TEXT	ENDS
PUBLIC	?ResetDigCompletePlots@CvPlayerCulture@@QAEXXZ	; CvPlayerCulture::ResetDigCompletePlots
; Function compile flags: /Ogtpy
;	COMDAT ?ResetDigCompletePlots@CvPlayerCulture@@QAEXXZ
_TEXT	SEGMENT
?ResetDigCompletePlots@CvPlayerCulture@@QAEXXZ PROC	; CvPlayerCulture::ResetDigCompletePlots, COMDAT
; _this$ = ecx

; 1990 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1991 : 	m_aDigCompletePlots.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN17@ResetDigCo
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN42@ResetDigCo
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN42@ResetDigCo:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN17@ResetDigCo:
	pop	edi
	pop	esi

; 1992 : }

	ret	0
?ResetDigCompletePlots@CvPlayerCulture@@QAEXXZ ENDP	; CvPlayerCulture::ResetDigCompletePlots
_TEXT	ENDS
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN33@operator@5
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@5

; 572  : 				clear();	// new sequence empty, erase existing sequence

	call	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
	pop	ebp
	pop	ebx
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@5:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@5

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@5:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN24@operator@5
	xor	ebx, ebx
	jmp	SHORT $LN25@operator@5
$LN24@operator@5:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN25@operator@5:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@5

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@5:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN28@operator@5

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@operator@5:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	test	al, al
	je	SHORT $LN32@operator@5

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	mov	DWORD PTR [esi+8], eax
$LN32@operator@5:
	pop	ebp
	pop	ebx
$LN33@operator@5:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z ; FStaticVector<CvGreatWork,22,0,297,0>::push_back
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T247485 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z PROC ; FStaticVector<CvGreatWork,22,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [edi+8]
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+32], edi
	mov	BYTE PTR [edi+1068], bl
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvGreatWork,22,0,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [edi+4]
	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 4
	add	esi, DWORD PTR [edi]
	mov	DWORD PTR $T247485[esp+32], esi
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	je	SHORT $LN4@push_back
	mov	ebx, DWORD PTR _element$[esp+28]
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR [esi+32], ecx
	mov	edx, DWORD PTR [ebx+36]
	mov	DWORD PTR [esi+36], edx
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+40], eax
	mov	ecx, DWORD PTR [ebx+44]
	mov	DWORD PTR [esi+44], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [edi+4]

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi+4], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T247485[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z ENDP ; FStaticVector<CvGreatWork,22,0,297,0>::push_back
PUBLIC	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
_TEXT	ENDS
PUBLIC	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
_TEXT	ENDS
PUBLIC	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXXZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@0@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@0@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@4
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@4
	push	ebx
	npad	4
$LL28@erase@4:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@4
	pop	ebx
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@4:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@0@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@0@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@0@Z
_TEXT	SEGMENT
$T247801 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$247805 = 12					; size = 1
$T247803 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@0@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [edi], eax
	cmp	eax, edx
	je	SHORT $LN26@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	BYTE PTR $T247801[esp+8], 0
	mov	ebx, DWORD PTR $T247801[esp+8]
	push	ebx
	mov	ebx, DWORD PTR __Cat$247805[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T247803[esp+16]
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN26@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@0@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@0@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@0@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@6
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@6
	push	ebx
	npad	4
$LL28@erase@6:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@6
	pop	ebx
$LN26@erase@6:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@6:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@0@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::erase
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$228935 = 16					; size = 4
__Tmp$228925 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$228925[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$228925[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$228925[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$228935[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$248190 = 8					; size = 1
__Cat$248118 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$229002 = 12					; size = 4
__Tmp$228992 = 12					; size = 4
__Newvec$228977 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T248187 = 16						; size = 1
$T248115 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@KAXXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4PlayerTypes@@@std@@YAPAW4PlayerTypes@@IPAW41@@Z ; std::_Allocate<enum PlayerTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$228977[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW43@IABW43@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$248118[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T248115[ebp], 0
	mov	ecx, DWORD PTR $T248115[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$228977[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T248187[ebp], 0
	mov	edx, DWORD PTR $T248187[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$248190[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$228977[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4PlayerTypes@@PAW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAPAW4PlayerTypes@@PAW41@00AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PlayerTypes *,enum PlayerTypes *,std::allocator<enum PlayerTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$228977[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$228992[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Umove<enum PlayerTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$228992[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW43@IABW43@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$228992[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z ; std::fill<enum PlayerTypes *,enum PlayerTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$229002[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Umove<enum PlayerTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum PlayerTypes *,enum PlayerTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$229002[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4PlayerTypes@@W41@@std@@YAXPAW4PlayerTypes@@0ABW41@@Z ; std::fill<enum PlayerTypes *,enum PlayerTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
__Tmp$229067 = -44					; size = 24
__Tmp$229057 = -44					; size = 24
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$248426 = 8					; size = 1
__Cat$248353 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$229042 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T248423 = 16						; size = 1
$T248350 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN85@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 178956970				; 0aaaaaaaH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@KAXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Xlen
$LN91@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 178956970				; 0aaaaaaaH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvGreatWorkInMyEmpire@@@std@@YAPAVCvGreatWorkInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkInMyEmpire>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 2
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	edi
	mov	DWORD PTR __Newvec$229042[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV3@IABV3@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$248353[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T248350[ebp], 0
	mov	ecx, DWORD PTR $T248350[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$229042[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$229042[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	BYTE PTR $T248423[ebp], 0
	mov	edx, DWORD PTR $T248423[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$248426[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvGreatWorkInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::allocator<CvGreatWorkInMyEmpire> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$229042[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$229042[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@3
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$229057[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$229057[ebp+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$229057[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$229057[ebp+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$229057[ebp+20], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$229057[ebp+16], edx
	call	??$_Umove@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Umove<CvGreatWorkInMyEmpire *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$229057[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV3@IABV3@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$229057[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ; std::_Fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$229067[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$229067[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	add	edi, edi
	mov	DWORD PTR __Tmp$229067[ebp+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$229067[ebp+12], edx
	mov	edx, DWORD PTR [eax+20]
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$229067[ebp+16], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$229067[ebp+20], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Umove<CvGreatWorkInMyEmpire *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR tv525[ebp]
	push	ebx
	push	eax
	push	ecx
	call	??$_Unchecked_move_backward@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$229067[ebp]
	push	edx
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAVCvGreatWorkInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkInMyEmpire@@0ABV1@@Z ; std::_Fill<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire>
	add	esp, 24					; 00000018H
$LN85@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$248668 = 8					; size = 1
__Cat$248596 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$229150 = 12					; size = 4
__Tmp$229140 = 12					; size = 4
__Newvec$229125 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T248665 = 16						; size = 1
$T248593 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@4
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@4
$LN29@Insert_n@4:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@4

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@KAXXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Xlen
$LN87@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4EraTypes@@@std@@YAPAW4EraTypes@@IPAW41@@Z ; std::_Allocate<enum EraTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$229125[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW43@IABW43@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$248596[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T248593[ebp], 0
	mov	ecx, DWORD PTR $T248593[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$229125[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T248665[ebp], 0
	mov	edx, DWORD PTR $T248665[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$248668[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$229125[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4EraTypes@@PAW41@V?$allocator@W4EraTypes@@@std@@@std@@YAPAW4EraTypes@@PAW41@00AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum EraTypes *,enum EraTypes *,std::allocator<enum EraTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$229125[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@4:
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$229140[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Umove<enum EraTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$229140[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW43@IABW43@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$229140[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z ; std::fill<enum EraTypes *,enum EraTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@4:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$229150[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Umove<enum EraTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum EraTypes *,enum EraTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$229150[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4EraTypes@@W41@@std@@YAXPAW4EraTypes@@0ABW41@@Z ; std::fill<enum EraTypes *,enum EraTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n
PUBLIC	??$_Umove@PAVCvGreatWorkBuildingInMyEmpire@@@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Umove<CvGreatWorkBuildingInMyEmpire *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvGreatWorkBuildingInMyEmpire@@@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV2@00@Z
_TEXT	SEGMENT
$T248746 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$248749 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvGreatWorkBuildingInMyEmpire@@@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV2@00@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Umove<CvGreatWorkBuildingInMyEmpire *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$248749[esp]
	mov	BYTE PTR $T248746[esp+4], 0
	mov	eax, DWORD PTR $T248746[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvGreatWorkBuildingInMyEmpire@@@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV2@00@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Umove<CvGreatWorkBuildingInMyEmpire *>
_TEXT	ENDS
PUBLIC	??$make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2203 : 	{	// make [_First, _Last) into a heap, using _Pred

	push	esi

; 2204 : 	_DEBUG_RANGE(_First, _Last);
; 2205 : 	_DEBUG_POINTER(_Pred);
; 2206 : 	if (1 < _Last - _First)

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jle	SHORT $LN1@make_heap

; 2207 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred,
; 2208 : 			_Dist_type(_First), _Val_type(_First));

	mov	ecx, DWORD PTR __Pred$[esp+4]
	push	0
	push	0
	push	ecx
	push	esi
	push	edi
	call	??$_Make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAHPAV2@@Z ; std::_Make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 20					; 00000014H
$LN1@make_heap:
	pop	edi
	pop	esi

; 2209 : 	}

	ret	0
??$make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2151 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

	push	esi

; 2152 : 	_DEBUG_RANGE(_First, _Last);
; 2153 : 	_DEBUG_POINTER(_Pred);
; 2154 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2155 : 	if (1 < _Last - _First)

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jle	SHORT $LN10@pop_heap

; 2156 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred, _Val_type(_First));

	mov	ecx, DWORD PTR __Pred$[esp+4]
	mov	edx, DWORD PTR [esi-12]
	push	0
	push	ecx
	lea	eax, DWORD PTR [esi-12]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	push	eax
	push	edi
	mov	DWORD PTR [ecx+8], edx
	call	??$_Pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@00VCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@ZPAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 32					; 00000020H
$LN10@pop_heap:

; 2157 : 	}

	pop	edi
	pop	esi
	ret	0
??$pop_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@2
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@2
	pop	ebx
$LN22@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214892 = 16					; size = 4
__Tmp$214882 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@5
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@5
$LN29@Insert_n@5:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@5
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214882[esp+16], edx
	jae	SHORT $LN3@Insert_n@5
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214882[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214882[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@5:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214892[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@5:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@5:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z ; CvGameCulture::CreateGreatWork
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z$1
__ehfuncinfo$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z
_TEXT	SEGMENT
_newGreatWork$ = -60					; size = 48
__$EHRec$ = -12						; size = 12
_eType$ = 8						; size = 4
_eClass$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
_eEra$ = 20						; size = 4
_szCreator$ = 24					; size = 28
?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z PROC ; CvGameCulture::CreateGreatWork, COMDAT
; _this$ = ecx

; 132  : {

	push	-1
	push	__ehhandler$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	mov	esi, ecx

; 133  : 	CvGreatWork newGreatWork;

	lea	ecx, DWORD PTR _newGreatWork$[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR _newGreatWork$[esp+104], -1

; 134  : 	newGreatWork.m_eType = eType;

	mov	eax, DWORD PTR _eType$[esp+64]

; 135  : 	newGreatWork.m_eClassType = eClass;

	mov	ecx, DWORD PTR _eClass$[esp+64]

; 136  : 	newGreatWork.m_eEra = eEra;

	mov	edx, DWORD PTR _eEra$[esp+64]
	mov	DWORD PTR _newGreatWork$[esp+96], eax

; 137  : 	newGreatWork.m_ePlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp+64]
	mov	DWORD PTR _newGreatWork$[esp+100], ecx

; 138  : 	newGreatWork.m_iTurnFounded = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+76], 1
	mov	DWORD PTR _newGreatWork$[esp+108], edx
	mov	DWORD PTR _newGreatWork$[esp+112], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 139  : 	newGreatWork.m_szGreatPersonName = szCreator;

	lea	ecx, DWORD PTR _szCreator$[esp+64]
	push	ecx
	lea	ecx, DWORD PTR _newGreatWork$[esp+72]
	mov	DWORD PTR _newGreatWork$[esp+108], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 140  : 
; 141  : 	int iNumGreatWorks = m_CurrentGreatWorks.size();

	mov	edi, DWORD PTR [esi+4]

; 142  : 
; 143  : 	m_CurrentGreatWorks.push_back(newGreatWork);

	lea	edx, DWORD PTR _newGreatWork$[esp+68]
	push	edx
	mov	ecx, esi
	call	?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z ; FStaticVector<CvGreatWork,22,0,297,0>::push_back

; 144  : 
; 145  : 	return iNumGreatWorks;

	lea	ecx, DWORD PTR _newGreatWork$[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szCreator$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 146  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	44					; 0000002cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z$0:
	lea	ecx, DWORD PTR _szCreator$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z$1:
	lea	ecx, DWORD PTR _newGreatWork$[ebp]
	jmp	??1CvGreatWork@@QAE@XZ
__ehhandler$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z ENDP ; CvGameCulture::CreateGreatWork
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z	; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z$0
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z
_TEXT	SEGMENT
_iEntriesToRead$ = -68					; size = 4
_uiVersion$ = -64					; size = 4
_tempItem$ = -60					; size = 48
__$EHRec$ = -12						; size = 12
_bTempBool$223405 = 8					; size = 1
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z PROC	; operator>>, COMDAT

; 647  : {

	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebp

; 648  : 	uint uiVersion;
; 649  : 
; 650  : 	loadFrom >> uiVersion;

	mov	ebp, DWORD PTR _loadFrom$[esp+68]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+80]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 651  : 
; 652  : 	int iEntriesToRead;
; 653  : 	CvGreatWork tempItem;

	lea	ecx, DWORD PTR _tempItem$[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	or	eax, -1
	mov	DWORD PTR _tempItem$[esp+108], eax
	mov	DWORD PTR _tempItem$[esp+112], eax
	mov	DWORD PTR _tempItem$[esp+116], eax
	mov	DWORD PTR _tempItem$[esp+120], eax
	mov	DWORD PTR _tempItem$[esp+124], eax

; 654  : 
; 655  : 	writeTo.m_CurrentGreatWorks.clear();

	mov	esi, DWORD PTR _writeTo$[esp+76]
	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	test	eax, eax
	jbe	SHORT $LN19@operator@6
	push	ebx
	mov	ebx, eax
$LL21@operator@6:
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	edi, 48					; 00000030H
	sub	ebx, 1
	jne	SHORT $LL21@operator@6
	pop	ebx
$LN19@operator@6:

; 656  : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+80]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR [esi+4], 0
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 657  : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	edi, edi
	cmp	DWORD PTR _iEntriesToRead$[esp+80], edi
	jle	SHORT $LN3@operator@6
$LL5@operator@6:

; 658  : 	{
; 659  : 		loadFrom >> tempItem;

	lea	edx, DWORD PTR _tempItem$[esp+80]
	push	edx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAVCvGreatWork@@@Z ; operator>>
	add	esp, 8

; 660  : 		writeTo.m_CurrentGreatWorks.push_back(tempItem);

	lea	eax, DWORD PTR _tempItem$[esp+80]
	push	eax
	mov	ecx, esi
	call	?push_back@?$FStaticVector@VCvGreatWork@@$0BG@$0A@$0BCJ@$0A@@@QAEIABVCvGreatWork@@@Z ; FStaticVector<CvGreatWork,22,0,297,0>::push_back
	inc	edi
	cmp	edi, DWORD PTR _iEntriesToRead$[esp+80]
	jl	SHORT $LL5@operator@6
$LN3@operator@6:

; 661  : 	}
; 662  : 
; 663  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+80], 2
	jb	SHORT $LN2@operator@6

; 664  : 	{
; 665  : 		bool bTempBool;
; 666  : 		loadFrom >> bTempBool;

	lea	ecx, DWORD PTR _bTempBool$223405[esp+76]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 667  : 		writeTo.SetReportedSomeoneInfluential(bTempBool);

	mov	dl, BYTE PTR _bTempBool$223405[esp+76]
	mov	BYTE PTR [esi+1072], dl

; 668  : 	}
; 669  : 	else

	jmp	SHORT $LN40@operator@6
$LN2@operator@6:

; 670  : 	{
; 671  : 		writeTo.SetReportedSomeoneInfluential(false);

	mov	BYTE PTR [esi+1072], 0
$LN40@operator@6:

; 672  : 	}
; 673  : 
; 674  : 	return loadFrom;

	lea	ecx, DWORD PTR _tempItem$[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 675  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z$0:
	lea	ecx, DWORD PTR _tempItem$[ebp]
	jmp	??1CvGreatWork@@QAE@XZ
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvGameCulture@@@Z ENDP	; operator>>
PUBLIC	?Init@CvPlayerCulture@@QAEXPAVCvPlayer@@@Z	; CvPlayerCulture::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvPlayerCulture@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvPlayerCulture@@QAEXPAVCvPlayer@@@Z PROC		; CvPlayerCulture::Init, COMDAT
; _this$ = ecx

; 770  : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx

; 771  : 
; 772  : 	ResetDigCompletePlots();

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	xor	ebx, ebx
	mov	DWORD PTR [esi+292], eax
	cmp	edi, ecx
	je	SHORT $LN22@Init
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, ebx
	lea	edx, DWORD PTR [eax*4]
	push	ebp
	lea	ebp, DWORD PTR [edx+edi]
	jle	SHORT $LN47@Init
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN47@Init:
	mov	DWORD PTR [esi+8], ebp
	pop	ebp
$LN22@Init:

; 773  : 
; 774  : 	m_iLastTurnLifetimeCulture = 0;

	mov	DWORD PTR [esi+16], ebx

; 775  : 	m_iOpinionUnhappiness = 0;

	mov	DWORD PTR [esi+216], ebx
	lea	eax, DWORD PTR [esi+108]
	mov	ecx, 22					; 00000016H
$LL3@Init:

; 776  : 
; 777  : 	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
; 778  : 	{
; 779  : 		m_aiCulturalInfluence[iI] = 0;

	mov	DWORD PTR [eax-88], ebx

; 780  : 		m_aiLastTurnCulturalInfluence[iI] = 0;

	mov	DWORD PTR [eax], ebx
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL3@Init

; 781  : 	}
; 782  : 
; 783  : 	m_bReportedTwoCivsAway = false;
; 784  : 	m_bReportedOneCivAway = false;
; 785  : 
; 786  : 	m_iSwappableWritingIndex  = -1;

	or	eax, -1
	pop	edi
	mov	BYTE PTR [esi+196], bl
	mov	BYTE PTR [esi+197], bl
	mov	DWORD PTR [esi+276], eax

; 787  : 	m_iSwappableArtIndex      = -1;

	mov	DWORD PTR [esi+280], eax

; 788  : 	m_iSwappableArtifactIndex = -1;

	mov	DWORD PTR [esi+284], eax

; 789  : 	m_iSwappableMusicIndex    = -1;

	mov	DWORD PTR [esi+288], eax

; 790  : 
; 791  : 	m_iTurnIdeologySwitch = -1;

	mov	DWORD PTR [esi+208], eax
	pop	esi
	pop	ebx

; 792  : }

	ret	4
?Init@CvPlayerCulture@@QAEXPAVCvPlayer@@@Z ENDP		; CvPlayerCulture::Init
_TEXT	ENDS
PUBLIC	?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z ; CvPlayerCulture::DoArchaeologyChoice
EXTRN	?SetNumArchaeologyChoices@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::SetNumArchaeologyChoices
EXTRN	?GetNumArchaeologyChoices@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumArchaeologyChoices
EXTRN	?changeJONSCulture@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeJONSCulture
EXTRN	?ChangeNegativeArchaeologyPoints@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeNegativeArchaeologyPoints
EXTRN	?ChangeNumLandmarksBuiltForMe@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeNumLandmarksBuiltForMe
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?ChangeFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z:PROC ; CvMinorCivAI::ChangeFriendshipWithMajor
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z$2
__ehfuncinfo$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z
_TEXT	SEGMENT
_pHousingCity$ = -156					; size = 4
_eArtArtifactSlot$225607 = -156				; size = 4
_eBuildingToHouse$ = -152				; size = 4
_eWritingSlot$225608 = -152				; size = 4
_iSlot$ = -148						; size = 4
_eClass$225610 = -144					; size = 4
_pPlot$ = -144						; size = 4
_pCulture$ = -140					; size = 4
$T249542 = -136						; size = 4
$T249539 = -136						; size = 4
$T249536 = -136						; size = 4
$T249540 = -132						; size = 20
$T249541 = -112						; size = 20
$T249538 = -92						; size = 20
$T249543 = -72						; size = 20
$T249537 = -52						; size = 20
$T249544 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_eChoice$ = 8						; size = 4
?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z PROC ; CvPlayerCulture::DoArchaeologyChoice, COMDAT
; _this$ = ecx

; 2164 : {

	push	-1
	push	__ehhandler$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 2165 : 	CvGameCulture *pCulture = GC.getGame().GetGameCulture();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	DWORD PTR _pCulture$[esp+172], eax

; 2166 : 	BuildingClassTypes eBuildingToHouse;
; 2167 : #ifdef AUI_WARNING_FIXES
; 2168 : 	uint iSlot;
; 2169 : #else
; 2170 : 	int iSlot;
; 2171 : #endif
; 2172 : 	CvCity *pHousingCity;
; 2173 : 	CvPlot *pPlot;
; 2174 : 	CvUnit *pUnit = GetNextDigCompleteArchaeologist(&pPlot);

	lea	eax, DWORD PTR _pPlot$[esp+172]
	push	eax
	mov	ecx, ebx
	call	?GetNextDigCompleteArchaeologist@CvPlayerCulture@@QBEPAVCvUnit@@PAPAVCvPlot@@@Z ; CvPlayerCulture::GetNextDigCompleteArchaeologist
	mov	edi, eax

; 2175 : 	if (pUnit)

	test	edi, edi
	je	$LN18@DoArchaeol

; 2176 : 	{
; 2177 : 		GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	mov	DWORD PTR _eArtArtifactSlot$225607[esp+172], eax

; 2178 : 		GreatWorkSlotType eWritingSlot = CvTypes::getGREAT_WORK_SLOT_LITERATURE();

	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE

; 2179 : 		GreatWorkType eGreatArtifact = CultureHelpers::GetArtifact(pPlot);

	mov	esi, DWORD PTR _pPlot$[esp+172]
	push	esi
	mov	DWORD PTR _eWritingSlot$225608[esp+176], eax
	call	?GetArtifact@CultureHelpers@@YA?AW4GreatWorkType@@PAVCvPlot@@@Z ; CultureHelpers::GetArtifact
	add	esp, 4

; 2180 : 		GreatWorkClass eClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ARTIFACT");

	push	0
	push	OFFSET $SG225612
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eClass$225610[esp+172], eax

; 2181 : 
; 2182 : 		switch (eChoice)

	mov	eax, DWORD PTR _eChoice$[esp+168]
	dec	eax
	cmp	eax, 4
	ja	$LN138@DoArchaeol
	jmp	DWORD PTR $LN143@DoArchaeol[eax*4]
$LN14@DoArchaeol:

; 2183 : 		{
; 2184 : 		case ARCHAEOLOGY_DO_NOTHING:
; 2185 : 			break;
; 2186 : 		case ARCHAEOLOGY_LANDMARK:
; 2187 : 			{
; 2188 : 				ImprovementTypes eLandmarkImprovement = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_LANDMARK");

	push	0
	push	OFFSET $SG225621
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2189 : 				if (eLandmarkImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	$LN138@DoArchaeol

; 2190 : 				{
; 2191 : 					pPlot->setImprovementType(eLandmarkImprovement, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebx+292]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	push	eax
	mov	ecx, esi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 2192 : 					pUnit->kill(true);

	push	-1
	push	1
	mov	ecx, edi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 2193 : 
; 2194 : 					if (pPlot->getOwner() != NO_PLAYER)

	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	$LN138@DoArchaeol

; 2195 : 					{
; 2196 : 						CvPlayer &kOwner = GET_PLAYER(pPlot->getOwner());

	movsx	edi, al
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2197 : 
; 2198 : 						// City-state owned territory?
; 2199 : 						if (kOwner.isMinorCiv())

	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN11@DoArchaeol

; 2200 : 						{
; 2201 : 							int iFriendship = GC.getLANDMARK_MINOR_FRIENDSHIP_CHANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7120

; 2202 : 							kOwner.GetMinorCivAI()->ChangeFriendshipWithMajor(m_pPlayer->GetID(), iFriendship);

	mov	ecx, DWORD PTR [ebx+292]
	mov	ecx, DWORD PTR [ecx+44]
	push	0
	push	eax
	push	ecx
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?ChangeFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::ChangeFriendshipWithMajor
	jmp	$LN138@DoArchaeol
$LN11@DoArchaeol:

; 2203 : 						}
; 2204 : 
; 2205 : 						// AI major civ owned territory?
; 2206 : 						else if (!kOwner.isHuman())

	mov	ecx, edi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN138@DoArchaeol

; 2207 : 						{
; 2208 : 							kOwner.GetDiplomacyAI()->ChangeNumLandmarksBuiltForMe(m_pPlayer->GetID(), 1);

	mov	edx, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [edx+44]
	push	1
	push	eax
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNumLandmarksBuiltForMe@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNumLandmarksBuiltForMe

; 2209 : 						}
; 2210 : 					}
; 2211 : 				}
; 2212 : 			}
; 2213 : 			break;

	jmp	$LN138@DoArchaeol
$LN8@DoArchaeol:

; 2214 : 		case ARCHAEOLOGY_ARTIFACT_PLAYER1:
; 2215 : 			{
; 2216 : 				if (pPlot->getOwner() != pUnit->getOwner() && pPlot->getOwner() != NO_PLAYER)

	mov	cl, BYTE PTR [esi+4]
	mov	edx, DWORD PTR [edi+40]
	movsx	eax, cl
	cmp	eax, edx
	je	SHORT $LN7@DoArchaeol
	cmp	cl, -1
	je	SHORT $LN7@DoArchaeol

; 2217 : 				{
; 2218 : 					GET_PLAYER(pPlot->getOwner()).GetDiplomacyAI()->ChangeNegativeArchaeologyPoints(pUnit->getOwner(), 10);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	10					; 0000000aH
	push	edx
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNegativeArchaeologyPoints@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNegativeArchaeologyPoints
$LN7@DoArchaeol:

; 2219 : 				}
; 2220 : 				pHousingCity = m_pPlayer->GetCulture()->GetClosestAvailableGreatWorkSlot(pUnit->getX(),pUnit->getY(), eArtArtifactSlot, &eBuildingToHouse, &iSlot);

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	lea	edx, DWORD PTR _iSlot$[esp+172]
	push	edx
	lea	edx, DWORD PTR _eBuildingToHouse$[esp+176]
	push	edx
	mov	edx, DWORD PTR _eArtArtifactSlot$225607[esp+180]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvPlayerCulture::GetClosestAvailableGreatWorkSlot

; 2221 : 				int iGWindex = 	pCulture->CreateGreatWork(eGreatArtifact, eClass, pPlot->GetArchaeologicalRecord().m_ePlayer1, pPlot->GetArchaeologicalRecord().m_eEra, "");

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T249536[esp+200], esp
	push	OFFSET $SG225635
	mov	DWORD PTR _pHousingCity$[esp+204], eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	eax, DWORD PTR $T249537[esp+200]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+212], 0
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T249538[esp+204]
	push	edx
	mov	ecx, esi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+8]
$LN141@DoArchaeol:
	mov	ecx, DWORD PTR _eClass$225610[esp+204]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pCulture$[esp+212]
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z ; CvGameCulture::CreateGreatWork

; 2222 : 				pHousingCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingToHouse, iSlot, iGWindex);

	mov	edx, DWORD PTR _iSlot$[esp+172]
	mov	ecx, DWORD PTR _pHousingCity$[esp+172]
	push	eax
	mov	eax, DWORD PTR _eBuildingToHouse$[esp+176]
	push	edx
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork

; 2223 : 				pPlot->setImprovementType(NO_IMPROVEMENT);
; 2224 : 				pUnit->kill(true);
; 2225 : 			}
; 2226 : 			break;

	jmp	$LN140@DoArchaeol
$LN6@DoArchaeol:

; 2227 : 		case ARCHAEOLOGY_ARTIFACT_PLAYER2:
; 2228 : 			{
; 2229 : 				if (pPlot->getOwner() != pUnit->getOwner() && pPlot->getOwner() != NO_PLAYER)

	mov	cl, BYTE PTR [esi+4]
	mov	edx, DWORD PTR [edi+40]
	movsx	eax, cl
	cmp	eax, edx
	je	SHORT $LN5@DoArchaeol
	cmp	cl, -1
	je	SHORT $LN5@DoArchaeol

; 2230 : 				{
; 2231 : 					GET_PLAYER(pPlot->getOwner()).GetDiplomacyAI()->ChangeNegativeArchaeologyPoints(pUnit->getOwner(), 10);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	10					; 0000000aH
	push	edx
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNegativeArchaeologyPoints@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNegativeArchaeologyPoints
$LN5@DoArchaeol:

; 2232 : 				}
; 2233 : 				pHousingCity = m_pPlayer->GetCulture()->GetClosestAvailableGreatWorkSlot(pUnit->getX(),pUnit->getY(), eArtArtifactSlot, &eBuildingToHouse, &iSlot);

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	lea	edx, DWORD PTR _iSlot$[esp+172]
	push	edx
	lea	edx, DWORD PTR _eBuildingToHouse$[esp+176]
	push	edx
	mov	edx, DWORD PTR _eArtArtifactSlot$225607[esp+180]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvPlayerCulture::GetClosestAvailableGreatWorkSlot

; 2234 : 				int iGWindex = 	pCulture->CreateGreatWork(eGreatArtifact, eClass, pPlot->GetArchaeologicalRecord().m_ePlayer2, pPlot->GetArchaeologicalRecord().m_eEra, "");

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T249539[esp+200], esp
	push	OFFSET $SG225642
	mov	DWORD PTR _pHousingCity$[esp+204], eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	eax, DWORD PTR $T249540[esp+200]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+212], 1
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T249541[esp+204]
	push	edx
	mov	ecx, esi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+12]

; 2235 : 				pHousingCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingToHouse, iSlot, iGWindex);
; 2236 : 				pPlot->setImprovementType(NO_IMPROVEMENT);
; 2237 : 				pUnit->kill(true);
; 2238 : 			}
; 2239 : 			break;

	jmp	$LN141@DoArchaeol
$LN4@DoArchaeol:

; 2240 : 
; 2241 : 		case ARCHAEOLOGY_ARTIFACT_WRITING:
; 2242 : 			{
; 2243 : 				if (pPlot->getOwner() != pUnit->getOwner() && pPlot->getOwner() != NO_PLAYER)

	mov	cl, BYTE PTR [esi+4]
	mov	edx, DWORD PTR [edi+40]
	movsx	eax, cl
	cmp	eax, edx
	je	SHORT $LN3@DoArchaeol
	cmp	cl, -1
	je	SHORT $LN3@DoArchaeol

; 2244 : 				{
; 2245 : 					GET_PLAYER(pPlot->getOwner()).GetDiplomacyAI()->ChangeNegativeArchaeologyPoints(pUnit->getOwner(), 10);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	10					; 0000000aH
	push	edx
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNegativeArchaeologyPoints@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNegativeArchaeologyPoints
$LN3@DoArchaeol:

; 2246 : 				}
; 2247 : 				pHousingCity = m_pPlayer->GetCulture()->GetClosestAvailableGreatWorkSlot(pUnit->getX(),pUnit->getY(), eWritingSlot, &eBuildingToHouse, &iSlot);

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	lea	edx, DWORD PTR _iSlot$[esp+172]
	push	edx
	lea	edx, DWORD PTR _eBuildingToHouse$[esp+176]
	push	edx
	mov	edx, DWORD PTR _eWritingSlot$225608[esp+180]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+292]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetClosestAvailableGreatWorkSlot@CvPlayerCulture@@QBEPAVCvCity@@HHW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvPlayerCulture::GetClosestAvailableGreatWorkSlot

; 2248 : 				int iGWindex = 	pCulture->CreateGreatWork(eGreatArtifact, (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_LITERATURE"), pPlot->GetArchaeologicalRecord().m_ePlayer1, pPlot->GetArchaeologicalRecord().m_eEra, "");

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T249542[esp+200], esp
	push	OFFSET $SG225650
	mov	DWORD PTR _pHousingCity$[esp+204], eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	eax, DWORD PTR $T249543[esp+200]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+212], 2
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T249544[esp+204]
	push	edx
	mov	ecx, esi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+8]
	push	eax
	push	0
	push	OFFSET $SG225651
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pCulture$[esp+208]
	push	eax
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	?CreateGreatWork@CvGameCulture@@QAEHW4GreatWorkType@@W4GreatWorkClass@@W4PlayerTypes@@W4EraTypes@@VCvString@@@Z ; CvGameCulture::CreateGreatWork

; 2249 : 				pHousingCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingToHouse, iSlot, iGWindex);

	mov	ecx, DWORD PTR _iSlot$[esp+172]
	mov	edx, DWORD PTR _eBuildingToHouse$[esp+172]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pHousingCity$[esp+180]
	push	edx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork
	jmp	SHORT $LN140@DoArchaeol
$LN2@DoArchaeol:

; 2250 : 				pPlot->setImprovementType(NO_IMPROVEMENT);
; 2251 : 				pUnit->kill(true);
; 2252 : 			}
; 2253 : 			break;
; 2254 : 
; 2255 : 		case ARCHAEOLOGY_CULTURE_BOOST:
; 2256 : 			{
; 2257 : 				if (pPlot->getOwner() != pUnit->getOwner() && pPlot->getOwner() != NO_PLAYER)

	mov	cl, BYTE PTR [esi+4]
	mov	edx, DWORD PTR [edi+40]
	movsx	eax, cl
	cmp	eax, edx
	je	SHORT $LN1@DoArchaeol
	cmp	cl, -1
	je	SHORT $LN1@DoArchaeol

; 2258 : 				{
; 2259 : 					GET_PLAYER(pPlot->getOwner()).GetDiplomacyAI()->ChangeNegativeArchaeologyPoints(pUnit->getOwner(), 10);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	10					; 0000000aH
	push	edx
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNegativeArchaeologyPoints@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNegativeArchaeologyPoints
$LN1@DoArchaeol:

; 2260 : 				}
; 2261 : 
; 2262 : 				// Culture boost based on 8 previous turns; same as GREAT_WRITER; move to XML?
; 2263 : 				int iValue = m_pPlayer->GetCultureYieldFromPreviousTurns(GC.getGame().getGameTurn(), 8 /*iPreviousTurnsToCount */);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	8
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [ebx+292]
	push	eax
	call	?GetCultureYieldFromPreviousTurns@CvPlayer@@QAEHHH@Z ; CvPlayer::GetCultureYieldFromPreviousTurns

; 2264 : 
; 2265 : 				// Modify based on game speed
; 2266 : 				iValue *= GC.getGame().getGameSpeedInfo().getCulturePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, eax
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	mov	ecx, eax
	imul	ecx, ebp

; 2267 : 				iValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 2268 : 
; 2269 : 				m_pPlayer->changeJONSCulture(iValue);

	mov	ecx, DWORD PTR [ebx+292]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	call	?changeJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::changeJONSCulture
$LN140@DoArchaeol:

; 2270 : 
; 2271 : 				pPlot->setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, esi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 2272 : 				pUnit->kill(true);

	push	-1
	push	1
	mov	ecx, edi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN138@DoArchaeol:

; 2273 : 			}
; 2274 : 			break;
; 2275 : 		}
; 2276 : 
; 2277 : 		m_pPlayer->SetNumArchaeologyChoices(m_pPlayer->GetNumArchaeologyChoices() - 1);

	mov	ecx, DWORD PTR [ebx+292]
	call	?GetNumArchaeologyChoices@CvPlayer@@QBEHXZ ; CvPlayer::GetNumArchaeologyChoices
	mov	ecx, DWORD PTR [ebx+292]
	dec	eax
	push	eax
	call	?SetNumArchaeologyChoices@CvPlayer@@QAEXH@Z ; CvPlayer::SetNumArchaeologyChoices

; 2278 : 		m_pPlayer->GetCulture()->RemoveDigCompletePlot(pPlot);

	mov	ecx, DWORD PTR [ebx+292]
	push	esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?RemoveDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ; CvPlayerCulture::RemoveDigCompletePlot
$LN18@DoArchaeol:

; 2279 : 	}
; 2280 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+172]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 156				; 0000009cH
	ret	4
	npad	2
$LN143@DoArchaeol:
	DD	$LN14@DoArchaeol
	DD	$LN8@DoArchaeol
	DD	$LN6@DoArchaeol
	DD	$LN2@DoArchaeol
	DD	$LN4@DoArchaeol
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z$0:
	mov	ecx, DWORD PTR $T249536[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z$1:
	mov	ecx, DWORD PTR $T249539[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z$2:
	mov	ecx, DWORD PTR $T249542[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z ENDP ; CvPlayerCulture::DoArchaeologyChoice
PUBLIC	??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@6:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear@4
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear@4
	push	edi
$LL42@clear@4:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear@4
	pop	edi
$LN40@clear@4:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear@4:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T250090 = -4						; size = 1
$T250092 = -4						; size = 1
__Cat$250095 = -4					; size = 1
?clear@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXXZ PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx
	push	esi
	mov	esi, ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN15@clear@5
	mov	BYTE PTR $T250090[esp+8], 0
	mov	edx, DWORD PTR $T250090[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$250095[esp+12]
	push	edx
	mov	edx, DWORD PTR $T250092[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN15@clear@5:
	pop	esi

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear@6
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear@6
	push	edi
$LL42@clear@6:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear@6
	pop	edi
$LN40@clear@6:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear@6:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@ABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@ABW4PlayerTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@ABW4PlayerTypes@@@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@V?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@ABW4PlayerTypes@@@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@ABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@ABVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@ABVCvGreatWorkInMyEmpire@@@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@IABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@ABVCvGreatWorkInMyEmpire@@@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@ABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@ABW4EraTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@ABW4EraTypes@@@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@V?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@ABW4EraTypes@@@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
__Tmp$228872 = -32					; size = 12
__Tmp$228862 = -32					; size = 12
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$250715 = 8					; size = 1
__Cat$250643 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$228847 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T250712 = 16						; size = 1
$T250640 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@6
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@6
$LN29@Insert_n@6:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@6:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@6

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 357913941				; 15555555H
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@KAXXZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Xlen
$LN87@Insert_n@6:
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@6:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvGreatWorkBuildingInMyEmpire@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@IPAV1@@Z ; std::_Allocate<CvGreatWorkBuildingInMyEmpire>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 1
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$228847[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV3@IABV3@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$250643[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T250640[ebp], 0
	mov	ecx, DWORD PTR $T250640[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$228847[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$228847[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T250712[ebp], 0
	mov	edx, DWORD PTR $T250712[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$250715[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *,std::allocator<CvGreatWorkBuildingInMyEmpire> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$228847[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$228847[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@6:
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@6
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$228862[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$228862[ebp+8], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$228862[ebp+4], edx
	call	??$_Umove@PAVCvGreatWorkBuildingInMyEmpire@@@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Umove<CvGreatWorkBuildingInMyEmpire *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$228862[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV3@IABV3@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$228862[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z ; std::fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@6:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$228872[ebp+8], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$228872[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$228872[ebp+4], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvGreatWorkBuildingInMyEmpire@@@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkBuildingInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Umove<CvGreatWorkBuildingInMyEmpire *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvGreatWorkBuildingInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkBuildingInMyEmpire@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$228872[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$fill@PAVCvGreatWorkBuildingInMyEmpire@@V1@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@0ABV1@@Z ; std::fill<CvGreatWorkBuildingInMyEmpire *,CvGreatWorkBuildingInMyEmpire>
	add	esp, 24					; 00000018H
$LN1@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Insert_n
PUBLIC	??$_Sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::_Sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2233 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last$[esp+8]
	mov	edx, esi
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	push	edi
	jle	SHORT $LN1@Sort_heap
	mov	ebp, DWORD PTR __Pred$[esp+12]
$LN72@Sort_heap:

; 2234 : 		std::pop_heap(_First, _Last, _Pred);

	mov	edi, DWORD PTR [esi-8]
	mov	ebx, DWORD PTR [esi-4]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [esi-12]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR [edx], esi
	sub	eax, ecx
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [edx+8], ebx
	mov	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	0
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@HHVCvGreatWorkBuildingInMyEmpire@@P6A_NABV2@2@Z@Z ; std::_Adjust_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	mov	esi, DWORD PTR __Last$[esp+40]
	mov	ecx, DWORD PTR __First$[esp+40]
	sub	esi, 12					; 0000000cH
	mov	edx, esi
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esp, 28					; 0000001cH
	cmp	eax, 1
	mov	DWORD PTR __Last$[esp+12], esi
	jg	SHORT $LN72@Sort_heap
$LN1@Sort_heap:

; 2235 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::_Sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@5
	xor	esi, esi
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@5:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@2:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@2
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
_TEXT	ENDS
PUBLIC	??4?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN79@operator@7
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@7

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	edx, ecx
	je	SHORT $LN80@operator@7
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN53@operator@7
	npad	1
$LL55@operator@7:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL55@operator@7
$LN53@operator@7:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	DWORD PTR [esi+8], edx
$LN80@operator@7:
	pop	ebp
	pop	ebx
$LN79@operator@7:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@7:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@7

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum PlayerTypes *,enum PlayerTypes *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@7:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN68@operator@7
	xor	ebx, ebx
	jmp	SHORT $LN69@operator@7
$LN68@operator@7:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN69@operator@7:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@7

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAW4PlayerTypes@@PAW41@@stdext@@YAPAW4PlayerTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum PlayerTypes *,enum PlayerTypes *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ucopy<enum PlayerTypes *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@7:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN72@operator@7

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@operator@7:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Buy
	test	al, al
	je	$LN80@operator@7

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAW4PlayerTypes@@@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEPAW4PlayerTypes@@PAW42@00@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Ucopy<enum PlayerTypes *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator=
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T251633 = -4						; size = 1
__Cat$251636 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z PROC ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$251636[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T251633[esp+12], 0
	mov	eax, DWORD PTR $T251633[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ENDP ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back
_TEXT	ENDS
PUBLIC	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T251958 = 8						; size = 1
__Cat$251963 = 8					; size = 1
$T251960 = 8						; size = 1
$T251929 = 8						; size = 1
__Cat$251934 = 8					; size = 1
$T251931 = 8						; size = 1
__Right$ = 8						; size = 4
??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN78@operator@8

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	ebp
	sar	edx, 2
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	jne	SHORT $LN8@operator@8

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	$LN79@operator@8
	mov	BYTE PTR $T251929[esp+8], 0
	mov	edx, DWORD PTR $T251929[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$251934[esp+12]
	push	edx
	mov	edx, DWORD PTR $T251931[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@8:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebp, ecx
	ja	SHORT $LN6@operator@8

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	BYTE PTR $T251958[esp+12], 0
	mov	eax, DWORD PTR $T251958[esp+12]
	mov	ecx, DWORD PTR __Cat$251963[esp+12]
	mov	edx, DWORD PTR $T251960[esp+12]
	push	eax
	mov	eax, DWORD PTR [edi+8]
	push	ecx
	push	edx
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??$_Copy_opt@PAVCvGreatWorkInMyEmpire@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *,std::random_access_iterator_tag>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [esi+4]
	sar	edx, 2
	add	esp, 24					; 00000018H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	ebx
	lea	eax, DWORD PTR [eax+eax*2]
	pop	ebp
	lea	edx, DWORD PTR [ecx+eax*8]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@8:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ebx, ebx
	jne	SHORT $LN69@operator@8
	xor	eax, eax
	jmp	SHORT $LN70@operator@8
$LN69@operator@8:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN70@operator@8:
	cmp	ebp, eax
	ja	SHORT $LN4@operator@8

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ebp, DWORD PTR [eax+ecx*8]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ebx
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvGreatWorkInMyEmpire@@PAV1@@stdext@@YAPAVCvGreatWorkInMyEmpire@@PAV1@00@Z ; stdext::unchecked_copy<CvGreatWorkInMyEmpire *,CvGreatWorkInMyEmpire *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	edx
	push	eax
	push	ebp
	mov	ecx, esi
	call	??$_Ucopy@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ucopy<CvGreatWorkInMyEmpire *>
	pop	ebx
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@8:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN73@operator@8

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN73@operator@8:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	ecx, esi
	call	?_Buy@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAE_NI@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Buy
	test	al, al
	je	SHORT $LN77@operator@8

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Ucopy@PAVCvGreatWorkInMyEmpire@@@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@IAEPAVCvGreatWorkInMyEmpire@@PAV2@00@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::_Ucopy<CvGreatWorkInMyEmpire *>
	mov	DWORD PTR [esi+8], eax
$LN77@operator@8:
	pop	ebx
$LN79@operator@8:
	pop	ebp
$LN78@operator@8:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z
_TEXT	SEGMENT
$T252036 = -4						; size = 1
__Cat$252040 = 8					; size = 1
$T252007 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z PROC ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@4
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@4:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$252040[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T252036[esp+16], 0
	mov	ecx, DWORD PTR $T252036[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvGreatWorkInMyEmpire@@IV1@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkInMyEmpire *,unsigned int,CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
	add	esp, 24					; 00000018H
	add	edi, 24					; 00000018H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T252007[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@2@ABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ENDP ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
_TEXT	ENDS
PUBLIC	??4?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN79@operator@9
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@9

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	edx, ecx
	je	SHORT $LN80@operator@9
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN53@operator@9
	npad	1
$LL55@operator@9:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL55@operator@9
$LN53@operator@9:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	DWORD PTR [esi+8], edx
$LN80@operator@9:
	pop	ebp
	pop	ebx
$LN79@operator@9:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@9:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@9

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum EraTypes *,enum EraTypes *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@9:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN68@operator@9
	xor	ebx, ebx
	jmp	SHORT $LN69@operator@9
$LN68@operator@9:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN69@operator@9:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@9

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAW4EraTypes@@PAW41@@stdext@@YAPAW4EraTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum EraTypes *,enum EraTypes *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ucopy<enum EraTypes *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@9:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN72@operator@9

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@operator@9:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Buy
	test	al, al
	je	$LN80@operator@9

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAW4EraTypes@@@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEPAW4EraTypes@@PAW42@00@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Ucopy<enum EraTypes *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator=
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z
_TEXT	SEGMENT
$T252352 = -4						; size = 1
__Cat$252355 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z PROC ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@5
	xor	eax, eax
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@5:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$252355[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T252352[esp+12], 0
	mov	eax, DWORD PTR $T252352[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ENDP ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@ABVCvGreatWorkBuildingInMyEmpire@@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@ABVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@ABVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@6
	xor	esi, esi
	jmp	SHORT $LN4@insert@6
$LN3@insert@6:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@6:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@IABVCvGreatWorkBuildingInMyEmpire@@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@ABVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::insert
_TEXT	ENDS
PUBLIC	??$sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 2241 : 	_DEBUG_RANGE(_First, _Last);
; 2242 : 	_DEBUG_POINTER(_Pred);
; 2243 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2244 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred);

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	??$_Sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 12					; 0000000cH

; 2245 : 	}

	ret	0
??$sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@6
	xor	eax, eax
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@6:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@6
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z ; CvPlayerCulture::FillBuilding
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z$2
__ehfuncinfo$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
_iCountSlots$ = -64					; size = 4
_aWorksChosen$ = -60					; size = 16
_tempWorks$225272 = -44					; size = 16
_worksToConsider$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_buildingIt$ = 8					; size = 4
_works1$ = 12						; size = 4
_works2$ = 16						; size = 4
?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z PROC ; CvPlayerCulture::FillBuilding, COMDAT
; _this$ = ecx

; 1807 : {

	push	-1
	push	__ehhandler$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H

; 1808 : 	CvBuildingEntry *pkEntry = GC.getBuildingInfo(buildingIt->m_eBuilding);

	mov	eax, DWORD PTR _buildingIt$[esp+64]
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+80], ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 1809 : 	if (!pkEntry)

	xor	edi, edi
	cmp	eax, edi
	jne	SHORT $LN17@FillBuildi
$LN585@FillBuildi:

; 1810 : 	{
; 1811 : 		return false;

	xor	al, al

; 1885 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
$LN17@FillBuildi:

; 1812 : 	}
; 1813 : 
; 1814 : 	int iCountSlots = pkEntry->GetGreatWorkCount();

	mov	ecx, eax
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 1815 : 	if (iCountSlots < 1)

	cmp	eax, 1
	mov	DWORD PTR _iCountSlots$[esp+84], eax

; 1816 : 	{
; 1817 : 		return false;

	jl	SHORT $LN585@FillBuildi

; 1818 : 
; 1819 : 	}
; 1820 : 
; 1821 : 	vector<CvGreatWorkInMyEmpire> worksToConsider;

	mov	DWORD PTR _worksToConsider$[esp+88], edi
	mov	DWORD PTR _worksToConsider$[esp+92], edi
	mov	DWORD PTR _worksToConsider$[esp+96], edi

; 1822 : 	vector<int> aWorksChosen;

	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+92], edi
	mov	DWORD PTR _aWorksChosen$[esp+88], edi
	mov	DWORD PTR _aWorksChosen$[esp+92], ebx
	mov	DWORD PTR _aWorksChosen$[esp+96], edi

; 1823 : 
; 1824 : 	worksToConsider = works1;

	mov	edx, DWORD PTR _works1$[esp+80]
	push	edx
	lea	ecx, DWORD PTR _worksToConsider$[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1825 : 	vector<CvGreatWorkInMyEmpire>::const_iterator it;
; 1826 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1827 : 	for (it = works2.begin(); it != works2.end(); ++it)
; 1828 : #else
; 1829 : 	for (it = works2.begin(); it != works2.end(); it++)

	mov	eax, DWORD PTR _works2$[esp+80]
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	cmp	esi, eax
	je	SHORT $LN13@FillBuildi
	npad	2
$LL110@FillBuildi:

; 1830 : #endif
; 1831 : 	{
; 1832 : 		worksToConsider.push_back(*it);

	push	esi
	lea	ecx, DWORD PTR _worksToConsider$[esp+88]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	eax, DWORD PTR _works2$[esp+80]
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LL110@FillBuildi
$LN13@FillBuildi:

; 1833 : 	}
; 1834 : 
; 1835 : 	it = worksToConsider.begin();
; 1836 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1837 : 	for (int iI = 0; iI < iCountSlots && it != worksToConsider.end(); iI++, ++it)
; 1838 : #else
; 1839 : 	for (int iI = 0; iI < iCountSlots && it != worksToConsider.end(); iI++, it++)

	cmp	DWORD PTR _iCountSlots$[esp+84], 0
	mov	esi, DWORD PTR _worksToConsider$[esp+88]
	mov	ebp, esi
	jle	$LN10@FillBuildi
	npad	9
$LL582@FillBuildi:
	cmp	ebp, DWORD PTR _worksToConsider$[esp+92]
	je	$LN10@FillBuildi

; 1840 : #endif
; 1841 : 	{
; 1842 : 		aWorksChosen.push_back(worksToConsider[iI].m_iGreatWorkIndex);

	mov	ecx, DWORD PTR _aWorksChosen$[esp+88]
	test	ecx, ecx
	jne	SHORT $LN154@FillBuildi
	xor	eax, eax
	jmp	SHORT $LN155@FillBuildi
$LN154@FillBuildi:
	mov	eax, DWORD PTR _aWorksChosen$[esp+96]
	sub	eax, ecx
	sar	eax, 2
$LN155@FillBuildi:
	mov	edx, ebx
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN147@FillBuildi
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	mov	DWORD PTR _aWorksChosen$[esp+92], ebx
	jmp	SHORT $LN201@FillBuildi
$LN147@FillBuildi:
	push	esi
	push	1
	push	ebx
	lea	ecx, DWORD PTR _aWorksChosen$[esp+96]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebx, DWORD PTR _aWorksChosen$[esp+92]
$LN201@FillBuildi:

; 1843 : 		MoveWorkIntoSlot(worksToConsider[iI], buildingIt->m_iCityID, buildingIt->m_eBuilding, iI);

	mov	eax, DWORD PTR _buildingIt$[esp+80]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _this$[esp+120]
	mov	DWORD PTR [eax+20], edx
	call	?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z ; CvPlayerCulture::MoveWorkIntoSlot
	inc	edi
	add	esi, 24					; 00000018H
	add	ebp, 24					; 00000018H
	cmp	edi, DWORD PTR _iCountSlots$[esp+84]
	jl	$LL582@FillBuildi
$LN10@FillBuildi:

; 1844 : 	}
; 1845 : 
; 1846 : 	// Remove these works from those to consider later
; 1847 : 	if (aWorksChosen.size() > 0)

	mov	edx, DWORD PTR _aWorksChosen$[esp+88]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	$LN544@FillBuildi

; 1848 : 	{
; 1849 : 		vector<CvGreatWorkInMyEmpire>::iterator it2;
; 1850 : 		vector<CvGreatWorkInMyEmpire> tempWorks;

	xor	edi, edi
	mov	DWORD PTR _tempWorks$225272[esp+88], edi
	mov	DWORD PTR _tempWorks$225272[esp+92], edi
	mov	DWORD PTR _tempWorks$225272[esp+96], edi

; 1851 : 
; 1852 : 		tempWorks.clear();
; 1853 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1854 : 		for (it2 = works1.begin(); it2 != works1.end(); ++it2)
; 1855 : #else
; 1856 : 		for (it2 = works1.begin(); it2 != works1.end(); it2++)

	mov	ebp, DWORD PTR _works1$[esp+80]
	mov	esi, DWORD PTR [ebp+4]
	mov	BYTE PTR __$EHRec$[esp+92], 2
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN6@FillBuildi
$LL313@FillBuildi:

; 1857 : #endif
; 1858 : 		{
; 1859 : 			// Copy it over if not chosen, updating its location
; 1860 : 			if (find(aWorksChosen.begin(), aWorksChosen.end(), it2->m_iGreatWorkIndex) == aWorksChosen.end())

	mov	eax, edx
	cmp	edx, ebx
	je	SHORT $LN580@FillBuildi
	mov	ecx, DWORD PTR [esi]
	npad	1
$LL359@FillBuildi:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN569@FillBuildi
	add	eax, 4
	cmp	eax, ebx
	jne	SHORT $LL359@FillBuildi
	jmp	SHORT $LN580@FillBuildi
$LN569@FillBuildi:
	cmp	eax, ebx
	jne	SHORT $LN7@FillBuildi
$LN580@FillBuildi:

; 1851 : 
; 1852 : 		tempWorks.clear();
; 1853 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1854 : 		for (it2 = works1.begin(); it2 != works1.end(); ++it2)
; 1855 : #else
; 1856 : 		for (it2 = works1.begin(); it2 != works1.end(); it2++)

	lea	ecx, DWORD PTR [esi+12]

; 1861 : 			{
; 1862 : 				GetGreatWorkLocation(it2->m_iGreatWorkIndex, it2->m_iCityID, it2->m_eBuilding, it2->m_iSlot);

	push	ecx
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+8]
	push	edx
	lea	eax, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+100]
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1863 : 				tempWorks.push_back(*it2);

	push	esi
	lea	ecx, DWORD PTR _tempWorks$225272[esp+88]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	edx, DWORD PTR _aWorksChosen$[esp+88]
$LN7@FillBuildi:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL313@FillBuildi

; 1851 : 
; 1852 : 		tempWorks.clear();
; 1853 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1854 : 		for (it2 = works1.begin(); it2 != works1.end(); ++it2)
; 1855 : #else
; 1856 : 		for (it2 = works1.begin(); it2 != works1.end(); it2++)

	mov	edi, DWORD PTR _tempWorks$225272[esp+88]
$LN6@FillBuildi:

; 1864 : 			}
; 1865 : 		}
; 1866 : 		works1 = tempWorks;

	lea	edx, DWORD PTR _tempWorks$225272[esp+84]
	push	edx
	mov	ecx, ebp
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1867 : 
; 1868 : 		tempWorks.clear();

	cmp	edi, DWORD PTR _tempWorks$225272[esp+92]
	je	SHORT $LN413@FillBuildi
	mov	DWORD PTR _tempWorks$225272[esp+92], edi
$LN413@FillBuildi:

; 1869 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1870 : 		for (it2 = works2.begin(); it2 != works2.end(); ++it2)
; 1871 : #else
; 1872 : 		for (it2 = works2.begin(); it2 != works2.end(); it2++)

	mov	ebp, DWORD PTR _works2$[esp+80]
	mov	esi, DWORD PTR [ebp+4]
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN2@FillBuildi
$LL453@FillBuildi:

; 1873 : #endif
; 1874 : 		{
; 1875 : 			// Copy it over if not chosen, updating its location
; 1876 : 			if (find(aWorksChosen.begin(), aWorksChosen.end(), it2->m_iGreatWorkIndex) == aWorksChosen.end())

	mov	eax, DWORD PTR _aWorksChosen$[esp+88]
	cmp	eax, ebx
	je	SHORT $LN581@FillBuildi
	mov	ecx, DWORD PTR [esi]
	npad	1
$LL499@FillBuildi:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN570@FillBuildi
	add	eax, 4
	cmp	eax, ebx
	jne	SHORT $LL499@FillBuildi
	jmp	SHORT $LN581@FillBuildi
$LN570@FillBuildi:
	cmp	eax, ebx
	jne	SHORT $LN3@FillBuildi
$LN581@FillBuildi:

; 1869 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1870 : 		for (it2 = works2.begin(); it2 != works2.end(); ++it2)
; 1871 : #else
; 1872 : 		for (it2 = works2.begin(); it2 != works2.end(); it2++)

	lea	eax, DWORD PTR [esi+12]

; 1877 : 			{
; 1878 : 				GetGreatWorkLocation(it2->m_iGreatWorkIndex, it2->m_iCityID, it2->m_eBuilding, it2->m_iSlot);

	push	eax
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+92]
	lea	edx, DWORD PTR [esi+4]
	push	edx
	push	eax
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1879 : 				tempWorks.push_back(*it2);

	push	esi
	lea	ecx, DWORD PTR _tempWorks$225272[esp+88]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
$LN3@FillBuildi:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL453@FillBuildi

; 1869 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1870 : 		for (it2 = works2.begin(); it2 != works2.end(); ++it2)
; 1871 : #else
; 1872 : 		for (it2 = works2.begin(); it2 != works2.end(); it2++)

	mov	edi, DWORD PTR _tempWorks$225272[esp+88]
$LN2@FillBuildi:

; 1880 : 			}
; 1881 : 		}
; 1882 : 		works2 = tempWorks;

	lea	ecx, DWORD PTR _tempWorks$225272[esp+84]
	push	ecx
	mov	ecx, ebp
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1883 : 	}

	test	edi, edi
	je	SHORT $LN583@FillBuildi
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN583@FillBuildi:
	mov	edx, DWORD PTR _aWorksChosen$[esp+88]
$LN544@FillBuildi:

; 1884 : 	return true;

	test	edx, edx
	je	SHORT $LN551@FillBuildi
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN551@FillBuildi:
	mov	eax, DWORD PTR _worksToConsider$[esp+88]
	test	eax, eax
	je	SHORT $LN558@FillBuildi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN558@FillBuildi:

; 1885 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z$0:
	lea	ecx, DWORD PTR _worksToConsider$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z$1:
	lea	ecx, DWORD PTR _aWorksChosen$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z$2:
	lea	ecx, DWORD PTR _tempWorks$225272[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__ehhandler$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z:
	mov	eax, OFFSET __ehfuncinfo$?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z ENDP ; CvPlayerCulture::FillBuilding
PUBLIC	?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ; CvPlayerCulture::AddDigCompletePlot
; Function compile flags: /Ogtpy
;	COMDAT ?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z PROC ; CvPlayerCulture::AddDigCompletePlot, COMDAT
; _this$ = ecx

; 1965 : {

	push	esi

; 1966 : 	m_aDigCompletePlots.push_back(pPlot);

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN11@AddDigComp
	xor	eax, eax
	jmp	SHORT $LN12@AddDigComp
$LN11@AddDigComp:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN12@AddDigComp:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax
	pop	edi
	pop	esi
	jae	SHORT $LN4@AddDigComp
	mov	eax, DWORD PTR _pPlot$[esp-4]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 1967 : }

	ret	4

; 1966 : 	m_aDigCompletePlots.push_back(pPlot);

$LN4@AddDigComp:
	lea	eax, DWORD PTR _pPlot$[esp-4]
	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 1967 : }

	ret	4
?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ENDP ; CvPlayerCulture::AddDigCompletePlot
_TEXT	ENDS
PUBLIC	?DoTurn@CvPlayerCulture@@QAEXXZ			; CvPlayerCulture::DoTurn
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?countMajorCivsEverAlive@CvGame@@QBEHXZ:PROC	; CvGame::countMajorCivsEverAlive
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	__imp_??0String@Localization@@QAE@ABV01@@Z:PROC
EXTRN	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z:PROC ; CvGame::isVictoryValid
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoTurn@CvPlayerCulture@@QAEXXZ DD 019930522H
	DD	019H
	DD	FLAT:__unwindtable$?DoTurn@CvPlayerCulture@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoTurn@CvPlayerCulture@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$8
	DD	07H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$9
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$15
	DD	0eH
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$16
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$22
	DD	015H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$23
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$24
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoTurn@CvPlayerCulture@@QAEXXZ
_TEXT	SEGMENT
_bCultureVictoryValid$ = -417				; size = 1
tv2235 = -416						; size = 4
_iNumWorksInBroadcastTowers$225826 = -416		; size = 4
_iBuildingClassLoop$225792 = -416			; size = 4
_iNotifyLoop$225732 = -416				; size = 4
_iNotifyPlayerID$225690 = -416				; size = 4
_iLoop$225787 = -412					; size = 4
_iNotifyLoop$225765 = -412				; size = 4
_iThisTurnInfluentialCivs$ = -412			; size = 4
_kOtherTeam$225666 = -412				; size = 4
_this$ = -408						; size = 4
tv2222 = -404						; size = 4
_pLoopCity$225788 = -404				; size = 4
_iLastTurnInfluentialCivs$ = -404			; size = 4
_iNumSlots$225804 = -400				; size = 4
_iInfluentialCivsForWin$ = -400				; size = 4
$T255056 = -396						; size = 4
_pTargetNotifications$ = -396				; size = 4
_strInfo$ = -392					; size = 28
_aiCityStateArtifact$225786 = -364			; size = 16
_targCloseOneSummary$225750 = -364			; size = 28
_someoneCloseTwoSummary$225723 = -364			; size = 28
_unmetFirstInfluentialInfo$225687 = -364		; size = 28
_strSummary$ = -336					; size = 28
_unmetCloseOneInfo$225762 = -308			; size = 28
_targCloseTwoSummary$225717 = -308			; size = 28
$T255051 = -308						; size = 28
$T255050 = -308						; size = 28
$T255048 = -308						; size = 28
_someoneCloseOneSummary$225756 = -280			; size = 28
_unmetCloseTwoInfo$225729 = -280			; size = 28
_targFirstInfluentialInfo$225681 = -280			; size = 28
_strTemp$225778 = -252					; size = 80
_strTemp$225773 = -252					; size = 80
_strTemp$225745 = -252					; size = 80
_strTemp$225740 = -252					; size = 80
_strTemp$225701 = -252					; size = 80
_targCloseOneInfo$225753 = -172				; size = 80
_someoneCloseTwoInfo$225726 = -172			; size = 80
_someoneFirstInfluentialInfo$225684 = -172		; size = 80
_someoneCloseOneInfo$225759 = -92			; size = 80
_targCloseTwoInfo$225720 = -92				; size = 80
_strTemp$225710 = -92					; size = 80
__$EHRec$ = -12						; size = 12
?DoTurn@CvPlayerCulture@@QAEXXZ PROC			; CvPlayerCulture::DoTurn, COMDAT
; _this$ = ecx

; 2286 : {

	push	-1
	push	__ehhandler$?DoTurn@CvPlayerCulture@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 408				; 00000198H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 2287 : 	int iInfluentialCivsForWin = GC.getGame().GetGameCulture()->GetNumCivsInfluentialForWin();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _this$[esp+436], ebx
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ ; CvGameCulture::GetNumCivsInfluentialForWin

; 2288 : 	int iLastTurnInfluentialCivs = GetNumCivsInfluentialOn();

	mov	ecx, ebx
	mov	DWORD PTR _iInfluentialCivsForWin$[esp+436], eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn

; 2289 : 
; 2290 : 	for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	ebp, ebp
	mov	DWORD PTR _iLastTurnInfluentialCivs$[esp+436], eax
	xor	edi, edi
	lea	esi, DWORD PTR [ebx+20]
	npad	3
$LL69@DoTurn:

; 2291 : 	{
; 2292 : 		// Move over last turn's numbers
; 2293 : 		m_aiLastTurnCulturalInfluence[iLoopPlayer] = m_aiCulturalInfluence[iLoopPlayer];

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+88], eax

; 2294 : 
; 2295 : 		CvPlayer &kOtherPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2296 : 		CvTeam &kOtherTeam = GET_TEAM(kOtherPlayer.getTeam());

	mov	eax, DWORD PTR [ecx+edi+44]
	add	ecx, edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN107@DoTurn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN108@DoTurn
$LN107@DoTurn:
	or	eax, -1
$LN108@DoTurn:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kOtherTeam$225666[esp+436], eax

; 2297 : 		if (iLoopPlayer != m_pPlayer->GetID() && kOtherPlayer.isAlive() && !kOtherPlayer.isMinorCiv() && kOtherTeam.isHasMet(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ebx+292]
	cmp	ebp, DWORD PTR [eax+44]
	je	SHORT $LN68@DoTurn
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN68@DoTurn
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN68@DoTurn
	mov	ecx, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN126@DoTurn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN127@DoTurn
$LN126@DoTurn:
	or	eax, -1
$LN127@DoTurn:
	mov	ecx, DWORD PTR _kOtherTeam$225666[esp+436]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN68@DoTurn

; 2298 : 		{
; 2299 : 			m_aiCulturalInfluence[iLoopPlayer] += GetInfluencePerTurn((PlayerTypes)iLoopPlayer);

	push	ebp
	mov	ecx, ebx
	call	?GetInfluencePerTurn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluencePerTurn
	add	DWORD PTR [esi], eax
$LN68@DoTurn:
	add	edi, 63236				; 0000f704H
	inc	ebp
	add	esi, 4
	cmp	edi, 1391192				; 00153a58H
	jl	$LL69@DoTurn

; 2300 : 		}
; 2301 : 	}
; 2302 : 	
; 2303 : 	DoPublicOpinion();

	mov	ecx, ebx
	call	?DoPublicOpinion@CvPlayerCulture@@QAEXXZ ; CvPlayerCulture::DoPublicOpinion

; 2304 : 
; 2305 : 	CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edi, edi

; 2306 : 	CvString strInfo;

	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	DWORD PTR __$EHRec$[esp+444], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2307 : 	CvNotifications* pTargetNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [ebx+292]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications

; 2308 : 	int iThisTurnInfluentialCivs = GetNumCivsInfluentialOn();

	mov	ecx, ebx
	mov	DWORD PTR _pTargetNotifications$[esp+436], eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn

; 2309 : 
; 2310 : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);

	push	1
	mov	esi, eax
	push	OFFSET $SG225675
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iThisTurnInfluentialCivs$[esp+444], esi
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2311 : 	const bool bCultureVictoryValid = (eVictory == NO_VICTORY || GC.getGame().isVictoryValid(eVictory));

	cmp	eax, -1
	je	SHORT $LN72@DoTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	mov	BYTE PTR _bCultureVictoryValid$[esp+436], 0
	test	al, al
	je	SHORT $LN73@DoTurn
$LN72@DoTurn:
	mov	BYTE PTR _bCultureVictoryValid$[esp+436], 1
$LN73@DoTurn:

; 2312 : 
; 2313 : 	if (iThisTurnInfluentialCivs > 0 && !GC.getGame().GetGameCulture()->GetReportedSomeoneInfluential())

	cmp	esi, edi
	jle	$LN530@DoTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	cmp	BYTE PTR [eax+1072], 0
	jne	$LN530@DoTurn

; 2314 : 	{
; 2315 : 		if(bCultureVictoryValid)

	cmp	BYTE PTR _bCultureVictoryValid$[esp+436], 0
	je	$LN64@DoTurn

; 2316 : 		{//This civilization is the first civ to be influential over another civs.  Notify the masses!
; 2317 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL");

	lea	edx, DWORD PTR $T255048[esp+436]
	push	OFFSET $SG225680
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+440]
	mov	BYTE PTR __$EHRec$[esp+448], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T255048[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2318 : 			CvString							targFirstInfluentialInfo = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL_ACTIVE_PLAYER_TT");

	lea	eax, DWORD PTR _targFirstInfluentialInfo$225681[esp+436]
	push	OFFSET $SG225683
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 2319 : 			Localization::String	someoneFirstInfluentialInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL_TT");

	lea	ecx, DWORD PTR _someoneFirstInfluentialInfo$225684[esp+444]
	push	OFFSET $SG225686
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+460], 3
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z

; 2320 : 			CvString							unmetFirstInfluentialInfo = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_UNMET_INFLUENTIAL_TT");

	lea	edx, DWORD PTR _unmetFirstInfluentialInfo$225687[esp+452]
	push	OFFSET $SG225689
	push	edx
	mov	BYTE PTR __$EHRec$[esp+468], 4
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 24					; 00000018H

; 2321 : 
; 2322 : 			for(int iNotifyPlayerID = 0; iNotifyPlayerID < MAX_MAJOR_CIVS; ++iNotifyPlayerID){

	xor	ebp, ebp
	mov	BYTE PTR __$EHRec$[esp+444], 5
	mov	DWORD PTR _iNotifyPlayerID$225690[esp+436], ebp
	npad	10
$LL63@DoTurn:

; 2323 : 				PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyPlayerID;
; 2324 : 				CvPlayerAI& kNotifyPlayer = GET_PLAYER(eNotifyPlayer);
; 2325 : 
; 2326 : 				if (m_pPlayer->GetID() == eNotifyPlayer){	

	mov	esi, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [esi+292]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ebx, DWORD PTR [eax+ebp]
	cmp	edx, DWORD PTR _iNotifyPlayerID$225690[esp+436]
	jne	SHORT $LN60@DoTurn

; 2327 : 					strInfo = targFirstInfluentialInfo;

	lea	edx, DWORD PTR _targFirstInfluentialInfo$225681[esp+436]
	push	edx

; 2328 : 				}
; 2329 : 				else

	jmp	$LN538@DoTurn
$LN60@DoTurn:

; 2330 : 				{
; 2331 : 					CvTeam& kCurTeam = GET_TEAM(kNotifyPlayer.getTeam());

	mov	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN160@DoTurn
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edi+eax*4]
	jmp	SHORT $LN161@DoTurn
$LN160@DoTurn:
	or	eax, -1
$LN161@DoTurn:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 2332 : 					if(kCurTeam.isHasMet(m_pPlayer->getTeam())){

	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN171@DoTurn
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN172@DoTurn
$LN171@DoTurn:
	or	edx, -1
$LN172@DoTurn:
	push	edx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN58@DoTurn

; 2333 : 						Localization::String strTemp = someoneFirstInfluentialInfo;

	lea	edx, DWORD PTR _someoneFirstInfluentialInfo$225684[esp+436]
	push	edx
	lea	ecx, DWORD PTR _strTemp$225701[esp+440]
	call	DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z

; 2334 : 						strTemp << m_pPlayer->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR __$EHRec$[esp+444], 6
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTemp$225701[esp+440]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 2335 : 						strInfo = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$225701[esp+436]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	test	eax, eax
	je	SHORT $LN179@DoTurn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 2336 : 					}

	lea	ecx, DWORD PTR _strTemp$225701[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 5
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2337 : 					else

	jmp	SHORT $LN182@DoTurn

; 2335 : 						strInfo = strTemp.toUTF8();

$LN179@DoTurn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 2336 : 					}

	lea	ecx, DWORD PTR _strTemp$225701[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 5
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2337 : 					else

	jmp	SHORT $LN182@DoTurn
$LN58@DoTurn:

; 2338 : 					{
; 2339 : 						strInfo = unmetFirstInfluentialInfo;

	lea	eax, DWORD PTR _unmetFirstInfluentialInfo$225687[esp+436]
	push	eax
$LN538@DoTurn:
	lea	ecx, DWORD PTR _strInfo$[esp+440]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN182@DoTurn:

; 2340 : 					}					
; 2341 : 				}
; 2342 : 				kNotifyPlayer.GetNotifications()->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strInfo, strSummary, -1, -1, m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[esp+436]
	mov	edx, DWORD PTR [ecx+292]
	mov	esi, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	edi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	edi
	push	eax
	push	359132113				; 1567ebd1H
	mov	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	inc	DWORD PTR _iNotifyPlayerID$225690[esp+436]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	jl	$LL63@DoTurn

; 2343 : 			}
; 2344 : 		}

	lea	ecx, DWORD PTR _unmetFirstInfluentialInfo$225687[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _someoneFirstInfluentialInfo$225684[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _targFirstInfluentialInfo$225681[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, DWORD PTR _this$[esp+436]
	mov	esi, DWORD PTR _iThisTurnInfluentialCivs$[esp+436]
	xor	edi, edi
$LN64@DoTurn:

; 2345 : 
; 2346 : 		GC.getGame().GetGameCulture()->SetReportedSomeoneInfluential(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	BYTE PTR [eax+1072], 1
$LN530@DoTurn:

; 2347 : 	}
; 2348 : 
; 2349 : 	if (iThisTurnInfluentialCivs < iLastTurnInfluentialCivs && bCultureVictoryValid)

	cmp	esi, DWORD PTR _iLastTurnInfluentialCivs$[esp+436]
	jge	$LN532@DoTurn
	cmp	BYTE PTR _bCultureVictoryValid$[esp+436], 0
	je	$LN532@DoTurn

; 2350 : 	{
; 2351 : 		Localization::String strTemp;

	lea	ecx, DWORD PTR _strTemp$225710[esp+436]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2352 : 		strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_NO_LONGER_INFLUENTIAL");

	lea	eax, DWORD PTR $T255050[esp+436]
	push	OFFSET $SG225712
	mov	bl, 7
	push	eax
	mov	BYTE PTR __$EHRec$[esp+452], bl
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+440]
	mov	BYTE PTR __$EHRec$[esp+448], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T255050[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2353 : 		strInfo = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_NO_LONGER_INFLUENTIAL_TT");

	lea	ecx, DWORD PTR $T255051[esp+436]
	push	OFFSET $SG225714
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strInfo$[esp+440]
	mov	BYTE PTR __$EHRec$[esp+448], 9
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T255051[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2354 : 		pTargetNotifications->Add(NOTIFICATION_CULTURE_VICTORY_NO_LONGER_INFLUENTIAL, strInfo, strSummary, -1, -1, m_pPlayer->GetID());

	mov	edx, DWORD PTR _this$[esp+436]
	mov	eax, DWORD PTR [edx+292]
	mov	esi, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strInfo$[esp+456]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pTargetNotifications$[esp+456]
	push	eax
	push	-30204373				; fe331e2bH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2355 : 	}

	lea	ecx, DWORD PTR _strTemp$225710[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	esi, DWORD PTR _iThisTurnInfluentialCivs$[esp+436]
	mov	ebx, DWORD PTR _this$[esp+436]
	xor	edi, edi
$LN532@DoTurn:

; 2356 : 
; 2357 : 	if (!m_bReportedTwoCivsAway && iThisTurnInfluentialCivs > 0 && iThisTurnInfluentialCivs == iInfluentialCivsForWin - 2 && GC.getGame().countMajorCivsEverAlive() >= 4)

	cmp	BYTE PTR [ebx+196], 0
	jne	$LN536@DoTurn
	cmp	esi, edi
	jle	$LN536@DoTurn
	mov	ecx, DWORD PTR _iInfluentialCivsForWin$[esp+436]
	add	ecx, -2					; fffffffeH
	cmp	esi, ecx
	jne	$LN536@DoTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?countMajorCivsEverAlive@CvGame@@QBEHXZ	; CvGame::countMajorCivsEverAlive
	cmp	eax, 4
	jl	$LN536@DoTurn

; 2358 : 	{
; 2359 : 		if(bCultureVictoryValid)

	cmp	BYTE PTR _bCultureVictoryValid$[esp+436], 0
	je	$LN54@DoTurn

; 2360 : 		{//This civilization is the first civ to be two civilizations away from getting a cultural victory.  Notify the masses!
; 2361 : 			CvString							targCloseTwoSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_ACTIVE_PLAYER");

	lea	edx, DWORD PTR _targCloseTwoSummary$225717[esp+436]
	push	OFFSET $SG225719
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 2362 : 			Localization::String	targCloseTwoInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_ACTIVE_PLAYER_TT");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR _targCloseTwoInfo$225720[esp+444]
	push	OFFSET $SG225722
	push	eax
	mov	BYTE PTR __$EHRec$[esp+460], 10		; 0000000aH
	call	esi

; 2363 : 			CvString							someoneCloseTwoSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO");

	lea	ecx, DWORD PTR _someoneCloseTwoSummary$225723[esp+452]
	push	OFFSET $SG225725
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+468], 11		; 0000000bH
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 2364 : 			Localization::String	someoneCloseTwoInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_TT");

	lea	edx, DWORD PTR _someoneCloseTwoInfo$225726[esp+460]
	push	OFFSET $SG225728
	push	edx
	mov	BYTE PTR __$EHRec$[esp+476], 12		; 0000000cH
	call	esi

; 2365 : 			CvString							unmetCloseTwoInfo = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_UNMET_TT");

	lea	eax, DWORD PTR _unmetCloseTwoInfo$225729[esp+468]
	push	OFFSET $SG225731
	push	eax
	mov	BYTE PTR __$EHRec$[esp+484], 13		; 0000000dH
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 40					; 00000028H
	mov	BYTE PTR __$EHRec$[esp+444], 14		; 0000000eH

; 2366 : 			for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	mov	DWORD PTR _iNotifyLoop$225732[esp+436], edi
	mov	DWORD PTR tv2222[esp+436], edi
	mov	ebp, edi
	npad	8
$LL53@DoTurn:

; 2367 : 				PlayerTypes eCurPlayer = (PlayerTypes) iNotifyLoop;
; 2368 : 				CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2369 : 
; 2370 : 				if (eCurPlayer == m_pPlayer->GetID()){	

	mov	edx, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR _iNotifyLoop$225732[esp+436]
	add	ebp, ecx
	cmp	eax, DWORD PTR [edx+44]
	jne	$LN50@DoTurn

; 2371 : 					strSummary = targCloseTwoSummary;

	lea	ecx, DWORD PTR _targCloseTwoSummary$225717[esp+436]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[esp+440]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2372 : 					Localization::String strTemp = targCloseTwoInfo;

	lea	edx, DWORD PTR _targCloseTwoInfo$225720[esp+436]
	push	edx
	lea	ecx, DWORD PTR _strTemp$225740[esp+440]
	call	DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z

; 2373 : 					strTemp << m_pPlayer->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [ebx+292]
	mov	BYTE PTR __$EHRec$[esp+444], 15		; 0000000fH
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTemp$225740[esp+440]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 2374 : 					strInfo = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$225740[esp+436]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	test	eax, eax
	je	SHORT $LN233@DoTurn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN232@DoTurn
$LN233@DoTurn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN232@DoTurn:

; 2375 : 					kCurPlayer.GetNotifications()->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO_ACTIVE_PLAYER, strInfo, strSummary, -1, -1, m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebx+292]
	mov	esi, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	edi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	edi
	push	eax
	push	-1730271966				; 98de2522H
	mov	ecx, ebp
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2376 : 				}

	lea	ecx, DWORD PTR _strTemp$225740[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 14		; 0000000eH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2377 : 				else{

	jmp	$LN52@DoTurn
$LN50@DoTurn:

; 2378 : 					strSummary = someoneCloseTwoSummary;

	lea	ecx, DWORD PTR _someoneCloseTwoSummary$225723[esp+436]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[esp+440]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2379 : 					CvTeam& kCurTeam = GET_TEAM(kCurPlayer.getTeam());

	mov	eax, DWORD PTR [ebp+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN250@DoTurn
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN251@DoTurn
$LN250@DoTurn:
	or	eax, -1
$LN251@DoTurn:

; 2380 : 					if(kCurTeam.isHasMet(m_pPlayer->getTeam())){

	mov	edx, DWORD PTR [ebx+292]
	imul	eax, 2984				; 00000ba8H
	mov	edx, DWORD PTR [edx+44]
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN261@DoTurn
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN262@DoTurn
$LN261@DoTurn:
	or	edx, -1
$LN262@DoTurn:
	push	edx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN48@DoTurn

; 2381 : 						Localization::String strTemp = someoneCloseTwoInfo;

	lea	edx, DWORD PTR _someoneCloseTwoInfo$225726[esp+436]
	push	edx
	lea	ecx, DWORD PTR _strTemp$225745[esp+440]
	call	DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z

; 2382 : 						strTemp << m_pPlayer->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [ebx+292]
	mov	BYTE PTR __$EHRec$[esp+444], 16		; 00000010H
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTemp$225745[esp+440]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 2383 : 						strInfo = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$225745[esp+436]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	test	eax, eax
	je	SHORT $LN269@DoTurn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 2384 : 					}

	lea	ecx, DWORD PTR _strTemp$225745[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 14		; 0000000eH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2385 : 					else{

	jmp	SHORT $LN272@DoTurn

; 2383 : 						strInfo = strTemp.toUTF8();

$LN269@DoTurn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 2384 : 					}

	lea	ecx, DWORD PTR _strTemp$225745[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 14		; 0000000eH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2385 : 					else{

	jmp	SHORT $LN272@DoTurn
$LN48@DoTurn:

; 2386 : 						strInfo = unmetCloseTwoInfo;

	lea	eax, DWORD PTR _unmetCloseTwoInfo$225729[esp+436]
	push	eax
	lea	ecx, DWORD PTR _strInfo$[esp+440]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN272@DoTurn:

; 2387 : 					}
; 2388 : 
; 2389 : 					kCurPlayer.GetNotifications()->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_TWO, strInfo, strSummary, -1, -1, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebx+292]
	mov	esi, DWORD PTR [ecx+44]
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	edi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	edi
	push	eax
	push	301374463				; 11f69bffH
	mov	ecx, ebp
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN52@DoTurn:
	mov	ebp, DWORD PTR tv2222[esp+436]
	inc	DWORD PTR _iNotifyLoop$225732[esp+436]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	mov	DWORD PTR tv2222[esp+436], ebp
	jl	$LL53@DoTurn

; 2390 : 				}
; 2391 : 			}
; 2392 : 		}

	lea	ecx, DWORD PTR _unmetCloseTwoInfo$225729[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _someoneCloseTwoInfo$225726[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 12		; 0000000cH
	call	esi
	lea	ecx, DWORD PTR _someoneCloseTwoSummary$225723[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _targCloseTwoInfo$225720[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 10		; 0000000aH
	call	esi
	lea	ecx, DWORD PTR _targCloseTwoSummary$225717[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esi, DWORD PTR _iThisTurnInfluentialCivs$[esp+436]
	xor	edi, edi
$LN54@DoTurn:

; 2393 : 
; 2394 : 		m_bReportedTwoCivsAway = true;

	mov	BYTE PTR [ebx+196], 1
$LN536@DoTurn:

; 2395 : 	}
; 2396 : 
; 2397 : 	if (!m_bReportedOneCivAway && iThisTurnInfluentialCivs == iInfluentialCivsForWin - 1 && GC.getGame().countMajorCivsEverAlive() >= 3)

	cmp	BYTE PTR [ebx+197], 0
	jne	$LN46@DoTurn
	mov	edx, DWORD PTR _iInfluentialCivsForWin$[esp+436]
	dec	edx
	cmp	esi, edx
	jne	$LN46@DoTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?countMajorCivsEverAlive@CvGame@@QBEHXZ	; CvGame::countMajorCivsEverAlive
	cmp	eax, 3
	jl	$LN46@DoTurn

; 2398 : 	{
; 2399 : 		if(bCultureVictoryValid)

	cmp	BYTE PTR _bCultureVictoryValid$[esp+436], 0
	je	$LN45@DoTurn

; 2400 : 		{//This civilization is the first civ to be one civilizations away from getting a cultural victory.  Notify the masses!
; 2401 : 			CvString							targCloseOneSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_ACTIVE_PLAYER");

	lea	eax, DWORD PTR _targCloseOneSummary$225750[esp+436]
	push	OFFSET $SG225752
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 2402 : 			Localization::String	targCloseOneInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_ACTIVE_PLAYER_TT");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _targCloseOneInfo$225753[esp+444]
	push	OFFSET $SG225755
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+460], 17		; 00000011H
	call	esi

; 2403 : 			CvString							someoneCloseOneSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE");

	lea	edx, DWORD PTR _someoneCloseOneSummary$225756[esp+452]
	push	OFFSET $SG225758
	push	edx
	mov	BYTE PTR __$EHRec$[esp+468], 18		; 00000012H
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 2404 : 			Localization::String	someoneCloseOneInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_TT");

	lea	eax, DWORD PTR _someoneCloseOneInfo$225759[esp+460]
	push	OFFSET $SG225761
	push	eax
	mov	BYTE PTR __$EHRec$[esp+476], 19		; 00000013H
	call	esi

; 2405 : 			CvString							unmetCloseOneInfo = GetLocalizedText("TXT_KEY_NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_UNMET_TT");

	lea	ecx, DWORD PTR _unmetCloseOneInfo$225762[esp+468]
	push	OFFSET $SG225764
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+484], 20		; 00000014H
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 40					; 00000028H
	mov	BYTE PTR __$EHRec$[esp+444], 21		; 00000015H

; 2406 : 			for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	mov	DWORD PTR _iNotifyLoop$225765[esp+436], edi
	mov	DWORD PTR tv2235[esp+436], edi
	mov	ebp, edi
$LL44@DoTurn:

; 2407 : 				PlayerTypes eCurPlayer = (PlayerTypes) iNotifyLoop;
; 2408 : 				CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2409 : 
; 2410 : 				if (eCurPlayer == m_pPlayer->GetID()){	

	mov	ecx, DWORD PTR _iNotifyLoop$225765[esp+436]
	mov	eax, DWORD PTR [ebx+292]
	add	ebp, edx
	cmp	ecx, DWORD PTR [eax+44]

; 2411 : 					strSummary = targCloseOneSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+436]
	jne	$LN41@DoTurn
	lea	edx, DWORD PTR _targCloseOneSummary$225750[esp+436]
	push	edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2412 : 					Localization::String strTemp = targCloseOneInfo;

	lea	eax, DWORD PTR _targCloseOneInfo$225753[esp+436]
	push	eax
	lea	ecx, DWORD PTR _strTemp$225773[esp+440]
	call	DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z

; 2413 : 					strTemp << m_pPlayer->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [ebx+292]
	mov	BYTE PTR __$EHRec$[esp+444], 22		; 00000016H
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTemp$225773[esp+440]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 2414 : 					strInfo = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$225773[esp+436]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	test	eax, eax
	je	SHORT $LN304@DoTurn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN303@DoTurn
$LN304@DoTurn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN303@DoTurn:

; 2415 : 					kCurPlayer.GetNotifications()->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE_ACTIVE_PLAYER, strInfo, strSummary, -1, -1, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebx+292]
	mov	esi, DWORD PTR [ecx+44]
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	edi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	edi
	push	eax
	push	1716970771				; 6656e513H
	mov	ecx, ebp
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2416 : 				}

	lea	ecx, DWORD PTR _strTemp$225773[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 21		; 00000015H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2417 : 				else

	jmp	$LN43@DoTurn
$LN41@DoTurn:

; 2418 : 				{
; 2419 : 					strSummary = someoneCloseOneSummary;

	lea	edx, DWORD PTR _someoneCloseOneSummary$225756[esp+436]
	push	edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2420 : 					CvTeam& kCurTeam = GET_TEAM(kCurPlayer.getTeam());

	mov	eax, DWORD PTR [ebp+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN321@DoTurn
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN322@DoTurn
$LN321@DoTurn:
	or	eax, -1
$LN322@DoTurn:

; 2421 : 					if(kCurTeam.isHasMet(m_pPlayer->getTeam())){

	mov	edx, DWORD PTR [ebx+292]
	imul	eax, 2984				; 00000ba8H
	mov	edx, DWORD PTR [edx+44]
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN332@DoTurn
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN333@DoTurn
$LN332@DoTurn:
	or	edx, -1
$LN333@DoTurn:
	push	edx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN39@DoTurn

; 2422 : 						Localization::String strTemp = someoneCloseOneInfo;

	lea	edx, DWORD PTR _someoneCloseOneInfo$225759[esp+436]
	push	edx
	lea	ecx, DWORD PTR _strTemp$225778[esp+440]
	call	DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z

; 2423 : 						strTemp << m_pPlayer->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [ebx+292]
	mov	BYTE PTR __$EHRec$[esp+444], 23		; 00000017H
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strTemp$225778[esp+440]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 2424 : 						strInfo = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$225778[esp+436]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	test	eax, eax
	je	SHORT $LN340@DoTurn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 2425 : 					}

	lea	ecx, DWORD PTR _strTemp$225778[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 21		; 00000015H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2426 : 					else{

	jmp	SHORT $LN343@DoTurn

; 2424 : 						strInfo = strTemp.toUTF8();

$LN340@DoTurn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 2425 : 					}

	lea	ecx, DWORD PTR _strTemp$225778[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 21		; 00000015H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2426 : 					else{

	jmp	SHORT $LN343@DoTurn
$LN39@DoTurn:

; 2427 : 						strInfo = unmetCloseOneInfo;

	lea	eax, DWORD PTR _unmetCloseOneInfo$225762[esp+436]
	push	eax
	lea	ecx, DWORD PTR _strInfo$[esp+440]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN343@DoTurn:

; 2428 : 					}
; 2429 : 					kCurPlayer.GetNotifications()->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE, strInfo, strSummary, -1, -1, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebx+292]
	mov	esi, DWORD PTR [ecx+44]
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	edi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	edi
	push	eax
	push	2052101992				; 7a509768H
	mov	ecx, ebp
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN43@DoTurn:
	mov	ebp, DWORD PTR tv2235[esp+436]
	inc	DWORD PTR _iNotifyLoop$225765[esp+436]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	mov	DWORD PTR tv2235[esp+436], ebp
	jl	$LL44@DoTurn

; 2430 : 				}
; 2431 : 			}
; 2432 : 		}

	lea	ecx, DWORD PTR _unmetCloseOneInfo$225762[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 20		; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _someoneCloseOneInfo$225759[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 19		; 00000013H
	call	esi
	lea	ecx, DWORD PTR _someoneCloseOneSummary$225756[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 18		; 00000012H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _targCloseOneInfo$225753[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 17		; 00000011H
	call	esi
	lea	ecx, DWORD PTR _targCloseOneSummary$225750[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN45@DoTurn:

; 2433 : 
; 2434 : 		m_bReportedOneCivAway = true;

	mov	BYTE PTR [ebx+197], 1
$LN46@DoTurn:

; 2435 : 	}
; 2436 : 
; 2437 : 	if (m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR [ebx+292]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN489@DoTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN489@DoTurn

; 2438 : 	{
; 2439 : 		// check for having city-state artifacts
; 2440 : 		std::vector<int> aiCityStateArtifact;

	xor	ebp, ebp
	xor	ebx, ebx
	mov	DWORD PTR _aiCityStateArtifact$225786[esp+440], ebx
	mov	DWORD PTR _aiCityStateArtifact$225786[esp+444], ebp
	mov	DWORD PTR _aiCityStateArtifact$225786[esp+448], ebp

; 2441 : 		int iLoop;
; 2442 : 		CvCity* pLoopCity = NULL;
; 2443 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	eax, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [eax+292]
	push	ebp
	lea	edx, DWORD PTR _iLoop$225787[esp+440]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+452], 24		; 00000018H
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$225788[esp+436], eax
	cmp	eax, ebp
	je	$LN34@DoTurn
$LL36@DoTurn:

; 2444 : 		{
; 2445 : #ifdef AUI_WARNING_FIXES
; 2446 : 			for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 2447 : #else
; 2448 : 			for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildingClassLoop$225792[esp+436], 0
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN35@DoTurn
	npad	6
$LL33@DoTurn:

; 2449 : #endif
; 2450 : 			{
; 2451 : 				CvCivilizationInfo& playerCivilizationInfo = m_pPlayer->getCivilizationInfo();

	mov	ecx, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [ecx+292]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 2452 : 				BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	mov	edx, DWORD PTR _iBuildingClassLoop$225792[esp+436]
	push	edx
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 2453 : 				if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	$LN32@DoTurn

; 2454 : 				{
; 2455 : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 2456 : 					if (pkBuilding)

	test	edi, edi
	je	$LN32@DoTurn

; 2457 : 					{
; 2458 : 						if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _pLoopCity$225788[esp+436]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN32@DoTurn

; 2459 : 						{
; 2460 : 							int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, edi
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 2461 : 							for (int iI = 0; iI < iNumSlots; iI++)

	xor	edi, edi
	mov	DWORD PTR _iNumSlots$225804[esp+436], eax
	test	eax, eax
	jle	$LN32@DoTurn
	npad	7
$LL27@DoTurn:

; 2462 : 							{
; 2463 : 								int iGreatWorkIndex = pLoopCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	mov	eax, DWORD PTR _iBuildingClassLoop$225792[esp+436]
	mov	ecx, DWORD PTR _pLoopCity$225788[esp+436]
	push	edi
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	mov	esi, eax

; 2464 : 								if (iGreatWorkIndex != NO_GREAT_WORK)

	cmp	esi, -1
	je	$LN26@DoTurn

; 2465 : 								{
; 2466 : 									bool bDupe = false;
; 2467 : 									PlayerTypes eCreatingPlayer = GC.getGame().GetGameCulture()->GetGreatWorkCreator(iGreatWorkIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	lea	ecx, DWORD PTR [esi+esi*2]
	shl	ecx, 4
	add	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx+44]

; 2468 : 									if (GET_PLAYER(eCreatingPlayer).isMinorCiv())

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN26@DoTurn

; 2469 : 									{
; 2470 : 										for (uint ui = 0; ui < aiCityStateArtifact.size(); ui++)

	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 2
	xor	ecx, ecx
	test	eax, eax
	jbe	SHORT $LN534@DoTurn
	npad	1
$LL22@DoTurn:

; 2471 : 										{
; 2472 : 											if (aiCityStateArtifact[ui] == eCreatingPlayer)

	cmp	DWORD PTR [ebx+ecx*4], esi
	je	SHORT $LN26@DoTurn
	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL22@DoTurn
$LN534@DoTurn:

; 2473 : 											{
; 2474 : 												bDupe = true;
; 2475 : 												break;
; 2476 : 											}
; 2477 : 										}
; 2478 : 
; 2479 : 										if (!bDupe)
; 2480 : 										{
; 2481 : 											aiCityStateArtifact.push_back(eCreatingPlayer);

	mov	DWORD PTR $T255056[esp+436], esi
	test	ebx, ebx
	jne	SHORT $LN421@DoTurn
	xor	ecx, ecx
	jmp	SHORT $LN422@DoTurn
$LN421@DoTurn:
	mov	ecx, DWORD PTR _aiCityStateArtifact$225786[esp+448]
	sub	ecx, ebx
	sar	ecx, 2
$LN422@DoTurn:
	cmp	eax, ecx
	jae	SHORT $LN414@DoTurn
	mov	DWORD PTR [ebp], esi
	add	ebp, 4
	mov	DWORD PTR _aiCityStateArtifact$225786[esp+444], ebp
	jmp	SHORT $LN468@DoTurn
$LN414@DoTurn:
	lea	ecx, DWORD PTR $T255056[esp+436]
	push	ecx
	push	1
	push	ebp
	lea	ecx, DWORD PTR _aiCityStateArtifact$225786[esp+448]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebp, DWORD PTR _aiCityStateArtifact$225786[esp+444]
	mov	ebx, DWORD PTR _aiCityStateArtifact$225786[esp+440]
$LN468@DoTurn:

; 2482 : 											if (aiCityStateArtifact.size() >= 10)

	mov	edx, ebp
	sub	edx, ebx
	sar	edx, 2
	cmp	edx, 10					; 0000000aH
	jae	SHORT $LN510@DoTurn
$LN26@DoTurn:

; 2461 : 							for (int iI = 0; iI < iNumSlots; iI++)

	inc	edi
	cmp	edi, DWORD PTR _iNumSlots$225804[esp+436]
	jl	$LL27@DoTurn

; 2482 : 											if (aiCityStateArtifact.size() >= 10)

	jmp	SHORT $LN32@DoTurn
$LN510@DoTurn:

; 2483 : 											{
; 2484 : 												gDLL->UnlockAchievement(ACHIEVEMENT_XP2_35);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	277					; 00000115H
	call	edx
$LN32@DoTurn:
	mov	esi, DWORD PTR _iBuildingClassLoop$225792[esp+436]
	inc	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildingClassLoop$225792[esp+436], esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	esi, eax
	jl	$LL33@DoTurn
$LN35@DoTurn:

; 2441 : 		int iLoop;
; 2442 : 		CvCity* pLoopCity = NULL;
; 2443 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [ecx+292]
	push	0
	lea	eax, DWORD PTR _iLoop$225787[esp+440]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$225788[esp+436], eax
	test	eax, eax
	jne	$LL36@DoTurn
$LN34@DoTurn:

; 2485 : 												break;
; 2486 : 											}
; 2487 : 										}
; 2488 : 									}
; 2489 : 								}
; 2490 : 							}
; 2491 : 						}
; 2492 : 					}
; 2493 : 				}
; 2494 : 			}
; 2495 : 		}
; 2496 : 
; 2497 : 		// check for having broadcast towers filled
; 2498 : 		PolicyBranchTypes eCurrentBranchType = m_pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	edx, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [edx+292]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree

; 2499 : 
; 2500 : 		if (eCurrentBranchType == (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	jne	$LN1@DoTurn

; 2501 : 		{
; 2502 : 			int iNumWorksInBroadcastTowers = 0;
; 2503 : 			for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [ecx+292]
	push	0
	lea	eax, DWORD PTR _iLoop$225787[esp+440]
	push	eax
	mov	DWORD PTR _iNumWorksInBroadcastTowers$225826[esp+444], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$225788[esp+436], eax
	test	eax, eax
	je	$LN1@DoTurn
	npad	1
$LL15@DoTurn:

; 2504 : 			{
; 2505 : #ifdef AUI_WARNING_FIXES
; 2506 : 				for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 2507 : #else
; 2508 : 				for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN14@DoTurn
	npad	12
$LL12@DoTurn:

; 2509 : #endif
; 2510 : 				{
; 2511 : 					CvCivilizationInfo& playerCivilizationInfo = m_pPlayer->getCivilizationInfo();

	mov	edx, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [edx+292]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 2512 : 					BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	ebp
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	ebx, eax

; 2513 : 					if (eBuilding != NO_BUILDING)

	cmp	ebx, -1
	je	$LN11@DoTurn

; 2514 : 					{
; 2515 : 						CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 2516 : 						if (pkBuilding && strcmp(pkBuilding->GetType(), "BUILDING_BROADCAST_TOWER") == 0)

	test	edi, edi
	je	$LN11@DoTurn
	lea	ecx, DWORD PTR [edi+176]
	mov	esi, OFFSET $SG225841
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL525@DoTurn:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN526@DoTurn
	test	cl, cl
	je	SHORT $LN527@DoTurn
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN526@DoTurn
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL525@DoTurn
$LN527@DoTurn:
	xor	eax, eax
	jmp	SHORT $LN528@DoTurn
$LN526@DoTurn:
	sbb	eax, eax
	sbb	eax, -1
$LN528@DoTurn:
	test	eax, eax
	jne	SHORT $LN11@DoTurn

; 2517 : 						{
; 2518 : 							if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _pLoopCity$225788[esp+436]
	push	ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN11@DoTurn

; 2519 : 							{
; 2520 : 								int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, edi
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	edi, eax

; 2521 : 								bool bAnySlotEmpty = false;

	xor	bl, bl

; 2522 : 								for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN529@DoTurn
$LL6@DoTurn:

; 2523 : 								{
; 2524 : 									int iGreatWorkIndex = pLoopCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	mov	ecx, DWORD PTR _pLoopCity$225788[esp+436]
	push	esi
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 2525 : 									if (iGreatWorkIndex == NO_GREAT_WORK)

	cmp	eax, -1
	jne	SHORT $LN5@DoTurn

; 2526 : 									{
; 2527 : 										bAnySlotEmpty = true;

	mov	bl, 1
$LN5@DoTurn:

; 2522 : 								for (int iI = 0; iI < iNumSlots; iI++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL6@DoTurn

; 2528 : 									}
; 2529 : 								}
; 2530 : 
; 2531 : 								if (!bAnySlotEmpty)

	test	bl, bl
	jne	SHORT $LN11@DoTurn
$LN529@DoTurn:

; 2532 : 								{
; 2533 : 									iNumWorksInBroadcastTowers++;

	inc	DWORD PTR _iNumWorksInBroadcastTowers$225826[esp+436]
$LN11@DoTurn:

; 2504 : 			{
; 2505 : #ifdef AUI_WARNING_FIXES
; 2506 : 				for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 2507 : #else
; 2508 : 				for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	$LL12@DoTurn
$LN14@DoTurn:

; 2501 : 		{
; 2502 : 			int iNumWorksInBroadcastTowers = 0;
; 2503 : 			for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR _this$[esp+436]
	mov	ecx, DWORD PTR [ecx+292]
	push	0
	lea	eax, DWORD PTR _iLoop$225787[esp+440]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$225788[esp+436], eax
	test	eax, eax
	jne	$LL15@DoTurn

; 2534 : 								}
; 2535 : 							}
; 2536 : 						}
; 2537 : 					}
; 2538 : 				}
; 2539 : 			}
; 2540 : 
; 2541 : 			if (iNumWorksInBroadcastTowers >= 10)

	cmp	DWORD PTR _iNumWorksInBroadcastTowers$225826[esp+436], 10 ; 0000000aH
	jl	SHORT $LN1@DoTurn

; 2542 : 			{
; 2543 : 				gDLL->UnlockAchievement(ACHIEVEMENT_XP2_38);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	280					; 00000118H
	call	eax
$LN1@DoTurn:

; 2544 : 			}
; 2545 : 		}
; 2546 : 	}	

	mov	eax, DWORD PTR _aiCityStateArtifact$225786[esp+440]
	mov	BYTE PTR __$EHRec$[esp+444], 1
	test	eax, eax
	je	SHORT $LN489@DoTurn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN489@DoTurn:

; 2547 : 
; 2548 : 	LogCultureData();

	mov	ecx, DWORD PTR _this$[esp+436]
	call	?LogCultureData@CvPlayerCulture@@AAEXXZ	; CvPlayerCulture::LogCultureData

; 2549 : }

	lea	ecx, DWORD PTR _strInfo$[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+436]
	mov	DWORD PTR __$EHRec$[esp+444], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+436]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 420				; 000001a4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strInfo$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T255048[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$3:
	lea	ecx, DWORD PTR _targFirstInfluentialInfo$225681[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$4:
	lea	ecx, DWORD PTR _someoneFirstInfluentialInfo$225684[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$5:
	lea	ecx, DWORD PTR _unmetFirstInfluentialInfo$225687[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$6:
	lea	ecx, DWORD PTR _strTemp$225701[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$7:
	lea	ecx, DWORD PTR _strTemp$225710[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T255050[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T255051[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$10:
	lea	ecx, DWORD PTR _targCloseTwoSummary$225717[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$11:
	lea	ecx, DWORD PTR _targCloseTwoInfo$225720[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$12:
	lea	ecx, DWORD PTR _someoneCloseTwoSummary$225723[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$13:
	lea	ecx, DWORD PTR _someoneCloseTwoInfo$225726[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$14:
	lea	ecx, DWORD PTR _unmetCloseTwoInfo$225729[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$15:
	lea	ecx, DWORD PTR _strTemp$225740[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$16:
	lea	ecx, DWORD PTR _strTemp$225745[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$17:
	lea	ecx, DWORD PTR _targCloseOneSummary$225750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$18:
	lea	ecx, DWORD PTR _targCloseOneInfo$225753[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$19:
	lea	ecx, DWORD PTR _someoneCloseOneSummary$225756[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$20:
	lea	ecx, DWORD PTR _someoneCloseOneInfo$225759[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$21:
	lea	ecx, DWORD PTR _unmetCloseOneInfo$225762[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$22:
	lea	ecx, DWORD PTR _strTemp$225773[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$23:
	lea	ecx, DWORD PTR _strTemp$225778[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTurn@CvPlayerCulture@@QAEXXZ$24:
	lea	ecx, DWORD PTR _aiCityStateArtifact$225786[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?DoTurn@CvPlayerCulture@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvPlayerCulture@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvPlayerCulture@@QAEXXZ ENDP			; CvPlayerCulture::DoTurn
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvPlayerCulture@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PolicyBranchTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvPlayerCulture@@@Z
_TEXT	SEGMENT
_iEntriesToRead$ = -20					; size = 4
_uiVersion$ = -16					; size = 4
_iTempX$ = -12						; size = 4
_iTempY$ = -8						; size = 4
_pPlot$ = -4						; size = 4
_iTemp$226877 = 8					; size = 4
_loadFrom$ = 8						; size = 4
_iI$226866 = 12						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerCulture@@@Z PROC	; operator>>, COMDAT

; 4190 : {

	sub	esp, 20					; 00000014H
	push	ebx

; 4191 : 	uint uiVersion;
; 4192 : 
; 4193 : 	loadFrom >> uiVersion;

	mov	ebx, DWORD PTR _loadFrom$[esp+20]
	push	ebp
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+36]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4194 : 
; 4195 : 	int iEntriesToRead;
; 4196 : 	int iTempX;
; 4197 : 	int iTempY;
; 4198 : 	CvPlot *pPlot;
; 4199 : 
; 4200 : 	writeTo.m_aDigCompletePlots.clear();

	mov	esi, DWORD PTR _writeTo$[esp+32]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, ecx
	je	SHORT $LN215@operator@10
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edi, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edi+edx]
	test	eax, eax
	jle	SHORT $LN60@operator@10
	push	edi
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN60@operator@10:
	mov	DWORD PTR [esi+8], ebp
$LN215@operator@10:

; 4201 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+36]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4202 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	cmp	DWORD PTR _iEntriesToRead$[esp+36], 0
	mov	DWORD PTR _iI$226866[esp+32], 0
	jle	$LN14@operator@10
	npad	7
$LL218@operator@10:

; 4203 : 	{
; 4204 : 		loadFrom >> iTempX;

	lea	edx, DWORD PTR _iTempX$[esp+36]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4205 : 		loadFrom >> iTempY;

	lea	eax, DWORD PTR _iTempY$[esp+36]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4206 : 		pPlot = GC.getMap().plot(iTempX, iTempY);

	mov	eax, DWORD PTR _iTempX$[esp+36]
	cmp	eax, -2147483647			; 80000001H
	je	$LN71@operator@10
	mov	ebx, DWORD PTR _iTempY$[esp+36]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN217@operator@10
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN81@operator@10
	test	eax, eax
	jge	SHORT $LN83@operator@10
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN85@operator@10
$LN83@operator@10:
	cmp	eax, ecx
	jl	SHORT $LN81@operator@10
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN85@operator@10
$LN81@operator@10:
	mov	edi, eax
$LN85@operator@10:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebp, DWORD PTR [edx+4024]
	je	SHORT $LN216@operator@10
	test	ebx, ebx
	jge	SHORT $LN93@operator@10
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN95@operator@10
$LN93@operator@10:
	cmp	ebx, ebp
	jl	SHORT $LN216@operator@10
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN95@operator@10
$LN216@operator@10:
	mov	edx, ebx
$LN95@operator@10:
	test	edi, edi
	jl	SHORT $LN217@operator@10
	cmp	edi, ecx
	jge	SHORT $LN217@operator@10
	test	edx, edx
	jl	SHORT $LN217@operator@10
	cmp	edx, ebp
	jge	SHORT $LN217@operator@10
	mov	ebx, DWORD PTR _loadFrom$[esp+32]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN73@operator@10
$LN217@operator@10:
	mov	ebx, DWORD PTR _loadFrom$[esp+32]
$LN71@operator@10:
	xor	ecx, ecx
$LN73@operator@10:

; 4207 : 		writeTo.m_aDigCompletePlots.push_back(pPlot);

	mov	edi, DWORD PTR [esi+4]
	mov	DWORD PTR _pPlot$[esp+36], ecx
	test	edi, edi
	jne	SHORT $LN117@operator@10
	xor	eax, eax
	jmp	SHORT $LN118@operator@10
$LN117@operator@10:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edi
	sar	eax, 2
$LN118@operator@10:
	mov	edx, DWORD PTR [esi+8]
	mov	ebp, edx
	sub	ebp, edi
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN110@operator@10
	mov	DWORD PTR [edx], ecx
	add	edx, 4
	mov	DWORD PTR [esi+8], edx
	jmp	SHORT $LN15@operator@10
$LN110@operator@10:
	lea	eax, DWORD PTR _pPlot$[esp+36]
	push	eax
	push	1
	push	edx
	mov	ecx, esi
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
$LN15@operator@10:
	mov	eax, DWORD PTR _iI$226866[esp+32]
	inc	eax
	cmp	eax, DWORD PTR _iEntriesToRead$[esp+36]
	mov	DWORD PTR _iI$226866[esp+32], eax
	jl	$LL218@operator@10
$LN14@operator@10:

; 4208 : 	}
; 4209 : 
; 4210 : 	loadFrom >> writeTo.m_iLastTurnLifetimeCulture;

	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4211 : 	loadFrom >> iEntriesToRead;

	lea	edx, DWORD PTR _iEntriesToRead$[esp+36]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4212 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iEntriesToRead$[esp+36], ebp
	jle	SHORT $LN11@operator@10

; 4208 : 	}
; 4209 : 
; 4210 : 	loadFrom >> writeTo.m_iLastTurnLifetimeCulture;

	lea	edi, DWORD PTR [esi+108]
$LL13@operator@10:

; 4213 : 	{
; 4214 : 		loadFrom >> writeTo.m_aiCulturalInfluence[iI];

	lea	eax, DWORD PTR [edi-88]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4215 : 		loadFrom >> writeTo.m_aiLastTurnCulturalInfluence[iI];

	push	edi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	ebp
	add	edi, 4
	cmp	ebp, DWORD PTR _iEntriesToRead$[esp+36]
	jl	SHORT $LL13@operator@10
$LN11@operator@10:

; 4216 : 	}
; 4217 : 
; 4218 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+36], 2
	jb	SHORT $LN10@operator@10

; 4219 : 	{
; 4220 : 		loadFrom >> writeTo.m_bReportedTwoCivsAway;

	lea	ecx, DWORD PTR [esi+196]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 4221 : 		loadFrom >> writeTo.m_bReportedOneCivAway;

	lea	edx, DWORD PTR [esi+197]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 4222 : 	}
; 4223 : 	else

	jmp	SHORT $LN9@operator@10
$LN10@operator@10:

; 4224 : 	{
; 4225 : 		writeTo.m_bReportedTwoCivsAway = false;

	mov	BYTE PTR [esi+196], 0

; 4226 : 		writeTo.m_bReportedOneCivAway = false;

	mov	BYTE PTR [esi+197], 0
$LN9@operator@10:

; 4227 : 	}
; 4228 : 
; 4229 : 	if (uiVersion >= 3)

	or	edi, -1
	cmp	DWORD PTR _uiVersion$[esp+36], 3
	jb	SHORT $LN8@operator@10

; 4230 : 	{
; 4231 : 		int iTemp;
; 4232 : 		loadFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$226877[esp+32]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4233 : 		writeTo.m_eOpinion = (PublicOpinionTypes)iTemp;

	mov	ecx, DWORD PTR _iTemp$226877[esp+32]

; 4234 : 		loadFrom >> writeTo.m_ePreferredIdeology;

	lea	edx, DWORD PTR [esi+212]
	push	edx
	push	ebx
	mov	DWORD PTR [esi+200], ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PolicyBranchTypes@@@Z ; operator>>
	add	esp, 8

; 4235 : 		loadFrom >> writeTo.m_iOpinionUnhappiness;

	lea	eax, DWORD PTR [esi+216]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4236 : 		loadFrom >> writeTo.m_strOpinionTooltip;

	lea	ecx, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 4237 : 	}
; 4238 : 	else

	jmp	SHORT $LN188@operator@10
$LN8@operator@10:

; 4239 : 	{
; 4240 : 		writeTo.m_eOpinion = NO_PUBLIC_OPINION;
; 4241 : 		writeTo.m_ePreferredIdeology = NO_POLICY_BRANCH_TYPE;
; 4242 : 		writeTo.m_iOpinionUnhappiness = 0;
; 4243 : 		writeTo.m_strOpinionTooltip = "";

	push	OFFSET $SG226883
	lea	ecx, DWORD PTR [esi+220]
	mov	DWORD PTR [esi+200], edi
	mov	DWORD PTR [esi+212], edi
	mov	DWORD PTR [esi+216], 0
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN188@operator@10:

; 4244 : 	}
; 4245 : 
; 4246 : 	if (uiVersion >= 5)

	cmp	DWORD PTR _uiVersion$[esp+36], 5
	jb	SHORT $LN6@operator@10

; 4247 : 	{
; 4248 : 		loadFrom >> writeTo.m_strOpinionUnhappinessTooltip;

	lea	edx, DWORD PTR [esi+248]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 4249 : 	}
; 4250 : 	else

	jmp	SHORT $LN194@operator@10
$LN6@operator@10:

; 4251 : 	{
; 4252 : 		writeTo.m_strOpinionUnhappinessTooltip = "";

	push	OFFSET $SG226886
	lea	ecx, DWORD PTR [esi+248]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN194@operator@10:

; 4253 : 	}
; 4254 : 
; 4255 : 	if (uiVersion >= 6)

	cmp	DWORD PTR _uiVersion$[esp+36], 6
	jb	SHORT $LN4@operator@10

; 4256 : 	{
; 4257 : 		loadFrom >> writeTo.m_eOpinionBiggestInfluence;

	lea	eax, DWORD PTR [esi+204]
	push	eax
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 4258 : 		loadFrom >> writeTo.m_iTurnIdeologySwitch;

	lea	ecx, DWORD PTR [esi+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4259 : 	}
; 4260 : 	else

	jmp	SHORT $LN3@operator@10
$LN4@operator@10:

; 4261 : 	{
; 4262 : 		writeTo.m_eOpinionBiggestInfluence = NO_PLAYER;

	mov	DWORD PTR [esi+204], edi

; 4263 : 		writeTo.m_iTurnIdeologySwitch = -1;

	mov	DWORD PTR [esi+208], edi
$LN3@operator@10:

; 4264 : 
; 4265 : 	}
; 4266 : 	if (uiVersion >= 4)

	cmp	DWORD PTR _uiVersion$[esp+36], 4
	jb	SHORT $LN2@operator@10

; 4267 : 	{
; 4268 : 		loadFrom >> writeTo.m_iSwappableWritingIndex;

	lea	edx, DWORD PTR [esi+276]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4269 : 		loadFrom >> writeTo.m_iSwappableArtIndex;

	lea	eax, DWORD PTR [esi+280]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4270 : 		loadFrom >> writeTo.m_iSwappableArtifactIndex;

	lea	ecx, DWORD PTR [esi+284]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4271 : 		loadFrom >> writeTo.m_iSwappableMusicIndex;

	add	esi, 288				; 00000120H
	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi
	pop	ebp

; 4279 : 	}
; 4280 : 
; 4281 : 	return loadFrom;

	mov	eax, ebx
	pop	ebx

; 4282 : }

	add	esp, 20					; 00000014H
	ret	0
$LN2@operator@10:

; 4272 : 	}
; 4273 : 	else
; 4274 : 	{
; 4275 : 		writeTo.m_iSwappableWritingIndex = -1;

	mov	DWORD PTR [esi+276], edi

; 4276 : 		writeTo.m_iSwappableArtIndex = -1;

	mov	DWORD PTR [esi+280], edi

; 4277 : 		writeTo.m_iSwappableArtifactIndex = -1;

	mov	DWORD PTR [esi+284], edi

; 4278 : 		writeTo.m_iSwappableMusicIndex = -1;

	mov	DWORD PTR [esi+288], edi
	pop	edi
	pop	esi
	pop	ebp

; 4279 : 	}
; 4280 : 
; 4281 : 	return loadFrom;

	mov	eax, ebx
	pop	ebx

; 4282 : }

	add	esp, 20					; 00000014H
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerCulture@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CultureHelpers::GetThemingBonusIndex
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_bValid$227755 = -157					; size = 1
_ePlayer$227807 = -156					; size = 4
_eEra$227777 = -156					; size = 4
_iNumSlots$227738 = -156				; size = 4
_bonusInfo$227756 = -152				; size = 4
_eArtClass$ = -152					; size = 4
_iCountArtifact$ = -148					; size = 4
_iCountArt$ = -144					; size = 4
__Cat$258673 = -140					; size = 1
__Cat$257951 = -140					; size = 1
_iNumThemes$227750 = -140				; size = 4
_aProcessedEras$227772 = -136				; size = 16
_jJ$227751 = -120					; size = 4
_aProcessedPlayers$227802 = -116			; size = 16
_aPlayersSeen$ = -100					; size = 16
_aErasSeen$ = -84					; size = 16
$T257948 = -68						; size = 1
$T258670 = -64						; size = 1
_work$227746 = -60					; size = 48
__$EHRec$ = -12						; size = 12
_eOwner$ = 8						; size = 4
_pkEntry$ = 12						; size = 4
_aGreatWorkIndices$ = 16				; size = 4
?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; CultureHelpers::GetThemingBonusIndex, COMDAT

; 5715 : {

	push	-1
	push	__ehhandler$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 5716 : 	int iCountArt = 0;

	xor	edi, edi
	mov	DWORD PTR _iCountArt$[esp+176], edi

; 5717 : 	int iCountArtifact = 0;

	mov	DWORD PTR _iCountArtifact$[esp+176], edi

; 5718 : 	vector<EraTypes> aErasSeen;

	mov	DWORD PTR _aErasSeen$[esp+180], edi
	mov	DWORD PTR _aErasSeen$[esp+184], edi
	mov	DWORD PTR _aErasSeen$[esp+188], edi
	mov	DWORD PTR __$EHRec$[esp+184], edi

; 5719 : 	vector<PlayerTypes> aPlayersSeen;

	mov	DWORD PTR _aPlayersSeen$[esp+180], edi
	mov	DWORD PTR _aPlayersSeen$[esp+184], edi
	mov	DWORD PTR _aPlayersSeen$[esp+188], edi

; 5720 : 
; 5721 : 	CvGameCulture *pCulture = GC.getGame().GetGameCulture();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture

; 5722 : 	GreatWorkClass eArtifactClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ARTIFACT");

	push	edi
	push	OFFSET $SG227733
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5723 : 	GreatWorkClass eArtClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ART");

	push	edi
	push	OFFSET $SG227736
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5724 : 
; 5725 : 	if (pkEntry)

	mov	ecx, DWORD PTR _pkEntry$[esp+172]
	mov	DWORD PTR _eArtClass$[esp+176], eax
	cmp	ecx, edi
	je	$LN602@GetTheming

; 5726 : 	{
; 5727 : #ifdef AUI_WARNING_FIXES
; 5728 : 		uint iNumSlots = pkEntry->GetGreatWorkCount();
; 5729 : #else
; 5730 : 		int iNumSlots = pkEntry->GetGreatWorkCount();

	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 5731 : #endif
; 5732 : 		if (aGreatWorkIndices.size() != iNumSlots)

	mov	ecx, DWORD PTR _aGreatWorkIndices$[esp+172]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _iNumSlots$227738[esp+176], eax
	sar	edx, 2
	cmp	edx, eax

; 5733 : 		{
; 5734 : 			return -1;  // No theming bonus if some slots still empty or too many entries

	jne	$LN602@GetTheming

; 5735 : 		}
; 5736 : 
; 5737 : 		// Store info on the attributes of all our Great Works
; 5738 : #ifdef AUI_WARNING_FIXES
; 5739 : 		for (uint iI = 0; iI < iNumSlots; iI++)
; 5740 : #else
; 5741 : 		for (int iI = 0; iI < iNumSlots; iI++)

	cmp	eax, edi
	jle	$LN43@GetTheming
	npad	5
$LL45@GetTheming:

; 5742 : #endif
; 5743 : 		{
; 5744 : 			int iGreatWork = aGreatWorkIndices[iI];

	mov	eax, DWORD PTR _aGreatWorkIndices$[esp+172]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edi*4]

; 5745 : 			CvGreatWork work = pCulture->m_CurrentGreatWorks[iGreatWork];

	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 4
	add	esi, DWORD PTR [ebp]
	lea	ecx, DWORD PTR _work$227746[esp+176]
	push	esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR _work$227746[esp+204], edx
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _work$227746[esp+208], eax
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR _work$227746[esp+212], ecx
	mov	edx, DWORD PTR [esi+40]
	mov	DWORD PTR _work$227746[esp+216], edx
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _work$227746[esp+220], ecx
	mov	BYTE PTR __$EHRec$[esp+184], 2

; 5746 : 
; 5747 : 			// Check Great Work class
; 5748 : 			if (work.m_eClassType == eArtifactClass)

	cmp	eax, ebx
	jne	SHORT $LN42@GetTheming

; 5749 : 			{
; 5750 : 				iCountArtifact++;

	inc	DWORD PTR _iCountArtifact$[esp+176]
	jmp	SHORT $LN634@GetTheming
$LN42@GetTheming:

; 5751 : 			}
; 5752 : 			else if (work.m_eClassType == eArtClass)

	cmp	eax, DWORD PTR _eArtClass$[esp+176]
	jne	SHORT $LN634@GetTheming

; 5753 : 			{
; 5754 : 				iCountArt++;

	inc	DWORD PTR _iCountArt$[esp+176]
$LN634@GetTheming:

; 5755 : 			}
; 5756 : 
; 5757 : 			// Store era and player
; 5758 : 			aErasSeen.push_back(work.m_eEra);

	lea	edx, DWORD PTR _work$227746[esp+216]
	push	edx
	lea	ecx, DWORD PTR _aErasSeen$[esp+180]
	call	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back

; 5759 : 			aPlayersSeen.push_back(work.m_ePlayer);

	lea	eax, DWORD PTR _work$227746[esp+220]
	push	eax
	lea	ecx, DWORD PTR _aPlayersSeen$[esp+180]
	call	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back

; 5760 : 		}

	lea	ecx, DWORD PTR _work$227746[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	edi
	cmp	edi, DWORD PTR _iNumSlots$227738[esp+176]
	jl	$LL45@GetTheming
$LN43@GetTheming:

; 5761 : 
; 5762 : 		// Now see if we match a theme bonus
; 5763 : 		int iNumThemes = pkEntry->GetNumThemingBonuses();

	mov	ecx, DWORD PTR _pkEntry$[esp+172]
	mov	eax, DWORD PTR [ecx+1008]

; 5764 : 		for (int jJ = 0; jJ < iNumThemes; jJ++)

	mov	ebx, DWORD PTR _aErasSeen$[esp+180]
	mov	esi, DWORD PTR _aPlayersSeen$[esp+180]
	xor	ecx, ecx
	mov	DWORD PTR _iNumThemes$227750[esp+176], eax
	mov	DWORD PTR _jJ$227751[esp+176], ecx
	test	eax, eax
	jle	$LN37@GetTheming
	mov	ebp, DWORD PTR _aPlayersSeen$[esp+184]
	npad	7
$LL642@GetTheming:
	mov	edi, DWORD PTR _iCountArt$[esp+176]

; 5765 : 		{
; 5766 : 			bool bValid = true;
; 5767 : 
; 5768 : 			// Can we rule this out based on type?
; 5769 : 			CvThemingBonusInfo *bonusInfo = pkEntry->GetThemingBonusInfo(jJ);

	push	ecx
	mov	ecx, DWORD PTR _pkEntry$[esp+176]
	mov	BYTE PTR _bValid$227755[esp+180], 1
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	edx, eax

; 5770 : 			if (bValid && bonusInfo->IsMustBeArt() && iCountArtifact > 0)

	cmp	BYTE PTR [edx+34], 0
	mov	DWORD PTR _bonusInfo$227756[esp+176], edx
	je	SHORT $LN643@GetTheming
	cmp	DWORD PTR _iCountArtifact$[esp+176], 0

; 5771 : 			{
; 5772 : 				bValid = false;
; 5773 : 			}
; 5774 : 			if (bValid && bonusInfo->IsMustBeArtifact() && iCountArt > 0)

	jg	$LN637@GetTheming
$LN643@GetTheming:
	cmp	BYTE PTR [edx+35], 0
	je	SHORT $LN629@GetTheming
	test	edi, edi

; 5775 : 			{
; 5776 : 				bValid = false;
; 5777 : 			}
; 5778 : 			if (bValid && bonusInfo->IsMustBeEqualArtArtifact() && iCountArt != iCountArtifact)

	jg	$LN637@GetTheming
$LN629@GetTheming:
	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN630@GetTheming
	cmp	edi, DWORD PTR _iCountArtifact$[esp+176]

; 5779 : 			{
; 5780 : 				bValid = false;
; 5781 : 			}
; 5782 : 
; 5783 : 			// Can we rule this out based on era?
; 5784 : 			if (bValid && bonusInfo->IsSameEra())

	jne	$LN637@GetTheming
$LN630@GetTheming:
	cmp	BYTE PTR [edx+32], 0
	je	SHORT $LN636@GetTheming

; 5785 : 			{
; 5786 : 				int eFirstEra = aErasSeen[0];
; 5787 : 				for (unsigned int kK = 1; kK < aErasSeen.size(); kK++)

	mov	eax, DWORD PTR _aErasSeen$[esp+184]
	mov	edi, DWORD PTR [ebx]
	sub	eax, ebx
	mov	ecx, 1
	sar	eax, 2
	cmp	eax, ecx
	jbe	SHORT $LN636@GetTheming
$LL32@GetTheming:

; 5788 : 				{
; 5789 : 					if (aErasSeen[kK] != eFirstEra)

	cmp	DWORD PTR [ebx+ecx*4], edi
	je	SHORT $LN31@GetTheming

; 5790 : 					{
; 5791 : 						bValid = false;

	mov	BYTE PTR _bValid$227755[esp+176], 0
$LN31@GetTheming:

; 5785 : 			{
; 5786 : 				int eFirstEra = aErasSeen[0];
; 5787 : 				for (unsigned int kK = 1; kK < aErasSeen.size(); kK++)

	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL32@GetTheming

; 5792 : 					}
; 5793 : 				}
; 5794 : 			}
; 5795 : 			if (bValid && bonusInfo->IsUniqueEras())

	cmp	BYTE PTR _bValid$227755[esp+176], 0
	je	$LN637@GetTheming
$LN636@GetTheming:
	cmp	BYTE PTR [edx+33], 0
	je	$LN28@GetTheming

; 5796 : 			{
; 5797 : 				vector<EraTypes> aProcessedEras;

	xor	eax, eax
	mov	DWORD PTR _aProcessedEras$227772[esp+180], eax
	mov	DWORD PTR _aProcessedEras$227772[esp+184], eax
	mov	DWORD PTR _aProcessedEras$227772[esp+188], eax

; 5798 : 				aProcessedEras.push_back(aErasSeen[0]);

	mov	edi, DWORD PTR _aErasSeen$[esp+180]
	push	edi
	push	1
	push	eax
	lea	ecx, DWORD PTR _aProcessedEras$227772[esp+188]
	mov	BYTE PTR __$EHRec$[esp+196], 3
	call	?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n

; 5799 : 				for (unsigned int kK = 1; kK < aErasSeen.size(); kK++)

	mov	ebp, DWORD PTR _aErasSeen$[esp+184]
	sub	ebp, edi
	mov	edi, DWORD PTR _aProcessedEras$227772[esp+180]
	mov	ebx, 1
	sar	ebp, 2
	cmp	ebp, ebx
	jbe	$LN25@GetTheming
	mov	esi, DWORD PTR _aProcessedEras$227772[esp+184]
	npad	2
$LL27@GetTheming:

; 5800 : 				{
; 5801 : 					EraTypes eEra = aErasSeen[kK];

	mov	edx, DWORD PTR _aErasSeen$[esp+180]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR _eEra$227777[esp+176], ecx

; 5802 : 					if (std::find(aProcessedEras.begin(), aProcessedEras.end(), eEra) != aProcessedEras.end())

	mov	eax, edi
	cmp	edi, esi
	je	SHORT $LN24@GetTheming
$LL298@GetTheming:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN614@GetTheming
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL298@GetTheming
$LN24@GetTheming:

; 5807 : 					{
; 5808 : 						aProcessedEras.push_back(eEra);

	test	edi, edi
	jne	SHORT $LN320@GetTheming
	xor	eax, eax
	jmp	SHORT $LN321@GetTheming
$LN614@GetTheming:

; 5802 : 					if (std::find(aProcessedEras.begin(), aProcessedEras.end(), eEra) != aProcessedEras.end())

	cmp	eax, esi
	je	SHORT $LN24@GetTheming

; 5803 : 					{
; 5804 : 						bValid = false;

	mov	BYTE PTR _bValid$227755[esp+176], 0

; 5805 : 					}
; 5806 : 					else

	jmp	SHORT $LN26@GetTheming

; 5807 : 					{
; 5808 : 						aProcessedEras.push_back(eEra);

$LN320@GetTheming:
	mov	eax, DWORD PTR _aProcessedEras$227772[esp+188]
	sub	eax, edi
	sar	eax, 2
$LN321@GetTheming:
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 2
	cmp	ecx, eax
	lea	ecx, DWORD PTR _aProcessedEras$227772[esp+176]
	jae	SHORT $LN313@GetTheming
	mov	eax, DWORD PTR __Cat$257951[esp+176]
	mov	BYTE PTR $T257948[esp+176], 0
	mov	edx, DWORD PTR $T257948[esp+176]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _eEra$227777[esp+188]
	push	edx
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
	add	esp, 24					; 00000018H
	add	esi, 4
	mov	DWORD PTR _aProcessedEras$227772[esp+184], esi
	jmp	SHORT $LN26@GetTheming
$LN313@GetTheming:
	lea	eax, DWORD PTR _eEra$227777[esp+176]
	push	eax
	push	1
	push	esi
	call	?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n
	mov	esi, DWORD PTR _aProcessedEras$227772[esp+184]
	mov	edi, DWORD PTR _aProcessedEras$227772[esp+180]
$LN26@GetTheming:
	inc	ebx
	cmp	ebx, ebp
	jb	$LL27@GetTheming

; 5799 : 				for (unsigned int kK = 1; kK < aErasSeen.size(); kK++)

	mov	esi, DWORD PTR _aPlayersSeen$[esp+180]
$LN25@GetTheming:

; 5809 : 					}
; 5810 : 				}
; 5811 : 			}

	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+184], 1
	cmp	edi, ebx
	je	SHORT $LN365@GetTheming
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN365@GetTheming:
	mov	ebp, DWORD PTR _aPlayersSeen$[esp+184]
	mov	edx, DWORD PTR _bonusInfo$227756[esp+176]
	mov	DWORD PTR _aProcessedEras$227772[esp+180], ebx
	mov	DWORD PTR _aProcessedEras$227772[esp+184], ebx
	mov	DWORD PTR _aProcessedEras$227772[esp+188], ebx
	mov	ebx, DWORD PTR _aErasSeen$[esp+180]
$LN28@GetTheming:

; 5812 : 
; 5813 : 			// Can we rule this out based on player?
; 5814 : 			if (bValid && bonusInfo->IsRequiresOwner())

	cmp	BYTE PTR _bValid$227755[esp+176], 0
	je	$LN637@GetTheming
	cmp	BYTE PTR [edx+37], 0
	je	SHORT $LN639@GetTheming

; 5815 : 			{
; 5816 : 				for (unsigned int kK = 0; kK < aPlayersSeen.size(); kK++)

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	xor	ecx, ecx
	test	eax, eax
	jbe	SHORT $LN639@GetTheming
	mov	edi, DWORD PTR _eOwner$[esp+172]
$LL21@GetTheming:

; 5817 : 				{
; 5818 : 					if (aPlayersSeen[kK] != eOwner)

	cmp	DWORD PTR [esi+ecx*4], edi
	je	SHORT $LN20@GetTheming

; 5819 : 					{
; 5820 : 						bValid = false;

	mov	BYTE PTR _bValid$227755[esp+176], 0
$LN20@GetTheming:

; 5815 : 			{
; 5816 : 				for (unsigned int kK = 0; kK < aPlayersSeen.size(); kK++)

	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL21@GetTheming
$LN639@GetTheming:

; 5821 : 					}
; 5822 : 				}
; 5823 : 			}
; 5824 : 			if (bValid && bonusInfo->IsRequiresSamePlayer())

	cmp	BYTE PTR _bValid$227755[esp+176], 0
	je	$LN637@GetTheming
	cmp	BYTE PTR [edx+39], 0
	je	SHORT $LN640@GetTheming

; 5825 : 			{
; 5826 : 				int eFirstPlayer = aPlayersSeen[0];

	mov	edi, DWORD PTR [esi]

; 5827 : 				for (unsigned int kK = 1; kK < aPlayersSeen.size(); kK++)

	mov	eax, ebp
	sub	eax, esi
	mov	ecx, 1
	sar	eax, 2
	cmp	eax, ecx
	jbe	SHORT $LN640@GetTheming
$LL16@GetTheming:

; 5828 : 				{
; 5829 : 					if (aPlayersSeen[kK] != eFirstPlayer)

	cmp	DWORD PTR [esi+ecx*4], edi
	je	SHORT $LN15@GetTheming

; 5830 : 					{
; 5831 : 						bValid = false;

	mov	BYTE PTR _bValid$227755[esp+176], 0
$LN15@GetTheming:

; 5827 : 				for (unsigned int kK = 1; kK < aPlayersSeen.size(); kK++)

	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL16@GetTheming
$LN640@GetTheming:

; 5832 : 					}
; 5833 : 				}
; 5834 : 			}
; 5835 : 			if (bValid && bonusInfo->IsRequiresUniquePlayers())

	cmp	BYTE PTR _bValid$227755[esp+176], 0
	je	$LN637@GetTheming
	cmp	BYTE PTR [edx+40], 0
	je	$LN12@GetTheming

; 5836 : 			{
; 5837 : 				vector<PlayerTypes> aProcessedPlayers;

	xor	eax, eax
	mov	DWORD PTR _aProcessedPlayers$227802[esp+180], eax
	mov	DWORD PTR _aProcessedPlayers$227802[esp+184], eax
	mov	DWORD PTR _aProcessedPlayers$227802[esp+188], eax

; 5838 : 				aProcessedPlayers.push_back(aPlayersSeen[0]);

	push	esi
	push	1
	push	eax
	lea	ecx, DWORD PTR _aProcessedPlayers$227802[esp+188]
	mov	BYTE PTR __$EHRec$[esp+196], 4
	call	?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n

; 5839 : 				for (unsigned int kK = 1; kK < aPlayersSeen.size(); kK++)

	mov	ebp, DWORD PTR _aPlayersSeen$[esp+184]
	mov	edi, DWORD PTR _aProcessedPlayers$227802[esp+180]
	sub	ebp, esi
	mov	ebx, 1
	sar	ebp, 2
	cmp	ebp, ebx
	jbe	$LN9@GetTheming
	mov	esi, DWORD PTR _aProcessedPlayers$227802[esp+184]
	npad	3
$LL11@GetTheming:

; 5840 : 				{
; 5841 : 					PlayerTypes ePlayer = aPlayersSeen[kK];

	mov	ecx, DWORD PTR _aPlayersSeen$[esp+180]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR _ePlayer$227807[esp+176], ecx

; 5842 : 					if (std::find(aProcessedPlayers.begin(), aProcessedPlayers.end(), ePlayer) != aProcessedPlayers.end())

	mov	eax, edi
	cmp	edi, esi
	je	SHORT $LN8@GetTheming
$LL501@GetTheming:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN615@GetTheming
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL501@GetTheming
$LN8@GetTheming:

; 5847 : 					{
; 5848 : 						aProcessedPlayers.push_back(ePlayer);

	test	edi, edi
	jne	SHORT $LN523@GetTheming
	xor	eax, eax
	jmp	SHORT $LN524@GetTheming
$LN615@GetTheming:

; 5842 : 					if (std::find(aProcessedPlayers.begin(), aProcessedPlayers.end(), ePlayer) != aProcessedPlayers.end())

	cmp	eax, esi
	je	SHORT $LN8@GetTheming

; 5843 : 					{
; 5844 : 						bValid = false;

	mov	BYTE PTR _bValid$227755[esp+176], 0

; 5845 : 					}
; 5846 : 					else

	jmp	SHORT $LN10@GetTheming

; 5847 : 					{
; 5848 : 						aProcessedPlayers.push_back(ePlayer);

$LN523@GetTheming:
	mov	eax, DWORD PTR _aProcessedPlayers$227802[esp+188]
	sub	eax, edi
	sar	eax, 2
$LN524@GetTheming:
	mov	edx, esi
	sub	edx, edi
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN516@GetTheming
	mov	ecx, DWORD PTR __Cat$258673[esp+176]
	mov	BYTE PTR $T258670[esp+176], 0
	mov	eax, DWORD PTR $T258670[esp+176]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _aProcessedPlayers$227802[esp+184]
	push	edx
	lea	eax, DWORD PTR _ePlayer$227807[esp+188]
	push	eax
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
	add	esp, 24					; 00000018H
	add	esi, 4
	mov	DWORD PTR _aProcessedPlayers$227802[esp+184], esi
	jmp	SHORT $LN10@GetTheming
$LN516@GetTheming:
	lea	ecx, DWORD PTR _ePlayer$227807[esp+176]
	push	ecx
	push	1
	push	esi
	lea	ecx, DWORD PTR _aProcessedPlayers$227802[esp+188]
	call	?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n
	mov	esi, DWORD PTR _aProcessedPlayers$227802[esp+184]
	mov	edi, DWORD PTR _aProcessedPlayers$227802[esp+180]
$LN10@GetTheming:
	inc	ebx
	cmp	ebx, ebp
	jb	$LL11@GetTheming

; 5839 : 				for (unsigned int kK = 1; kK < aPlayersSeen.size(); kK++)

	mov	esi, DWORD PTR _aPlayersSeen$[esp+180]
$LN9@GetTheming:

; 5849 : 					}
; 5850 : 				}
; 5851 : 			}

	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+184], 1
	cmp	edi, ebx
	je	SHORT $LN568@GetTheming
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN568@GetTheming:
	mov	ebp, DWORD PTR _aPlayersSeen$[esp+184]
	mov	edx, DWORD PTR _bonusInfo$227756[esp+176]
	mov	DWORD PTR _aProcessedPlayers$227802[esp+180], ebx
	mov	DWORD PTR _aProcessedPlayers$227802[esp+184], ebx
	mov	DWORD PTR _aProcessedPlayers$227802[esp+188], ebx
	mov	ebx, DWORD PTR _aErasSeen$[esp+180]
$LN12@GetTheming:

; 5852 : 			if (bValid && bonusInfo->IsRequiresAnyButOwner())

	cmp	BYTE PTR _bValid$227755[esp+176], 0
	je	SHORT $LN637@GetTheming
	cmp	BYTE PTR [edx+38], 0
	je	SHORT $LN641@GetTheming

; 5853 : 			{
; 5854 : 				for (unsigned int kK = 0; kK < aPlayersSeen.size(); kK++)

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	xor	ecx, ecx
	test	eax, eax
	jbe	SHORT $LN641@GetTheming
	mov	edx, DWORD PTR _eOwner$[esp+172]
$LL5@GetTheming:

; 5855 : 				{
; 5856 : 					if (aPlayersSeen[kK] == eOwner)

	cmp	DWORD PTR [esi+ecx*4], edx
	jne	SHORT $LN4@GetTheming

; 5857 : 					{
; 5858 : 						bValid = false;

	mov	BYTE PTR _bValid$227755[esp+176], 0
$LN4@GetTheming:

; 5853 : 			{
; 5854 : 				for (unsigned int kK = 0; kK < aPlayersSeen.size(); kK++)

	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL5@GetTheming
$LN641@GetTheming:

; 5859 : 					}
; 5860 : 				}
; 5861 : 			}
; 5862 : 
; 5863 : 			// Haven't ruled it out?  Then this is it (ASSUMES THEMING BONUSES FOR A BUILDING ARE IN SORTED ORDER IN DB!)
; 5864 : 			if (bValid)

	cmp	BYTE PTR _bValid$227755[esp+176], 0
	jne	SHORT $LN616@GetTheming
$LN637@GetTheming:

; 5764 : 		for (int jJ = 0; jJ < iNumThemes; jJ++)

	mov	ecx, DWORD PTR _jJ$227751[esp+176]
	inc	ecx
	cmp	ecx, DWORD PTR _iNumThemes$227750[esp+176]
	mov	DWORD PTR _jJ$227751[esp+176], ecx
	jl	$LL642@GetTheming
$LN37@GetTheming:

; 5867 : 			}
; 5868 : 		}
; 5869 : 	}
; 5870 : 	return -1;

	test	esi, esi
	je	SHORT $LN595@GetTheming
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN595@GetTheming:
	test	ebx, ebx
	je	SHORT $LN602@GetTheming
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN602@GetTheming:
	or	eax, -1
$LN48@GetTheming:

; 5871 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+176]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 160				; 000000a0H
	ret	0
$LN616@GetTheming:

; 5865 : 			{
; 5866 : 				return jJ;

	test	esi, esi
	je	SHORT $LN581@GetTheming
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN581@GetTheming:
	test	ebx, ebx
	je	SHORT $LN588@GetTheming
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN588@GetTheming:
	mov	eax, DWORD PTR _jJ$227751[esp+176]
	jmp	SHORT $LN48@GetTheming
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aErasSeen$[ebp]
	jmp	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$1:
	lea	ecx, DWORD PTR _aPlayersSeen$[ebp]
	jmp	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$2:
	lea	ecx, DWORD PTR _work$227746[ebp]
	jmp	??1CvGreatWork@@QAE@XZ
__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$3:
	lea	ecx, DWORD PTR _aProcessedEras$227772[ebp]
	jmp	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
__unwindfunclet$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z$4:
	lea	ecx, DWORD PTR _aProcessedPlayers$227802[ebp]
	jmp	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
__ehhandler$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; CultureHelpers::GetThemingBonusIndex
PUBLIC	?push_back@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkBuildingInMyEmpire@@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkBuildingInMyEmpire@@@Z
_TEXT	SEGMENT
$T258902 = -4						; size = 1
__Cat$258905 = 8					; size = 1
$T258871 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkBuildingInMyEmpire@@@Z PROC ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@7
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@7
$LN9@push_back@7:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@7:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$258905[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T258902[esp+16], 0
	mov	ecx, DWORD PTR $T258902[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvGreatWorkBuildingInMyEmpire@@IV1@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@YAXPAVCvGreatWorkBuildingInMyEmpire@@IABV1@AAV?$allocator@VCvGreatWorkBuildingInMyEmpire@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvGreatWorkBuildingInMyEmpire *,unsigned int,CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@7:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T258871[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@V?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@2@ABVCvGreatWorkBuildingInMyEmpire@@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkBuildingInMyEmpire@@@Z ENDP ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::push_back
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
__Mid$230475 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 3245 : 	_Diff _Count;
; 3246 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Pred$[esp+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+24]
	mov	edx, ecx
	sub	edx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 32					; 00000020H
	jle	$LN41@Sort
	mov	esi, DWORD PTR __Ideal$[esp+24]
$LL7@Sort:
	test	esi, esi
	jle	$LN6@Sort

; 3247 : 		{	// divide and conquer by quicksort
; 3248 : 		pair<_RanIt, _RanIt> _Mid =
; 3249 : 			std::_Unguarded_partition(_First, _Last, _Pred);

	push	ebp
	push	ecx
	lea	eax, DWORD PTR __Mid$230475[esp+36]
	push	edi
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YA?AU?$pair@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 3250 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3251 : 
; 3252 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	edi, DWORD PTR __Mid$230475[esp+48]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	mov	ebx, DWORD PTR __Mid$230475[esp+44]
	sar	eax, 1
	add	esi, eax
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __First$[esp+40]
	mov	DWORD PTR tv92[esp+44], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR tv92[esp+44]
	sar	edx, 1
	mov	ecx, edx
	add	esp, 16					; 00000010H
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, eax

; 3253 : 			{	// loop on second half
; 3254 : 			std::_Sort(_First, _Mid.first, _Ideal, _Pred);

	push	ebp
	push	esi
	jge	SHORT $LN5@Sort
	mov	edx, DWORD PTR __First$[esp+32]
	push	ebx
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 3255 : 			_First = _Mid.second;
; 3256 : 			}
; 3257 : 		else

	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	DWORD PTR __First$[esp+40], edi
	jmp	SHORT $LN42@Sort
$LN5@Sort:

; 3258 : 			{	// loop on first half
; 3259 : 			std::_Sort(_Mid.second, _Last, _Ideal, _Pred);

	mov	eax, DWORD PTR __Last$[esp+32]
	push	eax
	push	edi
	call	??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 3260 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, ebx
	mov	DWORD PTR __Last$[esp+40], ecx
$LN42@Sort:
	mov	edx, ecx
	sub	edx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esp, 16					; 00000010H
	cmp	eax, 32					; 00000020H
	jg	$LL7@Sort
$LN41@Sort:

; 3268 : 		}
; 3269 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN35@Sort

; 3270 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	push	ebp
	push	ecx
	push	edi
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@ZV3@@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAV2@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &),CvGreatWorkBuildingInMyEmpire>
	add	esp, 16					; 00000010H
$LN35@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3271 : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN6@Sort:

; 3261 : 			}
; 3262 : 		}
; 3263 : 
; 3264 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN41@Sort

; 3265 : 		{	// heap sort if too many divisions
; 3266 : 		std::make_heap(_First, _Last, _Pred);

	mov	edx, ecx
	sub	edx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jle	SHORT $LN22@Sort
	push	0
	push	0
	push	ebp
	push	ecx
	push	edi
	call	??$_Make_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HVCvGreatWorkBuildingInMyEmpire@@P6A_NABV3@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@ZPAHPAV2@@Z ; std::_Make_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,CvGreatWorkBuildingInMyEmpire,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	mov	ecx, DWORD PTR __Last$[esp+44]
	mov	edi, DWORD PTR __First$[esp+44]
	add	esp, 20					; 00000014H
$LN22@Sort:

; 3267 : 		std::sort_heap(_First, _Last, _Pred);

	push	ebp
	push	ecx
	push	edi
	call	??$_Sort_heap@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort_heap<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3271 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	?DoTurn@CvGameCulture@@QAEXXZ			; CvGameCulture::DoTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
;	COMDAT ?DoTurn@CvGameCulture@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvGameCulture@@QAEXXZ PROC			; CvGameCulture::DoTurn, COMDAT
; _this$ = ecx

; 118  : {

	push	esi

; 119  : 	for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	xor	esi, esi
	npad	13
$LL4@DoTurn@2:

; 120  : 	{
; 121  : 		PlayerTypes ePlayer = (PlayerTypes)uiPlayer;
; 122  : 		CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 123  : 		if (kPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN3@DoTurn@2

; 124  : 		{
; 125  : 			kPlayer.GetCulture()->DoTurn();

	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoTurn@CvPlayerCulture@@QAEXXZ		; CvPlayerCulture::DoTurn
$LN3@DoTurn@2:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jb	SHORT $LL4@DoTurn@2
	pop	esi

; 126  : 		}
; 127  : 	}
; 128  : }

	ret	0
?DoTurn@CvGameCulture@@QAEXXZ ENDP			; CvGameCulture::DoTurn
_TEXT	ENDS
PUBLIC	?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z ; CvPlayerCulture::ThemeEqualArtArtifact
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
_pkBonusInfo$ = -160					; size = 4
_it3$224959 = -156					; size = 4
_aWorksChosen$224944 = -152				; size = 16
_it$ = -136						; size = 4
_tempWorks$ = -132					; size = 16
_pkEntry$ = -116					; size = 4
$T260936 = -112						; size = 1
_iToBeAcquiredWorkIndex$225154 = -112			; size = 4
_aArtifactsChosen$ = -108				; size = 16
_iLoopPlayer$225146 = -92				; size = 4
_aArtifactsErasSeen$ = -88				; size = 16
_aPlayersSeen$224949 = -72				; size = 16
_aErasSeen$224954 = -56					; size = 16
tv3578 = -40						; size = 4
_pkGameCulture$ = -36					; size = 4
_iWorksInHalf$ = -32					; size = 4
_aArtifactsPlayersSeen$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_kBldg$ = 8						; size = 12
_iThemingBonusIndex$ = 20				; size = 4
_iNumSlots$ = 24					; size = 4
_works1$ = 28						; size = 4
_works2$ = 32						; size = 4
___formal$ = 36						; size = 1
?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z PROC ; CvPlayerCulture::ThemeEqualArtArtifact, COMDAT
; _this$ = ecx

; 1546 : {

	push	-1
	push	__ehhandler$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+176], ecx

; 1547 : 	CvGameCulture *pkGameCulture = GC.getGame().GetGameCulture();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture

; 1548 : 
; 1549 : 	vector<CvGreatWorkInMyEmpire>::const_iterator it;
; 1550 : 	vector<CvGreatWorkInMyEmpire>::iterator it5;
; 1551 : 	vector<CvGreatWorkInMyEmpire> tempWorks;

	xor	edi, edi
	mov	DWORD PTR _pkGameCulture$[esp+180], eax
	mov	DWORD PTR _tempWorks$[esp+184], edi
	mov	DWORD PTR _tempWorks$[esp+188], edi
	mov	DWORD PTR _tempWorks$[esp+192], edi
	mov	DWORD PTR __$EHRec$[esp+188], edi

; 1552 : 
; 1553 : 	vector<int> aArtifactsChosen;

	mov	DWORD PTR _aArtifactsChosen$[esp+184], edi
	mov	DWORD PTR _aArtifactsChosen$[esp+188], edi
	mov	DWORD PTR _aArtifactsChosen$[esp+192], edi

; 1554 : 	vector<PlayerTypes> aArtifactsPlayersSeen;

	mov	DWORD PTR _aArtifactsPlayersSeen$[esp+184], edi
	mov	DWORD PTR _aArtifactsPlayersSeen$[esp+188], edi
	mov	DWORD PTR _aArtifactsPlayersSeen$[esp+192], edi

; 1555 : 	vector<EraTypes> aArtifactsErasSeen;

	mov	DWORD PTR _aArtifactsErasSeen$[esp+184], edi
	mov	DWORD PTR _aArtifactsErasSeen$[esp+188], edi
	mov	DWORD PTR _aArtifactsErasSeen$[esp+192], edi

; 1556 : 
; 1557 : #ifdef AUI_WARNING_FIXES
; 1558 : 	uint iWorksInHalf = iNumSlots >> 1;
; 1559 : 	if (iWorksInHalf >> 1 != 0 || works1.size() < iWorksInHalf || works2.size() < iWorksInHalf)
; 1560 : #else
; 1561 : 	int iWorksInHalf = iNumSlots / 2;

	mov	eax, DWORD PTR _iNumSlots$[esp+176]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1

; 1562 : 	if (iWorksInHalf % 2 != 0 || (int)works1.size() < iWorksInHalf || (int)works2.size() < iWorksInHalf)

	mov	eax, esi
	and	eax, -2147483647			; 80000001H
	mov	BYTE PTR __$EHRec$[esp+188], 3
	mov	DWORD PTR _iWorksInHalf$[esp+180], esi
	jns	SHORT $LN1179@ThemeEqual
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN1179@ThemeEqual:
	jne	$LN59@ThemeEqual
	mov	eax, DWORD PTR _works1$[esp+176]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, esi
	jl	$LN59@ThemeEqual
	mov	ebx, DWORD PTR _works2$[esp+176]
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jl	$LN59@ThemeEqual

; 1566 : 	}
; 1567 : 
; 1568 : 	CvBuildingEntry *pkEntry = GC.getBuildingInfo(kBldg.m_eBuilding);

	mov	ecx, DWORD PTR _kBldg$[esp+180]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax
	mov	DWORD PTR _pkEntry$[esp+180], esi

; 1569 : 	if (!pkEntry || pkEntry->GetGreatWorkCount() < 2)

	cmp	esi, edi
	je	$LN57@ThemeEqual
	mov	ecx, esi
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	cmp	eax, 2
	jl	$LN57@ThemeEqual

; 1572 : 	}
; 1573 : 
; 1574 : 	CvThemingBonusInfo *pkBonusInfo = pkEntry->GetThemingBonusInfo(iThemingBonusIndex);

	mov	edx, DWORD PTR _iThemingBonusIndex$[esp+176]
	push	edx
	mov	ecx, esi
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo

; 1575 : 
; 1576 : 	// Try each of the Artifacts as the starter
; 1577 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1578 : 	for (it = works2.begin(); it != works2.end(); ++it)
; 1579 : #else
; 1580 : 	for (it = works2.begin(); it != works2.end(); it++)

	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR _pkBonusInfo$[esp+180], eax
	mov	DWORD PTR _it$[esp+180], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	je	$LN59@ThemeEqual
	npad	9
$LL263@ThemeEqual:

; 1581 : #endif
; 1582 : 	{
; 1583 : 		// First, make sure this "starter" is valid
; 1584 : 		if (pkBonusInfo->IsRequiresOwner() && it->m_ePlayer != m_pPlayer->GetID())

	mov	eax, DWORD PTR _pkBonusInfo$[esp+180]
	cmp	BYTE PTR [eax+37], 0
	je	SHORT $LN53@ThemeEqual
	mov	ecx, DWORD PTR _this$[esp+180]
	mov	edx, DWORD PTR [ecx+292]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [ebp+16], eax
	jne	$LN55@ThemeEqual
$LN53@ThemeEqual:

; 1585 : 		{
; 1586 : 			continue;
; 1587 : 		}
; 1588 : 		if (pkBonusInfo->IsRequiresAnyButOwner() && it->m_ePlayer == m_pPlayer->GetID())

	mov	eax, DWORD PTR _pkBonusInfo$[esp+180]
	cmp	BYTE PTR [eax+38], 0
	je	SHORT $LN52@ThemeEqual
	mov	ecx, DWORD PTR _this$[esp+180]
	mov	edx, DWORD PTR [ecx+292]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [ebp+16], eax
	je	$LN55@ThemeEqual
$LN52@ThemeEqual:

; 1589 : 		{
; 1590 : 			continue;
; 1591 : 		}
; 1592 : 
; 1593 : 		aArtifactsChosen.clear();

	lea	ecx, DWORD PTR _aArtifactsChosen$[esp+180]
	call	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 1594 : 		aArtifactsPlayersSeen.clear();

	lea	ecx, DWORD PTR _aArtifactsPlayersSeen$[esp+180]
	call	?clear@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXXZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::clear

; 1595 : 		aArtifactsErasSeen.clear();

	lea	ecx, DWORD PTR _aArtifactsErasSeen$[esp+180]
	call	?clear@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXXZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::clear

; 1596 : 
; 1597 : 		aArtifactsChosen.push_back(it->m_iGreatWorkIndex);

	push	ebp
	lea	ecx, DWORD PTR _aArtifactsChosen$[esp+184]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
	lea	eax, DWORD PTR [ebp+16]

; 1598 : 		aArtifactsPlayersSeen.push_back(it->m_ePlayer);

	push	eax
	lea	ecx, DWORD PTR _aArtifactsPlayersSeen$[esp+184]
	call	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back
	lea	ecx, DWORD PTR [ebp+20]

; 1599 : 		aArtifactsErasSeen.push_back(it->m_eEra);

	push	ecx
	lea	ecx, DWORD PTR _aArtifactsErasSeen$[esp+184]
	call	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back

; 1600 : 
; 1601 : 		// Loop through the rest looking for works that will match up
; 1602 : 		vector<CvGreatWorkInMyEmpire>::const_iterator it2 = it;
; 1603 : #ifdef AUI_WARNING_FIXES
; 1604 : 		for (++it2; it2 != works2.end() && aArtifactsChosen.size() < iWorksInHalf; ++it2)
; 1605 : #elif defined(AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS)
; 1606 : 		for (++it2; it2 != works2.end() && aArtifactsChosen.size() < (unsigned int)iWorksInHalf; ++it2)
; 1607 : #else
; 1608 : 		for (it2++; it2 != works2.end() && aArtifactsChosen.size() < (unsigned int)iWorksInHalf; it2++)

	mov	edx, DWORD PTR _works2$[esp+176]
	mov	ebx, DWORD PTR _aArtifactsChosen$[esp+188]
	lea	esi, DWORD PTR [ebp+24]
	cmp	esi, DWORD PTR [edx+8]
	je	$LN49@ThemeEqual
	npad	4
$LL313@ThemeEqual:
	mov	eax, ebx
	sub	eax, DWORD PTR _aArtifactsChosen$[esp+184]
	sar	eax, 2
	cmp	eax, DWORD PTR _iWorksInHalf$[esp+180]
	jae	SHORT $LN49@ThemeEqual

; 1609 : #endif
; 1610 : 		{
; 1611 : 			if (CultureHelpers::IsValidForThemingBonus(pkBonusInfo, it2->m_eEra, aArtifactsErasSeen, it2->m_ePlayer, aArtifactsPlayersSeen, m_pPlayer->GetID()))

	mov	ecx, DWORD PTR _this$[esp+180]
	mov	edx, DWORD PTR [ecx+292]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [esi+16]
	push	eax
	lea	eax, DWORD PTR _aArtifactsPlayersSeen$[esp+184]
	push	eax
	mov	eax, DWORD PTR [esi+20]
	lea	edi, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, DWORD PTR _pkBonusInfo$[esp+192]
	lea	edx, DWORD PTR _aArtifactsErasSeen$[esp+192]
	lea	ebp, DWORD PTR [esi+20]
	push	edx
	push	eax
	push	ecx
	call	?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ; CultureHelpers::IsValidForThemingBonus
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN50@ThemeEqual

; 1612 : 			{
; 1613 : 				aArtifactsChosen.push_back(it2->m_iGreatWorkIndex);

	push	esi
	lea	ecx, DWORD PTR _aArtifactsChosen$[esp+184]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 1614 : 				aArtifactsPlayersSeen.push_back(it2->m_ePlayer);

	push	edi
	lea	ecx, DWORD PTR _aArtifactsPlayersSeen$[esp+184]
	call	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back

; 1615 : 				aArtifactsErasSeen.push_back(it2->m_eEra);

	push	ebp
	lea	ecx, DWORD PTR _aArtifactsErasSeen$[esp+184]
	call	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back
	mov	ebx, DWORD PTR _aArtifactsChosen$[esp+188]
$LN50@ThemeEqual:
	mov	edx, DWORD PTR _works2$[esp+176]
	mov	ebp, DWORD PTR _it$[esp+180]
	add	esi, 24					; 00000018H
	xor	edi, edi
	cmp	esi, DWORD PTR [edx+8]
	jne	$LL313@ThemeEqual
$LN49@ThemeEqual:

; 1616 : 			}
; 1617 : 		}
; 1618 : 
; 1619 : 		// Do we have the right amount of art?
; 1620 : 		if (aArtifactsChosen.size() == iWorksInHalf)

	sub	ebx, DWORD PTR _aArtifactsChosen$[esp+184]
	sar	ebx, 2
	cmp	ebx, DWORD PTR _iWorksInHalf$[esp+180]
	jne	$LN55@ThemeEqual

; 1621 : 		{
; 1622 : 			vector<int> aWorksChosen;

	mov	DWORD PTR _aWorksChosen$224944[esp+184], edi
	mov	DWORD PTR _aWorksChosen$224944[esp+188], edi
	mov	DWORD PTR _aWorksChosen$224944[esp+192], edi

; 1623 : 			vector<PlayerTypes> aPlayersSeen;

	mov	DWORD PTR _aPlayersSeen$224949[esp+184], edi
	mov	DWORD PTR _aPlayersSeen$224949[esp+188], edi
	mov	DWORD PTR _aPlayersSeen$224949[esp+192], edi

; 1624 : 			vector<EraTypes> aErasSeen;

	mov	DWORD PTR _aErasSeen$224954[esp+184], edi
	mov	DWORD PTR _aErasSeen$224954[esp+188], edi
	mov	DWORD PTR _aErasSeen$224954[esp+192], edi

; 1625 : 
; 1626 : 			// Now see if we can get the right number of art works to work as well
; 1627 : 			vector<CvGreatWorkInMyEmpire>::const_iterator it3;
; 1628 : #ifdef AUI_WARNING_FIXES
; 1629 : 			for (it3 = works1.begin(); it3 != works1.end() && aWorksChosen.size() < iNumSlots; ++it3)
; 1630 : #elif defined(AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS)
; 1631 : 			for (it3 = works1.begin(); it3 != works1.end() && aWorksChosen.size() < (unsigned int)iNumSlots; ++it3)
; 1632 : #else
; 1633 : 			for (it3 = works1.begin(); it3 != works1.end() && aWorksChosen.size() < (unsigned int)iNumSlots; it3++)

	mov	ecx, DWORD PTR _works1$[esp+176]
	mov	eax, DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[esp+188], 6
	mov	DWORD PTR _it3$224959[esp+180], eax
	cmp	eax, DWORD PTR [ecx+8]
	je	$LN1163@ThemeEqual
	npad	6
$LL471@ThemeEqual:
	mov	eax, DWORD PTR _aWorksChosen$224944[esp+188]
	sub	eax, DWORD PTR _aWorksChosen$224944[esp+184]
	sar	eax, 2
	cmp	eax, DWORD PTR _iNumSlots$[esp+176]
	jae	$LN44@ThemeEqual

; 1634 : #endif
; 1635 : 			{
; 1636 : 				// First, make sure this "starter" is valid
; 1637 : 				if (pkBonusInfo->IsRequiresOwner() && it3->m_ePlayer != m_pPlayer->GetID())

	mov	ecx, DWORD PTR _pkBonusInfo$[esp+180]
	cmp	BYTE PTR [ecx+37], 0
	je	SHORT $LN1174@ThemeEqual
	mov	edx, DWORD PTR _this$[esp+180]
	mov	eax, DWORD PTR [edx+292]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _it3$224959[esp+180]
	cmp	DWORD PTR [ecx+16], eax
	jne	$LN45@ThemeEqual
$LN1174@ThemeEqual:

; 1638 : 				{
; 1639 : 					continue;
; 1640 : 				}
; 1641 : 				if (pkBonusInfo->IsRequiresAnyButOwner() && it3->m_ePlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR _pkBonusInfo$[esp+180]
	cmp	BYTE PTR [edx+38], 0
	je	SHORT $LN42@ThemeEqual
	mov	eax, DWORD PTR _this$[esp+180]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _it3$224959[esp+180]
	cmp	DWORD PTR [edx+16], eax
	je	$LN45@ThemeEqual
$LN42@ThemeEqual:

; 1642 : 				{
; 1643 : 					continue;
; 1644 : 				}
; 1645 : 				if (pkBonusInfo->IsSameEra() && it3->m_eEra != aArtifactsErasSeen[0])

	mov	eax, DWORD PTR _pkBonusInfo$[esp+180]
	cmp	BYTE PTR [eax+32], 0
	je	SHORT $LN1175@ThemeEqual
	mov	ecx, DWORD PTR _it3$224959[esp+180]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _aArtifactsErasSeen$[esp+184]
	cmp	edx, DWORD PTR [eax]
	jne	$LN45@ThemeEqual
$LN1175@ThemeEqual:

; 1646 : 				{
; 1647 : 					continue;
; 1648 : 				}
; 1649 : 				if (pkBonusInfo->IsUniqueEras() && find(aArtifactsErasSeen.begin(), aArtifactsErasSeen.end(), it3->m_eEra) != aArtifactsErasSeen.end())

	mov	ecx, DWORD PTR _pkBonusInfo$[esp+180]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LN1172@ThemeEqual
	mov	eax, DWORD PTR _aArtifactsErasSeen$[esp+184]
	mov	ecx, DWORD PTR _aArtifactsErasSeen$[esp+188]
	cmp	eax, ecx
	je	SHORT $LN1172@ThemeEqual
	mov	esi, DWORD PTR _it3$224959[esp+180]
	mov	edx, DWORD PTR [esi+20]
	npad	6
$LL547@ThemeEqual:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN1133@ThemeEqual
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL547@ThemeEqual
	jmp	SHORT $LN40@ThemeEqual
$LN1133@ThemeEqual:
	cmp	eax, ecx
	jne	$LN45@ThemeEqual
$LN1172@ThemeEqual:
	mov	esi, DWORD PTR _it3$224959[esp+180]
$LN40@ThemeEqual:

; 1650 : 				{
; 1651 : 					continue;
; 1652 : 				}
; 1653 : 
; 1654 : 				aWorksChosen = aArtifactsChosen;

	lea	edx, DWORD PTR _aArtifactsChosen$[esp+180]
	push	edx
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+184]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=

; 1655 : 				aPlayersSeen = aArtifactsPlayersSeen;

	lea	eax, DWORD PTR _aArtifactsPlayersSeen$[esp+180]
	push	eax
	lea	ecx, DWORD PTR _aPlayersSeen$224949[esp+184]
	call	??4?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::operator=

; 1656 : 				aErasSeen = aArtifactsErasSeen;

	lea	ecx, DWORD PTR _aArtifactsErasSeen$[esp+180]
	push	ecx
	lea	ecx, DWORD PTR _aErasSeen$224954[esp+184]
	call	??4?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::operator=

; 1657 : 
; 1658 : 				aWorksChosen.push_back(it3->m_iGreatWorkIndex);

	push	esi
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+184]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
	lea	edx, DWORD PTR [esi+16]

; 1659 : 				aPlayersSeen.push_back(it3->m_ePlayer);

	push	edx
	lea	ecx, DWORD PTR _aPlayersSeen$224949[esp+184]
	call	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back
	lea	eax, DWORD PTR [esi+20]

; 1660 : 				aErasSeen.push_back(it3->m_eEra);

	push	eax
	lea	ecx, DWORD PTR _aErasSeen$224954[esp+184]
	call	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back

; 1661 : 
; 1662 : 				// Loop through the rest looking for works that will match up
; 1663 : 				vector<CvGreatWorkInMyEmpire>::const_iterator it4 = it3;
; 1664 : #ifdef AUI_WARNING_FIXES
; 1665 : 				for (++it4; it4 != works1.end() && aWorksChosen.size() < iNumSlots; ++it4)
; 1666 : #elif defined(AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS)
; 1667 : 				for (++it4; it4 != works1.end() && aWorksChosen.size() < (unsigned int)iNumSlots; ++it4)
; 1668 : #else
; 1669 : 				for (it4++; it4 != works1.end() && aWorksChosen.size() < (unsigned int)iNumSlots; it4++)

	mov	ecx, DWORD PTR _works1$[esp+176]
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [ecx+8]
	je	$LN1161@ThemeEqual
$LL1168@ThemeEqual:
	mov	edx, DWORD PTR _aWorksChosen$224944[esp+188]
	sub	edx, DWORD PTR _aWorksChosen$224944[esp+184]
	sar	edx, 2
	cmp	edx, DWORD PTR _iNumSlots$[esp+176]
	jae	SHORT $LN1161@ThemeEqual

; 1670 : #endif
; 1671 : 				{
; 1672 : 					if (CultureHelpers::IsValidForThemingBonus(pkBonusInfo, it4->m_eEra, aErasSeen, it4->m_ePlayer, aPlayersSeen, m_pPlayer->GetID()))

	mov	eax, DWORD PTR _this$[esp+180]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR _aPlayersSeen$224949[esp+184]
	push	edx
	mov	edx, DWORD PTR [esi+20]
	lea	edi, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR _pkBonusInfo$[esp+192]
	lea	ecx, DWORD PTR _aErasSeen$224954[esp+192]
	lea	ebp, DWORD PTR [esi+20]
	push	ecx
	push	edx
	push	eax
	call	?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ; CultureHelpers::IsValidForThemingBonus
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN38@ThemeEqual

; 1673 : 					{
; 1674 : 						aWorksChosen.push_back(it4->m_iGreatWorkIndex);

	push	esi
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+184]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 1675 : 						aPlayersSeen.push_back(it4->m_ePlayer);

	push	edi
	lea	ecx, DWORD PTR _aPlayersSeen$224949[esp+184]
	call	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back

; 1676 : 						aErasSeen.push_back(it4->m_eEra);

	push	ebp
	lea	ecx, DWORD PTR _aErasSeen$224954[esp+184]
	call	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back
$LN38@ThemeEqual:
	mov	ecx, DWORD PTR _works1$[esp+176]
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LL1168@ThemeEqual
$LN1161@ThemeEqual:

; 1677 : 					}
; 1678 : 				}
; 1679 : 
; 1680 : 				// Did we theme it properly?
; 1681 : 				bool bThemedProperly = false;
; 1682 : 				if (aWorksChosen.size() == iNumSlots && CultureHelpers::GetThemingBonusIndex(m_pPlayer->GetID(), pkEntry, aWorksChosen) == iThemingBonusIndex)

	mov	esi, DWORD PTR _aWorksChosen$224944[esp+188]
	sub	esi, DWORD PTR _aWorksChosen$224944[esp+184]
	sar	esi, 2
	cmp	esi, DWORD PTR _iNumSlots$[esp+176]
	jne	SHORT $LN35@ThemeEqual
	mov	edx, DWORD PTR _this$[esp+180]
	mov	eax, DWORD PTR [edx+292]
	mov	edx, DWORD PTR _pkEntry$[esp+180]
	mov	eax, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+180]
	push	ecx
	push	edx
	push	eax
	call	?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CultureHelpers::GetThemingBonusIndex
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _iThemingBonusIndex$[esp+176]
	je	$LN1135@ThemeEqual
$LN35@ThemeEqual:

; 1683 : 				{
; 1684 : 					bThemedProperly = true;
; 1685 : 				}
; 1686 : 
; 1687 : 				// If we are one work short, let's look to other players for a last piece of art
; 1688 : 				else if (aWorksChosen.size() == (iNumSlots - 1))

	mov	eax, DWORD PTR _iNumSlots$[esp+176]
	dec	eax
	cmp	esi, eax
	jne	$LN45@ThemeEqual

; 1689 : 				{
; 1690 : 					for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	xor	edi, edi
	mov	DWORD PTR _iLoopPlayer$225146[esp+180], edi
	mov	DWORD PTR tv3578[esp+180], edi
	npad	1
$LL32@ThemeEqual:

; 1691 : 					{
; 1692 : 						CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1693 : 						if (kPlayer.isAlive() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid((PlayerTypes)iLoopPlayer))

	cmp	BYTE PTR [edi+ecx+2256], 0
	lea	esi, DWORD PTR [edi+ecx]
	je	$LN31@ThemeEqual
	mov	edx, DWORD PTR _iLoopPlayer$225146[esp+180]
	mov	eax, DWORD PTR _this$[esp+180]
	mov	ecx, DWORD PTR [eax+292]
	push	0
	push	edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	$LN31@ThemeEqual

; 1694 : 						{
; 1695 : 							int iToBeAcquiredWorkIndex = kPlayer.GetCulture()->GetSwappableArtIndex();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture

; 1696 : 							int iToBeDiscardedWorkIndex = CultureHelpers::FindWorkNotChosen(works1, aWorksChosen);

	mov	edx, DWORD PTR _works1$[esp+176]
	mov	esi, DWORD PTR [eax+280]
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+180]
	push	ecx
	push	edx
	mov	DWORD PTR _iToBeAcquiredWorkIndex$225154[esp+188], esi
	call	?FindWorkNotChosen@CultureHelpers@@YAHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z ; CultureHelpers::FindWorkNotChosen
	add	esp, 8
	mov	ebp, eax

; 1697 : 
; 1698 : 							// Does this work fit?
; 1699 : 							if (iToBeAcquiredWorkIndex != NO_GREAT_WORK && iToBeDiscardedWorkIndex != NO_GREAT_WORK)

	cmp	esi, -1
	je	$LN31@ThemeEqual
	cmp	ebp, -1
	je	$LN31@ThemeEqual

; 1700 : 							{
; 1701 : 								EraTypes eEra = pkGameCulture->m_CurrentGreatWorks[iToBeAcquiredWorkIndex].m_eEra;

	mov	ecx, DWORD PTR _pkGameCulture$[esp+180]
	mov	edx, DWORD PTR [ecx]

; 1702 : 								PlayerTypes ePlayer = pkGameCulture->GetGreatWorkCreator(iToBeAcquiredWorkIndex);
; 1703 : 								if (CultureHelpers::IsValidForThemingBonus(pkBonusInfo, eEra, aErasSeen, ePlayer, aPlayersSeen, m_pPlayer->GetID()))

	mov	ebx, DWORD PTR _this$[esp+180]
	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 4
	mov	ecx, DWORD PTR [eax+edx+40]
	mov	edi, DWORD PTR [eax+edx+44]
	add	eax, edx
	mov	eax, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	lea	edx, DWORD PTR _aPlayersSeen$224949[esp+184]
	push	edx
	push	edi
	lea	eax, DWORD PTR _aErasSeen$224954[esp+192]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pkBonusInfo$[esp+200]
	push	ecx
	call	?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ; CultureHelpers::IsValidForThemingBonus
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN1173@ThemeEqual

; 1704 : 								{
; 1705 : 									aWorksChosen.push_back(iToBeAcquiredWorkIndex);

	lea	edx, DWORD PTR _iToBeAcquiredWorkIndex$225154[esp+180]
	push	edx
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+184]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 1706 : 									if (CultureHelpers::GetThemingBonusIndex(m_pPlayer->GetID(), pkEntry, aWorksChosen) == iThemingBonusIndex)

	mov	eax, DWORD PTR [ebx+292]
	mov	edx, DWORD PTR _pkEntry$[esp+180]
	mov	eax, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _aWorksChosen$224944[esp+180]
	push	ecx
	push	edx
	push	eax
	call	?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CultureHelpers::GetThemingBonusIndex
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _iThemingBonusIndex$[esp+176]
	jne	SHORT $LN1173@ThemeEqual

; 1707 : 									{
; 1708 : 										bool bSwapSuccessful = pkGameCulture->SwapGreatWorks(m_pPlayer->GetID(), iToBeDiscardedWorkIndex, ePlayer, iToBeAcquiredWorkIndex);

	mov	eax, DWORD PTR [ebx+292]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _pkGameCulture$[esp+180]
	push	esi
	push	edi
	push	ebp
	push	eax
	call	?SwapGreatWorks@CvGameCulture@@QAE_NW4PlayerTypes@@H0H@Z ; CvGameCulture::SwapGreatWorks

; 1709 : 										if (bSwapSuccessful)

	test	al, al
	jne	$LN1134@ThemeEqual
$LN1173@ThemeEqual:
	mov	edi, DWORD PTR tv3578[esp+180]
$LN31@ThemeEqual:

; 1689 : 				{
; 1690 : 					for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	inc	DWORD PTR _iLoopPlayer$225146[esp+180]
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	mov	DWORD PTR tv3578[esp+180], edi
	jl	$LL32@ThemeEqual
$LN45@ThemeEqual:

; 1625 : 
; 1626 : 			// Now see if we can get the right number of art works to work as well
; 1627 : 			vector<CvGreatWorkInMyEmpire>::const_iterator it3;
; 1628 : #ifdef AUI_WARNING_FIXES
; 1629 : 			for (it3 = works1.begin(); it3 != works1.end() && aWorksChosen.size() < iNumSlots; ++it3)
; 1630 : #elif defined(AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS)
; 1631 : 			for (it3 = works1.begin(); it3 != works1.end() && aWorksChosen.size() < (unsigned int)iNumSlots; ++it3)
; 1632 : #else
; 1633 : 			for (it3 = works1.begin(); it3 != works1.end() && aWorksChosen.size() < (unsigned int)iNumSlots; it3++)

	mov	eax, DWORD PTR _it3$224959[esp+180]
	mov	ecx, DWORD PTR _works1$[esp+176]
	mov	ebp, DWORD PTR _it$[esp+180]
	add	eax, 24					; 00000018H
	xor	edi, edi
	mov	DWORD PTR _it3$224959[esp+180], eax
	cmp	eax, DWORD PTR [ecx+8]
	jne	$LL471@ThemeEqual
$LN44@ThemeEqual:

; 1798 : 				}
; 1799 : 			}
; 1800 : 		}

	mov	eax, DWORD PTR _aErasSeen$224954[esp+184]
	cmp	eax, edi
	je	SHORT $LN1163@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1163@ThemeEqual:
	mov	eax, DWORD PTR _aPlayersSeen$224949[esp+184]
	mov	DWORD PTR _aErasSeen$224954[esp+184], edi
	mov	DWORD PTR _aErasSeen$224954[esp+188], edi
	mov	DWORD PTR _aErasSeen$224954[esp+192], edi
	cmp	eax, edi
	je	SHORT $LN1080@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1080@ThemeEqual:
	mov	eax, DWORD PTR _aWorksChosen$224944[esp+184]
	mov	DWORD PTR _aPlayersSeen$224949[esp+184], edi
	mov	DWORD PTR _aPlayersSeen$224949[esp+188], edi
	mov	DWORD PTR _aPlayersSeen$224949[esp+192], edi
	mov	BYTE PTR __$EHRec$[esp+188], 3
	cmp	eax, edi
	je	SHORT $LN1087@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1087@ThemeEqual:
	mov	DWORD PTR _aWorksChosen$224944[esp+184], edi
	mov	DWORD PTR _aWorksChosen$224944[esp+188], edi
	mov	DWORD PTR _aWorksChosen$224944[esp+192], edi
$LN55@ThemeEqual:
	mov	edx, DWORD PTR _works2$[esp+176]
	add	ebp, 24					; 00000018H
	mov	DWORD PTR _it$[esp+180], ebp
	cmp	ebp, DWORD PTR [edx+8]
	jne	$LL263@ThemeEqual

; 1801 : 	}
; 1802 : 	return false;

	mov	eax, DWORD PTR _aArtifactsErasSeen$[esp+184]
	cmp	eax, edi
	je	SHORT $LN1094@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1094@ThemeEqual:
	mov	eax, DWORD PTR _aArtifactsPlayersSeen$[esp+184]
	cmp	eax, edi
	je	SHORT $LN1101@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1101@ThemeEqual:
	cmp	DWORD PTR _aArtifactsChosen$[esp+184], edi
	je	$LN59@ThemeEqual
	mov	eax, DWORD PTR _aArtifactsChosen$[esp+184]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	$LN59@ThemeEqual
$LN1134@ThemeEqual:

; 1710 : 										{
; 1711 : 											bThemedProperly = true;
; 1712 : 
; 1713 : 											// Update works list
; 1714 : 											tempWorks.clear();

	lea	ecx, DWORD PTR _tempWorks$[esp+180]
	call	?clear@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::clear

; 1715 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1716 : 											for (it5 = works1.begin(); it5 != works1.end(); ++it5)
; 1717 : #else
; 1718 : 											for (it5 = works1.begin(); it5 != works1.end(); it5++)

	mov	eax, DWORD PTR _works1$[esp+176]
	mov	ebx, DWORD PTR [eax+4]
	mov	ecx, eax
	cmp	ebx, DWORD PTR [ecx+8]
	je	SHORT $LN22@ThemeEqual
$LL661@ThemeEqual:

; 1719 : #endif
; 1720 : 											{
; 1721 : 												if (it5->m_iGreatWorkIndex == iToBeDiscardedWorkIndex)

	cmp	DWORD PTR [ebx], ebp
	jne	SHORT $LN21@ThemeEqual
	lea	edx, DWORD PTR [ebx+12]

; 1722 : 												{
; 1723 : 													it5->m_iGreatWorkIndex = iToBeAcquiredWorkIndex;
; 1724 : 													GetGreatWorkLocation(it5->m_iGreatWorkIndex, it5->m_iCityID, it5->m_eBuilding, it5->m_iSlot);

	push	edx
	lea	eax, DWORD PTR [ebx+8]
	push	eax
	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+192]
	push	esi
	mov	DWORD PTR [ebx], esi
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation
$LN21@ThemeEqual:

; 1725 : 												}
; 1726 : 												tempWorks.push_back(*it5);

	push	ebx
	lea	ecx, DWORD PTR _tempWorks$[esp+184]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	edx, DWORD PTR _works1$[esp+176]
	add	ebx, 24					; 00000018H
	cmp	ebx, DWORD PTR [edx+8]
	jne	SHORT $LL661@ThemeEqual
$LN22@ThemeEqual:

; 1727 : 											}
; 1728 : 											works1 = tempWorks;

	mov	ecx, DWORD PTR _works1$[esp+176]
	lea	eax, DWORD PTR _tempWorks$[esp+180]
	push	eax
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1729 : 
; 1730 : 											CultureHelpers::SendArtSwapNotification(pkEntry->GetGreatWorkSlotType(), pkBonusInfo->IsMustBeArt(), m_pPlayer->GetID(), ePlayer, iToBeDiscardedWorkIndex, iToBeAcquiredWorkIndex);

	mov	ecx, DWORD PTR _this$[esp+180]
	mov	edx, DWORD PTR [ecx+292]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _pkBonusInfo$[esp+180]
	mov	dl, BYTE PTR [ecx+34]
	mov	ecx, DWORD PTR _pkEntry$[esp+180]
	push	esi
	push	ebp
	push	edi
	push	eax
	mov	BYTE PTR $T260936[esp+196], dl
	mov	eax, DWORD PTR $T260936[esp+196]
	push	eax
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	push	eax
	call	?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z ; CultureHelpers::SendArtSwapNotification
	add	esp, 24					; 00000018H
$LN1135@ThemeEqual:

; 1731 : 											break;  // Themed it through acquisition
; 1732 : 										}
; 1733 : 									}
; 1734 : 								}
; 1735 : 							}
; 1736 : 						}
; 1737 : 					}
; 1738 : 				}
; 1739 : 
; 1740 : 				if (bThemedProperly)
; 1741 : 				{
; 1742 : 					for (int jJ = 0; jJ < (int)aWorksChosen.size(); jJ++)

	mov	ebp, DWORD PTR _aWorksChosen$224944[esp+188]
	mov	edx, DWORD PTR _aWorksChosen$224944[esp+184]
	mov	ebx, ebp
	sub	ebx, edx
	sar	ebx, 2
	xor	edi, edi
	test	ebx, ebx
	jle	$LN1170@ThemeEqual
	npad	11
$LL19@ThemeEqual:

; 1743 : 					{
; 1744 : 						for (int kK = 0; kK < (int)works1.size(); kK++)

	mov	eax, DWORD PTR _works1$[esp+176]
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN14@ThemeEqual
	mov	edx, DWORD PTR _aWorksChosen$224944[esp+184]
	mov	ebp, DWORD PTR [edx+edi*4]
	mov	edx, esi
	npad	1
$LL16@ThemeEqual:

; 1745 : 						{
; 1746 : 							if (works1[kK].m_iGreatWorkIndex == aWorksChosen[jJ])

	cmp	DWORD PTR [edx], ebp
	je	SHORT $LN1136@ThemeEqual
	inc	ecx
	add	edx, 24					; 00000018H
	cmp	ecx, eax
	jl	SHORT $LL16@ThemeEqual

; 1784 : #endif
; 1785 : 					{
; 1786 : 						// Copy it over if not chosen, updating its location
; 1787 : 						if (find(aWorksChosen.begin(), aWorksChosen.end(), it5->m_iGreatWorkIndex) == aWorksChosen.end())

	jmp	SHORT $LN14@ThemeEqual
$LN1136@ThemeEqual:

; 1747 : 							{
; 1748 : 								MoveWorkIntoSlot(works1[kK], kBldg.m_iCityID, kBldg.m_eBuilding, jJ);

	mov	eax, DWORD PTR _kBldg$[esp+180]
	mov	edx, DWORD PTR _kBldg$[esp+176]
	push	edi
	push	eax
	push	edx
	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	edx, DWORD PTR [esi+eax*8]
	lea	eax, DWORD PTR [esi+eax*8]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[esp+216]
	call	?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z ; CvPlayerCulture::MoveWorkIntoSlot
$LN14@ThemeEqual:

; 1749 : 								break;
; 1750 : 							}
; 1751 : 						}
; 1752 : 						for (int kK = 0; kK < (int)works2.size(); kK++)

	mov	eax, DWORD PTR _works2$[esp+176]
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN18@ThemeEqual
	mov	edx, DWORD PTR _aWorksChosen$224944[esp+184]
	mov	ebp, DWORD PTR [edx+edi*4]
	mov	edx, esi
$LL12@ThemeEqual:

; 1753 : 						{
; 1754 : 							if (works2[kK].m_iGreatWorkIndex == aWorksChosen[jJ])

	cmp	DWORD PTR [edx], ebp
	je	SHORT $LN1137@ThemeEqual
	inc	ecx
	add	edx, 24					; 00000018H
	cmp	ecx, eax
	jl	SHORT $LL12@ThemeEqual

; 1784 : #endif
; 1785 : 					{
; 1786 : 						// Copy it over if not chosen, updating its location
; 1787 : 						if (find(aWorksChosen.begin(), aWorksChosen.end(), it5->m_iGreatWorkIndex) == aWorksChosen.end())

	jmp	SHORT $LN18@ThemeEqual
$LN1137@ThemeEqual:

; 1755 : 							{
; 1756 : 								MoveWorkIntoSlot(works2[kK], kBldg.m_iCityID, kBldg.m_eBuilding, jJ);

	mov	eax, DWORD PTR _kBldg$[esp+180]
	mov	edx, DWORD PTR _kBldg$[esp+176]
	push	edi
	push	eax
	push	edx
	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	edx, DWORD PTR [esi+eax*8]
	lea	eax, DWORD PTR [esi+eax*8]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[esp+216]
	call	?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z ; CvPlayerCulture::MoveWorkIntoSlot
$LN18@ThemeEqual:
	inc	edi
	cmp	edi, ebx
	jl	$LL19@ThemeEqual
	mov	ebp, DWORD PTR _aWorksChosen$224944[esp+188]
	mov	edx, DWORD PTR _aWorksChosen$224944[esp+184]
$LN1170@ThemeEqual:

; 1757 : 								break;
; 1758 : 							}
; 1759 : 						}
; 1760 : 					}
; 1761 : 
; 1762 : 					// Remove these works from those to consider later
; 1763 : 					tempWorks.clear();

	mov	edi, DWORD PTR _tempWorks$[esp+184]
	mov	ebx, DWORD PTR _works1$[esp+176]
	cmp	edi, DWORD PTR _tempWorks$[esp+188]
	je	SHORT $LN751@ThemeEqual
	mov	DWORD PTR _tempWorks$[esp+188], edi
$LN751@ThemeEqual:

; 1764 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1765 : 					for (it5 = works1.begin(); it5 != works1.end(); ++it5)
; 1766 : #else
; 1767 : 					for (it5 = works1.begin(); it5 != works1.end(); it5++)

	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1171@ThemeEqual
	npad	7
$LL791@ThemeEqual:

; 1768 : #endif
; 1769 : 					{
; 1770 : 						// Copy it over if not chosen, updating its location
; 1771 : 						if (find(aWorksChosen.begin(), aWorksChosen.end(), it5->m_iGreatWorkIndex) == aWorksChosen.end())

	mov	eax, edx
	cmp	edx, ebp
	je	SHORT $LN1156@ThemeEqual
	mov	ecx, DWORD PTR [esi]
$LL837@ThemeEqual:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1138@ThemeEqual
	add	eax, 4
	cmp	eax, ebp
	jne	SHORT $LL837@ThemeEqual
	jmp	SHORT $LN1156@ThemeEqual
$LN1138@ThemeEqual:
	cmp	eax, ebp
	jne	SHORT $LN7@ThemeEqual
$LN1156@ThemeEqual:

; 1764 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1765 : 					for (it5 = works1.begin(); it5 != works1.end(); ++it5)
; 1766 : #else
; 1767 : 					for (it5 = works1.begin(); it5 != works1.end(); it5++)

	lea	ecx, DWORD PTR [esi+12]

; 1772 : 						{
; 1773 : 							GetGreatWorkLocation(it5->m_iGreatWorkIndex, it5->m_iCityID, it5->m_eBuilding, it5->m_iSlot);

	push	ecx
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+8]
	push	edx
	lea	eax, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+196]
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1774 : 							tempWorks.push_back(*it5);

	push	esi
	lea	ecx, DWORD PTR _tempWorks$[esp+184]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	edx, DWORD PTR _aWorksChosen$224944[esp+184]
$LN7@ThemeEqual:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL791@ThemeEqual

; 1764 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1765 : 					for (it5 = works1.begin(); it5 != works1.end(); ++it5)
; 1766 : #else
; 1767 : 					for (it5 = works1.begin(); it5 != works1.end(); it5++)

	mov	edi, DWORD PTR _tempWorks$[esp+184]
$LN1171@ThemeEqual:

; 1775 : 						}
; 1776 : 					}
; 1777 : 					works1 = tempWorks;

	lea	edx, DWORD PTR _tempWorks$[esp+180]
	push	edx
	mov	ecx, ebx
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1778 : 
; 1779 : 					tempWorks.clear();

	cmp	edi, DWORD PTR _tempWorks$[esp+188]
	je	SHORT $LN891@ThemeEqual
	mov	DWORD PTR _tempWorks$[esp+188], edi
$LN891@ThemeEqual:

; 1780 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1781 : 					for (it5 = works2.begin(); it5 != works2.end(); ++it5)
; 1782 : #else
; 1783 : 					for (it5 = works2.begin(); it5 != works2.end(); it5++)

	mov	eax, DWORD PTR _works2$[esp+176]
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [eax+8]
	je	SHORT $LN1177@ThemeEqual
	mov	edi, eax
$LL931@ThemeEqual:

; 1784 : #endif
; 1785 : 					{
; 1786 : 						// Copy it over if not chosen, updating its location
; 1787 : 						if (find(aWorksChosen.begin(), aWorksChosen.end(), it5->m_iGreatWorkIndex) == aWorksChosen.end())

	mov	ebx, DWORD PTR _aWorksChosen$224944[esp+184]
	mov	eax, ebx
	cmp	ebx, ebp
	je	SHORT $LN1157@ThemeEqual
	mov	ecx, DWORD PTR [esi]
	npad	2
$LL977@ThemeEqual:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1139@ThemeEqual
	add	eax, 4
	cmp	eax, ebp
	jne	SHORT $LL977@ThemeEqual
	jmp	SHORT $LN1157@ThemeEqual
$LN1139@ThemeEqual:
	cmp	eax, ebp
	jne	SHORT $LN3@ThemeEqual
$LN1157@ThemeEqual:

; 1780 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1781 : 					for (it5 = works2.begin(); it5 != works2.end(); ++it5)
; 1782 : #else
; 1783 : 					for (it5 = works2.begin(); it5 != works2.end(); it5++)

	lea	eax, DWORD PTR [esi+12]

; 1788 : 						{
; 1789 : 							GetGreatWorkLocation(it5->m_iGreatWorkIndex, it5->m_iCityID, it5->m_eBuilding, it5->m_iSlot);

	push	eax
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+188]
	lea	edx, DWORD PTR [esi+4]
	push	edx
	push	eax
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1790 : 							tempWorks.push_back(*it5);

	push	esi
	lea	ecx, DWORD PTR _tempWorks$[esp+184]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
$LN3@ThemeEqual:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL931@ThemeEqual

; 1780 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1781 : 					for (it5 = works2.begin(); it5 != works2.end(); ++it5)
; 1782 : #else
; 1783 : 					for (it5 = works2.begin(); it5 != works2.end(); it5++)

	mov	edi, DWORD PTR _tempWorks$[esp+184]
	jmp	SHORT $LN2@ThemeEqual
$LN1177@ThemeEqual:
	mov	ebx, DWORD PTR _aWorksChosen$224944[esp+184]
$LN2@ThemeEqual:

; 1791 : 						}
; 1792 : 					}
; 1793 : 					works2 = tempWorks;

	lea	ecx, DWORD PTR _tempWorks$[esp+180]
	push	ecx
	mov	ecx, DWORD PTR _works2$[esp+180]
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1794 : 
; 1795 : 					// All done
; 1796 : 					LogThemedBuilding(kBldg.m_iCityID, kBldg.m_eBuilding, pkBonusInfo->GetBonus());

	mov	edx, DWORD PTR _pkBonusInfo$[esp+180]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _kBldg$[esp+180]
	mov	edx, DWORD PTR _kBldg$[esp+176]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+188]
	push	edx
	call	?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z ; CvPlayerCulture::LogThemedBuilding

; 1797 : 					return true;

	mov	eax, DWORD PTR _aErasSeen$224954[esp+184]
	test	eax, eax
	je	SHORT $LN1024@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1024@ThemeEqual:
	mov	eax, DWORD PTR _aPlayersSeen$224949[esp+184]
	test	eax, eax
	je	SHORT $LN1031@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1031@ThemeEqual:
	test	ebx, ebx
	je	SHORT $LN1038@ThemeEqual
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1038@ThemeEqual:
	mov	eax, DWORD PTR _aArtifactsErasSeen$[esp+184]
	test	eax, eax
	je	SHORT $LN1045@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1045@ThemeEqual:
	mov	eax, DWORD PTR _aArtifactsPlayersSeen$[esp+184]
	test	eax, eax
	je	SHORT $LN1052@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1052@ThemeEqual:
	mov	eax, DWORD PTR _aArtifactsChosen$[esp+184]
	test	eax, eax
	je	SHORT $LN1059@ThemeEqual
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1059@ThemeEqual:
	test	edi, edi
	je	SHORT $LN1066@ThemeEqual
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1066@ThemeEqual:
	mov	al, 1
	jmp	SHORT $LN61@ThemeEqual
$LN57@ThemeEqual:

; 1570 : 	{
; 1571 : 		return false;

	lea	ecx, DWORD PTR _aArtifactsErasSeen$[esp+180]
	call	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
	lea	ecx, DWORD PTR _aArtifactsPlayersSeen$[esp+180]
	call	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
	lea	ecx, DWORD PTR _aArtifactsChosen$[esp+180]
	call	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	lea	ecx, DWORD PTR _tempWorks$[esp+180]
	call	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
$LN59@ThemeEqual:

; 1563 : #endif
; 1564 : 	{
; 1565 : 		return false;

	xor	al, al
$LN61@ThemeEqual:

; 1803 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+180]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 164				; 000000a4H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$0:
	lea	ecx, DWORD PTR _tempWorks$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$1:
	lea	ecx, DWORD PTR _aArtifactsChosen$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$2:
	lea	ecx, DWORD PTR _aArtifactsPlayersSeen$[ebp]
	jmp	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$3:
	lea	ecx, DWORD PTR _aArtifactsErasSeen$[ebp]
	jmp	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$4:
	lea	ecx, DWORD PTR _aWorksChosen$224944[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$5:
	lea	ecx, DWORD PTR _aPlayersSeen$224949[ebp]
	jmp	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
__unwindfunclet$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z$6:
	lea	ecx, DWORD PTR _aErasSeen$224954[ebp]
	jmp	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
__ehhandler$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z ENDP ; CvPlayerCulture::ThemeEqualArtArtifact
PUBLIC	?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonusIndex
EXTRN	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvCityBuildings::GetNumGreatWorksInBuilding
EXTRN	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvCity::getCivilizationType
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z$0
__ehfuncinfo$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_pkBuilding$227627 = -32				; size = 4
_aGreatWorkIndices$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_iGreatWork$227636 = 8					; size = 4
_eBuildingClass$ = 8					; size = 4
?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z PROC ; CvCityCulture::GetThemingBonusIndex, COMDAT
; _this$ = ecx

; 5509 : {  

	push	-1
	push	__ehhandler$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 5510 : 	vector<int> aGreatWorkIndices;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _aGreatWorkIndices$[esp+52], ebx
	mov	DWORD PTR _aGreatWorkIndices$[esp+56], ebx
	mov	DWORD PTR _aGreatWorkIndices$[esp+60], ebx

; 5511 : 	CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 5512 : 	if (pkCivInfo)

	cmp	eax, ebx
	je	SHORT $LN69@GetTheming@2

; 5513 : 	{
; 5514 : 		BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eBuildingClass);

	mov	ebp, DWORD PTR _eBuildingClass$[esp+44]
	push	ebp
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 5515 : 		if(NO_BUILDING != eBuilding)

	cmp	esi, -1
	je	SHORT $LN69@GetTheming@2

; 5516 : 		{
; 5517 : 			if (m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN69@GetTheming@2

; 5518 : 			{
; 5519 : 				CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuilding$227627[esp+48], eax

; 5520 : 				if (pkBuilding)

	cmp	eax, ebx
	je	SHORT $LN69@GetTheming@2

; 5521 : 				{
; 5522 : #ifdef AUI_WARNING_FIXES
; 5523 : 					uint iNumSlots = pkBuilding->GetGreatWorkCount();
; 5524 : #else
; 5525 : 					int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, eax
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 5526 : #endif
; 5527 : 					if (m_pCity->GetCityBuildings()->GetNumGreatWorksInBuilding(eBuildingClass) < iNumSlots)

	mov	ecx, DWORD PTR [edi]
	push	ebp
	mov	ebx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ; CvCityBuildings::GetNumGreatWorksInBuilding
	cmp	eax, ebx
	jge	SHORT $LN4@GetTheming@2

; 5528 : 					{
; 5529 : 						return -1;  // No theming bonus if some slots still empty

	lea	ecx, DWORD PTR _aGreatWorkIndices$[esp+48]
	call	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$LN69@GetTheming@2:
	pop	edi
	pop	esi
	pop	ebp

; 5544 : 				}
; 5545 : 			}
; 5546 : 		}
; 5547 : 	}
; 5548 : 	return -1;

	or	eax, -1
	pop	ebx

; 5549 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
$LN4@GetTheming@2:

; 5530 : 					}
; 5531 : 
; 5532 : 					// Store info on the attributes of all our Great Works
; 5533 : #ifdef AUI_WARNING_FIXES
; 5534 : 					for (uint iI = 0; iI < iNumSlots; iI++)
; 5535 : #else
; 5536 : 					for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN1@GetTheming@2
$LL3@GetTheming@2:

; 5537 : #endif
; 5538 : 					{
; 5539 : 						int iGreatWork = m_pCity->GetCityBuildings()->GetBuildingGreatWork(eBuildingClass, iI);

	mov	ecx, DWORD PTR [edi]
	push	esi
	push	ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	mov	DWORD PTR _iGreatWork$227636[esp+44], eax

; 5540 : 						aGreatWorkIndices.push_back(iGreatWork);

	lea	eax, DWORD PTR _iGreatWork$227636[esp+44]
	push	eax
	lea	ecx, DWORD PTR _aGreatWorkIndices$[esp+52]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL3@GetTheming@2
$LN1@GetTheming@2:

; 5541 : 					}
; 5542 : 
; 5543 : 					return CultureHelpers::GetThemingBonusIndex(m_pCity->getOwner(), pkBuilding, aGreatWorkIndices);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR _pkBuilding$227627[esp+48]
	lea	edx, DWORD PTR _aGreatWorkIndices$[esp+48]
	push	edx
	push	ecx
	push	eax
	call	?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CultureHelpers::GetThemingBonusIndex
	mov	esi, eax
	mov	eax, DWORD PTR _aGreatWorkIndices$[esp+64]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN58@GetTheming@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@GetTheming@2:

; 5549 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z$0:
	lea	ecx, DWORD PTR _aGreatWorkIndices$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z ENDP ; CvCityCulture::GetThemingBonusIndex
PUBLIC	??$sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>, COMDAT

; 3277 : 	_DEBUG_RANGE(_First, _Last);
; 3278 : 	_DEBUG_POINTER(_Pred);
; 3279 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	push	eax
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	esi
	push	edi
	call	??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 3280 : 	}

	ret	0
??$sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@P6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0P6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>
_TEXT	ENDS
PUBLIC	?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z ; CvPlayerCulture::ThemeBuilding
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z
_TEXT	SEGMENT
_this$ = -136						; size = 4
_pkBonusInfo$224740 = -132				; size = 4
_pkEntry$ = -128					; size = 4
_iI$224736 = -124					; size = 4
_it$ = -120						; size = 4
_iToBeAcquiredWorkIndex$224786 = -116			; size = 4
_it2$ = -116						; size = 4
_iCountSlots$224755 = -112				; size = 4
_iLoopPlayer$224778 = -108				; size = 4
_pkGameCulture$ = -104					; size = 4
$T265027 = -100						; size = 1
$T265698 = -96						; size = 1
$T265252 = -96						; size = 1
__Cat$265255 = -96					; size = 1
__Cat$265030 = -96					; size = 1
_aWorksChosen$ = -92					; size = 16
_worksToConsider$ = -76					; size = 16
_tempWorks$ = -60					; size = 16
_aPlayersSeen$ = -44					; size = 16
_aErasSeen$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_buildingIt$ = 8					; size = 4
_works1$ = 12						; size = 4
_works2$ = 16						; size = 4
_bConsiderOtherPlayers$ = 20				; size = 1
?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z PROC ; CvPlayerCulture::ThemeBuilding, COMDAT
; _this$ = ecx

; 1276 : {

	push	-1
	push	__ehhandler$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+148], ecx

; 1277 : 	CvGameCulture *pkGameCulture = GC.getGame().GetGameCulture();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture

; 1278 : 
; 1279 : 	vector<CvGreatWorkInMyEmpire> worksToConsider;

	xor	esi, esi
	mov	DWORD PTR _pkGameCulture$[esp+152], eax
	mov	DWORD PTR _worksToConsider$[esp+156], esi
	mov	DWORD PTR _worksToConsider$[esp+160], esi
	mov	DWORD PTR _worksToConsider$[esp+164], esi
	mov	DWORD PTR __$EHRec$[esp+160], esi

; 1280 : 	vector<CvGreatWorkInMyEmpire>::const_iterator it;
; 1281 : 	vector<CvGreatWorkInMyEmpire>::const_iterator it2;
; 1282 : 	vector<CvGreatWorkInMyEmpire>::iterator it3;
; 1283 : 	vector<CvGreatWorkInMyEmpire> tempWorks;

	mov	DWORD PTR _tempWorks$[esp+156], esi
	mov	DWORD PTR _tempWorks$[esp+160], esi
	mov	DWORD PTR _tempWorks$[esp+164], esi

; 1284 : 
; 1285 : 	vector<int> aWorksChosen;

	mov	DWORD PTR _aWorksChosen$[esp+156], esi
	mov	DWORD PTR _aWorksChosen$[esp+160], esi
	mov	DWORD PTR _aWorksChosen$[esp+164], esi

; 1286 : 	vector<PlayerTypes> aPlayersSeen;

	mov	DWORD PTR _aPlayersSeen$[esp+156], esi
	mov	DWORD PTR _aPlayersSeen$[esp+160], esi
	mov	DWORD PTR _aPlayersSeen$[esp+164], esi

; 1287 : 	vector<EraTypes> aErasSeen;

	mov	DWORD PTR _aErasSeen$[esp+156], esi
	mov	DWORD PTR _aErasSeen$[esp+160], esi
	mov	DWORD PTR _aErasSeen$[esp+164], esi

; 1288 : 
; 1289 : 	CvBuildingEntry *pkEntry = GC.getBuildingInfo(buildingIt->m_eBuilding);

	mov	eax, DWORD PTR _buildingIt$[esp+148]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+164], 4
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebp, eax
	mov	DWORD PTR _pkEntry$[esp+152], ebp

; 1290 : 	if (!pkEntry || pkEntry->GetGreatWorkCount() < 2)

	cmp	ebp, esi
	je	$LN66@ThemeBuild
	mov	ecx, ebp
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	cmp	eax, 2
	jl	$LN66@ThemeBuild

; 1293 : 	}
; 1294 : 
; 1295 : 	// Try each of the theming bonuses for this building
; 1296 : 	for (int iI = 0; iI < pkEntry->GetNumThemingBonuses(); iI++)

	cmp	DWORD PTR [ebp+1008], esi
	mov	DWORD PTR _iI$224736[esp+152], esi
	jle	$LN66@ThemeBuild
	mov	edi, DWORD PTR _works2$[esp+148]
	mov	ebx, DWORD PTR _works1$[esp+148]
$LL65@ThemeBuild:

; 1297 : 	{
; 1298 : 		CvThemingBonusInfo *pkBonusInfo = pkEntry->GetThemingBonusInfo(iI);

	mov	edx, DWORD PTR _iI$224736[esp+152]
	push	edx
	mov	ecx, ebp
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo

; 1299 : 		if (pkBonusInfo->IsMustBeArt())

	cmp	BYTE PTR [eax+34], 0
	mov	DWORD PTR _pkBonusInfo$224740[esp+152], eax
	je	SHORT $LN62@ThemeBuild

; 1300 : 		{
; 1301 : 			worksToConsider = works1;

	push	ebx
	lea	ecx, DWORD PTR _worksToConsider$[esp+156]
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=
	jmp	$LN1383@ThemeBuild
$LN62@ThemeBuild:

; 1302 : 		}
; 1303 : 		else if (pkBonusInfo->IsMustBeArtifact())

	cmp	BYTE PTR [eax+35], 0
	je	SHORT $LN60@ThemeBuild

; 1304 : 		{
; 1305 : 			worksToConsider = works2;

	push	edi
	lea	ecx, DWORD PTR _worksToConsider$[esp+156]
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=
	jmp	$LN1383@ThemeBuild
$LN60@ThemeBuild:

; 1306 : 		}
; 1307 : 		// Dedicated routine to handle the equal art/artifact case
; 1308 : 		else if (pkBonusInfo->IsMustBeEqualArtArtifact())

	cmp	BYTE PTR [eax+36], 0
	je	SHORT $LN58@ThemeBuild

; 1309 : 		{
; 1310 : 			if (ThemeEqualArtArtifact(*buildingIt, iI, pkEntry->GetGreatWorkCount(), works1, works2, bConsiderOtherPlayers))

	mov	eax, DWORD PTR _bConsiderOtherPlayers$[esp+148]
	mov	esi, DWORD PTR _buildingIt$[esp+148]
	push	eax
	push	edi
	push	ebx
	mov	ecx, ebp
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ecx, DWORD PTR _iI$224736[esp+164]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _this$[esp+184]
	mov	DWORD PTR [eax+8], edx
	call	?ThemeEqualArtArtifact@CvPlayerCulture@@QAE_NVCvGreatWorkBuildingInMyEmpire@@HHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@1_N@Z ; CvPlayerCulture::ThemeEqualArtArtifact
	test	al, al
	je	SHORT $LN1383@ThemeBuild

; 1311 : 			{
; 1312 : 				return true;

	lea	ecx, DWORD PTR _aErasSeen$[esp+152]
	call	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
	lea	ecx, DWORD PTR _aPlayersSeen$[esp+152]
	call	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
	lea	ecx, DWORD PTR _aWorksChosen$[esp+152]
	call	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	lea	ecx, DWORD PTR _tempWorks$[esp+152]
	call	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
	lea	ecx, DWORD PTR _worksToConsider$[esp+152]
	call	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
	mov	al, 1
	jmp	$LN68@ThemeBuild
$LN58@ThemeBuild:

; 1313 : 			}
; 1314 : 		}
; 1315 : 		else
; 1316 : 		{
; 1317 : 			worksToConsider = works1;

	push	ebx
	lea	ecx, DWORD PTR _worksToConsider$[esp+156]
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1318 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1319 : 			for (it = works2.begin(); it != works2.end(); ++it)
; 1320 : #else
; 1321 : 			for (it = works2.begin(); it != works2.end(); it++)

	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1383@ThemeBuild
	npad	4
$LL323@ThemeBuild:

; 1322 : #endif
; 1323 : 			{
; 1324 : 				worksToConsider.push_back(*it);

	push	esi
	lea	ecx, DWORD PTR _worksToConsider$[esp+156]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL323@ThemeBuild
$LN1383@ThemeBuild:

; 1325 : 			}
; 1326 : 		}
; 1327 : 
; 1328 : 		// If not enough works, try other theming bonuses
; 1329 : #ifdef AUI_WARNING_FIXES
; 1330 : 		uint iCountSlots = pkEntry->GetGreatWorkCount();
; 1331 : 		if (worksToConsider.size() < iCountSlots)
; 1332 : #else
; 1333 : 		int iCountSlots = pkEntry->GetGreatWorkCount();

	mov	ecx, ebp
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 1334 : 		if (worksToConsider.size() < (unsigned int)iCountSlots)

	mov	ecx, DWORD PTR _worksToConsider$[esp+160]
	sub	ecx, DWORD PTR _worksToConsider$[esp+156]
	mov	esi, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iCountSlots$224755[esp+152], esi
	cmp	eax, esi
	jb	$LN64@ThemeBuild

; 1335 : #endif
; 1336 : 		{
; 1337 : 			continue;
; 1338 : 		}
; 1339 : 
; 1340 : 		// Try each of the works as the starter
; 1341 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1342 : 		for (it = worksToConsider.begin(); it != worksToConsider.end(); ++it)
; 1343 : #else
; 1344 : 		for (it = worksToConsider.begin(); it != worksToConsider.end(); it++)

	mov	ebp, DWORD PTR _worksToConsider$[esp+156]
	mov	DWORD PTR _it$[esp+152], ebp
	cmp	ebp, DWORD PTR _worksToConsider$[esp+160]
	je	$LN64@ThemeBuild
	jmp	SHORT $LN347@ThemeBuild
$LL1388@ThemeBuild:
	mov	ebp, DWORD PTR _it$[esp+152]
$LN347@ThemeBuild:

; 1345 : #endif
; 1346 : 		{
; 1347 : 			// First, make sure this "starter" is valid
; 1348 : 			if (pkBonusInfo->IsRequiresOwner() && it->m_ePlayer != m_pPlayer->GetID())

	mov	ecx, DWORD PTR _pkBonusInfo$224740[esp+152]
	cmp	BYTE PTR [ecx+37], 0
	je	SHORT $LN48@ThemeBuild
	mov	edx, DWORD PTR _this$[esp+152]
	mov	eax, DWORD PTR [edx+292]
	mov	ecx, DWORD PTR [ebp+16]
	cmp	ecx, DWORD PTR [eax+44]
	jne	$LN50@ThemeBuild
	mov	ebp, DWORD PTR _it$[esp+152]
$LN48@ThemeBuild:

; 1349 : 			{
; 1350 : 				continue;
; 1351 : 			}
; 1352 : 			if (pkBonusInfo->IsRequiresAnyButOwner() && it->m_ePlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR _pkBonusInfo$224740[esp+152]
	cmp	BYTE PTR [edx+38], 0
	je	SHORT $LN47@ThemeBuild
	mov	eax, DWORD PTR _this$[esp+152]
	mov	ecx, DWORD PTR [eax+292]
	mov	edx, DWORD PTR [ebp+16]
	cmp	edx, DWORD PTR [ecx+44]
	je	$LN50@ThemeBuild
	mov	ebp, DWORD PTR _it$[esp+152]
$LN47@ThemeBuild:

; 1353 : 			{
; 1354 : 				continue;
; 1355 : 			}
; 1356 : 
; 1357 : 			aWorksChosen.clear();

	mov	edi, DWORD PTR _aWorksChosen$[esp+156]
	mov	ebx, DWORD PTR _aWorksChosen$[esp+160]
	cmp	edi, ebx
	je	SHORT $LN393@ThemeBuild
	mov	ebx, edi
	mov	DWORD PTR _aWorksChosen$[esp+160], ebx
$LN393@ThemeBuild:

; 1358 : 			aPlayersSeen.clear();

	mov	eax, DWORD PTR _aPlayersSeen$[esp+156]
	cmp	eax, DWORD PTR _aPlayersSeen$[esp+160]
	je	SHORT $LN435@ThemeBuild
	mov	DWORD PTR _aPlayersSeen$[esp+160], eax
$LN435@ThemeBuild:

; 1359 : 			aErasSeen.clear();

	mov	eax, DWORD PTR _aErasSeen$[esp+156]
	cmp	eax, DWORD PTR _aErasSeen$[esp+160]
	je	SHORT $LN479@ThemeBuild
	mov	DWORD PTR _aErasSeen$[esp+160], eax
$LN479@ThemeBuild:

; 1360 : 
; 1361 : 			aWorksChosen.push_back(it->m_iGreatWorkIndex);

	test	edi, edi
	jne	SHORT $LN521@ThemeBuild
	xor	eax, eax
	jmp	SHORT $LN522@ThemeBuild
$LN521@ThemeBuild:
	mov	eax, DWORD PTR _aWorksChosen$[esp+164]
	sub	eax, edi
	sar	eax, 2
$LN522@ThemeBuild:
	mov	ecx, ebx
	sub	ecx, edi
	sar	ecx, 2
	cmp	ecx, eax
	jae	SHORT $LN514@ThemeBuild
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR [ebx], edx
	add	ebx, 4
	mov	DWORD PTR _aWorksChosen$[esp+160], ebx
	jmp	SHORT $LN568@ThemeBuild
$LN514@ThemeBuild:
	push	ebp
	push	1
	push	ebx
	lea	ecx, DWORD PTR _aWorksChosen$[esp+164]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebx, DWORD PTR _aWorksChosen$[esp+160]
	mov	edi, DWORD PTR _aWorksChosen$[esp+156]
$LN568@ThemeBuild:
	lea	eax, DWORD PTR [ebp+16]

; 1362 : 			aPlayersSeen.push_back(it->m_ePlayer);

	push	eax
	lea	ecx, DWORD PTR _aPlayersSeen$[esp+156]
	call	?push_back@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAEXABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::push_back
	lea	ecx, DWORD PTR [ebp+20]

; 1363 : 			aErasSeen.push_back(it->m_eEra);

	push	ecx
	lea	ecx, DWORD PTR _aErasSeen$[esp+156]
	call	?push_back@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAEXABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::push_back
	lea	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR _it2$[esp+152], eax

; 1364 : 
; 1365 : 			// Loop through the rest looking for works that will match up
; 1366 : 			it2 = it;
; 1367 : #ifdef AUI_WARNING_FIXES
; 1368 : 			for (++it2; it2 != worksToConsider.end() && aWorksChosen.size() < iCountSlots; ++it2)
; 1369 : #elif defined(AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS)
; 1370 : 			for (++it2; it2 != worksToConsider.end() && aWorksChosen.size() < (unsigned int)iCountSlots; ++it2)
; 1371 : #else
; 1372 : 			for (it2++; it2 != worksToConsider.end() && aWorksChosen.size() < (unsigned int)iCountSlots; it2++)

	cmp	eax, DWORD PTR _worksToConsider$[esp+160]
	je	$LN44@ThemeBuild

; 1335 : #endif
; 1336 : 		{
; 1337 : 			continue;
; 1338 : 		}
; 1339 : 
; 1340 : 		// Try each of the works as the starter
; 1341 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1342 : 		for (it = worksToConsider.begin(); it != worksToConsider.end(); ++it)
; 1343 : #else
; 1344 : 		for (it = worksToConsider.begin(); it != worksToConsider.end(); it++)

	add	ebp, 44					; 0000002cH

; 1364 : 
; 1365 : 			// Loop through the rest looking for works that will match up
; 1366 : 			it2 = it;
; 1367 : #ifdef AUI_WARNING_FIXES
; 1368 : 			for (++it2; it2 != worksToConsider.end() && aWorksChosen.size() < iCountSlots; ++it2)
; 1369 : #elif defined(AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS)
; 1370 : 			for (++it2; it2 != worksToConsider.end() && aWorksChosen.size() < (unsigned int)iCountSlots; ++it2)
; 1371 : #else
; 1372 : 			for (it2++; it2 != worksToConsider.end() && aWorksChosen.size() < (unsigned int)iCountSlots; it2++)

$LL588@ThemeBuild:
	mov	esi, ebx
	sub	esi, edi
	sar	esi, 2
	cmp	esi, DWORD PTR _iCountSlots$224755[esp+152]
	jae	$LN44@ThemeBuild

; 1373 : #endif
; 1374 : 			{
; 1375 : 				if (CultureHelpers::IsValidForThemingBonus(pkBonusInfo, it2->m_eEra, aErasSeen, it2->m_ePlayer, aPlayersSeen, m_pPlayer->GetID()))

	mov	edx, DWORD PTR _this$[esp+152]
	mov	eax, DWORD PTR [edx+292]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ebp-4]
	push	ecx
	lea	edx, DWORD PTR _aPlayersSeen$[esp+156]
	push	edx
	mov	edx, DWORD PTR [ebp]
	lea	edi, DWORD PTR [ebp-4]
	push	eax
	mov	eax, DWORD PTR _pkBonusInfo$224740[esp+164]
	lea	ecx, DWORD PTR _aErasSeen$[esp+164]
	push	ecx
	push	edx
	push	eax
	call	?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ; CultureHelpers::IsValidForThemingBonus
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN45@ThemeBuild

; 1376 : 				{
; 1377 : 					aWorksChosen.push_back(it2->m_iGreatWorkIndex);

	mov	ecx, DWORD PTR _aWorksChosen$[esp+156]
	test	ecx, ecx
	jne	SHORT $LN626@ThemeBuild
	xor	eax, eax
	jmp	SHORT $LN627@ThemeBuild
$LN626@ThemeBuild:
	mov	eax, DWORD PTR _aWorksChosen$[esp+164]
	sub	eax, ecx
	sar	eax, 2
$LN627@ThemeBuild:
	cmp	esi, eax
	jae	SHORT $LN619@ThemeBuild
	mov	ecx, DWORD PTR _it2$[esp+152]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx], edx
	add	ebx, 4
	mov	DWORD PTR _aWorksChosen$[esp+160], ebx
	jmp	SHORT $LN673@ThemeBuild
$LN619@ThemeBuild:
	mov	eax, DWORD PTR _it2$[esp+152]
	push	eax
	push	1
	push	ebx
	lea	ecx, DWORD PTR _aWorksChosen$[esp+164]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebx, DWORD PTR _aWorksChosen$[esp+160]
$LN673@ThemeBuild:

; 1378 : 					aPlayersSeen.push_back(it2->m_ePlayer);

	mov	ecx, DWORD PTR _aPlayersSeen$[esp+156]
	test	ecx, ecx
	jne	SHORT $LN691@ThemeBuild
	xor	eax, eax
	jmp	SHORT $LN692@ThemeBuild
$LN691@ThemeBuild:
	mov	eax, DWORD PTR _aPlayersSeen$[esp+164]
	sub	eax, ecx
	sar	eax, 2
$LN692@ThemeBuild:
	mov	edx, DWORD PTR _aPlayersSeen$[esp+160]
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN684@ThemeBuild
	mov	ecx, DWORD PTR __Cat$265030[esp+152]
	mov	esi, DWORD PTR _aPlayersSeen$[esp+160]
	mov	BYTE PTR $T265027[esp+152], 0
	mov	eax, DWORD PTR $T265027[esp+152]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _aPlayersSeen$[esp+160]
	push	edx
	push	edi
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAW4PlayerTypes@@IW41@V?$allocator@W4PlayerTypes@@@std@@@std@@YAXPAW4PlayerTypes@@IABW41@AAV?$allocator@W4PlayerTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PlayerTypes *,unsigned int,enum PlayerTypes,std::allocator<enum PlayerTypes> >
	add	esp, 24					; 00000018H
	add	esi, 4
	mov	DWORD PTR _aPlayersSeen$[esp+160], esi
	jmp	SHORT $LN725@ThemeBuild
$LN684@ThemeBuild:
	mov	eax, DWORD PTR _aPlayersSeen$[esp+160]
	push	edi
	push	1
	push	eax
	lea	ecx, DWORD PTR _aPlayersSeen$[esp+164]
	call	?_Insert_n@?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@2@IABW4PlayerTypes@@@Z ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::_Insert_n
$LN725@ThemeBuild:

; 1379 : 					aErasSeen.push_back(it2->m_eEra);

	mov	ecx, DWORD PTR _aErasSeen$[esp+156]
	test	ecx, ecx
	jne	SHORT $LN743@ThemeBuild
	xor	eax, eax
	jmp	SHORT $LN744@ThemeBuild
$LN743@ThemeBuild:
	mov	eax, DWORD PTR _aErasSeen$[esp+164]
	sub	eax, ecx
	sar	eax, 2
$LN744@ThemeBuild:
	mov	esi, DWORD PTR _aErasSeen$[esp+160]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN736@ThemeBuild
	mov	BYTE PTR $T265252[esp+152], 0
	mov	eax, DWORD PTR $T265252[esp+152]
	mov	ecx, DWORD PTR __Cat$265255[esp+152]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _aErasSeen$[esp+160]
	push	edx
	push	ebp
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAW4EraTypes@@IW41@V?$allocator@W4EraTypes@@@std@@@std@@YAXPAW4EraTypes@@IABW41@AAV?$allocator@W4EraTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum EraTypes *,unsigned int,enum EraTypes,std::allocator<enum EraTypes> >
	add	esp, 24					; 00000018H
	add	esi, 4
	mov	DWORD PTR _aErasSeen$[esp+160], esi
	jmp	SHORT $LN45@ThemeBuild
$LN736@ThemeBuild:
	push	ebp
	push	1
	push	esi
	lea	ecx, DWORD PTR _aErasSeen$[esp+164]
	call	?_Insert_n@?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@2@IABW4EraTypes@@@Z ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::_Insert_n
$LN45@ThemeBuild:
	mov	eax, DWORD PTR _it2$[esp+152]
	mov	edi, DWORD PTR _aWorksChosen$[esp+156]
	add	eax, 24					; 00000018H
	add	ebp, 24					; 00000018H
	mov	DWORD PTR _it2$[esp+152], eax
	cmp	eax, DWORD PTR _worksToConsider$[esp+160]
	jne	$LL588@ThemeBuild
$LN44@ThemeBuild:

; 1380 : 				}
; 1381 : 			}
; 1382 : 
; 1383 : 			// Did we theme it properly?
; 1384 : 			bool bThemedProperly = false;
; 1385 : 			if (aWorksChosen.size() == iCountSlots && CultureHelpers::GetThemingBonusIndex(m_pPlayer->GetID(), pkEntry, aWorksChosen) == iI)

	mov	esi, ebx
	sub	esi, edi
	sar	esi, 2
	cmp	esi, DWORD PTR _iCountSlots$224755[esp+152]
	jne	SHORT $LN42@ThemeBuild
	mov	eax, DWORD PTR _this$[esp+152]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _pkEntry$[esp+152]
	lea	edx, DWORD PTR _aWorksChosen$[esp+152]
	push	edx
	push	ecx
	push	eax
	call	?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CultureHelpers::GetThemingBonusIndex
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _iI$224736[esp+152]
	je	$LN1355@ThemeBuild
$LN42@ThemeBuild:

; 1386 : 			{
; 1387 : 				bThemedProperly = true;
; 1388 : 			}
; 1389 : 
; 1390 : 			// If we are one work short, let's look to other players
; 1391 : 			else if (bConsiderOtherPlayers && aWorksChosen.size() == (iCountSlots - 1) && (pkEntry->GetGreatWorkSlotType() != CvTypes::getGREAT_WORK_SLOT_MUSIC()))

	cmp	BYTE PTR _bConsiderOtherPlayers$[esp+148], 0
	je	$LN50@ThemeBuild
	mov	edx, DWORD PTR _iCountSlots$224755[esp+152]
	dec	edx
	cmp	esi, edx
	jne	$LN50@ThemeBuild
	mov	ecx, DWORD PTR _pkEntry$[esp+152]
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	mov	esi, eax
	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	cmp	esi, eax
	je	$LN50@ThemeBuild

; 1392 : 			{
; 1393 : 				for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	mov	ebp, DWORD PTR _works1$[esp+148]
	xor	ebx, ebx
	mov	DWORD PTR _iLoopPlayer$224778[esp+152], ebx
	npad	15
$LL39@ThemeBuild:

; 1394 : 				{
; 1395 : 					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1396 : 					if (kPlayer.isAlive() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid((PlayerTypes)iLoopPlayer))

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	esi, DWORD PTR [ebx+eax]
	je	$LN38@ThemeBuild
	mov	ecx, DWORD PTR _iLoopPlayer$224778[esp+152]
	mov	edx, DWORD PTR _this$[esp+152]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [edx+292]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	$LN38@ThemeBuild

; 1397 : 					{
; 1398 : 						int iToBeAcquiredWorkIndex = NO_GREAT_WORK;
; 1399 : 						int iToBeDiscardedWorkIndex = NO_GREAT_WORK;
; 1400 : 
; 1401 : 						if (pkEntry->GetGreatWorkSlotType() == CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT())

	mov	ecx, DWORD PTR _pkEntry$[esp+152]
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	mov	edi, eax
	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	cmp	edi, eax
	jne	SHORT $LN35@ThemeBuild

; 1402 : 						{
; 1403 : 							if (pkBonusInfo->IsMustBeArt())

	mov	eax, DWORD PTR _pkBonusInfo$224740[esp+152]
	cmp	BYTE PTR [eax+34], 0
	je	SHORT $LN34@ThemeBuild

; 1404 : 							{
; 1405 : 								iToBeAcquiredWorkIndex = kPlayer.GetCulture()->GetSwappableArtIndex();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	esi, DWORD PTR [eax+280]

; 1406 : 								iToBeDiscardedWorkIndex = CultureHelpers::FindWorkNotChosen(works1, aWorksChosen);

	jmp	SHORT $LN1393@ThemeBuild
$LN34@ThemeBuild:

; 1407 : 							}
; 1408 : 							else if (pkBonusInfo->IsMustBeArtifact())

	cmp	BYTE PTR [eax+35], 0
	je	$LN38@ThemeBuild

; 1409 : 							{
; 1410 : 								iToBeAcquiredWorkIndex = kPlayer.GetCulture()->GetSwappableArtifactIndex();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture

; 1411 : 								iToBeDiscardedWorkIndex = CultureHelpers::FindWorkNotChosen(works2, aWorksChosen);

	mov	edx, DWORD PTR _works2$[esp+148]
	mov	esi, DWORD PTR [eax+284]
	lea	ecx, DWORD PTR _aWorksChosen$[esp+152]
	push	ecx
	push	edx

; 1412 : 							}
; 1413 : 						}
; 1414 : 						else

	jmp	SHORT $LN1394@ThemeBuild
$LN35@ThemeBuild:

; 1415 : 						{
; 1416 : 							iToBeAcquiredWorkIndex = kPlayer.GetCulture()->GetSwappableWritingIndex();

	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	esi, DWORD PTR [eax+276]
$LN1393@ThemeBuild:

; 1417 : 							iToBeDiscardedWorkIndex = CultureHelpers::FindWorkNotChosen(works1, aWorksChosen);

	lea	eax, DWORD PTR _aWorksChosen$[esp+152]
	push	eax
	push	ebp
$LN1394@ThemeBuild:
	mov	DWORD PTR _iToBeAcquiredWorkIndex$224786[esp+160], esi
	call	?FindWorkNotChosen@CultureHelpers@@YAHAAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@3@@Z ; CultureHelpers::FindWorkNotChosen
	add	esp, 8
	mov	edi, eax

; 1418 : 						}
; 1419 : 
; 1420 : 						// Does this work fit?
; 1421 : 						if (iToBeAcquiredWorkIndex != NO_GREAT_WORK && iToBeDiscardedWorkIndex != NO_GREAT_WORK)

	cmp	esi, -1
	je	$LN38@ThemeBuild
	cmp	edi, -1
	je	$LN38@ThemeBuild

; 1422 : 						{
; 1423 : 							EraTypes eEra = pkGameCulture->m_CurrentGreatWorks[iToBeAcquiredWorkIndex].m_eEra;
; 1424 : 							PlayerTypes ePlayer = pkGameCulture->GetGreatWorkCreator(iToBeAcquiredWorkIndex);

	mov	edx, DWORD PTR _pkGameCulture$[esp+152]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+esi*2]
	shl	ecx, 4
	mov	ebp, DWORD PTR [eax+ecx+44]
	add	eax, ecx

; 1425 : 							if (CultureHelpers::IsValidForThemingBonus(pkBonusInfo, eEra, aErasSeen, ePlayer, aPlayersSeen, m_pPlayer->GetID()))

	mov	ecx, DWORD PTR _this$[esp+152]
	mov	edx, DWORD PTR [ecx+292]
	mov	ecx, DWORD PTR [edx+44]
	push	ecx
	lea	edx, DWORD PTR _aPlayersSeen$[esp+156]
	push	edx
	mov	edx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR _pkBonusInfo$224740[esp+160]
	push	ebp
	lea	ecx, DWORD PTR _aErasSeen$[esp+164]
	push	ecx
	push	edx
	push	eax
	call	?IsValidForThemingBonus@CultureHelpers@@YA_NPAVCvThemingBonusInfo@@W4EraTypes@@AAV?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@W4PlayerTypes@@AAV?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@5@3@Z ; CultureHelpers::IsValidForThemingBonus
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN1389@ThemeBuild

; 1426 : 							{
; 1427 : 								aWorksChosen.push_back(iToBeAcquiredWorkIndex);

	lea	ecx, DWORD PTR _iToBeAcquiredWorkIndex$224786[esp+152]
	push	ecx
	lea	ecx, DWORD PTR _aWorksChosen$[esp+156]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 1428 : 								if (CultureHelpers::GetThemingBonusIndex(m_pPlayer->GetID(), pkEntry, aWorksChosen) == iI)

	mov	edx, DWORD PTR _this$[esp+152]
	mov	eax, DWORD PTR [edx+292]
	mov	edx, DWORD PTR _pkEntry$[esp+152]
	mov	eax, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _aWorksChosen$[esp+152]
	push	ecx
	push	edx
	push	eax
	call	?GetThemingBonusIndex@CultureHelpers@@YAHW4PlayerTypes@@PAVCvBuildingEntry@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CultureHelpers::GetThemingBonusIndex
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _iI$224736[esp+152]
	jne	SHORT $LN1389@ThemeBuild

; 1429 : 								{
; 1430 : 									bool bSwapSuccess = pkGameCulture->SwapGreatWorks(m_pPlayer->GetID(), iToBeDiscardedWorkIndex, ePlayer, iToBeAcquiredWorkIndex);

	mov	eax, DWORD PTR _this$[esp+152]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _pkGameCulture$[esp+152]
	push	esi
	push	ebp
	push	edi
	push	eax
	call	?SwapGreatWorks@CvGameCulture@@QAE_NW4PlayerTypes@@H0H@Z ; CvGameCulture::SwapGreatWorks

; 1431 : 									if (bSwapSuccess)

	test	al, al
	jne	SHORT $LN1354@ThemeBuild
$LN1389@ThemeBuild:
	mov	ebp, DWORD PTR _works1$[esp+148]
$LN38@ThemeBuild:

; 1392 : 			{
; 1393 : 				for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)

	inc	DWORD PTR _iLoopPlayer$224778[esp+152]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	$LL39@ThemeBuild
$LN50@ThemeBuild:

; 1335 : #endif
; 1336 : 		{
; 1337 : 			continue;
; 1338 : 		}
; 1339 : 
; 1340 : 		// Try each of the works as the starter
; 1341 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1342 : 		for (it = worksToConsider.begin(); it != worksToConsider.end(); ++it)
; 1343 : #else
; 1344 : 		for (it = worksToConsider.begin(); it != worksToConsider.end(); it++)

	mov	eax, DWORD PTR _it$[esp+152]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _it$[esp+152], eax
	cmp	eax, DWORD PTR _worksToConsider$[esp+160]
	jne	$LL1388@ThemeBuild
	mov	edi, DWORD PTR _works2$[esp+148]
	mov	ebx, DWORD PTR _works1$[esp+148]
$LN64@ThemeBuild:
	mov	eax, DWORD PTR _iI$224736[esp+152]
	mov	edx, DWORD PTR _pkEntry$[esp+152]
	inc	eax
	cmp	eax, DWORD PTR [edx+1008]
	mov	DWORD PTR _iI$224736[esp+152], eax
	jge	$LN63@ThemeBuild

; 1293 : 	}
; 1294 : 
; 1295 : 	// Try each of the theming bonuses for this building
; 1296 : 	for (int iI = 0; iI < pkEntry->GetNumThemingBonuses(); iI++)

	mov	ebp, edx
	jmp	$LL65@ThemeBuild
$LN1354@ThemeBuild:

; 1432 : 									{
; 1433 : 										bThemedProperly = true;
; 1434 : 
; 1435 : 										LogSwapWorks(ePlayer, iToBeDiscardedWorkIndex, iToBeAcquiredWorkIndex);

	mov	ecx, DWORD PTR _this$[esp+152]
	push	esi
	push	edi
	push	ebp
	call	?LogSwapWorks@CvPlayerCulture@@AAEXW4PlayerTypes@@HH@Z ; CvPlayerCulture::LogSwapWorks

; 1436 : 
; 1437 : 										// Update works list
; 1438 : 										tempWorks.clear();

	lea	ecx, DWORD PTR _tempWorks$[esp+152]
	call	?clear@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXXZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::clear

; 1439 : 										if (!pkBonusInfo->IsMustBeArtifact())

	mov	eax, DWORD PTR _pkBonusInfo$224740[esp+152]
	cmp	BYTE PTR [eax+35], 0
	jne	SHORT $LN26@ThemeBuild

; 1440 : 										{
; 1441 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1442 : 											for (it3 = works1.begin(); it3 != works1.end(); ++it3)
; 1443 : #else
; 1444 : 											for (it3 = works1.begin(); it3 != works1.end(); it3++)

	mov	eax, DWORD PTR _works1$[esp+148]
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [eax+8]
	je	SHORT $LN23@ThemeBuild
$LL837@ThemeBuild:

; 1445 : #endif
; 1446 : 											{
; 1447 : 												if (it3->m_iGreatWorkIndex == iToBeDiscardedWorkIndex)

	cmp	DWORD PTR [ebx], edi
	jne	SHORT $LN22@ThemeBuild
	lea	ecx, DWORD PTR [ebx+12]

; 1448 : 												{
; 1449 : 													it3->m_iGreatWorkIndex = iToBeAcquiredWorkIndex;
; 1450 : 													GetGreatWorkLocation(it3->m_iGreatWorkIndex, it3->m_iCityID, it3->m_eBuilding, it3->m_iSlot);

	push	ecx
	mov	ecx, DWORD PTR _this$[esp+156]
	lea	edx, DWORD PTR [ebx+8]
	push	edx
	lea	eax, DWORD PTR [ebx+4]
	push	eax
	push	esi
	mov	DWORD PTR [ebx], esi
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation
$LN22@ThemeBuild:

; 1451 : 												}
; 1452 : 												tempWorks.push_back(*it3);

	push	ebx
	lea	ecx, DWORD PTR _tempWorks$[esp+156]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	ecx, DWORD PTR _works1$[esp+148]
	add	ebx, 24					; 00000018H
	cmp	ebx, DWORD PTR [ecx+8]
	jne	SHORT $LL837@ThemeBuild
$LN23@ThemeBuild:

; 1453 : 											}
; 1454 : 											works1 = tempWorks;

	mov	ecx, DWORD PTR _works1$[esp+148]
	lea	edx, DWORD PTR _tempWorks$[esp+152]
	push	edx

; 1455 : 										}
; 1456 : 										else

	jmp	SHORT $LN1395@ThemeBuild
$LN26@ThemeBuild:

; 1457 : 										{
; 1458 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1459 : 											for (it3 = works2.begin(); it3 != works2.end(); ++it3)
; 1460 : #else
; 1461 : 											for (it3 = works2.begin(); it3 != works2.end(); it3++)

	mov	eax, DWORD PTR _works2$[esp+148]
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [eax+8]
	je	SHORT $LN18@ThemeBuild
$LL899@ThemeBuild:

; 1462 : #endif
; 1463 : 											{
; 1464 : 												if (it3->m_iGreatWorkIndex == iToBeDiscardedWorkIndex)

	cmp	DWORD PTR [ebx], edi
	jne	SHORT $LN17@ThemeBuild
	lea	eax, DWORD PTR [ebx+12]

; 1465 : 												{
; 1466 : 													it3->m_iGreatWorkIndex = iToBeAcquiredWorkIndex;
; 1467 : 													GetGreatWorkLocation(it3->m_iGreatWorkIndex, it3->m_iCityID, it3->m_eBuilding, it3->m_iSlot);

	push	eax
	lea	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+160]
	lea	edx, DWORD PTR [ebx+4]
	push	edx
	push	esi
	mov	DWORD PTR [ebx], esi
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation
$LN17@ThemeBuild:

; 1468 : 												}
; 1469 : 												tempWorks.push_back(*it3);

	push	ebx
	lea	ecx, DWORD PTR _tempWorks$[esp+156]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	eax, DWORD PTR _works2$[esp+148]
	add	ebx, 24					; 00000018H
	cmp	ebx, DWORD PTR [eax+8]
	jne	SHORT $LL899@ThemeBuild
$LN18@ThemeBuild:

; 1470 : 											}
; 1471 : 											works2 = tempWorks;

	lea	ecx, DWORD PTR _tempWorks$[esp+152]
	push	ecx
	mov	ecx, DWORD PTR _works2$[esp+152]
$LN1395@ThemeBuild:
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1472 : 										}
; 1473 : 
; 1474 : 										CultureHelpers::SendArtSwapNotification(pkEntry->GetGreatWorkSlotType(), pkBonusInfo->IsMustBeArt(), m_pPlayer->GetID(), ePlayer, iToBeDiscardedWorkIndex, iToBeAcquiredWorkIndex);

	mov	edx, DWORD PTR _this$[esp+152]
	mov	eax, DWORD PTR [edx+292]
	mov	ecx, DWORD PTR _pkBonusInfo$224740[esp+152]
	mov	eax, DWORD PTR [eax+44]
	mov	dl, BYTE PTR [ecx+34]
	mov	ecx, DWORD PTR _pkEntry$[esp+152]
	push	esi
	push	edi
	push	ebp
	push	eax
	mov	BYTE PTR $T265698[esp+168], dl
	mov	eax, DWORD PTR $T265698[esp+168]
	push	eax
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	push	eax
	call	?SendArtSwapNotification@CultureHelpers@@YAXW4GreatWorkSlotType@@_NW4PlayerTypes@@2HH@Z ; CultureHelpers::SendArtSwapNotification
	add	esp, 24					; 00000018H
$LN1355@ThemeBuild:

; 1475 : 										break;  // Themed it through acquisition
; 1476 : 									}
; 1477 : 								}
; 1478 : 							}
; 1479 : 						}
; 1480 : 					}
; 1481 : 				}
; 1482 : 			}
; 1483 : 
; 1484 : 			if (bThemedProperly)
; 1485 : 			{
; 1486 : 				for (int jJ = 0; jJ < (int)aWorksChosen.size(); jJ++)

	mov	ebp, DWORD PTR _aWorksChosen$[esp+160]
	sub	ebp, DWORD PTR _aWorksChosen$[esp+156]
	mov	ebx, DWORD PTR _this$[esp+152]
	sar	ebp, 2
	xor	edi, edi
	test	ebp, ebp
	jle	$LN13@ThemeBuild
	mov	eax, DWORD PTR _worksToConsider$[esp+160]
	sub	eax, DWORD PTR _worksToConsider$[esp+156]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LL15@ThemeBuild:

; 1487 : 				{
; 1488 : 					for (int kK = 0; kK < (int)worksToConsider.size(); kK++)

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN14@ThemeBuild
	mov	ecx, DWORD PTR _aWorksChosen$[esp+156]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _worksToConsider$[esp+156]
$LL12@ThemeBuild:

; 1489 : 					{
; 1490 : 						if (worksToConsider[kK].m_iGreatWorkIndex == aWorksChosen[jJ])

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN1357@ThemeBuild
	inc	eax
	add	ecx, 24					; 00000018H
	cmp	eax, esi
	jl	SHORT $LL12@ThemeBuild

; 1520 : #endif
; 1521 : 				{
; 1522 : 					// Copy it over if not chosen, updating its location
; 1523 : 					if (find(aWorksChosen.begin(), aWorksChosen.end(), it3->m_iGreatWorkIndex) == aWorksChosen.end())

	jmp	SHORT $LN14@ThemeBuild
$LN1357@ThemeBuild:

; 1491 : 						{
; 1492 : 							MoveWorkIntoSlot(worksToConsider[kK], buildingIt->m_iCityID, buildingIt->m_eBuilding, jJ);

	mov	ecx, DWORD PTR _buildingIt$[esp+148]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	push	edx
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _worksToConsider$[esp+164]
	lea	eax, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax]
	push	ecx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, ebx
	call	?MoveWorkIntoSlot@CvPlayerCulture@@QAEXVCvGreatWorkInMyEmpire@@HW4BuildingTypes@@H@Z ; CvPlayerCulture::MoveWorkIntoSlot
$LN14@ThemeBuild:
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL15@ThemeBuild
$LN13@ThemeBuild:

; 1493 : 							break;
; 1494 : 						}
; 1495 : 					}
; 1496 : 				}
; 1497 : 
; 1498 : 				// Remove these works from those to consider later
; 1499 : 				tempWorks.clear();

	mov	eax, DWORD PTR _tempWorks$[esp+156]
	cmp	eax, DWORD PTR _tempWorks$[esp+160]
	je	SHORT $LN989@ThemeBuild
	mov	DWORD PTR _tempWorks$[esp+160], eax
$LN989@ThemeBuild:

; 1500 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1501 : 				for (it3 = works1.begin(); it3 != works1.end(); ++it3)
; 1502 : #else
; 1503 : 				for (it3 = works1.begin(); it3 != works1.end(); it3++)

	mov	edi, DWORD PTR _works1$[esp+148]
	mov	esi, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR _aWorksChosen$[esp+160]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN6@ThemeBuild
	mov	edx, DWORD PTR _aWorksChosen$[esp+156]
$LL1029@ThemeBuild:

; 1504 : #endif
; 1505 : 				{
; 1506 : 					// Copy it over if not chosen, updating its location
; 1507 : 					if (find(aWorksChosen.begin(), aWorksChosen.end(), it3->m_iGreatWorkIndex) == aWorksChosen.end())

	mov	eax, edx
	cmp	edx, ebp
	je	SHORT $LN1379@ThemeBuild
	mov	ecx, DWORD PTR [esi]
	npad	5
$LL1075@ThemeBuild:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1358@ThemeBuild
	add	eax, 4
	cmp	eax, ebp
	jne	SHORT $LL1075@ThemeBuild
	jmp	SHORT $LN1379@ThemeBuild
$LN1358@ThemeBuild:
	cmp	eax, ebp
	jne	SHORT $LN7@ThemeBuild
$LN1379@ThemeBuild:

; 1500 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1501 : 				for (it3 = works1.begin(); it3 != works1.end(); ++it3)
; 1502 : #else
; 1503 : 				for (it3 = works1.begin(); it3 != works1.end(); it3++)

	lea	ecx, DWORD PTR [esi+12]

; 1508 : 					{
; 1509 : 						GetGreatWorkLocation(it3->m_iGreatWorkIndex, it3->m_iCityID, it3->m_eBuilding, it3->m_iSlot);

	push	ecx
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+8]
	push	edx
	lea	eax, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1510 : 						tempWorks.push_back(*it3);

	push	esi
	lea	ecx, DWORD PTR _tempWorks$[esp+156]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	edx, DWORD PTR _aWorksChosen$[esp+156]
$LN7@ThemeBuild:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL1029@ThemeBuild
$LN6@ThemeBuild:

; 1511 : 					}
; 1512 : 				}
; 1513 : 				works1 = tempWorks;

	lea	edx, DWORD PTR _tempWorks$[esp+152]
	push	edx
	mov	ecx, edi
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1514 : 
; 1515 : 				tempWorks.clear();

	mov	eax, DWORD PTR _tempWorks$[esp+156]
	cmp	eax, DWORD PTR _tempWorks$[esp+160]
	je	SHORT $LN1129@ThemeBuild
	mov	DWORD PTR _tempWorks$[esp+160], eax
$LN1129@ThemeBuild:

; 1516 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1517 : 				for (it3 = works2.begin(); it3 != works2.end(); ++it3)
; 1518 : #else
; 1519 : 				for (it3 = works2.begin(); it3 != works2.end(); it3++)

	mov	edi, DWORD PTR _works2$[esp+148]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN2@ThemeBuild
	mov	edx, DWORD PTR _aWorksChosen$[esp+156]
	npad	6
$LL1169@ThemeBuild:

; 1520 : #endif
; 1521 : 				{
; 1522 : 					// Copy it over if not chosen, updating its location
; 1523 : 					if (find(aWorksChosen.begin(), aWorksChosen.end(), it3->m_iGreatWorkIndex) == aWorksChosen.end())

	mov	eax, edx
	cmp	edx, ebp
	je	SHORT $LN1380@ThemeBuild
	mov	ecx, DWORD PTR [esi]
$LL1215@ThemeBuild:
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1359@ThemeBuild
	add	eax, 4
	cmp	eax, ebp
	jne	SHORT $LL1215@ThemeBuild
	jmp	SHORT $LN1380@ThemeBuild
$LN1359@ThemeBuild:
	cmp	eax, ebp
	jne	SHORT $LN3@ThemeBuild
$LN1380@ThemeBuild:

; 1516 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1517 : 				for (it3 = works2.begin(); it3 != works2.end(); ++it3)
; 1518 : #else
; 1519 : 				for (it3 = works2.begin(); it3 != works2.end(); it3++)

	lea	eax, DWORD PTR [esi+12]

; 1524 : 					{
; 1525 : 						GetGreatWorkLocation(it3->m_iGreatWorkIndex, it3->m_iCityID, it3->m_eBuilding, it3->m_iSlot);

	push	eax
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	lea	edx, DWORD PTR [esi+4]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?GetGreatWorkLocation@CvPlayerCulture@@QAE_NHAAHAAW4BuildingTypes@@0@Z ; CvPlayerCulture::GetGreatWorkLocation

; 1526 : 						tempWorks.push_back(*it3);

	push	esi
	lea	ecx, DWORD PTR _tempWorks$[esp+156]
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
	mov	edx, DWORD PTR _aWorksChosen$[esp+156]
$LN3@ThemeBuild:
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL1169@ThemeBuild
$LN2@ThemeBuild:

; 1527 : 					}
; 1528 : 				}
; 1529 : 				works2 = tempWorks;

	lea	ecx, DWORD PTR _tempWorks$[esp+152]
	push	ecx
	mov	ecx, edi
	call	??4?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::operator=

; 1530 : 
; 1531 : 				// All done
; 1532 : 				LogThemedBuilding(buildingIt->m_iCityID, buildingIt->m_eBuilding, pkBonusInfo->GetBonus());

	mov	edx, DWORD PTR _pkBonusInfo$224740[esp+152]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	eax, DWORD PTR _buildingIt$[esp+152]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?LogThemedBuilding@CvPlayerCulture@@AAEXHW4BuildingTypes@@H@Z ; CvPlayerCulture::LogThemedBuilding

; 1533 : 				return true;

	mov	eax, DWORD PTR _aErasSeen$[esp+156]
	test	eax, eax
	je	SHORT $LN1270@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1270@ThemeBuild:
	mov	eax, DWORD PTR _aPlayersSeen$[esp+156]
	test	eax, eax
	je	SHORT $LN1277@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1277@ThemeBuild:
	mov	eax, DWORD PTR _aWorksChosen$[esp+156]
	test	eax, eax
	je	SHORT $LN1284@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1284@ThemeBuild:
	mov	eax, DWORD PTR _tempWorks$[esp+156]
	test	eax, eax
	je	SHORT $LN1291@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1291@ThemeBuild:
	mov	eax, DWORD PTR _worksToConsider$[esp+156]
	test	eax, eax
	je	SHORT $LN1298@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1298@ThemeBuild:
	mov	al, 1
	jmp	SHORT $LN68@ThemeBuild
$LN63@ThemeBuild:

; 1534 : 			}
; 1535 : 		}
; 1536 : 	}
; 1537 : 	return false;

	mov	eax, DWORD PTR _aErasSeen$[esp+156]
	test	eax, eax
	je	SHORT $LN1305@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1305@ThemeBuild:
	mov	eax, DWORD PTR _aPlayersSeen$[esp+156]
	test	eax, eax
	je	SHORT $LN1312@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1312@ThemeBuild:
	mov	eax, DWORD PTR _aWorksChosen$[esp+156]
	test	eax, eax
	je	SHORT $LN1326@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1326@ThemeBuild:
	mov	eax, DWORD PTR _worksToConsider$[esp+156]
	test	eax, eax
	je	SHORT $LN66@ThemeBuild
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN66@ThemeBuild:

; 1291 : 	{
; 1292 : 		return false;

	xor	al, al
$LN68@ThemeBuild:

; 1538 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 136				; 00000088H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$0:
	lea	ecx, DWORD PTR _worksToConsider$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$1:
	lea	ecx, DWORD PTR _tempWorks$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$2:
	lea	ecx, DWORD PTR _aWorksChosen$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$3:
	lea	ecx, DWORD PTR _aPlayersSeen$[ebp]
	jmp	??1?$vector@W4PlayerTypes@@V?$allocator@W4PlayerTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >::~vector<enum PlayerTypes,std::allocator<enum PlayerTypes> >
__unwindfunclet$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z$4:
	lea	ecx, DWORD PTR _aErasSeen$[ebp]
	jmp	??1?$vector@W4EraTypes@@V?$allocator@W4EraTypes@@@std@@@std@@QAE@XZ ; std::vector<enum EraTypes,std::allocator<enum EraTypes> >::~vector<enum EraTypes,std::allocator<enum EraTypes> >
__ehhandler$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z ENDP ; CvPlayerCulture::ThemeBuilding
PUBLIC	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z PROC ; CvCityCulture::GetThemingBonus, COMDAT
; _this$ = ecx

; 5257 : {

	push	ebx
	push	ebp

; 5258 : 	CvPlayer &kPlayer = GET_PLAYER(m_pCity->getOwner());
; 5259 : 	int iRtnValue = 0;
; 5260 : 
; 5261 : 	if (IsThemingBonusPossible(eBuildingClass))

	mov	ebp, DWORD PTR _eBuildingClass$[esp+4]
	push	esi
	push	edi
	mov	ebx, ecx
	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+84]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	xor	esi, esi
	call	?IsThemingBonusPossible@CvCityCulture@@QBE_NW4BuildingClassTypes@@@Z ; CvCityCulture::IsThemingBonusPossible
	test	al, al
	je	$LN1@GetTheming@3

; 5262 : 	{
; 5263 : 		int iIndex = GetThemingBonusIndex(eBuildingClass);

	push	ebp
	mov	ecx, ebx
	call	?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonusIndex
	mov	ebp, eax

; 5264 : 		if (iIndex >= 0)

	test	ebp, ebp
	jl	$LN1@GetTheming@3

; 5265 : 		{
; 5266 : 			BuildingTypes eBuilding = (BuildingTypes)kPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	mov	ecx, DWORD PTR _eBuildingClass$[esp+12]
	push	ecx
	mov	ecx, edi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 5267 : 			CvBuildingEntry *pkBuilding = GC.GetGameBuildings()->GetEntry(eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 5268 : 			if (pkBuilding)

	test	eax, eax
	je	$LN1@GetTheming@3

; 5269 : 			{
; 5270 : 				int iBonus = pkBuilding->GetThemingBonusInfo(iIndex)->GetBonus();

	push	ebp
	mov	ecx, eax
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	esi, DWORD PTR [eax]

; 5271 : 				int iModifier = kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_THEMING_BONUS);

	push	41					; 00000029H
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ecx, eax

; 5272 : 				iRtnValue = iBonus * (100 + iModifier) / 100;

	add	ecx, 100				; 00000064H
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 5273 : 				if (m_pCity->isCapital())

	mov	ecx, DWORD PTR [ebx]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN1@GetTheming@3

; 5274 : 				{
; 5275 : 					iModifier = kPlayer.GetPlayerTraits()->GetCapitalThemingBonusModifier();

	mov	ecx, edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+148]

; 5276 : 					if (iModifier > 0)

	test	eax, eax
	jle	SHORT $LN1@GetTheming@3

; 5277 : 					{
; 5278 : 						iRtnValue = iRtnValue * (100 + iModifier) / 100;

	lea	ecx, DWORD PTR [eax+100]
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 5279 : 
; 5280 : 						if (kPlayer.isHuman() && !GC.getGame().isGameMultiPlayer() && iRtnValue >= 16)

	mov	ecx, edi
	mov	esi, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN1@GetTheming@3
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN1@GetTheming@3
	cmp	esi, 16					; 00000010H
	jl	SHORT $LN1@GetTheming@3

; 5281 : 						{
; 5282 : 							gDLL->UnlockAchievement(ACHIEVEMENT_XP2_40);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	282					; 0000011aH
	call	eax
$LN1@GetTheming@3:
	pop	edi

; 5283 : 						}
; 5284 : 					}
; 5285 : 				}
; 5286 : 			}
; 5287 : 		}
; 5288 : 	}
; 5289 : 
; 5290 : 	return iRtnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 5291 : }

	ret	4
?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvCityCulture::GetThemingBonus
_TEXT	ENDS
PUBLIC	?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingTooltip
EXTRN	?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ:PROC ; CvBuildingEntry::GetThemingBonusHelp
EXTRN	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationAdjectiveKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z DD 019930522H
	DD	01eH
	DD	FLAT:__unwindtable$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$11
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$13
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$13
	DD	0eH
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$15
	DD	010H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$16
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$17
	DD	012H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$18
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$18
	DD	014H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$19
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$20
	DD	016H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$21
	DD	07H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$21
	DD	018H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$22
	DD	02H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$23
	DD	02H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$24
	DD	02H
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$25
	DD	01cH
	DD	FLAT:__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$26
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z
_TEXT	SEGMENT
$T267000 = -516						; size = 4
$T266997 = -516						; size = 4
$T266992 = -516						; size = 4
$T267010 = -512						; size = 4
_szThemeDescription$ = -508				; size = 28
$T267006 = -480						; size = 28
$T267004 = -480						; size = 28
$T267003 = -480						; size = 28
$T267001 = -480						; size = 28
$T266987 = -480						; size = 28
_szCivAdj$227495 = -452					; size = 28
_szEraString$227494 = -424				; size = 28
$T267005 = -396						; size = 28
$T267002 = -396						; size = 28
$T266986 = -396						; size = 28
_szBonusString$ = -368					; size = 28
$T266990 = -340						; size = 28
$T266995 = -312						; size = 28
$T266999 = -284						; size = 28
$T266994 = -256						; size = 28
$T266998 = -228						; size = 28
$T266996 = -200						; size = 28
$T266988 = -172						; size = 28
$T266993 = -144						; size = 28
$T266991 = -116						; size = 28
$T266989 = -88						; size = 28
_work$227493 = -60					; size = 48
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eBuildingClass$ = 12					; size = 4
?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z PROC ; CvCityCulture::GetThemingTooltip, COMDAT
; _this$ = ecx

; 5294 : {

	push	-1
	push	__ehhandler$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 504				; 000001f8H
	push	ebx
	xor	eax, eax
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+532], eax
	mov	DWORD PTR $T267010[esp+524], eax
	mov	ebp, ecx

; 5295 : 	CvPlayer &kPlayer = GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi

; 5296 : 	CvString szBonusString = "";

	push	OFFSET $SG227470
	lea	ecx, DWORD PTR _szBonusString$[esp+536]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edi, 1

; 5297 : 	CvString szThemeDescription = "";

	push	OFFSET $SG227472
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	DWORD PTR __$EHRec$[esp+544], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 5298 : 	CvString szRtnValue = "";

	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+528]
	push	OFFSET $SG227474
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+544], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 5359 : 			}
; 5360 : 		}
; 5361 : 	}
; 5362 : 
; 5363 : 	return szRtnValue;

	mov	DWORD PTR $T267010[esp+532], edi
	mov	edi, DWORD PTR _eBuildingClass$[esp+528]
	push	edi
	mov	ecx, ebp
	call	?IsThemingBonusPossible@CvCityCulture@@QBE_NW4BuildingClassTypes@@@Z ; CvCityCulture::IsThemingBonusPossible
	test	al, al
	je	$LN1@GetTheming@4
	push	edi
	mov	ecx, esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	esi, eax
	test	esi, esi
	je	$LN1@GetTheming@4
	push	edi
	mov	ecx, ebp
	call	?GetThemingBonusIndex@CvCityCulture@@ABEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonusIndex
	mov	edi, eax
	test	edi, edi
	jl	$LN13@GetTheming@4
	mov	ecx, DWORD PTR _eBuildingClass$[esp+528]
	push	ecx
	mov	ecx, ebp
	call	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonus
	push	eax
	lea	edx, DWORD PTR _szBonusString$[esp+536]
	push	OFFSET $SG227482
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH
	push	0
	push	OFFSET $SG227487
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebx, eax
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	cmp	eax, ebx
	je	$LN11@GetTheming@4
	push	0
	push	OFFSET $SG227488
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, esi
	mov	ebx, eax
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	cmp	eax, ebx
	je	$LN11@GetTheming@4
	mov	eax, DWORD PTR _eBuildingClass$[esp+528]
	mov	ecx, DWORD PTR [ebp]
	push	0
	push	eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	lea	ecx, DWORD PTR [ebx+ebx*2]
	shl	ecx, 4
	add	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _work$227493[esp+536]
	call	??0CvGreatWork@@QAE@ABV0@@Z
	mov	ecx, DWORD PTR _work$227493[esp+572]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+544], 5
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getShortDesc@CvEraInfo@@QBEPBDXZ	; CvEraInfo::getShortDesc
	push	eax
	lea	ecx, DWORD PTR _szEraString$227494[esp+536]
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+540], 6
	mov	ecx, eax
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _szCivAdj$227495[esp+536]
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	bl, 7
	mov	BYTE PTR __$EHRec$[esp+540], bl
	cmp	edi, 11					; 0000000bH
	ja	$LN8@GetTheming@4

; 5315 : 				}
; 5316 : 				else
; 5317 : 				{
; 5318 : 					int iGreatWork = m_pCity->GetCityBuildings()->GetBuildingGreatWork(eBuildingClass, 0);
; 5319 : 					CvGreatWork work = GC.getGame().GetGameCulture()->m_CurrentGreatWorks[iGreatWork];
; 5320 : 					CvString szEraString = GC.getEraInfo(work.m_eEra)->getShortDesc();
; 5321 : 					CvString szCivAdj = GET_PLAYER(m_pCity->getOwner()).getCivilizationAdjectiveKey();
; 5322 : 					switch (iIndex)

	jmp	DWORD PTR $LN193@GetTheming@4[edi*4]
$LN7@GetTheming@4:

; 5323 : 					{
; 5324 : 					case 0:
; 5325 : 					case 2:
; 5326 : 						szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription(), szEraString, szCivAdj);

	lea	eax, DWORD PTR $T266988[esp+532]
	push	eax
	push	edi
	mov	ecx, esi
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+540], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _szCivAdj$227495[esp+532]
	push	ecx
	lea	edx, DWORD PTR _szEraString$227494[esp+536]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T266989[esp+544]
	push	eax
	call	??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z ; GetLocalizedText<CvString,CvString>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 9
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266989[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T266988[esp+532]

; 5327 : 						break;

	jmp	$LN190@GetTheming@4
$LN6@GetTheming@4:

; 5328 : 					case 1:
; 5329 : 					case 3:
; 5330 : 						szCivAdj = "TXT_KEY_CO_WORLD_MUSEUM";

	push	OFFSET $SG227504
	lea	ecx, DWORD PTR _szCivAdj$227495[esp+536]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 5331 : 						szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription(), szEraString, szCivAdj);

	lea	ecx, DWORD PTR $T266990[esp+532]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+540], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edx, DWORD PTR _szCivAdj$227495[esp+532]
	push	edx
	lea	ecx, DWORD PTR _szEraString$227494[esp+536]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T266991[esp+544]
	push	edx
	call	??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z ; GetLocalizedText<CvString,CvString>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 11		; 0000000bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266991[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T266990[esp+532]

; 5332 : 						break;

	jmp	$LN190@GetTheming@4
$LN5@GetTheming@4:

; 5333 : 					case 4:
; 5334 : 					case 5:
; 5335 : 					case 7:
; 5336 : 						szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription(), szEraString);

	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _szEraString$227494[esp+560]
	mov	DWORD PTR $T266992[esp+560], esp
	mov	ecx, esp
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR $T266993[esp+560]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+576], 12		; 0000000cH
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+568], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR $T266994[esp+564]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+576], 14		; 0000000eH
	call	??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z ; GetLocalizedText<CvString>
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 15		; 0000000fH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266994[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 14		; 0000000eH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T266993[esp+532]

; 5337 : 						break;

	jmp	$LN190@GetTheming@4
$LN4@GetTheming@4:

; 5338 : 					case 6:
; 5339 : 						szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription(), szCivAdj, szEraString);

	lea	eax, DWORD PTR $T266995[esp+532]
	push	eax
	push	6
	mov	ecx, esi
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+540], 16		; 00000010H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _szEraString$227494[esp+532]
	push	ecx
	lea	edx, DWORD PTR _szCivAdj$227495[esp+536]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T266996[esp+544]
	push	eax
	call	??$GetLocalizedText@VCvString@@V1@@@YA?AVCvString@@PBDABV0@1@Z ; GetLocalizedText<CvString,CvString>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 17		; 00000011H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266996[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 16		; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T266995[esp+532]

; 5340 : 						break;

	jmp	$LN190@GetTheming@4
$LN3@GetTheming@4:

; 5341 : 					case 8:
; 5342 : 					case 10:
; 5343 : 						szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription(), szCivAdj);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _szCivAdj$227495[esp+560]
	mov	DWORD PTR $T266997[esp+560], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR $T266998[esp+560]
	push	eax
	push	edi
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+576], 18		; 00000012H
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+568], 19		; 00000013H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR $T266999[esp+564]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+576], 20		; 00000014H
	call	??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z ; GetLocalizedText<CvString>
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 21		; 00000015H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266999[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 20		; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T266998[esp+532]

; 5344 : 						break;

	jmp	$LN190@GetTheming@4
$LN2@GetTheming@4:

; 5345 : 					case 9:
; 5346 : 					case 11:
; 5347 : 						szCivAdj = "TXT_KEY_CO_WORLD_MUSEUM";

	push	OFFSET $SG227524
	lea	ecx, DWORD PTR _szCivAdj$227495[esp+536]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 5348 : 						szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription(), szCivAdj);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _szCivAdj$227495[esp+560]
	mov	DWORD PTR $T267000[esp+560], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR $T267001[esp+560]
	push	eax
	push	edi
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+576], 22		; 00000016H
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+568], 23		; 00000017H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR $T267002[esp+564]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+576], 24		; 00000018H
	call	??$GetLocalizedText@VCvString@@@@YA?AVCvString@@PBDV0@@Z ; GetLocalizedText<CvString>
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 25		; 00000019H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267002[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 24		; 00000018H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T267001[esp+532]
$LN190@GetTheming@4:
	mov	BYTE PTR __$EHRec$[esp+540], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@GetTheming@4:

; 5349 : 						break;
; 5350 : 					}
; 5351 : 				}

	lea	ecx, DWORD PTR _szCivAdj$227495[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szEraString$227494[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _work$227493[esp+532]
	jmp	SHORT $LN191@GetTheming@4
$LN11@GetTheming@4:

; 5299 : 
; 5300 : 	if (IsThemingBonusPossible(eBuildingClass))
; 5301 : 	{
; 5302 : 		BuildingTypes eBuilding = (BuildingTypes)kPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
; 5303 : 		CvBuildingEntry *pkBuilding = GC.GetGameBuildings()->GetEntry(eBuilding);
; 5304 : 		if (pkBuilding)
; 5305 : 		{
; 5306 : 			int iIndex = GetThemingBonusIndex(eBuildingClass);
; 5307 : 			if (iIndex >= 0)
; 5308 : 			{
; 5309 : 				szBonusString.Format("+%d: ", GetThemingBonus(eBuildingClass));
; 5310 : 
; 5311 : 				if (pkBuilding->GetBuildingClassType() == (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_LOUVRE") ||
; 5312 : 					pkBuilding->GetBuildingClassType() == (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_HERMITAGE"))
; 5313 : 				{
; 5314 : 					szThemeDescription = GetLocalizedText(pkBuilding->GetThemingBonusInfo(iIndex)->GetDescription());

	lea	edx, DWORD PTR $T266986[esp+532]
	push	edx
	push	edi
	mov	ecx, esi
	call	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
	mov	ecx, eax
	call	?GetDescription@CvThemingBonusInfo@@QAE?AVCvString@@XZ ; CvThemingBonusInfo::GetDescription
	mov	bl, 3
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+540], bl
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T266987[esp+536]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _szThemeDescription$[esp+536]
	mov	BYTE PTR __$EHRec$[esp+544], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266987[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T266986[esp+532]
$LN191@GetTheming@4:
	mov	BYTE PTR __$EHRec$[esp+540], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5352 : 				szRtnValue = szBonusString + szThemeDescription;

	lea	ecx, DWORD PTR _szThemeDescription$[esp+532]
	push	ecx
	lea	edx, DWORD PTR _szBonusString$[esp+536]
	push	edx
	lea	eax, DWORD PTR $T267003[esp+540]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+540], 26		; 0000001aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+528]
	push	eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T267003[esp+532]

; 5353 : 			}
; 5354 : 			else

	jmp	$LN192@GetTheming@4
$LN13@GetTheming@4:

; 5355 : 			{
; 5356 : 				szRtnValue = GetLocalizedText("TXT_KEY_CO_NO_THEME");

	lea	ecx, DWORD PTR $T267004[esp+532]
	push	OFFSET $SG227531
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+544], 27		; 0000001bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267004[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5357 : 				szRtnValue += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG227532
	mov	ecx, ebx
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5358 : 				szRtnValue += GetLocalizedText(pkBuilding->GetThemingBonusHelp());

	lea	edx, DWORD PTR $T267005[esp+532]
	push	edx
	mov	ecx, esi
	call	?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ ; CvBuildingEntry::GetThemingBonusHelp
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+540], 28		; 0000001cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T267006[esp+536]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+544], 29		; 0000001dH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267006[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 28		; 0000001cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T267005[esp+532]
$LN192@GetTheming@4:
	mov	BYTE PTR __$EHRec$[esp+540], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@GetTheming@4:

; 5359 : 			}
; 5360 : 		}
; 5361 : 	}
; 5362 : 
; 5363 : 	return szRtnValue;

	lea	ecx, DWORD PTR _szThemeDescription$[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szBonusString$[esp+532]
	mov	BYTE PTR __$EHRec$[esp+540], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5364 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+532]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 516				; 00000204H
	ret	8
	npad	3
$LN193@GetTheming@4:
	DD	$LN7@GetTheming@4
	DD	$LN6@GetTheming@4
	DD	$LN7@GetTheming@4
	DD	$LN6@GetTheming@4
	DD	$LN5@GetTheming@4
	DD	$LN5@GetTheming@4
	DD	$LN4@GetTheming@4
	DD	$LN5@GetTheming@4
	DD	$LN3@GetTheming@4
	DD	$LN2@GetTheming@4
	DD	$LN3@GetTheming@4
	DD	$LN2@GetTheming@4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$0:
	lea	ecx, DWORD PTR _szBonusString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$1:
	lea	ecx, DWORD PTR _szThemeDescription$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$2:
	mov	eax, DWORD PTR $T267010[ebp]
	and	eax, 1
	je	$LN21@GetTheming@4
	and	DWORD PTR $T267010[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN21@GetTheming@4:
	ret	0
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$5:
	lea	ecx, DWORD PTR _work$227493[ebp]
	jmp	??1CvGreatWork@@QAE@XZ
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$6:
	lea	ecx, DWORD PTR _szEraString$227494[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$7:
	lea	ecx, DWORD PTR _szCivAdj$227495[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$8:
	lea	ecx, DWORD PTR $T266988[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$9:
	lea	ecx, DWORD PTR $T266989[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$10:
	lea	ecx, DWORD PTR $T266990[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$11:
	lea	ecx, DWORD PTR $T266991[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$12:
	mov	ecx, DWORD PTR $T266992[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$13:
	lea	ecx, DWORD PTR $T266993[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$14:
	lea	ecx, DWORD PTR $T266994[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$15:
	lea	ecx, DWORD PTR $T266995[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$16:
	lea	ecx, DWORD PTR $T266996[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$17:
	mov	ecx, DWORD PTR $T266997[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$18:
	lea	ecx, DWORD PTR $T266998[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$19:
	lea	ecx, DWORD PTR $T266999[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$20:
	mov	ecx, DWORD PTR $T267000[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$21:
	lea	ecx, DWORD PTR $T267001[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$22:
	lea	ecx, DWORD PTR $T267002[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$3:
	lea	ecx, DWORD PTR $T266986[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$4:
	lea	ecx, DWORD PTR $T266987[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$23:
	lea	ecx, DWORD PTR $T267003[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$24:
	lea	ecx, DWORD PTR $T267004[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$25:
	lea	ecx, DWORD PTR $T267005[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z$26:
	lea	ecx, DWORD PTR $T267006[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetThemingTooltip@CvCityCulture@@QBE?AVCvString@@W4BuildingClassTypes@@@Z ENDP ; CvCityCulture::GetThemingTooltip
PUBLIC	?GetGreatWorkCurrentThemingBonus@CvGameCulture@@QBEHH@Z ; CvGameCulture::GetGreatWorkCurrentThemingBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkCurrentThemingBonus@CvGameCulture@@QBEHH@Z
_TEXT	SEGMENT
tv241 = -8						; size = 4
_iCityLoop$223221 = -4					; size = 4
_iIndex$ = 8						; size = 4
?GetGreatWorkCurrentThemingBonus@CvGameCulture@@QBEHH@Z PROC ; CvGameCulture::GetGreatWorkCurrentThemingBonus, COMDAT
; _this$ = ecx

; 338  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 339  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 340  : 
; 341  : 	// for each player
; 342  : 	//   for each building
; 343  : 	//     for each slot
; 344  : 	//       check to see if it holds this work
; 345  : 
; 346  : 	for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR tv241[esp+24], ebx
	npad	3
$LL16@GetGreatWo@12:

; 347  : 	{
; 348  : 		PlayerTypes ePlayer = (PlayerTypes)uiPlayer;
; 349  : 
; 350  : 		int iCityLoop;
; 351  : 		CvCity* pCity = NULL;
; 352  : 		for (pCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pCity != NULL; pCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop$223221[esp+28]
	lea	ecx, DWORD PTR [ebx+eax]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN15@GetGreatWo@12
	npad	2
$LL13@GetGreatWo@12:

; 353  : 		{
; 354  : #ifdef AUI_WARNING_FIXES
; 355  : 			for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 356  : #else
; 357  : 			for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN12@GetGreatWo@12
	npad	12
$LL10@GetGreatWo@12:

; 358  : #endif
; 359  : 			{
; 360  : 				BuildingClassTypes eBuildingClass = (BuildingClassTypes)iBuildingClassLoop;
; 361  : 				CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 362  : 				BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	esi, eax

; 363  : 				if (eBuilding != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN9@GetGreatWo@12

; 364  : 				{
; 365  : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax

; 366  : 					if (pkBuilding)

	test	ebx, ebx
	je	SHORT $LN34@GetGreatWo@12

; 367  : 					{
; 368  : 						if (pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	esi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN34@GetGreatWo@12

; 369  : 						{
; 370  : 							int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, ebx
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	ebx, eax

; 371  : 							for (int iI = 0; iI < iNumSlots; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN34@GetGreatWo@12
	npad	1
$LL4@GetGreatWo@12:

; 372  : 							{
; 373  : 								int iGreatWorkIndex = pCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	push	esi
	push	edi
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork

; 374  : 								if (iGreatWorkIndex == iIndex)

	cmp	eax, DWORD PTR _iIndex$[esp+20]
	je	SHORT $LN29@GetGreatWo@12
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL4@GetGreatWo@12
$LN34@GetGreatWo@12:

; 371  : 							for (int iI = 0; iI < iNumSlots; iI++)

	mov	ebx, DWORD PTR tv241[esp+24]
$LN9@GetGreatWo@12:

; 353  : 		{
; 354  : #ifdef AUI_WARNING_FIXES
; 355  : 			for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 356  : #else
; 357  : 			for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	jl	SHORT $LL10@GetGreatWo@12
$LN12@GetGreatWo@12:

; 347  : 	{
; 348  : 		PlayerTypes ePlayer = (PlayerTypes)uiPlayer;
; 349  : 
; 350  : 		int iCityLoop;
; 351  : 		CvCity* pCity = NULL;
; 352  : 		for (pCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pCity != NULL; pCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop$223221[esp+28]
	add	ecx, ebx
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL13@GetGreatWo@12
$LN15@GetGreatWo@12:

; 339  : 	CvAssertMsg (iIndex < GetNumGreatWorks(), "Bad Great Work index");
; 340  : 
; 341  : 	// for each player
; 342  : 	//   for each building
; 343  : 	//     for each slot
; 344  : 	//       check to see if it holds this work
; 345  : 
; 346  : 	for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	add	ebx, 63236				; 0000f704H
	mov	DWORD PTR tv241[esp+24], ebx
	cmp	ebx, 1391192				; 00153a58H
	jb	$LL16@GetGreatWo@12
	pop	edi
	pop	esi
	pop	ebp

; 377  : 								}
; 378  : 							}
; 379  : 						}
; 380  : 					}
; 381  : 				}
; 382  : 			}
; 383  : 		}
; 384  : 	}
; 385  : 
; 386  : 	return 0;

	xor	eax, eax
	pop	ebx

; 387  : }

	add	esp, 8
	ret	4
$LN29@GetGreatWo@12:

; 375  : 								{
; 376  : 									return pCity->GetCityCulture()->GetThemingBonus(eBuildingClass);

	push	edi
	mov	ecx, ebp
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonus
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 387  : }

	add	esp, 8
	ret	4
?GetGreatWorkCurrentThemingBonus@CvGameCulture@@QBEHH@Z ENDP ; CvGameCulture::GetGreatWorkCurrentThemingBonus
_TEXT	ENDS
PUBLIC	?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z ; CvPlayerCulture::MoveWorks
; Function compile flags: /Ogtpy
;	COMDAT ?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
_buildings$ = 12					; size = 4
_works1$ = 16						; size = 4
_works2$ = 20						; size = 4
?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z PROC ; CvPlayerCulture::MoveWorks, COMDAT
; _this$ = ecx

; 1155 : {

	push	ebx
	push	ebp

; 1156 : 	std::sort (buildings.begin(), buildings.end(), SortThemingBonus);

	mov	ebp, DWORD PTR _buildings$[esp+4]
	push	esi
	mov	esi, DWORD PTR [ebp+8]
	push	edi
	mov	edi, DWORD PTR [ebp+4]
	mov	ebx, ecx
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	OFFSET ?SortThemingBonus@@YA_NABVCvGreatWorkBuildingInMyEmpire@@0@Z ; SortThemingBonus
	add	eax, edx
	push	eax
	push	esi
	push	edi
	call	??$_Sort@V?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@HP6A_NABVCvGreatWorkBuildingInMyEmpire@@0@Z@std@@YAXV?$_Vector_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@0@0HP6A_NABVCvGreatWorkBuildingInMyEmpire@@1@Z@Z ; std::_Sort<std::_Vector_iterator<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >,int,bool (__cdecl*)(CvGreatWorkBuildingInMyEmpire const &,CvGreatWorkBuildingInMyEmpire const &)>

; 1157 : 
; 1158 : 	// First building that are not endangered
; 1159 : 	vector<CvGreatWorkBuildingInMyEmpire>::iterator itBuilding;
; 1160 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1161 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); ++itBuilding)
; 1162 : #else
; 1163 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	mov	esi, DWORD PTR [ebp+4]
	mov	edi, DWORD PTR _works1$[esp+28]
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN32@MoveWorks
$LL69@MoveWorks:

; 1164 : #endif
; 1165 : 	{
; 1166 : 		if (!itBuilding->m_bEndangered)

	cmp	BYTE PTR [esi+9], 0
	jne	SHORT $LN33@MoveWorks

; 1167 : 		{
; 1168 : 			itBuilding->m_bThemed = false;
; 1169 : 			if (ThemeBuilding(itBuilding, works1, works2, false /*bConsiderOtherPlayers*/))

	mov	ecx, DWORD PTR _works2$[esp+12]
	push	0
	push	ecx
	push	edi
	push	esi
	mov	ecx, ebx
	mov	BYTE PTR [esi+8], 0
	call	?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z ; CvPlayerCulture::ThemeBuilding
	test	al, al
	je	SHORT $LN33@MoveWorks

; 1170 : 			{
; 1171 : 				itBuilding->m_bThemed = true;

	mov	BYTE PTR [esi+8], 1
$LN33@MoveWorks:

; 1157 : 
; 1158 : 	// First building that are not endangered
; 1159 : 	vector<CvGreatWorkBuildingInMyEmpire>::iterator itBuilding;
; 1160 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1161 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); ++itBuilding)
; 1162 : #else
; 1163 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL69@MoveWorks
$LN32@MoveWorks:

; 1172 : 			}
; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	// Then endangered ones
; 1177 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1178 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); ++itBuilding)
; 1179 : #else
; 1180 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	mov	esi, DWORD PTR [ebp+4]
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN27@MoveWorks
$LL109@MoveWorks:

; 1181 : #endif
; 1182 : 	{
; 1183 : 		if (itBuilding->m_bEndangered)

	cmp	BYTE PTR [esi+9], 0
	je	SHORT $LN28@MoveWorks

; 1184 : 		{
; 1185 : 			itBuilding->m_bThemed = false;
; 1186 : 			if (ThemeBuilding(itBuilding, works1, works2, false /*bConsiderOtherPlayers*/))

	mov	edx, DWORD PTR _works2$[esp+12]
	push	0
	push	edx
	push	edi
	push	esi
	mov	ecx, ebx
	mov	BYTE PTR [esi+8], 0
	call	?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z ; CvPlayerCulture::ThemeBuilding
	test	al, al
	je	SHORT $LN28@MoveWorks

; 1187 : 			{
; 1188 : 				itBuilding->m_bThemed = true;

	mov	BYTE PTR [esi+8], 1
$LN28@MoveWorks:

; 1172 : 			}
; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	// Then endangered ones
; 1177 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1178 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); ++itBuilding)
; 1179 : #else
; 1180 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL109@MoveWorks
$LN27@MoveWorks:

; 1189 : 			}
; 1190 : 		}
; 1191 : 	}
; 1192 : 
; 1193 : 	// One more pass through those that are not endangered to see if swapping with another player would help (as long as this isn't Music)
; 1194 : 	if (eType != CvTypes::getGREAT_WORK_SLOT_MUSIC())

	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	cmp	DWORD PTR _eType$[esp+12], eax
	je	SHORT $LN21@MoveWorks

; 1195 : 	{
; 1196 : 		for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	mov	esi, DWORD PTR [ebp+4]
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN21@MoveWorks
	npad	1
$LL149@MoveWorks:

; 1197 : 		{
; 1198 : 			if (!itBuilding->m_bEndangered && !itBuilding->m_bThemed)

	cmp	BYTE PTR [esi+9], 0
	jne	SHORT $LN22@MoveWorks
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN22@MoveWorks

; 1199 : 			{
; 1200 : 				if (ThemeBuilding(itBuilding, works1, works2, true /*bConsiderOtherPlayers*/))

	mov	eax, DWORD PTR _works2$[esp+12]
	push	1
	push	eax
	push	edi
	push	esi
	mov	ecx, ebx
	call	?ThemeBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1_N@Z ; CvPlayerCulture::ThemeBuilding
	test	al, al
	je	SHORT $LN22@MoveWorks

; 1201 : 				{
; 1202 : 					itBuilding->m_bThemed = true;

	mov	BYTE PTR [esi+8], 1
$LN22@MoveWorks:

; 1195 : 	{
; 1196 : 		for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL149@MoveWorks
$LN21@MoveWorks:

; 1203 : 				}
; 1204 : 			}
; 1205 : 		}
; 1206 : 	}
; 1207 : 
; 1208 : 	// Set the first work left that we haven't themed as something we'd be willing to trade
; 1209 : 	//    for Writing
; 1210 : 	if (eType == CvTypes::getGREAT_WORK_SLOT_LITERATURE())

	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
	mov	esi, DWORD PTR _eType$[esp+12]
	cmp	esi, eax
	jne	SHORT $LN18@MoveWorks

; 1211 : 	{
; 1212 : 		if (works1.size() > 0)

	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	SHORT $LN17@MoveWorks

; 1213 : 		{
; 1214 : 			SetSwappableWritingIndex(works1[0].m_iGreatWorkIndex);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+276], edx

; 1215 : 		}
; 1216 : 		else

	jmp	$LN201@MoveWorks
$LN17@MoveWorks:

; 1217 : 		{
; 1218 : 			SetSwappableWritingIndex(-1);

	mov	DWORD PTR [ebx+276], -1

; 1219 : 		}
; 1220 : 	}
; 1221 : 
; 1222 : 	//    for Art and Artifacts
; 1223 : 	else

	jmp	SHORT $LN201@MoveWorks
$LN18@MoveWorks:

; 1224 : 	{
; 1225 : 		if (eType == CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT())

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	cmp	esi, eax
	jne	SHORT $LN281@MoveWorks

; 1226 : 		{
; 1227 : 			if (works1.size() > 0)

	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN13@MoveWorks

; 1228 : 			{
; 1229 : 				SetSwappableArtIndex(works1[0].m_iGreatWorkIndex);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+280], ecx

; 1230 : 			}
; 1231 : 			else

	jmp	SHORT $LN281@MoveWorks
$LN13@MoveWorks:

; 1232 : 			{
; 1233 : 				SetSwappableArtIndex(-1);

	mov	DWORD PTR [ebx+280], -1
$LN281@MoveWorks:

; 1234 : 			}
; 1235 : 		}
; 1236 : 		if (eType == CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT())

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	cmp	DWORD PTR _eType$[esp+12], eax
	jne	SHORT $LN201@MoveWorks

; 1237 : 		{
; 1238 : 			if (works2.size() > 0)

	mov	eax, DWORD PTR _works2$[esp+12]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN10@MoveWorks

; 1239 : 			{
; 1240 : 				SetSwappableArtifactIndex(works2[0].m_iGreatWorkIndex);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+284], ecx

; 1241 : 			}
; 1242 : 			else

	jmp	SHORT $LN201@MoveWorks
$LN10@MoveWorks:

; 1243 : 			{
; 1244 : 				SetSwappableArtifactIndex(-1);

	mov	DWORD PTR [ebx+284], -1
$LN201@MoveWorks:

; 1245 : 			}
; 1246 : 		}
; 1247 : 	}
; 1248 : 
; 1249 : 	// Fill unthemed buildings, first those that aren't endangered
; 1250 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1251 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); ++itBuilding)
; 1252 : #else
; 1253 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	mov	esi, DWORD PTR [ebp+4]
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN6@MoveWorks
	npad	5
$LL213@MoveWorks:

; 1254 : #endif
; 1255 : 	{
; 1256 : 		if (!itBuilding->m_bEndangered && !itBuilding->m_bThemed)

	cmp	BYTE PTR [esi+9], 0
	jne	SHORT $LN7@MoveWorks
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN7@MoveWorks

; 1257 : 		{
; 1258 : 			FillBuilding(itBuilding, works1, works2);

	mov	edx, DWORD PTR _works2$[esp+12]
	push	edx
	push	edi
	push	esi
	mov	ecx, ebx
	call	?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z ; CvPlayerCulture::FillBuilding
$LN7@MoveWorks:
	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL213@MoveWorks
$LN6@MoveWorks:

; 1259 : 		}
; 1260 : 	}
; 1261 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1262 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); ++itBuilding)
; 1263 : #else
; 1264 : 	for (itBuilding = buildings.begin(); itBuilding != buildings.end(); itBuilding++)

	mov	esi, DWORD PTR [ebp+4]
	cmp	esi, DWORD PTR [ebp+8]
	je	SHORT $LN2@MoveWorks
	npad	6
$LL247@MoveWorks:

; 1265 : #endif
; 1266 : 	{
; 1267 : 		if (itBuilding->m_bEndangered && !itBuilding->m_bThemed)

	cmp	BYTE PTR [esi+9], 0
	je	SHORT $LN3@MoveWorks
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN3@MoveWorks

; 1268 : 		{
; 1269 : 			FillBuilding(itBuilding, works1, works2);

	mov	eax, DWORD PTR _works2$[esp+12]
	push	eax
	push	edi
	push	esi
	mov	ecx, ebx
	call	?FillBuilding@CvPlayerCulture@@QAE_NV?$_Vector_const_iterator@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@3@1@Z ; CvPlayerCulture::FillBuilding
$LN3@MoveWorks:
	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebp+8]
	jne	SHORT $LL247@MoveWorks
$LN2@MoveWorks:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1270 : 		}
; 1271 : 	}
; 1272 : }

	ret	16					; 00000010H
?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z ENDP ; CvPlayerCulture::MoveWorks
_TEXT	ENDS
PUBLIC	?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ	; CvPlayerCulture::DoSwapGreatWorks
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcultureclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ
_TEXT	SEGMENT
_iBuildingClassLoop$223947 = -208			; size = 4
_this$ = -204						; size = 4
_iLoop$ = -200						; size = 4
_building$223959 = -196					; size = 12
_eMusicClass$ = -184					; size = 4
_iNumSlots$223966 = -180				; size = 4
_eArtifactsClass$ = -176				; size = 4
_eWritingClass$ = -172					; size = 4
_eArtClass$ = -168					; size = 4
_work$223974 = -164					; size = 24
_aGreatWorkBuildingsArt$ = -140				; size = 16
_aGreatWorksArtifacts$ = -124				; size = 16
_aGreatWorkBuildingsWriting$ = -108			; size = 16
_aGreatWorksArt$ = -92					; size = 16
_aGreatWorksMusic$ = -76				; size = 16
_aGreatWorksWriting$ = -60				; size = 16
_aNull$ = -44						; size = 16
_aGreatWorkBuildingsMusic$ = -28			; size = 16
__$EHRec$ = -12						; size = 12
?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ PROC		; CvPlayerCulture::DoSwapGreatWorks, COMDAT
; _this$ = ecx

; 1029 : {

	push	-1
	push	__ehhandler$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1030 : 	GreatWorkClass eWritingClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_LITERATURE");

	xor	esi, esi
	mov	ebx, ecx
	push	esi
	push	OFFSET $SG223597
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+232], ebx
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1031 : 	GreatWorkClass eArtClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ART");

	push	esi
	push	OFFSET $SG223600
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eWritingClass$[esp+232], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1032 : 	GreatWorkClass eArtifactsClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_ARTIFACT");

	push	esi
	push	OFFSET $SG223603
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eArtClass$[esp+232], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1033 : 	GreatWorkClass eMusicClass = (GreatWorkClass)GC.getInfoTypeForString("GREAT_WORK_MUSIC");

	push	esi
	push	OFFSET $SG223606
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eArtifactsClass$[esp+232], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eMusicClass$[esp+224], eax

; 1034 : 
; 1035 : 	vector<CvGreatWorkInMyEmpire> aGreatWorksWriting;

	mov	DWORD PTR _aGreatWorksWriting$[esp+228], esi
	mov	DWORD PTR _aGreatWorksWriting$[esp+232], esi
	mov	DWORD PTR _aGreatWorksWriting$[esp+236], esi
	mov	DWORD PTR __$EHRec$[esp+232], esi

; 1036 : 	vector<CvGreatWorkInMyEmpire> aGreatWorksArt;

	mov	DWORD PTR _aGreatWorksArt$[esp+228], esi
	mov	DWORD PTR _aGreatWorksArt$[esp+232], esi
	mov	DWORD PTR _aGreatWorksArt$[esp+236], esi

; 1037 : 	vector<CvGreatWorkInMyEmpire> aGreatWorksArtifacts;

	mov	DWORD PTR _aGreatWorksArtifacts$[esp+228], esi
	mov	DWORD PTR _aGreatWorksArtifacts$[esp+232], esi
	mov	DWORD PTR _aGreatWorksArtifacts$[esp+236], esi

; 1038 : 	vector<CvGreatWorkInMyEmpire> aGreatWorksMusic;

	mov	DWORD PTR _aGreatWorksMusic$[esp+228], esi
	mov	DWORD PTR _aGreatWorksMusic$[esp+232], esi
	mov	DWORD PTR _aGreatWorksMusic$[esp+236], esi

; 1039 : 	vector<CvGreatWorkInMyEmpire> aNull;

	mov	DWORD PTR _aNull$[esp+228], esi
	mov	DWORD PTR _aNull$[esp+232], esi
	mov	DWORD PTR _aNull$[esp+236], esi

; 1040 : 
; 1041 : 	vector<CvGreatWorkBuildingInMyEmpire> aGreatWorkBuildingsWriting;

	mov	DWORD PTR _aGreatWorkBuildingsWriting$[esp+228], esi
	mov	DWORD PTR _aGreatWorkBuildingsWriting$[esp+232], esi
	mov	DWORD PTR _aGreatWorkBuildingsWriting$[esp+236], esi

; 1042 : 	vector<CvGreatWorkBuildingInMyEmpire> aGreatWorkBuildingsArt;

	mov	DWORD PTR _aGreatWorkBuildingsArt$[esp+228], esi
	mov	DWORD PTR _aGreatWorkBuildingsArt$[esp+232], esi
	mov	DWORD PTR _aGreatWorkBuildingsArt$[esp+236], esi

; 1043 : 	vector<CvGreatWorkBuildingInMyEmpire> aGreatWorkBuildingsMusic;

	xor	edi, edi
	mov	DWORD PTR _aGreatWorkBuildingsMusic$[esp+228], edi
	mov	DWORD PTR _aGreatWorkBuildingsMusic$[esp+232], esi
	mov	DWORD PTR _aGreatWorkBuildingsMusic$[esp+236], esi

; 1044 : 
; 1045 : 	CvCity* pLoopCity = NULL;
; 1046 : 	int iLoop = 0;
; 1047 : 
; 1048 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx+292]
	push	esi
	lea	eax, DWORD PTR _iLoop$[esp+228]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+240], 7
	mov	DWORD PTR _iLoop$[esp+232], esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	cmp	ebp, esi
	je	$LN23@DoSwapGrea
	npad	9
$LL25@DoSwapGrea:

; 1049 : 	{
; 1050 : #ifdef AUI_WARNING_FIXES
; 1051 : 		for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 1052 : #else
; 1053 : 		for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildingClassLoop$223947[esp+224], edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN24@DoSwapGrea
	npad	8
$LL22@DoSwapGrea:

; 1054 : #endif
; 1055 : 		{
; 1056 : 			CvCivilizationInfo& playerCivilizationInfo = m_pPlayer->getCivilizationInfo();

	mov	ecx, DWORD PTR [ebx+292]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 1057 : 			BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);

	push	edi
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	ebx, eax

; 1058 : 			if (eBuilding != NO_BUILDING)

	cmp	ebx, -1
	je	$LN21@DoSwapGrea

; 1059 : 			{
; 1060 : 				CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 1061 : 				if (pkBuilding)

	cmp	edi, esi
	je	$LN21@DoSwapGrea

; 1062 : 				{
; 1063 : 					if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	ebx
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN21@DoSwapGrea

; 1064 : 					{
; 1065 : 						CvGreatWorkBuildingInMyEmpire building;
; 1066 : 						building.m_eBuilding = eBuilding;
; 1067 : 						building.m_iCityID = pLoopCity->GetID();

	mov	ecx, DWORD PTR [ebp+120]
	mov	DWORD PTR _building$223959[esp+224], ecx

; 1068 : 						building.m_bEndangered = (pLoopCity->getDamage() > 0);

	mov	ecx, ebp
	mov	BYTE PTR _building$223959[esp+232], 0
	mov	DWORD PTR _building$223959[esp+228], ebx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	test	eax, eax
	setg	dl

; 1069 : 
; 1070 : 						GreatWorkSlotType eSlotType = pkBuilding->GetGreatWorkSlotType();

	mov	ecx, edi
	mov	BYTE PTR _building$223959[esp+233], dl
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	mov	esi, eax

; 1071 : 						if (eSlotType == CvTypes::getGREAT_WORK_SLOT_LITERATURE())

	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
	cmp	esi, eax
	jne	SHORT $LN16@DoSwapGrea

; 1072 : 						{
; 1073 : 							aGreatWorkBuildingsWriting.push_back(building);

	lea	eax, DWORD PTR _building$223959[esp+224]
	push	eax
	lea	ecx, DWORD PTR _aGreatWorkBuildingsWriting$[esp+228]
	jmp	SHORT $LN420@DoSwapGrea
$LN16@DoSwapGrea:

; 1074 : 						}
; 1075 : 						else if (eSlotType == CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT())

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	cmp	esi, eax
	jne	SHORT $LN14@DoSwapGrea

; 1076 : 						{
; 1077 : 							aGreatWorkBuildingsArt.push_back(building);

	lea	ecx, DWORD PTR _building$223959[esp+224]
	push	ecx
	lea	ecx, DWORD PTR _aGreatWorkBuildingsArt$[esp+228]
	jmp	SHORT $LN420@DoSwapGrea
$LN14@DoSwapGrea:

; 1078 : 						}
; 1079 : 						else if (eSlotType == CvTypes::getGREAT_WORK_SLOT_MUSIC())

	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	cmp	esi, eax
	jne	SHORT $LN12@DoSwapGrea

; 1080 : 						{
; 1081 : 							aGreatWorkBuildingsMusic.push_back(building);

	lea	edx, DWORD PTR _building$223959[esp+224]
	push	edx
	lea	ecx, DWORD PTR _aGreatWorkBuildingsMusic$[esp+228]
$LN420@DoSwapGrea:
	call	?push_back@?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkBuildingInMyEmpire@@@Z ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::push_back
$LN12@DoSwapGrea:

; 1082 : 						}
; 1083 : 
; 1084 : 						int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, edi
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount

; 1085 : 						for (int iI = 0; iI < iNumSlots; iI++)

	xor	edi, edi
	mov	DWORD PTR _iNumSlots$223966[esp+224], eax
	test	eax, eax
	jle	$LN416@DoSwapGrea
	npad	6
$LL415@DoSwapGrea:

; 1086 : 						{
; 1087 : 							int iGreatWorkIndex = pLoopCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);

	mov	eax, DWORD PTR _iBuildingClassLoop$223947[esp+224]
	push	edi
	push	eax
	mov	ecx, ebp
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	mov	esi, eax

; 1088 : 							if (iGreatWorkIndex != -1)

	cmp	esi, -1
	je	$LN10@DoSwapGrea

; 1089 : 							{
; 1090 : 								CvGreatWorkInMyEmpire work;
; 1091 : 								work.m_eBuilding = eBuilding;
; 1092 : 								work.m_iCityID = pLoopCity->GetID();

	mov	ecx, DWORD PTR [ebp+120]
	mov	DWORD PTR _work$223974[esp+228], ecx

; 1093 : 								work.m_iGreatWorkIndex = iGreatWorkIndex;
; 1094 : 								work.m_iSlot = iI;
; 1095 : 								work.m_ePlayer = GC.getGame().GetGameCulture()->GetGreatWorkCreator(iGreatWorkIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _work$223974[esp+232], ebx
	mov	DWORD PTR _work$223974[esp+224], esi
	mov	DWORD PTR _work$223974[esp+236], edi
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	edx, DWORD PTR [eax]

; 1096 : 								work.m_eEra = GC.getGame().GetGameCulture()->m_CurrentGreatWorks[iGreatWorkIndex].m_eEra;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	esi, DWORD PTR [esi+esi*2]
	shl	esi, 4
	mov	eax, DWORD PTR [edx+esi+44]
	mov	DWORD PTR _work$223974[esp+240], eax
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+ecx+40]

; 1097 : 
; 1098 : 								GreatWorkType eGreatWorkType = GC.getGame().GetGameCulture()->GetGreatWorkType(iGreatWorkIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _work$223974[esp+244], edx
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+esi+28]

; 1099 : 								GreatWorkClass eGWClass = CultureHelpers::GetGreatWorkClass(eGreatWorkType);

	push	esi
	call	?GetGreatWorkClass@CultureHelpers@@YA?AW4GreatWorkClass@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkClass
	add	esp, 4

; 1100 : 								if (eGWClass == eWritingClass)

	cmp	eax, DWORD PTR _eWritingClass$[esp+224]
	jne	SHORT $LN7@DoSwapGrea

; 1101 : 								{
; 1102 : 									aGreatWorksWriting.push_back(work);

	lea	ecx, DWORD PTR _work$223974[esp+224]
	push	ecx
	lea	ecx, DWORD PTR _aGreatWorksWriting$[esp+228]
	jmp	SHORT $LN421@DoSwapGrea
$LN7@DoSwapGrea:

; 1103 : 								}
; 1104 : 								else if (eGWClass == eArtClass)

	cmp	eax, DWORD PTR _eArtClass$[esp+224]
	jne	SHORT $LN5@DoSwapGrea

; 1105 : 								{
; 1106 : 									aGreatWorksArt.push_back(work);

	lea	edx, DWORD PTR _work$223974[esp+224]
	push	edx
	lea	ecx, DWORD PTR _aGreatWorksArt$[esp+228]
	jmp	SHORT $LN421@DoSwapGrea
$LN5@DoSwapGrea:

; 1107 : 								}
; 1108 : 								else if (eGWClass == eArtifactsClass)

	cmp	eax, DWORD PTR _eArtifactsClass$[esp+224]
	jne	SHORT $LN3@DoSwapGrea

; 1109 : 								{
; 1110 : 									aGreatWorksArtifacts.push_back(work);

	lea	eax, DWORD PTR _work$223974[esp+224]
	push	eax
	lea	ecx, DWORD PTR _aGreatWorksArtifacts$[esp+228]
	jmp	SHORT $LN421@DoSwapGrea
$LN3@DoSwapGrea:

; 1111 : 								}
; 1112 : 								else if (eGWClass == eMusicClass)

	cmp	eax, DWORD PTR _eMusicClass$[esp+224]
	jne	SHORT $LN10@DoSwapGrea

; 1113 : 								{
; 1114 : 									aGreatWorksMusic.push_back(work);

	lea	ecx, DWORD PTR _work$223974[esp+224]
	push	ecx
	lea	ecx, DWORD PTR _aGreatWorksMusic$[esp+228]
$LN421@DoSwapGrea:
	call	?push_back@?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAEXABVCvGreatWorkInMyEmpire@@@Z ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::push_back
$LN10@DoSwapGrea:

; 1085 : 						for (int iI = 0; iI < iNumSlots; iI++)

	inc	edi
	cmp	edi, DWORD PTR _iNumSlots$223966[esp+224]
	jl	$LL415@DoSwapGrea
$LN416@DoSwapGrea:
	xor	esi, esi
$LN21@DoSwapGrea:

; 1049 : 	{
; 1050 : #ifdef AUI_WARNING_FIXES
; 1051 : 		for (uint iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
; 1052 : #else
; 1053 : 		for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	edi, DWORD PTR _iBuildingClassLoop$223947[esp+224]
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildingClassLoop$223947[esp+224], edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	edi, eax
	mov	ebx, DWORD PTR _this$[esp+224]
	jl	$LL22@DoSwapGrea
$LN24@DoSwapGrea:

; 1044 : 
; 1045 : 	CvCity* pLoopCity = NULL;
; 1046 : 	int iLoop = 0;
; 1047 : 
; 1048 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx+292]
	push	esi
	lea	edx, DWORD PTR _iLoop$[esp+228]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	cmp	ebp, esi
	jne	$LL25@DoSwapGrea
	mov	edi, DWORD PTR _aGreatWorkBuildingsMusic$[esp+228]
$LN23@DoSwapGrea:

; 1115 : 								}
; 1116 : 							}
; 1117 : 						}
; 1118 : 					}
; 1119 : 				}
; 1120 : 			}
; 1121 : 		}
; 1122 : 	}
; 1123 : 
; 1124 : 	MoveWorks (CvTypes::getGREAT_WORK_SLOT_LITERATURE(), aGreatWorkBuildingsWriting, aGreatWorksWriting, aNull);

	lea	eax, DWORD PTR _aNull$[esp+224]
	push	eax
	lea	ecx, DWORD PTR _aGreatWorksWriting$[esp+228]
	push	ecx
	lea	edx, DWORD PTR _aGreatWorkBuildingsWriting$[esp+232]
	push	edx
	call	?getGREAT_WORK_SLOT_LITERATURE@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_LITERATURE
	push	eax
	mov	ecx, ebx
	call	?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z ; CvPlayerCulture::MoveWorks

; 1125 : 	MoveWorks (CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT(), aGreatWorkBuildingsArt, aGreatWorksArt, aGreatWorksArtifacts);

	lea	eax, DWORD PTR _aGreatWorksArtifacts$[esp+224]
	push	eax
	lea	ecx, DWORD PTR _aGreatWorksArt$[esp+228]
	push	ecx
	lea	edx, DWORD PTR _aGreatWorkBuildingsArt$[esp+232]
	push	edx
	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	push	eax
	mov	ecx, ebx
	call	?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z ; CvPlayerCulture::MoveWorks

; 1126 : 	MoveWorks (CvTypes::getGREAT_WORK_SLOT_MUSIC(), aGreatWorkBuildingsMusic, aGreatWorksMusic, aNull);

	lea	eax, DWORD PTR _aNull$[esp+224]
	push	eax
	lea	ecx, DWORD PTR _aGreatWorksMusic$[esp+228]
	push	ecx
	lea	edx, DWORD PTR _aGreatWorkBuildingsMusic$[esp+232]
	push	edx
	call	?getGREAT_WORK_SLOT_MUSIC@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_MUSIC
	push	eax
	mov	ecx, ebx
	call	?MoveWorks@CvPlayerCulture@@QAEXW4GreatWorkSlotType@@AAV?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@AAV?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@4@2@Z ; CvPlayerCulture::MoveWorks

; 1127 : }

	cmp	edi, esi
	je	SHORT $LN358@DoSwapGrea
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN358@DoSwapGrea:
	mov	eax, DWORD PTR _aGreatWorkBuildingsArt$[esp+228]
	cmp	eax, esi
	je	SHORT $LN365@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN365@DoSwapGrea:
	mov	eax, DWORD PTR _aGreatWorkBuildingsWriting$[esp+228]
	cmp	eax, esi
	je	SHORT $LN372@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN372@DoSwapGrea:
	mov	eax, DWORD PTR _aNull$[esp+228]
	cmp	eax, esi
	je	SHORT $LN379@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN379@DoSwapGrea:
	mov	eax, DWORD PTR _aGreatWorksMusic$[esp+228]
	cmp	eax, esi
	je	SHORT $LN386@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN386@DoSwapGrea:
	mov	eax, DWORD PTR _aGreatWorksArtifacts$[esp+228]
	cmp	eax, esi
	je	SHORT $LN393@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN393@DoSwapGrea:
	mov	eax, DWORD PTR _aGreatWorksArt$[esp+228]
	cmp	eax, esi
	je	SHORT $LN400@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN400@DoSwapGrea:
	mov	eax, DWORD PTR _aGreatWorksWriting$[esp+228]
	pop	edi
	cmp	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	je	SHORT $LN407@DoSwapGrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN407@DoSwapGrea:
	mov	ecx, DWORD PTR __$EHRec$[esp+208]
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$0:
	lea	ecx, DWORD PTR _aGreatWorksWriting$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$1:
	lea	ecx, DWORD PTR _aGreatWorksArt$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$2:
	lea	ecx, DWORD PTR _aGreatWorksArtifacts$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$3:
	lea	ecx, DWORD PTR _aGreatWorksMusic$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$4:
	lea	ecx, DWORD PTR _aNull$[ebp]
	jmp	??1?$vector@VCvGreatWorkInMyEmpire@@V?$allocator@VCvGreatWorkInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >::~vector<CvGreatWorkInMyEmpire,std::allocator<CvGreatWorkInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$5:
	lea	ecx, DWORD PTR _aGreatWorkBuildingsWriting$[ebp]
	jmp	??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$6:
	lea	ecx, DWORD PTR _aGreatWorkBuildingsArt$[ebp]
	jmp	??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
__unwindfunclet$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ$7:
	lea	ecx, DWORD PTR _aGreatWorkBuildingsMusic$[ebp]
	jmp	??1?$vector@VCvGreatWorkBuildingInMyEmpire@@V?$allocator@VCvGreatWorkBuildingInMyEmpire@@@std@@@std@@QAE@XZ ; std::vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >::~vector<CvGreatWorkBuildingInMyEmpire,std::allocator<CvGreatWorkBuildingInMyEmpire> >
__ehhandler$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ ENDP		; CvPlayerCulture::DoSwapGreatWorks
END
