; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPolicyClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG223566 DB	'CultureCost', 00H
$SG223567 DB	'GridX', 00H
	ORG $+2
$SG223568 DB	'GridY', 00H
	ORG $+2
$SG223569 DB	'Level', 00H
	ORG $+2
$SG223570 DB	'PolicyCostModifier', 00H
	ORG $+1
$SG223571 DB	'CulturePerCity', 00H
	ORG $+1
$SG223572 DB	'CulturePerWonder', 00H
	ORG $+3
$SG223573 DB	'CultureWonderMultiplier', 00H
$SG223574 DB	'CulturePerTechResearched', 00H
	ORG $+3
$SG223575 DB	'CultureImprovementChange', 00H
	ORG $+3
$SG223576 DB	'CultureFromKills', 00H
	ORG $+3
$SG223577 DB	'CultureFromBarbarianKills', 00H
	ORG $+2
$SG223578 DB	'GoldFromKills', 00H
	ORG $+2
$SG223579 DB	'ScienceFromKills', 00H
	ORG $+3
$SG223580 DB	'EmbarkedExtraMoves', 00H
	ORG $+1
$SG223581 DB	'AttackBonusTurns', 00H
	ORG $+3
$SG223582 DB	'GoldenAgeTurns', 00H
	ORG $+1
$SG223583 DB	'GoldenAgeMeterMod', 00H
	ORG $+2
$SG223584 DB	'GoldenAgeDurationMod', 00H
	ORG $+3
$SG223585 DB	'NumFreeTechs', 00H
	ORG $+3
$SG223586 DB	'NumFreePolicies', 00H
$SG223587 DB	'NumFreeGreatPeople', 00H
	ORG $+1
$SG223588 DB	'NumExtraSpies', 00H
	ORG $+2
$SG223589 DB	'MedianTechPercentChange', 00H
$SG223590 DB	'StrategicResourceMod', 00H
	ORG $+3
$SG223591 DB	'WonderProductionModifier', 00H
	ORG $+3
$SG223592 DB	'BuildingProductionModifier', 00H
	ORG $+1
$SG223593 DB	'GreatPeopleRateModifier', 00H
$SG223594 DB	'GreatGeneralRateModifier', 00H
	ORG $+3
$SG223595 DB	'GreatAdmiralRateModifier', 00H
	ORG $+3
$SG223596 DB	'GreatWriterRateModifier', 00H
$SG223597 DB	'GreatArtistRateModifier', 00H
$SG223598 DB	'GreatMusicianRateModifier', 00H
	ORG $+2
$SG223599 DB	'GreatMerchantRateModifier', 00H
	ORG $+2
$SG223600 DB	'GreatScientistRateModifier', 00H
	ORG $+1
$SG223601 DB	'DomesticGreatGeneralRateModifier', 00H
	ORG $+3
$SG223602 DB	'ExtraHappiness', 00H
	ORG $+1
$SG223603 DB	'ExtraHappinessPerCity', 00H
	ORG $+2
$SG223604 DB	'UnhappinessMod', 00H
	ORG $+1
$SG223605 DB	'CityCountUnhappinessMod', 00H
$SG223606 DB	'OccupiedPopulationUnhappinessMod', 00H
	ORG $+3
$SG223607 DB	'CapitalUnhappinessMod', 00H
	ORG $+2
$SG223608 DB	'FreeExperience', 00H
	ORG $+1
$SG223609 DB	'WorkerSpeedModifier', 00H
$SG223610 DB	'AllFeatureProduction', 00H
	ORG $+3
$SG223611 DB	'ImprovementCostModifier', 00H
$SG223612 DB	'ImprovementUpgradeRateModifier', 00H
	ORG $+1
$SG223613 DB	'SpecialistProductionModifier', 00H
	ORG $+3
$SG223614 DB	'SpecialistUpgradeModifier', 00H
	ORG $+2
$SG223615 DB	'MilitaryProductionModifier', 00H
	ORG $+1
$SG223616 DB	'BaseFreeUnits', 00H
	ORG $+2
$SG223617 DB	'BaseFreeMilitaryUnits', 00H
	ORG $+2
$SG223618 DB	'FreeUnitsPopulationPercent', 00H
	ORG $+1
$SG223619 DB	'FreeMilitaryUnitsPopulationPercent', 00H
	ORG $+1
$SG223620 DB	'HappinessPerGarrisonedUnit', 00H
	ORG $+1
$SG223621 DB	'CulturePerGarrisonedUnit', 00H
	ORG $+3
$SG223622 DB	'HappinessPerTradeRoute', 00H
	ORG $+1
$SG223623 DB	'HappinessPerRailConnection', 00H
	ORG $+1
$SG223624 DB	'HappinessPerXPopulation', 00H
$SG223625 DB	'ExtraHappinessPerLuxury', 00H
$SG223626 DB	'UnhappinessFromUnitsMod', 00H
$SG223627 DB	'NumExtraBuilders', 00H
	ORG $+3
$SG223628 DB	'PlotGoldCostMod', 00H
$SG223629 DB	'PlotCultureCostModifier', 00H
$SG223630 DB	'PlotCultureExponentModifier', 00H
$SG223631 DB	'NumCitiesPolicyCostDiscount', 00H
$SG223632 DB	'NumCitiesResearchCostDiscount', 00H
	ORG $+2
$SG223633 DB	'GarrisonedCityRangeStrikeModifier', 00H
	ORG $+2
$SG223634 DB	'UnitPurchaseCostModifier', 00H
	ORG $+3
$SG223635 DB	'BuildingPurchaseCostModifier', 00H
	ORG $+3
$SG223636 DB	'CityConnectionTradeRouteGoldModifier', 00H
	ORG $+3
$SG223637 DB	'TradeMissionGoldModifier', 00H
	ORG $+3
$SG223638 DB	'FaithCostModifier', 00H
	ORG $+2
$SG223639 DB	'CulturalPlunderMultiplier', 00H
	ORG $+2
$SG223640 DB	'StealTechSlowerModifier', 00H
$SG223641 DB	'StealTechFasterModifier', 00H
$SG223642 DB	'CatchSpiesModifier', 00H
	ORG $+1
$SG223643 DB	'GoldPerUnit', 00H
$SG223644 DB	'GoldPerMilitaryUnit', 00H
$SG223645 DB	'CityStrengthMod', 00H
$SG223646 DB	'CityGrowthMod', 00H
	ORG $+2
$SG223647 DB	'CapitalGrowthMod', 00H
	ORG $+3
$SG223648 DB	'SettlerProductionModifier', 00H
	ORG $+2
$SG223649 DB	'CapitalSettlerProductionModifier', 00H
	ORG $+3
$SG223650 DB	'NewCityExtraPopulation', 00H
	ORG $+1
$SG223651 DB	'FreeFoodBox', 00H
$SG223652 DB	'RouteGoldMaintenanceMod', 00H
$SG223653 DB	'BuildingGoldMaintenanceMod', 00H
	ORG $+1
$SG223654 DB	'UnitGoldMaintenanceMod', 00H
	ORG $+1
$SG223655 DB	'UnitSupplyMod', 00H
	ORG $+2
$SG223656 DB	'HappyPerMilitaryUnit', 00H
	ORG $+3
$SG223657 DB	'HappinessToCulture', 00H
	ORG $+1
$SG223658 DB	'HappinessToScience', 00H
	ORG $+1
$SG223659 DB	'GoldToScience', 00H
	ORG $+2
$SG223660 DB	'NumCitiesFreeAestheticsSchools', 00H
	ORG $+1
$SG223661 DB	'NumCitiesFreePietyGardens', 00H
	ORG $+2
$SG223662 DB	'NumCitiesFreeWalls', 00H
	ORG $+1
$SG223663 DB	'NumCitiesFreeCultureBuilding', 00H
	ORG $+3
$SG223664 DB	'NumCitiesFreeFoodBuilding', 00H
	ORG $+2
$SG223665 DB	'HalfSpecialistUnhappiness', 00H
	ORG $+2
$SG223666 DB	'HalfMoreSpecialistUnhappiness', 00H
	ORG $+2
$SG223667 DB	'HalfSpecialistFood', 00H
	ORG $+1
$SG223668 DB	'MilitaryFoodProduction', 00H
	ORG $+1
$SG223669 DB	'MaxConscript', 00H
	ORG $+3
$SG223670 DB	'WoundedUnitDamageMod', 00H
	ORG $+3
$SG223671 DB	'UnitUpgradeCostMod', 00H
	ORG $+1
$SG223672 DB	'BarbarianCombatBonus', 00H
	ORG $+3
$SG223673 DB	'AlwaysSeeBarbCamps', 00H
	ORG $+1
$SG223674 DB	'RevealAllCapitals', 00H
	ORG $+2
$SG223675 DB	'GarrisonFreeMaintenance', 00H
$SG223676 DB	'FreeSpecialist', 00H
	ORG $+1
$SG223677 DB	'ExpModifier', 00H
$SG223678 DB	'ExpInBorderModifier', 00H
$SG223679 DB	'MinorQuestFriendshipMod', 00H
$SG223680 DB	'MinorGoldFriendshipMod', 00H
	ORG $+1
$SG223681 DB	'MinorFriendshipMinimum', 00H
	ORG $+1
$SG223682 DB	'MinorFriendshipDecayMod', 00H
$SG223683 DB	'OtherPlayersMinorFriendshipDecayMod', 00H
$SG223684 DB	'CityStateUnitFrequencyModifier', 00H
	ORG $+1
$SG223685 DB	'CommonFoeTourismModifier', 00H
	ORG $+3
$SG223686 DB	'LessHappyTourismModifier', 00H
	ORG $+3
$SG223687 DB	'SharedIdeologyTourismModifier', 00H
	ORG $+2
$SG223688 DB	'LandTradeRouteGoldChange', 00H
	ORG $+3
$SG223689 DB	'SeaTradeRouteGoldChange', 00H
$SG223690 DB	'InternalTradeRouteGoldChange', 00H
	ORG $+3
$SG223691 DB	'SharedIdeologyTradeGoldChange', 00H
	ORG $+2
$SG223692 DB	'RiggingElectionModifier', 00H
$SG223693 DB	'MilitaryUnitGiftExtraInfluence', 00H
	ORG $+1
$SG223694 DB	'ProtectedMinorPerTurnInfluence', 00H
	ORG $+1
$SG223695 DB	'AfraidMinorPerTurnInfluence', 00H
$SG223696 DB	'MinorBullyScoreModifier', 00H
$SG223697 DB	'ThemingBonusMultiplier', 00H
	ORG $+1
$SG223698 DB	'InternalTradeRouteYieldModifier', 00H
$SG223699 DB	'InternalTradeRouteProductionYieldChange', 00H
$SG223700 DB	'RailConnectionProductionModifier', 00H
	ORG $+3
$SG223701 DB	'CombatBonusVsSmallerCiv', 00H
$SG223702 DB	'ProductionToGreatMusiciansModifier', 00H
	ORG $+1
$SG223703 DB	'TradeMissionInfluenceModifier', 00H
	ORG $+2
$SG223704 DB	'SciencePerGreatPersonBorn', 00H
	ORG $+2
$SG223705 DB	'InfluenceBoostPerGreatPersonBorn', 00H
	ORG $+3
$SG223706 DB	'TourismFromTradeMissions', 00H
	ORG $+3
$SG223707 DB	'HappinessFromGreatImprovements', 00H
	ORG $+1
$SG223708 DB	'MinorFriendshipGainBullyGoldSuccess', 00H
$SG223709 DB	'CoupChanceModifier', 00H
	ORG $+1
$SG223710 DB	'SharedReligionTourismModifier', 00H
	ORG $+2
$SG223711 DB	'TradeRouteTourismModifier', 00H
	ORG $+2
$SG223712 DB	'OpenBordersTourismModifier', 00H
	ORG $+1
$SG223713 DB	'CityStateTradeChange', 00H
	ORG $+3
$SG223714 DB	'MinorGreatPeopleAllies', 00H
	ORG $+1
$SG223715 DB	'MinorScienceAllies', 00H
	ORG $+1
$SG223716 DB	'MinorResourceBonus', 00H
	ORG $+1
$SG223717 DB	'MinorMilitaryNumExtraUnitsToGift', 00H
	ORG $+3
$SG223718 DB	'CityStateBonusModifier', 00H
	ORG $+1
$SG223719 DB	'ExtraTerritoryClaim', 00H
$SG223720 DB	'ExtraTourismPerGreatWork', 00H
	ORG $+3
$SG223721 DB	'TourismPerWonder', 00H
	ORG $+3
$SG223722 DB	'TourismPerCity', 00H
	ORG $+1
$SG223723 DB	'IdeologyPressureUnhappinessModifier', 00H
$SG223724 DB	'ProductionFromGarrison', 00H
	ORG $+1
$SG223725 DB	'GoldenAgeCultureBonusDisabled', 00H
	ORG $+2
$SG223726 DB	'SecondReligionPantheon', 00H
	ORG $+1
$SG223727 DB	'AddReformationBelief', 00H
	ORG $+3
$SG223728 DB	'EnablesSSPartHurry', 00H
	ORG $+1
$SG223729 DB	'DisablesResistanceTime', 00H
	ORG $+1
$SG223730 DB	'IsDoubleTrainedMilitaryLandUnits', 00H
	ORG $+3
$SG223731 DB	'IsWarHero', 00H
	ORG $+2
$SG223732 DB	'NoMinorDOWIfFriends', 00H
$SG223733 DB	'AllowPuppetPurchasing', 00H
	ORG $+2
$SG223734 DB	'EnablesSSPartPurchase', 00H
	ORG $+2
$SG223735 DB	'AbleToAnnexCityStates', 00H
	ORG $+2
$SG223736 DB	'OneShot', 00H
$SG223737 DB	'IncludesOneShotFreeUnits', 00H
	ORG $+3
$SG223738 DB	'WeLoveTheKing', 00H
	ORG $+2
$SG223741 DB	'TechPrereq', 00H
	ORG $+1
$SG223743 DB	'PolicyBranchType', 00H
	ORG $+3
$SG223744 DB	'NumExtraBranches', 00H
	ORG $+3
$SG223746 DB	'FreeBuildingOnConquest', 00H
	ORG $+1
$SG223750 DB	'PolicyType', 00H
	ORG $+1
$SG223751 DB	'Policy_YieldModifiers', 00H
	ORG $+2
$SG223752 DB	'PolicyType', 00H
	ORG $+1
$SG223753 DB	'Policy_CityYieldChanges', 00H
$SG223754 DB	'PolicyType', 00H
	ORG $+1
$SG223755 DB	'Policy_CoastalCityYieldChanges', 00H
	ORG $+1
$SG223756 DB	'PolicyType', 00H
	ORG $+1
$SG223757 DB	'Policy_CapitalYieldChanges', 00H
	ORG $+1
$SG223758 DB	'PolicyType', 00H
	ORG $+1
$SG223759 DB	'Policy_CapitalYieldPerPopChanges', 00H
	ORG $+3
$SG223760 DB	'PolicyType', 00H
	ORG $+1
$SG223761 DB	'Policy_CapitalYieldModifiers', 00H
	ORG $+3
$SG223762 DB	'PolicyType', 00H
	ORG $+1
$SG223763 DB	'Policy_GreatWorkYieldChanges', 00H
	ORG $+3
$SG223764 DB	'PolicyType', 00H
	ORG $+1
$SG223765 DB	'Policy_SpecialistExtraYields', 00H
	ORG $+3
$SG223766 DB	'PolicyType', 00H
	ORG $+1
$SG223767 DB	'Policy_Flavors', 00H
	ORG $+1
$SG223768 DB	'HurryCostModifier', 00H
	ORG $+2
$SG223769 DB	'PolicyType', 00H
	ORG $+1
$SG223770 DB	'HurryType', 00H
	ORG $+2
$SG223771 DB	'Policy_HurryModifiers', 00H
	ORG $+2
$SG223772 DB	'HurryInfos', 00H
	ORG $+1
$SG223773 DB	'PolicyType', 00H
	ORG $+1
$SG223774 DB	'SpecialistType', 00H
	ORG $+1
$SG223775 DB	'Policy_ValidSpecialists', 00H
$SG223776 DB	'Specialists', 00H
$SG223777 DB	'PolicyType', 00H
	ORG $+1
$SG223778 DB	'PromotionType', 00H
	ORG $+2
$SG223779 DB	'Policy_FreePromotions', 00H
	ORG $+2
$SG223780 DB	'UnitPromotions', 00H
	ORG $+1
$SG223781 DB	'FreeExperience', 00H
	ORG $+1
$SG223782 DB	'PolicyType', 00H
	ORG $+1
$SG223783 DB	'UnitCombatType', 00H
	ORG $+1
$SG223784 DB	'Policy_UnitCombatFreeExperiences', 00H
	ORG $+3
$SG223785 DB	'UnitCombatInfos', 00H
$SG223786 DB	'ProductionModifier', 00H
	ORG $+1
$SG223787 DB	'PolicyType', 00H
	ORG $+1
$SG223788 DB	'UnitCombatType', 00H
	ORG $+1
$SG223789 DB	'Policy_UnitCombatProductionModifiers', 00H
	ORG $+3
$SG223790 DB	'UnitCombatInfos', 00H
$SG223791 DB	'CultureChange', 00H
	ORG $+2
$SG223792 DB	'PolicyType', 00H
	ORG $+1
$SG223793 DB	'BuildingClassType', 00H
	ORG $+2
$SG223794 DB	'Policy_BuildingClassCultureChanges', 00H
	ORG $+1
$SG223795 DB	'BuildingClasses', 00H
$SG223796 DB	'ProductionModifier', 00H
	ORG $+1
$SG223797 DB	'PolicyType', 00H
	ORG $+1
$SG223798 DB	'BuildingClassType', 00H
	ORG $+2
$SG223799 DB	'Policy_BuildingClassProductionModifiers', 00H
$SG223800 DB	'BuildingClasses', 00H
$SG223801 DB	'TourismModifier', 00H
$SG223802 DB	'PolicyType', 00H
	ORG $+1
$SG223803 DB	'BuildingClassType', 00H
	ORG $+2
$SG223804 DB	'Policy_BuildingClassTourismModifiers', 00H
	ORG $+3
$SG223805 DB	'BuildingClasses', 00H
$SG223806 DB	'Happiness', 00H
	ORG $+2
$SG223807 DB	'PolicyType', 00H
	ORG $+1
$SG223808 DB	'BuildingClassType', 00H
	ORG $+2
$SG223809 DB	'Policy_BuildingClassHappiness', 00H
	ORG $+2
$SG223810 DB	'BuildingClasses', 00H
$SG223811 DB	'Count', 00H
	ORG $+2
$SG223812 DB	'PolicyType', 00H
	ORG $+1
$SG223813 DB	'UnitClassType', 00H
	ORG $+2
$SG223814 DB	'Policy_FreeUnitClasses', 00H
	ORG $+1
$SG223815 DB	'UnitClasses', 00H
$SG223816 DB	'Tourism', 00H
$SG223817 DB	'PolicyType', 00H
	ORG $+1
$SG223818 DB	'UnitClassType', 00H
	ORG $+2
$SG223819 DB	'Policy_TourismOnUnitCreation', 00H
	ORG $+3
$SG223820 DB	'UnitClasses', 00H
$SG223821 DB	'Yields', 00H
	ORG $+1
$SG223822 DB	'BuildingClasses', 00H
$SG223824 DB	'Policy_BuildingClassYieldModifiers', 00H
	ORG $+1
$SG223827 DB	'select BuildingClasses.ID as BuildingClassID, Yields.ID '
	DB	'as YieldID, YieldMod from Policy_BuildingClassYieldModifiers '
	DB	'inner join BuildingClasses on BuildingClasses.Type = Building'
	DB	'ClassType inner join Yields on Yields.Type = YieldType where '
	DB	'PolicyType = ?', 00H
	ORG $+2
$SG223834 DB	'Yields', 00H
	ORG $+1
$SG223835 DB	'BuildingClasses', 00H
$SG223837 DB	'Policy_BuildingClassYieldChanges', 00H
	ORG $+7
$SG223840 DB	'select BuildingClasses.ID as BuildingClassID, Yields.ID '
	DB	'as YieldID, YieldChange from Policy_BuildingClassYieldChanges'
	DB	' inner join BuildingClasses on BuildingClasses.Type = Buildin'
	DB	'gClassType inner join Yields on Yields.Type = YieldType where'
	DB	' PolicyType = ?', 00H
	ORG $+1
$SG223847 DB	'Yields', 00H
	ORG $+1
$SG223848 DB	'Improvements', 00H
	ORG $+3
$SG223850 DB	'Policy_ImprovementYieldChanges', 00H
	ORG $+1
$SG223853 DB	'select Improvements.ID as ImprovementID, Yields.ID as Yi'
	DB	'eldID, Yield from Policy_ImprovementYieldChanges inner join I'
	DB	'mprovements on Improvements.Type = ImprovementType inner join'
	DB	' Yields on Yields.Type = YieldType where PolicyType = ?', 00H
	ORG $+2
$SG223860 DB	'CultureChange', 00H
	ORG $+2
$SG223861 DB	'PolicyType', 00H
	ORG $+1
$SG223862 DB	'ImprovementType', 00H
$SG223863 DB	'Policy_ImprovementCultureChanges', 00H
	ORG $+3
$SG223864 DB	'Improvements', 00H
	ORG $+3
$SG223871 DB	'Policies', 00H
	ORG $+3
$SG223873 DB	'm_piPrereqOrPolicies', 00H
	ORG $+3
$SG223877 DB	'select Policies.ID from Policy_PrereqORPolicies inner jo'
	DB	'in Policies on Policies.Type = PrereqPolicy where PolicyType '
	DB	'= ?', 00H
	ORG $+3
$SG223883 DB	'Policies', 00H
	ORG $+3
$SG223885 DB	'm_piPrereqAndPolicies', 00H
	ORG $+2
$SG223889 DB	'select Policies.ID from Policy_PrereqPolicies inner join'
	DB	' Policies on Policies.Type = PrereqPolicy where PolicyType = '
	DB	'?', 00H
	ORG $+1
$SG223895 DB	'Policies', 00H
	ORG $+3
$SG223897 DB	'm_piPolicyDisables', 00H
	ORG $+1
$SG223901 DB	'select Policies.ID from Policy_Disables inner join Polic'
	DB	'ies on Policies.Type = PolicyDisable where PolicyType = ?', 00H
	ORG $+2
$SG223907 DB	'm_FreePromotionsUnitCombats', 00H
$SG223911 DB	'select UnitPromotions.ID, UnitCombatInfos.ID  from Polic'
	DB	'y_FreePromotionUnitCombats, UnitPromotions, UnitCombatInfos w'
	DB	'here PolicyType = ? and PromotionType = UnitPromotions.ID and'
	DB	' UnitCombatType = UnitCombatInfos.ID', 00H
	ORG $+1
$SG224818 DB	'EraPrereq', 00H
	ORG $+2
$SG224820 DB	'FreePolicy', 00H
	ORG $+1
$SG224822 DB	'FreeFinishingPolicy', 00H
$SG224823 DB	'FirstAdopterFreePolicies', 00H
	ORG $+3
$SG224824 DB	'SecondAdopterFreePolicies', 00H
	ORG $+2
$SG224826 DB	'PurchaseByLevel', 00H
$SG224827 DB	'LockedWithoutReligion', 00H
	ORG $+2
$SG224828 DB	'AIMutuallyExclusive', 00H
$SG224829 DB	'AIDelayNoReligion', 00H
	ORG $+2
$SG224830 DB	'AIDelayNoCulture', 00H
	ORG $+3
$SG224831 DB	'AIDelayNoCityStates', 00H
$SG224832 DB	'AIDelayNoScience', 00H
	ORG $+3
$SG224834 DB	'PolicyBranchTypes', 00H
	ORG $+2
$SG224836 DB	'm_piPolicyBranchDisables', 00H
	ORG $+3
$SG224840 DB	'select PolicyBranchTypes.ID from PolicyBranch_Disables i'
	DB	'nner join PolicyBranchTypes on PolicyBranchTypes.Type = Polic'
	DB	'yBranchDisable where PolicyBranchType = ?', 00H
	ORG $+1
$SG225830 DB	'PlayerCanAdoptPolicy', 00H
	ORG $+3
$SG225850 DB	'PlayerAdoptPolicyBranch', 00H
$SG225871 DB	'PlayerCanAdoptPolicyBranch', 00H
	ORG $+1
$SG225915 DB	'TXT_KEY_NOTIFICATION_IDEOLOGY_CHANGE', 00H
	ORG $+3
$SG225920 DB	'TXT_KEY_NOTIFICATION_IDEOLOGY_CHOSEN', 00H
	ORG $+3
$SG225929 DB	'TXT_KEY_NOTIFICATION_IDEOLOGY_CHANGE_UNMET', 00H
	ORG $+1
$SG225932 DB	'TXT_KEY_NOTIFICATION_IDEOLOGY_CHOSEN_UNMET', 00H
	ORG $+1
$SG225936 DB	'TXT_KEY_NOTIFICATION_SUMMARY_IDEOLOGY_CHANGE', 00H
	ORG $+3
$SG225939 DB	'TXT_KEY_NOTIFICATION_SUMMARY_IDEOLOGY_CHOSEN', 00H
	ORG $+3
$SG226269 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226685 DB	'ECONOMICAISTRATEGY_LOSING_MONEY', 00H
$SG226691 DB	'FLAVOR_GOLD', 00H
$SG226694 DB	'FLAVOR_HAPPINESS', 00H
	ORG $+3
$SG226697 DB	'FLAVOR_DEFENSE', 00H
	ORG $+1
$SG226700 DB	'FLAVOR_CITY_DEFENSE', 00H
$SG92492 DB	'b103d2e0-3aab-40d7-a2f3-375d2eabfcaf', 00H
	ORG $+3
_CIV5_XP1_SCENARIO3_MODID DD FLAT:$SG92492
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z	; std::_Container_base::_Swap_aux
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z PROC	; std::_Container_base::_Swap_aux, COMDAT
; _this$ = ecx

; 602  : 		// Do nothing: we don't have an aux object.
; 603  : 		}

	ret	4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z ENDP	; std::_Container_base::_Swap_aux
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetCultureCost@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetCultureCost
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
;	COMDAT ?GetCultureCost@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureCost@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCultureCost, COMDAT
; _this$ = ecx

; 861  : 	return m_iCultureCost;

	mov	eax, DWORD PTR [ecx+264]

; 862  : }

	ret	0
?GetCultureCost@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCultureCost
_TEXT	ENDS
PUBLIC	?GetGridX@CvPolicyEntry@@QBEHXZ			; CvPolicyEntry::GetGridX
; Function compile flags: /Ogtpy
;	COMDAT ?GetGridX@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGridX@CvPolicyEntry@@QBEHXZ PROC			; CvPolicyEntry::GetGridX, COMDAT
; _this$ = ecx

; 867  : 	return m_iGridX;

	mov	eax, DWORD PTR [ecx+268]

; 868  : }

	ret	0
?GetGridX@CvPolicyEntry@@QBEHXZ ENDP			; CvPolicyEntry::GetGridX
_TEXT	ENDS
PUBLIC	?GetGridY@CvPolicyEntry@@QBEHXZ			; CvPolicyEntry::GetGridY
; Function compile flags: /Ogtpy
;	COMDAT ?GetGridY@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGridY@CvPolicyEntry@@QBEHXZ PROC			; CvPolicyEntry::GetGridY, COMDAT
; _this$ = ecx

; 873  : 	return m_iGridY;

	mov	eax, DWORD PTR [ecx+272]

; 874  : }

	ret	0
?GetGridY@CvPolicyEntry@@QBEHXZ ENDP			; CvPolicyEntry::GetGridY
_TEXT	ENDS
PUBLIC	?GetLevel@CvPolicyEntry@@QBEHXZ			; CvPolicyEntry::GetLevel
; Function compile flags: /Ogtpy
;	COMDAT ?GetLevel@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLevel@CvPolicyEntry@@QBEHXZ PROC			; CvPolicyEntry::GetLevel, COMDAT
; _this$ = ecx

; 879  : 	return m_iLevel;

	mov	eax, DWORD PTR [ecx+276]

; 880  : }

	ret	0
?GetLevel@CvPolicyEntry@@QBEHXZ ENDP			; CvPolicyEntry::GetLevel
_TEXT	ENDS
PUBLIC	?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetPolicyCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetPolicyCostModifier, COMDAT
; _this$ = ecx

; 885  : 	return m_iPolicyCostModifier;

	mov	eax, DWORD PTR [ecx+280]

; 886  : }

	ret	0
?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetPolicyCostModifier
_TEXT	ENDS
PUBLIC	?GetCulturePerCity@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCulturePerCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePerCity@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCulturePerCity@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCulturePerCity, COMDAT
; _this$ = ecx

; 891  : 	return m_iCulturePerCity;

	mov	eax, DWORD PTR [ecx+284]

; 892  : }

	ret	0
?GetCulturePerCity@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCulturePerCity
_TEXT	ENDS
PUBLIC	?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCulturePerWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCulturePerWonder, COMDAT
; _this$ = ecx

; 906  : 	return m_iCulturePerWonder;

	mov	eax, DWORD PTR [ecx+288]

; 907  : }

	ret	0
?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCulturePerWonder
_TEXT	ENDS
PUBLIC	?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureWonderMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCultureWonderMultiplier, COMDAT
; _this$ = ecx

; 912  : 	return m_iCultureWonderMultiplier;

	mov	eax, DWORD PTR [ecx+292]

; 913  : }

	ret	0
?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCultureWonderMultiplier
_TEXT	ENDS
PUBLIC	?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturePerTechResearched
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCulturePerTechResearched, COMDAT
; _this$ = ecx

; 918  : 	return m_iCulturePerTechResearched;

	mov	eax, DWORD PTR [ecx+296]

; 919  : }

	ret	0
?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCulturePerTechResearched
_TEXT	ENDS
PUBLIC	?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureImprovementChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCultureImprovementChange, COMDAT
; _this$ = ecx

; 924  : 	return m_iCultureImprovementChange;

	mov	eax, DWORD PTR [ecx+300]

; 925  : }

	ret	0
?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCultureImprovementChange
_TEXT	ENDS
PUBLIC	?GetCultureFromKills@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCultureFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureFromKills@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCultureFromKills, COMDAT
; _this$ = ecx

; 930  : 	return m_iCultureFromKills;

	mov	eax, DWORD PTR [ecx+304]

; 931  : }

	ret	0
?GetCultureFromKills@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCultureFromKills
_TEXT	ENDS
PUBLIC	?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureFromBarbarianKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCultureFromBarbarianKills, COMDAT
; _this$ = ecx

; 936  : 	return m_iCultureFromBarbarianKills;

	mov	eax, DWORD PTR [ecx+308]

; 937  : }

	ret	0
?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCultureFromBarbarianKills
_TEXT	ENDS
PUBLIC	?GetGoldFromKills@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetGoldFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldFromKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldFromKills@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldFromKills, COMDAT
; _this$ = ecx

; 942  : 	return m_iGoldFromKills;

	mov	eax, DWORD PTR [ecx+312]

; 943  : }

	ret	0
?GetGoldFromKills@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldFromKills
_TEXT	ENDS
PUBLIC	?GetScienceFromKills@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetScienceFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetScienceFromKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetScienceFromKills@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetScienceFromKills, COMDAT
; _this$ = ecx

; 949  : 	return m_iScienceFromKills;

	mov	eax, DWORD PTR [ecx+316]

; 950  : }

	ret	0
?GetScienceFromKills@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetScienceFromKills
_TEXT	ENDS
PUBLIC	?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetEmbarkedExtraMoves
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetEmbarkedExtraMoves, COMDAT
; _this$ = ecx

; 956  : 	return m_iEmbarkedExtraMoves;

	mov	eax, DWORD PTR [ecx+320]

; 957  : }

	ret	0
?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetEmbarkedExtraMoves
_TEXT	ENDS
PUBLIC	?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetAttackBonusTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetAttackBonusTurns, COMDAT
; _this$ = ecx

; 962  : 	return m_iAttackBonusTurns;

	mov	eax, DWORD PTR [ecx+324]

; 963  : }

	ret	0
?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetAttackBonusTurns
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldenAgeTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldenAgeTurns, COMDAT
; _this$ = ecx

; 968  : 	return m_iGoldenAgeTurns;

	mov	eax, DWORD PTR [ecx+328]

; 969  : }

	ret	0
?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldenAgeTurns
_TEXT	ENDS
PUBLIC	?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldenAgeMeterMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGoldenAgeMeterMod, COMDAT
; _this$ = ecx

; 974  : 	return m_iGoldenAgeMeterMod;

	mov	eax, DWORD PTR [ecx+332]

; 975  : }

	ret	0
?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGoldenAgeMeterMod
_TEXT	ENDS
PUBLIC	?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldenAgeDurationMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGoldenAgeDurationMod, COMDAT
; _this$ = ecx

; 980  : 	return m_iGoldenAgeDurationMod;

	mov	eax, DWORD PTR [ecx+336]

; 981  : }

	ret	0
?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGoldenAgeDurationMod
_TEXT	ENDS
PUBLIC	?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetNumFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumFreeTechs, COMDAT
; _this$ = ecx

; 986  : 	return m_iNumFreeTechs;

	mov	eax, DWORD PTR [ecx+340]

; 987  : }

	ret	0
?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumFreeTechs
_TEXT	ENDS
PUBLIC	?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumFreePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumFreePolicies, COMDAT
; _this$ = ecx

; 992  : 	return m_iNumFreePolicies;

	mov	eax, DWORD PTR [ecx+344]

; 993  : }

	ret	0
?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumFreePolicies
_TEXT	ENDS
PUBLIC	?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumFreeGreatPeople
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetNumFreeGreatPeople, COMDAT
; _this$ = ecx

; 998  : 	return m_iNumFreeGreatPeople;

	mov	eax, DWORD PTR [ecx+348]

; 999  : }

	ret	0
?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetNumFreeGreatPeople
_TEXT	ENDS
PUBLIC	?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetNumExtraSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumExtraSpies, COMDAT
; _this$ = ecx

; 1005 : 	return m_iNumExtraSpies;

	mov	eax, DWORD PTR [ecx+352]

; 1006 : }

	ret	0
?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumExtraSpies
_TEXT	ENDS
PUBLIC	?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMedianTechPercentChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMedianTechPercentChange, COMDAT
; _this$ = ecx

; 1012 : 	return m_iMedianTechPercentChange;

	mov	eax, DWORD PTR [ecx+356]

; 1013 : }

	ret	0
?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMedianTechPercentChange
_TEXT	ENDS
PUBLIC	?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetStrategicResourceMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetStrategicResourceMod, COMDAT
; _this$ = ecx

; 1018 : 	return m_iStrategicResourceMod;

	mov	eax, DWORD PTR [ecx+360]

; 1019 : }

	ret	0
?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetStrategicResourceMod
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetWonderProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 1024 : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR [ecx+364]

; 1025 : }

	ret	0
?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 1030 : 	return m_iBuildingProductionModifier;

	mov	eax, DWORD PTR [ecx+368]

; 1031 : }

	ret	0
?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatPeopleRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 1036 : 	return m_iGreatPeopleRateModifier;

	mov	eax, DWORD PTR [ecx+372]

; 1037 : }

	ret	0
?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatGeneralRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 1042 : 	return m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR [ecx+376]

; 1043 : }

	ret	0
?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatAdmiralRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatAdmiralRateModifier, COMDAT
; _this$ = ecx

; 1048 : 	return m_iGreatAdmiralRateModifier;

	mov	eax, DWORD PTR [ecx+380]

; 1049 : }

	ret	0
?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatAdmiralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatWriterRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatWriterRateModifier, COMDAT
; _this$ = ecx

; 1054 : 	return m_iGreatWriterRateModifier;

	mov	eax, DWORD PTR [ecx+384]

; 1055 : }

	ret	0
?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatWriterRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatArtistRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatArtistRateModifier, COMDAT
; _this$ = ecx

; 1060 : 	return m_iGreatArtistRateModifier;

	mov	eax, DWORD PTR [ecx+388]

; 1061 : }

	ret	0
?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatArtistRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatMusicianRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGreatMusicianRateModifier, COMDAT
; _this$ = ecx

; 1066 : 	return m_iGreatMusicianRateModifier;

	mov	eax, DWORD PTR [ecx+392]

; 1067 : }

	ret	0
?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGreatMusicianRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatMerchantRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGreatMerchantRateModifier, COMDAT
; _this$ = ecx

; 1072 : 	return m_iGreatMerchantRateModifier;

	mov	eax, DWORD PTR [ecx+396]

; 1073 : }

	ret	0
?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGreatMerchantRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatScientistRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGreatScientistRateModifier, COMDAT
; _this$ = ecx

; 1078 : 	return m_iGreatScientistRateModifier;

	mov	eax, DWORD PTR [ecx+400]

; 1079 : }

	ret	0
?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGreatScientistRateModifier
_TEXT	ENDS
PUBLIC	?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 1084 : 	return m_iDomesticGreatGeneralRateModifier;

	mov	eax, DWORD PTR [ecx+404]

; 1085 : }

	ret	0
?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetExtraHappiness@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExtraHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraHappiness@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraHappiness@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetExtraHappiness, COMDAT
; _this$ = ecx

; 1090 : 	return m_iExtraHappiness;

	mov	eax, DWORD PTR [ecx+408]

; 1091 : }

	ret	0
?GetExtraHappiness@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetExtraHappiness
_TEXT	ENDS
PUBLIC	?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExtraHappinessPerCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraHappinessPerCity, COMDAT
; _this$ = ecx

; 1096 : 	return m_iExtraHappinessPerCity;

	mov	eax, DWORD PTR [ecx+412]

; 1097 : }

	ret	0
?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraHappinessPerCity
_TEXT	ENDS
PUBLIC	?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetUnhappinessMod, COMDAT
; _this$ = ecx

; 1102 : 	return m_iUnhappinessMod;

	mov	eax, DWORD PTR [ecx+416]

; 1103 : }

	ret	0
?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityCountUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCityCountUnhappinessMod, COMDAT
; _this$ = ecx

; 1108 : 	return m_iCityCountUnhappinessMod;

	mov	eax, DWORD PTR [ecx+420]

; 1109 : }

	ret	0
?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCityCountUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOccupiedPopulationUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetOccupiedPopulationUnhappinessMod, COMDAT
; _this$ = ecx

; 1114 : 	return m_iOccupiedPopulationUnhappinessMod;

	mov	eax, DWORD PTR [ecx+424]

; 1115 : }

	ret	0
?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetOccupiedPopulationUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCapitalUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCapitalUnhappinessMod, COMDAT
; _this$ = ecx

; 1120 : 	return m_iCapitalUnhappinessMod;

	mov	eax, DWORD PTR [ecx+428]

; 1121 : }

	ret	0
?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCapitalUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetFreeExperience@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetFreeExperience
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeExperience@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeExperience@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetFreeExperience, COMDAT
; _this$ = ecx

; 1126 : 	return m_iFreeExperience;

	mov	eax, DWORD PTR [ecx+432]

; 1127 : }

	ret	0
?GetFreeExperience@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetFreeExperience
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetWorkerSpeedModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 1132 : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR [ecx+436]

; 1133 : }

	ret	0
?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetAllFeatureProduction
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetAllFeatureProduction, COMDAT
; _this$ = ecx

; 1138 : 	return m_iAllFeatureProduction;

	mov	eax, DWORD PTR [ecx+440]

; 1139 : }

	ret	0
?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetAllFeatureProduction
_TEXT	ENDS
PUBLIC	?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetImprovementCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetImprovementCostModifier, COMDAT
; _this$ = ecx

; 1144 : 	return m_iImprovementCostModifier;

	mov	eax, DWORD PTR [ecx+444]

; 1145 : }

	ret	0
?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetImprovementCostModifier
_TEXT	ENDS
PUBLIC	?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetImprovementUpgradeRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetImprovementUpgradeRateModifier, COMDAT
; _this$ = ecx

; 1150 : 	return m_iImprovementUpgradeRateModifier;

	mov	eax, DWORD PTR [ecx+448]

; 1151 : }

	ret	0
?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetImprovementUpgradeRateModifier
_TEXT	ENDS
PUBLIC	?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSpecialistProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSpecialistProductionModifier, COMDAT
; _this$ = ecx

; 1156 : 	return m_iSpecialistProductionModifier;

	mov	eax, DWORD PTR [ecx+452]

; 1157 : }

	ret	0
?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSpecialistProductionModifier
_TEXT	ENDS
PUBLIC	?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSpecialistUpgradeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSpecialistUpgradeModifier, COMDAT
; _this$ = ecx

; 1162 : 	return m_iSpecialistUpgradeModifier;

	mov	eax, DWORD PTR [ecx+456]

; 1163 : }

	ret	0
?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSpecialistUpgradeModifier
_TEXT	ENDS
PUBLIC	?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMilitaryProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMilitaryProductionModifier, COMDAT
; _this$ = ecx

; 1168 : 	return m_iMilitaryProductionModifier;

	mov	eax, DWORD PTR [ecx+460]

; 1169 : }

	ret	0
?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMilitaryProductionModifier
_TEXT	ENDS
PUBLIC	?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetBaseFreeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetBaseFreeUnits, COMDAT
; _this$ = ecx

; 1174 : 	return m_iBaseFreeUnits;

	mov	eax, DWORD PTR [ecx+464]

; 1175 : }

	ret	0
?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetBaseFreeUnits
_TEXT	ENDS
PUBLIC	?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetBaseFreeMilitaryUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetBaseFreeMilitaryUnits, COMDAT
; _this$ = ecx

; 1180 : 	return m_iBaseFreeMilitaryUnits;

	mov	eax, DWORD PTR [ecx+468]

; 1181 : }

	ret	0
?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetBaseFreeMilitaryUnits
_TEXT	ENDS
PUBLIC	?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetFreeUnitsPopulationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetFreeUnitsPopulationPercent, COMDAT
; _this$ = ecx

; 1186 : 	return m_iFreeUnitsPopulationPercent;

	mov	eax, DWORD PTR [ecx+472]

; 1187 : }

	ret	0
?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetFreeUnitsPopulationPercent
_TEXT	ENDS
PUBLIC	?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetFreeMilitaryUnitsPopulationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetFreeMilitaryUnitsPopulationPercent, COMDAT
; _this$ = ecx

; 1192 : 	return m_iFreeMilitaryUnitsPopulationPercent;

	mov	eax, DWORD PTR [ecx+476]

; 1193 : }

	ret	0
?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetFreeMilitaryUnitsPopulationPercent
_TEXT	ENDS
PUBLIC	?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerGarrisonedUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetHappinessPerGarrisonedUnit, COMDAT
; _this$ = ecx

; 1198 : 	return m_iHappinessPerGarrisonedUnit;

	mov	eax, DWORD PTR [ecx+480]

; 1199 : }

	ret	0
?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetHappinessPerGarrisonedUnit
_TEXT	ENDS
PUBLIC	?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturePerGarrisonedUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCulturePerGarrisonedUnit, COMDAT
; _this$ = ecx

; 1204 : 	return m_iCulturePerGarrisonedUnit;

	mov	eax, DWORD PTR [ecx+484]

; 1205 : }

	ret	0
?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCulturePerGarrisonedUnit
_TEXT	ENDS
PUBLIC	?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessPerTradeRoute, COMDAT
; _this$ = ecx

; 1210 : 	return m_iHappinessPerTradeRoute;

	mov	eax, DWORD PTR [ecx+488]

; 1211 : }

	ret	0
?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessPerTradeRoute
_TEXT	ENDS
PUBLIC	?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerRailConnection
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetHappinessPerRailConnection, COMDAT
; _this$ = ecx

; 1217 : 	return m_iHappinessPerRailConnection;

	mov	eax, DWORD PTR [ecx+492]

; 1218 : }

	ret	0
?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetHappinessPerRailConnection
_TEXT	ENDS
PUBLIC	?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerXPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessPerXPopulation, COMDAT
; _this$ = ecx

; 1224 : 	return m_iHappinessPerXPopulation;

	mov	eax, DWORD PTR [ecx+496]

; 1225 : }

	ret	0
?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessPerXPopulation
_TEXT	ENDS
PUBLIC	?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraHappinessPerLuxury
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraHappinessPerLuxury, COMDAT
; _this$ = ecx

; 1230 : 	return m_iExtraHappinessPerLuxury;

	mov	eax, DWORD PTR [ecx+500]

; 1231 : }

	ret	0
?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraHappinessPerLuxury
_TEXT	ENDS
PUBLIC	?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetUnhappinessFromUnitsMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnhappinessFromUnitsMod, COMDAT
; _this$ = ecx

; 1236 : 	return m_iUnhappinessFromUnitsMod;

	mov	eax, DWORD PTR [ecx+504]

; 1237 : }

	ret	0
?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnhappinessFromUnitsMod
_TEXT	ENDS
PUBLIC	?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumExtraBuilders
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumExtraBuilders, COMDAT
; _this$ = ecx

; 1242 : 	return m_iNumExtraBuilders;

	mov	eax, DWORD PTR [ecx+508]

; 1243 : }

	ret	0
?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumExtraBuilders
_TEXT	ENDS
PUBLIC	?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetPlotGoldCostMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetPlotGoldCostMod, COMDAT
; _this$ = ecx

; 1248 : 	return m_iPlotGoldCostMod;

	mov	eax, DWORD PTR [ecx+512]

; 1249 : }

	ret	0
?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetPlotGoldCostMod
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPlotCultureCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 1254 : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR [ecx+516]

; 1255 : }

	ret	0
?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPlotCultureExponentModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetPlotCultureExponentModifier, COMDAT
; _this$ = ecx

; 1260 : 	return m_iPlotCultureExponentModifier;

	mov	eax, DWORD PTR [ecx+520]

; 1261 : }

	ret	0
?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetPlotCultureExponentModifier
_TEXT	ENDS
PUBLIC	?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesPolicyCostDiscount
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesPolicyCostDiscount, COMDAT
; _this$ = ecx

; 1266 : 	return m_iNumCitiesPolicyCostDiscount;

	mov	eax, DWORD PTR [ecx+524]

; 1267 : }

	ret	0
?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesPolicyCostDiscount
_TEXT	ENDS
PUBLIC	?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesResearchCostDiscount
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesResearchCostDiscount, COMDAT
; _this$ = ecx

; 1273 : 	return m_iNumCitiesResearchCostDiscount;

	mov	eax, DWORD PTR [ecx+528]

; 1274 : }

	ret	0
?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesResearchCostDiscount
_TEXT	ENDS
PUBLIC	?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier, COMDAT
; _this$ = ecx

; 1280 : 	return m_iGarrisonedCityRangeStrikeModifier;

	mov	eax, DWORD PTR [ecx+532]

; 1281 : }

	ret	0
?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier
_TEXT	ENDS
PUBLIC	?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetUnitPurchaseCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnitPurchaseCostModifier, COMDAT
; _this$ = ecx

; 1286 : 	return m_iUnitPurchaseCostModifier;

	mov	eax, DWORD PTR [ecx+536]

; 1287 : }

	ret	0
?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnitPurchaseCostModifier
_TEXT	ENDS
PUBLIC	?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingPurchaseCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetBuildingPurchaseCostModifier, COMDAT
; _this$ = ecx

; 1292 : 	return m_iBuildingPurchaseCostModifier;

	mov	eax, DWORD PTR [ecx+540]

; 1293 : }

	ret	0
?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetBuildingPurchaseCostModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityConnectionTradeRouteGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCityConnectionTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 1298 : 	return m_iCityConnectionTradeRouteGoldModifier;

	mov	eax, DWORD PTR [ecx+544]

; 1299 : }

	ret	0
?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCityConnectionTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeMissionGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetTradeMissionGoldModifier, COMDAT
; _this$ = ecx

; 1304 : 	return m_iTradeMissionGoldModifier;

	mov	eax, DWORD PTR [ecx+548]

; 1305 : }

	ret	0
?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetTradeMissionGoldModifier
_TEXT	ENDS
PUBLIC	?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetFaithCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetFaithCostModifier, COMDAT
; _this$ = ecx

; 1310 : 	return m_iFaithCostModifier;

	mov	eax, DWORD PTR [ecx+552]

; 1311 : }

	ret	0
?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetFaithCostModifier
_TEXT	ENDS
PUBLIC	?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturalPlunderMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCulturalPlunderMultiplier, COMDAT
; _this$ = ecx

; 1316 : 	return m_iCulturalPlunderMultiplier;

	mov	eax, DWORD PTR [ecx+556]

; 1317 : }

	ret	0
?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCulturalPlunderMultiplier
_TEXT	ENDS
PUBLIC	?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetStealTechSlowerModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetStealTechSlowerModifier, COMDAT
; _this$ = ecx

; 1322 : 	return m_iStealTechSlowerModifier;

	mov	eax, DWORD PTR [ecx+560]

; 1323 : }

	ret	0
?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetStealTechSlowerModifier
_TEXT	ENDS
PUBLIC	?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetStealTechFasterModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetStealTechFasterModifier, COMDAT
; _this$ = ecx

; 1327 : 	return m_iStealTechFasterModifier;

	mov	eax, DWORD PTR [ecx+564]

; 1328 : }

	ret	0
?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetStealTechFasterModifier
_TEXT	ENDS
PUBLIC	?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCatchSpiesModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCatchSpiesModifier, COMDAT
; _this$ = ecx

; 1333 : 	return m_iCatchSpiesModifier;

	mov	eax, DWORD PTR [ecx+568]

; 1334 : }

	ret	0
?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCatchSpiesModifier
_TEXT	ENDS
PUBLIC	?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetGoldPerUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldPerUnit, COMDAT
; _this$ = ecx

; 1339 : 	return m_iGoldPerUnit;

	mov	eax, DWORD PTR [ecx+572]

; 1340 : }

	ret	0
?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldPerUnit
_TEXT	ENDS
PUBLIC	?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldPerMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGoldPerMilitaryUnit, COMDAT
; _this$ = ecx

; 1345 : 	return m_iGoldPerMilitaryUnit;

	mov	eax, DWORD PTR [ecx+576]

; 1346 : }

	ret	0
?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGoldPerMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCityStrengthMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCityStrengthMod, COMDAT
; _this$ = ecx

; 1351 : 	return m_iCityStrengthMod;

	mov	eax, DWORD PTR [ecx+580]

; 1352 : }

	ret	0
?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCityStrengthMod
_TEXT	ENDS
PUBLIC	?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetCityGrowthMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCityGrowthMod, COMDAT
; _this$ = ecx

; 1357 : 	return m_iCityGrowthMod;

	mov	eax, DWORD PTR [ecx+584]

; 1358 : }

	ret	0
?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCityGrowthMod
_TEXT	ENDS
PUBLIC	?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCapitalGrowthMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCapitalGrowthMod, COMDAT
; _this$ = ecx

; 1363 : 	return m_iCapitalGrowthMod;

	mov	eax, DWORD PTR [ecx+588]

; 1364 : }

	ret	0
?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCapitalGrowthMod
_TEXT	ENDS
PUBLIC	?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSettlerProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSettlerProductionModifier, COMDAT
; _this$ = ecx

; 1369 : 	return m_iSettlerProductionModifier;

	mov	eax, DWORD PTR [ecx+592]

; 1370 : }

	ret	0
?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSettlerProductionModifier
_TEXT	ENDS
PUBLIC	?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCapitalSettlerProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCapitalSettlerProductionModifier, COMDAT
; _this$ = ecx

; 1375 : 	return m_iCapitalSettlerProductionModifier;

	mov	eax, DWORD PTR [ecx+596]

; 1376 : }

	ret	0
?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCapitalSettlerProductionModifier
_TEXT	ENDS
PUBLIC	?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNewCityExtraPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetNewCityExtraPopulation, COMDAT
; _this$ = ecx

; 1381 : 	return m_iNewCityExtraPopulation;

	mov	eax, DWORD PTR [ecx+600]

; 1382 : }

	ret	0
?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetNewCityExtraPopulation
_TEXT	ENDS
PUBLIC	?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetFreeFoodBox
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetFreeFoodBox, COMDAT
; _this$ = ecx

; 1387 : 	return m_iFreeFoodBox;

	mov	eax, DWORD PTR [ecx+604]

; 1388 : }

	ret	0
?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetFreeFoodBox
_TEXT	ENDS
PUBLIC	?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRouteGoldMaintenanceMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetRouteGoldMaintenanceMod, COMDAT
; _this$ = ecx

; 1393 : 	return m_iRouteGoldMaintenanceMod;

	mov	eax, DWORD PTR [ecx+608]

; 1394 : }

	ret	0
?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetRouteGoldMaintenanceMod
_TEXT	ENDS
PUBLIC	?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingGoldMaintenanceMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetBuildingGoldMaintenanceMod, COMDAT
; _this$ = ecx

; 1399 : 	return m_iBuildingGoldMaintenanceMod;

	mov	eax, DWORD PTR [ecx+612]

; 1400 : }

	ret	0
?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetBuildingGoldMaintenanceMod
_TEXT	ENDS
PUBLIC	?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetUnitGoldMaintenanceMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnitGoldMaintenanceMod, COMDAT
; _this$ = ecx

; 1405 : 	return m_iUnitGoldMaintenanceMod;

	mov	eax, DWORD PTR [ecx+616]

; 1406 : }

	ret	0
?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnitGoldMaintenanceMod
_TEXT	ENDS
PUBLIC	?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetUnitSupplyMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetUnitSupplyMod, COMDAT
; _this$ = ecx

; 1411 : 	return m_iUnitSupplyMod;

	mov	eax, DWORD PTR [ecx+620]

; 1412 : }

	ret	0
?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetUnitSupplyMod
_TEXT	ENDS
PUBLIC	?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetHappyPerMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappyPerMilitaryUnit, COMDAT
; _this$ = ecx

; 1417 : 	return m_iHappyPerMilitaryUnit;

	mov	eax, DWORD PTR [ecx+624]

; 1418 : }

	ret	0
?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappyPerMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetFreeSpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetFreeSpecialist, COMDAT
; _this$ = ecx

; 1423 : 	return m_iFreeSpecialist;

	mov	eax, DWORD PTR [ecx+812]

; 1424 : }

	ret	0
?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetFreeSpecialist
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechPrereq@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechPrereq@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 1429 : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+260]

; 1430 : }

	ret	0
?GetTechPrereq@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetMaxConscript@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetMaxConscript
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxConscript@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxConscript@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetMaxConscript, COMDAT
; _this$ = ecx

; 1435 : 	return m_iMaxConscript;

	mov	eax, DWORD PTR [ecx+816]

; 1436 : }

	ret	0
?GetMaxConscript@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetMaxConscript
_TEXT	ENDS
PUBLIC	?GetExpModifier@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetExpModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetExpModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExpModifier@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetExpModifier, COMDAT
; _this$ = ecx

; 1441 : 	return m_iExpModifier;

	mov	eax, DWORD PTR [ecx+628]

; 1442 : }

	ret	0
?GetExpModifier@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetExpModifier
_TEXT	ENDS
PUBLIC	?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExpInBorderModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExpInBorderModifier, COMDAT
; _this$ = ecx

; 1447 : 	return m_iExpInBorderModifier;

	mov	eax, DWORD PTR [ecx+632]

; 1448 : }

	ret	0
?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExpInBorderModifier
_TEXT	ENDS
PUBLIC	?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorQuestFriendshipMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorQuestFriendshipMod, COMDAT
; _this$ = ecx

; 1453 : 	return m_iMinorQuestFriendshipMod;

	mov	eax, DWORD PTR [ecx+636]

; 1454 : }

	ret	0
?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorQuestFriendshipMod
_TEXT	ENDS
PUBLIC	?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorGoldFriendshipMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorGoldFriendshipMod, COMDAT
; _this$ = ecx

; 1459 : 	return m_iMinorGoldFriendshipMod;

	mov	eax, DWORD PTR [ecx+640]

; 1460 : }

	ret	0
?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorGoldFriendshipMod
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipMinimum
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorFriendshipMinimum, COMDAT
; _this$ = ecx

; 1465 : 	return m_iMinorFriendshipMinimum;

	mov	eax, DWORD PTR [ecx+644]

; 1466 : }

	ret	0
?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorFriendshipMinimum
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipDecayMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorFriendshipDecayMod, COMDAT
; _this$ = ecx

; 1471 : 	return m_iMinorFriendshipDecayMod;

	mov	eax, DWORD PTR [ecx+648]

; 1472 : }

	ret	0
?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorFriendshipDecayMod
_TEXT	ENDS
PUBLIC	?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOtherPlayersMinorFriendshipDecayMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetOtherPlayersMinorFriendshipDecayMod, COMDAT
; _this$ = ecx

; 1477 : 	return m_iOtherPlayersMinorFriendshipDecayMod;

	mov	eax, DWORD PTR [ecx+652]

; 1478 : }

	ret	0
?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetOtherPlayersMinorFriendshipDecayMod
_TEXT	ENDS
PUBLIC	?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateUnitFrequencyModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCityStateUnitFrequencyModifier, COMDAT
; _this$ = ecx

; 1483 : 	return m_iCityStateUnitFrequencyModifier;

	mov	eax, DWORD PTR [ecx+656]

; 1484 : }

	ret	0
?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCityStateUnitFrequencyModifier
_TEXT	ENDS
PUBLIC	?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCommonFoeTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCommonFoeTourismModifier, COMDAT
; _this$ = ecx

; 1489 : 	return m_iCommonFoeTourismModifier;

	mov	eax, DWORD PTR [ecx+660]

; 1490 : }

	ret	0
?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCommonFoeTourismModifier
_TEXT	ENDS
PUBLIC	?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetLessHappyTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetLessHappyTourismModifier, COMDAT
; _this$ = ecx

; 1495 : 	return m_iLessHappyTourismModifier;

	mov	eax, DWORD PTR [ecx+664]

; 1496 : }

	ret	0
?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetLessHappyTourismModifier
_TEXT	ENDS
PUBLIC	?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedIdeologyTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSharedIdeologyTourismModifier, COMDAT
; _this$ = ecx

; 1501 : 	return m_iSharedIdeologyTourismModifier;

	mov	eax, DWORD PTR [ecx+668]

; 1502 : }

	ret	0
?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSharedIdeologyTourismModifier
_TEXT	ENDS
PUBLIC	?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetLandTradeRouteGoldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetLandTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 1507 : 	return m_iLandTradeRouteGoldChange;

	mov	eax, DWORD PTR [ecx+672]

; 1508 : }

	ret	0
?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetLandTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSeaTradeRouteGoldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetSeaTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 1513 : 	return m_iSeaTradeRouteGoldChange;

	mov	eax, DWORD PTR [ecx+676]

; 1514 : }

	ret	0
?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetSeaTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteGoldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInternalTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 1520 : 	return m_iInternalTradeRouteGoldChange;

	mov	eax, DWORD PTR [ecx+680]

; 1521 : }

	ret	0
?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInternalTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange, COMDAT
; _this$ = ecx

; 1526 : 	return m_iSharedIdeologyTradeGoldChange;

	mov	eax, DWORD PTR [ecx+684]

; 1527 : }

	ret	0
?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange
_TEXT	ENDS
PUBLIC	?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRiggingElectionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetRiggingElectionModifier, COMDAT
; _this$ = ecx

; 1532 : 	return m_iRiggingElectionModifier;

	mov	eax, DWORD PTR [ecx+688]

; 1533 : }

	ret	0
?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetRiggingElectionModifier
_TEXT	ENDS
PUBLIC	?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence, COMDAT
; _this$ = ecx

; 1538 : 	return m_iMilitaryUnitGiftExtraInfluence;

	mov	eax, DWORD PTR [ecx+692]

; 1539 : }

	ret	0
?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence
_TEXT	ENDS
PUBLIC	?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 1544 : 	return m_iProtectedMinorPerTurnInfluence;

	mov	eax, DWORD PTR [ecx+696]

; 1545 : }

	ret	0
?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 1550 : 	return m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR [ecx+700]

; 1551 : }

	ret	0
?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorBullyScoreModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorBullyScoreModifier, COMDAT
; _this$ = ecx

; 1556 : 	return m_iMinorBullyScoreModifier;

	mov	eax, DWORD PTR [ecx+704]

; 1557 : }

	ret	0
?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorBullyScoreModifier
_TEXT	ENDS
PUBLIC	?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetThemingBonusMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetThemingBonusMultiplier, COMDAT
; _this$ = ecx

; 1562 : 	return m_iThemingBonusMultiplier;

	mov	eax, DWORD PTR [ecx+708]

; 1563 : }

	ret	0
?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetThemingBonusMultiplier
_TEXT	ENDS
PUBLIC	?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInternalTradeRouteYieldModifier, COMDAT
; _this$ = ecx

; 1568 : 	return m_iInternalTradeRouteYieldModifier;

	mov	eax, DWORD PTR [ecx+712]

; 1569 : }

	ret	0
?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInternalTradeRouteYieldModifier
_TEXT	ENDS
PUBLIC	?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange, COMDAT
; _this$ = ecx

; 1583 : 	return m_iInternalTradeRouteProductionYieldChange;

	mov	eax, DWORD PTR [ecx+716]

; 1584 : }

	ret	0
?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange
_TEXT	ENDS
PUBLIC	?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRailConnectionProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetRailConnectionProductionModifier, COMDAT
; _this$ = ecx

; 1591 : 	return m_iRailConnectionProductionModifier;

	mov	eax, DWORD PTR [ecx+720]

; 1592 : }

	ret	0
?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetRailConnectionProductionModifier
_TEXT	ENDS
PUBLIC	?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCombatBonusVsSmallerCiv
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCombatBonusVsSmallerCiv, COMDAT
; _this$ = ecx

; 1599 : 	return m_iCombatBonusVsSmallerCiv;

	mov	eax, DWORD PTR [ecx+724]

; 1600 : }

	ret	0
?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCombatBonusVsSmallerCiv
_TEXT	ENDS
PUBLIC	?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProductionToGreatMusiciansModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetProductionToGreatMusiciansModifier, COMDAT
; _this$ = ecx

; 1607 : 	return m_iProductionToGreatMusiciansModifier;

	mov	eax, DWORD PTR [ecx+728]

; 1608 : }

	ret	0
?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetProductionToGreatMusiciansModifier
_TEXT	ENDS
PUBLIC	?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeMissionInfluenceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetTradeMissionInfluenceModifier, COMDAT
; _this$ = ecx

; 1616 : 	return m_iTradeMissionInfluenceModifier;

	mov	eax, DWORD PTR [ecx+732]

; 1617 : }

	ret	0
?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetTradeMissionInfluenceModifier
_TEXT	ENDS
PUBLIC	?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSciencePerGreatPersonBorn
; Function compile flags: /Ogtpy
;	COMDAT ?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSciencePerGreatPersonBorn, COMDAT
; _this$ = ecx

; 1624 : 	return m_iSciencePerGreatPersonBorn;

	mov	eax, DWORD PTR [ecx+736]

; 1625 : }

	ret	0
?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSciencePerGreatPersonBorn
_TEXT	ENDS
PUBLIC	?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn, COMDAT
; _this$ = ecx

; 1632 : 	return m_iInfluenceBoostPerGreatPersonBorn;

	mov	eax, DWORD PTR [ecx+740]

; 1633 : }

	ret	0
?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn
_TEXT	ENDS
PUBLIC	?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTourismFromTradeMissions
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetTourismFromTradeMissions, COMDAT
; _this$ = ecx

; 1640 : 	return m_iTourismFromTradeMissions;

	mov	eax, DWORD PTR [ecx+744]

; 1641 : }

	ret	0
?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetTourismFromTradeMissions
_TEXT	ENDS
PUBLIC	?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessFromGreatImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetHappinessFromGreatImprovements, COMDAT
; _this$ = ecx

; 1648 : 	return m_iHappinessFromGreatImprovements;

	mov	eax, DWORD PTR [ecx+748]

; 1649 : }

	ret	0
?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetHappinessFromGreatImprovements
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess, COMDAT
; _this$ = ecx

; 1656 : 	return m_iMinorFriendshipGainBullyGoldSuccess;

	mov	eax, DWORD PTR [ecx+752]

; 1657 : }

	ret	0
?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess
_TEXT	ENDS
PUBLIC	?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCoupChanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCoupChanceModifier, COMDAT
; _this$ = ecx

; 1664 : 	return m_iCoupChanceModifier;

	mov	eax, DWORD PTR [ecx+756]

; 1665 : }

	ret	0
?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCoupChanceModifier
_TEXT	ENDS
PUBLIC	?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedReligionTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSharedReligionTourismModifier, COMDAT
; _this$ = ecx

; 1671 : 	return m_iSharedReligionTourismModifier;

	mov	eax, DWORD PTR [ecx+760]

; 1672 : }

	ret	0
?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSharedReligionTourismModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeRouteTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetTradeRouteTourismModifier, COMDAT
; _this$ = ecx

; 1677 : 	return m_iTradeRouteTourismModifier;

	mov	eax, DWORD PTR [ecx+764]

; 1678 : }

	ret	0
?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetTradeRouteTourismModifier
_TEXT	ENDS
PUBLIC	?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOpenBordersTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetOpenBordersTourismModifier, COMDAT
; _this$ = ecx

; 1683 : 	return m_iOpenBordersTourismModifier;

	mov	eax, DWORD PTR [ecx+768]

; 1684 : }

	ret	0
?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetOpenBordersTourismModifier
_TEXT	ENDS
PUBLIC	?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCityStateTradeChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCityStateTradeChange, COMDAT
; _this$ = ecx

; 1689 : 	return m_iCityStateTradeChange;

	mov	eax, DWORD PTR [ecx+772]

; 1690 : }

	ret	0
?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCityStateTradeChange
_TEXT	ENDS
PUBLIC	?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsMinorGreatPeopleAllies
; Function compile flags: /Ogtpy
;	COMDAT ?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMinorGreatPeopleAllies, COMDAT
; _this$ = ecx

; 1695 : 	return m_bMinorGreatPeopleAllies;

	mov	al, BYTE PTR [ecx+776]

; 1696 : }

	ret	0
?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMinorGreatPeopleAllies
_TEXT	ENDS
PUBLIC	?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsMinorScienceAllies
; Function compile flags: /Ogtpy
;	COMDAT ?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMinorScienceAllies, COMDAT
; _this$ = ecx

; 1701 : 	return m_bMinorScienceAllies;

	mov	al, BYTE PTR [ecx+777]

; 1702 : }

	ret	0
?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMinorScienceAllies
_TEXT	ENDS
PUBLIC	?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsMinorResourceBonus
; Function compile flags: /Ogtpy
;	COMDAT ?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMinorResourceBonus, COMDAT
; _this$ = ecx

; 1707 : 	return m_bMinorResourceBonus;

	mov	al, BYTE PTR [ecx+778]

; 1708 : }

	ret	0
?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMinorResourceBonus
_TEXT	ENDS
PUBLIC	?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift, COMDAT
; _this$ = ecx

; 1714 : 	return m_iMinorMilitaryNumExtraUnitsToGift;

	mov	eax, DWORD PTR [ecx+780]

; 1715 : }

	ret	0
?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift
_TEXT	ENDS
PUBLIC	?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateBonusModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCityStateBonusModifier, COMDAT
; _this$ = ecx

; 1720 : 	return m_iCityStateBonusModifier;

	mov	eax, DWORD PTR [ecx+784]

; 1721 : }

	ret	0
?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCityStateBonusModifier
_TEXT	ENDS
PUBLIC	?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExtraTerritoryClaim
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraTerritoryClaim, COMDAT
; _this$ = ecx

; 1728 : 	return m_iExtraTerritoryClaim;

	mov	eax, DWORD PTR [ecx+788]

; 1729 : }

	ret	0
?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraTerritoryClaim
_TEXT	ENDS
PUBLIC	?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraTourismPerGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraTourismPerGreatWork, COMDAT
; _this$ = ecx

; 1735 : 	return m_iExtraTourismPerGreatWork;

	mov	eax, DWORD PTR [ecx+792]

; 1736 : }

	ret	0
?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraTourismPerGreatWork
_TEXT	ENDS
PUBLIC	?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetTourismPerWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetTourismPerWonder, COMDAT
; _this$ = ecx

; 1742 : 	return m_iTourismPerWonder;

	mov	eax, DWORD PTR [ecx+796]

; 1743 : }

	ret	0
?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetTourismPerWonder
_TEXT	ENDS
PUBLIC	?GetTourismPerCity@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetTourismPerCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismPerCity@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTourismPerCity@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetTourismPerCity, COMDAT
; _this$ = ecx

; 1749 : 	return m_iTourismPerCity;

	mov	eax, DWORD PTR [ecx+800]

; 1750 : }

	ret	0
?GetTourismPerCity@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetTourismPerCity
_TEXT	ENDS
PUBLIC	?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier, COMDAT
; _this$ = ecx

; 1757 : 	return m_iIdeologyPressureUnhappinessModifier;

	mov	eax, DWORD PTR [ecx+804]

; 1758 : }

	ret	0
?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProductionFromGarrison
; Function compile flags: /Ogtpy
;	COMDAT ?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetProductionFromGarrison, COMDAT
; _this$ = ecx

; 1765 : 	return m_iProductionFromGarrison;

	mov	eax, DWORD PTR [ecx+808]

; 1766 : }

	ret	0
?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetProductionFromGarrison
_TEXT	ENDS
PUBLIC	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetPolicyBranchType
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetPolicyBranchType, COMDAT
; _this$ = ecx

; 1771 : 	return m_iPolicyBranchType;

	mov	eax, DWORD PTR [ecx+820]

; 1772 : }

	ret	0
?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetPolicyBranchType
_TEXT	ENDS
PUBLIC	?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumExtraBranches
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumExtraBranches, COMDAT
; _this$ = ecx

; 1777 : 	return m_iNumExtraBranches;

	mov	eax, DWORD PTR [ecx+824]

; 1778 : }

	ret	0
?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumExtraBranches
_TEXT	ENDS
PUBLIC	?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetHappinessToCulture
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessToCulture, COMDAT
; _this$ = ecx

; 1783 : 	return m_iHappinessToCulture;

	mov	eax, DWORD PTR [ecx+840]

; 1784 : }

	ret	0
?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessToCulture
_TEXT	ENDS
PUBLIC	?GetHappinessToScience@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetHappinessToScience
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessToScience@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessToScience@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessToScience, COMDAT
; _this$ = ecx

; 1789 : 	return m_iHappinessToScience;

	mov	eax, DWORD PTR [ecx+844]

; 1790 : }

	ret	0
?GetHappinessToScience@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessToScience
_TEXT	ENDS
PUBLIC	?GetGoldToScience@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetGoldToScience
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldToScience@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldToScience@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldToScience, COMDAT
; _this$ = ecx

; 1796 : 	return m_iGoldToScience;

	mov	eax, DWORD PTR [ecx+848]

; 1797 : }

	ret	0
?GetGoldToScience@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldToScience
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreeAestheticsSchools
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreeAestheticsSchools, COMDAT
; _this$ = ecx

; 1804 : 	return m_iNumCitiesFreeAestheticsSchools;

	mov	eax, DWORD PTR [ecx+852]

; 1805 : }

	ret	0
?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreeAestheticsSchools
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreePietyGardens
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreePietyGardens, COMDAT
; _this$ = ecx

; 1810 : 	return m_iNumCitiesFreePietyGardens;

	mov	eax, DWORD PTR [ecx+856]

; 1811 : }

	ret	0
?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreePietyGardens
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumCitiesFreeWalls
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetNumCitiesFreeWalls, COMDAT
; _this$ = ecx

; 1817 : 	return m_iNumCitiesFreeWalls;

	mov	eax, DWORD PTR [ecx+860]

; 1818 : }

	ret	0
?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetNumCitiesFreeWalls
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreeCultureBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreeCultureBuilding, COMDAT
; _this$ = ecx

; 1823 : 	return m_iNumCitiesFreeCultureBuilding;

	mov	eax, DWORD PTR [ecx+864]

; 1824 : }

	ret	0
?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreeCultureBuilding
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreeFoodBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreeFoodBuilding, COMDAT
; _this$ = ecx

; 1829 : 	return m_iNumCitiesFreeFoodBuilding;

	mov	eax, DWORD PTR [ecx+868]

; 1830 : }

	ret	0
?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreeFoodBuilding
_TEXT	ENDS
PUBLIC	?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsHalfSpecialistUnhappiness
; Function compile flags: /Ogtpy
;	COMDAT ?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsHalfSpecialistUnhappiness, COMDAT
; _this$ = ecx

; 1835 : 	return m_bHalfSpecialistUnhappiness;

	mov	al, BYTE PTR [ecx+872]

; 1836 : }

	ret	0
?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsHalfSpecialistUnhappiness
_TEXT	ENDS
PUBLIC	?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsHalfMoreSpecialistUnhappiness
; Function compile flags: /Ogtpy
;	COMDAT ?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsHalfMoreSpecialistUnhappiness, COMDAT
; _this$ = ecx

; 1840 : 	return m_bHalfMoreSpecialistUnhappiness;

	mov	al, BYTE PTR [ecx+873]

; 1841 : }

	ret	0
?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsHalfMoreSpecialistUnhappiness
_TEXT	ENDS
PUBLIC	?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsHalfSpecialistFood
; Function compile flags: /Ogtpy
;	COMDAT ?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsHalfSpecialistFood, COMDAT
; _this$ = ecx

; 1845 : 	return m_bHalfSpecialistFood;

	mov	al, BYTE PTR [ecx+874]

; 1846 : }

	ret	0
?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsHalfSpecialistFood
_TEXT	ENDS
PUBLIC	?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsMilitaryFoodProduction
; Function compile flags: /Ogtpy
;	COMDAT ?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMilitaryFoodProduction, COMDAT
; _this$ = ecx

; 1851 : 	return m_bMilitaryFoodProduction;

	mov	al, BYTE PTR [ecx+875]

; 1852 : }

	ret	0
?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMilitaryFoodProduction
_TEXT	ENDS
PUBLIC	?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetWoundedUnitDamageMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetWoundedUnitDamageMod, COMDAT
; _this$ = ecx

; 1857 : 	return m_iWoundedUnitDamageMod;

	mov	eax, DWORD PTR [ecx+828]

; 1858 : }

	ret	0
?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetWoundedUnitDamageMod
_TEXT	ENDS
PUBLIC	?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetUnitUpgradeCostMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnitUpgradeCostMod, COMDAT
; _this$ = ecx

; 1863 : 	return m_iUnitUpgradeCostMod;

	mov	eax, DWORD PTR [ecx+832]

; 1864 : }

	ret	0
?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnitUpgradeCostMod
_TEXT	ENDS
PUBLIC	?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetBarbarianCombatBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetBarbarianCombatBonus, COMDAT
; _this$ = ecx

; 1869 : 	return m_iBarbarianCombatBonus;

	mov	eax, DWORD PTR [ecx+836]

; 1870 : }

	ret	0
?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetBarbarianCombatBonus
_TEXT	ENDS
PUBLIC	?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAlwaysSeeBarbCamps
; Function compile flags: /Ogtpy
;	COMDAT ?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAlwaysSeeBarbCamps, COMDAT
; _this$ = ecx

; 1875 : 	return m_bAlwaysSeeBarbCamps;

	mov	al, BYTE PTR [ecx+876]

; 1876 : }

	ret	0
?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAlwaysSeeBarbCamps
_TEXT	ENDS
PUBLIC	?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsRevealAllCapitals
; Function compile flags: /Ogtpy
;	COMDAT ?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsRevealAllCapitals, COMDAT
; _this$ = ecx

; 1881 : 	return m_bRevealAllCapitals;

	mov	al, BYTE PTR [ecx+877]

; 1882 : }

	ret	0
?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsRevealAllCapitals
_TEXT	ENDS
PUBLIC	?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsGarrisonFreeMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsGarrisonFreeMaintenance, COMDAT
; _this$ = ecx

; 1887 : 	return m_bGarrisonFreeMaintenance;

	mov	al, BYTE PTR [ecx+878]

; 1888 : }

	ret	0
?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsGarrisonFreeMaintenance
_TEXT	ENDS
PUBLIC	?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsGoldenAgeCultureBonusDisabled
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsGoldenAgeCultureBonusDisabled, COMDAT
; _this$ = ecx

; 1892 : 	return m_bGoldenAgeCultureBonusDisabled;

	mov	al, BYTE PTR [ecx+879]

; 1893 : }

	ret	0
?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsGoldenAgeCultureBonusDisabled
_TEXT	ENDS
PUBLIC	?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsSecondReligionPantheon
; Function compile flags: /Ogtpy
;	COMDAT ?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsSecondReligionPantheon, COMDAT
; _this$ = ecx

; 1897 : 	return m_bSecondReligionPantheon;

	mov	al, BYTE PTR [ecx+880]

; 1898 : }

	ret	0
?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsSecondReligionPantheon
_TEXT	ENDS
PUBLIC	?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAddReformationBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAddReformationBelief, COMDAT
; _this$ = ecx

; 1902 : 	return m_bAddReformationBelief;

	mov	al, BYTE PTR [ecx+881]

; 1903 : }

	ret	0
?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAddReformationBelief
_TEXT	ENDS
PUBLIC	?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsEnablesSSPartHurry
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsEnablesSSPartHurry, COMDAT
; _this$ = ecx

; 1907 : 	return m_bEnablesSSPartHurry;

	mov	al, BYTE PTR [ecx+882]

; 1908 : }

	ret	0
?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsEnablesSSPartHurry
_TEXT	ENDS
PUBLIC	?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsDisablesResistanceTime
; Function compile flags: /Ogtpy
;	COMDAT ?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsDisablesResistanceTime, COMDAT
; _this$ = ecx

; 1913 : 	return m_bDisablesResistanceTime;

	mov	al, BYTE PTR [ecx+883]

; 1914 : }

	ret	0
?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsDisablesResistanceTime
_TEXT	ENDS
PUBLIC	?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsDoubleTrainedMilitaryLandUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsDoubleTrainedMilitaryLandUnit, COMDAT
; _this$ = ecx

; 1920 : 	return m_bDoubleTrainedMilitaryLandUnit;

	mov	al, BYTE PTR [ecx+884]

; 1921 : }

	ret	0
?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsDoubleTrainedMilitaryLandUnit
_TEXT	ENDS
PUBLIC	?IsWarHero@CvPolicyEntry@@QBE_NXZ		; CvPolicyEntry::IsWarHero
; Function compile flags: /Ogtpy
;	COMDAT ?IsWarHero@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsWarHero@CvPolicyEntry@@QBE_NXZ PROC			; CvPolicyEntry::IsWarHero, COMDAT
; _this$ = ecx

; 1927 : 	return m_bWarHero;

	mov	al, BYTE PTR [ecx+885]

; 1928 : }

	ret	0
?IsWarHero@CvPolicyEntry@@QBE_NXZ ENDP			; CvPolicyEntry::IsWarHero
_TEXT	ENDS
PUBLIC	?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsNoMinorDOWIfFriends
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsNoMinorDOWIfFriends, COMDAT
; _this$ = ecx

; 1941 : 	return m_bNoMinorDOWIfFriends;

	mov	al, BYTE PTR [ecx+886]

; 1942 : }

	ret	0
?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsNoMinorDOWIfFriends
_TEXT	ENDS
PUBLIC	?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAllowPuppetPurchasing
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAllowPuppetPurchasing, COMDAT
; _this$ = ecx

; 1948 : 	return m_bAllowPuppetPurchasing;

	mov	al, BYTE PTR [ecx+887]

; 1949 : }

	ret	0
?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAllowPuppetPurchasing
_TEXT	ENDS
PUBLIC	?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsEnablesSSPartPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsEnablesSSPartPurchase, COMDAT
; _this$ = ecx

; 1954 : 	return m_bEnablesSSPartPurchase;

	mov	al, BYTE PTR [ecx+888]

; 1955 : }

	ret	0
?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsEnablesSSPartPurchase
_TEXT	ENDS
PUBLIC	?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAbleToAnnexCityStates
; Function compile flags: /Ogtpy
;	COMDAT ?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAbleToAnnexCityStates, COMDAT
; _this$ = ecx

; 1960 : 	return m_bAbleToAnnexCityStates;

	mov	al, BYTE PTR [ecx+889]

; 1961 : }

	ret	0
?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAbleToAnnexCityStates
_TEXT	ENDS
PUBLIC	?IsOneShot@CvPolicyEntry@@QBE_NXZ		; CvPolicyEntry::IsOneShot
; Function compile flags: /Ogtpy
;	COMDAT ?IsOneShot@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsOneShot@CvPolicyEntry@@QBE_NXZ PROC			; CvPolicyEntry::IsOneShot, COMDAT
; _this$ = ecx

; 1966 : 	return m_bOneShot;

	mov	al, BYTE PTR [ecx+890]

; 1967 : }

	ret	0
?IsOneShot@CvPolicyEntry@@QBE_NXZ ENDP			; CvPolicyEntry::IsOneShot
_TEXT	ENDS
PUBLIC	?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IncludesOneShotFreeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IncludesOneShotFreeUnits, COMDAT
; _this$ = ecx

; 1972 : 	return m_bIncludesOneShotFreeUnits;

	mov	al, BYTE PTR [ecx+891]

; 1973 : }

	ret	0
?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IncludesOneShotFreeUnits
_TEXT	ENDS
PUBLIC	?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ	; CvPolicyEntry::GetWeLoveTheKing
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ
_TEXT	SEGMENT
?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ PROC		; CvPolicyEntry::GetWeLoveTheKing, COMDAT
; _this$ = ecx

; 1978 : 	return m_wstrWeLoveTheKing.c_str();

	add	ecx, 920				; 00000398H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ ENDP		; CvPolicyEntry::GetWeLoveTheKing
_TEXT	ENDS
PUBLIC	?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetPrereqOrPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetPrereqOrPolicies, COMDAT
; _this$ = ecx

; 1992 : 	return m_piPrereqOrPolicies ? m_piPrereqOrPolicies[i] : -1;

	mov	eax, DWORD PTR [ecx+964]
	test	eax, eax
	je	SHORT $LN3@GetPrereqO
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1993 : }

	ret	4
$LN3@GetPrereqO:

; 1992 : 	return m_piPrereqOrPolicies ? m_piPrereqOrPolicies[i] : -1;

	or	eax, -1

; 1993 : }

	ret	4
?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetPrereqOrPolicies
_TEXT	ENDS
PUBLIC	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetPrereqAndPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetPrereqAndPolicies, COMDAT
; _this$ = ecx

; 1998 : 	return m_piPrereqAndPolicies ? m_piPrereqAndPolicies[i] : -1;

	mov	eax, DWORD PTR [ecx+968]
	test	eax, eax
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1999 : }

	ret	4
$LN3@GetPrereqA:

; 1998 : 	return m_piPrereqAndPolicies ? m_piPrereqAndPolicies[i] : -1;

	or	eax, -1

; 1999 : }

	ret	4
?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetPrereqAndPolicies
_TEXT	ENDS
PUBLIC	?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetPolicyDisables
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetPolicyDisables, COMDAT
; _this$ = ecx

; 2004 : 	return m_piPolicyDisables ? m_piPolicyDisables[i] : -1;

	mov	eax, DWORD PTR [ecx+972]
	test	eax, eax
	je	SHORT $LN3@GetPolicyD
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2005 : }

	ret	4
$LN3@GetPolicyD:

; 2004 : 	return m_piPolicyDisables ? m_piPolicyDisables[i] : -1;

	or	eax, -1

; 2005 : }

	ret	4
?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetPolicyDisables
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldModifier@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetYieldModifier, COMDAT
; _this$ = ecx

; 2010 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2011 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2012 : 	return m_piYieldModifier ? m_piYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+976]
	test	eax, eax
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2013 : }

	ret	4
$LN3@GetYieldMo:

; 2010 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2011 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2012 : 	return m_piYieldModifier ? m_piYieldModifier[i] : -1;

	or	eax, -1

; 2013 : }

	ret	4
?GetYieldModifier@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ	; CvPolicyEntry::GetYieldModifierArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ PROC	; CvPolicyEntry::GetYieldModifierArray, COMDAT
; _this$ = ecx

; 2018 : 	return m_piYieldModifier;

	mov	eax, DWORD PTR [ecx+976]

; 2019 : }

	ret	0
?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ ENDP	; CvPolicyEntry::GetYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetCityYieldChange, COMDAT
; _this$ = ecx

; 2024 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2025 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2026 : 	return m_piCityYieldChange ? m_piCityYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+980]
	test	eax, eax
	je	SHORT $LN3@GetCityYie
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2027 : }

	ret	4
$LN3@GetCityYie:

; 2024 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2025 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2026 : 	return m_piCityYieldChange ? m_piCityYieldChange[i] : -1;

	or	eax, -1

; 2027 : }

	ret	4
?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetCityYieldChange
_TEXT	ENDS
PUBLIC	?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCityYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC	; CvPolicyEntry::GetCityYieldChangeArray, COMDAT
; _this$ = ecx

; 2032 : 	return m_piCityYieldChange;

	mov	eax, DWORD PTR [ecx+980]

; 2033 : }

	ret	0
?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP	; CvPolicyEntry::GetCityYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetCoastalCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetCoastalCityYieldChange, COMDAT
; _this$ = ecx

; 2038 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2039 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2040 : 	return m_piCoastalCityYieldChange ? m_piCoastalCityYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+984]
	test	eax, eax
	je	SHORT $LN3@GetCoastal
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2041 : }

	ret	4
$LN3@GetCoastal:

; 2038 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2039 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2040 : 	return m_piCoastalCityYieldChange ? m_piCoastalCityYieldChange[i] : -1;

	or	eax, -1

; 2041 : }

	ret	4
?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetCoastalCityYieldChange
_TEXT	ENDS
PUBLIC	?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCoastalCityYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCoastalCityYieldChangeArray, COMDAT
; _this$ = ecx

; 2046 : 	return m_piCoastalCityYieldChange;

	mov	eax, DWORD PTR [ecx+984]

; 2047 : }

	ret	0
?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCoastalCityYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetCapitalYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetCapitalYieldChange, COMDAT
; _this$ = ecx

; 2052 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2053 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2054 : 	return m_piCapitalYieldChange ? m_piCapitalYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+988]
	test	eax, eax
	je	SHORT $LN3@GetCapital
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2055 : }

	ret	4
$LN3@GetCapital:

; 2052 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2053 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2054 : 	return m_piCapitalYieldChange ? m_piCapitalYieldChange[i] : -1;

	or	eax, -1

; 2055 : }

	ret	4
?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetCapitalYieldChange
_TEXT	ENDS
PUBLIC	?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCapitalYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCapitalYieldChangeArray, COMDAT
; _this$ = ecx

; 2060 : 	return m_piCapitalYieldChange;

	mov	eax, DWORD PTR [ecx+988]

; 2061 : }

	ret	0
?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCapitalYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetCapitalYieldPerPopChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetCapitalYieldPerPopChange, COMDAT
; _this$ = ecx

; 2066 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2067 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2068 : 	return m_piCapitalYieldPerPopChange ? m_piCapitalYieldPerPopChange[i] : -1;

	mov	eax, DWORD PTR [ecx+992]
	test	eax, eax
	je	SHORT $LN3@GetCapital@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2069 : }

	ret	4
$LN3@GetCapital@2:

; 2066 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2067 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2068 : 	return m_piCapitalYieldPerPopChange ? m_piCapitalYieldPerPopChange[i] : -1;

	or	eax, -1

; 2069 : }

	ret	4
?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetCapitalYieldPerPopChange
_TEXT	ENDS
PUBLIC	?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCapitalYieldPerPopChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCapitalYieldPerPopChangeArray, COMDAT
; _this$ = ecx

; 2074 : 	return m_piCapitalYieldPerPopChange;

	mov	eax, DWORD PTR [ecx+992]

; 2075 : }

	ret	0
?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCapitalYieldPerPopChangeArray
_TEXT	ENDS
PUBLIC	?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetCapitalYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetCapitalYieldModifier, COMDAT
; _this$ = ecx

; 2080 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2081 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2082 : 	return m_piCapitalYieldModifier ? m_piCapitalYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+996]
	test	eax, eax
	je	SHORT $LN3@GetCapital@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2083 : }

	ret	4
$LN3@GetCapital@3:

; 2080 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2081 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2082 : 	return m_piCapitalYieldModifier ? m_piCapitalYieldModifier[i] : -1;

	or	eax, -1

; 2083 : }

	ret	4
?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetCapitalYieldModifier
_TEXT	ENDS
PUBLIC	?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCapitalYieldModifierArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCapitalYieldModifierArray, COMDAT
; _this$ = ecx

; 2088 : 	return m_piCapitalYieldModifier;

	mov	eax, DWORD PTR [ecx+996]

; 2089 : }

	ret	0
?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCapitalYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetGreatWorkYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetGreatWorkYieldChange, COMDAT
; _this$ = ecx

; 2094 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2095 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2096 : 	return m_piGreatWorkYieldChange ? m_piGreatWorkYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+1000]
	test	eax, eax
	je	SHORT $LN3@GetGreatWo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2097 : }

	ret	4
$LN3@GetGreatWo:

; 2094 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2095 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2096 : 	return m_piGreatWorkYieldChange ? m_piGreatWorkYieldChange[i] : -1;

	or	eax, -1

; 2097 : }

	ret	4
?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetGreatWorkYieldChange
_TEXT	ENDS
PUBLIC	?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetGreatWorkYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetGreatWorkYieldChangeArray, COMDAT
; _this$ = ecx

; 2102 : 	return m_piGreatWorkYieldChange;

	mov	eax, DWORD PTR [ecx+1000]

; 2103 : }

	ret	0
?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetGreatWorkYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetSpecialistExtraYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetSpecialistExtraYield, COMDAT
; _this$ = ecx

; 2108 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2109 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2110 : 	return m_piSpecialistExtraYield ? m_piSpecialistExtraYield[i] : -1;

	mov	eax, DWORD PTR [ecx+1004]
	test	eax, eax
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2111 : }

	ret	4
$LN3@GetSpecial:

; 2108 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2109 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2110 : 	return m_piSpecialistExtraYield ? m_piSpecialistExtraYield[i] : -1;

	or	eax, -1

; 2111 : }

	ret	4
?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetSpecialistExtraYield
_TEXT	ENDS
PUBLIC	?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetSpecialistExtraYieldArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetSpecialistExtraYieldArray, COMDAT
; _this$ = ecx

; 2116 : 	return m_piSpecialistExtraYield;

	mov	eax, DWORD PTR [ecx+1004]

; 2117 : }

	ret	0
?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetSpecialistExtraYieldArray
_TEXT	ENDS
PUBLIC	?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetUnitCombatProductionModifiers
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetUnitCombatProductionModifiers, COMDAT
; _this$ = ecx

; 2122 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 2123 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2124 : 	return m_paiUnitCombatProductionModifiers ? m_paiUnitCombatProductionModifiers[i] : -1;

	mov	eax, DWORD PTR [ecx+1016]
	test	eax, eax
	je	SHORT $LN3@GetUnitCom
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2125 : }

	ret	4
$LN3@GetUnitCom:

; 2122 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 2123 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2124 : 	return m_paiUnitCombatProductionModifiers ? m_paiUnitCombatProductionModifiers[i] : -1;

	or	eax, -1

; 2125 : }

	ret	4
?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetUnitCombatProductionModifiers
_TEXT	ENDS
PUBLIC	?IsFreePromotion@CvPolicyEntry@@QBEHH@Z		; CvPolicyEntry::IsFreePromotion
; Function compile flags: /Ogtpy
;	COMDAT ?IsFreePromotion@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsFreePromotion@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::IsFreePromotion, COMDAT
; _this$ = ecx

; 2129 : 	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;

	mov	eax, DWORD PTR [ecx+1012]
	test	eax, eax
	je	SHORT $LN3@IsFreeProm
	mov	ecx, DWORD PTR _i$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx]

; 2130 : }

	ret	4
$LN3@IsFreeProm:

; 2129 : 	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;

	or	eax, -1

; 2130 : }

	ret	4
?IsFreePromotion@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::IsFreePromotion
_TEXT	ENDS
PUBLIC	?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetUnitCombatFreeExperiences
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetUnitCombatFreeExperiences, COMDAT
; _this$ = ecx

; 2157 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 2158 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2159 : 	return m_paiUnitCombatFreeExperiences ? m_paiUnitCombatFreeExperiences[i] : -1;

	mov	eax, DWORD PTR [ecx+1020]
	test	eax, eax
	je	SHORT $LN3@GetUnitCom@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2160 : }

	ret	4
$LN3@GetUnitCom@2:

; 2157 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 2158 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2159 : 	return m_paiUnitCombatFreeExperiences ? m_paiUnitCombatFreeExperiences[i] : -1;

	or	eax, -1

; 2160 : }

	ret	4
?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetUnitCombatFreeExperiences
_TEXT	ENDS
PUBLIC	?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassCultureChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetBuildingClassCultureChange, COMDAT
; _this$ = ecx

; 2165 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2166 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2167 : 	return m_paiBuildingClassCultureChanges ? m_paiBuildingClassCultureChanges[i] : -1;

	mov	eax, DWORD PTR [ecx+1028]
	test	eax, eax
	je	SHORT $LN3@GetBuildin
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2168 : }

	ret	4
$LN3@GetBuildin:

; 2165 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2166 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2167 : 	return m_paiBuildingClassCultureChanges ? m_paiBuildingClassCultureChanges[i] : -1;

	or	eax, -1

; 2168 : }

	ret	4
?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetBuildingClassCultureChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetBuildingClassHappiness, COMDAT
; _this$ = ecx

; 2173 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2174 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2175 : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	mov	eax, DWORD PTR [ecx+1040]
	test	eax, eax
	je	SHORT $LN3@GetBuildin@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2176 : }

	ret	4
$LN3@GetBuildin@2:

; 2173 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2174 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2175 : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	or	eax, -1

; 2176 : }

	ret	4
?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetBuildingClassHappiness
_TEXT	ENDS
PUBLIC	?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetNumFreeUnitsByClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetNumFreeUnitsByClass, COMDAT
; _this$ = ecx

; 2181 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2182 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2183 : 	return m_paiFreeUnitClasses ? m_paiFreeUnitClasses[i] : -1;

	mov	eax, DWORD PTR [ecx+1044]
	test	eax, eax
	je	SHORT $LN3@GetNumFree
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2184 : }

	ret	4
$LN3@GetNumFree:

; 2181 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2182 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2183 : 	return m_paiFreeUnitClasses ? m_paiFreeUnitClasses[i] : -1;

	or	eax, -1

; 2184 : }

	ret	4
?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetNumFreeUnitsByClass
_TEXT	ENDS
PUBLIC	?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetTourismByUnitClassCreated
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetTourismByUnitClassCreated, COMDAT
; _this$ = ecx

; 2189 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2190 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2191 : 	return m_paiTourismOnUnitCreation ? m_paiTourismOnUnitCreation[i] : -1;

	mov	eax, DWORD PTR [ecx+1048]
	test	eax, eax
	je	SHORT $LN3@GetTourism
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2192 : }

	ret	4
$LN3@GetTourism:

; 2189 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2190 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2191 : 	return m_paiTourismOnUnitCreation ? m_paiTourismOnUnitCreation[i] : -1;

	or	eax, -1

; 2192 : }

	ret	4
?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetTourismByUnitClassCreated
_TEXT	ENDS
PUBLIC	?GetHurryModifier@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetHurryModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetHurryModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetHurryModifier@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetHurryModifier, COMDAT
; _this$ = ecx

; 2205 : 	CvAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
; 2206 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2207 : 	return m_paiHurryModifier ? m_paiHurryModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+1024]
	test	eax, eax
	je	SHORT $LN3@GetHurryMo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2208 : }

	ret	4
$LN3@GetHurryMo:

; 2205 : 	CvAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
; 2206 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2207 : 	return m_paiHurryModifier ? m_paiHurryModifier[i] : -1;

	or	eax, -1

; 2208 : }

	ret	4
?GetHurryModifier@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetHurryModifier
_TEXT	ENDS
PUBLIC	?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z	; CvPolicyEntry::IsSpecialistValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z PROC		; CvPolicyEntry::IsSpecialistValid, COMDAT
; _this$ = ecx

; 2213 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2214 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2215 : 	return m_pabSpecialistValid ? m_pabSpecialistValid[i] : false;

	mov	eax, DWORD PTR [ecx+1052]
	test	eax, eax
	je	SHORT $LN3@IsSpeciali
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 2216 : }

	ret	4
$LN3@IsSpeciali:

; 2213 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2214 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2215 : 	return m_pabSpecialistValid ? m_pabSpecialistValid[i] : false;

	xor	al, al

; 2216 : }

	ret	4
?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z ENDP		; CvPolicyEntry::IsSpecialistValid
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetImprovementYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z PROC ; CvPolicyEntry::GetImprovementYieldChanges, COMDAT
; _this$ = ecx

; 2221 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2222 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2223 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2224 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2225 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2226 : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[i][j] : 0;
; 2227 : #else
; 2228 : 	return m_ppiImprovementYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+1056]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2229 : #endif
; 2230 : }

	ret	8
?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z ENDP ; CvPolicyEntry::GetImprovementYieldChanges
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetBuildingClassYieldModifiers
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z PROC ; CvPolicyEntry::GetBuildingClassYieldModifiers, COMDAT
; _this$ = ecx

; 2235 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2236 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2237 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2238 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2239 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2240 : 	return m_ppiBuildingClassYieldModifiers.first ? m_ppiBuildingClassYieldModifiers.first[i][j] : 0;
; 2241 : #else
; 2242 : 	return m_ppiBuildingClassYieldModifiers[i][j];

	mov	eax, DWORD PTR [ecx+1060]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2243 : #endif
; 2244 : }

	ret	8
?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z ENDP ; CvPolicyEntry::GetBuildingClassYieldModifiers
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetBuildingClassYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z PROC ; CvPolicyEntry::GetBuildingClassYieldChanges, COMDAT
; _this$ = ecx

; 2249 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2250 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2251 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2252 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2253 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2254 : 	return m_ppiBuildingClassYieldChanges.first ? m_ppiBuildingClassYieldChanges.first[i][j] : 0;
; 2255 : #else
; 2256 : 	return m_ppiBuildingClassYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+1064]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 2257 : #endif
; 2258 : }

	ret	8
?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z ENDP ; CvPolicyEntry::GetBuildingClassYieldChanges
_TEXT	ENDS
PUBLIC	?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetBuildingClassProductionModifier, COMDAT
; _this$ = ecx

; 2274 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2275 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2276 : 	return m_paiBuildingClassProductionModifiers[i];

	mov	eax, DWORD PTR [ecx+1032]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2277 : }

	ret	4
?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetBuildingClassProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetBuildingClassTourismModifier, COMDAT
; _this$ = ecx

; 2282 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2283 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2284 : 	return m_paiBuildingClassTourismModifiers[i];

	mov	eax, DWORD PTR [ecx+1036]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2285 : }

	ret	4
?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetBuildingClassTourismModifier
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z		; CvPolicyEntry::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 2290 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 2291 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2292 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR [ecx+1068]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2293 : }

	ret	4
$LN3@GetFlavorV:

; 2290 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 2291 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2292 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	xor	eax, eax

; 2293 : }

	ret	4
?GetFlavorValue@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetImprovementCultureChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetImprovementCultureChanges, COMDAT
; _this$ = ecx

; 2298 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2299 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2300 : 	return m_piImprovementCultureChange[i];

	mov	eax, DWORD PTR [ecx+1008]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2301 : }

	ret	4
?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetImprovementCultureChanges
_TEXT	ENDS
PUBLIC	?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ ; CvPolicyEntry::GetFreeBuildingOnConquest
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvPolicyEntry::GetFreeBuildingOnConquest, COMDAT
; _this$ = ecx

; 2306 : 	return m_eFreeBuildingOnConquest;

	mov	eax, DWORD PTR [ecx+948]

; 2307 : }

	ret	0
?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPolicyEntry::GetFreeBuildingOnConquest
_TEXT	ENDS
PUBLIC	?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ	; CvPolicyBranchEntry::GetEraPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ PROC		; CvPolicyBranchEntry::GetEraPrereq, COMDAT
; _this$ = ecx

; 2390 : 	return m_iEraPrereq;

	mov	eax, DWORD PTR [ecx+260]

; 2391 : }

	ret	0
?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ ENDP		; CvPolicyBranchEntry::GetEraPrereq
_TEXT	ENDS
PUBLIC	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ	; CvPolicyBranchEntry::GetFreePolicy
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ PROC		; CvPolicyBranchEntry::GetFreePolicy, COMDAT
; _this$ = ecx

; 2396 : 	return m_iFreePolicy;

	mov	eax, DWORD PTR [ecx+264]

; 2397 : }

	ret	0
?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ENDP		; CvPolicyBranchEntry::GetFreePolicy
_TEXT	ENDS
PUBLIC	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreeFinishingPolicy
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ PROC ; CvPolicyBranchEntry::GetFreeFinishingPolicy, COMDAT
; _this$ = ecx

; 2402 : 	return m_iFreeFinishingPolicy;

	mov	eax, DWORD PTR [ecx+268]

; 2403 : }

	ret	0
?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ENDP ; CvPolicyBranchEntry::GetFreeFinishingPolicy
_TEXT	ENDS
PUBLIC	?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ PROC ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies, COMDAT
; _this$ = ecx

; 2408 : 	return m_iFirstAdopterFreePolicies;

	mov	eax, DWORD PTR [ecx+272]

; 2409 : }

	ret	0
?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ENDP ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies
_TEXT	ENDS
PUBLIC	?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ PROC ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies, COMDAT
; _this$ = ecx

; 2414 : 	return m_iSecondAdopterFreePolicies;

	mov	eax, DWORD PTR [ecx+276]

; 2415 : }

	ret	0
?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ENDP ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies
_TEXT	ENDS
PUBLIC	?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ; CvPolicyBranchEntry::GetPolicyBranchDisables
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z PROC ; CvPolicyBranchEntry::GetPolicyBranchDisables, COMDAT
; _this$ = ecx

; 2420 : 	return m_piPolicyBranchDisables ? m_piPolicyBranchDisables[i] : -1;

	mov	eax, DWORD PTR [ecx+288]
	test	eax, eax
	je	SHORT $LN3@GetPolicyB
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2421 : }

	ret	4
$LN3@GetPolicyB:

; 2420 : 	return m_piPolicyBranchDisables ? m_piPolicyBranchDisables[i] : -1;

	or	eax, -1

; 2421 : }

	ret	4
?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ENDP ; CvPolicyBranchEntry::GetPolicyBranchDisables
_TEXT	ENDS
PUBLIC	?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ	; CvPolicyBranchEntry::IsPurchaseByLevel
; Function compile flags: /Ogtpy
;	COMDAT ?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsPurchaseByLevel, COMDAT
; _this$ = ecx

; 2426 : 	return m_bPurchaseByLevel;

	mov	al, BYTE PTR [ecx+280]

; 2427 : }

	ret	0
?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsPurchaseByLevel
_TEXT	ENDS
PUBLIC	?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsLockedWithoutReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ PROC ; CvPolicyBranchEntry::IsLockedWithoutReligion, COMDAT
; _this$ = ecx

; 2432 : 	return m_bLockedWithoutReligion;

	mov	al, BYTE PTR [ecx+281]

; 2433 : }

	ret	0
?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ ENDP ; CvPolicyBranchEntry::IsLockedWithoutReligion
_TEXT	ENDS
PUBLIC	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsMutuallyExclusive
; Function compile flags: /Ogtpy
;	COMDAT ?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsMutuallyExclusive, COMDAT
; _this$ = ecx

; 2438 : 	return m_bMutuallyExclusive;

	mov	al, BYTE PTR [ecx+282]

; 2439 : }

	ret	0
?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsMutuallyExclusive
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ PROC ; CvPolicyBranchEntry::IsDelayWhenNoReligion, COMDAT
; _this$ = ecx

; 2444 : 	return m_bDelayWhenNoReligion;

	mov	al, BYTE PTR [ecx+283]

; 2445 : }

	ret	0
?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ ENDP ; CvPolicyBranchEntry::IsDelayWhenNoReligion
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCulture
; Function compile flags: /Ogtpy
;	COMDAT ?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsDelayWhenNoCulture, COMDAT
; _this$ = ecx

; 2450 : 	return m_bDelayWhenNoCulture;

	mov	al, BYTE PTR [ecx+284]

; 2451 : }

	ret	0
?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsDelayWhenNoCulture
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
; Function compile flags: /Ogtpy
;	COMDAT ?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ PROC ; CvPolicyBranchEntry::IsDelayWhenNoCityStates, COMDAT
; _this$ = ecx

; 2456 : 	return m_bDelayWhenNoCityStates;

	mov	al, BYTE PTR [ecx+285]

; 2457 : }

	ret	0
?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ ENDP ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoScience
; Function compile flags: /Ogtpy
;	COMDAT ?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsDelayWhenNoScience, COMDAT
; _this$ = ecx

; 2462 : 	return m_bDelayWhenNoScience;

	mov	al, BYTE PTR [ecx+286]

; 2463 : }

	ret	0
?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsDelayWhenNoScience
_TEXT	ENDS
PUBLIC	?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ PROC ; CvPolicyXMLEntries::GetPolicyEntries, COMDAT
; _this$ = ecx

; 2483 : {

	mov	eax, ecx

; 2484 : 	return m_paPolicyEntries;
; 2485 : }

	ret	0
?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ENDP ; CvPolicyXMLEntries::GetPolicyEntries
_TEXT	ENDS
PUBLIC	?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyBranchEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ PROC ; CvPolicyXMLEntries::GetPolicyBranchEntries, COMDAT
; _this$ = ecx

; 2521 : 	return m_paPolicyBranchEntries;

	lea	eax, DWORD PTR [ecx+16]

; 2522 : }

	ret	0
?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ENDP ; CvPolicyXMLEntries::GetPolicyBranchEntries
_TEXT	ENDS
PUBLIC	??_7CvPlayerPolicies@@6B@			; CvPlayerPolicies::`vftable'
PUBLIC	??0CvPlayerPolicies@@QAE@XZ			; CvPlayerPolicies::CvPlayerPolicies
PUBLIC	??_R4CvPlayerPolicies@@6B@			; CvPlayerPolicies::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPlayerPolicies@@@8			; CvPlayerPolicies `RTTI Type Descriptor'
PUBLIC	??_R3CvPlayerPolicies@@8			; CvPlayerPolicies::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPlayerPolicies@@8			; CvPlayerPolicies::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPlayerPolicies@@8		; CvPlayerPolicies::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvFlavorRecipient@@8		; CvFlavorRecipient::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvFlavorRecipient@@@8			; CvFlavorRecipient `RTTI Type Descriptor'
PUBLIC	??_R3CvFlavorRecipient@@8			; CvFlavorRecipient::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvFlavorRecipient@@8			; CvFlavorRecipient::`RTTI Base Class Array'
PUBLIC	?Uninit@CvPlayerPolicies@@UAEXXZ		; CvPlayerPolicies::Uninit
PUBLIC	?FlavorUpdate@CvPlayerPolicies@@UAEXXZ		; CvPlayerPolicies::FlavorUpdate
PUBLIC	?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z ; CvPlayerPolicies::LogFlavors
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
;	COMDAT ??_R2CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R2CvFlavorRecipient@@8 DD FLAT:??_R1A@?0A@EA@CvFlavorRecipient@@8 ; CvFlavorRecipient::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R3CvFlavorRecipient@@8 DD 00H			; CvFlavorRecipient::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvFlavorRecipient@@@8
_DATA	SEGMENT
??_R0?AVCvFlavorRecipient@@@8 DD FLAT:??_7type_info@@6B@ ; CvFlavorRecipient `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvFlavorRecipient@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvFlavorRecipient@@8 DD FLAT:??_R0?AVCvFlavorRecipient@@@8 ; CvFlavorRecipient::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvPlayerPolicies@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPlayerPolicies@@8 DD FLAT:??_R0?AVCvPlayerPolicies@@@8 ; CvPlayerPolicies::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPlayerPolicies@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPlayerPolicies@@8
rdata$r	SEGMENT
??_R2CvPlayerPolicies@@8 DD FLAT:??_R1A@?0A@EA@CvPlayerPolicies@@8 ; CvPlayerPolicies::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPlayerPolicies@@8
rdata$r	SEGMENT
??_R3CvPlayerPolicies@@8 DD 00H				; CvPlayerPolicies::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPlayerPolicies@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPlayerPolicies@@@8
_DATA	SEGMENT
??_R0?AVCvPlayerPolicies@@@8 DD FLAT:??_7type_info@@6B@	; CvPlayerPolicies `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPlayerPolicies@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPlayerPolicies@@6B@
rdata$r	SEGMENT
??_R4CvPlayerPolicies@@6B@ DD 00H			; CvPlayerPolicies::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPlayerPolicies@@@8
	DD	FLAT:??_R3CvPlayerPolicies@@8
rdata$r	ENDS
;	COMDAT ??_7CvPlayerPolicies@@6B@
CONST	SEGMENT
??_7CvPlayerPolicies@@6B@ DD FLAT:??_R4CvPlayerPolicies@@6B@ ; CvPlayerPolicies::`vftable'
	DD	FLAT:?Init@CvFlavorRecipient@@UAEXXZ
	DD	FLAT:?Uninit@CvPlayerPolicies@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvPlayerPolicies@@UAEXXZ
	DD	FLAT:?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvPlayerPolicies@@QAE@XZ
_TEXT	SEGMENT
??0CvPlayerPolicies@@QAE@XZ PROC			; CvPlayerPolicies::CvPlayerPolicies, COMDAT
; _this$ = ecx

; 2579 : {

	push	esi
	mov	esi, ecx
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvPlayerPolicies@@6B@

; 2580 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvPlayerPolicies@@QAE@XZ ENDP			; CvPlayerPolicies::CvPlayerPolicies
_TEXT	ENDS
PUBLIC	??1CvPlayerPolicies@@QAE@XZ			; CvPlayerPolicies::~CvPlayerPolicies
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
; Function compile flags: /Ogtpy
;	COMDAT ??1CvPlayerPolicies@@QAE@XZ
_TEXT	SEGMENT
??1CvPlayerPolicies@@QAE@XZ PROC			; CvPlayerPolicies::~CvPlayerPolicies, COMDAT
; _this$ = ecx

; 2584 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvPlayerPolicies@@6B@

; 2585 : }

	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
??1CvPlayerPolicies@@QAE@XZ ENDP			; CvPlayerPolicies::~CvPlayerPolicies
_TEXT	ENDS
PUBLIC	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ	; CvPlayerPolicies::GetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ PROC	; CvPlayerPolicies::GetPlayer, COMDAT
; _this$ = ecx

; 2820 : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx+60]

; 2821 : }

	ret	0
?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ENDP	; CvPlayerPolicies::GetPlayer
_TEXT	ENDS
PUBLIC	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
; Function compile flags: /Ogtpy
;	COMDAT ?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::HasPolicy, COMDAT
; _this$ = ecx

; 2826 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2827 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2828 : 	return m_pabHasPolicy[eIndex];

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 2829 : }

	ret	4
?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::HasPolicy
_TEXT	ENDS
PUBLIC	?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasOneShotPolicyFired
; Function compile flags: /Ogtpy
;	COMDAT ?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::HasOneShotPolicyFired, COMDAT
; _this$ = ecx

; 2922 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2923 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2924 : 	return m_pabHasOneShotPolicyFired[eIndex];

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 2925 : }

	ret	4
?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::HasOneShotPolicyFired
_TEXT	ENDS
PUBLIC	?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ; CvPlayerPolicies::SetOneShotPolicyFired
; Function compile flags: /Ogtpy
;	COMDAT ?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bFired$ = 12						; size = 1
?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::SetOneShotPolicyFired, COMDAT
; _this$ = ecx

; 2930 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2931 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2932 : 	m_pabHasOneShotPolicyFired[eIndex] = bFired;

	mov	eax, DWORD PTR [ecx+16]
	mov	cl, BYTE PTR _bFired$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	BYTE PTR [edx+eax], cl

; 2933 : }

	ret	8
?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::SetOneShotPolicyFired
_TEXT	ENDS
PUBLIC	?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HaveOneShotFreeUnitsFired
; Function compile flags: /Ogtpy
;	COMDAT ?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::HaveOneShotFreeUnitsFired, COMDAT
; _this$ = ecx

; 2937 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2938 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2939 : 	return m_pabHaveOneShotFreeUnitsFired[eIndex];

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 2940 : }

	ret	4
?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::HaveOneShotFreeUnitsFired
_TEXT	ENDS
PUBLIC	?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ; CvPlayerPolicies::SetOneShotFreeUnitsFired
; Function compile flags: /Ogtpy
;	COMDAT ?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bFired$ = 12						; size = 1
?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::SetOneShotFreeUnitsFired, COMDAT
; _this$ = ecx

; 2945 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2946 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2947 : 	m_pabHaveOneShotFreeUnitsFired[eIndex] = bFired;

	mov	eax, DWORD PTR [ecx+20]
	mov	cl, BYTE PTR _bFired$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	BYTE PTR [edx+eax], cl

; 2948 : }

	ret	8
?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::SetOneShotFreeUnitsFired
_TEXT	ENDS
PUBLIC	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ
_TEXT	SEGMENT
?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ PROC ; CvPlayerPolicies::GetPolicies, COMDAT
; _this$ = ecx

; 2995 : 	return m_pPolicies;

	mov	eax, DWORD PTR [ecx+52]

; 2996 : }

	ret	0
?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ENDP ; CvPlayerPolicies::GetPolicies
_TEXT	ENDS
PUBLIC	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
; Function compile flags: /Ogtpy
;	COMDAT ?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranchType$ = 8					; size = 4
?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked, COMDAT
; _this$ = ecx

; 3889 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3890 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 3891 : 	return m_pabPolicyBranchUnlocked[eBranchType];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _eBranchType$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 3892 : }

	ret	4
?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBranchUnlocked
_TEXT	ENDS
PUBLIC	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
; Function compile flags: /Ogtpy
;	COMDAT ?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranchType$ = 8					; size = 4
?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBranchBlocked, COMDAT
; _this$ = ecx

; 4157 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4158 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4159 : 	return m_pabPolicyBranchBlocked[eBranchType];

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _eBranchType$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 4160 : }

	ret	4
?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBranchBlocked
_TEXT	ENDS
PUBLIC	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
; Function compile flags: /Ogtpy
;	COMDAT ?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBlocked, COMDAT
; _this$ = ecx

; 4165 : 	CvAssertMsg(eType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4166 : 	CvAssertMsg(eType < m_pPolicies->GetNumPolicies(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4167 : 
; 4168 : 	// Get the policy branch we have to check.
; 4169 : 	PolicyBranchTypes eBranch = m_paePolicyBlockedBranchCheck[eType];

	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _eType$[esp-4]
	mov	eax, DWORD PTR [eax+edx*4]

; 4170 : 	if (eBranch == NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	jne	SHORT $LN1@IsPolicyBl

; 4171 : 		return false;	// Policy has no branch

	xor	al, al

; 4174 : }

	ret	4
$LN1@IsPolicyBl:

; 4172 : 
; 4173 : 	return IsPolicyBranchBlocked(eBranch);

	mov	ecx, DWORD PTR [ecx+28]
	mov	al, BYTE PTR [eax+ecx]

; 4174 : }

	ret	4
?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBlocked
_TEXT	ENDS
PUBLIC	?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchFinished
; Function compile flags: /Ogtpy
;	COMDAT ?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranchType$ = 8					; size = 4
?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBranchFinished, COMDAT
; _this$ = ecx

; 4313 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4314 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4315 : 	return m_pabPolicyBranchFinished[eBranchType];

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _eBranchType$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 4316 : }

	ret	4
?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBranchFinished
_TEXT	ENDS
PUBLIC	?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ	; CvPlayerPolicies::GetNumExtraBranches
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ PROC	; CvPlayerPolicies::GetNumExtraBranches, COMDAT
; _this$ = ecx

; 4399 : 	return m_iNumExtraBranches;

	mov	eax, DWORD PTR [ecx+64]

; 4400 : }

	ret	0
?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ ENDP	; CvPlayerPolicies::GetNumExtraBranches
_TEXT	ENDS
PUBLIC	?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z ; CvPlayerPolicies::ChangeNumExtraBranches
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z PROC	; CvPlayerPolicies::ChangeNumExtraBranches, COMDAT
; _this$ = ecx

; 4405 : 	m_iNumExtraBranches += iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+64], eax

; 4406 : }

	ret	4
?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z ENDP	; CvPlayerPolicies::ChangeNumExtraBranches
_TEXT	ENDS
PUBLIC	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
; Function compile flags: /Ogtpy
;	COMDAT ?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetBranchPicked1, COMDAT
; _this$ = ecx

; 4604 : 	return m_eBranchPicked1;

	mov	eax, DWORD PTR [ecx+68]

; 4605 : }

	ret	0
?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetBranchPicked1
_TEXT	ENDS
PUBLIC	?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked1
; Function compile flags: /Ogtpy
;	COMDAT ?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetBranchPicked1, COMDAT
; _this$ = ecx

; 4610 : 	m_eBranchPicked1 = eBranch;

	mov	eax, DWORD PTR _eBranch$[esp-4]
	mov	DWORD PTR [ecx+68], eax

; 4611 : }

	ret	4
?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetBranchPicked1
_TEXT	ENDS
PUBLIC	?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked2
; Function compile flags: /Ogtpy
;	COMDAT ?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetBranchPicked2, COMDAT
; _this$ = ecx

; 4616 : 	return m_eBranchPicked2;

	mov	eax, DWORD PTR [ecx+72]

; 4617 : }

	ret	0
?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetBranchPicked2
_TEXT	ENDS
PUBLIC	?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked2
; Function compile flags: /Ogtpy
;	COMDAT ?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetBranchPicked2, COMDAT
; _this$ = ecx

; 4622 : 	m_eBranchPicked2 = eBranch;

	mov	eax, DWORD PTR _eBranch$[esp-4]
	mov	DWORD PTR [ecx+72], eax

; 4623 : }

	ret	4
?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetBranchPicked2
_TEXT	ENDS
PUBLIC	?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked3
; Function compile flags: /Ogtpy
;	COMDAT ?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetBranchPicked3, COMDAT
; _this$ = ecx

; 4628 : 	return m_eBranchPicked3;

	mov	eax, DWORD PTR [ecx+76]

; 4629 : }

	ret	0
?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetBranchPicked3
_TEXT	ENDS
PUBLIC	?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked3
; Function compile flags: /Ogtpy
;	COMDAT ?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetBranchPicked3, COMDAT
; _this$ = ecx

; 4634 : 	m_eBranchPicked3 = eBranch;

	mov	eax, DWORD PTR _eBranch$[esp-4]
	mov	DWORD PTR [ecx+76], eax

; 4635 : }

	ret	4
?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetBranchPicked3
_TEXT	ENDS
PUBLIC	?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ	; CvPlayerPolicies::DoChooseIdeology
EXTRN	?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z:PROC ; CvPolicyAI::DoChooseIdeology
; Function compile flags: /Ogtpy
;	COMDAT ?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ
_TEXT	SEGMENT
?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ PROC		; CvPlayerPolicies::DoChooseIdeology, COMDAT
; _this$ = ecx

; 4873 : 	m_pPolicyAI->DoChooseIdeology(m_pPlayer);

	mov	eax, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [ecx+56]
	push	eax
	call	?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoChooseIdeology

; 4874 : }

	ret	0
?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ ENDP		; CvPlayerPolicies::DoChooseIdeology
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z PROC ; CvPlayerPolicies::LogFlavors, COMDAT
; _this$ = ecx

; 4934 : 	return; // Now using personality flavors, so this is unnecessary (or is it?)
; 4935 : }

	ret	4
?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z ENDP ; CvPlayerPolicies::LogFlavors
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$pair@HH@std@@QAE@ABH0@Z			; std::pair<int,int>::pair<int,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@HH@std@@QAE@ABH0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@HH@std@@QAE@ABH0@Z PROC			; std::pair<int,int>::pair<int,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@HH@std@@QAE@ABH0@Z ENDP			; std::pair<int,int>::pair<int,int>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\functional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 144  : 		}

	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::key_comp
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::key_comp
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@XZ	; std::allocator<CvPolicyEntry *>::allocator<CvPolicyEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@XZ PROC	; std::allocator<CvPolicyEntry *>::allocator<CvPolicyEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvPolicyEntry *>::allocator<CvPolicyEntry *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@XZ ; std::allocator<CvPolicyBranchEntry *>::allocator<CvPolicyBranchEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@XZ PROC ; std::allocator<CvPolicyBranchEntry *>::allocator<CvPolicyBranchEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvPolicyBranchEntry *>::allocator<CvPolicyBranchEntry *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231738 = -80						; size = 28
$T231737 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231738[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231737[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231738[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231737[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231737[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231737[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231737[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231738[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231737[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ PROC	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4BuildingTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4BuildingTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum BuildingTypes>::allocator<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z ; std::allocator<enum BuildingTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z PROC ; std::allocator<enum BuildingTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@I@Z ENDP ; std::allocator<enum BuildingTypes>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEABQAVCvPolicyEntry@@XZ ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEABQAVCvPolicyEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEABQAVCvPolicyEntry@@XZ PROC ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEABQAVCvPolicyEntry@@XZ ENDP ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEABQAVCvPolicyBranchEntry@@XZ ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEABQAVCvPolicyBranchEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEABQAVCvPolicyBranchEntry@@XZ PROC ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEABQAVCvPolicyBranchEntry@@XZ ENDP ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::size
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231811 = -80						; size = 28
$T231810 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231811[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231810[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231811[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231810[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231810[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231810[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231810[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231811[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231810[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4PolicyTypes@@@std@@QAE@XZ	; std::allocator<enum PolicyTypes>::allocator<enum PolicyTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@W4PolicyTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4PolicyTypes@@@std@@QAE@XZ PROC		; std::allocator<enum PolicyTypes>::allocator<enum PolicyTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4PolicyTypes@@@std@@QAE@XZ ENDP		; std::allocator<enum PolicyTypes>::allocator<enum PolicyTypes>
_TEXT	ENDS
PUBLIC	??0?$allocator@W4PolicyTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum PolicyTypes>::allocator<enum PolicyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@W4PolicyTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4PolicyTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum PolicyTypes>::allocator<enum PolicyTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4PolicyTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum PolicyTypes>::allocator<enum PolicyTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@I@Z ; std::allocator<enum PolicyTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@I@Z PROC ; std::allocator<enum PolicyTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@I@Z ENDP ; std::allocator<enum PolicyTypes>::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Isnil
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Kfn
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231905 = -80						; size = 28
$T231904 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231905[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231904[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231905[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231904[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231904[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231904[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231904[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231905[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231904[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvPolicyEntry *>::allocator<CvPolicyEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPolicyEntry *>::allocator<CvPolicyEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPolicyEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPolicyEntry *>::allocator<CvPolicyEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEXPAPAVCvPolicyEntry@@I@Z ; std::allocator<CvPolicyEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEXPAPAVCvPolicyEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEXPAPAVCvPolicyEntry@@I@Z PROC ; std::allocator<CvPolicyEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEXPAPAVCvPolicyEntry@@I@Z ENDP ; std::allocator<CvPolicyEntry *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231939 = -80						; size = 28
$T231938 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231939[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231938[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231939[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231938[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231938[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231938[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231938[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231939[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231938[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvPolicyBranchEntry *>::allocator<CvPolicyBranchEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPolicyBranchEntry *>::allocator<CvPolicyBranchEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPolicyBranchEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPolicyBranchEntry *>::allocator<CvPolicyBranchEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEXPAPAVCvPolicyBranchEntry@@I@Z ; std::allocator<CvPolicyBranchEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEXPAPAVCvPolicyBranchEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEXPAPAVCvPolicyBranchEntry@@I@Z PROC ; std::allocator<CvPolicyBranchEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEXPAPAVCvPolicyBranchEntry@@I@Z ENDP ; std::allocator<CvPolicyBranchEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ ; std::allocator<enum BuildingTypes>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ PROC ; std::allocator<enum BuildingTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4BuildingTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum BuildingTypes>::max_size
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::iterator
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z PROC ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z ENDP ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z PROC ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z ENDP ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4PolicyTypes@@@std@@QBEIXZ ; std::allocator<enum PolicyTypes>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@W4PolicyTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4PolicyTypes@@@std@@QBEIXZ PROC	; std::allocator<enum PolicyTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4PolicyTypes@@@std@@QBEIXZ ENDP	; std::allocator<enum PolicyTypes>::max_size
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z PROC ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@PAW4BuildingTypes@@@Z ENDP ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z PROC ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@PAW4PolicyTypes@@@Z ENDP ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Color
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Color
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Make_iter
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?max_size@?$allocator@PAVCvPolicyEntry@@@std@@QBEIXZ ; std::allocator<CvPolicyEntry *>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvPolicyEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPolicyEntry@@@std@@QBEIXZ PROC ; std::allocator<CvPolicyEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPolicyEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvPolicyEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPolicyBranchEntry@@@std@@QBEIXZ ; std::allocator<CvPolicyBranchEntry *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvPolicyBranchEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPolicyBranchEntry@@@std@@QBEIXZ PROC ; std::allocator<CvPolicyBranchEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPolicyBranchEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvPolicyBranchEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,int> >::max_size
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node::_Node
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z ; std::pair<int const ,int>::pair<int const ,int><int,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z PROC	; std::pair<int const ,int>::pair<int const ,int><int,int>, COMDAT
; _this$ = ecx

; 57   : 		{	// construct from compatible pair

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 58   : 		}

	ret	4
??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z ENDP	; std::pair<int const ,int>::pair<int const ,int><int,int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@W4PolicyBranchTypes@@@@YAXAAPAW4PolicyBranchTypes@@@Z ; SAFE_DELETE_ARRAY<enum PolicyBranchTypes>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@W4PolicyBranchTypes@@@@YAXAAPAW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@W4PolicyBranchTypes@@@@YAXAAPAW4PolicyBranchTypes@@@Z PROC ; SAFE_DELETE_ARRAY<enum PolicyBranchTypes>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@W4PolicyBranchTypes@@@@YAXAAPAW4PolicyBranchTypes@@@Z ENDP ; SAFE_DELETE_ARRAY<enum PolicyBranchTypes>
_TEXT	ENDS
PUBLIC	??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z ; std::operator==<std::pair<int const ,int>,std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z PROC ; std::operator==<std::pair<int const ,int>,std::pair<int const ,int> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z ENDP ; std::operator==<std::pair<int const ,int>,std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z PROC ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z ENDP ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
_TEXT	ENDS
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T232171 = -12						; size = 12
$T232175 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z PROC ; std::_Allocate<enum BuildingTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232175[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232171[esp+16]
	mov	DWORD PTR $T232175[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232171[esp+16]
	push	ecx
	mov	DWORD PTR $T232171[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T232181 = -12						; size = 12
$T232185 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z PROC ; std::_Allocate<enum PolicyTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232185[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232181[esp+16]
	mov	DWORD PTR $T232185[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232181[esp+16]
	push	ecx
	mov	DWORD PTR $T232181[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum PolicyTypes>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T232200 = -12						; size = 12
$T232204 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvPolicyEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232204[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232200[esp+16]
	mov	DWORD PTR $T232204[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232200[esp+16]
	push	ecx
	mov	DWORD PTR $T232200[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPolicyEntry *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyBranchEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T232210 = -12						; size = 12
$T232214 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvPolicyBranchEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232214[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232210[esp+16]
	mov	DWORD PTR $T232214[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232210[esp+16]
	push	ecx
	mov	DWORD PTR $T232210[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPolicyBranchEntry *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T232223 = -12						; size = 12
$T232227 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232227[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232223[esp+16]
	mov	DWORD PTR $T232227[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232223[esp+16]
	push	ecx
	mov	DWORD PTR $T232223[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
_TEXT	ENDS
PUBLIC	??_GCvPolicyAI@@QAEPAXI@Z			; CvPolicyAI::`scalar deleting destructor'
EXTRN	??1CvPolicyAI@@QAE@XZ:PROC			; CvPolicyAI::~CvPolicyAI
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPolicyAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPolicyAI@@QAEPAXI@Z PROC				; CvPolicyAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvPolicyAI@@QAE@XZ			; CvPolicyAI::~CvPolicyAI
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPolicyAI@@QAEPAXI@Z ENDP				; CvPolicyAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::swap<std::less<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC	; std::swap<std::less<int> >, COMDAT

; 18   : 	if (&_Left != &_Right)
; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;
; 21   : 
; 22   : 		_Left = _Right;
; 23   : 		_Right = _Tmp;
; 24   : 		}
; 25   : 	}

	ret	0
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP	; std::swap<std::less<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyEntry@@0@Z ; std::_Iter_random<CvPolicyEntry * *,CvPolicyEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyEntry@@0@Z PROC ; std::_Iter_random<CvPolicyEntry * *,CvPolicyEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyEntry@@0@Z ENDP ; std::_Iter_random<CvPolicyEntry * *,CvPolicyEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyEntry@@0@Z ; std::_Ptr_cat<CvPolicyEntry * *,CvPolicyEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyEntry@@0@Z PROC ; std::_Ptr_cat<CvPolicyEntry * *,CvPolicyEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPolicyEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyEntry@@0@Z ENDP ; std::_Ptr_cat<CvPolicyEntry * *,CvPolicyEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPolicyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPolicyEntry * *,CvPolicyEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPolicyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPolicyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPolicyEntry * *,CvPolicyEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPolicyEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPolicyEntry * *,CvPolicyEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyBranchEntry@@0@Z ; std::_Iter_random<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyBranchEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyBranchEntry@@0@Z PROC ; std::_Iter_random<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPolicyBranchEntry@@0@Z ENDP ; std::_Iter_random<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyBranchEntry@@0@Z ; std::_Ptr_cat<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyBranchEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyBranchEntry@@0@Z PROC ; std::_Ptr_cat<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPolicyBranchEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPolicyBranchEntry@@0@Z ENDP ; std::_Ptr_cat<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPolicyBranchEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPolicyBranchEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPolicyBranchEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPolicyBranchEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z ; std::_Ptr_cat<enum BuildingTypes *,enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z PROC ; std::_Ptr_cat<enum BuildingTypes *,enum BuildingTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4BuildingTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4BuildingTypes@@0@Z ENDP ; std::_Ptr_cat<enum BuildingTypes *,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4PolicyTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PolicyTypes@@0@Z ; std::_Ptr_cat<enum PolicyTypes *,enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4PolicyTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PolicyTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4PolicyTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PolicyTypes@@0@Z PROC ; std::_Ptr_cat<enum PolicyTypes *,enum PolicyTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4PolicyTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4PolicyTypes@@0@Z ENDP ; std::_Ptr_cat<enum PolicyTypes *,enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPolicyEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPolicyBranchEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z ; std::_Fill<enum BuildingTypes *,enum BuildingTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z PROC ; std::_Fill<enum BuildingTypes *,enum BuildingTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z ENDP ; std::_Fill<enum BuildingTypes *,enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z ; std::_Iter_random<enum BuildingTypes *,enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z PROC ; std::_Iter_random<enum BuildingTypes *,enum BuildingTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4BuildingTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4BuildingTypes@@0@Z ENDP ; std::_Iter_random<enum BuildingTypes *,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4BuildingTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4BuildingTypes@@@Z ; std::_Move_cat<enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4BuildingTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4BuildingTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4BuildingTypes@@@Z PROC ; std::_Move_cat<enum BuildingTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4BuildingTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4BuildingTypes@@@Z ENDP ; std::_Move_cat<enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z ; std::_Fill<enum PolicyTypes *,enum PolicyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z PROC ; std::_Fill<enum PolicyTypes *,enum PolicyTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z ENDP ; std::_Fill<enum PolicyTypes *,enum PolicyTypes>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4PolicyTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PolicyTypes@@0@Z ; std::_Iter_random<enum PolicyTypes *,enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4PolicyTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PolicyTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4PolicyTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PolicyTypes@@0@Z PROC ; std::_Iter_random<enum PolicyTypes *,enum PolicyTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4PolicyTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4PolicyTypes@@0@Z ENDP ; std::_Iter_random<enum PolicyTypes *,enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4PolicyTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PolicyTypes@@@Z ; std::_Move_cat<enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4PolicyTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4PolicyTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PolicyTypes@@@Z PROC ; std::_Move_cat<enum PolicyTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4PolicyTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4PolicyTypes@@@Z ENDP ; std::_Move_cat<enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum PolicyTypes *,enum PolicyTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum PolicyTypes *,enum PolicyTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum PolicyTypes *,enum PolicyTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@W4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@ABW41@@Z ; std::_Construct<enum BuildingTypes,enum BuildingTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Construct@W4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@ABW41@@Z PROC ; std::_Construct<enum BuildingTypes,enum BuildingTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@W4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@ABW41@@Z ENDP ; std::_Construct<enum BuildingTypes,enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z ; std::_Destroy<enum BuildingTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z PROC ; std::_Destroy<enum BuildingTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4BuildingTypes@@@std@@YAXPAW4BuildingTypes@@@Z ENDP ; std::_Destroy<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$_Construct@W4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@ABW41@@Z ; std::_Construct<enum PolicyTypes,enum PolicyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@ABW41@@Z PROC ; std::_Construct<enum PolicyTypes,enum PolicyTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@W4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@ABW41@@Z ENDP ; std::_Construct<enum PolicyTypes,enum PolicyTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4PolicyTypes@@@std@@YAXPAW4PolicyTypes@@@Z ; std::_Destroy<enum PolicyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4PolicyTypes@@@std@@YAXPAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4PolicyTypes@@@std@@YAXPAW4PolicyTypes@@@Z PROC ; std::_Destroy<enum PolicyTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4PolicyTypes@@@std@@YAXPAW4PolicyTypes@@@Z ENDP ; std::_Destroy<enum PolicyTypes>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEABW4BuildingTypes@@XZ ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEABW4PolicyTypes@@XZ ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEABW4PolicyTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEABW4PolicyTypes@@XZ PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEABW4PolicyTypes@@XZ ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator==
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z ; std::_Ptr_cat<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@AAPAW4BuildingTypes@@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z ; std::_Ptr_cat<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@AAPAW4PolicyTypes@@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEAAW4BuildingTypes@@XZ ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEAAW4BuildingTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEAAW4BuildingTypes@@XZ PROC ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEAAW4BuildingTypes@@XZ ENDP ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEAAW4PolicyTypes@@XZ ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEAAW4PolicyTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEAAW4PolicyTypes@@XZ PROC ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEAAW4PolicyTypes@@XZ ENDP ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator++
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescriptionKey
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescriptionKey, COMDAT
; _this$ = ecx

; 69   : 		return m_strDescriptionKey.c_str();

	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescriptionKey
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getPOLICY_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getPOLICY_WEIGHT_PROPAGATION_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPOLICY_WEIGHT_PROPAGATION_PERCENT, COMDAT
; _this$ = ecx

; 889  : 		return m_iPOLICY_WEIGHT_PROPAGATION_PERCENT;

	mov	eax, DWORD PTR [ecx+1824]

; 890  : 	}

	ret	0
?getPOLICY_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPOLICY_WEIGHT_PROPAGATION_PERCENT
_TEXT	ENDS
PUBLIC	?getNUM_POLICY_BRANCHES_ALLOWED@CvGlobals@@QAEHXZ ; CvGlobals::getNUM_POLICY_BRANCHES_ALLOWED
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_POLICY_BRANCHES_ALLOWED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_POLICY_BRANCHES_ALLOWED@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUM_POLICY_BRANCHES_ALLOWED, COMDAT
; _this$ = ecx

; 5332 : 		return m_iNUM_POLICY_BRANCHES_ALLOWED;

	mov	eax, DWORD PTR [ecx+6256]

; 5333 : 	}

	ret	0
?getNUM_POLICY_BRANCHES_ALLOWED@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUM_POLICY_BRANCHES_ALLOWED
_TEXT	ENDS
PUBLIC	?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_OR_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUM_OR_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5344 : 		return m_iNUM_OR_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6268]

; 5345 : 	}

	ret	0
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUM_OR_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_AND_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUM_AND_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5348 : 		return m_iNUM_AND_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6272]

; 5349 : 	}

	ret	0
?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUM_AND_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getBASE_POLICY_COST@CvGlobals@@QAEHXZ		; CvGlobals::getBASE_POLICY_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getBASE_POLICY_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBASE_POLICY_COST@CvGlobals@@QAEHXZ PROC		; CvGlobals::getBASE_POLICY_COST, COMDAT
; _this$ = ecx

; 6040 : 		return m_iBASE_POLICY_COST;

	mov	eax, DWORD PTR [ecx+6964]

; 6041 : 	}

	ret	0
?getBASE_POLICY_COST@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getBASE_POLICY_COST
_TEXT	ENDS
PUBLIC	?getPOLICY_COST_INCREASE_TO_BE_EXPONENTED@CvGlobals@@QAEHXZ ; CvGlobals::getPOLICY_COST_INCREASE_TO_BE_EXPONENTED
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_COST_INCREASE_TO_BE_EXPONENTED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_COST_INCREASE_TO_BE_EXPONENTED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPOLICY_COST_INCREASE_TO_BE_EXPONENTED, COMDAT
; _this$ = ecx

; 6044 : 		return m_iPOLICY_COST_INCREASE_TO_BE_EXPONENTED;

	mov	eax, DWORD PTR [ecx+6968]

; 6045 : 	}

	ret	0
?getPOLICY_COST_INCREASE_TO_BE_EXPONENTED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPOLICY_COST_INCREASE_TO_BE_EXPONENTED
_TEXT	ENDS
PUBLIC	?getPOLICY_COST_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getPOLICY_COST_VISIBLE_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_COST_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_COST_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_COST_VISIBLE_DIVISOR, COMDAT
; _this$ = ecx

; 6048 : 		return m_iPOLICY_COST_VISIBLE_DIVISOR;

	mov	eax, DWORD PTR [ecx+6972]

; 6049 : 	}

	ret	0
?getPOLICY_COST_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_COST_VISIBLE_DIVISOR
_TEXT	ENDS
PUBLIC	?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS, COMDAT
; _this$ = ecx

; 6052 : 		return m_iSWITCH_POLICY_BRANCHES_ANARCHY_TURNS;

	mov	eax, DWORD PTR [ecx+6976]

; 6053 : 	}

	ret	0
?getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS
_TEXT	ENDS
PUBLIC	?getSWITCH_POLICY_BRANCHES_TENETS_LOST@CvGlobals@@QAEHXZ ; CvGlobals::getSWITCH_POLICY_BRANCHES_TENETS_LOST
; Function compile flags: /Ogtpy
;	COMDAT ?getSWITCH_POLICY_BRANCHES_TENETS_LOST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSWITCH_POLICY_BRANCHES_TENETS_LOST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getSWITCH_POLICY_BRANCHES_TENETS_LOST, COMDAT
; _this$ = ecx

; 6056 : 		return m_iSWITCH_POLICY_BRANCHES_TENETS_LOST;

	mov	eax, DWORD PTR [ecx+6980]

; 6057 : 	}

	ret	0
?getSWITCH_POLICY_BRANCHES_TENETS_LOST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getSWITCH_POLICY_BRANCHES_TENETS_LOST
_TEXT	ENDS
PUBLIC	?getPOLICY_COST_EXPONENT@CvGlobals@@QAEMXZ	; CvGlobals::getPOLICY_COST_EXPONENT
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_COST_EXPONENT@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getPOLICY_COST_EXPONENT@CvGlobals@@QAEMXZ PROC		; CvGlobals::getPOLICY_COST_EXPONENT, COMDAT
; _this$ = ecx

; 7148 : 		return m_fPOLICY_COST_EXPONENT;

	fld	DWORD PTR [ecx+8136]

; 7149 : 	}

	ret	0
?getPOLICY_COST_EXPONENT@CvGlobals@@QAEMXZ ENDP		; CvGlobals::getPOLICY_COST_EXPONENT
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_FREEDOM
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_FREEDOM, COMDAT
; _this$ = ecx

; 7599 : 		return m_iPOLICY_BRANCH_FREEDOM;

	mov	eax, DWORD PTR [ecx+8376]

; 7600 : 	}

	ret	0
?getPOLICY_BRANCH_FREEDOM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_FREEDOM
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY, COMDAT
; _this$ = ecx

; 7603 : 		return m_iPOLICY_BRANCH_AUTOCRACY;

	mov	eax, DWORD PTR [ecx+8380]

; 7604 : 	}

	ret	0
?getPOLICY_BRANCH_AUTOCRACY@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPOLICY_BRANCH_AUTOCRACY
_TEXT	ENDS
PUBLIC	?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ	; CvGlobals::getPOLICY_BRANCH_ORDER
; Function compile flags: /Ogtpy
;	COMDAT ?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPOLICY_BRANCH_ORDER, COMDAT
; _this$ = ecx

; 7607 : 		return m_iPOLICY_BRANCH_ORDER;

	mov	eax, DWORD PTR [ecx+8384]

; 7608 : 	}

	ret	0
?getPOLICY_BRANCH_ORDER@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPOLICY_BRANCH_ORDER
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T232535 = -80						; size = 28
$T232534 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232535[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232534[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232535[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232534[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232534[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232534[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232534[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232535[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232534[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T232588 = -12						; size = 12
$T232592 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232592[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232588[esp+16]
	mov	DWORD PTR $T232592[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232588[esp+16]
	push	ecx
	mov	DWORD PTR $T232588[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T232663 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T232663[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T232663[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T232663[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T232663[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z	; CvPolicyEntry::SetWeLoveTheKingKey
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
;	COMDAT ?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z PROC	; CvPolicyEntry::SetWeLoveTheKingKey, COMDAT
; _this$ = ecx

; 1984 : 	m_strWeLoveTheKingKey = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 892				; 0000037cH
	test	eax, eax
	je	SHORT $LN4@SetWeLoveT
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetWeLoveT:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 1985 : }

	ret	4
?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z ENDP	; CvPolicyEntry::SetWeLoveTheKingKey
_TEXT	ENDS
PUBLIC	??_7CvPolicyBranchEntry@@6B@			; CvPolicyBranchEntry::`vftable'
PUBLIC	??0CvPolicyBranchEntry@@QAE@XZ			; CvPolicyBranchEntry::CvPolicyBranchEntry
PUBLIC	??_R4CvPolicyBranchEntry@@6B@			; CvPolicyBranchEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPolicyBranchEntry@@@8			; CvPolicyBranchEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvPolicyBranchEntry@@8			; CvPolicyBranchEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPolicyBranchEntry@@8			; CvPolicyBranchEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPolicyBranchEntry@@8		; CvPolicyBranchEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPolicyBranchEntry::CacheResults
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvPolicyBranchEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPolicyBranchEntry@@8 DD FLAT:??_R0?AVCvPolicyBranchEntry@@@8 ; CvPolicyBranchEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPolicyBranchEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPolicyBranchEntry@@8
rdata$r	SEGMENT
??_R2CvPolicyBranchEntry@@8 DD FLAT:??_R1A@?0A@EA@CvPolicyBranchEntry@@8 ; CvPolicyBranchEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPolicyBranchEntry@@8
rdata$r	SEGMENT
??_R3CvPolicyBranchEntry@@8 DD 00H			; CvPolicyBranchEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPolicyBranchEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPolicyBranchEntry@@@8
_DATA	SEGMENT
??_R0?AVCvPolicyBranchEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvPolicyBranchEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPolicyBranchEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPolicyBranchEntry@@6B@
rdata$r	SEGMENT
??_R4CvPolicyBranchEntry@@6B@ DD 00H			; CvPolicyBranchEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPolicyBranchEntry@@@8
	DD	FLAT:??_R3CvPolicyBranchEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvPolicyBranchEntry@@6B@
CONST	SEGMENT
??_7CvPolicyBranchEntry@@6B@ DD FLAT:??_R4CvPolicyBranchEntry@@6B@ ; CvPolicyBranchEntry::`vftable'
	DD	FLAT:?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvPolicyBranchEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvPolicyBranchEntry@@QAE@XZ PROC			; CvPolicyBranchEntry::CvPolicyBranchEntry, COMDAT
; _this$ = ecx

; 2321 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	or	eax, -1
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	xor	eax, eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyBranchEntry@@6B@

; 2322 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvPolicyBranchEntry@@QAE@XZ ENDP			; CvPolicyBranchEntry::CvPolicyBranchEntry
_TEXT	ENDS
PUBLIC	??1CvPolicyBranchEntry@@QAE@XZ			; CvPolicyBranchEntry::~CvPolicyBranchEntry
; Function compile flags: /Ogtpy
;	COMDAT ??1CvPolicyBranchEntry@@QAE@XZ
_TEXT	SEGMENT
??1CvPolicyBranchEntry@@QAE@XZ PROC			; CvPolicyBranchEntry::~CvPolicyBranchEntry, COMDAT
; _this$ = ecx

; 2326 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyBranchEntry@@6B@

; 2327 : 	SAFE_DELETE_ARRAY(m_piPolicyBranchDisables);

	mov	eax, DWORD PTR [esi+288]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+288], 0

; 2328 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvPolicyBranchEntry@@QAE@XZ ENDP			; CvPolicyBranchEntry::~CvPolicyBranchEntry
_TEXT	ENDS
PUBLIC	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ	; CvPolicyXMLEntries::GetNumPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ PROC		; CvPolicyXMLEntries::GetNumPolicies, COMDAT
; _this$ = ecx

; 2494 : 	return m_paPolicyEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 2495 : }

	ret	0
?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ENDP		; CvPolicyXMLEntries::GetNumPolicies
_TEXT	ENDS
PUBLIC	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z PROC ; CvPolicyXMLEntries::GetPolicyEntry, COMDAT
; _this$ = ecx

; 2515 : 	return m_paPolicyEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2516 : }

	ret	4
?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ENDP ; CvPolicyXMLEntries::GetPolicyEntry
_TEXT	ENDS
PUBLIC	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ PROC	; CvPolicyXMLEntries::GetNumPolicyBranches, COMDAT
; _this$ = ecx

; 2531 : 	return m_paPolicyBranchEntries.size();

	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+20]
	sar	eax, 2

; 2532 : }

	ret	0
?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ENDP	; CvPolicyXMLEntries::GetNumPolicyBranches
_TEXT	ENDS
PUBLIC	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyBranchEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z PROC ; CvPolicyXMLEntries::GetPolicyBranchEntry, COMDAT
; _this$ = ecx

; 2552 : 	return m_paPolicyBranchEntries[index];

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2553 : }

	ret	4
?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ENDP ; CvPolicyXMLEntries::GetPolicyBranchEntry
_TEXT	ENDS
PUBLIC	?Reset@CvPlayerPolicies@@QAEXXZ			; CvPlayerPolicies::Reset
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?Reset@CvPolicyAI@@QAEXXZ:PROC			; CvPolicyAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvPlayerPolicies@@QAEXXZ
_TEXT	SEGMENT
_eBranch$225312 = -4					; size = 4
?Reset@CvPlayerPolicies@@QAEXXZ PROC			; CvPlayerPolicies::Reset, COMDAT
; _this$ = ecx

; 2649 : {

	push	ecx
	push	ebp
	push	esi
	mov	esi, ecx

; 2650 : #ifdef AUI_WARNING_FIXES
; 2651 : 	uint iI;
; 2652 : #else
; 2653 : 	int iI;
; 2654 : #endif
; 2655 : 
; 2656 : 	for(iI = 0; iI < m_pPolicies->GetNumPolicies(); iI++)

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	xor	ebp, ebp
	xor	eax, eax
	test	edx, -4					; fffffffcH
	jle	SHORT $LN15@Reset
	npad	6
$LL17@Reset:

; 2657 : 	{
; 2658 : 		m_pabHasPolicy[iI] = false;

	mov	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR [eax+ecx], 0

; 2659 : 		m_pabHasOneShotPolicyFired[iI] = false;

	mov	edx, DWORD PTR [esi+16]
	mov	BYTE PTR [eax+edx], 0

; 2660 : 		m_pabHaveOneShotFreeUnitsFired[iI] = false;

	mov	ecx, DWORD PTR [esi+20]
	mov	BYTE PTR [eax+ecx], 0

; 2661 : 		m_paePolicyBlockedBranchCheck[iI] = (PolicyBranchTypes)-2;

	mov	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [edx+eax*4], -2		; fffffffeH
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	inc	eax
	sar	edx, 2
	cmp	eax, edx
	jl	SHORT $LL17@Reset
$LN15@Reset:

; 2662 : 	}
; 2663 : 
; 2664 : 	for(iI = 0; iI < m_pPolicies->GetNumPolicyBranches(); iI++)

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR [ecx+20]
	add	ecx, 16					; 00000010H
	xor	eax, eax
	test	edx, -4					; fffffffcH
	jle	SHORT $LN12@Reset
$LL14@Reset:

; 2665 : 	{
; 2666 : 		m_pabPolicyBranchUnlocked[iI] = false;

	mov	ecx, DWORD PTR [esi+24]
	mov	BYTE PTR [eax+ecx], 0

; 2667 : 		m_pabPolicyBranchBlocked[iI] = false;

	mov	edx, DWORD PTR [esi+28]
	mov	BYTE PTR [eax+edx], 0

; 2668 : 		m_pabPolicyBranchFinished[iI] = false;

	mov	ecx, DWORD PTR [esi+32]
	mov	BYTE PTR [eax+ecx], 0

; 2669 : 		m_paePolicyBranchesChosen[iI] = NO_POLICY_BRANCH_TYPE;

	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [edx+eax*4], -1
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR [ecx+20]
	add	ecx, 16					; 00000010H
	inc	eax
	sar	edx, 2
	cmp	eax, edx
	jl	SHORT $LL14@Reset
$LN12@Reset:

; 2670 : 	}
; 2671 : 
; 2672 : 	m_iNumExtraBranches = 0;
; 2673 : 
; 2674 : 	m_eBranchPicked1 = NO_POLICY_BRANCH_TYPE;
; 2675 : 	m_eBranchPicked2 = NO_POLICY_BRANCH_TYPE;
; 2676 : 	m_eBranchPicked3 = NO_POLICY_BRANCH_TYPE;
; 2677 : 
; 2678 : 	// Reset AI too
; 2679 : 	m_pPolicyAI->Reset();

	mov	ecx, DWORD PTR [esi+56]
	or	eax, -1
	mov	DWORD PTR [esi+64], ebp
	mov	DWORD PTR [esi+68], eax
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], eax
	call	?Reset@CvPolicyAI@@QAEXXZ		; CvPolicyAI::Reset

; 2680 : 
; 2681 : 
; 2682 : 	CvAssert( m_pPolicies->GetNumPolicies() == m_pPolicies->GetNumPolicies());
; 2683 : 	//  Pre-calculate a policy to branch table so we don't do this over and over again.
; 2684 : 	for (iI = 0; iI < m_pPolicies->GetNumPolicies(); ++iI)

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	test	ecx, -4					; fffffffcH
	jle	$LN9@Reset
	push	ebx
	push	edi
	npad	9
$LL50@Reset:

; 2685 : 	{
; 2686 : 		PolicyTypes eType = (PolicyTypes) iI;
; 2687 : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eType);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 2688 : 		if(pkPolicyInfo == NULL)

	test	eax, eax
	jne	SHORT $LN8@Reset

; 2689 : 		{
; 2690 : 			m_paePolicyBlockedBranchCheck[eType] = NO_POLICY_BRANCH_TYPE;

	mov	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [edx+ebp*4], -1

; 2691 : 		}
; 2692 : 		else

	jmp	SHORT $LN10@Reset
$LN8@Reset:

; 2693 : 		{
; 2694 : 			// What is our branch?
; 2695 : 			PolicyBranchTypes eBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	eax, DWORD PTR [eax+820]
	mov	DWORD PTR _eBranch$225312[esp+20], eax

; 2696 : 
; 2697 : 			// Are we a free branch policy?
; 2698 : 			if(eBranch == NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	jne	SHORT $LN49@Reset

; 2699 : 			{
; 2700 : 				int iNumPolicyBranches = m_pPolicies->GetNumPolicyBranches();

	mov	eax, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [eax+24]
	sub	edi, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	sar	edi, 2

; 2701 : 				for(int iBranchLoop = 0; iBranchLoop < iNumPolicyBranches; iBranchLoop++)

	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN49@Reset
	npad	1
$LL5@Reset:

; 2702 : 				{
; 2703 : 					const PolicyBranchTypes eLoopBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 2704 : 					CvPolicyBranchEntry* pkLoopPolicyBranch = GC.getPolicyBranchInfo(eLoopBranch);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 2705 : 					if(pkLoopPolicyBranch)

	test	eax, eax
	je	SHORT $LN4@Reset

; 2706 : 					{
; 2707 : 						// Yes, it's a freebie
; 2708 : 						if(pkLoopPolicyBranch->GetFreePolicy() == eType)

	cmp	DWORD PTR [eax+264], ebp
	je	SHORT $LN44@Reset
$LN4@Reset:

; 2701 : 				for(int iBranchLoop = 0; iBranchLoop < iNumPolicyBranches; iBranchLoop++)

	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL5@Reset

; 2706 : 					{
; 2707 : 						// Yes, it's a freebie
; 2708 : 						if(pkLoopPolicyBranch->GetFreePolicy() == eType)

	jmp	SHORT $LN49@Reset
$LN44@Reset:

; 2709 : 						{
; 2710 : 							eBranch = eLoopBranch;

	mov	DWORD PTR _eBranch$225312[esp+20], ebx
$LN49@Reset:

; 2711 : 							break;
; 2712 : 						}
; 2713 : 					}
; 2714 : 				}
; 2715 : 			}
; 2716 : 
; 2717 : 			m_paePolicyBlockedBranchCheck[eType] = eBranch;

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _eBranch$225312[esp+20]
	mov	DWORD PTR [eax+ebp*4], ecx
$LN10@Reset:
	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	inc	ebp
	sar	edx, 2
	cmp	ebp, edx
	jl	SHORT $LL50@Reset
	pop	edi
	pop	ebx
$LN9@Reset:
	pop	esi
	pop	ebp

; 2718 : 		}
; 2719 : 	}
; 2720 : }

	pop	ecx
	ret	0
?Reset@CvPlayerPolicies@@QAEXXZ ENDP			; CvPlayerPolicies::Reset
_TEXT	ENDS
PUBLIC	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ	; CvPlayerPolicies::GetNumPoliciesOwned
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ PROC	; CvPlayerPolicies::GetNumPoliciesOwned, COMDAT
; _this$ = ecx

; 2953 : 	int rtnValue = 0;
; 2954 : 
; 2955 : #ifdef AUI_WARNING_FIXES
; 2956 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 2957 : #else
; 2958 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edx, DWORD PTR [ecx+52]
	push	esi
	push	edi
	mov	edi, DWORD PTR [edx+8]
	sub	edi, DWORD PTR [edx+4]
	xor	eax, eax
	xor	esi, esi
	test	edi, -4					; fffffffcH
	jle	SHORT $LN2@GetNumPoli
	mov	edi, DWORD PTR [edx+8]
	sub	edi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+12]
	sar	edi, 2
$LL4@GetNumPoli:

; 2959 : #endif
; 2960 : 	{
; 2961 : 		// Do we have this policy?
; 2962 : 		if(m_pabHasPolicy[i])

	cmp	BYTE PTR [ecx+esi], 0
	je	SHORT $LN3@GetNumPoli

; 2963 : 		{
; 2964 : 			rtnValue++;

	inc	eax
$LN3@GetNumPoli:

; 2953 : 	int rtnValue = 0;
; 2954 : 
; 2955 : #ifdef AUI_WARNING_FIXES
; 2956 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 2957 : #else
; 2958 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@GetNumPoli
$LN2@GetNumPoli:
	pop	edi
	pop	esi

; 2965 : 		}
; 2966 : 	}
; 2967 : 
; 2968 : 	return rtnValue;
; 2969 : }

	ret	0
?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ ENDP	; CvPlayerPolicies::GetNumPoliciesOwned
_TEXT	ENDS
PUBLIC	?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch, COMDAT
; _this$ = ecx

; 2974 : 	int rtnValue = 0;
; 2975 : 
; 2976 : #ifdef AUI_WARNING_FIXES
; 2977 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 2978 : #else
; 2979 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edx, DWORD PTR [ecx+52]
	push	esi
	push	edi
	mov	edi, DWORD PTR [edx+8]
	sub	edi, DWORD PTR [edx+4]
	xor	eax, eax
	xor	esi, esi
	test	edi, -4					; fffffffcH
	jle	SHORT $LN2@GetNumPoli@2
	mov	ecx, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR _eBranch$[esp+4]
	push	ebx
	npad	1
$LL4@GetNumPoli@2:

; 2980 : #endif
; 2981 : 	{
; 2982 : 		// Do we have this policy?
; 2983 : 		if (m_pabHasPolicy[i] && m_pPolicies->GetPolicyEntry(i)->GetPolicyBranchType() == eBranch)

	cmp	BYTE PTR [ecx+esi], 0
	je	SHORT $LN3@GetNumPoli@2
	mov	ebx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ebx+esi*4]
	cmp	DWORD PTR [ebx+820], edi
	jne	SHORT $LN3@GetNumPoli@2

; 2984 : 		{
; 2985 : 			rtnValue++;

	inc	eax
$LN3@GetNumPoli@2:

; 2974 : 	int rtnValue = 0;
; 2975 : 
; 2976 : #ifdef AUI_WARNING_FIXES
; 2977 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 2978 : #else
; 2979 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	ebx, DWORD PTR [edx+8]
	sub	ebx, DWORD PTR [edx+4]
	inc	esi
	sar	ebx, 2
	cmp	esi, ebx
	jl	SHORT $LL4@GetNumPoli@2
	pop	ebx
$LN2@GetNumPoli@2:
	pop	edi
	pop	esi

; 2986 : 		}
; 2987 : 	}
; 2988 : 
; 2989 : 	return rtnValue;
; 2990 : }

	ret	4
?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch
_TEXT	ENDS
PUBLIC	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z PROC ; CvPlayerPolicies::GetNumericModifier, COMDAT
; _this$ = ecx

; 3000 : {

	push	ebx
	push	esi

; 3001 : 	int rtnValue = 0;
; 3002 : 
; 3003 : 	int iNumPolicies = m_pPolicies->GetNumPolicies();

	mov	esi, DWORD PTR [ecx+52]
	mov	ebx, DWORD PTR [esi+8]
	sub	ebx, DWORD PTR [esi+4]
	xor	eax, eax
	sar	ebx, 2

; 3004 : 	for(int i = 0; i < iNumPolicies; i++)

	xor	edx, edx
	test	ebx, ebx
	jle	$LN71@GetNumeric
	push	ebp
	push	edi
	npad	4
$LL73@GetNumeric:

; 3005 : 	{
; 3006 : 		// Do we have this policy?
; 3007 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [edi+edx], 0
	je	$LN72@GetNumeric
	mov	edi, DWORD PTR [ecx+48]
	mov	edi, DWORD PTR [edi+edx*4]
	cmp	edi, -1
	je	SHORT $LN489@GetNumeric
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [edi+ebp], 0
	jne	$LN72@GetNumeric
$LN489@GetNumeric:

; 3008 : 		{
; 3009 : 			// Yes, so add it to our counts
; 3010 : 			switch(eType)

	mov	edi, DWORD PTR _eType$[esp+12]
	cmp	edi, 67					; 00000043H
	ja	$LN72@GetNumeric
	jmp	DWORD PTR $LN492@GetNumeric[edi*4]
$LN67@GetNumeric:

; 3011 : 			{
; 3012 : 			case POLICYMOD_EXTRA_HAPPINESS:
; 3013 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraHappiness();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+408]

; 3014 : 				break;

	jmp	$LN72@GetNumeric
$LN66@GetNumeric:

; 3015 : 			case POLICYMOD_EXTRA_HAPPINESS_PER_CITY:
; 3016 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraHappinessPerCity();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+412]

; 3017 : 				break;

	jmp	$LN72@GetNumeric
$LN65@GetNumeric:

; 3018 : 			case POLICYMOD_GREAT_PERSON_RATE:
; 3019 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatPeopleRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+372]

; 3020 : 				break;

	jmp	$LN72@GetNumeric
$LN64@GetNumeric:

; 3021 : 			case POLICYMOD_GREAT_GENERAL_RATE:
; 3022 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatGeneralRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+376]

; 3023 : 				break;

	jmp	$LN72@GetNumeric
$LN63@GetNumeric:

; 3024 : 			case POLICYMOD_GREAT_ADMIRAL_RATE:
; 3025 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatAdmiralRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+380]

; 3026 : 				break;

	jmp	$LN72@GetNumeric
$LN62@GetNumeric:

; 3027 : 			case POLICYMOD_GREAT_WRITER_RATE:
; 3028 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatWriterRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+384]

; 3029 : 				break;

	jmp	$LN72@GetNumeric
$LN61@GetNumeric:

; 3030 : 			case POLICYMOD_GREAT_ARTIST_RATE:
; 3031 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatArtistRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+388]

; 3032 : 				break;

	jmp	$LN72@GetNumeric
$LN60@GetNumeric:

; 3033 : 			case POLICYMOD_GREAT_MUSICIAN_RATE:
; 3034 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatMusicianRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+392]

; 3035 : 				break;

	jmp	$LN72@GetNumeric
$LN59@GetNumeric:

; 3036 : 			case POLICYMOD_GREAT_MERCHANT_RATE:
; 3037 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatMerchantRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+396]

; 3038 : 				break;

	jmp	$LN72@GetNumeric
$LN58@GetNumeric:

; 3039 : 			case POLICYMOD_GREAT_SCIENTIST_RATE:
; 3040 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatScientistRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+400]

; 3041 : 				break;

	jmp	$LN72@GetNumeric
$LN57@GetNumeric:

; 3042 : 			case POLICYMOD_DOMESTIC_GREAT_GENERAL_RATE:
; 3043 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetDomesticGreatGeneralRateModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+404]

; 3044 : 				break;

	jmp	$LN72@GetNumeric
$LN56@GetNumeric:

; 3045 : 			case POLICYMOD_POLICY_COST_MODIFIER:
; 3046 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetPolicyCostModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+280]

; 3047 : 				break;

	jmp	$LN72@GetNumeric
$LN55@GetNumeric:

; 3048 : 			case POLICYMOD_WONDER_PRODUCTION_MODIFIER:
; 3049 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetWonderProductionModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+364]

; 3050 : 				break;

	jmp	$LN72@GetNumeric
$LN54@GetNumeric:

; 3051 : 			case POLICYMOD_BUILDING_PRODUCTION_MODIFIER:
; 3052 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingProductionModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+368]

; 3053 : 				break;

	jmp	$LN72@GetNumeric
$LN53@GetNumeric:

; 3054 : 			case POLICYMOD_FREE_EXPERIENCE:
; 3055 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetFreeExperience();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+432]

; 3056 : 				break;

	jmp	$LN72@GetNumeric
$LN52@GetNumeric:

; 3057 : 			case POLICYMOD_EXTRA_CULTURE_FROM_IMPROVEMENTS:
; 3058 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCultureImprovementChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+300]

; 3059 : 				break;

	jmp	$LN72@GetNumeric
$LN51@GetNumeric:

; 3060 : 			case POLICYMOD_CULTURE_FROM_KILLS:
; 3061 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCultureFromKills();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+304]

; 3062 : 				break;

	jmp	$LN72@GetNumeric
$LN50@GetNumeric:

; 3063 : 			case POLICYMOD_EMBARKED_EXTRA_MOVES:
; 3064 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetEmbarkedExtraMoves();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+320]

; 3065 : 				break;

	jmp	$LN72@GetNumeric
$LN49@GetNumeric:

; 3066 : 			case POLICYMOD_CULTURE_FROM_BARBARIAN_KILLS:
; 3067 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCultureFromBarbarianKills();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+308]

; 3068 : 				break;

	jmp	$LN72@GetNumeric
$LN48@GetNumeric:

; 3069 : 			case POLICYMOD_GOLD_FROM_KILLS:
; 3070 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGoldFromKills();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+312]

; 3071 : 				break;

	jmp	$LN72@GetNumeric
$LN47@GetNumeric:

; 3072 : 			// NQMP GJS - Honor Finisher
; 3073 : 			case POLICYMOD_SCIENCE_FROM_KILLS:
; 3074 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetScienceFromKills();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+316]

; 3075 : 				break;

	jmp	$LN72@GetNumeric
$LN46@GetNumeric:

; 3076 : 			// NQMP GJS - Honor Finisher end
; 3077 : 			case POLICYMOD_CULTURE_FROM_GARRISON:
; 3078 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCulturePerGarrisonedUnit();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+484]

; 3079 : 				break;

	jmp	$LN72@GetNumeric
$LN45@GetNumeric:

; 3080 : 			case POLICYMOD_UNIT_FREQUENCY_MODIFIER:
; 3081 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCityStateUnitFrequencyModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+656]

; 3082 : 				break;

	jmp	$LN72@GetNumeric
$LN44@GetNumeric:

; 3083 : 			// NQMP GJS - Patronage Finisher begin
; 3084 : 			case POLICYMOD_MINOR_MILITARY_NUM_EXTRA_UNITS_TO_GIFT:
; 3085 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMinorMilitaryNumExtraUnitsToGift();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+780]

; 3086 : 				break;

	jmp	$LN72@GetNumeric
$LN43@GetNumeric:

; 3087 : 			case POLICYMOD_CITY_STATE_BONUS_MODIFIER:
; 3088 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCityStateBonusModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+784]

; 3089 : 				break;

	jmp	$LN72@GetNumeric
$LN42@GetNumeric:

; 3090 : 			// NQMP GJS - Patronage Finisher end
; 3091 : 			// NQMP GJS - Colonialism begin
; 3092 : 			case POLICYMOD_EXTRA_TERRITORY_CLAIM:
; 3093 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraTerritoryClaim();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+788]

; 3094 : 				break;

	jmp	$LN72@GetNumeric
$LN41@GetNumeric:

; 3095 : 			// NQMP GJS - Colonialism end
; 3096 : 			// NQMP GJS - Cultural Exchange begin
; 3097 : 			case POLICYMOD_EXTRA_TOURISM_PER_GREAT_WORK:
; 3098 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraTourismPerGreatWork();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+792]

; 3099 : 				break;

	jmp	$LN72@GetNumeric
$LN40@GetNumeric:

; 3100 : 			// NQMP GJS - Cultural Exchange end
; 3101 : 			// NQMP GJS - Flourishing of the Arts begin
; 3102 : 			case POLICYMOD_TOURISM_PER_WONDER:
; 3103 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTourismPerWonder();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+796]

; 3104 : 				break;

	jmp	$LN72@GetNumeric
$LN39@GetNumeric:

; 3105 : 			// NQMP GJS - Flourishing of the Arts end
; 3106 : #ifdef NQ_TOURISM_PER_CITY
; 3107 : 			case POLICYMOD_TOURISM_PER_CITY:
; 3108 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTourismPerCity();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+800]

; 3109 : 				break;

	jmp	$LN72@GetNumeric
$LN38@GetNumeric:

; 3110 : #endif
; 3111 : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 3112 : 			case POLICYMOD_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER:
; 3113 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetIdeologyPressureUnhappinessModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+804]

; 3114 : 				break;

	jmp	$LN72@GetNumeric
$LN37@GetNumeric:

; 3115 : #endif
; 3116 : 			// NQMP GJS - Military Caste begin
; 3117 : 			case POLICYMOD_PRODUCTION_FROM_GARRISON:
; 3118 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetProductionFromGarrison();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+808]

; 3119 : 				break;

	jmp	$LN72@GetNumeric
$LN36@GetNumeric:

; 3120 : 			// NQMP GJS - Military Caste end
; 3121 : 			case POLICYMOD_TOURISM_MOD_COMMON_FOE:
; 3122 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCommonFoeTourismModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+660]

; 3123 : 				break;

	jmp	$LN72@GetNumeric
$LN35@GetNumeric:

; 3124 : 			case POLICYMOD_TOURISM_MOD_LESS_HAPPY:
; 3125 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetLessHappyTourismModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+664]

; 3126 : 				break;

	jmp	$LN72@GetNumeric
$LN34@GetNumeric:

; 3127 : 			case POLICYMOD_TOURISM_MOD_SHARED_IDEOLOGY:
; 3128 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSharedIdeologyTourismModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+668]

; 3129 : 				break;

	jmp	$LN72@GetNumeric
$LN33@GetNumeric:

; 3130 : 			case POLICYMOD_TRADE_MISSION_GOLD_MODIFIER:
; 3131 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTradeMissionGoldModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+548]

; 3132 : 				break;

	jmp	$LN72@GetNumeric
$LN32@GetNumeric:

; 3133 : 			case POLICYMOD_FAITH_COST_MODIFIER:
; 3134 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetFaithCostModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+552]

; 3135 : 				break;

	jmp	$LN72@GetNumeric
$LN31@GetNumeric:

; 3136 : 			case POLICYMOD_CULTURAL_PLUNDER_MULTIPLIER:
; 3137 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCulturalPlunderMultiplier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+556]

; 3138 : 				break;

	jmp	$LN72@GetNumeric
$LN30@GetNumeric:

; 3139 : 			case POLICYMOD_STEAL_TECH_SLOWER_MODIFIER:
; 3140 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetStealTechSlowerModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+560]

; 3141 : 				break;

	jmp	$LN72@GetNumeric
$LN29@GetNumeric:

; 3142 : 			case POLICYMOD_STEAL_TECH_FASTER_MODIFIER:
; 3143 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetStealTechFasterModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+564]

; 3144 : 				break;

	jmp	$LN72@GetNumeric
$LN28@GetNumeric:

; 3145 : 			case POLICYMOD_CATCH_SPIES_MODIFIER:
; 3146 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCatchSpiesModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+568]

; 3147 : 				break;

	jmp	$LN72@GetNumeric
$LN27@GetNumeric:

; 3148 : 			case POLICYMOD_BUILDING_PURCHASE_COST_MODIFIER:
; 3149 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingPurchaseCostModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+540]

; 3150 : 				break;

	jmp	$LN72@GetNumeric
$LN26@GetNumeric:

; 3151 : 			case POLICYMOD_LAND_TRADE_GOLD_CHANGE:
; 3152 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetLandTradeRouteGoldChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+672]

; 3153 : 				break;

	jmp	$LN72@GetNumeric
$LN25@GetNumeric:

; 3154 : 			case POLICYMOD_SEA_TRADE_GOLD_CHANGE:
; 3155 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSeaTradeRouteGoldChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+676]

; 3156 : 				break;

	jmp	$LN72@GetNumeric
$LN24@GetNumeric:

; 3157 : 			// NQMP GJS - Silk Road begin
; 3158 : 			case POLICYMOD_INTERNAL_TRADE_GOLD_CHANGE:
; 3159 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteGoldChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+680]

; 3160 : 				break;

	jmp	$LN72@GetNumeric
$LN23@GetNumeric:

; 3161 : 			// NQMP GJS - Silk Road end
; 3162 : 			case POLICYMOD_SHARED_IDEOLOGY_TRADE_CHANGE:
; 3163 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSharedIdeologyTradeGoldChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+684]

; 3164 : 				break;

	jmp	$LN72@GetNumeric
$LN22@GetNumeric:

; 3165 : 			case POLICYMOD_RIGGING_ELECTION_MODIFIER:
; 3166 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetRiggingElectionModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+688]

; 3167 : 				break;

	jmp	$LN72@GetNumeric
$LN21@GetNumeric:

; 3168 : 			case POLICYMOD_MILITARY_UNIT_GIFT_INFLUENCE:
; 3169 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMilitaryUnitGiftExtraInfluence();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+692]

; 3170 : 				break;

	jmp	$LN72@GetNumeric
$LN20@GetNumeric:

; 3171 : 			case POLICYMOD_PROTECTED_MINOR_INFLUENCE:
; 3172 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetProtectedMinorPerTurnInfluence();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+696]

; 3173 : 				break;

	jmp	$LN72@GetNumeric
$LN19@GetNumeric:

; 3174 : 			case POLICYMOD_AFRAID_INFLUENCE:
; 3175 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetAfraidMinorPerTurnInfluence();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+700]

; 3176 : 				break;

	jmp	$LN72@GetNumeric
$LN18@GetNumeric:

; 3177 : 			case POLICYMOD_MINOR_BULLY_SCORE_MODIFIER:
; 3178 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMinorBullyScoreModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+704]

; 3179 : 				break;

	jmp	$LN72@GetNumeric
$LN17@GetNumeric:

; 3180 : 			case POLICYMOD_THEMING_BONUS:
; 3181 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetThemingBonusMultiplier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+708]

; 3182 : 				break;

	jmp	$LN72@GetNumeric
$LN16@GetNumeric:

; 3183 : 			case POLICYMOD_CITY_STATE_TRADE_CHANGE:
; 3184 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCityStateTradeChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+772]

; 3185 : 				break;

	jmp	$LN72@GetNumeric
$LN15@GetNumeric:

; 3186 : 			case POLICYMOD_INTERNAL_TRADE_MODIFIER:
; 3187 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteYieldModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+712]

; 3188 : 				break;

	jmp	$LN72@GetNumeric
$LN14@GetNumeric:

; 3189 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3190 : 			case POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE:
; 3191 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteFoodYieldChange();
; 3192 : 				break;
; 3193 : #endif
; 3194 : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 3195 : 			case POLICYMOD_INTERNAL_TRADE_PRODUCTION_YIELD_CHANGE:
; 3196 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteProductionYieldChange();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+716]

; 3197 : 				break;

	jmp	$LN72@GetNumeric
$LN13@GetNumeric:

; 3198 : #endif
; 3199 : #ifdef NQ_RAIL_CONNECTION_PRODUCTION_MODIFIER_FROM_POLICIES
; 3200 : 			case POLICYMOD_RAIL_CONNECTION_PRODUCTION_MODIFIER:
; 3201 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetRailConnectionProductionModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+720]

; 3202 : 				break;

	jmp	$LN72@GetNumeric
$LN12@GetNumeric:

; 3203 : #endif
; 3204 : #ifdef NQ_COMBAT_BONUS_VS_SMALLER_CIV_FROM_POLICIES
; 3205 : 			case POLICYMOD_COMBAT_BONUS_VS_SMALLER_CIV:
; 3206 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCombatBonusVsSmallerCiv();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+724]

; 3207 : 				break;

	jmp	$LN72@GetNumeric
$LN11@GetNumeric:

; 3208 : #endif
; 3209 : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 3210 : 			case POLICYMOD_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER:
; 3211 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetProductionToGreatMusiciansModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+728]

; 3212 : 				break;

	jmp	$LN72@GetNumeric
$LN10@GetNumeric:

; 3213 : #endif
; 3214 : #ifdef NQ_TRADE_MISSION_INFLUENCE_MODIFIER_FROM_POLICIES
; 3215 : 			case POLICYMOD_TRADE_MISSION_INFLUENCE_MODIFIER:
; 3216 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTradeMissionInfluenceModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+732]

; 3217 : 				break;

	jmp	$LN72@GetNumeric
$LN9@GetNumeric:

; 3218 : #endif
; 3219 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 3220 : 			case POLICYMOD_SCIENCE_PER_GREAT_PERSON_BORN:
; 3221 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSciencePerGreatPersonBorn();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+736]

; 3222 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN8@GetNumeric:

; 3223 : #endif
; 3224 : #ifdef NQ_INFLUENCE_BOOST_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 3225 : 			case POLICYMOD_INFLUENCE_BOOST_PER_GREAT_PERSON_BORN:
; 3226 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInfluenceBoostPerGreatPersonBorn();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+740]

; 3227 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN7@GetNumeric:

; 3228 : #endif
; 3229 : #ifdef NQ_TOURISM_FROM_TRADE_MISSIONS_FROM_POLICIES
; 3230 : 			case POLICYMOD_TOURISM_FROM_TRADE_MISSIONS:
; 3231 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTourismFromTradeMissions();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+744]

; 3232 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN6@GetNumeric:

; 3233 : #endif
; 3234 : #ifdef NQ_HAPPINESS_FROM_GREAT_IMPROVEMENTS_FROM_POLICIES
; 3235 : 			case POLICYMOD_HAPPINESS_FROM_GREAT_IMPROVEMENTS:
; 3236 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetHappinessFromGreatImprovements();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+748]

; 3237 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN5@GetNumeric:

; 3238 : #endif
; 3239 : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 3240 : 			case POLICYMOD_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS:
; 3241 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMinorFriendshipGainBullyGoldSuccess();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+752]

; 3242 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN4@GetNumeric:

; 3243 : #endif
; 3244 : #ifdef NQ_COUP_CHANCE_MODIFIER_FROM_POLICIES
; 3245 : 			case POLICYMOD_COUP_CHANCE_MODIFIER:
; 3246 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCoupChanceModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+756]

; 3247 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN3@GetNumeric:

; 3248 : #endif
; 3249 : 			case POLICYMOD_SHARED_RELIGION_TOURISM_MODIFIER:
; 3250 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSharedReligionTourismModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+760]

; 3251 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN2@GetNumeric:

; 3252 : 			case POLICYMOD_TRADE_ROUTE_TOURISM_MODIFIER:
; 3253 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTradeRouteTourismModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+764]

; 3254 : 				break;

	jmp	SHORT $LN72@GetNumeric
$LN1@GetNumeric:

; 3255 : 			case POLICYMOD_OPEN_BORDERS_TOURISM_MODIFIER:
; 3256 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetOpenBordersTourismModifier();

	mov	edi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, DWORD PTR [edi+768]
$LN72@GetNumeric:
	inc	edx
	cmp	edx, ebx
	jl	$LL73@GetNumeric
	pop	edi
	pop	ebp
$LN71@GetNumeric:
	pop	esi
	pop	ebx

; 3257 : 				break;
; 3258 : 			}
; 3259 : 		}
; 3260 : 	}
; 3261 : 
; 3262 : 	return rtnValue;
; 3263 : }

	ret	4
	npad	1
$LN492@GetNumeric:
	DD	$LN67@GetNumeric
	DD	$LN66@GetNumeric
	DD	$LN65@GetNumeric
	DD	$LN64@GetNumeric
	DD	$LN57@GetNumeric
	DD	$LN56@GetNumeric
	DD	$LN72@GetNumeric
	DD	$LN55@GetNumeric
	DD	$LN54@GetNumeric
	DD	$LN53@GetNumeric
	DD	$LN52@GetNumeric
	DD	$LN51@GetNumeric
	DD	$LN50@GetNumeric
	DD	$LN49@GetNumeric
	DD	$LN48@GetNumeric
	DD	$LN46@GetNumeric
	DD	$LN45@GetNumeric
	DD	$LN33@GetNumeric
	DD	$LN32@GetNumeric
	DD	$LN31@GetNumeric
	DD	$LN30@GetNumeric
	DD	$LN28@GetNumeric
	DD	$LN63@GetNumeric
	DD	$LN62@GetNumeric
	DD	$LN61@GetNumeric
	DD	$LN60@GetNumeric
	DD	$LN59@GetNumeric
	DD	$LN58@GetNumeric
	DD	$LN36@GetNumeric
	DD	$LN35@GetNumeric
	DD	$LN34@GetNumeric
	DD	$LN27@GetNumeric
	DD	$LN26@GetNumeric
	DD	$LN25@GetNumeric
	DD	$LN23@GetNumeric
	DD	$LN22@GetNumeric
	DD	$LN21@GetNumeric
	DD	$LN20@GetNumeric
	DD	$LN19@GetNumeric
	DD	$LN18@GetNumeric
	DD	$LN29@GetNumeric
	DD	$LN17@GetNumeric
	DD	$LN16@GetNumeric
	DD	$LN15@GetNumeric
	DD	$LN14@GetNumeric
	DD	$LN13@GetNumeric
	DD	$LN12@GetNumeric
	DD	$LN11@GetNumeric
	DD	$LN10@GetNumeric
	DD	$LN9@GetNumeric
	DD	$LN8@GetNumeric
	DD	$LN7@GetNumeric
	DD	$LN6@GetNumeric
	DD	$LN5@GetNumeric
	DD	$LN4@GetNumeric
	DD	$LN3@GetNumeric
	DD	$LN2@GetNumeric
	DD	$LN1@GetNumeric
	DD	$LN47@GetNumeric
	DD	$LN44@GetNumeric
	DD	$LN43@GetNumeric
	DD	$LN42@GetNumeric
	DD	$LN37@GetNumeric
	DD	$LN41@GetNumeric
	DD	$LN40@GetNumeric
	DD	$LN39@GetNumeric
	DD	$LN38@GetNumeric
	DD	$LN24@GetNumeric
?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ENDP ; CvPlayerPolicies::GetNumericModifier
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z ; CvPlayerPolicies::GetYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYieldType$ = 8					; size = 4
?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z PROC ; CvPlayerPolicies::GetYieldModifier, COMDAT
; _this$ = ecx

; 3267 : {

	push	esi
	push	edi

; 3268 : 	int rtnValue = 0;
; 3269 : 
; 3270 : #ifdef AUI_WARNING_FIXES
; 3271 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3272 : #else
; 3273 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetYieldMo@2
	push	ebx
	mov	ebx, DWORD PTR [ecx+12]
	push	ebp
	npad	4
$LL29@GetYieldMo@2:

; 3274 : #endif
; 3275 : 	{
; 3276 : 		// Do we have this policy?
; 3277 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	cmp	BYTE PTR [ebx+edx], 0
	je	SHORT $LN3@GetYieldMo@2
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN26@GetYieldMo@2
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN3@GetYieldMo@2
$LN26@GetYieldMo@2:

; 3278 : 		{
; 3279 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetYieldModifier(eYieldType);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+976]
	test	esi, esi
	je	SHORT $LN22@GetYieldMo@2
	mov	ebp, DWORD PTR _eYieldType$[esp+12]
	mov	esi, DWORD PTR [esi+ebp*4]
	jmp	SHORT $LN23@GetYieldMo@2
$LN22@GetYieldMo@2:
	or	esi, -1
$LN23@GetYieldMo@2:
	add	eax, esi
$LN3@GetYieldMo@2:

; 3268 : 	int rtnValue = 0;
; 3269 : 
; 3270 : #ifdef AUI_WARNING_FIXES
; 3271 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3272 : #else
; 3273 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL29@GetYieldMo@2
	pop	ebp
	pop	ebx
$LN2@GetYieldMo@2:
	pop	edi
	pop	esi

; 3280 : 		}
; 3281 : 	}
; 3282 : 
; 3283 : 	return rtnValue;
; 3284 : }

	ret	4
?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z ENDP ; CvPlayerPolicies::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvPlayerPolicies::GetBuildingClassYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
_eYieldType$ = 12					; size = 4
?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassYieldModifier, COMDAT
; _this$ = ecx

; 3288 : {

	push	esi
	push	edi

; 3289 : 	int rtnValue = 0;
; 3290 : 
; 3291 : #ifdef AUI_WARNING_FIXES
; 3292 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3293 : #else
; 3294 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetBuildin@3
	push	ebx
	mov	ebx, DWORD PTR _eYieldType$[esp+8]
	push	ebp
	npad	3
$LL4@GetBuildin@3:

; 3295 : #endif
; 3296 : 	{
; 3297 : 		// Do we have this policy?
; 3298 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	esi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN3@GetBuildin@3
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN24@GetBuildin@3
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN3@GetBuildin@3
$LN24@GetBuildin@3:

; 3299 : 		{
; 3300 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassYieldModifiers(eBuildingClass, eYieldType);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+1060]
	mov	ebp, DWORD PTR _eBuildingClass$[esp+12]
	mov	esi, DWORD PTR [esi+ebp*4]
	add	eax, DWORD PTR [esi+ebx*4]
$LN3@GetBuildin@3:
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL4@GetBuildin@3
	pop	ebp
	pop	ebx
$LN2@GetBuildin@3:
	pop	edi
	pop	esi

; 3301 : 		}
; 3302 : 	}
; 3303 : 
; 3304 : 	return rtnValue;
; 3305 : }

	ret	8
?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassYieldModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvPlayerPolicies::GetBuildingClassYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
_eYieldType$ = 12					; size = 4
?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassYieldChange, COMDAT
; _this$ = ecx

; 3309 : {

	push	esi
	push	edi

; 3310 : 	int rtnValue = 0;
; 3311 : 
; 3312 : #ifdef AUI_WARNING_FIXES
; 3313 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3314 : #else
; 3315 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetBuildin@4
	push	ebx
	mov	ebx, DWORD PTR _eYieldType$[esp+8]
	push	ebp
	npad	3
$LL4@GetBuildin@4:

; 3316 : #endif
; 3317 : 	{
; 3318 : 		// Do we have this policy?
; 3319 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	esi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN3@GetBuildin@4
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN24@GetBuildin@4
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN3@GetBuildin@4
$LN24@GetBuildin@4:

; 3320 : 		{
; 3321 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassYieldChanges(eBuildingClass, eYieldType);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+1064]
	mov	ebp, DWORD PTR _eBuildingClass$[esp+12]
	mov	esi, DWORD PTR [esi+ebp*4]
	add	eax, DWORD PTR [esi+ebx*4]
$LN3@GetBuildin@4:
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL4@GetBuildin@4
	pop	ebp
	pop	ebx
$LN2@GetBuildin@4:
	pop	edi
	pop	esi

; 3322 : 		}
; 3323 : 	}
; 3324 : 
; 3325 : 	return rtnValue;
; 3326 : }

	ret	8
?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassYieldChange
_TEXT	ENDS
PUBLIC	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ; CvPlayerPolicies::GetImprovementCultureChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z PROC ; CvPlayerPolicies::GetImprovementCultureChange, COMDAT
; _this$ = ecx

; 3330 : {

	push	esi
	push	edi

; 3331 : 	int rtnValue = 0;
; 3332 : 
; 3333 : #ifdef AUI_WARNING_FIXES
; 3334 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3335 : #else
; 3336 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetImprove
	push	ebx
	mov	ebx, DWORD PTR _eImprovement$[esp+8]
	push	ebp
	npad	3
$LL4@GetImprove:

; 3337 : #endif
; 3338 : 	{
; 3339 : 		// Do we have this policy?
; 3340 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	esi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN3@GetImprove
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN24@GetImprove
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN3@GetImprove
$LN24@GetImprove:

; 3341 : 		{
; 3342 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetImprovementCultureChanges(eImprovement);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+1008]
	add	eax, DWORD PTR [esi+ebx*4]
$LN3@GetImprove:
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL4@GetImprove
	pop	ebp
	pop	ebx
$LN2@GetImprove:
	pop	edi
	pop	esi

; 3343 : 		}
; 3344 : 	}
; 3345 : 
; 3346 : 	return rtnValue;
; 3347 : }

	ret	4
?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ENDP ; CvPlayerPolicies::GetImprovementCultureChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassProductionModifier, COMDAT
; _this$ = ecx

; 3351 : {

	push	esi
	push	edi

; 3352 : 	int rtnValue = 0;
; 3353 : 
; 3354 : #ifdef AUI_WARNING_FIXES
; 3355 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3356 : #else
; 3357 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetBuildin@5
	push	ebx
	mov	ebx, DWORD PTR _eBuildingClass$[esp+8]
	push	ebp
	npad	3
$LL4@GetBuildin@5:

; 3358 : #endif
; 3359 : 	{
; 3360 : 		// Do we have this policy?
; 3361 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	esi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN3@GetBuildin@5
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN24@GetBuildin@5
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN3@GetBuildin@5
$LN24@GetBuildin@5:

; 3362 : 		{
; 3363 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassProductionModifier(eBuildingClass);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+1032]
	add	eax, DWORD PTR [esi+ebx*4]
$LN3@GetBuildin@5:
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL4@GetBuildin@5
	pop	ebp
	pop	ebx
$LN2@GetBuildin@5:
	pop	edi
	pop	esi

; 3364 : 		}
; 3365 : 	}
; 3366 : 
; 3367 : 	return rtnValue;
; 3368 : }

	ret	4
?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassTourismModifier, COMDAT
; _this$ = ecx

; 3372 : {

	push	esi
	push	edi

; 3373 : 	int rtnValue = 0;
; 3374 : 
; 3375 : #ifdef AUI_WARNING_FIXES
; 3376 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3377 : #else
; 3378 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetBuildin@6
	push	ebx
	mov	ebx, DWORD PTR _eBuildingClass$[esp+8]
	push	ebp
	npad	3
$LL4@GetBuildin@6:

; 3379 : #endif
; 3380 : 	{
; 3381 : 		// Do we have this policy?
; 3382 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	esi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN3@GetBuildin@6
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN24@GetBuildin@6
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN3@GetBuildin@6
$LN24@GetBuildin@6:

; 3383 : 		{
; 3384 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassTourismModifier(eBuildingClass);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+1036]
	add	eax, DWORD PTR [esi+ebx*4]
$LN3@GetBuildin@6:
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL4@GetBuildin@6
	pop	ebp
	pop	ebx
$LN2@GetBuildin@6:
	pop	edi
	pop	esi

; 3385 : 		}
; 3386 : 	}
; 3387 : 
; 3388 : 	return rtnValue;
; 3389 : }

	ret	4
?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassTourismModifier
_TEXT	ENDS
PUBLIC	?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
; Function compile flags: /Ogtpy
;	COMDAT ?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ PROC ; CvPlayerPolicies::HasPolicyEncouragingGarrisons, COMDAT
; _this$ = ecx

; 3393 : {

	push	ebx
	push	esi

; 3394 : #ifdef AUI_WARNING_FIXES
; 3395 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3396 : #else
; 3397 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	esi, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	xor	edx, edx
	push	edi
	test	eax, -4					; fffffffcH
	jle	SHORT $LN9@HasPolicyE
	mov	edi, DWORD PTR [ecx+12]
$LL11@HasPolicyE:

; 3398 : #endif
; 3399 : 	{
; 3400 : 		// Do we have this policy?
; 3401 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	cmp	BYTE PTR [edi+edx], 0
	je	SHORT $LN10@HasPolicyE
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax+edx*4]
	cmp	eax, -1
	je	SHORT $LN41@HasPolicyE
	mov	ebx, DWORD PTR [ecx+28]
	cmp	BYTE PTR [eax+ebx], 0
	jne	SHORT $LN10@HasPolicyE
$LN41@HasPolicyE:

; 3402 : 		{
; 3403 : 			CvPolicyEntry* pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+edx*4]

; 3404 : 			if(pPolicy->GetGarrisonedCityRangeStrikeModifier() > 0)

	cmp	DWORD PTR [eax+532], 0
	jg	SHORT $LN36@HasPolicyE

; 3407 : 			}
; 3408 : 			else if(pPolicy->GetCulturePerGarrisonedUnit() > 0)

	cmp	DWORD PTR [eax+484], 0
	jg	SHORT $LN36@HasPolicyE

; 3409 : 			{
; 3410 : 				return true;
; 3411 : 			}
; 3412 : 			else if(pPolicy->GetHappinessPerGarrisonedUnit() > 0)

	cmp	DWORD PTR [eax+480], 0
	jg	SHORT $LN36@HasPolicyE

; 3413 : 			{
; 3414 : 				return true;
; 3415 : 			}
; 3416 : 			else if(pPolicy->IsGarrisonFreeMaintenance())

	cmp	BYTE PTR [eax+878], 0
	jne	SHORT $LN36@HasPolicyE
$LN10@HasPolicyE:

; 3394 : #ifdef AUI_WARNING_FIXES
; 3395 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3396 : #else
; 3397 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	inc	edx
	sar	eax, 2
	cmp	edx, eax
	jl	SHORT $LL11@HasPolicyE
$LN9@HasPolicyE:
	pop	edi
	pop	esi

; 3417 : 			{
; 3418 : 				return true;
; 3419 : 			}
; 3420 : 		}
; 3421 : 	}
; 3422 : 
; 3423 : 	return false;

	xor	al, al
	pop	ebx

; 3424 : }

	ret	0
$LN36@HasPolicyE:
	pop	edi
	pop	esi

; 3405 : 			{
; 3406 : 				return true;

	mov	al, 1
	pop	ebx

; 3424 : }

	ret	0
?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ ENDP ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
_TEXT	ENDS
PUBLIC	?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::HasPolicyGrantingReformationBelief
; Function compile flags: /Ogtpy
;	COMDAT ?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ PROC ; CvPlayerPolicies::HasPolicyGrantingReformationBelief, COMDAT
; _this$ = ecx

; 3428 : {

	push	ebx
	push	esi

; 3429 : #ifdef AUI_WARNING_FIXES
; 3430 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3431 : #else
; 3432 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	esi, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, DWORD PTR [esi+4]
	xor	eax, eax
	push	edi
	test	edx, -4					; fffffffcH
	jle	SHORT $LN3@HasPolicyG
	mov	edi, DWORD PTR [ecx+12]
	npad	7
$LL5@HasPolicyG:

; 3433 : #endif
; 3434 : 	{
; 3435 : 		// Do we have this policy?
; 3436 : 		if (m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	cmp	BYTE PTR [edi+eax], 0
	je	SHORT $LN4@HasPolicyG
	mov	edx, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edx, -1
	je	SHORT $LN26@HasPolicyG
	mov	ebx, DWORD PTR [ecx+28]
	cmp	BYTE PTR [edx+ebx], 0
	jne	SHORT $LN4@HasPolicyG
$LN26@HasPolicyG:

; 3437 : 		{
; 3438 : 			CvPolicyEntry *pPolicy = m_pPolicies->GetPolicyEntry(i);
; 3439 : 			if (pPolicy->IsAddReformationBelief())

	mov	edx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	BYTE PTR [edx+881], 0
	jne	SHORT $LN24@HasPolicyG
$LN4@HasPolicyG:

; 3429 : #ifdef AUI_WARNING_FIXES
; 3430 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3431 : #else
; 3432 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edx, DWORD PTR [esi+8]
	sub	edx, DWORD PTR [esi+4]
	inc	eax
	sar	edx, 2
	cmp	eax, edx
	jl	SHORT $LL5@HasPolicyG
$LN3@HasPolicyG:
	pop	edi
	pop	esi

; 3442 : 			}
; 3443 : 		}
; 3444 : 	}
; 3445 : 
; 3446 : 	return false;

	xor	al, al
	pop	ebx

; 3447 : }

	ret	0
$LN24@HasPolicyG:
	pop	edi
	pop	esi

; 3440 : 			{
; 3441 : 				return true;

	mov	al, 1
	pop	ebx

; 3447 : }

	ret	0
?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ ENDP ; CvPlayerPolicies::HasPolicyGrantingReformationBelief
_TEXT	ENDS
PUBLIC	?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ ; CvPlayerPolicies::GetWeLoveTheKingString
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$1
__ehfuncinfo$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
$T234141 = -44						; size = 4
_str$225710 = -40					; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ PROC ; CvPlayerPolicies::GetWeLoveTheKingString, COMDAT
; _this$ = ecx

; 3451 : {

	push	-1
	push	__ehhandler$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T234141[esp+56], ebx

; 3452 : 	CvString rtnValue;

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+52]
	push	edi
	mov	edi, ecx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3479 : 	}
; 3480 : 
; 3481 : 	return rtnValue;

	mov	eax, DWORD PTR [edi+52]
	mov	esi, DWORD PTR [eax+8]
	sub	esi, DWORD PTR [eax+4]
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	sar	esi, 2
	sub	esi, 1
	mov	DWORD PTR $T234141[esp+60], 1
	js	$LN48@GetWeLoveT
$LL5@GetWeLoveT:

; 3466 : 	{
; 3467 : 		// Do we have this policy?
; 3468 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	eax, DWORD PTR [edi+12]
	cmp	BYTE PTR [esi+eax], bl
	je	SHORT $LN4@GetWeLoveT
	mov	ecx, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [ecx+esi*4]
	cmp	eax, -1
	je	SHORT $LN47@GetWeLoveT
	mov	edx, DWORD PTR [edi+28]
	cmp	BYTE PTR [eax+edx], bl
	jne	SHORT $LN4@GetWeLoveT
$LN47@GetWeLoveT:

; 3469 : 		{
; 3470 : 			// Does it have a string for us?
; 3471 : 			CvString str = m_pPolicies->GetPolicyEntry(i)->GetWeLoveTheKing();

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi*4]
	lea	ecx, DWORD PTR [eax+920]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	cmp	eax, ebx
	jne	SHORT $LN32@GetWeLoveT
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@GetWeLoveT:
	push	eax
	lea	ecx, DWORD PTR _str$225710[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[esp+68], 1

; 3472 : #endif
; 3473 : 			if(str.length() > 0)

	cmp	DWORD PTR _str$225710[esp+80], ebx
	ja	SHORT $LN45@GetWeLoveT

; 3477 : 			}
; 3478 : 		}

	lea	ecx, DWORD PTR _str$225710[esp+60]
	mov	BYTE PTR __$EHRec$[esp+68], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@GetWeLoveT:

; 3453 : 
; 3454 : 	// Policies are arranged from least to most advanced in XML
; 3455 : 	//   So loop from back to front until we find a string
; 3456 : #ifdef AUI_WARNING_FIXES
; 3457 : 	for (uint i = m_pPolicies->GetNumPolicies(); i > 0; i--)
; 3458 : 	{
; 3459 : 		// Do we have this policy?
; 3460 : 		if (m_pabHasPolicy[i - 1] && !IsPolicyBlocked((PolicyTypes)(i - 1)))
; 3461 : 		{
; 3462 : 			// Does it have a string for us?
; 3463 : 			CvString str = m_pPolicies->GetPolicyEntry(i - 1)->GetWeLoveTheKing();
; 3464 : #else
; 3465 : 	for(int i = m_pPolicies->GetNumPolicies() - 1; i >= 0; i--)

	sub	esi, 1
	jns	SHORT $LL5@GetWeLoveT

; 3472 : #endif
; 3473 : 			if(str.length() > 0)

	jmp	SHORT $LN48@GetWeLoveT
$LN45@GetWeLoveT:

; 3474 : 			{
; 3475 : 				rtnValue = str;

	lea	edx, DWORD PTR _str$225710[esp+60]
	push	edx
	mov	ecx, ebp
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3476 : 				break;  // All done when find the first one

	lea	ecx, DWORD PTR _str$225710[esp+60]
	mov	BYTE PTR __$EHRec$[esp+68], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN48@GetWeLoveT:

; 3482 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T234141[ebp]
	and	eax, 1
	je	$LN9@GetWeLoveT
	and	DWORD PTR $T234141[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN9@GetWeLoveT:
	ret	0
__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR _str$225710[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ ENDP ; CvPlayerPolicies::GetWeLoveTheKingString
PUBLIC	?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z ; CvPlayerPolicies::GetTourismFromUnitCreation
; Function compile flags: /Ogtpy
;	COMDAT ?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z PROC ; CvPlayerPolicies::GetTourismFromUnitCreation, COMDAT
; _this$ = ecx

; 3512 : {

	push	esi
	push	edi

; 3513 : 	int iTourism = 0;
; 3514 : 
; 3515 : #ifdef AUI_WARNING_FIXES
; 3516 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3517 : #else
; 3518 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	edi, DWORD PTR [ecx+52]
	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN3@GetTourism@2
	push	ebx
	mov	ebx, DWORD PTR _eUnitClass$[esp+8]
	push	ebp
	npad	3
$LL5@GetTourism@2:

; 3519 : #endif
; 3520 : 	{
; 3521 : 		// Do we have this policy?
; 3522 : 		if (m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	esi, DWORD PTR [ecx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN4@GetTourism@2
	mov	esi, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [esi+edx*4]
	cmp	esi, -1
	je	SHORT $LN31@GetTourism@2
	mov	ebp, DWORD PTR [ecx+28]
	cmp	BYTE PTR [esi+ebp], 0
	jne	SHORT $LN4@GetTourism@2
$LN31@GetTourism@2:

; 3523 : 		{
; 3524 : 			CvPolicyEntry *pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	esi, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx*4]

; 3525 : 			if (pPolicy->GetTourismByUnitClassCreated(eUnitClass) > 0)

	mov	esi, DWORD PTR [esi+1048]
	test	esi, esi
	je	SHORT $LN4@GetTourism@2
	mov	esi, DWORD PTR [esi+ebx*4]
	test	esi, esi
	jle	SHORT $LN4@GetTourism@2

; 3526 : 			{
; 3527 : 				iTourism += pPolicy->GetTourismByUnitClassCreated(eUnitClass);

	add	eax, esi
$LN4@GetTourism@2:

; 3513 : 	int iTourism = 0;
; 3514 : 
; 3515 : #ifdef AUI_WARNING_FIXES
; 3516 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3517 : #else
; 3518 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]
	inc	edx
	sar	esi, 2
	cmp	edx, esi
	jl	SHORT $LL5@GetTourism@2
	pop	ebp
	pop	ebx
$LN3@GetTourism@2:
	pop	edi
	pop	esi

; 3528 : 			}
; 3529 : 		}
; 3530 : 	}
; 3531 : 
; 3532 : 	return iTourism;
; 3533 : }

	ret	4
?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z ENDP ; CvPlayerPolicies::GetTourismFromUnitCreation
_TEXT	ENDS
PUBLIC	?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ	; CvPlayerPolicies::GetNextPolicyCost
EXTRN	?getPolicyPercent@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getPolicyPercent
EXTRN	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvPlayer::getHandicapInfo
EXTRN	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getCulturePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getPolicyCostModifier@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getPolicyCostModifier
EXTRN	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z:PROC	; CvPlayer::GetMaxEffectiveCities
EXTRN	?GetNumCitiesPolicyCostDiscount@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetNumCitiesPolicyCostDiscount
EXTRN	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::GetNumCitiesPolicyCostMod
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	_pow:PROC
EXTRN	?GetNumFreeTenets@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetNumFreeTenets
EXTRN	?GetNumFreePolicies@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumFreePolicies
EXTRN	?GetNumFreePoliciesEver@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumFreePoliciesEver
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ
_TEXT	SEGMENT
tv287 = -4						; size = 4
_iNumCities$ = -4					; size = 4
?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ PROC	; CvPlayerPolicies::GetNextPolicyCost, COMDAT
; _this$ = ecx

; 3537 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3538 : 	int iNumPolicies = GetNumPoliciesOwned();

	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	push	edi
	xor	edi, edi
	xor	ecx, ecx
	test	edx, -4					; fffffffcH
	jle	SHORT $LN5@GetNextPol
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+12]
	sar	edx, 2
$LL7@GetNextPol:
	cmp	BYTE PTR [eax+ecx], 0
	je	SHORT $LN6@GetNextPol
	inc	edi
$LN6@GetNextPol:
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL7@GetNextPol
$LN5@GetNextPol:

; 3539 : 
; 3540 : 	// Reduce count by however many free Policies we've had in this game
; 3541 : 	iNumPolicies -= (m_pPlayer->GetNumFreePoliciesEver() - m_pPlayer->GetNumFreePolicies() - m_pPlayer->GetNumFreeTenets());

	mov	ecx, DWORD PTR [esi+60]
	call	?GetNumFreePoliciesEver@CvPlayer@@QBEHXZ ; CvPlayer::GetNumFreePoliciesEver
	mov	ecx, DWORD PTR [esi+60]
	sub	edi, eax
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	mov	ecx, DWORD PTR [esi+60]
	add	edi, eax
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets

; 3542 : 
; 3543 : 	// Each branch we unlock (after the first) costs us a buy, so add that in; JON: not any more
; 3544 : 	//if (GetNumPolicyBranchesUnlocked() > 0)
; 3545 : 	//{
; 3546 : 	//	iNumPolicies += (GetNumPolicyBranchesUnlocked() - 1);
; 3547 : 	//}
; 3548 : 
; 3549 : 	int iCost = 0;
; 3550 : 	iCost += (iNumPolicies* /*7*/ GC.getPOLICY_COST_INCREASE_TO_BE_EXPONENTED());
; 3551 : 
; 3552 : 	// Exponential cost scaling
; 3553 : 	iCost = (int) pow((double) iCost, (double) /*1.70*/ GC.getPOLICY_COST_EXPONENT());

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8136
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6968
	add	eax, edi
	imul	ecx, eax
	sub	esp, 16					; 00000010H
	mov	DWORD PTR tv287[esp+36], ecx
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR tv287[esp+36]
	fstp	QWORD PTR [esp]
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2_sse_excpt

; 3554 : 
; 3555 : 	// Base cost that doesn't get exponent-ed
; 3556 : 	iCost += /*25*/ GC.getBASE_POLICY_COST();
; 3557 : 
; 3558 : 	// Mod for City Count
; 3559 : 	int iMod = GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod();	// Default is 40, gets smaller on larger maps

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, eax
	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6964
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ ; CvWorldInfo::GetNumCitiesPolicyCostMod

; 3560 : 	int iPolicyModDiscount = m_pPlayer->GetNumCitiesPolicyCostDiscount();

	mov	ecx, DWORD PTR [esi+60]
	mov	ebp, eax
	call	?GetNumCitiesPolicyCostDiscount@CvPlayer@@QBEHXZ ; CvPlayer::GetNumCitiesPolicyCostDiscount

; 3561 : 	if(iPolicyModDiscount != 0)

	test	eax, eax
	je	SHORT $LN1@GetNextPol

; 3562 : 	{
; 3563 : 		iMod = iMod * (100 + iPolicyModDiscount);

	lea	ecx, DWORD PTR [eax+100]
	imul	ecx, ebp

; 3564 : 		iMod /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax
$LN1@GetNextPol:

; 3565 : 	}
; 3566 : 
; 3567 : 	int iNumCities = m_pPlayer->GetMaxEffectiveCities();

	mov	ecx, DWORD PTR [esi+60]
	push	0
	call	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z ; CvPlayer::GetMaxEffectiveCities

; 3568 : 
; 3569 : 	iMod = (iCost * (iNumCities - 1) * iMod);
; 3570 : 	iMod /= 100;
; 3571 : 	iCost += iMod;
; 3572 : 
; 3573 : 	// Policy Cost Mod
; 3574 : 	iCost *= (100 + m_pPlayer->getPolicyCostModifier());

	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR _iNumCities$[esp+20], eax
	call	?getPolicyCostModifier@CvPlayer@@QBEHXZ	; CvPlayer::getPolicyCostModifier
	mov	ecx, DWORD PTR _iNumCities$[esp+20]
	dec	ecx
	imul	ecx, ebp

; 3575 : 	iCost /= 100;

	imul	ecx, ebx
	mov	edi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	edi, 100				; 00000064H
	add	ecx, ebx
	imul	edi, ecx

; 3576 : 
; 3577 : 	// Game Speed Mod
; 3578 : 	iCost *= GC.getGame().getGameSpeedInfo().getCulturePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	mov	ecx, eax
	imul	ecx, edi

; 3579 : 	iCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3580 : 
; 3581 : 	// Handicap Mod
; 3582 : 	iCost *= m_pPlayer->getHandicapInfo().getPolicyPercent();

	mov	ecx, DWORD PTR [esi+60]
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	ecx, eax
	call	?getPolicyPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getPolicyPercent
	mov	ecx, eax
	imul	ecx, edi

; 3583 : 	iCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3584 : 
; 3585 : 	// Make the number nice and even
; 3586 : 	int iDivisor = /*5*/ GC.getPOLICY_COST_VISIBLE_DIVISOR();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6972
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 3587 : 	iCost /= iDivisor;

	cdq
	idiv	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3588 : 	iCost *= iDivisor;

	imul	eax, ecx

; 3589 : 
; 3590 : 	return iCost;
; 3591 : }

	pop	ecx
	ret	0
?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ ENDP	; CvPlayerPolicies::GetNextPolicyCost
_TEXT	ENDS
PUBLIC	?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesUnlocked
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ PROC ; CvPlayerPolicies::GetNumPolicyBranchesUnlocked, COMDAT
; _this$ = ecx

; 3969 : 	int iCount = 0;
; 3970 : 
; 3971 : #ifdef AUI_WARNING_FIXES
; 3972 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 3973 : #else
; 3974 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	edx, DWORD PTR [ecx+52]
	push	esi
	push	edi
	mov	edi, DWORD PTR [edx+24]
	sub	edi, DWORD PTR [edx+20]
	xor	eax, eax
	xor	esi, esi
	test	edi, -4					; fffffffcH
	jle	SHORT $LN2@GetNumPoli@3
	mov	edi, DWORD PTR [edx+24]
	sub	edi, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [ecx+24]
	sar	edi, 2
$LL4@GetNumPoli@3:

; 3975 : #endif
; 3976 : 	{
; 3977 : 		if(IsPolicyBranchUnlocked((PolicyBranchTypes) iBranchLoop))

	cmp	BYTE PTR [ecx+esi], 0
	je	SHORT $LN3@GetNumPoli@3

; 3978 : 		{
; 3979 : 			iCount++;

	inc	eax
$LN3@GetNumPoli@3:

; 3969 : 	int iCount = 0;
; 3970 : 
; 3971 : #ifdef AUI_WARNING_FIXES
; 3972 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 3973 : #else
; 3974 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@GetNumPoli@3
$LN2@GetNumPoli@3:
	pop	edi
	pop	esi

; 3980 : 		}
; 3981 : 	}
; 3982 : 
; 3983 : 	return iCount;
; 3984 : }

	ret	0
?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ ENDP ; CvPlayerPolicies::GetNumPolicyBranchesUnlocked
_TEXT	ENDS
PUBLIC	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
EXTRN	?processPolicies@CvPlayer@@IAEXW4PolicyTypes@@H@Z:PROC ; CvPlayer::processPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z
_TEXT	SEGMENT
_eBranchType$ = 8					; size = 4
_bValue$ = 12						; size = 1
?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z PROC ; CvPlayerPolicies::SetPolicyBranchBlocked, COMDAT
; _this$ = ecx

; 4109 : {

	push	ebx
	push	esi

; 4110 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4111 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4112 : 
; 4113 : 	CvPolicyBranchEntry* pkPolicyBranchEntry = GC.getPolicyBranchInfo(eBranchType);

	mov	esi, DWORD PTR _eBranchType$[esp+4]
	push	edi
	mov	edi, ecx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	ebx, eax

; 4114 : 	if(pkPolicyBranchEntry)

	test	ebx, ebx
	je	$LN5@SetPolicyB

; 4115 : 	{
; 4116 : 		if(bValue != IsPolicyBranchBlocked(eBranchType))

	mov	eax, DWORD PTR [edi+28]
	mov	cl, BYTE PTR _bValue$[esp+8]
	add	eax, esi
	cmp	cl, BYTE PTR [eax]
	je	SHORT $LN5@SetPolicyB

; 4117 : 		{
; 4118 : 			m_pabPolicyBranchBlocked[eBranchType] = bValue;
; 4119 : 
; 4120 : 			int iPolicyEffectChange = bValue ? -1 : 1;

	xor	edx, edx
	test	cl, cl
	sete	dl
	push	ebp
	mov	BYTE PTR [eax], cl
	lea	edx, DWORD PTR [edx+edx-1]
	mov	ebp, edx

; 4121 : 
; 4122 : 			if(iPolicyEffectChange != 0)

	test	ebp, ebp
	je	SHORT $LN33@SetPolicyB

; 4123 : 			{
; 4124 : 				// Set Policies in this branch as blocked
; 4125 : #ifdef AUI_WARNING_FIXES
; 4126 : 				for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4127 : #else
; 4128 : 				for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN33@SetPolicyB
$LL7@SetPolicyB:

; 4129 : #endif
; 4130 : 				{
; 4131 : 					const PolicyTypes ePolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 4132 : 					CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 4133 : 					if(pkPolicyInfo)

	test	eax, eax
	je	SHORT $LN6@SetPolicyB

; 4134 : 					{
; 4135 : 						if(eBranchType == (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType() ||	// Branch type matches
; 4136 : 						        pkPolicyBranchEntry->GetFreePolicy() == ePolicy ||		// Free Policy with this branch
; 4137 : 						        pkPolicyBranchEntry->GetFreeFinishingPolicy() == ePolicy)

	mov	edx, DWORD PTR _eBranchType$[esp+12]
	cmp	edx, DWORD PTR [eax+820]
	je	SHORT $LN2@SetPolicyB
	cmp	DWORD PTR [ebx+264], esi
	je	SHORT $LN2@SetPolicyB
	cmp	DWORD PTR [ebx+268], esi
	jne	SHORT $LN6@SetPolicyB
$LN2@SetPolicyB:

; 4138 : 						{
; 4139 : 							//ChangePolicyBlockedCount(ePolicy, iPolicyEffectChange);
; 4140 : 
; 4141 : 							// Activate/Deactivate Policies
; 4142 : 							if(HasPolicy(ePolicy))

	mov	eax, DWORD PTR [edi+12]
	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN6@SetPolicyB

; 4143 : 							{
; 4144 : 								GetPlayer()->processPolicies(ePolicy, iPolicyEffectChange);

	mov	ecx, DWORD PTR [edi+60]
	push	ebp
	push	esi
	call	?processPolicies@CvPlayer@@IAEXW4PolicyTypes@@H@Z ; CvPlayer::processPolicies
$LN6@SetPolicyB:
	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL7@SetPolicyB
$LN33@SetPolicyB:
	pop	ebp
$LN5@SetPolicyB:
	pop	edi
	pop	esi
	pop	ebx

; 4145 : 							}
; 4146 : 						}
; 4147 : 					}
; 4148 : 				}
; 4149 : 			}
; 4150 : 		}
; 4151 : 	}
; 4152 : }

	ret	8
?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ENDP ; CvPlayerPolicies::SetPolicyBranchBlocked
_TEXT	ENDS
PUBLIC	?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::ClearPolicyBranch
EXTRN	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z:PROC ; CvPlayer::setHasPolicy
; Function compile flags: /Ogtpy
;	COMDAT ?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranchType$ = 8					; size = 4
?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::ClearPolicyBranch, COMDAT
; _this$ = ecx

; 4202 : {

	push	esi
	push	edi
	mov	edi, ecx

; 4203 : 	// count the policies within the branch
; 4204 : #ifdef AUI_WARNING_FIXES
; 4205 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4206 : #else
; 4207 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN3@ClearPolic
	push	ebx
	mov	ebx, DWORD PTR _eBranchType$[esp+8]
	npad	4
$LL5@ClearPolic:

; 4208 : #endif
; 4209 : 	{
; 4210 : 		const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 4211 : 		CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 4212 : 		if(pkLoopPolicyInfo)

	test	eax, eax
	je	SHORT $LN4@ClearPolic

; 4213 : 		{
; 4214 : 			PolicyBranchTypes eLoopBranch = (PolicyBranchTypes)pkLoopPolicyInfo->GetPolicyBranchType();
; 4215 : 			if (eLoopBranch == eBranchType)

	cmp	DWORD PTR [eax+820], ebx
	jne	SHORT $LN4@ClearPolic

; 4216 : 			{
; 4217 : 				m_pPlayer->setHasPolicy(eLoopPolicy, false);

	mov	ecx, DWORD PTR [edi+60]
	push	0
	push	esi
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
$LN4@ClearPolic:
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	inc	esi
	sar	edx, 2
	cmp	esi, edx
	jl	SHORT $LL5@ClearPolic
	pop	ebx
$LN3@ClearPolic:
	pop	edi
	pop	esi

; 4218 : 			}
; 4219 : 		}
; 4220 : 	}
; 4221 : }

	ret	4
?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::ClearPolicyBranch
_TEXT	ENDS
PUBLIC	?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesFinished
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ PROC ; CvPlayerPolicies::GetNumPolicyBranchesFinished, COMDAT
; _this$ = ecx

; 4226 : 	int iNumBranchesFinished = 0;
; 4227 : 
; 4228 : 	PolicyBranchTypes eLoopBranch;
; 4229 : #ifdef AUI_WARNING_FIXES
; 4230 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4231 : #else
; 4232 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	edx, DWORD PTR [ecx+52]
	push	esi
	push	edi
	mov	edi, DWORD PTR [edx+24]
	sub	edi, DWORD PTR [edx+20]
	xor	eax, eax
	xor	esi, esi
	test	edi, -4					; fffffffcH
	jle	SHORT $LN2@GetNumPoli@4
	mov	edi, DWORD PTR [edx+24]
	sub	edi, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [ecx+32]
	sar	edi, 2
$LL4@GetNumPoli@4:

; 4233 : #endif
; 4234 : 	{
; 4235 : 		eLoopBranch = (PolicyBranchTypes) iBranchLoop;
; 4236 : 
; 4237 : 		if(IsPolicyBranchFinished(eLoopBranch))

	cmp	BYTE PTR [ecx+esi], 0
	je	SHORT $LN3@GetNumPoli@4

; 4238 : 		{
; 4239 : 			iNumBranchesFinished++;

	inc	eax
$LN3@GetNumPoli@4:

; 4226 : 	int iNumBranchesFinished = 0;
; 4227 : 
; 4228 : 	PolicyBranchTypes eLoopBranch;
; 4229 : #ifdef AUI_WARNING_FIXES
; 4230 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4231 : #else
; 4232 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@GetNumPoli@4
$LN2@GetNumPoli@4:
	pop	edi
	pop	esi

; 4240 : 		}
; 4241 : 	}
; 4242 : 
; 4243 : 	return iNumBranchesFinished;
; 4244 : }

	ret	0
?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ ENDP ; CvPlayerPolicies::GetNumPolicyBranchesFinished
_TEXT	ENDS
PUBLIC	?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::WillFinishBranchIfAdopted
; Function compile flags: /Ogtpy
;	COMDAT ?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::WillFinishBranchIfAdopted, COMDAT
; _this$ = ecx

; 4320 : {

	push	ebx
	push	ebp

; 4321 : 	PolicyBranchTypes eBranchType = (PolicyBranchTypes)m_pPolicies->GetPolicyEntry(eType)->GetPolicyBranchType();

	mov	ebp, DWORD PTR _eType$[esp+4]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+ebp*4]
	mov	ebx, DWORD PTR [edx+820]

; 4322 : 
; 4323 : 	if(eBranchType != NO_POLICY_BRANCH_TYPE)

	cmp	ebx, -1
	je	SHORT $LN8@WillFinish

; 4324 : 	{
; 4325 : 		// Is the branch this policy is in finished?
; 4326 : #ifdef AUI_WARNING_FIXES
; 4327 : 		for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4328 : #else
; 4329 : 		for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	push	esi
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN5@WillFinish
	npad	2
$LL7@WillFinish:

; 4330 : #endif
; 4331 : 		{
; 4332 : 			const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 4333 : 
; 4334 : 			CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 4335 : 			if(pkLoopPolicyInfo)

	test	eax, eax
	je	SHORT $LN6@WillFinish

; 4336 : 			{
; 4337 : 				// This policy belongs to our branch
; 4338 : 				if(pkLoopPolicyInfo->GetPolicyBranchType() == eBranchType)

	cmp	DWORD PTR [eax+820], ebx
	jne	SHORT $LN6@WillFinish

; 4339 : 				{
; 4340 : 					// We don't have this policy!
; 4341 : 					if(!HasPolicy(eLoopPolicy))

	mov	edx, DWORD PTR [edi+12]
	cmp	BYTE PTR [esi+edx], 0
	jne	SHORT $LN6@WillFinish

; 4342 : 					{
; 4343 : 						// Is it this policy passed in?
; 4344 : 						if(eLoopPolicy != eType)

	cmp	esi, ebp
	jne	SHORT $LN28@WillFinish
$LN6@WillFinish:

; 4324 : 	{
; 4325 : 		// Is the branch this policy is in finished?
; 4326 : #ifdef AUI_WARNING_FIXES
; 4327 : 		for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4328 : #else
; 4329 : 		for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL7@WillFinish
$LN5@WillFinish:
	pop	esi
	pop	edi
	pop	ebp

; 4348 : 						}
; 4349 : 					}
; 4350 : 				}
; 4351 : 			}
; 4352 : 		}
; 4353 : 
; 4354 : 		// Didn't find any policy in this branch that we didn't have covered.  This will finish it
; 4355 : 		return true;

	mov	al, 1
	pop	ebx

; 4359 : }

	ret	4
$LN28@WillFinish:
	pop	esi
	pop	edi
	pop	ebp

; 4345 : 						{
; 4346 : 							// No, so this one won't finish branch
; 4347 : 							return false;

	xor	al, al
	pop	ebx

; 4359 : }

	ret	4
$LN8@WillFinish:
	pop	edi
	pop	ebp

; 4356 : 	}
; 4357 : 
; 4358 : 	return false;

	xor	al, al
	pop	ebx

; 4359 : }

	ret	4
?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::WillFinishBranchIfAdopted
_TEXT	ENDS
PUBLIC	?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ PROC ; CvPlayerPolicies::GetNumPolicyBranchesAllowed, COMDAT
; _this$ = ecx

; 4393 : 	return /*2*/ GC.getNUM_POLICY_BRANCHES_ALLOWED() + GetNumExtraBranches();

	mov	eax, DWORD PTR [ecx+64]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6256

; 4394 : }

	ret	0
?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ ENDP ; CvPlayerPolicies::GetNumPolicyBranchesAllowed
_TEXT	ENDS
PUBLIC	?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z ; CvPlayerPolicies::DoNewPolicyPickedForHistory
; Function compile flags: /Ogtpy
;	COMDAT ?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z
_TEXT	SEGMENT
_ePolicy$ = 8						; size = 4
?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::DoNewPolicyPickedForHistory, COMDAT
; _this$ = ecx

; 4462 : {

	push	ebp

; 4463 : 	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	mov	ebp, DWORD PTR _ePolicy$[esp]
	push	esi
	mov	esi, ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 4464 : 	if(pkPolicyInfo == NULL)

	test	eax, eax
	je	$LN44@DoNewPolic
	push	ebx

; 4465 : 		return;
; 4466 : 
; 4467 : 	PolicyBranchTypes eNewBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	ebx, DWORD PTR [eax+820]

; 4468 : 
; 4469 : 	// Are we a free branch policy?
; 4470 : 	if(eNewBranch == NO_POLICY_BRANCH_TYPE)

	cmp	ebx, -1
	jne	SHORT $LN9@DoNewPolic

; 4471 : 	{
; 4472 : #ifdef AUI_WARNING_FIXES
; 4473 : 		for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4474 : #else
; 4475 : 		for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	push	edi
	xor	edi, edi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN50@DoNewPolic
	npad	2
$LL11@DoNewPolic:

; 4476 : #endif
; 4477 : 		{
; 4478 : 			const PolicyBranchTypes eLoopBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 4479 : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eLoopBranch);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 4480 : 			if(pkPolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN10@DoNewPolic

; 4481 : 			{
; 4482 : 				// Yes, it's a freebie
; 4483 : 				if(pkPolicyBranchInfo->GetFreePolicy() == ePolicy)

	cmp	DWORD PTR [eax+264], ebp
	je	SHORT $LN47@DoNewPolic
$LN10@DoNewPolic:

; 4471 : 	{
; 4472 : #ifdef AUI_WARNING_FIXES
; 4473 : 		for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4474 : #else
; 4475 : 		for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	edi
	sar	edx, 2
	cmp	edi, edx
	jl	SHORT $LL11@DoNewPolic

; 4481 : 			{
; 4482 : 				// Yes, it's a freebie
; 4483 : 				if(pkPolicyBranchInfo->GetFreePolicy() == ePolicy)

	jmp	SHORT $LN50@DoNewPolic
$LN47@DoNewPolic:

; 4484 : 				{
; 4485 : 					eNewBranch = eLoopBranch;

	mov	ebx, edi
$LN50@DoNewPolic:
	pop	edi
$LN9@DoNewPolic:

; 4486 : 					break;
; 4487 : 				}
; 4488 : 			}
; 4489 : 		}
; 4490 : 	}
; 4491 : 
; 4492 : 	// Have we filled up the slots yet?
; 4493 : 	if(GetBranchPicked1() == NO_POLICY_BRANCH_TYPE)

	mov	ecx, DWORD PTR [esi+68]
	cmp	ecx, -1

; 4494 : 	{
; 4495 : 		SetBranchPicked1(eNewBranch);

	je	SHORT $LN51@DoNewPolic

; 4496 : 	}
; 4497 : 	else if(GetBranchPicked2() == NO_POLICY_BRANCH_TYPE)

	mov	eax, DWORD PTR [esi+72]
	cmp	eax, -1
	jne	SHORT $LN4@DoNewPolic

; 4498 : 	{
; 4499 : 		SetBranchPicked2(eNewBranch);

	mov	DWORD PTR [esi+72], ebx
	pop	ebx
	pop	esi
	pop	ebp

; 4512 : 	}
; 4513 : }

	ret	4
$LN4@DoNewPolic:

; 4500 : 	}
; 4501 : 	else if(GetBranchPicked3() == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR [esi+76], -1
	jne	SHORT $LN2@DoNewPolic

; 4502 : 	{
; 4503 : 		SetBranchPicked3(eNewBranch);

	mov	DWORD PTR [esi+76], ebx
	pop	ebx
	pop	esi
	pop	ebp

; 4512 : 	}
; 4513 : }

	ret	4
$LN2@DoNewPolic:

; 4504 : 	}
; 4505 : 
; 4506 : 	// if we've gotten here it means that all the slots are filled already, so we gotta bump some stuff
; 4507 : 	else
; 4508 : 	{
; 4509 : 		SetBranchPicked3(GetBranchPicked2());

	mov	DWORD PTR [esi+76], eax

; 4510 : 		SetBranchPicked2(GetBranchPicked1());

	mov	DWORD PTR [esi+72], ecx
$LN51@DoNewPolic:

; 4511 : 		SetBranchPicked1(eNewBranch);

	mov	DWORD PTR [esi+68], ebx
	pop	ebx
$LN44@DoNewPolic:
	pop	esi
	pop	ebp

; 4512 : 	}
; 4513 : }

	ret	4
?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::DoNewPolicyPickedForHistory
_TEXT	ENDS
PUBLIC	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
; Function compile flags: /Ogtpy
;	COMDAT ?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetLateGamePolicyTree, COMDAT
; _this$ = ecx

; 4641 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4642 : 	PolicyBranchTypes eOurChoice = NO_POLICY_BRANCH_TYPE;
; 4643 : 
; 4644 : 	PolicyBranchTypes eLoopBranch;
; 4645 : #ifdef AUI_WARNING_FIXES
; 4646 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4647 : #else
; 4648 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	or	ebx, -1
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN19@GetLateGam
	npad	2
$LL5@GetLateGam:

; 4649 : #endif
; 4650 : 	{
; 4651 : 		eLoopBranch = (PolicyBranchTypes) iBranchLoop;
; 4652 : 
; 4653 : 		CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eLoopBranch);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 4654 : 		if(pkPolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN4@GetLateGam

; 4655 : 		{
; 4656 : 			if (pkPolicyBranchInfo->IsPurchaseByLevel() && IsPolicyBranchUnlocked(eLoopBranch))

	cmp	BYTE PTR [eax+280], 0
	je	SHORT $LN4@GetLateGam
	mov	edx, DWORD PTR [edi+24]
	cmp	BYTE PTR [esi+edx], 0
	jne	SHORT $LN17@GetLateGam
$LN4@GetLateGam:

; 4642 : 	PolicyBranchTypes eOurChoice = NO_POLICY_BRANCH_TYPE;
; 4643 : 
; 4644 : 	PolicyBranchTypes eLoopBranch;
; 4645 : #ifdef AUI_WARNING_FIXES
; 4646 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4647 : #else
; 4648 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL5@GetLateGam
$LN19@GetLateGam:
	pop	edi
	pop	esi

; 4657 : 			{
; 4658 : 				eOurChoice = eLoopBranch;
; 4659 : 				break;
; 4660 : 			}
; 4661 : 		}
; 4662 : 	}
; 4663 : 
; 4664 : 	return eOurChoice;

	mov	eax, ebx
	pop	ebx

; 4665 : }

	ret	0
$LN17@GetLateGam:
	pop	edi

; 4657 : 			{
; 4658 : 				eOurChoice = eLoopBranch;
; 4659 : 				break;
; 4660 : 			}
; 4661 : 		}
; 4662 : 	}
; 4663 : 
; 4664 : 	return eOurChoice;

	mov	eax, esi
	pop	esi
	pop	ebx

; 4665 : }

	ret	0
?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetLateGamePolicyTree
_TEXT	ENDS
PUBLIC	?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::IsTimeToChooseIdeology
EXTRN	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassCount
EXTRN	?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
; Function compile flags: /Ogtpy
;	COMDAT ?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
_pkGameBuildings$226271 = -4				; size = 4
?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ PROC	; CvPlayerPolicies::IsTimeToChooseIdeology, COMDAT
; _this$ = ecx

; 4669 : {

	push	ecx

; 4670 : 	PolicyBranchTypes eFreedomBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();
; 4671 : 	PolicyBranchTypes eAutocracyBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();
; 4672 : 	PolicyBranchTypes eOrderBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();
; 4673 : 	if (eFreedomBranch == NO_POLICY_BRANCH_TYPE || eAutocracyBranch == NO_POLICY_BRANCH_TYPE || eOrderBranch == NO_POLICY_BRANCH_TYPE)

	or	eax, -1
	push	ebp
	mov	ebp, ecx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376, eax
	je	$LN11@IsTimeToCh
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380, eax
	je	$LN11@IsTimeToCh
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384, eax
	je	$LN11@IsTimeToCh
	push	esi

; 4676 : 	}
; 4677 : 
; 4678 : 	if (m_pPlayer->GetCurrentEra() > GC.getInfoTypeForString("ERA_INDUSTRIAL"))

	push	0
	push	OFFSET $SG226269
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [ebp+60]
	mov	esi, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	cmp	eax, esi
	jle	SHORT $LN10@IsTimeToCh
	pop	esi

; 4679 : 	{
; 4680 : 		return true;

	mov	al, 1
	pop	ebp

; 4720 : }

	pop	ecx
	ret	0
$LN10@IsTimeToCh:
	push	ebx
	push	edi

; 4681 : 	}
; 4682 : 
; 4683 : 	// Check for the right number of buildings of a certain type (3 factories)
; 4684 : 	else
; 4685 : 	{
; 4686 : 		CvBuildingXMLEntries* pkGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings

; 4687 : 		CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(m_pPlayer->getCivilizationType());

	mov	ecx, DWORD PTR [ebp+60]
	mov	DWORD PTR _pkGameBuildings$226271[esp+20], eax
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ebx, eax

; 4688 : 		if(pkInfo)

	test	ebx, ebx
	je	SHORT $LN5@IsTimeToCh

; 4689 : 		{
; 4690 : 			// Find a building that triggers an ideology
; 4691 : 			// Loop through all building classes
; 4692 : #ifdef AUI_WARNING_FIXES
; 4693 : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4694 : #else
; 4695 : 			for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN5@IsTimeToCh
	npad	6
$LL25@IsTimeToCh:

; 4696 : #endif
; 4697 : 			{
; 4698 : 				const BuildingTypes eBuilding = static_cast<BuildingTypes>(pkInfo->getCivilizationBuildings(iI));

	push	esi
	mov	ecx, ebx
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings

; 4699 : 				CvBuildingEntry* pkBuildingInfo = NULL;
; 4700 : 				if(eBuilding != -1)

	cmp	eax, -1
	je	SHORT $LN6@IsTimeToCh

; 4701 : 				{
; 4702 : 					pkBuildingInfo = pkGameBuildings->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _pkGameBuildings$226271[esp+20]
	push	eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 4703 : 					if (pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN6@IsTimeToCh

; 4704 : 					{
; 4705 : 						int iIdeologyTriggerCount = pkBuildingInfo->GetXBuiltTriggersIdeologyChoice();

	mov	ecx, eax
	call	?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
	mov	edi, eax

; 4706 : 						if (iIdeologyTriggerCount > 0)

	test	edi, edi
	jle	SHORT $LN6@IsTimeToCh

; 4707 : 						{
; 4708 : 							if (m_pPlayer->getBuildingClassCount((BuildingClassTypes)iI) >= iIdeologyTriggerCount)

	mov	ecx, DWORD PTR [ebp+60]
	push	esi
	call	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassCount
	cmp	eax, edi
	jge	SHORT $LN22@IsTimeToCh
$LN6@IsTimeToCh:

; 4689 : 		{
; 4690 : 			// Find a building that triggers an ideology
; 4691 : 			// Loop through all building classes
; 4692 : #ifdef AUI_WARNING_FIXES
; 4693 : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4694 : #else
; 4695 : 			for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	esi, eax
	jl	SHORT $LL25@IsTimeToCh
$LN5@IsTimeToCh:
	pop	edi
	pop	ebx
	pop	esi

; 4711 : 							}
; 4712 : 						}
; 4713 : 					}
; 4714 : 				}
; 4715 : 			}
; 4716 : 		}
; 4717 : 	}
; 4718 : 
; 4719 : 	return false;

	xor	al, al
	pop	ebp

; 4720 : }

	pop	ecx
	ret	0
$LN22@IsTimeToCh:
	pop	edi
	pop	ebx
	pop	esi

; 4709 : 							{
; 4710 : 								return true;

	mov	al, 1
	pop	ebp

; 4720 : }

	pop	ecx
	ret	0
$LN11@IsTimeToCh:

; 4674 : 	{
; 4675 : 		return false;

	xor	al, al
	pop	ebp

; 4720 : }

	pop	ecx
	ret	0
?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ ENDP	; CvPlayerPolicies::IsTimeToChooseIdeology
_TEXT	ENDS
PUBLIC	?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z ; CvPlayerPolicies::GetTenet
EXTRN	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ:PROC ; CvGlobals::GetGamePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
_iLevel$ = 12						; size = 4
_iIndex$ = 16						; size = 4
?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z PROC ; CvPlayerPolicies::GetTenet, COMDAT
; _this$ = ecx

; 4753 : {

	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 4755 : 
; 4756 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies

; 4757 : #ifdef AUI_WARNING_FIXES
; 4758 : 	for (uint iI = 0; iI < pkPolicies->GetNumPolicies(); iI++)
; 4759 : #else
; 4760 : 	const int iNumPolicies = pkPolicies->GetNumPolicies();

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	sar	ecx, 2

; 4761 : 
; 4762 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN3@GetTenet

; 4754 : 	int iNumFound = 0;

	mov	esi, edx
$LL28@GetTenet:

; 4763 : #endif
; 4764 : 	{
; 4765 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));
; 4766 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	edx, DWORD PTR [esi]

; 4767 : 		if (pEntry && pEntry->GetPolicyBranchType() == eBranch && pEntry->GetLevel() == iLevel && HasPolicy(eTenet))

	test	edx, edx
	je	SHORT $LN4@GetTenet
	mov	ebp, DWORD PTR [edx+820]
	cmp	ebp, DWORD PTR _eBranch$[esp+12]
	jne	SHORT $LN4@GetTenet
	mov	ebp, DWORD PTR _iLevel$[esp+12]
	cmp	DWORD PTR [edx+276], ebp
	jne	SHORT $LN4@GetTenet
	mov	edx, DWORD PTR [ebx+12]
	cmp	BYTE PTR [eax+edx], 0
	je	SHORT $LN4@GetTenet

; 4768 : 		{
; 4769 : 			iNumFound++;

	inc	edi

; 4770 : 			if (iNumFound == iIndex)

	cmp	edi, DWORD PTR _iIndex$[esp+12]
	je	SHORT $LN6@GetTenet
$LN4@GetTenet:

; 4761 : 
; 4762 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	inc	eax
	add	esi, 4
	cmp	eax, ecx
	jl	SHORT $LL28@GetTenet
$LN3@GetTenet:

; 4771 : 			{
; 4772 : 				return eTenet;
; 4773 : 			}
; 4774 : 		}
; 4775 : 	}
; 4776 : 
; 4777 : 	return NO_POLICY;

	or	eax, -1
$LN6@GetTenet:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4778 : }

	ret	12					; 0000000cH
?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z ENDP ; CvPlayerPolicies::GetTenet
_TEXT	ENDS
PUBLIC	?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetNumTenetsOfLevel
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z PROC ; CvPlayerPolicies::GetNumTenetsOfLevel, COMDAT
; _this$ = ecx

; 4782 : {

	push	ebx
	push	edi
	mov	edi, ecx

; 4783 : 	int iNumFound = 0;
; 4784 : 
; 4785 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies

; 4786 : #ifdef AUI_WARNING_FIXES
; 4787 : 	for (uint iI = 0; iI < pkPolicies->GetNumPolicies(); iI++)
; 4788 : #else
; 4789 : 	const int iNumPolicies = pkPolicies->GetNumPolicies();

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, edx
	sar	eax, 2

; 4790 : 
; 4791 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN23@GetNumTene
	push	ebp
	push	esi
	mov	esi, edx
$LL26@GetNumTene:

; 4792 : #endif
; 4793 : 	{
; 4794 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));
; 4795 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	edx, DWORD PTR [esi]

; 4796 : 		if (pEntry && pEntry->GetPolicyBranchType() == eBranch && pEntry->GetLevel() == iLevel && HasPolicy(eTenet))

	test	edx, edx
	je	SHORT $LN3@GetNumTene
	mov	ebp, DWORD PTR [edx+820]
	cmp	ebp, DWORD PTR _eBranch$[esp+12]
	jne	SHORT $LN3@GetNumTene
	mov	ebp, DWORD PTR _iLevel$[esp+12]
	cmp	DWORD PTR [edx+276], ebp
	jne	SHORT $LN3@GetNumTene
	mov	edx, DWORD PTR [edi+12]
	cmp	BYTE PTR [ecx+edx], 0
	je	SHORT $LN3@GetNumTene

; 4797 : 		{
; 4798 : 			iNumFound++;

	inc	ebx
$LN3@GetNumTene:

; 4790 : 
; 4791 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	inc	ecx
	add	esi, 4
	cmp	ecx, eax
	jl	SHORT $LL26@GetNumTene
	pop	esi
	pop	ebp
$LN23@GetNumTene:
	pop	edi

; 4799 : 		}
; 4800 : 	}
; 4801 : 
; 4802 : 	return iNumFound;

	mov	eax, ebx
	pop	ebx

; 4803 : }

	ret	8
?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ENDP ; CvPlayerPolicies::GetNumTenetsOfLevel
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEAAPAVCvPolicyEntry@@XZ ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEAAPAVCvPolicyEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEAAPAVCvPolicyEntry@@XZ PROC ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEAAPAVCvPolicyEntry@@XZ ENDP ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEAAPAVCvPolicyBranchEntry@@XZ ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEAAPAVCvPolicyBranchEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEAAPAVCvPolicyBranchEntry@@XZ PROC ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEAAPAVCvPolicyBranchEntry@@XZ ENDP ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Key
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Key
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Root
_TEXT	ENDS
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
; Function compile flags: /Ogtpy
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound, COMDAT
; _this$ = ecx

; 1350 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1351 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1352 : 
; 1353 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Ubound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Ubound:

; 1354 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN2@Ubound

; 1355 : 				{	// _Pnode greater than _Keyval, remember it
; 1356 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1357 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]

; 1358 : 				}
; 1359 : 			else

	jmp	SHORT $LN1@Ubound
$LN2@Ubound:

; 1360 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]
$LN1@Ubound:

; 1351 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1352 : 
; 1353 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Ubound
$LN3@Ubound:

; 1361 : 
; 1362 : 		return (_Wherenode);	// return best remembered candidate
; 1363 : 		}

	ret	4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z PROC ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyEntry@@@1@@Z ENDP ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z PROC ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPolicyBranchEntry@@@1@@Z ENDP ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z PROC ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE@V?$allocator@W4BuildingTypes@@@1@@Z ENDP ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z ; std::allocator<enum BuildingTypes>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z PROC ; std::allocator<enum BuildingTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4BuildingTypes@@@std@@QAEPAW4BuildingTypes@@I@Z ENDP ; std::allocator<enum BuildingTypes>::allocate
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z PROC ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@PAPAVCvPolicyEntry@@@Z ENDP ; std::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Vector_iterator<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z PROC ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@PAPAVCvPolicyBranchEntry@@@Z ENDP ; std::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Vector_iterator<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z PROC ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE@V?$allocator@W4PolicyTypes@@@1@@Z ENDP ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4PolicyTypes@@@std@@QAEPAW4PolicyTypes@@I@Z ; std::allocator<enum PolicyTypes>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4PolicyTypes@@@std@@QAEPAW4PolicyTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4PolicyTypes@@@std@@QAEPAW4PolicyTypes@@I@Z PROC ; std::allocator<enum PolicyTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4PolicyTypes@@@std@@QAEPAW4PolicyTypes@@I@Z ENDP ; std::allocator<enum PolicyTypes>::allocate
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEPAPAVCvPolicyEntry@@I@Z ; std::allocator<CvPolicyEntry *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEPAPAVCvPolicyEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEPAPAVCvPolicyEntry@@I@Z PROC ; std::allocator<CvPolicyEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPolicyEntry@@@std@@QAEPAPAVCvPolicyEntry@@I@Z ENDP ; std::allocator<CvPolicyEntry *>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEPAPAVCvPolicyBranchEntry@@I@Z ; std::allocator<CvPolicyBranchEntry *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEPAPAVCvPolicyBranchEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEPAPAVCvPolicyBranchEntry@@I@Z PROC ; std::allocator<CvPolicyBranchEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyBranchEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPolicyBranchEntry@@@std@@QAEPAPAVCvPolicyBranchEntry@@I@Z ENDP ; std::allocator<CvPolicyBranchEntry *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
_TEXT	ENDS
PUBLIC	??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ; CvDatabaseUtility::InitializeArray<int>
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_szTableName$ = 12					; size = 4
_default$ = 16						; size = 4
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z PROC ; CvDatabaseUtility::InitializeArray<int>, COMDAT
; _this$ = ecx

; 180  : 	size_t count = MaxRows(szTableName);

	mov	eax, DWORD PTR _szTableName$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 181  : 
; 182  : 	//This is a bit of a hack to support empty tables.
; 183  : 	//For example, the "Automates" table will be empty during a tutorial.
; 184  : 	//We cannot simply NULL out the array because WAY too much code blindly assumes SOMETHING will be there..
; 185  : 	//Instead we allocate room for 1 element and just roll with it.
; 186  : 
; 187  : 	//CvAssertMsg(count > 0, DB.ErrorMessage());
; 188  : 	if(count == 0)

	test	eax, eax
	jne	SHORT $LN1@Initialize@2

; 189  : 		count = 1;

	mov	eax, 1
$LN1@Initialize@2:

; 190  : 
; 191  : 	InitializeArray(pArray, count, default);

	mov	ecx, DWORD PTR _default$[esp]
	mov	edx, DWORD PTR _pArray$[esp]
	push	ecx
	push	eax
	push	edx
	mov	ecx, esi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
	pop	esi

; 192  : }

	ret	12					; 0000000cH
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ENDP ; CvDatabaseUtility::InitializeArray<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPolicyAI@@@@YAXAAPAVCvPolicyAI@@@Z ; SAFE_DELETE<CvPolicyAI>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvPolicyAI@@@@YAXAAPAVCvPolicyAI@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPolicyAI@@@@YAXAAPAVCvPolicyAI@@@Z PROC ; SAFE_DELETE<CvPolicyAI>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET
	mov	ecx, esi
	call	??1CvPolicyAI@@QAE@XZ			; CvPolicyAI::~CvPolicyAI
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPolicyAI@@@@YAXAAPAVCvPolicyAI@@@Z ENDP ; SAFE_DELETE<CvPolicyAI>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$228229 = -7					; size = 1
_bValid$228226 = -6					; size = 1
_tValue$228234 = -5					; size = 1
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	sub	esp, 8
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiNumEntries$[esp+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+16], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+16]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$228226[esp+24]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228229[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	al, BYTE PTR _tValue$228229[esp+24]
	mov	ecx, DWORD PTR _paArray$[esp+20]
	mov	BYTE PTR [esi+ecx], al

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$228226[esp+24], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228234[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+24]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 8
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
_TEXT	ENDS
PUBLIC	??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z
_TEXT	SEGMENT
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z PROC ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>, COMDAT

; 455  : {

	push	ecx
	push	esi
	push	edi

; 456  : 	uint uiNumEntries;
; 457  : 
; 458  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiNumEntries$[esp+12]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 459  : 
; 460  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiNumEntries$[esp+12], esi
	jbe	SHORT $LN2@ReadHashed@2
	push	ebx
	mov	ebx, DWORD PTR _uiArraySize$[esp+12]
	push	ebp
	mov	ebp, DWORD PTR _paArray$[esp+16]
$LL11@ReadHashed@2:

; 461  : 	{
; 462  : 		TType eType = (TType)ReadHashed(kStream);

	push	0
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 463  : 		if(iI < uiArraySize)

	cmp	esi, ebx
	jae	SHORT $LN3@ReadHashed@2

; 464  : 			paArray[iI] = eType;

	mov	DWORD PTR [ebp+esi*4], eax
$LN3@ReadHashed@2:

; 459  : 
; 460  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	inc	esi
	cmp	esi, DWORD PTR _uiNumEntries$[esp+20]
	jb	SHORT $LL11@ReadHashed@2
	pop	ebp
	pop	ebx
$LN2@ReadHashed@2:
	pop	edi
	pop	esi

; 465  : 	}
; 466  : }

	pop	ecx
	ret	0
??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ENDP ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@2
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@2:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@2

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@2:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	ebx
$LN2@WriteHashe:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@2
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@2:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe@2:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@2
	pop	ebx
$LN2@WriteHashe@2:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>, COMDAT

; 673  : {

	push	esi
	push	edi

; 674  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 675  : 
; 676  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN1@WriteHashe@3
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL3@WriteHashe@3:

; 677  : 	{
; 678  : 		WriteHashed(kStream, paArray[iI]);

	mov	ecx, DWORD PTR [ebx+esi*4]
	push	ecx
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL3@WriteHashe@3
	pop	ebx
$LN1@WriteHashe@3:
	pop	edi
	pop	esi

; 679  : 	}
; 680  : }

	ret	0
??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@3:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@3

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@3:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235474 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235474[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 517  : 
; 518  : 	size_t bytes = 0;
; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 520  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 521  : 	str.assign(szComposedString, bytes);
; 522  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235474[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	mov	eax, DWORD PTR $T235474[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T235474[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235497 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235497[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 503  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 504  : 
; 505  : 	size_t bytes = 0;
; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 507  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 508  : 	str.assign(szComposedString, bytes);
; 509  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235497[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	mov	eax, DWORD PTR $T235497[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T235497[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::_Swap_adl<std::less<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC ; std::_Swap_adl<std::less<int> >, COMDAT

; 31   : 	swap(_Left, _Right);
; 32   : 	}

	ret	0
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP ; std::_Swap_adl<std::less<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPolicyEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@YAXPAPAVCvPolicyEntry@@0AAV?$allocator@PAVCvPolicyEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPolicyBranchEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@YAXPAPAVCvPolicyBranchEntry@@0AAV?$allocator@PAVCvPolicyBranchEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??$fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z ; std::fill<enum BuildingTypes *,enum BuildingTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z PROC ; std::fill<enum BuildingTypes *,enum BuildingTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z ENDP ; std::fill<enum BuildingTypes *,enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z ; std::fill<enum PolicyTypes *,enum PolicyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z PROC ; std::fill<enum PolicyTypes *,enum PolicyTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z ENDP ; std::fill<enum PolicyTypes *,enum PolicyTypes>
_TEXT	ENDS
PUBLIC	??_GCvPolicyBranchEntry@@QAEPAXI@Z		; CvPolicyBranchEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPolicyBranchEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPolicyBranchEntry@@QAEPAXI@Z PROC			; CvPolicyBranchEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyBranchEntry@@6B@
	mov	eax, DWORD PTR [esi+288]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+288], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN9@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPolicyBranchEntry@@QAEPAXI@Z ENDP			; CvPolicyBranchEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4BuildingTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum BuildingTypes *,enum BuildingTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum PolicyTypes *,enum PolicyTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum PolicyTypes *,enum PolicyTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@2
	push	esi
$LL6@Move_backw@2:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@2
	pop	esi
$LN5@Move_backw@2:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4PolicyTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum PolicyTypes *,enum PolicyTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@ABW43@@Z ; std::allocator<enum BuildingTypes>::construct
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?construct@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@ABW43@@Z PROC ; std::allocator<enum BuildingTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@ABW43@@Z ENDP ; std::allocator<enum BuildingTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z ; std::allocator<enum BuildingTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z PROC ; std::allocator<enum BuildingTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4BuildingTypes@@@std@@QAEXPAW4BuildingTypes@@@Z ENDP ; std::allocator<enum BuildingTypes>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@ABW43@@Z ; std::allocator<enum PolicyTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@ABW43@@Z PROC ; std::allocator<enum PolicyTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@ABW43@@Z ENDP ; std::allocator<enum PolicyTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@@Z ; std::allocator<enum PolicyTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@@Z PROC ; std::allocator<enum PolicyTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4PolicyTypes@@@std@@QAEXPAW4PolicyTypes@@@Z ENDP ; std::allocator<enum PolicyTypes>::destroy
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator!=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL16@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL16@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL16@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@3:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL16@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@4:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
$LL6@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@5:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@3
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@3:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_sqlKey$224835 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_szPolicyBranchType$ = 12				; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPolicyBranchEntry::CacheResults, COMDAT
; _this$ = ecx

; 2332 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebp

; 2333 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp+40]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+48]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul
	pop	edi
	pop	esi
	pop	ebp

; 2383 : 
; 2384 : 	return true;
; 2385 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN4@CacheResul:
	push	ebx

; 2334 : 		return false;
; 2335 : 
; 2336 : 	//References
; 2337 : 	const char* szEraPrereq = kResults.GetText("EraPrereq");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG224818
	mov	ecx, edi
	call	ebx

; 2338 : 	m_iEraPrereq = GC.getInfoTypeForString(szEraPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2339 : 
; 2340 : 	const char* szFreePolicy = kResults.GetText("FreePolicy");

	push	OFFSET $SG224820
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 2341 : 	m_iFreePolicy = GC.getInfoTypeForString(szFreePolicy, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2342 : 
; 2343 : 	const char* szFreeFinishingPolicy = kResults.GetText("FreeFinishingPolicy");

	push	OFFSET $SG224822
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 2344 : 	m_iFreeFinishingPolicy = GC.getInfoTypeForString(szFreeFinishingPolicy, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2345 : 
; 2346 : 	m_iFirstAdopterFreePolicies = kResults.GetInt("FirstAdopterFreePolicies");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG224823
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 2347 : 	m_iSecondAdopterFreePolicies = kResults.GetInt("SecondAdopterFreePolicies");

	push	OFFSET $SG224824
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 2348 : 
; 2349 : 	const char* szPolicyBranchType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+276], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 2350 : 
; 2351 : 	m_bPurchaseByLevel = kResults.GetBool("PurchaseByLevel");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG224826
	mov	ecx, edi
	mov	DWORD PTR _szPolicyBranchType$[esp+56], eax
	call	ebx

; 2352 : 	m_bLockedWithoutReligion = kResults.GetBool("LockedWithoutReligion");

	push	OFFSET $SG224827
	mov	ecx, edi
	mov	BYTE PTR [esi+280], al
	call	ebx

; 2353 : 	m_bMutuallyExclusive = kResults.GetBool("AIMutuallyExclusive");

	push	OFFSET $SG224828
	mov	ecx, edi
	mov	BYTE PTR [esi+281], al
	call	ebx

; 2354 : 
; 2355 : 	m_bDelayWhenNoReligion = kResults.GetBool("AIDelayNoReligion");

	push	OFFSET $SG224829
	mov	ecx, edi
	mov	BYTE PTR [esi+282], al
	call	ebx

; 2356 : 	m_bDelayWhenNoCulture = kResults.GetBool("AIDelayNoCulture");

	push	OFFSET $SG224830
	mov	ecx, edi
	mov	BYTE PTR [esi+283], al
	call	ebx

; 2357 : 	m_bDelayWhenNoCityStates = kResults.GetBool("AIDelayNoCityStates");

	push	OFFSET $SG224831
	mov	ecx, edi
	mov	BYTE PTR [esi+284], al
	call	ebx

; 2358 : 	m_bDelayWhenNoScience = kResults.GetBool("AIDelayNoScience");

	push	OFFSET $SG224832
	mov	ecx, edi
	mov	BYTE PTR [esi+285], al
	call	ebx

; 2359 : 
; 2360 : 	//PolicyBranch_Disables
; 2361 : 	{
; 2362 : 		kUtility.InitializeArray(m_piPolicyBranchDisables, "PolicyBranchTypes", (int)NO_POLICY_BRANCH_TYPE);

	push	OFFSET $SG224834
	mov	ecx, ebp
	mov	BYTE PTR [esi+286], al
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN24@CacheResul
	mov	edi, 1
$LN24@CacheResul:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+288], eax
	add	esp, 4
	xor	eax, eax
	test	edi, edi
	jbe	SHORT $LN25@CacheResul
$LL15@CacheResul:
	mov	ecx, DWORD PTR [esi+288]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL15@CacheResul
$LN25@CacheResul:

; 2363 : 
; 2364 : 		std::string sqlKey = "m_piPolicyBranchDisables";

	push	OFFSET $SG224836
	lea	ecx, DWORD PTR _sqlKey$224835[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2365 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$224835[esp+56]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 2366 : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN3@CacheResul

; 2367 : 		{
; 2368 : 			const char* szSQL = "select PolicyBranchTypes.ID from PolicyBranch_Disables inner join PolicyBranchTypes on PolicyBranchTypes.Type = PolicyBranchDisable where PolicyBranchType = ?";
; 2369 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG224840
	lea	eax, DWORD PTR _sqlKey$224835[esp+60]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN3@CacheResul:

; 2370 : 		}
; 2371 : 
; 2372 : 		pResults->Bind(1, szPolicyBranchType, false);

	mov	ecx, DWORD PTR _szPolicyBranchType$[esp+52]
	push	0
	push	ecx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 2373 : 
; 2374 : 		int iID;
; 2375 : 		while(pResults->Step())

	mov	ebx, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, edi
	call	ebx
	test	al, al
	je	SHORT $LN1@CacheResul
	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
$LL2@CacheResul:

; 2376 : 		{
; 2377 : 			iID = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	ebp

; 2378 : 			m_piPolicyBranchDisables[iID] = 1;

	mov	edx, DWORD PTR [esi+288]
	mov	ecx, edi
	mov	DWORD PTR [edx+eax*4], 1
	call	ebx
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 2379 : 		}
; 2380 : 
; 2381 : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2382 : 	}

	lea	ecx, DWORD PTR _sqlKey$224835[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2383 : 
; 2384 : 	return true;
; 2385 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	ebx
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _sqlKey$224835[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPolicyBranchEntry::CacheResults
PUBLIC	?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z ; CvPlayerPolicies::Init
EXTRN	??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z:PROC	; CvPolicyAI::CvPolicyAI
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z$0
__ehfuncinfo$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pPolicies$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
$T236156 = 16						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z PROC ; CvPlayerPolicies::Init, COMDAT
; _this$ = ecx

; 2589 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 2590 : 	// Init base class
; 2591 : 	CvFlavorRecipient::Init();

	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 2592 : 
; 2593 : 	// Store off the pointer to the policies active for this game
; 2594 : 	m_bIsCity = bIsCity;
; 2595 : 	m_pPolicies = pPolicies;

	mov	ecx, DWORD PTR _pPolicies$[esp+12]
	mov	al, BYTE PTR _bIsCity$[esp+12]

; 2596 : 	m_pPlayer = pPlayer;

	mov	edx, DWORD PTR _pPlayer$[esp+12]
	mov	BYTE PTR [esi+4], al
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+60], edx

; 2597 : 
; 2598 : 	// Initialize policy status array
; 2599 : 	CvAssertMsg(m_pabHasPolicy==NULL, "about to leak memory, CvPlayerPolicies::m_pabHasPolicy");
; 2600 : 	m_pabHasPolicy = FNEW(bool[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2601 : 	CvAssertMsg(m_pabHasOneShotPolicyFired==NULL, "about to leak memory, CvPlayerPolicies::m_pabHasOneShotPolicyFired");
; 2602 : 	m_pabHasOneShotPolicyFired = FNEW(bool[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2603 : 	CvAssertMsg(m_pabHaveOneShotFreeUnitsFired==NULL, "about to leak memory, CvPlayerPolicies::m_pabHaveOneShotFreeUnitsFired");
; 2604 : 	m_pabHaveOneShotFreeUnitsFired = FNEW(bool[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2605 : 
; 2606 : 	// Policy Branches Chosen
; 2607 : 	CvAssertMsg(m_pabPolicyBranchUnlocked==NULL, "about to leak memory, CvPlayerPolicies::m_pabPolicyBranchUnlocked");
; 2608 : 	m_pabPolicyBranchUnlocked = FNEW(bool[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+20]
	add	ecx, 16					; 00000010H
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2609 : 
; 2610 : 	// Policy Branches Blocked by choices
; 2611 : 	CvAssertMsg(m_pabPolicyBranchBlocked==NULL, "about to leak memory, CvPlayerPolicies::m_pabPolicyBranchBlocked");
; 2612 : 	m_pabPolicyBranchBlocked = FNEW(bool[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+20]
	add	ecx, 16					; 00000010H
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2613 : 
; 2614 : 	// Policy Branches finished
; 2615 : 	CvAssertMsg(m_pabPolicyBranchFinished==NULL, "about to leak memory, CvPlayerPolicies::m_pabPolicyBranchFinished");
; 2616 : 	m_pabPolicyBranchFinished = FNEW(bool[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+20]
	add	ecx, 16					; 00000010H
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2617 : 
; 2618 : 	CvAssertMsg(m_paePolicyBranchesChosen==NULL, "about to leak memory, CvPlayerPolicies::m_paePolicyBranchesChosen");
; 2619 : 	m_paePolicyBranchesChosen = FNEW(PolicyBranchTypes[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR [esi+32], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 2620 : 
; 2621 : 	CvAssertMsg(m_paePolicyBlockedBranchCheck==NULL, "about to leak memory, CvPlayerPolicies::m_paePolicyBlockedBranchCheck");
; 2622 : 	m_paePolicyBlockedBranchCheck = FNEW(PolicyBranchTypes[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+44], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 2623 : 	
; 2624 : 	// Create AI object
; 2625 : 	m_pPolicyAI = FNEW(CvPolicyAI(this), c_eCiv5GameplayDLL, 0);

	push	1068					; 0000042cH
	mov	DWORD PTR [esi+48], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 36					; 00000024H
	mov	DWORD PTR $T236156[esp+12], eax
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	eax, eax
	je	SHORT $LN3@Init
	push	esi
	mov	ecx, eax
	call	??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z ; CvPolicyAI::CvPolicyAI
	jmp	SHORT $LN4@Init
$LN3@Init:
	xor	eax, eax
$LN4@Init:

; 2626 : 
; 2627 : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+24], -1
	mov	DWORD PTR [esi+56], eax
	call	?Reset@CvPlayerPolicies@@QAEXXZ		; CvPlayerPolicies::Reset

; 2628 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z$0:
	mov	eax, DWORD PTR $T236156[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z ENDP ; CvPlayerPolicies::Init
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvPlayerPolicies@@UAEXXZ
_TEXT	SEGMENT
?Uninit@CvPlayerPolicies@@UAEXXZ PROC			; CvPlayerPolicies::Uninit, COMDAT
; _this$ = ecx

; 2632 : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 2633 : 	// Uninit base class
; 2634 : 	CvFlavorRecipient::Uninit();

	call	?Uninit@CvFlavorRecipient@@UAEXXZ	; CvFlavorRecipient::Uninit

; 2635 : 
; 2636 : 	SAFE_DELETE_ARRAY(m_pabHasPolicy);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+12], edi

; 2637 : 	SAFE_DELETE_ARRAY(m_pabHasOneShotPolicyFired);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+16], edi

; 2638 : 	SAFE_DELETE_ARRAY(m_pabHaveOneShotFreeUnitsFired);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+20], edi

; 2639 : 	SAFE_DELETE_ARRAY(m_pabPolicyBranchUnlocked);

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+24], edi

; 2640 : 	SAFE_DELETE_ARRAY(m_pabPolicyBranchBlocked);

	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+28], edi

; 2641 : 	SAFE_DELETE_ARRAY(m_pabPolicyBranchFinished);

	mov	edx, DWORD PTR [esi+32]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+32], edi

; 2642 : 	SAFE_DELETE_ARRAY(m_paePolicyBranchesChosen);

	mov	eax, DWORD PTR [esi+44]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+44], edi

; 2643 : 	SAFE_DELETE(m_pPolicyAI);

	mov	ebx, DWORD PTR [esi+56]
	add	esp, 28					; 0000001cH
	cmp	ebx, edi
	je	SHORT $LN19@Uninit
	mov	ecx, ebx
	call	??1CvPolicyAI@@QAE@XZ			; CvPolicyAI::~CvPolicyAI
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@Uninit:
	mov	DWORD PTR [esi+56], edi

; 2644 : 	SAFE_DELETE_ARRAY(m_paePolicyBlockedBranchCheck);

	mov	ecx, DWORD PTR [esi+48]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+48], edi
	pop	edi
	pop	esi
	pop	ebx

; 2645 : }

	ret	0
?Uninit@CvPlayerPolicies@@UAEXXZ ENDP			; CvPlayerPolicies::Uninit
_TEXT	ENDS
PUBLIC	?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z	; CvPlayerPolicies::Read
EXTRN	?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z:PROC	; CvPolicyAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iNumFlavors$ = -8					; size = 4
_temp$225349 = -4					; size = 4
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerPolicies::Read, COMDAT
; _this$ = ecx

; 2724 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 2725 : 	// Version number to maintain backwards compatibility
; 2726 : 	uint uiVersion;
; 2727 : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+16]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2728 : 
; 2729 : 	CvAssertMsg(m_pPolicies != NULL && m_pPolicies->GetNumPolicies() > 0, "Number of policies to serialize is expected to greater than 0");
; 2730 : 
; 2731 : 	uint uiPolicyCount = 0;
; 2732 : 	uint uiPolicyBranchCount = 0;
; 2733 : 	if(m_pPolicies)

	mov	eax, DWORD PTR [edi+52]
	xor	ebp, ebp
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN2@Read

; 2734 : 	{
; 2735 : 		uiPolicyCount = m_pPolicies->GetNumPolicies();

	mov	ebp, DWORD PTR [eax+8]
	sub	ebp, DWORD PTR [eax+4]

; 2736 : 		uiPolicyBranchCount = m_pPolicies->GetNumPolicyBranches();

	mov	ebx, DWORD PTR [eax+24]
	sub	ebx, DWORD PTR [eax+20]
	sar	ebp, 2
	sar	ebx, 2
$LN2@Read:

; 2737 : 	}
; 2738 : 
; 2739 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabHasPolicy, uiPolicyCount);

	mov	ecx, DWORD PTR [edi+12]
	push	ebp
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 2740 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabHasOneShotPolicyFired, uiPolicyCount);

	mov	edx, DWORD PTR [edi+16]
	push	ebp
	push	edx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 2741 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabHaveOneShotFreeUnitsFired, uiPolicyCount);

	mov	eax, DWORD PTR [edi+20]
	push	ebp
	push	eax
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 2742 : 
; 2743 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabPolicyBranchUnlocked, uiPolicyBranchCount);

	mov	ecx, DWORD PTR [edi+24]
	push	ebx
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 2744 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabPolicyBranchBlocked, uiPolicyBranchCount);

	mov	edx, DWORD PTR [edi+28]
	push	ebx
	push	edx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 2745 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabPolicyBranchFinished, uiPolicyBranchCount);

	mov	eax, DWORD PTR [edi+32]
	push	ebx
	push	eax
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 2746 : 	CvInfosSerializationHelper::ReadHashedTypeArray(kStream, m_paePolicyBranchesChosen, uiPolicyBranchCount);

	mov	ecx, DWORD PTR [edi+44]
	add	esp, 72					; 00000048H
	push	ebx
	push	ecx
	push	esi
	call	??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>
	add	esp, 12					; 0000000cH

; 2747 : 
; 2748 : 	kStream >> m_iNumExtraBranches;

	lea	edx, DWORD PTR [edi+64]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2749 : 
; 2750 : 	m_eBranchPicked1 = (PolicyBranchTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	esi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed

; 2751 : 	m_eBranchPicked2 = (PolicyBranchTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	esi
	mov	DWORD PTR [edi+68], eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed

; 2752 : 	m_eBranchPicked3 = (PolicyBranchTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	esi
	mov	DWORD PTR [edi+72], eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 24					; 00000018H

; 2753 : 
; 2754 : 	if (uiVersion < 2)

	cmp	DWORD PTR _uiVersion$[esp+20], 2
	mov	DWORD PTR [edi+76], eax
	jae	SHORT $LN17@Read

; 2755 : 	{
; 2756 : 		int temp;
; 2757 : 		kStream >> temp;  // m_iMaxEffectiveCities moved to player class

	lea	eax, DWORD PTR _temp$225349[esp+24]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN17@Read:

; 2758 : 	}
; 2759 : 
; 2760 : 	// Now for AI
; 2761 : 	m_pPolicyAI->Read(kStream);

	mov	ecx, DWORD PTR [edi+56]
	push	esi
	call	?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z ; CvPolicyAI::Read

; 2762 : 
; 2763 : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 2764 : 
; 2765 : 	int iNumFlavors;
; 2766 : 	kStream >> iNumFlavors;

	lea	ecx, DWORD PTR _iNumFlavors$[esp+24]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2767 : 
; 2768 : 	ArrayWrapper<int> wrapm_piLatestFlavorValues(iNumFlavors, m_piLatestFlavorValues);
; 2769 : 	kStream >> wrapm_piLatestFlavorValues;

	mov	ebx, DWORD PTR _iNumFlavors$[esp+24]
	mov	edi, DWORD PTR [edi+8]
	test	ebx, ebx
	jle	SHORT $LN23@Read
	npad	5
$LL25@Read:
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL25@Read
$LN23@Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2770 : }

	add	esp, 8
	ret	4
?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerPolicies::Read
_TEXT	ENDS
PUBLIC	?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z	; CvPlayerPolicies::Write
EXTRN	?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z:PROC	; CvPolicyAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T236383 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z PROC	; CvPlayerPolicies::Write, COMDAT
; _this$ = ecx

; 2774 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2775 : 	// Current version number
; 2776 : 	uint uiVersion = 2;
; 2777 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+16]
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+24], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2778 : 
; 2779 : 	CvAssertMsg(m_pPolicies != NULL && GC.getNumPolicyInfos() > 0, "Number of policies to serialize is expected to greater than 0");
; 2780 : 
; 2781 : 	uint uiPolicyCount = 0;
; 2782 : 	uint uiPolicyBranchCount = 0;

	xor	ebx, ebx
	xor	ebp, ebp

; 2783 : 	if(m_pPolicies)

	cmp	DWORD PTR [esi+52], ebx
	je	SHORT $LN1@Write

; 2784 : 	{
; 2785 : 		uiPolicyCount = m_pPolicies->GetNumPolicies();

	mov	eax, DWORD PTR [esi+52]
	mov	ebp, DWORD PTR [eax+8]
	sub	ebp, DWORD PTR [eax+4]

; 2786 : 		uiPolicyBranchCount = m_pPolicies->GetNumPolicyBranches();

	mov	ebx, DWORD PTR [eax+24]
	sub	ebx, DWORD PTR [eax+20]
	sar	ebp, 2
	sar	ebx, 2
$LN1@Write:

; 2787 : 	}
; 2788 : 
; 2789 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHasPolicy, uiPolicyCount);

	mov	ecx, DWORD PTR [esi+12]
	push	ebp
	push	ecx
	push	edi
	call	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>

; 2790 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHasOneShotPolicyFired, uiPolicyCount);

	mov	edx, DWORD PTR [esi+16]
	push	ebp
	push	edx
	push	edi
	call	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>

; 2791 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHaveOneShotFreeUnitsFired, uiPolicyCount);

	mov	eax, DWORD PTR [esi+20]
	push	ebp
	push	eax
	push	edi
	call	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>

; 2792 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyBranchTypes>(kStream, m_pabPolicyBranchUnlocked, uiPolicyBranchCount);

	mov	ecx, DWORD PTR [esi+24]
	push	ebx
	push	ecx
	push	edi
	call	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>

; 2793 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyBranchTypes>(kStream, m_pabPolicyBranchBlocked, uiPolicyBranchCount);

	mov	edx, DWORD PTR [esi+28]
	push	ebx
	push	edx
	push	edi
	call	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>

; 2794 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyBranchTypes>(kStream, m_pabPolicyBranchFinished, uiPolicyBranchCount);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	push	eax
	push	edi
	call	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>

; 2795 : 	CvInfosSerializationHelper::WriteHashedTypeArray<PolicyBranchTypes>(kStream, m_paePolicyBranchesChosen, uiPolicyBranchCount);

	mov	ecx, DWORD PTR [esi+44]
	add	esp, 72					; 00000048H
	push	ebx
	push	ecx
	push	edi
	call	??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>
	add	esp, 12					; 0000000cH

; 2796 : 
; 2797 : 	kStream << m_iNumExtraBranches;

	lea	edx, DWORD PTR [esi+64]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2798 : 
; 2799 : 	CvInfosSerializationHelper::WriteHashed(kStream, m_eBranchPicked1);

	mov	eax, DWORD PTR [esi+68]
	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 2800 : 	CvInfosSerializationHelper::WriteHashed(kStream, m_eBranchPicked2);

	mov	ecx, DWORD PTR [esi+72]
	push	ecx
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 2801 : 	CvInfosSerializationHelper::WriteHashed(kStream, m_eBranchPicked3);

	mov	edx, DWORD PTR [esi+76]
	push	edx
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 2802 : 
; 2803 : 	// Now for AI
; 2804 : 	m_pPolicyAI->Write(kStream);

	mov	ecx, DWORD PTR [esi+56]
	add	esp, 24					; 00000018H
	push	edi
	call	?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z ; CvPolicyAI::Write

; 2805 : 
; 2806 : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 2807 : 	kStream << GC.getNumFlavorTypes();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	lea	ecx, DWORD PTR $T236383[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T236383[esp+20], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2808 : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	esi, DWORD PTR [esi+8]
	test	eax, eax
	jle	SHORT $LN24@Write

; 2787 : 	}
; 2788 : 
; 2789 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHasPolicy, uiPolicyCount);

	mov	ebx, eax

; 2808 : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

$LL26@Write:
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL26@Write
$LN24@Write:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2809 : }

	pop	ecx
	ret	4
?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z ENDP	; CvPlayerPolicies::Write
_TEXT	ENDS
PUBLIC	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ; CvPlayerPolicies::CanAdoptPolicy
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getJONSCulture@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getJONSCulture
EXTRN	?getNextPolicyCost@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getNextPolicyCost
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z$0
__ehfuncinfo$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
_args$225827 = -20					; size = 4
_pkPolicyEntry$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bResult$225828 = 12					; size = 1
_bIgnoreCost$ = 12					; size = 1
?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::CanAdoptPolicy, COMDAT
; _this$ = ecx

; 3595 : {

	push	-1
	push	__ehhandler$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 3596 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3597 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 3598 : 
; 3599 : 	CvPolicyEntry* pkPolicyEntry = GC.getPolicyInfo(eIndex);

	mov	edi, DWORD PTR _eIndex$[esp+28]
	mov	esi, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+36], esi
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	ebp, eax
	mov	DWORD PTR _pkPolicyEntry$[esp+32], ebp

; 3600 : 	if(pkPolicyEntry == NULL)

	test	ebp, ebp
	jne	SHORT $LN40@CanAdoptPo
$LN139@CanAdoptPo:
	pop	edi
	pop	esi

; 3601 : 		return false;

	xor	al, al
	pop	ebp

; 3757 : 
; 3758 : 	return true;
; 3759 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	8
$LN40@CanAdoptPo:

; 3602 : 
; 3603 : 	// Already has Policy?
; 3604 : 	if(HasPolicy(eIndex))

	mov	eax, DWORD PTR [esi+12]
	cmp	BYTE PTR [edi+eax], 0

; 3605 : 	{
; 3606 : 		return false;

	jne	SHORT $LN139@CanAdoptPo

; 3607 : 	}
; 3608 : 
; 3609 : 	// Has enough culture to spend?
; 3610 : 	if((!bIgnoreCost) && m_pPlayer->getNextPolicyCost() > 0)

	cmp	BYTE PTR _bIgnoreCost$[esp+28], 0
	push	ebx
	jne	SHORT $LN131@CanAdoptPo
	mov	ecx, DWORD PTR [esi+60]
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	test	eax, eax
	jle	SHORT $LN131@CanAdoptPo

; 3611 : 	{
; 3612 : 		if(m_pPlayer->getJONSCulture() < m_pPlayer->getNextPolicyCost())

	mov	ecx, DWORD PTR [esi+60]
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	mov	ecx, DWORD PTR [esi+60]
	mov	edi, eax
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	cmp	edi, eax
	jge	SHORT $LN131@CanAdoptPo

; 3613 : 		{
; 3614 : 			bool bTenet = pkPolicyEntry->GetLevel() > 0;

	cmp	DWORD PTR [ebp+276], 0

; 3615 : 			if (m_pPlayer->GetNumFreePolicies() == 0)

	mov	ecx, DWORD PTR [esi+60]
	setg	bl
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jne	SHORT $LN131@CanAdoptPo

; 3616 : 			{
; 3617 : 				if (!bTenet || m_pPlayer->GetNumFreeTenets() == 0)

	test	bl, bl
	je	$LN138@CanAdoptPo
	mov	ecx, DWORD PTR [esi+60]
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	test	eax, eax

; 3618 : 				{
; 3619 : 					return false;

	je	$LN138@CanAdoptPo
$LN131@CanAdoptPo:

; 3620 : 				}
; 3621 : 			}
; 3622 : 		}
; 3623 : 	}
; 3624 : 
; 3625 : 	PolicyBranchTypes eBranch = (PolicyBranchTypes) pkPolicyEntry->GetPolicyBranchType();

	mov	edi, DWORD PTR [ebp+820]

; 3626 : 
; 3627 : 	// If it doesn't have a branch, it's a freebie that comes WITH the branch, so we can't pick it manually
; 3628 : 	if(eBranch == NO_POLICY_BRANCH_TYPE)

	cmp	edi, -1

; 3629 : 	{
; 3630 : 		return false;

	je	$LN138@CanAdoptPo

; 3631 : 	}
; 3632 : 
; 3633 : 	if(!IsPolicyBranchUnlocked(eBranch))

	mov	ecx, DWORD PTR [esi+24]
	cmp	BYTE PTR [edi+ecx], 0

; 3634 : 	{
; 3635 : 		return false;

	je	$LN138@CanAdoptPo

; 3636 : 	}
; 3637 : 
; 3638 : 	// Is it from a branch with Levels?
; 3639 : 	CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranch);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 3640 : 	if(pkPolicyBranchInfo == NULL)

	test	eax, eax

; 3641 : 	{
; 3642 : 		return false;

	je	$LN138@CanAdoptPo

; 3643 : 	}
; 3644 : 	else
; 3645 : 	{
; 3646 : 		if (pkPolicyBranchInfo->IsPurchaseByLevel())

	mov	al, BYTE PTR [eax+280]
	test	al, al
	je	SHORT $LN133@CanAdoptPo

; 3647 : 		{
; 3648 : 			// If below level 1, can't have as many of this level as of the previous one
; 3649 : 			int iLevel = pkPolicyEntry->GetLevel();

	mov	ebp, DWORD PTR [ebp+276]

; 3650 : 			if (iLevel > 1)

	cmp	ebp, 1
	jle	SHORT $LN130@CanAdoptPo

; 3651 : 			{
; 3652 : 				int iPoliciesOfThisLevel = GetNumTenetsOfLevel(eBranch, iLevel) + 1 /* For the policy we're adding here */;

	push	ebp
	push	edi
	mov	ecx, esi
	call	?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetNumTenetsOfLevel

; 3653 : 				int iPoliciesOfPreviousLevel = GetNumTenetsOfLevel(eBranch, iLevel - 1);

	mov	ecx, DWORD PTR _this$[esp+36]
	dec	ebp
	push	ebp
	mov	esi, eax
	push	edi
	inc	esi
	call	?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetNumTenetsOfLevel

; 3654 : 				if (iPoliciesOfThisLevel >= iPoliciesOfPreviousLevel)

	cmp	esi, eax

; 3655 : 				{
; 3656 : 					return false;

	jge	$LN138@CanAdoptPo

; 3654 : 				if (iPoliciesOfThisLevel >= iPoliciesOfPreviousLevel)

	mov	esi, DWORD PTR _this$[esp+36]
$LN130@CanAdoptPo:
	mov	ebp, DWORD PTR _pkPolicyEntry$[esp+36]
$LN133@CanAdoptPo:

; 3657 : 				}
; 3658 : 			}
; 3659 : 		}
; 3660 : 	}
; 3661 : 
; 3662 : 	// Other Policies as Prereqs
; 3663 : 
; 3664 : 	bool bFoundPossible = false;
; 3665 : 	bool bFoundValid = false;
; 3666 : 
; 3667 : 	for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	xor	ecx, ecx
	xor	dl, dl
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268, ecx
	jle	SHORT $LN132@CanAdoptPo
	mov	edi, DWORD PTR [ebp+964]
	npad	1
$LL134@CanAdoptPo:

; 3668 : 	{
; 3669 : 		PolicyTypes ePrereq = (PolicyTypes)pkPolicyEntry->GetPrereqOrPolicies(iI);

	test	edi, edi
	je	SHORT $LN25@CanAdoptPo
	mov	eax, DWORD PTR [edi+ecx*4]

; 3670 : 		if(ePrereq != NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN25@CanAdoptPo

; 3671 : 		{
; 3672 : 			bFoundPossible = true;
; 3673 : 
; 3674 : 			if(HasPolicy(ePrereq))

	mov	ebx, DWORD PTR [esi+12]
	cmp	BYTE PTR [eax+ebx], 0
	mov	dl, 1
	jne	SHORT $LN132@CanAdoptPo
$LN25@CanAdoptPo:

; 3657 : 				}
; 3658 : 			}
; 3659 : 		}
; 3660 : 	}
; 3661 : 
; 3662 : 	// Other Policies as Prereqs
; 3663 : 
; 3664 : 	bool bFoundPossible = false;
; 3665 : 	bool bFoundValid = false;
; 3666 : 
; 3667 : 	for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	inc	ecx
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	jl	SHORT $LL134@CanAdoptPo

; 3675 : 			{
; 3676 : 				bFoundValid = true;
; 3677 : 				break;
; 3678 : 			}
; 3679 : 		}
; 3680 : 	}
; 3681 : 
; 3682 : 	if(bFoundPossible && !bFoundValid)

	test	dl, dl

; 3683 : 	{
; 3684 : 		return false;

	jne	$LN138@CanAdoptPo
$LN132@CanAdoptPo:

; 3685 : 	}
; 3686 : 
; 3687 : 	for(int iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272, edi
	jle	SHORT $LN18@CanAdoptPo
$LL135@CanAdoptPo:

; 3688 : 	{
; 3689 : 		const PolicyTypes ePrereq = static_cast<PolicyTypes>(pkPolicyEntry->GetPrereqAndPolicies(iI));

	mov	eax, DWORD PTR [ebp+968]
	test	eax, eax
	je	SHORT $LN19@CanAdoptPo
	mov	esi, DWORD PTR [eax+edi*4]

; 3690 : 
; 3691 : 		if(ePrereq == NO_POLICY)

	cmp	esi, -1
	je	SHORT $LN128@CanAdoptPo

; 3692 : 			continue;
; 3693 : 
; 3694 : 		CvPolicyEntry* pkPrereqPolicyInfo = GC.getPolicyInfo(ePrereq);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 3695 : 		if(pkPrereqPolicyInfo)

	test	eax, eax
	je	SHORT $LN128@CanAdoptPo

; 3696 : 		{
; 3697 : 			if(!HasPolicy(ePrereq))

	mov	edx, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [edx+12]
	cmp	BYTE PTR [esi+eax], 0
	je	$LN138@CanAdoptPo
$LN128@CanAdoptPo:
	mov	ebp, DWORD PTR _pkPolicyEntry$[esp+36]
$LN19@CanAdoptPo:

; 3685 : 	}
; 3686 : 
; 3687 : 	for(int iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	inc	edi
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272
	jl	SHORT $LL135@CanAdoptPo
$LN18@CanAdoptPo:

; 3698 : 			{
; 3699 : 				return false;
; 3700 : 			}
; 3701 : 		}
; 3702 : 	}
; 3703 : 
; 3704 : 	// Disabled by another Policy?
; 3705 : #ifdef AUI_WARNING_FIXES
; 3706 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 3707 : #else
; 3708 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	ebx, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN129@CanAdoptPo
	npad	8
$LL14@CanAdoptPo:

; 3709 : #endif
; 3710 : 	{
; 3711 : 		const PolicyTypes eDisablePolicy =static_cast<PolicyTypes>(iPolicyLoop);
; 3712 : 
; 3713 : 		CvPolicyEntry* pkDisablePolicyInfo = GC.getPolicyInfo(eDisablePolicy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 3714 : 		if(pkDisablePolicyInfo)

	test	eax, eax
	je	SHORT $LN13@CanAdoptPo

; 3715 : 		{
; 3716 : 			if(HasPolicy(eDisablePolicy))

	mov	edx, DWORD PTR [ebx+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN13@CanAdoptPo

; 3717 : 			{
; 3718 : 				for(int iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN13@CanAdoptPo
	mov	edx, DWORD PTR [eax+972]
	npad	6
$LL9@CanAdoptPo:

; 3719 : 				{
; 3720 : 					if(pkDisablePolicyInfo->GetPolicyDisables(iI) == eIndex)

	test	edx, edx
	je	SHORT $LN84@CanAdoptPo

; 3717 : 			{
; 3718 : 				for(int iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	mov	eax, DWORD PTR [edx+ecx*4]

; 3719 : 				{
; 3720 : 					if(pkDisablePolicyInfo->GetPolicyDisables(iI) == eIndex)

	jmp	SHORT $LN85@CanAdoptPo
$LN84@CanAdoptPo:
	or	eax, -1
$LN85@CanAdoptPo:
	cmp	eax, DWORD PTR _eIndex$[esp+32]
	je	$LN138@CanAdoptPo
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL9@CanAdoptPo
$LN13@CanAdoptPo:

; 3698 : 			{
; 3699 : 				return false;
; 3700 : 			}
; 3701 : 		}
; 3702 : 	}
; 3703 : 
; 3704 : 	// Disabled by another Policy?
; 3705 : #ifdef AUI_WARNING_FIXES
; 3706 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 3707 : #else
; 3708 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL14@CanAdoptPo
$LN129@CanAdoptPo:

; 3721 : 					{
; 3722 : 						return false;
; 3723 : 					}
; 3724 : 				}
; 3725 : 			}
; 3726 : 		}
; 3727 : 	}
; 3728 : 
; 3729 : 	// Has tech prereq? (no policies have one by default)
; 3730 : 	if(pkPolicyEntry->GetTechPrereq() != NO_TECH)

	mov	edx, DWORD PTR _pkPolicyEntry$[esp+36]
	mov	ecx, DWORD PTR [edx+260]
	or	edi, -1
	cmp	ecx, edi
	je	SHORT $LN4@CanAdoptPo

; 3731 : 	{
; 3732 : 		if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes) pkPolicyEntry->GetTechPrereq()))

	mov	eax, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN94@CanAdoptPo
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN95@CanAdoptPo
$LN94@CanAdoptPo:
	mov	eax, edi
$LN95@CanAdoptPo:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 3733 : 		{
; 3734 : 			return false;

	je	SHORT $LN138@CanAdoptPo
$LN4@CanAdoptPo:

; 3735 : 		}
; 3736 : 	}
; 3737 : 
; 3738 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 3739 : 	if(pkScriptSystem)

	test	esi, esi
	je	$LN3@CanAdoptPo

; 3740 : 	{
; 3741 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225827[esp+36]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 3742 : 		args->Push(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _args$225827[esp+36]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+48], 0
	call	eax

; 3743 : 		args->Push(eIndex);

	mov	ecx, DWORD PTR _args$225827[esp+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _eIndex$[esp+32]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 3744 : 
; 3745 : 		// Attempt to execute the game events.
; 3746 : 		// Will return false if there are no registered listeners.
; 3747 : 		bool bResult = false;
; 3748 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanAdoptPolicy", args.get(), bResult))

	mov	ecx, DWORD PTR _args$225827[esp+36]
	lea	eax, DWORD PTR _bResult$225828[esp+32]
	push	eax
	push	ecx
	push	OFFSET $SG225830
	push	esi
	mov	BYTE PTR _bResult$225828[esp+48], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN1@CanAdoptPo

; 3749 : 		{
; 3750 : 			// Check the result.
; 3751 : 			if(bResult == false)

	cmp	BYTE PTR _bResult$225828[esp+32], 0
	jne	SHORT $LN1@CanAdoptPo

; 3752 : 			{
; 3753 : 				return false;

	lea	ecx, DWORD PTR _args$225827[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], edi
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN138@CanAdoptPo:
	pop	ebx
	pop	edi
	pop	esi
	xor	al, al
	pop	ebp

; 3757 : 
; 3758 : 	return true;
; 3759 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	8
$LN1@CanAdoptPo:

; 3754 : 			}
; 3755 : 		}
; 3756 : 	}

	lea	ecx, DWORD PTR _args$225827[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], edi
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanAdoptPo:

; 3757 : 
; 3758 : 	return true;
; 3759 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	ebx
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$225827[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::CanAdoptPolicy
PUBLIC	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
EXTRN	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ:PROC	; CvTeam::GetCurrentEra
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z$0
__ehfuncinfo$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_args$225868 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bResult$225869 = 8					; size = 1
_eBranchType$ = 8					; size = 4
?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::CanUnlockPolicyBranch, COMDAT
; _this$ = ecx

; 3826 : {

	push	-1
	push	__ehhandler$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 3827 : 	// Must have enough culture to spend a buy opening a new branch
; 3828 : 	if(GetPlayer()->getJONSCulture() < GetPlayer()->getNextPolicyCost())

	mov	esi, DWORD PTR [edi+60]
	mov	ecx, esi
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	mov	ecx, esi
	mov	ebx, eax
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	cmp	eax, ebx
	jge	SHORT $LN10@CanUnlockP

; 3829 : 	{
; 3830 : 		if(GetPlayer()->GetNumFreePolicies() == 0)

	mov	ecx, DWORD PTR [edi+60]
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jne	SHORT $LN10@CanUnlockP
	pop	edi
	pop	esi

; 3831 : 			return false;

	xor	al, al
	pop	ebx

; 3882 : 
; 3883 : 	return true;
; 3884 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN10@CanUnlockP:

; 3832 : 	}
; 3833 : 
; 3834 : 	CvPolicyBranchEntry* pkBranchEntry = m_pPolicies->GetPolicyBranchEntry(eBranchType);

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+20]
	push	ebp
	mov	ebp, DWORD PTR _eBranchType$[esp+28]
	mov	esi, DWORD PTR [ecx+ebp*4]

; 3835 : 	if(pkBranchEntry)

	xor	ebx, ebx
	cmp	esi, ebx
	je	SHORT $LN4@CanUnlockP

; 3836 : 	{
; 3837 : 		// Ideology branches unlocked through a direct call to SetPolicyBranchUnlocked()
; 3838 : 		if (pkBranchEntry->IsPurchaseByLevel())

	cmp	BYTE PTR [esi+280], bl

; 3839 : 		{
; 3840 : 			return false;

	jne	$LN60@CanUnlockP

; 3841 : 		}
; 3842 : 
; 3843 : 		if (pkBranchEntry->IsLockedWithoutReligion())

	cmp	BYTE PTR [esi+281], bl
	je	SHORT $LN6@CanUnlockP

; 3844 : 		{
; 3845 : 			if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	21					; 00000015H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 3846 : 			{
; 3847 : 				return false;

	jne	$LN60@CanUnlockP
$LN6@CanUnlockP:

; 3848 : 			}
; 3849 : 		}
; 3850 : 
; 3851 : 		EraTypes ePrereqEra = (EraTypes) pkBranchEntry->GetEraPrereq();

	mov	esi, DWORD PTR [esi+260]

; 3852 : 
; 3853 : 		// Must be in the proper Era
; 3854 : 		if(ePrereqEra != NO_ERA)

	cmp	esi, -1
	je	SHORT $LN4@CanUnlockP

; 3855 : 		{
; 3856 : 			if(GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra() < ePrereqEra)

	mov	eax, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@CanUnlockP
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN40@CanUnlockP
$LN39@CanUnlockP:
	or	eax, -1
$LN40@CanUnlockP:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, esi

; 3857 : 			{
; 3858 : 				return false;

	jl	SHORT $LN60@CanUnlockP
$LN4@CanUnlockP:

; 3859 : 			}
; 3860 : 		}
; 3861 : 	}
; 3862 : 
; 3863 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	esi, eax

; 3864 : 	if(pkScriptSystem)

	cmp	esi, ebx
	je	$LN3@CanUnlockP

; 3865 : 	{
; 3866 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225868[esp+32]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 3867 : 		args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$225868[esp+32]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	call	eax

; 3868 : 		args->Push(eBranchType);

	mov	ecx, DWORD PTR _args$225868[esp+32]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 3869 : 
; 3870 : 		// Attempt to execute the game events.
; 3871 : 		// Will return false if there are no registered listeners.
; 3872 : 		bool bResult = false;
; 3873 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanAdoptPolicyBranch", args.get(), bResult))

	mov	edx, DWORD PTR _args$225868[esp+32]
	lea	ecx, DWORD PTR _bResult$225869[esp+28]
	push	ecx
	push	edx
	push	OFFSET $SG225871
	push	esi
	mov	BYTE PTR _bResult$225869[esp+44], bl
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN1@CanUnlockP

; 3874 : 		{
; 3875 : 			// Check the result.
; 3876 : 			if(bResult == false)

	cmp	BYTE PTR _bResult$225869[esp+28], bl
	jne	SHORT $LN1@CanUnlockP

; 3877 : 			{
; 3878 : 				return false;

	lea	ecx, DWORD PTR _args$225868[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN60@CanUnlockP:
	pop	ebp
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 3882 : 
; 3883 : 	return true;
; 3884 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN1@CanUnlockP:

; 3879 : 			}
; 3880 : 		}
; 3881 : 	}

	lea	ecx, DWORD PTR _args$225868[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanUnlockP:

; 3882 : 
; 3883 : 	return true;
; 3884 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	ebp
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$225868[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::CanUnlockPolicyBranch
PUBLIC	?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchToPolicyBranch
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?ChangeAnarchyNumTurns@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeAnarchyNumTurns
; Function compile flags: /Ogtpy
;	COMDAT ?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_pkActivateBranchInfo$225973 = 8			; size = 4
_eBranchType$ = 8					; size = 4
?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::DoSwitchToPolicyBranch, COMDAT
; _this$ = ecx

; 3988 : {

	push	ebx

; 3989 : 	// Must be unlocked
; 3990 : 	if(!IsPolicyBranchUnlocked(eBranchType))

	mov	ebx, DWORD PTR _eBranchType$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+24]
	cmp	BYTE PTR [ebx+eax], 0
	je	$LN1@DoSwitchTo

; 3991 : 	{
; 3992 : 		return;
; 3993 : 	}
; 3994 : 
; 3995 : 	// Is this branch blocked?
; 3996 : 	if(IsPolicyBranchBlocked(eBranchType))

	mov	ecx, DWORD PTR [edi+28]
	cmp	BYTE PTR [ebx+ecx], 0
	je	SHORT $LN88@DoSwitchTo

; 3997 : 	{
; 3998 : 		// Anarchy time!
; 3999 : 		int iNumTurnsAnarchy = /*1*/ GC.getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS();
; 4000 : 		GetPlayer()->ChangeAnarchyNumTurns(iNumTurnsAnarchy);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6976
	mov	ecx, DWORD PTR [edi+60]
	push	edx
	call	?ChangeAnarchyNumTurns@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeAnarchyNumTurns

; 4001 : 
; 4002 : 		// Turn off blocking
; 4003 : 		SetPolicyBranchBlocked(eBranchType, false);

	push	0
	push	ebx
	mov	ecx, edi
	call	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
$LN88@DoSwitchTo:

; 4004 : 	}
; 4005 : 
; 4006 : 	// Does THIS Branch block any other branch?
; 4007 : #ifdef AUI_WARNING_FIXES
; 4008 : 	uint iBranchLoop;
; 4009 : #else
; 4010 : 	int iBranchLoop;
; 4011 : #endif
; 4012 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	push	ebp
	push	esi
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN21@DoSwitchTo
	npad	1
$LL23@DoSwitchTo:

; 4013 : 	{
; 4014 : 		const PolicyBranchTypes eDisableBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 4015 : 		CvPolicyBranchEntry* pkDisablePolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 4016 : 		if(pkDisablePolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN22@DoSwitchTo

; 4017 : 		{
; 4018 : 			if(pkDisablePolicyBranchInfo->GetPolicyBranchDisables(eDisableBranch) > 0)

	mov	eax, DWORD PTR [eax+288]
	test	eax, eax
	je	SHORT $LN22@DoSwitchTo
	cmp	DWORD PTR [eax+esi*4], 0
	jle	SHORT $LN22@DoSwitchTo

; 4019 : 			{
; 4020 : 				SetPolicyBranchBlocked(eDisableBranch, true);

	push	1
	push	esi
	mov	ecx, edi
	call	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
$LN22@DoSwitchTo:
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	esi
	sar	edx, 2
	cmp	esi, edx
	jl	SHORT $LL23@DoSwitchTo
$LN21@DoSwitchTo:

; 4021 : 			}
; 4022 : 		}
; 4023 : 
; 4024 : 	}
; 4025 : 
; 4026 : //	std::vector<PolicyBranchTypes> veOtherPoliciesToUnblock;
; 4027 : 	bool bUnlockBranch;
; 4028 : 
; 4029 : 	// Do a pass over the Policies to see if there are any we can safely unblock
; 4030 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	xor	ebp, ebp
	test	ecx, -4					; fffffffcH
	jle	$LN16@DoSwitchTo
	npad	9
$LL18@DoSwitchTo:

; 4031 : 	{
; 4032 : 		const PolicyBranchTypes eActivateBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 4033 : 		CvPolicyBranchEntry* pkActivateBranchInfo = GC.getPolicyBranchInfo(eActivateBranch);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkActivateBranchInfo$225973[esp+12], eax

; 4034 : 		if(pkActivateBranchInfo)

	test	eax, eax
	je	$LN17@DoSwitchTo

; 4035 : 		{
; 4036 : 			// Must be activatable
; 4037 : 			if(!IsPolicyBranchUnlocked(eActivateBranch))

	mov	edx, DWORD PTR [edi+24]
	cmp	BYTE PTR [edx+ebp], 0
	je	$LN17@DoSwitchTo

; 4038 : 			{
; 4039 : 				continue;
; 4040 : 			}
; 4041 : 
; 4042 : 			// Must be blocked now
; 4043 : 			if(!IsPolicyBranchBlocked(eActivateBranch))

	mov	eax, DWORD PTR [edi+28]
	cmp	BYTE PTR [eax+ebp], 0
	je	$LN17@DoSwitchTo

; 4044 : 			{
; 4045 : 				continue;
; 4046 : 			}
; 4047 : 
; 4048 : 			// Let's try to unblock this
; 4049 : 			bUnlockBranch = true;
; 4050 : 
; 4051 : 			// Loop through all Policies we have and make sure they don't interfere with us
; 4052 : #ifdef AUI_WARNING_FIXES
; 4053 : 			for (uint iOtherBranchLoop = 0; iOtherBranchLoop < m_pPolicies->GetNumPolicyBranches(); iOtherBranchLoop++)
; 4054 : #else
; 4055 : 			for(int iOtherBranchLoop = 0; iOtherBranchLoop < m_pPolicies->GetNumPolicyBranches(); iOtherBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	xor	esi, esi
	mov	bl, 1
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN85@DoSwitchTo
	npad	7
$LL12@DoSwitchTo:

; 4056 : #endif
; 4057 : 			{
; 4058 : 				const PolicyBranchTypes eOtherBranch = static_cast<PolicyBranchTypes>(iOtherBranchLoop);
; 4059 : 				CvPolicyBranchEntry* pkOtherPolicyBranchInfo = GC.getPolicyBranchInfo(eOtherBranch);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 4060 : 				if(pkOtherPolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN11@DoSwitchTo

; 4061 : 				{
; 4062 : 					// Don't test branch against itself
; 4063 : 					if(eActivateBranch != eOtherBranch)

	cmp	ebp, esi
	je	SHORT $LN11@DoSwitchTo

; 4064 : 					{
; 4065 : 						// Is this other branch unlocked and unblocked?
; 4066 : 						if(IsPolicyBranchUnlocked(eOtherBranch))

	mov	edx, DWORD PTR [edi+24]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN4@DoSwitchTo

; 4067 : 						{
; 4068 : 							if(!IsPolicyBranchBlocked(eOtherBranch))

	mov	ecx, DWORD PTR [edi+28]
	cmp	BYTE PTR [esi+ecx], 0
	jne	SHORT $LN4@DoSwitchTo

; 4069 : 							{
; 4070 : 								// Do we block them?
; 4071 : 								if(pkActivateBranchInfo->GetPolicyBranchDisables(eOtherBranch) > 0)

	mov	edx, DWORD PTR _pkActivateBranchInfo$225973[esp+12]
	mov	ecx, DWORD PTR [edx+288]
	test	ecx, ecx
	je	SHORT $LN5@DoSwitchTo
	cmp	DWORD PTR [ecx+esi*4], 0
	jle	SHORT $LN5@DoSwitchTo

; 4072 : 								{
; 4073 : 									bUnlockBranch = false;

	xor	bl, bl
$LN5@DoSwitchTo:

; 4074 : 								}
; 4075 : 								// Do they block us?
; 4076 : 								if(pkOtherPolicyBranchInfo->GetPolicyBranchDisables(eActivateBranch) > 0)

	mov	eax, DWORD PTR [eax+288]
	test	eax, eax
	je	SHORT $LN4@DoSwitchTo
	cmp	DWORD PTR [eax+ebp*4], 0
	jg	SHORT $LN17@DoSwitchTo
$LN4@DoSwitchTo:

; 4077 : 								{
; 4078 : 									bUnlockBranch = false;
; 4079 : 								}
; 4080 : 							}
; 4081 : 						}
; 4082 : 
; 4083 : 						// We've identified that eActivateBranch conflicts with something, so leave it be
; 4084 : 						if(!bUnlockBranch)

	test	bl, bl
	je	SHORT $LN17@DoSwitchTo
$LN11@DoSwitchTo:

; 4044 : 			{
; 4045 : 				continue;
; 4046 : 			}
; 4047 : 
; 4048 : 			// Let's try to unblock this
; 4049 : 			bUnlockBranch = true;
; 4050 : 
; 4051 : 			// Loop through all Policies we have and make sure they don't interfere with us
; 4052 : #ifdef AUI_WARNING_FIXES
; 4053 : 			for (uint iOtherBranchLoop = 0; iOtherBranchLoop < m_pPolicies->GetNumPolicyBranches(); iOtherBranchLoop++)
; 4054 : #else
; 4055 : 			for(int iOtherBranchLoop = 0; iOtherBranchLoop < m_pPolicies->GetNumPolicyBranches(); iOtherBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL12@DoSwitchTo

; 4085 : 						{
; 4086 : 							break;
; 4087 : 						}
; 4088 : 					}
; 4089 : 				}
; 4090 : 			}
; 4091 : 
; 4092 : 			// We know that eActivateBranch doesn't affect anything, so unblock it!
; 4093 : 			if(bUnlockBranch)

	test	bl, bl
	je	SHORT $LN17@DoSwitchTo
$LN85@DoSwitchTo:

; 4094 : 			{
; 4095 : 				SetPolicyBranchBlocked(eActivateBranch, false);

	push	0
	push	ebp
	mov	ecx, edi
	call	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
$LN17@DoSwitchTo:
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	ebp
	sar	edx, 2
	cmp	ebp, edx
	jl	$LL18@DoSwitchTo
$LN16@DoSwitchTo:

; 4096 : 			}
; 4097 : 		}
; 4098 : 	}
; 4099 : 
; 4100 : 	// This Dirty bit must only be set when changing something for the active player
; 4101 : 	if(GC.getGame().getActivePlayer() == GetPlayer()->GetID())

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, esi
	pop	esi
	pop	ebp
	jne	SHORT $LN1@DoSwitchTo

; 4102 : 	{
; 4103 : 		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	32					; 00000020H
	call	eax
$LN1@DoSwitchTo:
	pop	edi
	pop	ebx

; 4104 : 	}
; 4105 : }

	ret	4
?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::DoSwitchToPolicyBranch
_TEXT	ENDS
PUBLIC	?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchFinished
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z
_TEXT	SEGMENT
_eBranchType$ = 8					; size = 4
_bValue$ = 12						; size = 1
?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z PROC ; CvPlayerPolicies::SetPolicyBranchFinished, COMDAT
; _this$ = ecx

; 4248 : {

	push	esi
	mov	esi, ecx

; 4249 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4250 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4251 : 
; 4252 : 	if(bValue != IsPolicyBranchFinished(eBranchType))

	mov	eax, DWORD PTR [esi+32]
	mov	cl, BYTE PTR _bValue$[esp]
	push	edi
	mov	edi, DWORD PTR _eBranchType$[esp+4]
	add	eax, edi
	cmp	cl, BYTE PTR [eax]
	je	$LN1@SetPolicyB@2

; 4253 : 	{
; 4254 : 		m_pabPolicyBranchFinished[eBranchType] = bValue;

	mov	BYTE PTR [eax], cl

; 4255 : 
; 4256 : 
; 4257 : 		bool bUsingXP1Scenario3 = gDLL->IsModActivated(CIV5_XP1_SCENARIO3_MODID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	push	ebx
	push	OFFSET $SG92492
	call	eax

; 4258 : 
; 4259 : 		//Achievements for fulfilling branches
; 4260 : 		if(!GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	bl, al
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN74@SetPolicyB@2

; 4261 : 		{
; 4262 : 			//Must not be playing smokey skies scenario.
; 4263 : 			if(m_pPlayer->GetID() == GC.getGame().getActivePlayer() && !bUsingXP1Scenario3)

	mov	ecx, DWORD PTR [esi+60]
	mov	esi, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN11@SetPolicyB@2
	test	bl, bl
	jne	SHORT $LN11@SetPolicyB@2

; 4264 : 			{
; 4265 : #ifdef AUI_WARNING_FIXES
; 4266 : 				switch (static_cast<int>(eBranchType))
; 4267 : #else
; 4268 : 				switch(eBranchType)

	cmp	edi, 8
	ja	SHORT $LN11@SetPolicyB@2
	jmp	DWORD PTR $LN76@SetPolicyB@2[edi*4]
$LN10@SetPolicyB@2:

; 4269 : #endif
; 4270 : 				{
; 4271 : 				case 0:
; 4272 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_TRADITION);

	push	82					; 00000052H

; 4273 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN9@SetPolicyB@2:

; 4274 : 				case 1:
; 4275 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_LIBERTY);

	push	78					; 0000004eH

; 4276 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN8@SetPolicyB@2:

; 4277 : 				case 2:
; 4278 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_HONOR);

	push	83					; 00000053H

; 4279 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN7@SetPolicyB@2:

; 4280 : 				case 3:
; 4281 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_PIETY);

	push	79					; 0000004fH

; 4282 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN6@SetPolicyB@2:

; 4283 : 				case 4:
; 4284 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_PATRONAGE);

	push	84					; 00000054H

; 4285 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN5@SetPolicyB@2:

; 4286 : 				
; 4287 : 				case 5:	//Aesthetics
; 4288 : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_48);

	push	290					; 00000122H

; 4289 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN4@SetPolicyB@2:

; 4290 : 				case 6:
; 4291 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_COMMERCE);

	push	85					; 00000055H

; 4292 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN3@SetPolicyB@2:

; 4293 : 				case 7: //Exploration
; 4294 : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_47);

	push	289					; 00000121H

; 4295 : 					break;

	jmp	SHORT $LN75@SetPolicyB@2
$LN2@SetPolicyB@2:

; 4296 : 				case 8:
; 4297 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_RATIONALISM);

	push	86					; 00000056H
$LN75@SetPolicyB@2:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN11@SetPolicyB@2:

; 4298 : 					break;
; 4299 : 				}
; 4300 : 			}
; 4301 : 			if(gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_TRADITION) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_HONOR) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_LIBERTY) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_PIETY) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_PATRONAGE) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_ORDER) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_AUTOCRACY)&& gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_FREEDOM)&& gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_COMMERCE)&& gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_RATIONALISM))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	82					; 00000052H
	call	eax
	test	al, al
	je	$LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	83					; 00000053H
	call	eax
	test	al, al
	je	$LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	78					; 0000004eH
	call	eax
	test	al, al
	je	$LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	79					; 0000004fH
	call	eax
	test	al, al
	je	$LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	84					; 00000054H
	call	eax
	test	al, al
	je	$LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	81					; 00000051H
	call	eax
	test	al, al
	je	SHORT $LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	80					; 00000050H
	call	eax
	test	al, al
	je	SHORT $LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	87					; 00000057H
	call	eax
	test	al, al
	je	SHORT $LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	85					; 00000055H
	call	eax
	test	al, al
	je	SHORT $LN74@SetPolicyB@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+832]
	push	86					; 00000056H
	call	eax
	test	al, al
	je	SHORT $LN74@SetPolicyB@2

; 4302 : 			{
; 4303 : 				gDLL->UnlockAchievement(ACHIEVEMENT_ALL_SOCIAL_POLICIES);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	53					; 00000035H
	call	eax
$LN74@SetPolicyB@2:
	pop	ebx
$LN1@SetPolicyB@2:
	pop	edi
	pop	esi

; 4304 : 			}
; 4305 : 		}
; 4306 : 
; 4307 : 	}
; 4308 : }

	ret	8
	npad	2
$LN76@SetPolicyB@2:
	DD	$LN10@SetPolicyB@2
	DD	$LN9@SetPolicyB@2
	DD	$LN8@SetPolicyB@2
	DD	$LN7@SetPolicyB@2
	DD	$LN6@SetPolicyB@2
	DD	$LN5@SetPolicyB@2
	DD	$LN4@SetPolicyB@2
	DD	$LN3@SetPolicyB@2
	DD	$LN2@SetPolicyB@2
?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ENDP ; CvPlayerPolicies::SetPolicyBranchFinished
_TEXT	ENDS
PUBLIC	?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetPolicyBranchChosen
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z PROC ; CvPlayerPolicies::GetPolicyBranchChosen, COMDAT
; _this$ = ecx

; 4364 : 	if(iID < GetNumPolicyBranchesAllowed())

	mov	edx, DWORD PTR [ecx+64]
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6256
	mov	eax, DWORD PTR _iID$[esp-4]
	cmp	eax, edx
	jge	SHORT $LN1@GetPolicyB@2

; 4365 : 	{
; 4366 : 		return m_paePolicyBranchesChosen[iID];

	mov	ecx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [ecx+eax*4]

; 4372 : }

	ret	4
$LN1@GetPolicyB@2:

; 4367 : 	}
; 4368 : 
; 4369 : 	FAssert(false);
; 4370 : 
; 4371 : 	return NO_POLICY_BRANCH_TYPE;

	or	eax, -1

; 4372 : }

	ret	4
?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z ENDP ; CvPlayerPolicies::GetPolicyBranchChosen
_TEXT	ENDS
PUBLIC	?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetPolicyBranchChosen
; Function compile flags: /Ogtpy
;	COMDAT ?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_eBranchType$ = 12					; size = 4
?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetPolicyBranchChosen, COMDAT
; _this$ = ecx

; 4377 : 	FAssert(eBranchType > -1);
; 4378 : 	FAssert(eBranchType < m_pPolicies->GetNumPolicyBranches());
; 4379 : 
; 4380 : 	if(iID < GetNumPolicyBranchesAllowed())

	mov	edx, DWORD PTR [ecx+64]
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6256
	mov	eax, DWORD PTR _iID$[esp-4]
	cmp	eax, edx
	jge	SHORT $LN2@SetPolicyB@3

; 4381 : 	{
; 4382 : 		m_paePolicyBranchesChosen[iID] = eBranchType;

	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _eBranchType$[esp-4]
	mov	DWORD PTR [ecx+eax*4], edx
$LN2@SetPolicyB@3:

; 4383 : 	}
; 4384 : 	else
; 4385 : 	{
; 4386 : 		FAssert(false);
; 4387 : 	}
; 4388 : }

	ret	8
?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetPolicyBranchChosen
_TEXT	ENDS
PUBLIC	?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ
_TEXT	SEGMENT
?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ PROC ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted, COMDAT
; _this$ = ecx

; 4410 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 4411 : 	int iNumPoliciesToAcquire = 0;
; 4412 : 
; 4413 : 	// count the branch openers
; 4414 : #ifdef AUI_WARNING_FIXES
; 4415 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4416 : #else
; 4417 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	push	edi
	xor	ebx, ebx
	xor	edi, edi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN12@GetNumPoli@5
	npad	3
$LL14@GetNumPoli@5:

; 4418 : #endif
; 4419 : 	{
; 4420 : 		PolicyBranchTypes eBranchType = (PolicyBranchTypes)iBranchLoop;
; 4421 : 		if (IsPolicyBranchUnlocked(eBranchType) || CanUnlockPolicyBranch(eBranchType))

	mov	edx, DWORD PTR [esi+24]
	cmp	BYTE PTR [edi+edx], 0
	jne	SHORT $LN10@GetNumPoli@5
	push	edi
	mov	ecx, esi
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	test	al, al
	je	SHORT $LN13@GetNumPoli@5
$LN10@GetNumPoli@5:

; 4422 : 		{
; 4423 : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 4424 : 			if(pkPolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN13@GetNumPoli@5

; 4425 : 			{
; 4426 : 				// Yes, it's a freebie
; 4427 : 				if(pkPolicyBranchInfo->GetFreePolicy() != NO_POLICY)

	cmp	DWORD PTR [eax+264], -1
	je	SHORT $LN13@GetNumPoli@5

; 4428 : 				{
; 4429 : 					iNumPoliciesToAcquire++;

	inc	ebx
$LN13@GetNumPoli@5:

; 4411 : 	int iNumPoliciesToAcquire = 0;
; 4412 : 
; 4413 : 	// count the branch openers
; 4414 : #ifdef AUI_WARNING_FIXES
; 4415 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4416 : #else
; 4417 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	edi
	sar	ecx, 2
	cmp	edi, ecx
	jl	SHORT $LL14@GetNumPoli@5
$LN12@GetNumPoli@5:

; 4430 : 				}
; 4431 : 			}
; 4432 : 		}
; 4433 : 	}
; 4434 : 
; 4435 : 	// count the policies within the branch
; 4436 : #ifdef AUI_WARNING_FIXES
; 4437 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4438 : #else
; 4439 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	xor	edi, edi
	test	edx, -4					; fffffffcH
	jle	SHORT $LN5@GetNumPoli@5
$LL7@GetNumPoli@5:

; 4440 : #endif
; 4441 : 	{
; 4442 : 		const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 4443 : 		CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 4444 : 		if(pkLoopPolicyInfo)

	test	eax, eax
	je	SHORT $LN6@GetNumPoli@5

; 4445 : 		{
; 4446 : 			PolicyBranchTypes eBranchType = (PolicyBranchTypes)pkLoopPolicyInfo->GetPolicyBranchType();

	mov	eax, DWORD PTR [eax+820]

; 4447 : 			if (eBranchType != -1)

	cmp	eax, -1
	je	SHORT $LN6@GetNumPoli@5

; 4448 : 			{
; 4449 : 				if (IsPolicyBranchUnlocked(eBranchType) || CanUnlockPolicyBranch(eBranchType))

	mov	ecx, DWORD PTR [esi+24]
	cmp	BYTE PTR [eax+ecx], 0
	jne	SHORT $LN1@GetNumPoli@5
	push	eax
	mov	ecx, esi
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	test	al, al
	je	SHORT $LN6@GetNumPoli@5
$LN1@GetNumPoli@5:

; 4450 : 				{
; 4451 : 					iNumPoliciesToAcquire++;

	inc	ebx
$LN6@GetNumPoli@5:

; 4430 : 				}
; 4431 : 			}
; 4432 : 		}
; 4433 : 	}
; 4434 : 
; 4435 : 	// count the policies within the branch
; 4436 : #ifdef AUI_WARNING_FIXES
; 4437 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4438 : #else
; 4439 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	inc	edi
	sar	edx, 2
	cmp	edi, edx
	jl	SHORT $LL7@GetNumPoli@5
$LN5@GetNumPoli@5:

; 4452 : 				}
; 4453 : 			}
; 4454 : 		}
; 4455 : 	}
; 4456 : 
; 4457 : 	return iNumPoliciesToAcquire - GetNumPoliciesOwned();

	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	xor	edi, edi
	xor	ecx, ecx
	test	edx, -4					; fffffffcH
	jle	SHORT $LN36@GetNumPoli@5
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [esi+12]
	sar	edx, 2
$LL38@GetNumPoli@5:
	cmp	BYTE PTR [esi+ecx], 0
	je	SHORT $LN37@GetNumPoli@5
	inc	edi
$LN37@GetNumPoli@5:
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL38@GetNumPoli@5
$LN36@GetNumPoli@5:
	mov	eax, ebx
	sub	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4458 : }

	ret	0
?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ ENDP ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted
_TEXT	ENDS
PUBLIC	?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ	; CvPlayerPolicies::CanGetAdvancedTenet
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ PROC	; CvPlayerPolicies::CanGetAdvancedTenet, COMDAT
; _this$ = ecx

; 4807 : {

	push	ebx
	push	edi
	mov	edi, ecx

; 4808 : 	PolicyBranchTypes eIdeology = GetLateGamePolicyTree();

	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	ebx, eax

; 4809 : 	if (eIdeology == NO_POLICY_BRANCH_TYPE)

	cmp	ebx, -1
	jne	SHORT $LN5@CanGetAdva
	pop	edi

; 4810 : 	{
; 4811 : 		return false;

	xor	al, al
	pop	ebx

; 4830 : }

	ret	0
$LN5@CanGetAdva:
	push	ebp
	push	esi

; 4812 : 	}
; 4813 : 		
; 4814 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies

; 4815 : #ifdef AUI_WARNING_FIXES
; 4816 : 	for (uint iI = 0; iI < GC.getNumPolicyInfos(); iI++)
; 4817 : #else
; 4818 : 	for(int iI = 0; iI < GC.getNumPolicyInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	xor	esi, esi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	test	eax, eax
	jle	SHORT $LN2@CanGetAdva
$LL4@CanGetAdva:

; 4819 : #endif
; 4820 : 	{
; 4821 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));
; 4822 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	eax, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [eax+esi*4]

; 4823 : 		if (pEntry && pEntry->GetPolicyBranchType() == eIdeology && pEntry->GetLevel() > 1 && !HasPolicy(eTenet) && CanAdoptPolicy(eTenet))

	test	eax, eax
	je	SHORT $LN3@CanGetAdva
	cmp	DWORD PTR [eax+820], ebx
	jne	SHORT $LN3@CanGetAdva
	cmp	DWORD PTR [eax+276], 1
	jle	SHORT $LN3@CanGetAdva
	mov	ecx, DWORD PTR [edi+12]
	cmp	BYTE PTR [esi+ecx], 0
	jne	SHORT $LN3@CanGetAdva
	push	0
	push	esi
	mov	ecx, edi
	call	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ; CvPlayerPolicies::CanAdoptPolicy
	test	al, al
	jne	SHORT $LN19@CanGetAdva
$LN3@CanGetAdva:

; 4815 : #ifdef AUI_WARNING_FIXES
; 4816 : 	for (uint iI = 0; iI < GC.getNumPolicyInfos(); iI++)
; 4817 : #else
; 4818 : 	for(int iI = 0; iI < GC.getNumPolicyInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	esi, eax
	jl	SHORT $LL4@CanGetAdva
$LN2@CanGetAdva:
	pop	esi
	pop	ebp
	pop	edi

; 4826 : 		}
; 4827 : 	}
; 4828 : 
; 4829 : 	return false;

	xor	al, al
	pop	ebx

; 4830 : }

	ret	0
$LN19@CanGetAdva:
	pop	esi
	pop	ebp
	pop	edi

; 4824 : 		{
; 4825 : 			return true;

	mov	al, 1
	pop	ebx

; 4830 : }

	ret	0
?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ ENDP	; CvPlayerPolicies::CanGetAdvancedTenet
_TEXT	ENDS
PUBLIC	?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z ; CvPlayerPolicies::AddFlavorAsStrategies
EXTRN	?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z:PROC ; CvPolicyAI::AddFlavorWeights
EXTRN	?GetHappiness@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetHappiness
EXTRN	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z:PROC ; CvPlayer::GetUnhappiness
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?getAtWarCount@CvTeam@@QBEH_N@Z:PROC		; CvTeam::getAtWarCount
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
; Function compile flags: /Ogtpy
;	COMDAT ?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z
_TEXT	SEGMENT
_bIsAtWarWithSomeone$226688 = -1			; size = 1
_iPropagatePercent$ = 8					; size = 4
?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z PROC	; CvPlayerPolicies::AddFlavorAsStrategies, COMDAT
; _this$ = ecx

; 4880 : {

	push	ecx
	push	ebp
	mov	ebp, ecx

; 4881 : 	int iFlavorValue;
; 4882 : 
; 4883 : 	// Start by resetting the AI
; 4884 : 	m_pPolicyAI->Reset();

	mov	ecx, DWORD PTR [ebp+56]
	push	edi
	call	?Reset@CvPolicyAI@@QAEXXZ		; CvPolicyAI::Reset

; 4885 : 
; 4886 : 	// Now populate the AI with the current flavor information
; 4887 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	jle	$LN10@AddFlavorA
	push	ebx
	push	esi
	npad	3
$LL12@AddFlavorA:

; 4888 : 	{
; 4889 : //		OLD WAY: use CURRENT player flavors
; 4890 : //		iFlavorValue = GetLatestFlavorValue((FlavorTypes) iFlavor);
; 4891 : 
; 4892 : //		NEW WAY: use PERSONALITY flavors (since policy choices are LONG-TERM)
; 4893 : //		EVEN NEWER WAY: add in a modifier for the Grand Strategy we are running (since these are also long term)
; 4894 : 		iFlavorValue = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavor);

	mov	ecx, DWORD PTR [ebp+60]
	push	edi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4895 : 
; 4896 : //		Boost flavor even further based on in-game conditions
; 4897 : 		
; 4898 : 
; 4899 : 		EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY", true);

	push	1
	push	OFFSET $SG226685
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4900 : 		if (eStrategyLosingMoney == NO_ECONOMICAISTRATEGY)

	cmp	esi, -1
	je	$LN11@AddFlavorA

; 4901 : 		{
; 4902 : 			continue;
; 4903 : 		}
; 4904 : 		CvTeam& kTeam = GET_TEAM(m_pPlayer->getTeam());

	mov	eax, DWORD PTR [ebp+60]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@AddFlavorA
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN22@AddFlavorA
$LN21@AddFlavorA:
	or	eax, -1
$LN22@AddFlavorA:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 4905 : 		bool bIsAtWarWithSomeone = (kTeam.getAtWarCount(false) > 0);

	push	0
	mov	ecx, eax
	call	?getAtWarCount@CvTeam@@QBEH_N@Z		; CvTeam::getAtWarCount

; 4906 : 		bool bInDeficit = m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	ecx, DWORD PTR [ebp+60]
	test	eax, eax
	push	esi
	setg	BYTE PTR _bIsAtWarWithSomeone$226688[esp+24]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy

; 4907 : 
; 4908 : 		if(bInDeficit && iFlavor == GC.getInfoTypeForString("FLAVOR_GOLD"))

	test	al, al
	je	SHORT $LN30@AddFlavorA
	push	0
	push	OFFSET $SG226691
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	edi, eax
	jne	SHORT $LN30@AddFlavorA

; 4909 : 		{
; 4910 : 			iFlavorValue += 5;

	add	ebx, 5
	jmp	SHORT $LN31@AddFlavorA
$LN30@AddFlavorA:

; 4911 : 		}
; 4912 : 		else if(m_pPlayer->GetHappiness() < m_pPlayer->GetUnhappiness() && iFlavor == GC.getInfoTypeForString("FLAVOR_HAPPINESS"))

	mov	ecx, DWORD PTR [ebp+60]
	push	0
	push	0
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	mov	ecx, DWORD PTR [ebp+60]
	mov	esi, eax
	call	?GetHappiness@CvPlayer@@QBEHXZ		; CvPlayer::GetHappiness
	cmp	eax, esi
	jge	SHORT $LN6@AddFlavorA
	push	0
	push	OFFSET $SG226694
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	edi, eax
	jne	SHORT $LN6@AddFlavorA

; 4913 : 		{
; 4914 : 			iFlavorValue += 5;

	add	ebx, 5
	jmp	SHORT $LN31@AddFlavorA
$LN6@AddFlavorA:

; 4915 : 		}
; 4916 : 		else if(bIsAtWarWithSomeone && iFlavor == GC.getInfoTypeForString("FLAVOR_DEFENSE"))

	cmp	BYTE PTR _bIsAtWarWithSomeone$226688[esp+20], 0
	je	SHORT $LN31@AddFlavorA
	push	0
	push	OFFSET $SG226697
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	edi, eax

; 4917 : 		{
; 4918 : 			iFlavorValue += 3;

	je	SHORT $LN32@AddFlavorA

; 4919 : 		}
; 4920 : 		else if(bIsAtWarWithSomeone && iFlavor == GC.getInfoTypeForString("FLAVOR_CITY_DEFENSE"))

	push	0
	push	OFFSET $SG226700
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	edi, eax
	jne	SHORT $LN31@AddFlavorA
$LN32@AddFlavorA:

; 4921 : 		{
; 4922 : 			iFlavorValue += 3;

	add	ebx, 3
$LN31@AddFlavorA:

; 4923 : 		}
; 4924 : 
; 4925 : 		if(iFlavorValue > 0)

	test	ebx, ebx
	jle	SHORT $LN11@AddFlavorA

; 4926 : 		{
; 4927 : 			m_pPolicyAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue, iPropagatePercent);

	mov	eax, DWORD PTR _iPropagatePercent$[esp+16]
	mov	ecx, DWORD PTR [ebp+56]
	push	eax
	push	ebx
	push	edi
	call	?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z ; CvPolicyAI::AddFlavorWeights
$LN11@AddFlavorA:
	inc	edi
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL12@AddFlavorA
	pop	esi
	pop	ebx
$LN10@AddFlavorA:
	pop	edi
	pop	ebp

; 4928 : 		}
; 4929 : 	}
; 4930 : }

	pop	ecx
	ret	4
?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z ENDP	; CvPlayerPolicies::AddFlavorAsStrategies
_TEXT	ENDS
PUBLIC	?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumPlayersWithBranchUnlocked
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z PROC ; PolicyHelpers::GetNumPlayersWithBranchUnlocked, COMDAT

; 4940 : {

	push	ebx

; 4941 : 	int iRtnValue = 0;

	mov	ebx, DWORD PTR _eBranch$[esp]
	push	ebp
	push	esi
	push	edi
	xor	ebp, ebp
	xor	edi, edi
	npad	4
$LL5@GetNumPlay:

; 4944 : 	{
; 4945 : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 4946 : 
; 4947 : 		if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN4@GetNumPlay
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN4@GetNumPlay
	mov	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN4@GetNumPlay

; 4948 : 		{
; 4949 : 			if (kPlayer.GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))

	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, DWORD PTR [eax+24]
	cmp	BYTE PTR [ebx+ecx], 0
	je	SHORT $LN4@GetNumPlay

; 4950 : 			{
; 4951 : 				iRtnValue++;

	inc	ebp
$LN4@GetNumPlay:

; 4942 : 
; 4943 : 	for (int iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL5@GetNumPlay
	pop	edi
	pop	esi

; 4952 : 			}
; 4953 : 		}
; 4954 : 	}
; 4955 : 
; 4956 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 4957 : }

	ret	0
?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ENDP ; PolicyHelpers::GetNumPlayersWithBranchUnlocked
_TEXT	ENDS
PUBLIC	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
EXTRN	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getStartEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_eBranch$ = 8						; size = 4
?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z PROC ; PolicyHelpers::GetNumFreePolicies, COMDAT

; 4960 : {

	push	ebp
	push	esi
	push	edi

; 4961 : 	int iFreePolicies = 0;
; 4962 : 
; 4963 : 	CvPolicyBranchEntry *pkEntry = GC.getPolicyBranchInfo(eBranch);

	mov	edi, DWORD PTR _eBranch$[esp+8]
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	esi, eax

; 4964 : 	if (pkEntry)

	test	esi, esi
	je	SHORT $LN18@GetNumFree@2

; 4965 : 	{
; 4966 : 		if (pkEntry->GetEraPrereq() >= GC.getGame().getStartEra())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	mov	ebx, DWORD PTR [esi+260]
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	cmp	ebx, eax
	pop	ebx
	jl	SHORT $LN18@GetNumFree@2

; 4967 : 		{
; 4968 : 			int iNumPreviousUnlockers = PolicyHelpers::GetNumPlayersWithBranchUnlocked(eBranch);

	push	edi
	call	?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumPlayersWithBranchUnlocked
	add	esp, 4

; 4969 : 			if (iNumPreviousUnlockers == 0)

	test	eax, eax
	jne	SHORT $LN3@GetNumFree@2

; 4974 : 			{
; 4975 : 				iFreePolicies = pkEntry->GetSecondAdopterFreePolicies();
; 4976 : 			}
; 4977 : 		}
; 4978 : 	}
; 4979 : 
; 4980 : 	return iFreePolicies;

	mov	eax, DWORD PTR [esi+272]
	pop	edi
	pop	esi
	pop	ebp

; 4981 : }

	ret	0
$LN3@GetNumFree@2:

; 4970 : 			{
; 4971 : 				iFreePolicies = pkEntry->GetFirstAdopterFreePolicies();
; 4972 : 			}
; 4973 : 			else if (iNumPreviousUnlockers == 1)

	cmp	eax, 1
	jne	SHORT $LN18@GetNumFree@2

; 4974 : 			{
; 4975 : 				iFreePolicies = pkEntry->GetSecondAdopterFreePolicies();
; 4976 : 			}
; 4977 : 		}
; 4978 : 	}
; 4979 : 
; 4980 : 	return iFreePolicies;

	mov	eax, DWORD PTR [esi+276]
	pop	edi
	pop	esi
	pop	ebp

; 4981 : }

	ret	0
$LN18@GetNumFree@2:
	pop	edi
	pop	esi

; 4974 : 			{
; 4975 : 				iFreePolicies = pkEntry->GetSecondAdopterFreePolicies();
; 4976 : 			}
; 4977 : 		}
; 4978 : 	}
; 4979 : 
; 4980 : 	return iFreePolicies;

	mov	eax, ebp
	pop	ebp

; 4981 : }

	ret	0
?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ENDP ; PolicyHelpers::GetNumFreePolicies
_TEXT	ENDS
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::upper_bound
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::upper_bound, COMDAT
; _this$ = ecx

; 1019 : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@upper_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@upper_boun:
	cmp	edx, DWORD PTR [eax+12]
	jge	SHORT $LN4@upper_boun
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN3@upper_boun
$LN4@upper_boun:
	mov	eax, DWORD PTR [eax+8]
$LN3@upper_boun:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@upper_boun
$LN30@upper_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1020 : 		}

	ret	8
?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::upper_bound
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@XZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@XZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::end
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator->
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun
$LN30@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyBranchEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode
	mov	DWORD PTR [eax], 0
$LN27@Buynode:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode
	mov	DWORD PTR [ecx], 0
$LN37@Buynode:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode
	mov	DWORD PTR [ecx], 0
$LN47@Buynode:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+21], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXPAPAVCvPolicyEntry@@0@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXPAPAVCvPolicyEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXPAPAVCvPolicyEntry@@0@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXPAPAVCvPolicyEntry@@0@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXPAPAVCvPolicyBranchEntry@@0@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXPAPAVCvPolicyBranchEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXPAPAVCvPolicyBranchEntry@@0@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXPAPAVCvPolicyBranchEntry@@0@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >::operator+
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
; File s:\msvs2008\vc\include\xtree
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T237678 = -80						; size = 28
$T237677 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T237678[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T237677[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T237678[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T237677[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T237677[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T237677[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T237677[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase:
$LN40@erase:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+21], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN288@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase
	mov	eax, esi
	jmp	SHORT $LN44@erase
$LN43@erase:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min
	add	esp, 4
$LN44@erase:
	mov	DWORD PTR [ebx], eax
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN173@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	6
$LL18@erase:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+20], bl
	je	SHORT $LN292@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN4@erase
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase
$LN292@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+20], 0
$LN291@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T237678[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T237677[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0
$LN4@Buynode@2:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPolicyBranchEntry@@@@YAXAAPAVCvPolicyBranchEntry@@@Z ; SAFE_DELETE<CvPolicyBranchEntry>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvPolicyBranchEntry@@@@YAXAAPAVCvPolicyBranchEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPolicyBranchEntry@@@@YAXAAPAVCvPolicyBranchEntry@@@Z PROC ; SAFE_DELETE<CvPolicyBranchEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN13@SAFE_DELET@2
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyBranchEntry@@6B@
	mov	eax, DWORD PTR [esi+288]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+288], 0
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPolicyBranchEntry@@@@YAXAAPAVCvPolicyBranchEntry@@@Z ENDP ; SAFE_DELETE<CvPolicyBranchEntry>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum BuildingTypes *,enum BuildingTypes *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum BuildingTypes *,enum BuildingTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum BuildingTypes *,enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4PolicyTypes@@PAW41@@stdext@@YAPAW4PolicyTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum PolicyTypes *,enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAW4PolicyTypes@@PAW41@@stdext@@YAPAW4PolicyTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4PolicyTypes@@PAW41@@stdext@@YAPAW4PolicyTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum PolicyTypes *,enum PolicyTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@2
	push	esi
$LL12@Unchecked_@2:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@2
	pop	esi
$LN11@Unchecked_@2:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4PolicyTypes@@PAW41@@stdext@@YAPAW4PolicyTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum PolicyTypes *,enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum BuildingTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum PolicyTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@6
	push	esi
$LL14@Uninit_cop@6:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@6
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@6:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@6
	pop	esi
$LN4@Uninit_cop@6:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@7
	push	esi
$LL14@Uninit_cop@7:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@7
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@7:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@7
	pop	esi
$LN4@Uninit_cop@7:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z
_TEXT	SEGMENT
$T238504 = -4						; size = 1
__Cat$238508 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238504[esp+4], 0
	mov	eax, DWORD PTR $T238504[esp+4]
	mov	ecx, DWORD PTR __Cat$238508[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z
_TEXT	SEGMENT
$T238513 = -4						; size = 1
__Cat$238517 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238513[esp+4], 0
	mov	eax, DWORD PTR $T238513[esp+4]
	mov	ecx, DWORD PTR __Cat$238517[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z
_TEXT	SEGMENT
$T238522 = -4						; size = 1
__Cat$238526 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238522[esp+4], 0
	mov	eax, DWORD PTR $T238522[esp+4]
	mov	ecx, DWORD PTR __Cat$238526[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z
_TEXT	SEGMENT
$T238531 = -4						; size = 1
__Cat$238535 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238531[esp+4], 0
	mov	eax, DWORD PTR $T238531[esp+4]
	mov	ecx, DWORD PTR __Cat$238535[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
_TEXT	ENDS
;	COMDAT ?FlavorUpdate@CvPlayerPolicies@@UAEXXZ
_TEXT	SEGMENT
?FlavorUpdate@CvPlayerPolicies@@UAEXXZ PROC		; CvPlayerPolicies::FlavorUpdate, COMDAT
; _this$ = ecx

; 2814 : 	AddFlavorAsStrategies(GC.getPOLICY_WEIGHT_PROPAGATION_PERCENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1824
	push	eax
	call	?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z ; CvPlayerPolicies::AddFlavorAsStrategies

; 2815 : }

	ret	0
?FlavorUpdate@CvPlayerPolicies@@UAEXXZ ENDP		; CvPlayerPolicies::FlavorUpdate
_TEXT	ENDS
PUBLIC	?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ; CvPlayerPolicies::SetPolicy
EXTRN	?ChangeNumFreePoliciesEver@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeNumFreePoliciesEver
EXTRN	?ChangeNumPolicies@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bBranchFinished$225461 = 12				; size = 1
_bNewValue$ = 12					; size = 1
?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::SetPolicy, COMDAT
; _this$ = ecx

; 2833 : {

	push	ebp
	push	esi

; 2834 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2835 : 	CvAssertMsg(eIndex < m_pPolicies->GetNumPolicies(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2836 : 
; 2837 : 	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eIndex);

	mov	esi, DWORD PTR _eIndex$[esp+4]
	push	edi
	mov	edi, ecx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	ebp, eax

; 2838 : 	if(pkPolicyInfo == NULL)

	test	ebp, ebp
	je	$LN1@SetPolicy

; 2839 : 		return;
; 2840 : 
; 2841 : 	if(HasPolicy(eIndex) != bNewValue)

	mov	eax, DWORD PTR [edi+12]
	push	ebx
	mov	bl, BYTE PTR _bNewValue$[esp+12]
	add	eax, esi
	cmp	BYTE PTR [eax], bl
	je	$LN54@SetPolicy

; 2842 : 	{
; 2843 : 		m_pabHasPolicy[eIndex] = bNewValue;
; 2844 : 
; 2845 : 		int iChange = bNewValue ? 1 : -1;

	xor	ecx, ecx
	test	bl, bl
	setne	cl
	mov	BYTE PTR [eax], bl
	lea	ecx, DWORD PTR [ecx+ecx-1]

; 2846 : 		GetPlayer()->ChangeNumPolicies(iChange);

	push	ecx
	mov	ecx, DWORD PTR [edi+60]
	call	?ChangeNumPolicies@CvPlayer@@QAEXH@Z	; CvPlayer::ChangeNumPolicies

; 2847 : 
; 2848 : 		if(bNewValue)

	test	bl, bl
	je	SHORT $LN52@SetPolicy

; 2849 : 		{
; 2850 : 			DoNewPolicyPickedForHistory(eIndex);

	push	esi
	mov	ecx, edi
	call	?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z ; CvPlayerPolicies::DoNewPolicyPickedForHistory

; 2851 : 
; 2852 : 			if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	edx, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edx+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN52@SetPolicy

; 2853 : 				GC.GetEngineUserInterface()->SetPolicyNotificationSeen(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+512]
	push	0
	call	edx
$LN52@SetPolicy:

; 2854 : 		}
; 2855 : 
; 2856 : 		PolicyBranchTypes eThisBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	ebp, DWORD PTR [ebp+820]

; 2857 : 
; 2858 : 		if(eThisBranch != NO_POLICY_BRANCH_TYPE)

	cmp	ebp, -1
	je	$LN54@SetPolicy

; 2859 : 		{
; 2860 : 			bool bBranchFinished;
; 2861 : 
; 2862 : 			// We don't have this Policy, so this branch is definitely not finished
; 2863 : 			if(!bNewValue)

	test	bl, bl

; 2864 : 			{
; 2865 : 				bBranchFinished = false;
; 2866 : 			}
; 2867 : 			// We now have this Policy, so we MAY have this branch finished
; 2868 : 			else

	je	SHORT $LN50@SetPolicy

; 2869 : 			{
; 2870 : 				bBranchFinished = true;
; 2871 : 
; 2872 : 				// Is the branch this policy is in finished?
; 2873 : #ifdef AUI_WARNING_FIXES
; 2874 : 				for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 2875 : #else
; 2876 : 				for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	bl, 1
	xor	esi, esi
	mov	BYTE PTR _bBranchFinished$225461[esp+12], bl
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN53@SetPolicy
$LL9@SetPolicy:

; 2877 : #endif
; 2878 : 				{
; 2879 : 					const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 2880 : 
; 2881 : 					CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 2882 : 					if(pkLoopPolicyInfo)

	test	eax, eax
	je	SHORT $LN8@SetPolicy

; 2883 : 					{
; 2884 : 						// This policy belongs to our branch
; 2885 : 						if(pkLoopPolicyInfo->GetPolicyBranchType() == eThisBranch)

	cmp	DWORD PTR [eax+820], ebp
	jne	SHORT $LN8@SetPolicy

; 2886 : 						{
; 2887 : 							// We don't have this policy!
; 2888 : 							if(!HasPolicy(eLoopPolicy))

	mov	edx, DWORD PTR [edi+12]
	cmp	BYTE PTR [esi+edx], 0
	je	SHORT $LN50@SetPolicy
$LN8@SetPolicy:

; 2869 : 			{
; 2870 : 				bBranchFinished = true;
; 2871 : 
; 2872 : 				// Is the branch this policy is in finished?
; 2873 : #ifdef AUI_WARNING_FIXES
; 2874 : 				for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 2875 : #else
; 2876 : 				for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL9@SetPolicy

; 2886 : 						{
; 2887 : 							// We don't have this policy!
; 2888 : 							if(!HasPolicy(eLoopPolicy))

	jmp	SHORT $LN53@SetPolicy
$LN50@SetPolicy:

; 2889 : 							{
; 2890 : 								bBranchFinished = false;

	xor	bl, bl
	mov	BYTE PTR _bBranchFinished$225461[esp+12], bl
$LN53@SetPolicy:

; 2891 : 
; 2892 : 								// No need to continue, we already know we don't have the branch
; 2893 : 								break;
; 2894 : 							}
; 2895 : 						}
; 2896 : 					}
; 2897 : 				}
; 2898 : 			}
; 2899 : 
; 2900 : 			SetPolicyBranchFinished(eThisBranch, bBranchFinished);

	mov	edx, DWORD PTR _bBranchFinished$225461[esp+12]
	push	edx
	push	ebp
	mov	ecx, edi
	call	?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchFinished

; 2901 : 
; 2902 : 			if(bBranchFinished)

	test	bl, bl
	je	SHORT $LN54@SetPolicy

; 2903 : 			{
; 2904 : 				CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eThisBranch);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 2905 : 				if(pkPolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN54@SetPolicy

; 2906 : 				{
; 2907 : 					PolicyTypes eFinisher = (PolicyTypes)pkPolicyBranchInfo->GetFreeFinishingPolicy();

	mov	eax, DWORD PTR [eax+268]

; 2908 : 					if(eFinisher != NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN54@SetPolicy

; 2909 : 					{
; 2910 : 						GetPlayer()->setHasPolicy(eFinisher, true);

	mov	ecx, DWORD PTR [edi+60]
	push	1
	push	eax
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy

; 2911 : 						GetPlayer()->ChangeNumFreePoliciesEver(1);

	mov	ecx, DWORD PTR [edi+60]
	push	1
	call	?ChangeNumFreePoliciesEver@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePoliciesEver
$LN54@SetPolicy:
	pop	ebx
$LN1@SetPolicy:
	pop	edi
	pop	esi
	pop	ebp

; 2912 : 					}
; 2913 : 				}
; 2914 : 			}
; 2915 : 		}
; 2916 : 	}
; 2917 : }

	ret	8
?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::SetPolicy
_TEXT	ENDS
PUBLIC	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked
EXTRN	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumFreePolicies
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?ChangeNumFreeTenets@CvPlayer@@QAEXH_N@Z:PROC	; CvPlayer::ChangeNumFreeTenets
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
_TEXT	SEGMENT
_pkPolicyBranchInfo$225887 = -144			; size = 4
$T238794 = -140						; size = 4
$T238792 = -140						; size = 4
$T238795 = -136						; size = 4
$T238791 = -136						; size = 4
_iNotifyLoop$225890 = -132				; size = 4
tv629 = -128						; size = 4
$T238799 = -124						; size = 28
$T238798 = -124						; size = 28
$T238797 = -124						; size = 28
$T238796 = -124						; size = 28
$T238793 = -124						; size = 28
_strBuffer$225902 = -96					; size = 28
_strSummary$225933 = -68				; size = 28
$T238800 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eBranchType$ = 8					; size = 4
_bNewValue$ = 12					; size = 1
_bRevolution$ = 16					; size = 1
?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z PROC ; CvPlayerPolicies::SetPolicyBranchUnlocked, COMDAT
; _this$ = ecx

; 3896 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 132				; 00000084H
	push	ebx

; 3897 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3898 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 3899 : 
; 3900 : 	if(IsPolicyBranchUnlocked(eBranchType) != bNewValue)

	mov	bl, BYTE PTR _bNewValue$[esp+144]
	push	ebp
	mov	ebp, ecx
	mov	eax, DWORD PTR [ebp+24]
	push	edi
	mov	edi, DWORD PTR _eBranchType$[esp+152]
	mov	al, BYTE PTR [edi+eax]
	cmp	al, bl
	je	$LN18@SetPolicyB@4

; 3901 : 	{
; 3902 : 		// Unlocked?
; 3903 : 		if (bNewValue)

	test	bl, bl
	je	$LN1@SetPolicyB@4
	push	esi

; 3904 : 		{
; 3905 : 			int iFreePolicies = PolicyHelpers::GetNumFreePolicies(eBranchType);

	push	edi
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	add	esp, 4

; 3906 : 
; 3907 : 			// Late-game tree so want to issue notification?
; 3908 : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$225887[esp+160], eax

; 3909 : 			if(pkPolicyBranchInfo != NULL)

	test	eax, eax
	je	$LN121@SetPolicyB@4

; 3910 : 			{
; 3911 : 				if (pkPolicyBranchInfo->IsPurchaseByLevel())

	cmp	BYTE PTR [eax+280], 0
	je	$LN15@SetPolicyB@4

; 3912 : 				{
; 3913 : 					m_pPlayer->ChangeNumFreeTenets(iFreePolicies, !bRevolution);

	cmp	BYTE PTR _bRevolution$[esp+156], 0
	sete	cl
	movzx	edx, cl
	mov	ecx, DWORD PTR [ebp+60]
	push	edx
	push	esi
	call	?ChangeNumFreeTenets@CvPlayer@@QAEXH_N@Z ; CvPlayer::ChangeNumFreeTenets

; 3914 : 
; 3915 : 					for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	xor	esi, esi
	mov	DWORD PTR _iNotifyLoop$225890[esp+160], esi
	mov	DWORD PTR tv629[esp+160], esi
	npad	10
$LL14@SetPolicyB@4:

; 3916 : 						PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;
; 3917 : 						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
; 3918 : 
; 3919 : 						// Issue notification if OTHER than target player
; 3920 : 						if (m_pPlayer->GetID() != eNotifyPlayer)

	mov	ecx, DWORD PTR [ebp+60]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [ecx+44]
	add	esi, eax
	cmp	edx, DWORD PTR _iNotifyLoop$225890[esp+160]
	je	$LN13@SetPolicyB@4

; 3921 : 						{
; 3922 : 							CvTeam& kNotifyTeam = GET_TEAM(kCurNotifyPlayer.getTeam());

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN43@SetPolicyB@4
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edi+eax*4]
	jmp	SHORT $LN44@SetPolicyB@4
$LN43@SetPolicyB@4:
	or	eax, -1
$LN44@SetPolicyB@4:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 3923 : 							const bool bHasMet = kNotifyTeam.isHasMet(m_pPlayer->getTeam());

	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN54@SetPolicyB@4
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN55@SetPolicyB@4
$LN54@SetPolicyB@4:
	or	edx, -1
$LN55@SetPolicyB@4:
	push	edx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet

; 3924 : 
; 3925 : 							CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();

	mov	ecx, esi
	mov	bl, al
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 3926 : 							if(pNotifications)

	test	edi, edi
	je	$LN13@SetPolicyB@4

; 3927 : 							{
; 3928 : 								CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$225902[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3929 : 								if(bHasMet)
; 3930 : 								{
; 3931 : 									if (bRevolution)
; 3932 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHANGE", m_pPlayer->getCivilizationShortDescriptionKey(), pkPolicyBranchInfo->GetDescriptionKey());

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225887[esp+160]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	bl, bl
	je	SHORT $LN9@SetPolicyB@4
	cmp	BYTE PTR _bRevolution$[esp+156], 0
	mov	ecx, DWORD PTR [ebp+60]
	je	SHORT $LN8@SetPolicyB@4
	mov	DWORD PTR $T238791[esp+160], eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	lea	edx, DWORD PTR $T238791[esp+160]
	push	edx
	mov	DWORD PTR $T238792[esp+164], eax
	lea	eax, DWORD PTR $T238792[esp+164]
	push	eax
	lea	ecx, DWORD PTR $T238793[esp+168]
	push	OFFSET $SG225915
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+168], 1

; 3933 : 									else

	jmp	SHORT $LN122@SetPolicyB@4
$LN8@SetPolicyB@4:

; 3934 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHOSEN", m_pPlayer->getCivilizationShortDescriptionKey(), pkPolicyBranchInfo->GetDescriptionKey());

	mov	DWORD PTR $T238794[esp+160], eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	lea	edx, DWORD PTR $T238794[esp+160]
	push	edx
	mov	DWORD PTR $T238795[esp+164], eax
	lea	eax, DWORD PTR $T238795[esp+164]
	push	eax
	lea	ecx, DWORD PTR $T238796[esp+168]
	push	OFFSET $SG225920
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+168], 2

; 3935 : 								}
; 3936 : 								else

	jmp	SHORT $LN122@SetPolicyB@4
$LN9@SetPolicyB@4:

; 3937 : 								{
; 3938 : 									if (bRevolution)

	cmp	BYTE PTR _bRevolution$[esp+156], 0

; 3939 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHANGE_UNMET", pkPolicyBranchInfo->GetDescriptionKey());

	push	eax
	je	SHORT $LN5@SetPolicyB@4
	lea	edx, DWORD PTR $T238797[esp+164]
	push	OFFSET $SG225929
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+168], 3

; 3940 : 									else

	jmp	SHORT $LN122@SetPolicyB@4
$LN5@SetPolicyB@4:

; 3941 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHOSEN_UNMET", pkPolicyBranchInfo->GetDescriptionKey());

	lea	eax, DWORD PTR $T238798[esp+164]
	push	OFFSET $SG225932
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+168], 4
$LN122@SetPolicyB@4:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225902[esp+164]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238798[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3942 : 								}
; 3943 : 
; 3944 : 								CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$225933[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3945 : 								if (bRevolution)

	cmp	BYTE PTR _bRevolution$[esp+156], 0
	mov	BYTE PTR __$EHRec$[esp+168], 5
	je	SHORT $LN3@SetPolicyB@4

; 3946 : 									strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_IDEOLOGY_CHANGE");

	lea	ecx, DWORD PTR $T238799[esp+160]
	push	OFFSET $SG225936
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$225933[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238799[esp+160]

; 3947 : 								else

	jmp	SHORT $LN123@SetPolicyB@4
$LN3@SetPolicyB@4:

; 3948 : 									strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_IDEOLOGY_CHOSEN");

	lea	edx, DWORD PTR $T238800[esp+160]
	push	OFFSET $SG225939
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$225933[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 7
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238800[esp+160]
$LN123@SetPolicyB@4:
	mov	BYTE PTR __$EHRec$[esp+168], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3949 : 
; 3950 : 								pNotifications->Add(NOTIFICATION_IDEOLOGY_CHOSEN, strBuffer, strSummary, -1, -1, m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebp+60]
	mov	esi, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _strSummary$225933[esp+160]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225902[esp+180]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1871397394				; 9074bdeeH
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3951 : 							}

	lea	ecx, DWORD PTR _strSummary$225933[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$225902[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN13@SetPolicyB@4:
	mov	esi, DWORD PTR tv629[esp+160]
	inc	DWORD PTR _iNotifyLoop$225890[esp+160]
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv629[esp+160], esi
	jl	$LL14@SetPolicyB@4

; 3952 : 						}
; 3953 : 					}
; 3954 : 				}
; 3955 : 				else

	mov	bl, BYTE PTR _bNewValue$[esp+156]
	mov	edi, DWORD PTR _eBranchType$[esp+156]
	jmp	SHORT $LN121@SetPolicyB@4
$LN15@SetPolicyB@4:

; 3956 : 				{
; 3957 : 					m_pPlayer->ChangeNumFreePolicies(iFreePolicies);

	mov	ecx, DWORD PTR [ebp+60]
	push	esi
	call	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePolicies
$LN121@SetPolicyB@4:
	pop	esi
$LN1@SetPolicyB@4:

; 3958 : 				}
; 3959 : 			}
; 3960 : 		}
; 3961 : 
; 3962 : 		m_pabPolicyBranchUnlocked[eBranchType] = bNewValue;

	mov	ecx, DWORD PTR [ebp+24]
	mov	BYTE PTR [edi+ecx], bl
$LN18@SetPolicyB@4:

; 3963 : 	}
; 3964 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+156]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 144				; 00000090H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225902[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR $T238793[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$2:
	lea	ecx, DWORD PTR $T238796[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$3:
	lea	ecx, DWORD PTR $T238797[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$4:
	lea	ecx, DWORD PTR $T238798[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$5:
	lea	ecx, DWORD PTR _strSummary$225933[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$6:
	lea	ecx, DWORD PTR $T238799[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$7:
	lea	ecx, DWORD PTR $T238800[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ENDP ; CvPlayerPolicies::SetPolicyBranchUnlocked
PUBLIC	?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchIdeologies
EXTRN	?setJONSCulture@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::setJONSCulture
EXTRN	?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z:PROC ; CvPlayerCulture::SetTurnIdeologySwitch
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?DoPublicOpinion@CvPlayerCulture@@QAEXXZ:PROC	; CvPlayerCulture::DoPublicOpinion
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
; Function compile flags: /Ogtpy
;	COMDAT ?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
$T238989 = -8						; size = 4
$T238990 = -4						; size = 4
_eNewBranchType$ = 8					; size = 4
?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::DoSwitchIdeologies, COMDAT
; _this$ = ecx

; 4178 : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 4179 : 	PolicyBranchTypes eOldBranchType = GetLateGamePolicyTree();

	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	edi, eax

; 4180 : 	CvAssertMsg (eOldBranchType != eNewBranchType && eNewBranchType != NO_POLICY_BRANCH_TYPE && eOldBranchType != NO_POLICY_BRANCH_TYPE, "Illegal time for Ideology change");
; 4181 : 
; 4182 : 	int iOldBranchTenets = GetNumPoliciesOwnedInBranch(eOldBranchType);

	push	edi
	mov	ecx, esi
	call	?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch

; 4183 : 	int iNewBranchTenets = max(0, iOldBranchTenets - GC.getSWITCH_POLICY_BRANCHES_TENETS_LOST());

	sub	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6980
	mov	DWORD PTR $T238990[esp+20], 0
	mov	DWORD PTR $T238989[esp+20], eax
	test	eax, eax
	lea	eax, DWORD PTR $T238989[esp+20]
	jg	SHORT $LN9@DoSwitchId
	lea	eax, DWORD PTR $T238990[esp+20]
$LN9@DoSwitchId:
	mov	ebx, DWORD PTR [eax]

; 4184 : 
; 4185 : 	ClearPolicyBranch(eOldBranchType);

	push	edi
	mov	ecx, esi
	call	?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::ClearPolicyBranch

; 4186 : 	SetPolicyBranchUnlocked(eOldBranchType, false, false);

	mov	eax, DWORD PTR [esi+24]
	add	eax, edi
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN27@DoSwitchId
	mov	BYTE PTR [eax], 0
$LN27@DoSwitchId:

; 4187 : 
; 4188 : 	SetPolicyBranchUnlocked(eNewBranchType, true, true /*bRevolution*/);

	mov	ecx, DWORD PTR _eNewBranchType$[esp+16]
	push	1
	push	1
	push	ecx
	mov	ecx, esi
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 4189 : 	m_pPlayer->GetCulture()->DoPublicOpinion();

	mov	ecx, DWORD PTR [esi+60]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoPublicOpinion@CvPlayerCulture@@QAEXXZ ; CvPlayerCulture::DoPublicOpinion

; 4190 : 	m_pPlayer->GetCulture()->SetTurnIdeologySwitch(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+60]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::SetTurnIdeologySwitch

; 4191 : 	m_pPlayer->setJONSCulture(0);

	mov	ecx, DWORD PTR [esi+60]
	push	0
	call	?setJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::setJONSCulture

; 4192 : 	m_pPlayer->ChangeNumFreeTenets(iNewBranchTenets, false /*bCountAsFreePolicies*/);

	mov	ecx, DWORD PTR [esi+60]
	push	0
	push	ebx
	call	?ChangeNumFreeTenets@CvPlayer@@QAEXH_N@Z ; CvPlayer::ChangeNumFreeTenets

; 4193 : 
; 4194 : 	if (GC.getGame().getActivePlayer() == m_pPlayer->GetID())

	mov	edx, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edx+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	pop	edi
	cmp	eax, esi
	pop	esi
	pop	ebx
	jne	SHORT $LN1@DoSwitchId

; 4195 : 	{
; 4196 : 		DLLUI->setDirty(Policies_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	32					; 00000020H
	call	edx
$LN1@DoSwitchId:

; 4197 : 	}
; 4198 : }

	add	esp, 8
	ret	4
?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::DoSwitchIdeologies
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
; Function compile flags: /Ogtpy
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
$T239373 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jge	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jl	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T239373[esp+8], eax
	lea	eax, DWORD PTR $T239373[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@3
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@3:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T240140 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@4
	cmp	edx, eax
	jne	SHORT $LN101@erase@4

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@4:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@4
	npad	2
$LL2@erase@4:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+21], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@4
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN103@erase@4
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN79@erase@4
	npad	5
$LL80@erase@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL80@erase@4
$LN79@erase@4:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@4
$LN103@erase@4:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN63@erase@4
	npad	7
$LL64@erase@4:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@4
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL64@erase@4
$LN63@erase@4:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@4:
	push	edx
	lea	eax, DWORD PTR $T240140[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@4
$LN1@erase@4:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+21], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+20]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+21], 0
	mov	edi, eax
	je	SHORT $LN2@Copy

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy:
$LN28@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T240501 = -80						; size = 28
$T240500 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 536870910		; 1ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T240501[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T240500[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T240501[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T240500[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T240500[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T240500[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T240500[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+20], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+20], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T240501[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$2:
	lea	ecx, DWORD PTR $T240500[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum BuildingTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@0AAV?$allocator@W4BuildingTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@std@@@Z
_TEXT	SEGMENT
$T240961 = -4						; size = 1
__Cat$240966 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240961[esp+4], 0
	mov	eax, DWORD PTR $T240961[esp+4]
	mov	ecx, DWORD PTR __Cat$240966[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum PolicyTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@0AAV?$allocator@W4PolicyTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@std@@@Z
_TEXT	SEGMENT
$T240978 = -4						; size = 1
__Cat$240983 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240978[esp+4], 0
	mov	eax, DWORD PTR $T240978[esp+4]
	mov	ecx, DWORD PTR __Cat$240983[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z
_TEXT	SEGMENT
$T240987 = -4						; size = 1
__Cat$240991 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240987[esp+4], 0
	mov	eax, DWORD PTR $T240987[esp+4]
	mov	ecx, DWORD PTR __Cat$240991[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z
_TEXT	SEGMENT
$T240996 = -4						; size = 1
__Cat$241000 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240996[esp+4], 0
	mov	eax, DWORD PTR $T240996[esp+4]
	mov	ecx, DWORD PTR __Cat$241000[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241014 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241017 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$241017[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241014[esp+4], 0
	mov	eax, DWORD PTR $T241014[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241033 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241036 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$241036[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241033[esp+4], 0
	mov	eax, DWORD PTR $T241033[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@U_Undefined_move_tag@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241052 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241056 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$241056[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241052[esp+4], 0
	mov	eax, DWORD PTR $T241052[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241071 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241075 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$241075[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241071[esp+4], 0
	mov	eax, DWORD PTR $T241071[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@3
	pop	esi
$LN9@Uninit_fil@3:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z ; CvPolicyEntry::IsFreePromotionUnitCombat
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
;	COMDAT ?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_promotionID$ = 8					; size = 4
_unitCombatID$ = 12					; size = 4
?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z PROC ; CvPolicyEntry::IsFreePromotionUnitCombat, COMDAT
; _this$ = ecx

; 2134 : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 2135 : 	std::multimap<int, int>::const_iterator it = m_FreePromotionUnitCombats.find(promotionID);

	lea	eax, DWORD PTR _promotionID$[esp+8]
	push	eax
	lea	ecx, DWORD PTR _it$[esp+16]
	lea	esi, DWORD PTR [edi+952]
	push	ecx
	mov	ecx, esi
	call	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find

; 2136 : 	if(it != m_FreePromotionUnitCombats.end())

	mov	edx, DWORD PTR _it$[esp+12]
	cmp	edx, DWORD PTR [edi+956]
	je	SHORT $LN2@IsFreeProm@2

; 2137 : 	{
; 2138 : 		// get an iterator to the element that is one past the last element associated with key
; 2139 : 		std::multimap<int, int>::const_iterator lastElement = m_FreePromotionUnitCombats.upper_bound(promotionID);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	mov	esi, ecx
	jne	SHORT $LN20@IsFreeProm@2
	mov	ecx, DWORD PTR _promotionID$[esp+8]
	npad	6
$LL21@IsFreeProm@2:
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN19@IsFreeProm@2
	mov	esi, eax
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@IsFreeProm@2
$LN19@IsFreeProm@2:
	mov	eax, DWORD PTR [eax+8]
$LN18@IsFreeProm@2:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL21@IsFreeProm@2
$LN20@IsFreeProm@2:

; 2140 : 
; 2141 : 		// for each element in the sequence [itr, lastElement)
; 2142 : 		for(; it != lastElement; ++it)

	cmp	edx, esi
	je	SHORT $LN2@IsFreeProm@2
	mov	edi, DWORD PTR _unitCombatID$[esp+8]
	npad	4
$LL44@IsFreeProm@2:

; 2143 : 		{
; 2144 : 			if(it->second == unitCombatID)

	cmp	DWORD PTR [edx+16], edi
	je	SHORT $LN58@IsFreeProm@2
	lea	ecx, DWORD PTR _it$[esp+12]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
	mov	edx, DWORD PTR _it$[esp+12]
	cmp	edx, esi
	jne	SHORT $LL44@IsFreeProm@2
$LN2@IsFreeProm@2:
	pop	edi

; 2147 : 			}
; 2148 : 		}
; 2149 : 	}
; 2150 : 
; 2151 : 	return false;

	xor	al, al
	pop	esi

; 2152 : }

	pop	ecx
	ret	8
$LN58@IsFreeProm@2:
	pop	edi

; 2145 : 			{
; 2146 : 				return true;

	mov	al, 1
	pop	esi

; 2152 : }

	pop	ecx
	ret	8
?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z ENDP ; CvPolicyEntry::IsFreePromotionUnitCombat
_TEXT	ENDS
PUBLIC	?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoUnlockPolicyBranch
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateNextPolicyCost
EXTRN	?changeJONSCulture@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeJONSCulture
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z$0
__ehfuncinfo$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_args$225848 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bResult$225849 = 8					; size = 1
_eBranchType$ = 8					; size = 4
?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::DoUnlockPolicyBranch, COMDAT
; _this$ = ecx

; 3763 : {

	push	-1
	push	__ehhandler$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebp
	push	esi
	push	edi

; 3764 : 	CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	mov	edi, DWORD PTR _eBranchType$[esp+24]
	mov	esi, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	ebp, eax

; 3765 : 	if(pkPolicyBranchInfo == NULL)

	test	ebp, ebp
	je	$LN1@DoUnlockPo

; 3766 : 	{
; 3767 : 		return;
; 3768 : 	}
; 3769 : 
; 3770 : 	// Can we actually do this?
; 3771 : 	if(!CanUnlockPolicyBranch(eBranchType))

	push	edi
	mov	ecx, esi
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	test	al, al
	je	$LN1@DoUnlockPo

; 3772 : 	{
; 3773 : 		return;
; 3774 : 	}
; 3775 : 
; 3776 : 	// Set that we now have it
; 3777 : 	SetPolicyBranchUnlocked(eBranchType, true, false);

	push	0
	push	1
	push	edi
	mov	ecx, esi
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 3778 : 
; 3779 : 	// Are we blocked? If so, unblock us
; 3780 : 	DoSwitchToPolicyBranch(eBranchType);

	push	edi
	mov	ecx, esi
	call	?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchToPolicyBranch

; 3781 : 
; 3782 : 	// Free Policy with this Branch?
; 3783 : 	PolicyTypes eFreePolicy = (PolicyTypes) pkPolicyBranchInfo->GetFreePolicy();

	mov	eax, DWORD PTR [ebp+264]

; 3784 : 	if(eFreePolicy != NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN49@DoUnlockPo

; 3785 : 	{
; 3786 : 		GetPlayer()->setHasPolicy(eFreePolicy, true);

	mov	ecx, DWORD PTR [esi+60]
	push	1
	push	eax
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
$LN49@DoUnlockPo:

; 3787 : 	}
; 3788 : 
; 3789 : 	// Pay Culture cost - if applicable
; 3790 : 	if(GetPlayer()->GetNumFreePolicies() == 0)

	mov	ecx, DWORD PTR [esi+60]
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jne	SHORT $LN4@DoUnlockPo

; 3791 : 	{
; 3792 : 		GetPlayer()->changeJONSCulture(-GetPlayer()->getNextPolicyCost());

	mov	ebp, DWORD PTR [esi+60]
	mov	ecx, ebp
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	neg	eax
	push	eax
	mov	ecx, ebp
	call	?changeJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::changeJONSCulture

; 3793 : 	}
; 3794 : 	else

	jmp	SHORT $LN3@DoUnlockPo
$LN4@DoUnlockPo:

; 3795 : 	{
; 3796 : 		GetPlayer()->ChangeNumFreePolicies(-1);

	mov	ecx, DWORD PTR [esi+60]
	push	-1
	call	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePolicies
$LN3@DoUnlockPo:

; 3797 : 	}
; 3798 : 
; 3799 : 	// Update cost if trying to buy another policy this turn
; 3800 : 	GetPlayer()->DoUpdateNextPolicyCost();

	mov	ecx, DWORD PTR [esi+60]
	call	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ ; CvPlayer::DoUpdateNextPolicyCost

; 3801 : 
; 3802 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx

; 3803 : 
; 3804 : 	// This Dirty bit must only be set when changing something for the active player
; 3805 : 	if(GC.getGame().getActivePlayer() == GetPlayer()->GetID())

	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, ebp
	jne	SHORT $LN2@DoUnlockPo

; 3806 : 	{
; 3807 : 		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	32					; 00000020H
	call	edx
$LN2@DoUnlockPo:

; 3808 : 	}
; 3809 : 
; 3810 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ebp, eax

; 3811 : 	if(pkScriptSystem)

	test	ebp, ebp
	je	SHORT $LN1@DoUnlockPo

; 3812 : 	{
; 3813 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225848[esp+28]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 3814 : 		args->Push(m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _args$225848[esp+28]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	eax

; 3815 : 		args->Push(eBranchType);

	mov	ecx, DWORD PTR _args$225848[esp+28]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 3816 : 
; 3817 : 		// Attempt to execute the game events.
; 3818 : 		// Will return false if there are no registered listeners.
; 3819 : 		bool bResult = false;
; 3820 : 		LuaSupport::CallHook(pkScriptSystem, "PlayerAdoptPolicyBranch", args.get(), bResult);

	mov	edx, DWORD PTR _args$225848[esp+28]
	lea	ecx, DWORD PTR _bResult$225849[esp+24]
	push	ecx
	push	edx
	push	OFFSET $SG225850
	push	ebp
	mov	BYTE PTR _bResult$225849[esp+40], 0
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 3821 : 	}

	lea	ecx, DWORD PTR _args$225848[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN1@DoUnlockPo:

; 3822 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$225848[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::DoUnlockPolicyBranch
PUBLIC	?DoPolicyAI@CvPlayerPolicies@@QAEXXZ		; CvPlayerPolicies::DoPolicyAI
EXTRN	?doAdoptPolicy@CvPlayer@@QAEXW4PolicyTypes@@@Z:PROC ; CvPlayer::doAdoptPolicy
EXTRN	?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z:PROC ; CvPolicyAI::ChooseNextPolicy
EXTRN	?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z:PROC ; CvPolicyAI::DoConsiderIdeologySwitch
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ$0
__ehfuncinfo$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
_TEXT	SEGMENT
_strBuffer$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
?DoPolicyAI@CvPlayerPolicies@@QAEXXZ PROC		; CvPlayerPolicies::DoPolicyAI, COMDAT
; _this$ = ecx

; 4836 : {

	push	-1
	push	__ehhandler$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	esi, ecx

; 4837 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4838 : 
; 4839 : 	m_pPolicyAI->DoConsiderIdeologySwitch(m_pPlayer);

	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi+56]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoConsiderIdeologySwitch

; 4840 : 
; 4841 : 	// Do we have enough points to buy a new policy?
; 4842 : 	if(m_pPlayer->getNextPolicyCost() > 0)

	mov	ecx, DWORD PTR [esi+60]
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	test	eax, eax
	jle	SHORT $LN26@DoPolicyAI
	push	edi
$LL6@DoPolicyAI:

; 4843 : 	{
; 4844 : 		// Adopt new policies until we run out of freebies and culture (usually only one per turn)
; 4845 : 		while(m_pPlayer->getJONSCulture() >= m_pPlayer->getNextPolicyCost() || m_pPlayer->GetNumFreePolicies() > 0 || m_pPlayer->GetNumFreeTenets() > 0)

	mov	ecx, DWORD PTR [esi+60]
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	mov	ecx, DWORD PTR [esi+60]
	mov	edi, eax
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	cmp	edi, eax
	jge	SHORT $LN4@DoPolicyAI
	mov	ecx, DWORD PTR [esi+60]
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jg	SHORT $LN4@DoPolicyAI
	mov	ecx, DWORD PTR [esi+60]
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	test	eax, eax
	jle	SHORT $LN28@DoPolicyAI
$LN4@DoPolicyAI:

; 4846 : 		{
; 4847 : 			// Choose the policy we want next (or a branch)
; 4848 : #ifdef AUI_WARNING_FIXES
; 4849 : 			uint iNextPolicy = m_pPolicyAI->ChooseNextPolicy(m_pPlayer);
; 4850 : 			if (iNextPolicy == (uint)NO_POLICY)
; 4851 : #else
; 4852 : 			int iNextPolicy = m_pPolicyAI->ChooseNextPolicy(m_pPlayer);

	mov	ecx, DWORD PTR [esi+60]
	push	ecx
	mov	ecx, DWORD PTR [esi+56]
	call	?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z ; CvPolicyAI::ChooseNextPolicy

; 4853 : 			if (iNextPolicy == NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN28@DoPolicyAI

; 4854 : #endif
; 4855 : 				break;
; 4856 : 
; 4857 : 			// These actions should spend our number of free policies or our culture, otherwise we'll loop forever
; 4858 : 			if(iNextPolicy < m_pPolicies->GetNumPolicyBranches()) // Low return values indicate a branch has been chosen

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR [ecx+20]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@DoPolicyAI

; 4859 : 			{
; 4860 : 				m_pPlayer->GetPlayerPolicies()->DoUnlockPolicyBranch((PolicyBranchTypes)iNextPolicy);

	mov	ecx, DWORD PTR [esi+60]
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoUnlockPolicyBranch

; 4861 : 			}
; 4862 : 			else

	jmp	SHORT $LL6@DoPolicyAI
$LN2@DoPolicyAI:

; 4863 : 			{
; 4864 : 				m_pPlayer->doAdoptPolicy((PolicyTypes)(iNextPolicy - m_pPolicies->GetNumPolicyBranches()));

	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [esi+60]
	sar	edx, 2
	sub	eax, edx
	push	eax
	call	?doAdoptPolicy@CvPlayer@@QAEXW4PolicyTypes@@@Z ; CvPlayer::doAdoptPolicy

; 4865 : 			}
; 4866 : 		}

	jmp	SHORT $LL6@DoPolicyAI
$LN28@DoPolicyAI:
	pop	edi
$LN26@DoPolicyAI:

; 4867 : 	}
; 4868 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoPolicyAI@CvPlayerPolicies@@QAEXXZ ENDP		; CvPlayerPolicies::DoPolicyAI
PUBLIC	??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@2:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::clear
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T241918 = 12						; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	mov	esi, edx
	mov	BYTE PTR __Addleft$[esp+12], 1
	jne	SHORT $LN9@insert
	push	edi
	mov	edi, DWORD PTR [ebp]
	npad	2
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edi, DWORD PTR [eax+12]
	mov	esi, eax
	setl	dl
	mov	BYTE PTR __Addleft$[esp+16], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	dl, dl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@insert
	pop	edi
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	eax, DWORD PTR __Addleft$[esp+12]
	push	ebp
	push	esi
	push	eax
	lea	edx, DWORD PTR $T241918[esp+20]
	push	edx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 647  : 			if (!_Addleft)
; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())
; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));
; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay
; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,
; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));
; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN2@Copy@2

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN25@Copy@2
$LL26@Copy@2:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL26@Copy@2
$LN25@Copy@2:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN43@Copy@2
$LL44@Copy@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL44@Copy@2
$LN43@Copy@2:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@2:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T242187 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T242187[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXPAW4BuildingTypes@@0@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW43@IABW43@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T242354 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$242358 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$242358[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T242354[esp+12], 0
	mov	eax, DWORD PTR $T242354[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXPAW4PolicyTypes@@0@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXPAW4PolicyTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXPAW4PolicyTypes@@0@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXPAW4PolicyTypes@@0@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW43@IABW43@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T242383 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$242387 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$242387[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T242383[esp+12], 0
	mov	eax, DWORD PTR $T242383[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ucopy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z
_TEXT	SEGMENT
$T242401 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242404 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ucopy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$242404[esp]
	mov	BYTE PTR $T242401[esp+4], 0
	mov	eax, DWORD PTR $T242401[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ucopy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> > >
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ucopy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z
_TEXT	SEGMENT
$T242420 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242423 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ucopy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$242423[esp]
	mov	BYTE PTR $T242420[esp+4], 0
	mov	eax, DWORD PTR $T242420[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ucopy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z
_TEXT	SEGMENT
$T242457 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242460 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242460[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242457[esp+4], 0
	mov	eax, DWORD PTR $T242457[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@stdext@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4BuildingTypes@@@3@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z
_TEXT	SEGMENT
$T242494 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242497 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242497[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242494[esp+4], 0
	mov	eax, DWORD PTR $T242494[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@stdext@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4PolicyTypes@@@3@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z
_TEXT	SEGMENT
$T242531 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242535 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242535[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242531[esp+4], 0
	mov	eax, DWORD PTR $T242531[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z
_TEXT	SEGMENT
$T242568 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242571 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242571[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242568[esp+4], 0
	mov	eax, DWORD PTR $T242568[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@5
	pop	esi
$LN13@unchecked_@5:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??0CvPolicyXMLEntries@@QAE@XZ			; CvPolicyXMLEntries::CvPolicyXMLEntries
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvPolicyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$0
__ehfuncinfo$??0CvPolicyXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvPolicyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPolicyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPolicyXMLEntries@@QAE@XZ PROC			; CvPolicyXMLEntries::CvPolicyXMLEntries, COMDAT
; _this$ = ecx

; 2470 : {

	push	-1
	push	__ehhandler$??0CvPolicyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx

; 2471 : 
; 2472 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
__ehhandler$??0CvPolicyXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPolicyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPolicyXMLEntries@@QAE@XZ ENDP			; CvPolicyXMLEntries::CvPolicyXMLEntries
PUBLIC	?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ ; CvPolicyXMLEntries::DeletePolicyBranchesArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ PROC ; CvPolicyXMLEntries::DeletePolicyBranchesArray, COMDAT
; _this$ = ecx

; 2536 : {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 2537 : 	for(std::vector<CvPolicyBranchEntry*>::iterator it = m_paPolicyBranchEntries.begin(); it != m_paPolicyBranchEntries.end(); ++it)

	mov	edi, DWORD PTR [ebx+20]
	cmp	edi, DWORD PTR [ebx+24]
	je	SHORT $LN1@DeletePoli
	npad	3
$LL14@DeletePoli:

; 2538 : 	{
; 2539 : 		SAFE_DELETE(*it);

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN32@DeletePoli
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyBranchEntry@@6B@
	mov	eax, DWORD PTR [esi+288]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+288], 0
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeletePoli:
	mov	DWORD PTR [edi], 0
	add	edi, 4
	cmp	edi, DWORD PTR [ebx+24]
	jne	SHORT $LL14@DeletePoli
$LN1@DeletePoli:

; 2540 : 	}
; 2541 : 
; 2542 : 	m_paPolicyBranchEntries.clear();

	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ebx+20]
	cmp	esi, ecx
	je	SHORT $LN56@DeletePoli
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN81@DeletePoli
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN81@DeletePoli:
	mov	DWORD PTR [ebx+24], edi
$LN56@DeletePoli:
	pop	edi
	pop	esi
	pop	ebx

; 2543 : }

	ret	0
?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ ENDP ; CvPolicyXMLEntries::DeletePolicyBranchesArray
_TEXT	ENDS
PUBLIC	?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T243353 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::insert, COMDAT
; _this$ = ecx

; 271  : 		return (_Mybase::insert(_Val).first);

	mov	eax, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	push	eax
	lea	edx, DWORD PTR $T243353[esp+12]
	push	edx
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx

; 272  : 		}

	add	esp, 8
	ret	8
?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::insert
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree:
$LN56@Tree:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T243615 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T243615[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T243755 = 8						; size = 1
__Cat$243759 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@4
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@4
	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
$LN54@vector@4:
$LN22@vector@4:
	push	eax
	push	edi
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T243755[ebp], 0
	mov	edx, DWORD PTR $T243755[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$243759[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@4:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@4:
$LN53@vector@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T243906 = 8						; size = 1
__Cat$243909 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@6
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@6
	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
$LN54@vector@6:
$LN22@vector@6:
	push	eax
	push	edi
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T243906[ebp], 0
	mov	edx, DWORD PTR $T243906[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$243909[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@6:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@6:
$LN53@vector@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@7:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T244113 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	esi
	push	edi

; 545  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN20@operator@4

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T244113[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
$LN20@operator@4:
	pop	edi

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, esi
	pop	esi

; 552  : 		}

	ret	4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
_TEXT	ENDS
PUBLIC	??$_Umove@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Umove@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z
_TEXT	SEGMENT
$T244208 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244211 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$244211[esp]
	mov	BYTE PTR $T244208[esp+4], 0
	mov	eax, DWORD PTR $T244208[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@1@0PAW42@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> > >
_TEXT	ENDS
PUBLIC	??$_Umove@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z
_TEXT	SEGMENT
$T244263 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244266 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$244266[esp]
	mov	BYTE PTR $T244263[esp+4], 0
	mov	eax, DWORD PTR $T244263[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@1@0PAW42@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4BuildingTypes@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW42@00@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<enum BuildingTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4BuildingTypes@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T244318 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244322 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4BuildingTypes@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW42@00@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<enum BuildingTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$244322[esp]
	mov	BYTE PTR $T244318[esp+4], 0
	mov	eax, DWORD PTR $T244318[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4BuildingTypes@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW42@00@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<enum BuildingTypes *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4PolicyTypes@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW42@00@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<enum PolicyTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4PolicyTypes@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T244373 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244377 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4PolicyTypes@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW42@00@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<enum PolicyTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$244377[esp]
	mov	BYTE PTR $T244373[esp+4], 0
	mov	eax, DWORD PTR $T244373[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4PolicyTypes@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW42@00@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<enum PolicyTypes *>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214846 = 16					; size = 4
__Tmp$214836 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214836[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214846[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T244678 = -4						; size = 4
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T244678[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??_7CvPolicyEntry@@6B@				; CvPolicyEntry::`vftable'
PUBLIC	??1CvPolicyEntry@@QAE@XZ			; CvPolicyEntry::~CvPolicyEntry
PUBLIC	??_R4CvPolicyEntry@@6B@				; CvPolicyEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPolicyEntry@@@8			; CvPolicyEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvPolicyEntry@@8				; CvPolicyEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPolicyEntry@@8				; CvPolicyEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPolicyEntry@@8			; CvPolicyEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPolicyEntry::CacheResults
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
;	COMDAT ??_R1A@?0A@EA@CvPolicyEntry@@8
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPolicyEntry@@8 DD FLAT:??_R0?AVCvPolicyEntry@@@8 ; CvPolicyEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPolicyEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPolicyEntry@@8
rdata$r	SEGMENT
??_R2CvPolicyEntry@@8 DD FLAT:??_R1A@?0A@EA@CvPolicyEntry@@8 ; CvPolicyEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPolicyEntry@@8
rdata$r	SEGMENT
??_R3CvPolicyEntry@@8 DD 00H				; CvPolicyEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPolicyEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPolicyEntry@@@8
_DATA	SEGMENT
??_R0?AVCvPolicyEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvPolicyEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPolicyEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPolicyEntry@@6B@
rdata$r	SEGMENT
??_R4CvPolicyEntry@@6B@ DD 00H				; CvPolicyEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPolicyEntry@@@8
	DD	FLAT:??_R3CvPolicyEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvPolicyEntry@@6B@
CONST	SEGMENT
??_7CvPolicyEntry@@6B@ DD FLAT:??_R4CvPolicyEntry@@6B@	; CvPolicyEntry::`vftable'
	DD	FLAT:?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvPolicyEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$3
__ehfuncinfo$??1CvPolicyEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvPolicyEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPolicyEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T244982 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPolicyEntry@@QAE@XZ PROC				; CvPolicyEntry::~CvPolicyEntry, COMDAT
; _this$ = ecx

; 297  : {

	push	-1
	push	__ehhandler$??1CvPolicyEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyEntry@@6B@

; 298  : 	SAFE_DELETE_ARRAY(m_piPrereqOrPolicies);

	mov	eax, DWORD PTR [esi+964]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+44], 3
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+964], ebx

; 299  : 	SAFE_DELETE_ARRAY(m_piPrereqAndPolicies);

	mov	eax, DWORD PTR [esi+968]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+968], ebx

; 300  : 	SAFE_DELETE_ARRAY(m_piPolicyDisables);

	mov	eax, DWORD PTR [esi+972]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+972], ebx

; 301  : 	SAFE_DELETE_ARRAY(m_piYieldModifier);

	mov	eax, DWORD PTR [esi+976]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+976], ebx

; 302  : 	SAFE_DELETE_ARRAY(m_piCityYieldChange);

	mov	eax, DWORD PTR [esi+980]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+980], ebx

; 303  : 	SAFE_DELETE_ARRAY(m_piCoastalCityYieldChange);

	mov	eax, DWORD PTR [esi+984]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+984], ebx

; 304  : 	SAFE_DELETE_ARRAY(m_piCapitalYieldChange);

	mov	eax, DWORD PTR [esi+988]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+988], ebx

; 305  : 	SAFE_DELETE_ARRAY(m_piCapitalYieldPerPopChange);

	mov	eax, DWORD PTR [esi+992]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+992], ebx

; 306  : 	SAFE_DELETE_ARRAY(m_piCapitalYieldModifier);

	mov	eax, DWORD PTR [esi+996]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+996], ebx

; 307  : 	SAFE_DELETE_ARRAY(m_piGreatWorkYieldChange);

	mov	eax, DWORD PTR [esi+1000]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1000], ebx

; 308  : 	SAFE_DELETE_ARRAY(m_piSpecialistExtraYield);

	mov	eax, DWORD PTR [esi+1004]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1004], ebx

; 309  : 	SAFE_DELETE_ARRAY(m_pabFreePromotion);

	mov	eax, DWORD PTR [esi+1012]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1012], ebx

; 310  : 	SAFE_DELETE_ARRAY(m_paiUnitCombatProductionModifiers);

	mov	eax, DWORD PTR [esi+1016]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1016], ebx

; 311  : 	SAFE_DELETE_ARRAY(m_paiUnitCombatFreeExperiences);

	mov	eax, DWORD PTR [esi+1020]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1020], ebx

; 312  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassCultureChanges);

	mov	eax, DWORD PTR [esi+1028]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1028], ebx

; 313  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassProductionModifiers);

	mov	eax, DWORD PTR [esi+1032]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1032], ebx

; 314  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassTourismModifiers);

	mov	eax, DWORD PTR [esi+1036]
	add	esp, 64					; 00000040H
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1036], ebx

; 315  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassHappiness);

	mov	eax, DWORD PTR [esi+1040]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1040], ebx

; 316  : 	SAFE_DELETE_ARRAY(m_paiFreeUnitClasses);

	mov	eax, DWORD PTR [esi+1044]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1044], ebx

; 317  : 	SAFE_DELETE_ARRAY(m_paiTourismOnUnitCreation);

	mov	eax, DWORD PTR [esi+1048]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1048], ebx

; 318  : 
; 319  : //	SAFE_DELETE_ARRAY(m_pabHurry);
; 320  : 	SAFE_DELETE_ARRAY(m_paiHurryModifier);

	mov	eax, DWORD PTR [esi+1024]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+1024], ebx

; 321  : 	SAFE_DELETE_ARRAY(m_pabSpecialistValid);

	mov	eax, DWORD PTR [esi+1052]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 322  : 
; 323  : #ifdef AUI_WARNING_FIXES
; 324  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);
; 325  : 	SAFE_DELETE_ARRAY(m_piImprovementCultureChange);
; 326  : #endif
; 327  : 
; 328  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 329  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges.first, m_ppiImprovementYieldChanges.second);
; 330  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldModifiers.first, m_ppiBuildingClassYieldModifiers.second);
; 331  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges.first, m_ppiBuildingClassYieldChanges.second);
; 332  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 333  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassFlavorChanges.first, m_ppiBuildingClassFlavorChanges.second);
; 334  : #endif
; 335  : #else
; 336  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges);

	lea	eax, DWORD PTR [esi+1056]
	push	eax
	mov	DWORD PTR [esi+1052], ebx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 337  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldModifiers);

	lea	ecx, DWORD PTR [esi+1060]
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 338  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges);

	lea	edx, DWORD PTR [esi+1064]
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 339  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 340  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassFlavorChanges);
; 341  : #endif
; 342  : #endif
; 343  : }

	mov	eax, DWORD PTR [esi+956]
	mov	ecx, DWORD PTR [eax]
	add	esp, 36					; 00000024H
	lea	edi, DWORD PTR [esi+952]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T244982[esp+40]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR [esi+920]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+892]
	mov	BYTE PTR __$EHRec$[esp+40], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__ehhandler$??1CvPolicyEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPolicyEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPolicyEntry@@QAE@XZ ENDP				; CvPolicyEntry::~CvPolicyEntry
PUBLIC	??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 228  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 229  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 1034 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp+16]
	push	edi
	cmp	ecx, esi
	je	SHORT $LN23@swap@4

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())
; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	je	SHORT $LN20@swap@4
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN20@swap@4:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	lea	eax, DWORD PTR [esi+8]
	add	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN23@swap@4
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN23@swap@4:

; 1048 : 			}
; 1049 : 		else
; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);
; 1052 : 
; 1053 : 			_Myt _Tmp = *this;
; 1054 : 
; 1055 : 			*this = _Right;
; 1056 : 			_Right = _Tmp;
; 1057 : 			}
; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
PUBLIC	?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$227026 = -24					; size = 4
$T245713 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Cat$245716 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 603  : 		if (max_size() < _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
$LN57@reserve:
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN20@reserve
	xor	eax, eax
	jmp	SHORT $LN21@reserve
$LN20@reserve:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN21@reserve:
	cmp	eax, edx
	jae	SHORT $LN3@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edx
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR $T245713[ebp], 0
	mov	edx, DWORD PTR $T245713[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$245716[ebp]
	push	edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+8]
	push	esi
	push	ebx
	push	eax
	push	ecx
	mov	DWORD PTR __Ptr$227026[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+8]
	sub	edi, eax
	add	esp, 32					; 00000020H
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN52@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], ebx
$LN3@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$227026[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve:
$LN56@reserve:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve
PUBLIC	?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$227248 = -24					; size = 4
$T245872 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Cat$245877 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 603  : 		if (max_size() < _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@2

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
$LN57@reserve@2:
$LN5@reserve@2:

; 605  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN20@reserve@2
	xor	eax, eax
	jmp	SHORT $LN21@reserve@2
$LN20@reserve@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN21@reserve@2:
	cmp	eax, edx
	jae	SHORT $LN3@reserve@2

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edx
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR $T245872[ebp], 0
	mov	edx, DWORD PTR $T245872[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$245877[ebp]
	push	edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+8]
	push	esi
	push	ebx
	push	eax
	push	ecx
	mov	DWORD PTR __Ptr$227248[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+8]
	sub	edi, eax
	add	esp, 32					; 00000020H
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN52@reserve@2

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@reserve@2:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], ebx
$LN3@reserve@2:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$227248[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve@2:
$LN56@reserve@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve
PUBLIC	?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$246112 = 8					; size = 1
__Cat$246039 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$227930 = 12					; size = 4
__Tmp$227920 = 12					; size = 4
__Newvec$227905 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T246108 = 16						; size = 1
$T246035 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$227905[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW43@IABW43@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$246039[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T246035[ebp], 0
	mov	ecx, DWORD PTR $T246035[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227905[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T246108[ebp], 0
	mov	edx, DWORD PTR $T246108[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$246112[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$227905[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227905[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$227920[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4BuildingTypes@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW42@00@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<enum BuildingTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$227920[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW43@IABW43@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$227920[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z ; std::fill<enum BuildingTypes *,enum BuildingTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227930[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4BuildingTypes@@@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEPAW4BuildingTypes@@PAW42@00@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Umove<enum BuildingTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4BuildingTypes@@PAW41@@stdext@@YAPAW4BuildingTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum BuildingTypes *,enum BuildingTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$227930[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4BuildingTypes@@W41@@std@@YAXPAW4BuildingTypes@@0ABW41@@Z ; std::fill<enum BuildingTypes *,enum BuildingTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$246348 = 8					; size = 1
__Cat$246275 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$227989 = 12					; size = 4
__Tmp$227979 = 12					; size = 4
__Newvec$227964 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T246344 = 16						; size = 1
$T246271 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
$LN87@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$227964[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW43@IABW43@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$246275[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T246271[ebp], 0
	mov	ecx, DWORD PTR $T246271[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227964[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T246344[ebp], 0
	mov	edx, DWORD PTR $T246344[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$246348[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$227964[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227964[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$227979[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4PolicyTypes@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW42@00@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<enum PolicyTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$227979[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW43@IABW43@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$227979[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z ; std::fill<enum PolicyTypes *,enum PolicyTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227989[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4PolicyTypes@@@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEPAW4PolicyTypes@@PAW42@00@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Umove<enum PolicyTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4PolicyTypes@@PAW41@@stdext@@YAPAW4PolicyTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum PolicyTypes *,enum PolicyTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$227989[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4PolicyTypes@@W41@@std@@YAXPAW4PolicyTypes@@0ABW41@@Z ; std::fill<enum PolicyTypes *,enum PolicyTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n
PUBLIC	??_GCvPolicyEntry@@QAEPAXI@Z			; CvPolicyEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPolicyEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPolicyEntry@@QAEPAXI@Z PROC			; CvPolicyEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvPolicyEntry@@QAE@XZ		; CvPolicyEntry::~CvPolicyEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPolicyEntry@@QAEPAXI@Z ENDP			; CvPolicyEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??0CvPolicyEntry@@QAE@XZ			; CvPolicyEntry::CvPolicyEntry
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0CvPolicyEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$2
__ehfuncinfo$??0CvPolicyEntry@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvPolicyEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPolicyEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPolicyEntry@@QAE@XZ PROC				; CvPolicyEntry::CvPolicyEntry, COMDAT
; _this$ = ecx

; 292  : {

	push	-1
	push	__ehhandler$??0CvPolicyEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	edi, -1
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvPolicyEntry@@6B@
	mov	DWORD PTR [esi+260], edi
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	DWORD PTR [esi+340], ebx
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+348], ebx
	mov	DWORD PTR [esi+352], ebx
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	DWORD PTR [esi+364], ebx
	mov	DWORD PTR [esi+368], ebx
	mov	DWORD PTR [esi+372], ebx
	mov	DWORD PTR [esi+376], ebx
	mov	DWORD PTR [esi+380], ebx
	mov	DWORD PTR [esi+384], ebx
	mov	DWORD PTR [esi+388], ebx
	mov	DWORD PTR [esi+392], ebx
	mov	DWORD PTR [esi+396], ebx
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+420], ebx
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+428], ebx
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	DWORD PTR [esi+440], ebx
	mov	DWORD PTR [esi+444], ebx
	mov	DWORD PTR [esi+448], ebx
	mov	DWORD PTR [esi+452], ebx
	mov	DWORD PTR [esi+456], ebx
	mov	DWORD PTR [esi+460], ebx
	mov	DWORD PTR [esi+464], ebx
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+472], ebx
	mov	DWORD PTR [esi+476], ebx
	mov	DWORD PTR [esi+480], ebx
	mov	DWORD PTR [esi+484], ebx
	mov	DWORD PTR [esi+488], ebx
	mov	DWORD PTR [esi+492], ebx
	mov	DWORD PTR [esi+496], ebx
	mov	DWORD PTR [esi+500], ebx
	mov	DWORD PTR [esi+504], ebx
	mov	DWORD PTR [esi+508], ebx
	mov	DWORD PTR [esi+512], ebx
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	DWORD PTR [esi+528], ebx
	mov	DWORD PTR [esi+532], ebx
	mov	DWORD PTR [esi+536], ebx
	mov	DWORD PTR [esi+540], ebx
	mov	DWORD PTR [esi+544], ebx
	mov	DWORD PTR [esi+548], ebx
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+556], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	DWORD PTR [esi+572], ebx
	mov	DWORD PTR [esi+576], ebx
	mov	DWORD PTR [esi+580], ebx
	mov	DWORD PTR [esi+584], ebx
	mov	DWORD PTR [esi+588], ebx
	mov	DWORD PTR [esi+592], ebx
	mov	DWORD PTR [esi+596], ebx
	mov	DWORD PTR [esi+600], ebx
	mov	DWORD PTR [esi+604], ebx
	mov	DWORD PTR [esi+608], ebx
	mov	DWORD PTR [esi+612], ebx
	mov	DWORD PTR [esi+616], ebx
	mov	DWORD PTR [esi+620], ebx
	mov	DWORD PTR [esi+624], ebx
	mov	DWORD PTR [esi+628], ebx
	mov	DWORD PTR [esi+632], ebx
	mov	DWORD PTR [esi+636], ebx
	mov	DWORD PTR [esi+640], ebx
	mov	DWORD PTR [esi+644], ebx
	mov	DWORD PTR [esi+648], ebx
	mov	DWORD PTR [esi+652], ebx
	mov	DWORD PTR [esi+656], ebx
	mov	DWORD PTR [esi+660], ebx
	mov	DWORD PTR [esi+664], ebx
	mov	DWORD PTR [esi+668], ebx
	mov	DWORD PTR [esi+672], ebx
	mov	DWORD PTR [esi+676], ebx
	mov	DWORD PTR [esi+680], ebx
	mov	DWORD PTR [esi+684], ebx
	mov	DWORD PTR [esi+688], ebx
	mov	DWORD PTR [esi+692], ebx
	mov	DWORD PTR [esi+696], ebx
	mov	DWORD PTR [esi+700], ebx
	mov	DWORD PTR [esi+704], ebx
	mov	DWORD PTR [esi+708], ebx
	mov	DWORD PTR [esi+712], ebx
	mov	DWORD PTR [esi+716], ebx
	mov	DWORD PTR [esi+720], ebx
	mov	DWORD PTR [esi+724], ebx
	mov	DWORD PTR [esi+728], ebx
	mov	DWORD PTR [esi+732], ebx
	mov	DWORD PTR [esi+736], ebx
	mov	DWORD PTR [esi+740], ebx
	mov	DWORD PTR [esi+744], ebx
	mov	DWORD PTR [esi+748], ebx
	mov	DWORD PTR [esi+752], ebx
	mov	DWORD PTR [esi+756], ebx
	mov	DWORD PTR [esi+760], ebx
	mov	DWORD PTR [esi+764], ebx
	mov	DWORD PTR [esi+768], ebx
	mov	DWORD PTR [esi+772], ebx
	mov	BYTE PTR [esi+776], bl
	mov	BYTE PTR [esi+777], bl
	mov	BYTE PTR [esi+778], bl
	mov	DWORD PTR [esi+780], ebx
	mov	DWORD PTR [esi+784], ebx
	mov	DWORD PTR [esi+788], ebx
	mov	DWORD PTR [esi+792], ebx
	mov	DWORD PTR [esi+796], ebx
	mov	DWORD PTR [esi+800], ebx
	mov	DWORD PTR [esi+804], ebx
	mov	DWORD PTR [esi+808], ebx
	mov	DWORD PTR [esi+812], ebx
	mov	DWORD PTR [esi+816], ebx
	mov	DWORD PTR [esi+820], edi
	mov	DWORD PTR [esi+824], ebx
	mov	DWORD PTR [esi+828], ebx
	mov	DWORD PTR [esi+832], ebx
	mov	DWORD PTR [esi+836], ebx
	mov	DWORD PTR [esi+840], ebx
	mov	DWORD PTR [esi+844], ebx
	mov	DWORD PTR [esi+848], ebx
	mov	DWORD PTR [esi+852], ebx
	mov	DWORD PTR [esi+856], ebx
	mov	DWORD PTR [esi+860], ebx
	mov	DWORD PTR [esi+864], ebx
	mov	DWORD PTR [esi+868], ebx
	mov	BYTE PTR [esi+872], bl
	mov	BYTE PTR [esi+873], bl
	mov	BYTE PTR [esi+874], bl
	mov	BYTE PTR [esi+875], bl
	mov	BYTE PTR [esi+876], bl
	mov	BYTE PTR [esi+877], bl
	mov	BYTE PTR [esi+878], bl
	mov	BYTE PTR [esi+879], bl
	mov	BYTE PTR [esi+880], bl
	mov	BYTE PTR [esi+881], bl
	mov	BYTE PTR [esi+882], bl
	mov	BYTE PTR [esi+883], bl
	mov	BYTE PTR [esi+884], bl
	mov	BYTE PTR [esi+885], bl
	mov	BYTE PTR [esi+886], bl
	mov	BYTE PTR [esi+887], bl
	mov	BYTE PTR [esi+888], bl
	mov	BYTE PTR [esi+889], bl
	mov	BYTE PTR [esi+890], bl
	lea	ecx, DWORD PTR [esi+892]
	mov	BYTE PTR [esi+891], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+920]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+948], edi
	lea	edi, DWORD PTR [esi+952]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [esi+964], ebx
	mov	DWORD PTR [esi+968], ebx
	mov	DWORD PTR [esi+972], ebx
	mov	DWORD PTR [esi+976], ebx
	mov	DWORD PTR [esi+980], ebx
	mov	DWORD PTR [esi+984], ebx
	mov	DWORD PTR [esi+988], ebx
	mov	DWORD PTR [esi+992], ebx
	mov	DWORD PTR [esi+996], ebx
	mov	DWORD PTR [esi+1000], ebx
	mov	DWORD PTR [esi+1004], ebx

; 293  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+1012], ebx
	mov	DWORD PTR [esi+1016], ebx
	mov	DWORD PTR [esi+1020], ebx
	mov	DWORD PTR [esi+1024], ebx
	mov	DWORD PTR [esi+1028], ebx
	mov	DWORD PTR [esi+1032], ebx
	mov	DWORD PTR [esi+1036], ebx
	mov	DWORD PTR [esi+1040], ebx
	mov	DWORD PTR [esi+1044], ebx
	mov	DWORD PTR [esi+1048], ebx
	mov	DWORD PTR [esi+1052], ebx
	mov	DWORD PTR [esi+1056], ebx
	mov	DWORD PTR [esi+1060], ebx
	mov	DWORD PTR [esi+1064], ebx
	mov	DWORD PTR [esi+1068], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvPolicyEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPolicyEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPolicyEntry@@QAE@XZ ENDP				; CvPolicyEntry::CvPolicyEntry
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
$T246741 = -88						; size = 8
_YieldID$223858 = -88					; size = 4
_iYieldID$223845 = -88					; size = 4
_iYieldID$223832 = -88					; size = 4
$T246917 = -80						; size = 8
$T246744 = -80						; size = 12
_sqlKey$223896 = -68					; size = 28
_sqlKey$223884 = -68					; size = 28
_sqlKey$223872 = -68					; size = 28
_strKey$223849 = -68					; size = 28
_strKey$223836 = -68					; size = 28
_strKey$223823 = -68					; size = 28
$T246740 = -68						; size = 28
_sqlKey$223906 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_szPolicyType$ = 8					; size = 4
_kResults$ = 8						; size = 4
tv2729 = 12						; size = 4
tv2710 = 12						; size = 4
tv2691 = 12						; size = 4
$T247063 = 12						; size = 4
_ImprovementID$223857 = 12				; size = 4
_BuildingClassID$223844 = 12				; size = 4
_BuildingClassID$223831 = 12				; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPolicyEntry::CacheResults, COMDAT
; _this$ = ecx

; 347  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 348  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+92]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN23@CacheResul@2
	pop	edi
	pop	esi

; 854  : 
; 855  : 	return true;
; 856  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
$LN23@CacheResul@2:
	push	ebx

; 349  : 		return false;
; 350  : 
; 351  : 	//Basic Properties
; 352  : 	m_iCultureCost = kResults.GetInt("CultureCost");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	ebp
	push	OFFSET $SG223566
	mov	ecx, edi
	call	ebx

; 353  : 	m_iGridX = kResults.GetInt("GridX");

	push	OFFSET $SG223567
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 354  : 	m_iGridY = kResults.GetInt("GridY");

	push	OFFSET $SG223568
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 355  : 	m_iLevel = kResults.GetInt("Level");

	push	OFFSET $SG223569
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 356  : 	m_iPolicyCostModifier = kResults.GetInt("PolicyCostModifier");

	push	OFFSET $SG223570
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 357  : 	m_iCulturePerCity = kResults.GetInt("CulturePerCity");

	push	OFFSET $SG223571
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 358  : #ifdef FRUITY_TRADITION_ARISTOCRACY
; 359  : 	m_iCapitalCulturePerUniqueLuxury = kResults.GetInt("CapitalCulturePerUniqueLuxury");
; 360  : #endif
; 361  : 	m_iCulturePerWonder = kResults.GetInt("CulturePerWonder");

	push	OFFSET $SG223572
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 362  : 	m_iCultureWonderMultiplier = kResults.GetInt("CultureWonderMultiplier");

	push	OFFSET $SG223573
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 363  : 	m_iCulturePerTechResearched = kResults.GetInt("CulturePerTechResearched");

	push	OFFSET $SG223574
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 364  : 	m_iCultureImprovementChange = kResults.GetInt("CultureImprovementChange");

	push	OFFSET $SG223575
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 365  : 	m_iCultureFromKills = kResults.GetInt("CultureFromKills");

	push	OFFSET $SG223576
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 366  : 	m_iCultureFromBarbarianKills = kResults.GetInt("CultureFromBarbarianKills");

	push	OFFSET $SG223577
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 367  : 	m_iGoldFromKills = kResults.GetInt("GoldFromKills");

	push	OFFSET $SG223578
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 368  : 	m_iScienceFromKills = kResults.GetInt("ScienceFromKills"); // NQMP GJS - Honor Finisher

	push	OFFSET $SG223579
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebx

; 369  : 	m_iEmbarkedExtraMoves = kResults.GetInt("EmbarkedExtraMoves");

	push	OFFSET $SG223580
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx

; 370  : 	m_iAttackBonusTurns = kResults.GetInt("AttackBonusTurns");

	push	OFFSET $SG223581
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebx

; 371  : 	m_iGoldenAgeTurns = kResults.GetInt("GoldenAgeTurns");

	push	OFFSET $SG223582
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebx

; 372  : 	m_iGoldenAgeMeterMod = kResults.GetInt("GoldenAgeMeterMod");

	push	OFFSET $SG223583
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebx

; 373  : 	m_iGoldenAgeDurationMod = kResults.GetInt("GoldenAgeDurationMod");

	push	OFFSET $SG223584
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebx
	mov	DWORD PTR [esi+336], eax

; 374  : 	m_iNumFreeTechs = kResults.GetInt("NumFreeTechs");

	push	OFFSET $SG223585
	mov	ecx, edi
	call	ebx

; 375  : 	m_iNumFreePolicies = kResults.GetInt("NumFreePolicies");

	push	OFFSET $SG223586
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebx

; 376  : 	m_iNumFreeGreatPeople = kResults.GetInt("NumFreeGreatPeople");

	push	OFFSET $SG223587
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebx

; 377  : #ifdef NQ_EXTRA_SPIES_FROM_POLICIES
; 378  : 	m_iNumExtraSpies = kResults.GetInt("NumExtraSpies");

	push	OFFSET $SG223588
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebx

; 379  : #endif
; 380  : 	m_iMedianTechPercentChange = kResults.GetInt("MedianTechPercentChange");

	push	OFFSET $SG223589
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	ebx

; 381  : 	m_iStrategicResourceMod = kResults.GetInt("StrategicResourceMod");

	push	OFFSET $SG223590
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebx

; 382  : 	m_iWonderProductionModifier = kResults.GetInt("WonderProductionModifier");

	push	OFFSET $SG223591
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebx

; 383  : 	m_iBuildingProductionModifier = kResults.GetInt("BuildingProductionModifier");

	push	OFFSET $SG223592
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	ebx

; 384  : 	m_iGreatPeopleRateModifier = kResults.GetInt("GreatPeopleRateModifier");

	push	OFFSET $SG223593
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebx

; 385  : 	m_iGreatGeneralRateModifier = kResults.GetInt("GreatGeneralRateModifier");

	push	OFFSET $SG223594
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebx

; 386  : 	m_iGreatAdmiralRateModifier = kResults.GetInt("GreatAdmiralRateModifier");

	push	OFFSET $SG223595
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebx

; 387  : 	m_iGreatWriterRateModifier = kResults.GetInt("GreatWriterRateModifier");

	push	OFFSET $SG223596
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebx

; 388  : 	m_iGreatArtistRateModifier = kResults.GetInt("GreatArtistRateModifier");

	push	OFFSET $SG223597
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebx

; 389  : 	m_iGreatMusicianRateModifier = kResults.GetInt("GreatMusicianRateModifier");

	push	OFFSET $SG223598
	mov	ecx, edi
	mov	DWORD PTR [esi+388], eax
	call	ebx

; 390  : 	m_iGreatMerchantRateModifier = kResults.GetInt("GreatMerchantRateModifier");

	push	OFFSET $SG223599
	mov	ecx, edi
	mov	DWORD PTR [esi+392], eax
	call	ebx

; 391  : 	m_iGreatScientistRateModifier = kResults.GetInt("GreatScientistRateModifier");

	push	OFFSET $SG223600
	mov	ecx, edi
	mov	DWORD PTR [esi+396], eax
	call	ebx

; 392  : 	m_iDomesticGreatGeneralRateModifier = kResults.GetInt("DomesticGreatGeneralRateModifier");

	push	OFFSET $SG223601
	mov	ecx, edi
	mov	DWORD PTR [esi+400], eax
	call	ebx

; 393  : 	m_iExtraHappiness = kResults.GetInt("ExtraHappiness");

	push	OFFSET $SG223602
	mov	ecx, edi
	mov	DWORD PTR [esi+404], eax
	call	ebx

; 394  : 	m_iExtraHappinessPerCity = kResults.GetInt("ExtraHappinessPerCity");

	push	OFFSET $SG223603
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	ebx

; 395  : 	m_iUnhappinessMod = kResults.GetInt("UnhappinessMod");

	push	OFFSET $SG223604
	mov	ecx, edi
	mov	DWORD PTR [esi+412], eax
	call	ebx

; 396  : 	m_iCityCountUnhappinessMod = kResults.GetInt("CityCountUnhappinessMod");

	push	OFFSET $SG223605
	mov	ecx, edi
	mov	DWORD PTR [esi+416], eax
	call	ebx

; 397  : 	m_iOccupiedPopulationUnhappinessMod = kResults.GetInt("OccupiedPopulationUnhappinessMod");

	push	OFFSET $SG223606
	mov	ecx, edi
	mov	DWORD PTR [esi+420], eax
	call	ebx

; 398  : 	m_iCapitalUnhappinessMod = kResults.GetInt("CapitalUnhappinessMod");

	push	OFFSET $SG223607
	mov	ecx, edi
	mov	DWORD PTR [esi+424], eax
	call	ebx

; 399  : 	m_iFreeExperience = kResults.GetInt("FreeExperience");

	push	OFFSET $SG223608
	mov	ecx, edi
	mov	DWORD PTR [esi+428], eax
	call	ebx

; 400  : 	m_iWorkerSpeedModifier = kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET $SG223609
	mov	ecx, edi
	mov	DWORD PTR [esi+432], eax
	call	ebx

; 401  : 	m_iAllFeatureProduction = kResults.GetInt("AllFeatureProduction");

	push	OFFSET $SG223610
	mov	ecx, edi
	mov	DWORD PTR [esi+436], eax
	call	ebx

; 402  : 	m_iImprovementCostModifier = kResults.GetInt("ImprovementCostModifier");

	push	OFFSET $SG223611
	mov	ecx, edi
	mov	DWORD PTR [esi+440], eax
	call	ebx

; 403  : 	m_iImprovementUpgradeRateModifier = kResults.GetInt("ImprovementUpgradeRateModifier");

	push	OFFSET $SG223612
	mov	ecx, edi
	mov	DWORD PTR [esi+444], eax
	call	ebx

; 404  : 	m_iSpecialistProductionModifier = kResults.GetInt("SpecialistProductionModifier");

	push	OFFSET $SG223613
	mov	ecx, edi
	mov	DWORD PTR [esi+448], eax
	call	ebx

; 405  : 	m_iSpecialistUpgradeModifier = kResults.GetInt("SpecialistUpgradeModifier");

	push	OFFSET $SG223614
	mov	ecx, edi
	mov	DWORD PTR [esi+452], eax
	call	ebx

; 406  : 	m_iMilitaryProductionModifier = kResults.GetInt("MilitaryProductionModifier");

	push	OFFSET $SG223615
	mov	ecx, edi
	mov	DWORD PTR [esi+456], eax
	call	ebx

; 407  : 	m_iBaseFreeUnits = kResults.GetInt("BaseFreeUnits");

	push	OFFSET $SG223616
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebx

; 408  : 	m_iBaseFreeMilitaryUnits = kResults.GetInt("BaseFreeMilitaryUnits");

	push	OFFSET $SG223617
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebx

; 409  : 	m_iFreeUnitsPopulationPercent = kResults.GetInt("FreeUnitsPopulationPercent");

	push	OFFSET $SG223618
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	ebx

; 410  : 	m_iFreeMilitaryUnitsPopulationPercent = kResults.GetInt("FreeMilitaryUnitsPopulationPercent");

	push	OFFSET $SG223619
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	ebx

; 411  : 	m_iHappinessPerGarrisonedUnit = kResults.GetInt("HappinessPerGarrisonedUnit");

	push	OFFSET $SG223620
	mov	ecx, edi
	mov	DWORD PTR [esi+476], eax
	call	ebx

; 412  : 	m_iCulturePerGarrisonedUnit = kResults.GetInt("CulturePerGarrisonedUnit");

	push	OFFSET $SG223621
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	ebx

; 413  : 	m_iHappinessPerTradeRoute = kResults.GetInt("HappinessPerTradeRoute");

	push	OFFSET $SG223622
	mov	ecx, edi
	mov	DWORD PTR [esi+484], eax
	call	ebx

; 414  : #ifdef NQ_RAIL_CONNECTION_HAPPINESS_FROM_POLICIES
; 415  : 	m_iHappinessPerRailConnection = kResults.GetInt("HappinessPerRailConnection");

	push	OFFSET $SG223623
	mov	ecx, edi
	mov	DWORD PTR [esi+488], eax
	call	ebx

; 416  : #endif
; 417  : 	m_iHappinessPerXPopulation = kResults.GetInt("HappinessPerXPopulation");

	push	OFFSET $SG223624
	mov	ecx, edi
	mov	DWORD PTR [esi+492], eax
	call	ebx

; 418  : 	m_iExtraHappinessPerLuxury = kResults.GetInt("ExtraHappinessPerLuxury");

	push	OFFSET $SG223625
	mov	ecx, edi
	mov	DWORD PTR [esi+496], eax
	call	ebx
	mov	DWORD PTR [esi+500], eax

; 419  : 	m_iUnhappinessFromUnitsMod = kResults.GetInt("UnhappinessFromUnitsMod");

	push	OFFSET $SG223626
	mov	ecx, edi
	call	ebx

; 420  : 	m_iNumExtraBuilders = kResults.GetInt("NumExtraBuilders");

	push	OFFSET $SG223627
	mov	ecx, edi
	mov	DWORD PTR [esi+504], eax
	call	ebx

; 421  : 	m_iPlotGoldCostMod = kResults.GetInt("PlotGoldCostMod");

	push	OFFSET $SG223628
	mov	ecx, edi
	mov	DWORD PTR [esi+508], eax
	call	ebx

; 422  : 	m_iPlotCultureCostModifier = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET $SG223629
	mov	ecx, edi
	mov	DWORD PTR [esi+512], eax
	call	ebx

; 423  : 	m_iPlotCultureExponentModifier = kResults.GetInt("PlotCultureExponentModifier");

	push	OFFSET $SG223630
	mov	ecx, edi
	mov	DWORD PTR [esi+516], eax
	call	ebx

; 424  : 	m_iNumCitiesPolicyCostDiscount = kResults.GetInt("NumCitiesPolicyCostDiscount");

	push	OFFSET $SG223631
	mov	ecx, edi
	mov	DWORD PTR [esi+520], eax
	call	ebx

; 425  : 	m_iNumCitiesResearchCostDiscount = kResults.GetInt("NumCitiesResearchCostDiscount"); // NQMP GJS - new Dictatorship of the Proletariat i.e. Communism

	push	OFFSET $SG223632
	mov	ecx, edi
	mov	DWORD PTR [esi+524], eax
	call	ebx

; 426  : 	m_iGarrisonedCityRangeStrikeModifier = kResults.GetInt("GarrisonedCityRangeStrikeModifier");

	push	OFFSET $SG223633
	mov	ecx, edi
	mov	DWORD PTR [esi+528], eax
	call	ebx

; 427  : 	m_iUnitPurchaseCostModifier = kResults.GetInt("UnitPurchaseCostModifier");

	push	OFFSET $SG223634
	mov	ecx, edi
	mov	DWORD PTR [esi+532], eax
	call	ebx

; 428  : 	m_iBuildingPurchaseCostModifier = kResults.GetInt("BuildingPurchaseCostModifier");

	push	OFFSET $SG223635
	mov	ecx, edi
	mov	DWORD PTR [esi+536], eax
	call	ebx

; 429  : 	m_iCityConnectionTradeRouteGoldModifier = kResults.GetInt("CityConnectionTradeRouteGoldModifier");

	push	OFFSET $SG223636
	mov	ecx, edi
	mov	DWORD PTR [esi+540], eax
	call	ebx

; 430  : 	m_iTradeMissionGoldModifier = kResults.GetInt("TradeMissionGoldModifier");

	push	OFFSET $SG223637
	mov	ecx, edi
	mov	DWORD PTR [esi+544], eax
	call	ebx

; 431  : 	m_iFaithCostModifier = kResults.GetInt("FaithCostModifier");

	push	OFFSET $SG223638
	mov	ecx, edi
	mov	DWORD PTR [esi+548], eax
	call	ebx

; 432  : 	m_iCulturalPlunderMultiplier = kResults.GetInt("CulturalPlunderMultiplier");

	push	OFFSET $SG223639
	mov	ecx, edi
	mov	DWORD PTR [esi+552], eax
	call	ebx

; 433  : 	m_iStealTechSlowerModifier = kResults.GetInt("StealTechSlowerModifier");

	push	OFFSET $SG223640
	mov	ecx, edi
	mov	DWORD PTR [esi+556], eax
	call	ebx

; 434  : 	m_iStealTechFasterModifier = kResults.GetInt("StealTechFasterModifier");

	push	OFFSET $SG223641
	mov	ecx, edi
	mov	DWORD PTR [esi+560], eax
	call	ebx

; 435  : 	m_iCatchSpiesModifier = kResults.GetInt("CatchSpiesModifier");

	push	OFFSET $SG223642
	mov	ecx, edi
	mov	DWORD PTR [esi+564], eax
	call	ebx

; 436  : 	m_iGoldPerUnit = kResults.GetInt("GoldPerUnit");

	push	OFFSET $SG223643
	mov	ecx, edi
	mov	DWORD PTR [esi+568], eax
	call	ebx

; 437  : 	m_iGoldPerMilitaryUnit = kResults.GetInt("GoldPerMilitaryUnit");

	push	OFFSET $SG223644
	mov	ecx, edi
	mov	DWORD PTR [esi+572], eax
	call	ebx

; 438  : 	m_iCityStrengthMod = kResults.GetInt("CityStrengthMod");

	push	OFFSET $SG223645
	mov	ecx, edi
	mov	DWORD PTR [esi+576], eax
	call	ebx
	mov	DWORD PTR [esi+580], eax

; 439  : 	m_iCityGrowthMod = kResults.GetInt("CityGrowthMod");

	push	OFFSET $SG223646
	mov	ecx, edi
	call	ebx

; 440  : 	m_iCapitalGrowthMod = kResults.GetInt("CapitalGrowthMod");

	push	OFFSET $SG223647
	mov	ecx, edi
	mov	DWORD PTR [esi+584], eax
	call	ebx

; 441  : 	m_iSettlerProductionModifier = kResults.GetInt("SettlerProductionModifier");

	push	OFFSET $SG223648
	mov	ecx, edi
	mov	DWORD PTR [esi+588], eax
	call	ebx

; 442  : 	m_iCapitalSettlerProductionModifier = kResults.GetInt("CapitalSettlerProductionModifier");

	push	OFFSET $SG223649
	mov	ecx, edi
	mov	DWORD PTR [esi+592], eax
	call	ebx

; 443  : 	m_iNewCityExtraPopulation = kResults.GetInt("NewCityExtraPopulation");

	push	OFFSET $SG223650
	mov	ecx, edi
	mov	DWORD PTR [esi+596], eax
	call	ebx

; 444  : 	m_iFreeFoodBox = kResults.GetInt("FreeFoodBox");

	push	OFFSET $SG223651
	mov	ecx, edi
	mov	DWORD PTR [esi+600], eax
	call	ebx

; 445  : 	m_iRouteGoldMaintenanceMod = kResults.GetInt("RouteGoldMaintenanceMod");

	push	OFFSET $SG223652
	mov	ecx, edi
	mov	DWORD PTR [esi+604], eax
	call	ebx

; 446  : 	m_iBuildingGoldMaintenanceMod = kResults.GetInt("BuildingGoldMaintenanceMod");

	push	OFFSET $SG223653
	mov	ecx, edi
	mov	DWORD PTR [esi+608], eax
	call	ebx

; 447  : 	m_iUnitGoldMaintenanceMod = kResults.GetInt("UnitGoldMaintenanceMod");

	push	OFFSET $SG223654
	mov	ecx, edi
	mov	DWORD PTR [esi+612], eax
	call	ebx

; 448  : 	m_iUnitSupplyMod = kResults.GetInt("UnitSupplyMod");

	push	OFFSET $SG223655
	mov	ecx, edi
	mov	DWORD PTR [esi+616], eax
	call	ebx

; 449  : 	m_iHappyPerMilitaryUnit = kResults.GetInt("HappyPerMilitaryUnit");

	push	OFFSET $SG223656
	mov	ecx, edi
	mov	DWORD PTR [esi+620], eax
	call	ebx

; 450  : 	m_iHappinessToCulture = kResults.GetInt("HappinessToCulture");

	push	OFFSET $SG223657
	mov	ecx, edi
	mov	DWORD PTR [esi+624], eax
	call	ebx

; 451  : 	m_iHappinessToScience = kResults.GetInt("HappinessToScience");

	push	OFFSET $SG223658
	mov	ecx, edi
	mov	DWORD PTR [esi+840], eax
	call	ebx

; 452  : #ifdef NQ_GOLD_TO_SCIENCE_FROM_POLICIES
; 453  : 	m_iGoldToScience = kResults.GetInt("GoldToScience");

	push	OFFSET $SG223659
	mov	ecx, edi
	mov	DWORD PTR [esi+844], eax
	call	ebx

; 454  : #endif
; 455  : 	m_iNumCitiesFreeAestheticsSchools = kResults.GetInt("NumCitiesFreeAestheticsSchools"); // NQMP GJS - add support for NumCitiesFreeAestheticsSchools

	push	OFFSET $SG223660
	mov	ecx, edi
	mov	DWORD PTR [esi+848], eax
	call	ebx

; 456  : 	m_iNumCitiesFreePietyGardens = kResults.GetInt("NumCitiesFreePietyGardens");

	push	OFFSET $SG223661
	mov	ecx, edi
	mov	DWORD PTR [esi+852], eax
	call	ebx

; 457  : 	m_iNumCitiesFreeWalls = kResults.GetInt("NumCitiesFreeWalls"); // NQMP GJS - New Oligarchy add support for NumCitiesFreeWalls

	push	OFFSET $SG223662
	mov	ecx, edi
	mov	DWORD PTR [esi+856], eax
	call	ebx

; 458  : 	m_iNumCitiesFreeCultureBuilding = kResults.GetInt("NumCitiesFreeCultureBuilding");

	push	OFFSET $SG223663
	mov	ecx, edi
	mov	DWORD PTR [esi+860], eax
	call	ebx

; 459  : 	m_iNumCitiesFreeFoodBuilding = kResults.GetInt("NumCitiesFreeFoodBuilding");

	push	OFFSET $SG223664
	mov	ecx, edi
	mov	DWORD PTR [esi+864], eax
	call	ebx

; 460  : 	m_bHalfSpecialistUnhappiness = kResults.GetBool("HalfSpecialistUnhappiness");

	mov	ebp, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG223665
	mov	ecx, edi
	mov	DWORD PTR [esi+868], eax
	call	ebp
	mov	BYTE PTR [esi+872], al

; 461  : 	m_bHalfMoreSpecialistUnhappiness = kResults.GetBool("HalfMoreSpecialistUnhappiness");

	push	OFFSET $SG223666
	mov	ecx, edi
	call	ebp

; 462  : 	m_bHalfSpecialistFood = kResults.GetBool("HalfSpecialistFood");

	push	OFFSET $SG223667
	mov	ecx, edi
	mov	BYTE PTR [esi+873], al
	call	ebp

; 463  : 	m_bMilitaryFoodProduction = kResults.GetBool("MilitaryFoodProduction");

	push	OFFSET $SG223668
	mov	ecx, edi
	mov	BYTE PTR [esi+874], al
	call	ebp

; 464  : 	m_iMaxConscript = kResults.GetInt("MaxConscript");

	push	OFFSET $SG223669
	mov	ecx, edi
	mov	BYTE PTR [esi+875], al
	call	ebx

; 465  : 	m_iWoundedUnitDamageMod = kResults.GetInt("WoundedUnitDamageMod");

	push	OFFSET $SG223670
	mov	ecx, edi
	mov	DWORD PTR [esi+816], eax
	call	ebx

; 466  : 	m_iUnitUpgradeCostMod = kResults.GetInt("UnitUpgradeCostMod");

	push	OFFSET $SG223671
	mov	ecx, edi
	mov	DWORD PTR [esi+828], eax
	call	ebx

; 467  : 	m_iBarbarianCombatBonus = kResults.GetInt("BarbarianCombatBonus");

	push	OFFSET $SG223672
	mov	ecx, edi
	mov	DWORD PTR [esi+832], eax
	call	ebx

; 468  : 	m_bAlwaysSeeBarbCamps = kResults.GetBool("AlwaysSeeBarbCamps");

	push	OFFSET $SG223673
	mov	ecx, edi
	mov	DWORD PTR [esi+836], eax
	call	ebp

; 469  : 	m_bRevealAllCapitals = kResults.GetBool("RevealAllCapitals");

	push	OFFSET $SG223674
	mov	ecx, edi
	mov	BYTE PTR [esi+876], al
	call	ebp

; 470  : 	m_bGarrisonFreeMaintenance = kResults.GetBool("GarrisonFreeMaintenance");

	push	OFFSET $SG223675
	mov	ecx, edi
	mov	BYTE PTR [esi+877], al
	call	ebp

; 471  : 	m_iFreeSpecialist = kResults.GetInt("FreeSpecialist");

	push	OFFSET $SG223676
	mov	ecx, edi
	mov	BYTE PTR [esi+878], al
	call	ebx

; 472  : 	m_iExpModifier = kResults.GetInt("ExpModifier");

	push	OFFSET $SG223677
	mov	ecx, edi
	mov	DWORD PTR [esi+812], eax
	call	ebx

; 473  : 	m_iExpInBorderModifier = kResults.GetInt("ExpInBorderModifier");

	push	OFFSET $SG223678
	mov	ecx, edi
	mov	DWORD PTR [esi+628], eax
	call	ebx

; 474  : 	m_iMinorQuestFriendshipMod = kResults.GetInt("MinorQuestFriendshipMod");

	push	OFFSET $SG223679
	mov	ecx, edi
	mov	DWORD PTR [esi+632], eax
	call	ebx

; 475  : 	m_iMinorGoldFriendshipMod = kResults.GetInt("MinorGoldFriendshipMod");

	push	OFFSET $SG223680
	mov	ecx, edi
	mov	DWORD PTR [esi+636], eax
	call	ebx

; 476  : 	m_iMinorFriendshipMinimum = kResults.GetInt("MinorFriendshipMinimum");

	push	OFFSET $SG223681
	mov	ecx, edi
	mov	DWORD PTR [esi+640], eax
	call	ebx

; 477  : 	m_iMinorFriendshipDecayMod = kResults.GetInt("MinorFriendshipDecayMod");

	push	OFFSET $SG223682
	mov	ecx, edi
	mov	DWORD PTR [esi+644], eax
	call	ebx

; 478  : 	m_iOtherPlayersMinorFriendshipDecayMod = kResults.GetInt("OtherPlayersMinorFriendshipDecayMod");

	push	OFFSET $SG223683
	mov	ecx, edi
	mov	DWORD PTR [esi+648], eax
	call	ebx

; 479  : 	m_iCityStateUnitFrequencyModifier = kResults.GetInt("CityStateUnitFrequencyModifier");

	push	OFFSET $SG223684
	mov	ecx, edi
	mov	DWORD PTR [esi+652], eax
	call	ebx

; 480  : 	m_iCommonFoeTourismModifier = kResults.GetInt("CommonFoeTourismModifier");

	push	OFFSET $SG223685
	mov	ecx, edi
	mov	DWORD PTR [esi+656], eax
	call	ebx
	mov	DWORD PTR [esi+660], eax

; 481  : 	m_iLessHappyTourismModifier = kResults.GetInt("LessHappyTourismModifier");

	push	OFFSET $SG223686
	mov	ecx, edi
	call	ebx

; 482  : 	m_iSharedIdeologyTourismModifier = kResults.GetInt("SharedIdeologyTourismModifier");

	push	OFFSET $SG223687
	mov	ecx, edi
	mov	DWORD PTR [esi+664], eax
	call	ebx

; 483  : 	m_iLandTradeRouteGoldChange = kResults.GetInt("LandTradeRouteGoldChange");

	push	OFFSET $SG223688
	mov	ecx, edi
	mov	DWORD PTR [esi+668], eax
	call	ebx

; 484  : 	m_iSeaTradeRouteGoldChange = kResults.GetInt("SeaTradeRouteGoldChange");

	push	OFFSET $SG223689
	mov	ecx, edi
	mov	DWORD PTR [esi+672], eax
	call	ebx

; 485  : 	m_iInternalTradeRouteGoldChange = kResults.GetInt("InternalTradeRouteGoldChange"); // NQMP GJS - Silk Road

	push	OFFSET $SG223690
	mov	ecx, edi
	mov	DWORD PTR [esi+676], eax
	call	ebx

; 486  : 	m_iSharedIdeologyTradeGoldChange = kResults.GetInt("SharedIdeologyTradeGoldChange");

	push	OFFSET $SG223691
	mov	ecx, edi
	mov	DWORD PTR [esi+680], eax
	call	ebx

; 487  : 
; 488  : 	m_iRiggingElectionModifier = kResults.GetInt("RiggingElectionModifier");

	push	OFFSET $SG223692
	mov	ecx, edi
	mov	DWORD PTR [esi+684], eax
	call	ebx

; 489  : 	m_iMilitaryUnitGiftExtraInfluence = kResults.GetInt("MilitaryUnitGiftExtraInfluence");

	push	OFFSET $SG223693
	mov	ecx, edi
	mov	DWORD PTR [esi+688], eax
	call	ebx

; 490  : 	m_iProtectedMinorPerTurnInfluence = kResults.GetInt("ProtectedMinorPerTurnInfluence");

	push	OFFSET $SG223694
	mov	ecx, edi
	mov	DWORD PTR [esi+692], eax
	call	ebx

; 491  : 	m_iAfraidMinorPerTurnInfluence = kResults.GetInt("AfraidMinorPerTurnInfluence");

	push	OFFSET $SG223695
	mov	ecx, edi
	mov	DWORD PTR [esi+696], eax
	call	ebx

; 492  : 	m_iMinorBullyScoreModifier = kResults.GetInt("MinorBullyScoreModifier");

	push	OFFSET $SG223696
	mov	ecx, edi
	mov	DWORD PTR [esi+700], eax
	call	ebx

; 493  : 	m_iThemingBonusMultiplier = kResults.GetInt("ThemingBonusMultiplier");

	push	OFFSET $SG223697
	mov	ecx, edi
	mov	DWORD PTR [esi+704], eax
	call	ebx

; 494  : 	m_iInternalTradeRouteYieldModifier = kResults.GetInt("InternalTradeRouteYieldModifier");

	push	OFFSET $SG223698
	mov	ecx, edi
	mov	DWORD PTR [esi+708], eax
	call	ebx

; 495  : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 496  : 	m_iInternalTradeRouteFoodYieldChange = kResults.GetInt("InternalTradeRouteFoodYieldChange");
; 497  : #endif
; 498  : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 499  : 	m_iInternalTradeRouteProductionYieldChange = kResults.GetInt("InternalTradeRouteProductionYieldChange");

	push	OFFSET $SG223699
	mov	ecx, edi
	mov	DWORD PTR [esi+712], eax
	call	ebx

; 500  : #endif
; 501  : #ifdef NQ_RAIL_CONNECTION_PRODUCTION_MODIFIER_FROM_POLICIES
; 502  : 	m_iRailConnectionProductionModifier = kResults.GetInt("RailConnectionProductionModifier");

	push	OFFSET $SG223700
	mov	ecx, edi
	mov	DWORD PTR [esi+716], eax
	call	ebx

; 503  : #endif
; 504  : #ifdef NQ_COMBAT_BONUS_VS_SMALLER_CIV_FROM_POLICIES
; 505  : 	m_iCombatBonusVsSmallerCiv = kResults.GetInt("CombatBonusVsSmallerCiv");

	push	OFFSET $SG223701
	mov	ecx, edi
	mov	DWORD PTR [esi+720], eax
	call	ebx

; 506  : #endif
; 507  : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 508  : 	m_iProductionToGreatMusiciansModifier = kResults.GetInt("ProductionToGreatMusiciansModifier");

	push	OFFSET $SG223702
	mov	ecx, edi
	mov	DWORD PTR [esi+724], eax
	call	ebx

; 509  : #endif
; 510  : #ifdef NQ_TRADE_MISSION_INFLUENCE_MODIFIER_FROM_POLICIES
; 511  : 	m_iTradeMissionInfluenceModifier = kResults.GetInt("TradeMissionInfluenceModifier");

	push	OFFSET $SG223703
	mov	ecx, edi
	mov	DWORD PTR [esi+728], eax
	call	ebx

; 512  : #endif
; 513  : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 514  : 	m_iSciencePerGreatPersonBorn = kResults.GetInt("SciencePerGreatPersonBorn");

	push	OFFSET $SG223704
	mov	ecx, edi
	mov	DWORD PTR [esi+732], eax
	call	ebx

; 515  : #endif
; 516  : #ifdef NQ_INFLUENCE_BOOST_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 517  : 	m_iInfluenceBoostPerGreatPersonBorn = kResults.GetInt("InfluenceBoostPerGreatPersonBorn");

	push	OFFSET $SG223705
	mov	ecx, edi
	mov	DWORD PTR [esi+736], eax
	call	ebx

; 518  : #endif
; 519  : #ifdef NQ_TOURISM_FROM_TRADE_MISSIONS_FROM_POLICIES
; 520  : 	m_iTourismFromTradeMissions = kResults.GetInt("TourismFromTradeMissions");

	push	OFFSET $SG223706
	mov	ecx, edi
	mov	DWORD PTR [esi+740], eax
	call	ebx

; 521  : #endif
; 522  : #ifdef NQ_HAPPINESS_FROM_GREAT_IMPROVEMENTS_FROM_POLICIES
; 523  : 	m_iHappinessFromGreatImprovements = kResults.GetInt("HappinessFromGreatImprovements");

	push	OFFSET $SG223707
	mov	ecx, edi
	mov	DWORD PTR [esi+744], eax
	call	ebx

; 524  : #endif
; 525  : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 526  : 	m_iMinorFriendshipGainBullyGoldSuccess = kResults.GetInt("MinorFriendshipGainBullyGoldSuccess");

	push	OFFSET $SG223708
	mov	ecx, edi
	mov	DWORD PTR [esi+748], eax
	call	ebx

; 527  : #endif
; 528  : #ifdef NQ_COUP_CHANCE_MODIFIER_FROM_POLICIES
; 529  : 	m_iCoupChanceModifier = kResults.GetInt("CoupChanceModifier");

	push	OFFSET $SG223709
	mov	ecx, edi
	mov	DWORD PTR [esi+752], eax
	call	ebx

; 530  : #endif
; 531  : 	m_iSharedReligionTourismModifier = kResults.GetInt("SharedReligionTourismModifier");

	push	OFFSET $SG223710
	mov	ecx, edi
	mov	DWORD PTR [esi+756], eax
	call	ebx

; 532  : 	m_iTradeRouteTourismModifier = kResults.GetInt("TradeRouteTourismModifier");

	push	OFFSET $SG223711
	mov	ecx, edi
	mov	DWORD PTR [esi+760], eax
	call	ebx

; 533  : 	m_iOpenBordersTourismModifier = kResults.GetInt("OpenBordersTourismModifier");

	push	OFFSET $SG223712
	mov	ecx, edi
	mov	DWORD PTR [esi+764], eax
	call	ebx

; 534  : 	m_iCityStateTradeChange = kResults.GetInt("CityStateTradeChange");

	push	OFFSET $SG223713
	mov	ecx, edi
	mov	DWORD PTR [esi+768], eax
	call	ebx

; 535  : 	m_bMinorGreatPeopleAllies = kResults.GetBool("MinorGreatPeopleAllies");

	push	OFFSET $SG223714
	mov	ecx, edi
	mov	DWORD PTR [esi+772], eax
	call	ebp

; 536  : 	m_bMinorScienceAllies = kResults.GetBool("MinorScienceAllies");

	push	OFFSET $SG223715
	mov	ecx, edi
	mov	BYTE PTR [esi+776], al
	call	ebp

; 537  : 	m_bMinorResourceBonus = kResults.GetBool("MinorResourceBonus");

	push	OFFSET $SG223716
	mov	ecx, edi
	mov	BYTE PTR [esi+777], al
	call	ebp

; 538  : 	m_iMinorMilitaryNumExtraUnitsToGift = kResults.GetInt("MinorMilitaryNumExtraUnitsToGift"); // NQMP GJS - Patronage Finisher

	push	OFFSET $SG223717
	mov	ecx, edi
	mov	BYTE PTR [esi+778], al
	call	ebx

; 539  : 	m_iCityStateBonusModifier = kResults.GetInt("CityStateBonusModifier"); // NQMP GJS - Patronage Finisher

	push	OFFSET $SG223718
	mov	ecx, edi
	mov	DWORD PTR [esi+780], eax
	call	ebx

; 540  : 	m_iExtraTerritoryClaim = kResults.GetInt("ExtraTerritoryClaim"); // NQMP GJS - Colonialism

	push	OFFSET $SG223719
	mov	ecx, edi
	mov	DWORD PTR [esi+784], eax
	call	ebx

; 541  : 	m_iExtraTourismPerGreatWork = kResults.GetInt("ExtraTourismPerGreatWork"); // NQMP GJS - Cultural Exchange

	push	OFFSET $SG223720
	mov	ecx, edi
	mov	DWORD PTR [esi+788], eax
	call	ebx

; 542  : 	m_iTourismPerWonder = kResults.GetInt("TourismPerWonder"); // NQMP GJS - Flourishing of the Arts

	push	OFFSET $SG223721
	mov	ecx, edi
	mov	DWORD PTR [esi+792], eax
	call	ebx

; 543  : #ifdef NQ_TOURISM_PER_CITY
; 544  : 	m_iTourismPerCity = kResults.GetInt("TourismPerCity");

	push	OFFSET $SG223722
	mov	ecx, edi
	mov	DWORD PTR [esi+796], eax
	call	ebx

; 545  : #endif
; 546  : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 547  : 	m_iIdeologyPressureUnhappinessModifier = kResults.GetInt("IdeologyPressureUnhappinessModifier");

	push	OFFSET $SG223723
	mov	ecx, edi
	mov	DWORD PTR [esi+800], eax
	call	ebx

; 548  : #endif
; 549  : 
; 550  : 	m_iProductionFromGarrison = kResults.GetInt("ProductionFromGarrison"); // NQMP GJS - Military Caste

	push	OFFSET $SG223724
	mov	ecx, edi
	mov	DWORD PTR [esi+804], eax
	call	ebx

; 551  : 	m_bGoldenAgeCultureBonusDisabled = kResults.GetBool("GoldenAgeCultureBonusDisabled");

	push	OFFSET $SG223725
	mov	ecx, edi
	mov	DWORD PTR [esi+808], eax
	call	ebp

; 552  : 	m_bSecondReligionPantheon = kResults.GetBool("SecondReligionPantheon");

	push	OFFSET $SG223726
	mov	ecx, edi
	mov	BYTE PTR [esi+879], al
	call	ebp
	mov	BYTE PTR [esi+880], al

; 553  : 	m_bAddReformationBelief = kResults.GetBool("AddReformationBelief");

	push	OFFSET $SG223727
	mov	ecx, edi
	call	ebp

; 554  : 	m_bEnablesSSPartHurry = kResults.GetBool("EnablesSSPartHurry");

	push	OFFSET $SG223728
	mov	ecx, edi
	mov	BYTE PTR [esi+881], al
	call	ebp

; 555  : #ifdef NQ_DIABLE_RESISTANCE_TIME_VIA_POLICIES
; 556  : 	m_bDisablesResistanceTime = kResults.GetBool("DisablesResistanceTime");

	push	OFFSET $SG223729
	mov	ecx, edi
	mov	BYTE PTR [esi+882], al
	call	ebp

; 557  : #endif
; 558  : #ifdef NQ_PATRIOTIC_WAR
; 559  : 	m_bDoubleTrainedMilitaryLandUnit = kResults.GetBool("IsDoubleTrainedMilitaryLandUnits");

	push	OFFSET $SG223730
	mov	ecx, edi
	mov	BYTE PTR [esi+883], al
	call	ebp

; 560  : #endif
; 561  : #ifdef NQ_WAR_HERO
; 562  : 	m_bWarHero = kResults.GetBool("IsWarHero");

	push	OFFSET $SG223731
	mov	ecx, edi
	mov	BYTE PTR [esi+884], al
	call	ebp

; 563  : #endif
; 564  : #ifdef NQ_IGNORE_PUPPETS_FOR_RESEARCH_COSTS_FROM_POLICIES
; 565  : 	m_bIgnorePuppetsForResearchCosts = kResults.GetBool("IgnorePuppetsForResearchCosts");
; 566  : #endif
; 567  : #ifdef NQ_POLICY_TOGGLE_NO_MINOR_DOW_IF_FRIENDS
; 568  : 	m_bNoMinorDOWIfFriends = kResults.GetBool("NoMinorDOWIfFriends");

	push	OFFSET $SG223732
	mov	ecx, edi
	mov	BYTE PTR [esi+885], al
	call	ebp

; 569  : #endif
; 570  : #ifdef NQ_ALLOW_PUPPET_PURCHASING_FROM_POLICIES
; 571  : 	m_bAllowPuppetPurchasing = kResults.GetBool("AllowPuppetPurchasing");

	push	OFFSET $SG223733
	mov	ecx, edi
	mov	BYTE PTR [esi+886], al
	call	ebp

; 572  : #endif
; 573  : 
; 574  : 	m_bEnablesSSPartPurchase = kResults.GetBool("EnablesSSPartPurchase");

	push	OFFSET $SG223734
	mov	ecx, edi
	mov	BYTE PTR [esi+887], al
	call	ebp

; 575  : 	m_bAbleToAnnexCityStates = kResults.GetBool("AbleToAnnexCityStates");

	push	OFFSET $SG223735
	mov	ecx, edi
	mov	BYTE PTR [esi+888], al
	call	ebp

; 576  : 	m_bOneShot = kResults.GetBool("OneShot");

	push	OFFSET $SG223736
	mov	ecx, edi
	mov	BYTE PTR [esi+889], al
	call	ebp

; 577  : 	m_bIncludesOneShotFreeUnits = kResults.GetBool("IncludesOneShotFreeUnits");

	push	OFFSET $SG223737
	mov	ecx, edi
	mov	BYTE PTR [esi+890], al
	call	ebp

; 578  : 
; 579  : 	m_strWeLoveTheKingKey = kResults.GetText("WeLoveTheKing");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG223738
	mov	ecx, edi
	mov	BYTE PTR [esi+891], al
	call	ebp
	lea	ecx, DWORD PTR [esi+892]
	test	eax, eax
	je	SHORT $LN36@CacheResul@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@CacheResul@2
$LN36@CacheResul@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@CacheResul@2:

; 580  : 	m_wstrWeLoveTheKing = GetLocalizedText(m_strWeLoveTheKingKey);

	lea	ecx, DWORD PTR [esi+892]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR $T246740[esp+108]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [esi+920]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T246740[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 581  : 
; 582  : 	//References
; 583  : 	const char* szTechPrereq = kResults.GetText("TechPrereq");

	push	OFFSET $SG223741
	mov	ecx, edi
	call	ebp

; 584  : 	m_iTechPrereq = GC.getInfoTypeForString(szTechPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 585  : 
; 586  : 	const char* szPolicyBranchType = kResults.GetText("PolicyBranchType");

	push	OFFSET $SG223743
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebp

; 587  : 	m_iPolicyBranchType = GC.getInfoTypeForString(szPolicyBranchType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 588  : 
; 589  : 	m_iNumExtraBranches = kResults.GetInt("NumExtraBranches");

	push	OFFSET $SG223744
	mov	ecx, edi
	mov	DWORD PTR [esi+820], eax
	call	ebx

; 590  : 
; 591  : 	const char* szFreeBuilding = kResults.GetText("FreeBuildingOnConquest");

	push	OFFSET $SG223746
	mov	ecx, edi
	mov	DWORD PTR [esi+824], eax
	call	ebp

; 592  : 	if(szFreeBuilding)

	test	eax, eax
	je	SHORT $LN22@CacheResul@2

; 593  : 	{
; 594  : 		m_eFreeBuildingOnConquest = (BuildingTypes)GC.getInfoTypeForString(szFreeBuilding, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+948], eax
$LN22@CacheResul@2:

; 595  : 	}
; 596  : 
; 597  : 	//Arrays
; 598  : 	const char* szPolicyType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 599  : 	kUtility.SetYields(m_piYieldModifier, "Policy_YieldModifiers", "PolicyType", szPolicyType);

	mov	ebp, DWORD PTR _kUtility$[esp+100]
	mov	edi, eax
	push	edi
	push	OFFSET $SG223750
	push	OFFSET $SG223751
	lea	edx, DWORD PTR [esi+976]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR _szPolicyType$[esp+116], edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 600  : 	kUtility.SetYields(m_piCityYieldChange, "Policy_CityYieldChanges", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223752
	push	OFFSET $SG223753
	lea	eax, DWORD PTR [esi+980]
	push	eax
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 601  : 	kUtility.SetYields(m_piCoastalCityYieldChange, "Policy_CoastalCityYieldChanges", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223754
	push	OFFSET $SG223755
	lea	ecx, DWORD PTR [esi+984]
	push	ecx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 602  : 	kUtility.SetYields(m_piCapitalYieldChange, "Policy_CapitalYieldChanges", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223756
	push	OFFSET $SG223757
	lea	edx, DWORD PTR [esi+988]
	push	edx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 603  : 	kUtility.SetYields(m_piCapitalYieldPerPopChange, "Policy_CapitalYieldPerPopChanges", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223758
	push	OFFSET $SG223759
	lea	eax, DWORD PTR [esi+992]
	push	eax
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 604  : 	kUtility.SetYields(m_piCapitalYieldModifier, "Policy_CapitalYieldModifiers", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223760
	push	OFFSET $SG223761
	lea	ecx, DWORD PTR [esi+996]
	push	ecx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 605  : 	kUtility.SetYields(m_piGreatWorkYieldChange, "Policy_GreatWorkYieldChanges", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223762
	push	OFFSET $SG223763
	lea	edx, DWORD PTR [esi+1000]
	push	edx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 606  : 	kUtility.SetYields(m_piSpecialistExtraYield, "Policy_SpecialistExtraYields", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223764
	push	OFFSET $SG223765
	lea	eax, DWORD PTR [esi+1004]
	push	eax
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 607  : 
; 608  : 	kUtility.SetFlavors(m_piFlavorValue, "Policy_Flavors", "PolicyType", szPolicyType);

	push	0
	push	edi
	push	OFFSET $SG223766
	push	OFFSET $SG223767
	lea	ecx, DWORD PTR [esi+1068]
	push	ecx
	mov	ecx, ebp
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 609  : 
; 610  : 	kUtility.PopulateArrayByValue(m_paiHurryModifier, "HurryInfos", "Policy_HurryModifiers", "HurryType", "PolicyType", szPolicyType, "HurryCostModifier");

	push	0
	push	0
	push	OFFSET $SG223768
	push	edi
	push	OFFSET $SG223769
	push	OFFSET $SG223770
	push	OFFSET $SG223771
	push	OFFSET $SG223772
	lea	edx, DWORD PTR [esi+1024]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 611  : 
; 612  : 	kUtility.PopulateArrayByExistence(m_pabSpecialistValid, "Specialists", "Policy_ValidSpecialists", "SpecialistType", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223773
	push	OFFSET $SG223774
	push	OFFSET $SG223775
	push	OFFSET $SG223776
	lea	eax, DWORD PTR [esi+1052]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 613  : 
; 614  : 	kUtility.PopulateArrayByExistence(m_pabFreePromotion, "UnitPromotions", "Policy_FreePromotions", "PromotionType", "PolicyType", szPolicyType);

	push	edi
	push	OFFSET $SG223777
	push	OFFSET $SG223778
	push	OFFSET $SG223779
	push	OFFSET $SG223780
	lea	ecx, DWORD PTR [esi+1012]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 615  : 	kUtility.PopulateArrayByValue(m_paiUnitCombatFreeExperiences, "UnitCombatInfos", "Policy_UnitCombatFreeExperiences", "UnitCombatType", "PolicyType", szPolicyType, "FreeExperience");

	push	0
	push	0
	push	OFFSET $SG223781
	push	edi
	push	OFFSET $SG223782
	push	OFFSET $SG223783
	push	OFFSET $SG223784
	push	OFFSET $SG223785
	lea	edx, DWORD PTR [esi+1020]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 616  : 	kUtility.PopulateArrayByValue(m_paiUnitCombatProductionModifiers, "UnitCombatInfos", "Policy_UnitCombatProductionModifiers", "UnitCombatType", "PolicyType", szPolicyType, "ProductionModifier");

	push	0
	push	0
	push	OFFSET $SG223786
	push	edi
	push	OFFSET $SG223787
	push	OFFSET $SG223788
	push	OFFSET $SG223789
	push	OFFSET $SG223790
	lea	eax, DWORD PTR [esi+1016]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 617  : 
; 618  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassCultureChanges, "BuildingClasses", "Policy_BuildingClassCultureChanges", "BuildingClassType", "PolicyType", szPolicyType, "CultureChange");

	push	0
	push	0
	push	OFFSET $SG223791
	push	edi
	push	OFFSET $SG223792
	push	OFFSET $SG223793
	push	OFFSET $SG223794
	push	OFFSET $SG223795
	lea	ecx, DWORD PTR [esi+1028]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 619  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassProductionModifiers, "BuildingClasses", "Policy_BuildingClassProductionModifiers", "BuildingClassType", "PolicyType", szPolicyType, "ProductionModifier");

	push	0
	push	0
	push	OFFSET $SG223796
	push	edi
	push	OFFSET $SG223797
	push	OFFSET $SG223798
	push	OFFSET $SG223799
	push	OFFSET $SG223800
	lea	edx, DWORD PTR [esi+1032]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 620  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassTourismModifiers, "BuildingClasses", "Policy_BuildingClassTourismModifiers", "BuildingClassType", "PolicyType", szPolicyType, "TourismModifier");

	push	0
	push	0
	push	OFFSET $SG223801
	push	edi
	push	OFFSET $SG223802
	push	OFFSET $SG223803
	push	OFFSET $SG223804
	push	OFFSET $SG223805
	lea	eax, DWORD PTR [esi+1036]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 621  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassHappiness, "BuildingClasses", "Policy_BuildingClassHappiness", "BuildingClassType", "PolicyType", szPolicyType, "Happiness");

	push	0
	push	0
	push	OFFSET $SG223806
	push	edi
	push	OFFSET $SG223807
	push	OFFSET $SG223808
	push	OFFSET $SG223809
	push	OFFSET $SG223810
	lea	ecx, DWORD PTR [esi+1040]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 622  : 
; 623  : 	kUtility.PopulateArrayByValue(m_paiFreeUnitClasses, "UnitClasses", "Policy_FreeUnitClasses", "UnitClassType", "PolicyType", szPolicyType, "Count");

	push	0
	push	0
	push	OFFSET $SG223811
	push	edi
	push	OFFSET $SG223812
	push	OFFSET $SG223813
	push	OFFSET $SG223814
	push	OFFSET $SG223815
	lea	edx, DWORD PTR [esi+1044]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 624  : 	kUtility.PopulateArrayByValue(m_paiTourismOnUnitCreation, "UnitClasses", "Policy_TourismOnUnitCreation", "UnitClassType", "PolicyType", szPolicyType, "Tourism");

	push	0
	push	0
	push	OFFSET $SG223816
	push	edi
	push	OFFSET $SG223817
	push	OFFSET $SG223818
	push	OFFSET $SG223819
	push	OFFSET $SG223820
	lea	eax, DWORD PTR [esi+1048]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 625  : 
; 626  : 	//BuildingYieldModifiers
; 627  : 	{
; 628  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 629  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldModifiers.first, "BuildingClasses", "Yields");
; 630  : 		m_ppiBuildingClassYieldModifiers.second = kUtility.MaxRows("BuildingClasses");
; 631  : #else
; 632  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldModifiers, "BuildingClasses", "Yields");

	push	0
	push	OFFSET $SG223821
	lea	eax, DWORD PTR [esi+1060]
	push	OFFSET $SG223822
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 633  : #endif
; 634  : 
; 635  : 		std::string strKey("Policy_BuildingClassYieldModifiers");

	push	OFFSET $SG223824
	lea	ecx, DWORD PTR _strKey$223823[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 636  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$223823[esp+104]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 637  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN21@CacheResul@2

; 638  : 		{
; 639  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldMod from Policy_BuildingClassYieldModifiers inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where PolicyType = ?");

	push	OFFSET $SG223827
	lea	edx, DWORD PTR _strKey$223823[esp+108]
	push	edx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN21@CacheResul@2:

; 640  : 		}
; 641  : 
; 642  : 		pResults->Bind(1, szPolicyType);

	push	1
	push	edi
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 643  : 
; 644  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	edi, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	test	al, al
	je	SHORT $LN19@CacheResul@2
$LL20@CacheResul@2:

; 645  : 		{
; 646  : 			const int BuildingClassID = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 647  : 			const int iYieldID = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _BuildingClassID$223831[esp+104], eax
	call	edi

; 648  : 			const int iYieldMod = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _iYieldID$223832[esp+108], eax
	call	edi

; 649  : 
; 650  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 651  : 			m_ppiBuildingClassYieldModifiers.first[BuildingClassID][iYieldID] = iYieldMod;
; 652  : #else
; 653  : 			m_ppiBuildingClassYieldModifiers[BuildingClassID][iYieldID] = iYieldMod;

	mov	ecx, DWORD PTR [esi+1060]
	mov	edx, DWORD PTR _BuildingClassID$223831[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _iYieldID$223832[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL20@CacheResul@2
$LN19@CacheResul@2:

; 654  : #endif
; 655  : 		}
; 656  : 	}

	lea	ecx, DWORD PTR _strKey$223823[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 657  : 
; 658  : 	//BuildingYieldChanges
; 659  : 	{
; 660  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 661  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges.first, "BuildingClasses", "Yields");
; 662  : 		m_ppiBuildingClassYieldChanges.second = kUtility.MaxRows("BuildingClasses");
; 663  : #else
; 664  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges, "BuildingClasses", "Yields");

	push	0
	push	OFFSET $SG223834
	lea	eax, DWORD PTR [esi+1064]
	push	OFFSET $SG223835
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 665  : #endif
; 666  : 
; 667  : 		std::string strKey("Policy_BuildingClassYieldChanges");

	push	OFFSET $SG223837
	lea	ecx, DWORD PTR _strKey$223836[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 668  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$223836[esp+104]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 2
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 669  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN18@CacheResul@2

; 670  : 		{
; 671  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldChange from Policy_BuildingClassYieldChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where PolicyType = ?");

	push	OFFSET $SG223840
	lea	ecx, DWORD PTR _strKey$223836[esp+108]
	push	ecx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN18@CacheResul@2:

; 672  : 		}
; 673  : 
; 674  : 		pResults->Bind(1, szPolicyType);

	mov	edx, DWORD PTR _szPolicyType$[esp+100]
	push	1
	push	edx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 675  : 
; 676  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN16@CacheResul@2
$LL17@CacheResul@2:

; 677  : 		{
; 678  : 			const int BuildingClassID = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 679  : 			const int iYieldID = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _BuildingClassID$223844[esp+104], eax
	call	edi

; 680  : 			const int iYieldChange = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _iYieldID$223845[esp+108], eax
	call	edi

; 681  : 
; 682  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 683  : 			m_ppiBuildingClassYieldChanges.first[BuildingClassID][iYieldID] = iYieldChange;
; 684  : #else
; 685  : 			m_ppiBuildingClassYieldChanges[BuildingClassID][iYieldID] = iYieldChange;

	mov	ecx, DWORD PTR [esi+1064]
	mov	edx, DWORD PTR _BuildingClassID$223844[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _iYieldID$223845[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL17@CacheResul@2
$LN16@CacheResul@2:

; 686  : #endif
; 687  : 		}
; 688  : 	}

	lea	ecx, DWORD PTR _strKey$223836[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 689  : 
; 690  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 691  : 	//BuildingClassFlavorChanges
; 692  : 	{
; 693  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 694  : 		kUtility.Initialize2DArray(m_ppiBuildingClassFlavorChanges.first, "BuildingClasses", "Flavors");
; 695  : 		m_ppiBuildingClassFlavorChanges.second = kUtility.MaxRows("BuildingClasses");
; 696  : #else
; 697  : 		kUtility.Initialize2DArray(m_ppiBuildingClassFlavorChanges, "BuildingClasses", "Flavors");
; 698  : #endif
; 699  : 
; 700  : 		std::string strKey("Policy_BuildingClassFlavorChanges");
; 701  : 		Database::Results* pResults = kUtility.GetResults(strKey);
; 702  : 		if (pResults == NULL)
; 703  : 		{
; 704  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Flavors.ID as FlavorID, FlavorChange from Policy_BuildingClassFlavorChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Flavors on Flavors.Type = FlavorType where PolicyType = ?");
; 705  : 		}
; 706  : 
; 707  : 		pResults->Bind(1, szPolicyType);
; 708  : 
; 709  : 		while (pResults->Step())
; 710  : 		{
; 711  : 			const int BuildingClassID = pResults->GetInt(0);
; 712  : 			const int iFlavorID = pResults->GetInt(1);
; 713  : 			const int iFlavorChange = pResults->GetInt(2);
; 714  : 
; 715  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 716  : 			m_ppiBuildingClassFlavorChanges.first[BuildingClassID][iFlavorID] = iFlavorChange;
; 717  : #else
; 718  : 			m_ppiBuildingClassFlavorChanges[BuildingClassID][iFlavorID] = iFlavorChange;
; 719  : #endif
; 720  : 		}
; 721  : 	}
; 722  : #endif
; 723  : 
; 724  : 	//ImprovementYieldChanges
; 725  : 	{
; 726  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 727  : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges.first, "Improvements", "Yields");
; 728  : 		m_ppiImprovementYieldChanges.second = kUtility.MaxRows("Improvements");
; 729  : #else
; 730  : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges, "Improvements", "Yields");

	push	0
	push	OFFSET $SG223847
	lea	eax, DWORD PTR [esi+1056]
	push	OFFSET $SG223848
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 731  : #endif
; 732  : 
; 733  : 		std::string strKey("Policy_ImprovementYieldChanges");

	push	OFFSET $SG223850
	lea	ecx, DWORD PTR _strKey$223849[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 734  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$223849[esp+104]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 735  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN15@CacheResul@2

; 736  : 		{
; 737  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Policy_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where PolicyType = ?");

	push	OFFSET $SG223853
	lea	ecx, DWORD PTR _strKey$223849[esp+108]
	push	ecx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN15@CacheResul@2:

; 738  : 		}
; 739  : 
; 740  : 		pResults->Bind(1, szPolicyType);

	mov	edx, DWORD PTR _szPolicyType$[esp+100]
	push	1
	push	edx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 741  : 
; 742  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN13@CacheResul@2
$LL14@CacheResul@2:

; 743  : 		{
; 744  : 			const int ImprovementID = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 745  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _ImprovementID$223857[esp+104], eax
	call	edi

; 746  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _YieldID$223858[esp+108], eax
	call	edi

; 747  : 
; 748  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 749  : 			m_ppiImprovementYieldChanges.first[ImprovementID][YieldID] = yield;
; 750  : #else
; 751  : 			m_ppiImprovementYieldChanges[ImprovementID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+1056]
	mov	edx, DWORD PTR _ImprovementID$223857[esp+100]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$223858[esp+104]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL14@CacheResul@2
$LN13@CacheResul@2:

; 752  : #endif
; 753  : 		}
; 754  : 	}

	lea	ecx, DWORD PTR _strKey$223849[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 755  : 
; 756  : 	//ImprovementCultureChanges
; 757  : 	kUtility.PopulateArrayByValue(m_piImprovementCultureChange, "Improvements", "Policy_ImprovementCultureChanges", "ImprovementType", "PolicyType", szPolicyType, "CultureChange");

	mov	eax, DWORD PTR _szPolicyType$[esp+100]
	push	0
	push	0
	push	OFFSET $SG223860
	push	eax
	push	OFFSET $SG223861
	push	OFFSET $SG223862
	push	OFFSET $SG223863
	push	OFFSET $SG223864
	lea	ecx, DWORD PTR [esi+1008]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 758  : 
; 759  : 	//OrPreReqs
; 760  : 	{
; 761  : 		kUtility.InitializeArray(m_piPrereqOrPolicies, "Policies", (int)NO_POLICY);

	push	OFFSET $SG223871
	mov	ecx, ebp
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LN156@CacheResul@2
	mov	ebx, 1
$LN156@CacheResul@2:
	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+964], eax
	add	esp, 4
	xor	eax, eax
	test	ebx, ebx
	jbe	SHORT $LN51@CacheResul@2
	npad	4
$LL53@CacheResul@2:
	mov	ecx, DWORD PTR [esi+964]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, ebx
	jb	SHORT $LL53@CacheResul@2
$LN51@CacheResul@2:

; 762  : 
; 763  : 		std::string sqlKey = "m_piPrereqOrPolicies";

	push	OFFSET $SG223873
	lea	ecx, DWORD PTR _sqlKey$223872[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 764  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$223872[esp+104]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 765  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN12@CacheResul@2

; 766  : 		{
; 767  : 			const char* szSQL = "select Policies.ID from Policy_PrereqORPolicies inner join Policies on Policies.Type = PrereqPolicy where PolicyType = ?";
; 768  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG223877
	lea	eax, DWORD PTR _sqlKey$223872[esp+108]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN12@CacheResul@2:

; 769  : 		}
; 770  : 
; 771  : 		pResults->Bind(1, szPolicyType, false);

	mov	ecx, DWORD PTR _szPolicyType$[esp+100]
	push	0
	push	ecx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 772  : 
; 773  : 		int i = 0;
; 774  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN10@CacheResul@2

; 769  : 		}
; 770  : 
; 771  : 		pResults->Bind(1, szPolicyType, false);

	mov	DWORD PTR tv2691[esp+100], 0
$LL11@CacheResul@2:

; 775  : 		{
; 776  : 			m_piPrereqOrPolicies[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi
	mov	ecx, DWORD PTR tv2691[esp+100]
	mov	edx, DWORD PTR [esi+964]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	mov	DWORD PTR tv2691[esp+100], ecx
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL11@CacheResul@2
$LN10@CacheResul@2:

; 777  : 		}
; 778  : 
; 779  : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 780  : 	}

	lea	ecx, DWORD PTR _sqlKey$223872[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 781  : 
; 782  : 	//AndPreReqs
; 783  : 	{
; 784  : 		kUtility.InitializeArray(m_piPrereqAndPolicies, "Policies", (int)NO_POLICY);

	push	OFFSET $SG223883
	mov	ecx, ebp
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LN159@CacheResul@2
	mov	ebx, 1
$LN159@CacheResul@2:
	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+968], eax
	add	esp, 4
	xor	eax, eax
	test	ebx, ebx
	jbe	SHORT $LN61@CacheResul@2
$LL63@CacheResul@2:
	mov	ecx, DWORD PTR [esi+968]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, ebx
	jb	SHORT $LL63@CacheResul@2
$LN61@CacheResul@2:

; 785  : 		std::string sqlKey = "m_piPrereqAndPolicies";

	push	OFFSET $SG223885
	lea	ecx, DWORD PTR _sqlKey$223884[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 786  : 
; 787  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$223884[esp+104]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 5
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 788  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN9@CacheResul@2

; 789  : 		{
; 790  : 			const char* szSQL = "select Policies.ID from Policy_PrereqPolicies inner join Policies on Policies.Type = PrereqPolicy where PolicyType = ?";
; 791  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG223889
	lea	eax, DWORD PTR _sqlKey$223884[esp+108]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN9@CacheResul@2:

; 792  : 		}
; 793  : 
; 794  : 		pResults->Bind(1, szPolicyType, false);

	mov	ecx, DWORD PTR _szPolicyType$[esp+100]
	push	0
	push	ecx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 795  : 
; 796  : 		int i = 0;
; 797  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN7@CacheResul@2

; 792  : 		}
; 793  : 
; 794  : 		pResults->Bind(1, szPolicyType, false);

	mov	DWORD PTR tv2710[esp+100], 0
$LL8@CacheResul@2:

; 798  : 		{
; 799  : 			m_piPrereqAndPolicies[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi
	mov	ecx, DWORD PTR tv2710[esp+100]
	mov	edx, DWORD PTR [esi+968]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	mov	DWORD PTR tv2710[esp+100], ecx
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL8@CacheResul@2
$LN7@CacheResul@2:

; 800  : 		}
; 801  : 
; 802  : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 803  : 	}

	lea	ecx, DWORD PTR _sqlKey$223884[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 804  : 
; 805  : 	//Policy_Disables
; 806  : 	{
; 807  : 		kUtility.InitializeArray(m_piPolicyDisables, "Policies", (int)NO_POLICY);

	push	OFFSET $SG223895
	mov	ecx, ebp
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LN161@CacheResul@2
	mov	ebx, 1
$LN161@CacheResul@2:
	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+972], eax
	add	esp, 4
	xor	eax, eax
	test	ebx, ebx
	jbe	SHORT $LN71@CacheResul@2
$LL73@CacheResul@2:
	mov	ecx, DWORD PTR [esi+972]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, ebx
	jb	SHORT $LL73@CacheResul@2
$LN71@CacheResul@2:

; 808  : 
; 809  : 		std::string sqlKey = "m_piPolicyDisables";

	push	OFFSET $SG223897
	lea	ecx, DWORD PTR _sqlKey$223896[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 810  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$223896[esp+104]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 6
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 811  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN6@CacheResul@2

; 812  : 		{
; 813  : 			const char* szSQL = "select Policies.ID from Policy_Disables inner join Policies on Policies.Type = PolicyDisable where PolicyType = ?";
; 814  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG223901
	lea	eax, DWORD PTR _sqlKey$223896[esp+108]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN6@CacheResul@2:

; 815  : 		}
; 816  : 
; 817  : 		pResults->Bind(1, szPolicyType, false);

	mov	ecx, DWORD PTR _szPolicyType$[esp+100]
	push	0
	push	ecx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 818  : 
; 819  : 		int i = 0;
; 820  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@CacheResul@2

; 815  : 		}
; 816  : 
; 817  : 		pResults->Bind(1, szPolicyType, false);

	mov	DWORD PTR tv2729[esp+100], 0
$LL5@CacheResul@2:

; 821  : 		{
; 822  : 			m_piPolicyDisables[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi
	mov	ecx, DWORD PTR tv2729[esp+100]
	mov	edx, DWORD PTR [esi+972]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	mov	DWORD PTR tv2729[esp+100], ecx
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL5@CacheResul@2
$LN4@CacheResul@2:

; 823  : 		}
; 824  : 
; 825  : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 826  : 	}

	lea	ecx, DWORD PTR _sqlKey$223896[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 827  : 
; 828  : 	//UnitCombatFreePromotions
; 829  : 	{
; 830  : 		m_FreePromotionUnitCombats.clear();

	mov	eax, DWORD PTR [esi+956]
	mov	ecx, DWORD PTR [eax+4]
	add	esi, 952				; 000003b8H
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]

; 831  : 		std::string sqlKey = "m_FreePromotionsUnitCombats";

	push	OFFSET $SG223907
	lea	ecx, DWORD PTR _sqlKey$223906[esp+108]
	mov	DWORD PTR [eax+8], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 832  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$223906[esp+104]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+116], 7
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 833  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN3@CacheResul@2

; 834  : 		{
; 835  : 			const char* szSQL = "select UnitPromotions.ID, UnitCombatInfos.ID  from Policy_FreePromotionUnitCombats, UnitPromotions, UnitCombatInfos where PolicyType = ? and PromotionType = UnitPromotions.ID and UnitCombatType = UnitCombatInfos.ID";
; 836  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG223911
	lea	eax, DWORD PTR _sqlKey$223906[esp+108]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN3@CacheResul@2:

; 837  : 		}
; 838  : 
; 839  : 		pResults->Bind(1, szPolicyType, false);

	mov	ecx, DWORD PTR _szPolicyType$[esp+100]
	push	0
	push	ecx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 840  : 
; 841  : 		while(pResults->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@CacheResul@2
	npad	3
$LL2@CacheResul@2:

; 842  : 		{
; 843  : 			const int UnitPromotionID = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 844  : 			const int UnitCombatInfoID = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	ebp, eax
	call	edi

; 845  : 
; 846  : 			m_FreePromotionUnitCombats.insert(std::pair<int, int>(UnitPromotionID, UnitCombatInfoID));

	lea	edx, DWORD PTR $T246741[esp+104]
	mov	DWORD PTR $T246741[esp+108], eax
	push	edx
	lea	eax, DWORD PTR $T246917[esp+108]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T246741[esp+112], ebp
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul@2
$LN1@CacheResul@2:

; 847  : 		}
; 848  : 
; 849  : 		//Trim capacity
; 850  : 		std::multimap<int, int>(m_FreePromotionUnitCombats).swap(m_FreePromotionUnitCombats);

	push	esi
	lea	ecx, DWORD PTR $T246744[esp+108]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	push	esi
	lea	ecx, DWORD PTR $T246744[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 8
	call	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
	mov	eax, DWORD PTR $T246744[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T247063[esp+108]
	push	ecx
	lea	ecx, DWORD PTR $T246744[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 7
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	edx, DWORD PTR $T246744[esp+108]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	add	esp, 4

; 851  : 
; 852  : 		pResults->Reset();

	mov	ecx, ebx
	mov	DWORD PTR $T246744[esp+108], eax
	mov	DWORD PTR $T246744[esp+112], eax
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 853  : 	}

	lea	ecx, DWORD PTR _sqlKey$223906[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 854  : 
; 855  : 	return true;
; 856  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR $T246740[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$223823[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _strKey$223836[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$223849[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _sqlKey$223872[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _sqlKey$223884[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _sqlKey$223896[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _sqlKey$223906[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR $T246744[ebp]
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPolicyEntry::CacheResults
PUBLIC	?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPolicyEntry@@@@YAXAAPAVCvPolicyEntry@@@Z ; SAFE_DELETE<CvPolicyEntry>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvPolicyEntry@@@@YAXAAPAVCvPolicyEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPolicyEntry@@@@YAXAAPAVCvPolicyEntry@@@Z PROC ; SAFE_DELETE<CvPolicyEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@3
	mov	ecx, esi
	call	??1CvPolicyEntry@@QAE@XZ		; CvPolicyEntry::~CvPolicyEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@3:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPolicyEntry@@@@YAXAAPAVCvPolicyEntry@@@Z ENDP ; SAFE_DELETE<CvPolicyEntry>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ	; CvPolicyXMLEntries::DeletePoliciesArray
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
;	COMDAT ?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ PROC	; CvPolicyXMLEntries::DeletePoliciesArray, COMDAT
; _this$ = ecx

; 2499 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 2500 : 	for(std::vector<CvPolicyEntry*>::iterator it = m_paPolicyEntries.begin(); it != m_paPolicyEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeletePoli@2
	npad	3
$LL14@DeletePoli@2:

; 2501 : 	{
; 2502 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeletePoli@2
	mov	ecx, edi
	call	??1CvPolicyEntry@@QAE@XZ		; CvPolicyEntry::~CvPolicyEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeletePoli@2:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeletePoli@2
$LN1@DeletePoli@2:

; 2503 : 	}
; 2504 : 
; 2505 : 	m_paPolicyEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeletePoli@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeletePoli@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeletePoli@2:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeletePoli@2:
	pop	edi
	pop	esi
	pop	ebx

; 2506 : }

	ret	0
?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ ENDP	; CvPolicyXMLEntries::DeletePoliciesArray
_TEXT	ENDS
PUBLIC	?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetDominantPolicyBranchForTitle
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ$0
__ehfuncinfo$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
$T247802 = -32						; size = 4
_viPolicyBranchCounts$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetDominantPolicyBranchForTitle, COMDAT
; _this$ = ecx

; 4517 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	edi
	mov	edi, ecx

; 4518 : 	// Everything we've picked recently matches
; 4519 : 	if(GetBranchPicked1() == GetBranchPicked2() &&
; 4520 : 	        GetBranchPicked1() == GetBranchPicked3() &&
; 4521 : 	        GetBranchPicked2() == GetBranchPicked3())

	mov	eax, DWORD PTR [edi+68]
	mov	edx, DWORD PTR [edi+72]
	cmp	eax, edx
	jne	SHORT $LN20@GetDominan
	mov	ecx, DWORD PTR [edi+76]
	cmp	eax, ecx
	jne	SHORT $LN20@GetDominan
	cmp	edx, ecx

; 4522 : 	{
; 4523 : 		return GetBranchPicked1();

	je	$LN21@GetDominan
$LN20@GetDominan:
	push	ebx
	push	ebp

; 4524 : 	}
; 4525 : 
; 4526 : 	// Haven't picked stuff from a branch three times in a row, so we have to see which branch we have the most of
; 4527 : 
; 4528 : 	PolicyBranchTypes eTempBranch;
; 4529 : 
; 4530 : 	std::vector<int> viPolicyBranchCounts;

	xor	ebp, ebp
	xor	ebx, ebx
	xor	ecx, ecx
	push	esi
	mov	DWORD PTR _viPolicyBranchCounts$[esp+52], ebx
	mov	DWORD PTR _viPolicyBranchCounts$[esp+56], ecx
	mov	DWORD PTR _viPolicyBranchCounts$[esp+60], ebp

; 4531 : 
; 4532 : 	// Init vector
; 4533 : #ifdef AUI_WARNING_FIXES
; 4534 : 	uint iBranchLoop;
; 4535 : #else
; 4536 : 	int iBranchLoop;
; 4537 : #endif
; 4538 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+56], ebp
	test	edx, -4					; fffffffcH
	jle	SHORT $LN17@GetDominan

; 4539 : 	{
; 4540 : 		viPolicyBranchCounts.push_back(0);

	mov	DWORD PTR $T247802[esp+48], ebp
$LL19@GetDominan:
	cmp	ebx, ebp
	jne	SHORT $LN87@GetDominan
	xor	eax, eax
	jmp	SHORT $LN88@GetDominan
$LN87@GetDominan:
	mov	eax, DWORD PTR _viPolicyBranchCounts$[esp+60]
	sub	eax, ebx
	sar	eax, 2
$LN88@GetDominan:
	mov	edx, ecx
	sub	edx, ebx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN80@GetDominan
	mov	DWORD PTR [ecx], ebp
	add	ecx, 4
	mov	DWORD PTR _viPolicyBranchCounts$[esp+56], ecx
	jmp	SHORT $LN18@GetDominan
$LN80@GetDominan:
	lea	eax, DWORD PTR $T247802[esp+48]
	push	eax
	push	1
	push	ecx
	lea	ecx, DWORD PTR _viPolicyBranchCounts$[esp+60]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ecx, DWORD PTR _viPolicyBranchCounts$[esp+56]
	mov	ebx, DWORD PTR _viPolicyBranchCounts$[esp+52]
$LN18@GetDominan:
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	esi
	sar	edx, 2
	cmp	esi, edx
	jl	SHORT $LL19@GetDominan
$LN17@GetDominan:

; 4541 : 	}
; 4542 : 
; 4543 : 	// Get count of each branch
; 4544 : #ifdef AUI_WARNING_FIXES
; 4545 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 4546 : #else
; 4547 : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	test	eax, eax
	jle	$LN14@GetDominan
	npad	3
$LL16@GetDominan:

; 4548 : #endif
; 4549 : 	{
; 4550 : 		const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 4551 : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 4552 : 		if(pkPolicyInfo)

	test	eax, eax
	je	SHORT $LN15@GetDominan

; 4553 : 		{
; 4554 : 			if(HasPolicy(eLoopPolicy))

	mov	ecx, DWORD PTR [edi+12]
	cmp	BYTE PTR [ecx+ebp], 0
	je	SHORT $LN15@GetDominan

; 4555 : 			{
; 4556 : 				eTempBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	eax, DWORD PTR [eax+820]

; 4557 : 
; 4558 : 				// Are we a free branch policy?
; 4559 : 				if(eTempBranch == NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	jne	SHORT $LN178@GetDominan

; 4560 : 				{
; 4561 : 					for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	xor	esi, esi
	test	edx, -4					; fffffffcH
	jle	SHORT $LN15@GetDominan
	npad	7
$LL10@GetDominan:

; 4562 : 					{
; 4563 : 						const PolicyBranchTypes eLoopBranch = static_cast<PolicyBranchTypes>(iBranchLoop);
; 4564 : 						CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eLoopBranch);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo

; 4565 : 						if(pkPolicyBranchInfo)

	test	eax, eax
	je	SHORT $LN9@GetDominan

; 4566 : 						{
; 4567 : 							// Yes, it's a freebie
; 4568 : 							if(pkPolicyBranchInfo->GetFreePolicy() == eLoopPolicy)

	cmp	DWORD PTR [eax+264], ebp
	je	SHORT $LN172@GetDominan
$LN9@GetDominan:

; 4560 : 				{
; 4561 : 					for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR [eax+20]
	add	eax, 16					; 00000010H
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL10@GetDominan

; 4566 : 						{
; 4567 : 							// Yes, it's a freebie
; 4568 : 							if(pkPolicyBranchInfo->GetFreePolicy() == eLoopPolicy)

	jmp	SHORT $LN15@GetDominan
$LN172@GetDominan:

; 4569 : 							{
; 4570 : 								eTempBranch = eLoopBranch;

	mov	eax, esi

; 4571 : 								break;
; 4572 : 							}
; 4573 : 						}
; 4574 : 					}
; 4575 : 				}
; 4576 : 
; 4577 : 				if(eTempBranch != NO_POLICY_BRANCH_TYPE)

	cmp	esi, -1
	je	SHORT $LN15@GetDominan
$LN178@GetDominan:

; 4578 : 				{
; 4579 : 					viPolicyBranchCounts[eTempBranch]++;

	inc	DWORD PTR [ebx+eax*4]
$LN15@GetDominan:

; 4541 : 	}
; 4542 : 
; 4543 : 	// Get count of each branch
; 4544 : #ifdef AUI_WARNING_FIXES
; 4545 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 4546 : #else
; 4547 : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	ebp, eax
	jl	$LL16@GetDominan
$LN14@GetDominan:

; 4580 : 				}
; 4581 : 			}
; 4582 : 		}
; 4583 : 	}
; 4584 : 
; 4585 : 	// Now that we have our vector, see which has the most
; 4586 : 	PolicyBranchTypes eBestBranch = NO_POLICY_BRANCH_TYPE;
; 4587 : 	int iBestValue = 0;
; 4588 : 
; 4589 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	edi, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [edi+24]
	sub	ecx, DWORD PTR [edi+20]
	or	esi, -1
	xor	edx, edx
	xor	eax, eax
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN2@GetDominan
	mov	ebp, DWORD PTR [edi+24]
	sub	ebp, DWORD PTR [edi+20]
	sar	ebp, 2
	npad	5
$LL4@GetDominan:

; 4590 : 	{
; 4591 : 		if(viPolicyBranchCounts[iBranchLoop] > iBestValue)

	mov	ecx, DWORD PTR [ebx+eax*4]
	cmp	ecx, edx
	jle	SHORT $LN3@GetDominan

; 4592 : 		{
; 4593 : 			eBestBranch = (PolicyBranchTypes) iBranchLoop;

	mov	esi, eax

; 4594 : 			iBestValue = viPolicyBranchCounts[iBranchLoop];

	mov	edx, ecx
$LN3@GetDominan:
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL4@GetDominan
$LN2@GetDominan:

; 4595 : 		}
; 4596 : 	}
; 4597 : 
; 4598 : 	return eBestBranch;

	test	ebx, ebx
	je	SHORT $LN165@GetDominan
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN165@GetDominan:
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
$LN21@GetDominan:

; 4599 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ$0:
	lea	ecx, DWORD PTR _viPolicyBranchCounts$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetDominantPolicyBranchForTitle
PUBLIC	?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z
_TEXT	SEGMENT
$T248414 = -4						; size = 1
__Cat$248418 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$248418[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T248414[esp+12], 0
	mov	eax, DWORD PTR $T248414[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z
_TEXT	SEGMENT
$T248562 = -4						; size = 1
__Cat$248566 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$248566[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T248562[esp+12], 0
	mov	eax, DWORD PTR $T248562[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back
_TEXT	ENDS
PUBLIC	??1CvPolicyXMLEntries@@QAE@XZ			; CvPolicyXMLEntries::~CvPolicyXMLEntries
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvPolicyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvPolicyXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvPolicyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPolicyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPolicyXMLEntries@@QAE@XZ PROC			; CvPolicyXMLEntries::~CvPolicyXMLEntries, COMDAT
; _this$ = ecx

; 2476 : {

	push	-1
	push	__ehhandler$??1CvPolicyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR __$EHRec$[esp+32], 1

; 2477 : 	DeletePoliciesArray();

	call	?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ ; CvPolicyXMLEntries::DeletePoliciesArray

; 2478 : 	DeletePolicyBranchesArray();

	mov	ecx, esi
	call	?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ ; CvPolicyXMLEntries::DeletePolicyBranchesArray

; 2479 : }

	mov	eax, DWORD PTR [esi+20]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@CvPolicyXM
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@CvPolicyXM:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN17@CvPolicyXM
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@CvPolicyXM:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
__ehhandler$??1CvPolicyXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPolicyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPolicyXMLEntries@@QAE@XZ ENDP			; CvPolicyXMLEntries::~CvPolicyXMLEntries
PUBLIC	?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ ; CvPlayerPolicies::GetFreeBuildingsOnConquest
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$0
__ehfuncinfo$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
_TEXT	SEGMENT
$T248728 = -20						; size = 4
_eFreeBuilding$225732 = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ PROC ; CvPlayerPolicies::GetFreeBuildingsOnConquest, COMDAT
; _this$ = ecx

; 3486 : {

	push	-1
	push	__ehhandler$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR $T248728[esp+28], ebx

; 3487 : 	std::vector<BuildingTypes> freeBuildings;

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+24]
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	mov	DWORD PTR [ebp+12], ebx

; 3504 : 			}
; 3505 : 		}
; 3506 : 	}
; 3507 : 	return freeBuildings;

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	sar	ecx, 2
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR $T248728[esp+40], 1
	call	?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve
	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	xor	edi, edi
	test	edx, -4					; fffffffcH
	jle	SHORT $LN69@GetFreeBui
$LL5@GetFreeBui:

; 3488 : 	freeBuildings.reserve(m_pPolicies->GetNumPolicies());
; 3489 : 
; 3490 : #ifdef AUI_WARNING_FIXES
; 3491 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3492 : #else
; 3493 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3494 : #endif
; 3495 : 	{
; 3496 : 		// Do we have this policy?
; 3497 : 		if (m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	ecx, DWORD PTR [esi+12]
	cmp	BYTE PTR [edi+ecx], bl
	je	SHORT $LN4@GetFreeBui
	mov	edx, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [edx+edi*4]
	cmp	ecx, -1
	je	SHORT $LN68@GetFreeBui
	mov	edx, DWORD PTR [esi+28]
	cmp	BYTE PTR [ecx+edx], bl
	jne	SHORT $LN4@GetFreeBui
$LN68@GetFreeBui:

; 3498 : 		{
; 3499 : 			CvPolicyEntry *pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edi*4]

; 3500 : 			BuildingTypes eFreeBuilding = pPolicy->GetFreeBuildingOnConquest();

	mov	eax, DWORD PTR [eax+948]
	mov	DWORD PTR _eFreeBuilding$225732[esp+36], eax

; 3501 : 			if (eFreeBuilding)

	cmp	eax, ebx
	je	SHORT $LN4@GetFreeBui

; 3502 : 			{
; 3503 : 				freeBuildings.push_back(eFreeBuilding);

	lea	ecx, DWORD PTR _eFreeBuilding$225732[esp+36]
	push	ecx
	mov	ecx, ebp
	call	?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back
$LN4@GetFreeBui:
	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	inc	edi
	sar	edx, 2
	cmp	edi, edx
	jl	SHORT $LL5@GetFreeBui
$LN69@GetFreeBui:

; 3508 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$0:
	mov	eax, DWORD PTR $T248728[ebp]
	and	eax, 1
	je	$LN9@GetFreeBui
	and	DWORD PTR $T248728[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
$LN9@GetFreeBui:
	ret	0
__ehhandler$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ ENDP ; CvPlayerPolicies::GetFreeBuildingsOnConquest
PUBLIC	?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetAvailableTenets
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$0
__ehfuncinfo$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
_TEXT	SEGMENT
$T248924 = -24						; size = 4
_this$ = -20						; size = 4
_eTenet$226604 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eBranch$ = 12						; size = 4
_iLevel$ = 16						; size = 4
?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z PROC ; CvPlayerPolicies::GetAvailableTenets, COMDAT
; _this$ = ecx

; 4724 : {

	push	-1
	push	__ehhandler$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T248924[esp+40], edi

; 4725 : 	std::vector<PolicyTypes> availableTenets;

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	DWORD PTR _this$[esp+40], ecx
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+8], edi
	mov	DWORD PTR [ebp+12], edi

; 4745 : 		}
; 4746 : 	}
; 4747 : 
; 4748 : 	return availableTenets;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+48], edi
	mov	DWORD PTR $T248924[esp+40], 1
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies
	mov	ebx, eax
	mov	esi, DWORD PTR [ebx+8]
	sub	esi, DWORD PTR [ebx+4]
	mov	ecx, ebp
	sar	esi, 2
	push	esi
	call	?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve
	test	esi, esi
	jle	SHORT $LN62@GetAvailab
$LL63@GetAvailab:

; 4726 : 
; 4727 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();
; 4728 : #ifdef AUI_WARNING_FIXES
; 4729 : 	const uint iNumPolicies = pkPolicies->GetNumPolicies();
; 4730 : 
; 4731 : 	availableTenets.reserve(iNumPolicies);
; 4732 : 	for (uint iI = 0; iI < iNumPolicies; iI++)
; 4733 : #else
; 4734 : 	const int iNumPolicies = pkPolicies->GetNumPolicies();
; 4735 : 
; 4736 : 	availableTenets.reserve(iNumPolicies);
; 4737 : 	for(int iI = 0; iI < iNumPolicies; iI++)
; 4738 : #endif
; 4739 : 	{
; 4740 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));
; 4741 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _eTenet$226604[esp+40], edi

; 4742 : 		if (pEntry && pEntry->GetPolicyBranchType() == eBranch && pEntry->GetLevel() == iLevel && !HasPolicy(eTenet))

	test	eax, eax
	je	SHORT $LN3@GetAvailab
	mov	ecx, DWORD PTR _eBranch$[esp+36]
	cmp	DWORD PTR [eax+820], ecx
	jne	SHORT $LN3@GetAvailab
	mov	edx, DWORD PTR _iLevel$[esp+36]
	cmp	DWORD PTR [eax+276], edx
	jne	SHORT $LN3@GetAvailab
	mov	eax, DWORD PTR _this$[esp+40]
	mov	ecx, DWORD PTR [eax+12]
	cmp	BYTE PTR [edi+ecx], 0
	jne	SHORT $LN3@GetAvailab

; 4743 : 		{
; 4744 : 			availableTenets.push_back(eTenet);

	lea	edx, DWORD PTR _eTenet$226604[esp+40]
	push	edx
	mov	ecx, ebp
	call	?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back
$LN3@GetAvailab:
	inc	edi
	cmp	edi, esi
	jl	SHORT $LL63@GetAvailab
$LN62@GetAvailab:

; 4749 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$0:
	mov	eax, DWORD PTR $T248924[ebp]
	and	eax, 1
	je	$LN8@GetAvailab
	and	DWORD PTR $T248924[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
$LN8@GetAvailab:
	ret	0
__ehhandler$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z ENDP ; CvPlayerPolicies::GetAvailableTenets
END
