; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDealAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG221843 DB	00H
	ORG $+7
$SG222006 DB	'Deal AI: ASYNC RAND call to determine if AI will give in'
	DB	'to a human demand.', 00H
	ORG $+1
$SG222190 DB	'GAMEOPTION_AI_GIMP_ALWAYS_WHITE_PEACE', 00H
	ORG $+2
$SG222596 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG222613 DB	'AIGRANDSTRATEGY_CULTURE', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	??0CvDealAI@@QAE@XZ				; CvDealAI::CvDealAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ??0CvDealAI@@QAE@XZ
_TEXT	SEGMENT
??0CvDealAI@@QAE@XZ PROC				; CvDealAI::CvDealAI, COMDAT
; _this$ = ecx

; 26   : {

	mov	eax, ecx

; 27   : #ifdef AUI_WARNING_FIXES
; 28   : 	Init(NULL);
; 29   : #endif
; 30   : }

	ret	0
??0CvDealAI@@QAE@XZ ENDP				; CvDealAI::CvDealAI
_TEXT	ENDS
PUBLIC	?Uninit@CvDealAI@@QAEXXZ			; CvDealAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvDealAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvDealAI@@QAEXXZ PROC				; CvDealAI::Uninit, COMDAT
; _this$ = ecx

; 49   : }

	ret	0
?Uninit@CvDealAI@@QAEXXZ ENDP				; CvDealAI::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvDealAI@@QAEXXZ				; CvDealAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvDealAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvDealAI@@QAEXXZ PROC				; CvDealAI::Reset, COMDAT
; _this$ = ecx

; 54   : 	m_iCachedValueOfPeaceWithHuman = 0;

	mov	DWORD PTR [ecx+4], 0

; 55   : }

	ret	0
?Reset@CvDealAI@@QAEXXZ ENDP				; CvDealAI::Reset
_TEXT	ENDS
PUBLIC	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ		; CvDealAI::GetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ PROC		; CvDealAI::GetPlayer, COMDAT
; _this$ = ecx

; 76   : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx]

; 77   : }

	ret	0
?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ ENDP		; CvDealAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ	; CvDealAI::GetDealPercentLeewayWithAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ
_TEXT	SEGMENT
?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ PROC	; CvDealAI::GetDealPercentLeewayWithAI, COMDAT
; _this$ = ecx

; 88   : 	return 25;

	mov	eax, 25					; 00000019H

; 89   : }

	ret	0
?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ ENDP	; CvDealAI::GetDealPercentLeewayWithAI
_TEXT	ENDS
PUBLIC	?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ	; CvDealAI::GetDealPercentLeewayWithHuman
; Function compile flags: /Ogtpy
;	COMDAT ?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ
_TEXT	SEGMENT
?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ PROC	; CvDealAI::GetDealPercentLeewayWithHuman, COMDAT
; _this$ = ecx

; 94   : 	return 10;

	mov	eax, 10					; 0000000aH

; 95   : }

	ret	0
?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ ENDP	; CvDealAI::GetDealPercentLeewayWithHuman
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z ; CvDealAI::GetPeaceTreatyValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z PROC ; CvDealAI::GetPeaceTreatyValue, COMDAT
; _this$ = ecx

; 1943 : #endif
; 1944 : 	return 0;

	xor	eax, eax

; 1945 : 
; 1946 : 	// DEPRECATED
; 1947 : 
; 1948 : 	//int iItemValue = 500;
; 1949 : 
; 1950 : 	//// What I think me giving up peace is worth to them (if we're winning "our peace" is more valuable)
; 1951 : 	//if (bFromMe)
; 1952 : 	//{
; 1953 : 	//	if (GetPlayer()->GetDiplomacyAI()->IsWantsPeaceWithPlayer(eOtherPlayer))
; 1954 : 	//	{
; 1955 : 	//		iItemValue = 200;
; 1956 : 	//	}
; 1957 : 	//}
; 1958 : 	//// What I think them agreeing to peace with me is worth (if they're winning "their peace" is more valuable)
; 1959 : 	//else
; 1960 : 	//{
; 1961 : 	//	if (GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->IsWantsPeaceWithPlayer(GetPlayer()->GetID()))
; 1962 : 	//	{
; 1963 : 	//		iItemValue = 200;
; 1964 : 	//	}
; 1965 : 	//}
; 1966 : 
; 1967 : 	//// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1968 : 	//if (bUseEvenValue)
; 1969 : 	//{
; 1970 : 	//	iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetPeaceTreatyValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);
; 1971 : 
; 1972 : 	//	iItemValue /= 2;
; 1973 : 	//}
; 1974 : 
; 1975 : 	//return iItemValue;
; 1976 : }

	ret	4
?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvDealAI::GetPeaceTreatyValue
_TEXT	ENDS
PUBLIC	?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ; CvDealAI::GetCachedValueOfPeaceWithHuman
; Function compile flags: /Ogtpy
;	COMDAT ?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ
_TEXT	SEGMENT
?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ PROC	; CvDealAI::GetCachedValueOfPeaceWithHuman, COMDAT
; _this$ = ecx

; 3616 : 	return m_iCachedValueOfPeaceWithHuman;		// NOT SERIALIZED

	mov	eax, DWORD PTR [ecx+4]

; 3617 : }

	ret	0
?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ENDP	; CvDealAI::GetCachedValueOfPeaceWithHuman
_TEXT	ENDS
PUBLIC	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman
; Function compile flags: /Ogtpy
;	COMDAT ?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z PROC	; CvDealAI::SetCachedValueOfPeaceWithHuman, COMDAT
; _this$ = ecx

; 3622 : 	m_iCachedValueOfPeaceWithHuman = iValue;		// NOT SERIALIZED

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 3623 : }

	ret	4
?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ENDP	; CvDealAI::SetCachedValueOfPeaceWithHuman
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?begin@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ PROC ; BaseVector<CvLeagueAI::VoteCommitment,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ ENDP ; BaseVector<CvLeagueAI::VoteCommitment,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ PROC ; BaseVector<CvLeagueAI::VoteCommitment,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 198  :     };

	ret	0
?end@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAEPAUVoteCommitment@CvLeagueAI@@XZ ENDP ; BaseVector<CvLeagueAI::VoteCommitment,0>::end
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z PROC	; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ENDP	; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z PROC ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z ENDP ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvDeal1@@@std@@QBEPAVICvDeal1@@XZ ; std::auto_ptr<ICvDeal1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvDeal1@@@std@@QBEPAVICvDeal1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvDeal1@@@std@@QBEPAVICvDeal1@@XZ PROC ; std::auto_ptr<ICvDeal1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvDeal1@@@std@@QBEPAVICvDeal1@@XZ ENDP ; std::auto_ptr<ICvDeal1>::get
_TEXT	ENDS
PUBLIC	??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator!=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator!=, COMDAT
; _this$ = ecx

; 353  : 			return m_uiCurrPos != rhs.m_uiCurrPos;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _rhs$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	al, cl

; 354  : 		};

	ret	4
??9?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBE_NABV01@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator!=
_TEXT	ENDS
PUBLIC	?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::size, COMDAT
; _this$ = ecx

; 522  : 		return m_uiSize;

	mov	eax, DWORD PTR [ecx+20]

; 523  : 	};

	ret	0
?size@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QBEIXZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::size
_TEXT	ENDS
PUBLIC	?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ PROC ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator, COMDAT
; _this$ = ecx

; 711  : 	T_ALLOCATOR& get_allocator(){ return m_kAllocator; };

	mov	eax, ecx
	ret	0
?get_allocator@?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@QAEAAV?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@XZ ENDP ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::get_allocator
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ PROC ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ENDP ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEABUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEABUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEABUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEABUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEIXZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@XZ ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@XZ ; CvWeightedVector<int,1,0>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@XZ PROC ; CvWeightedVector<int,1,0>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@XZ ENDP ; CvWeightedVector<int,1,0>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::operator[]
_TEXT	ENDS
PUBLIC	??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>, COMDAT
; _this$ = ecx

; 299  : 		~base_iterator(){};

	ret	0
??1?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::~base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
_TEXT	ENDS
PUBLIC	??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\lekmod files\lekmod dll versions\v29\le'
	DB	'kmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 1
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAE@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@ABU01@@Z ; CvWeightedVector<int,1,0>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,1,0>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$00$0A@@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,1,0>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??_GVoteCommitment@CvLeagueAI@@QAEPAXI@Z	; CvLeagueAI::VoteCommitment::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??1VoteCommitment@CvLeagueAI@@QAE@XZ:PROC	; CvLeagueAI::VoteCommitment::~VoteCommitment
; Function compile flags: /Ogtpy
;	COMDAT ??_GVoteCommitment@CvLeagueAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GVoteCommitment@CvLeagueAI@@QAEPAXI@Z PROC		; CvLeagueAI::VoteCommitment::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1VoteCommitment@CvLeagueAI@@QAE@XZ	; CvLeagueAI::VoteCommitment::~VoteCommitment
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GVoteCommitment@CvLeagueAI@@QAEPAXI@Z ENDP		; CvLeagueAI::VoteCommitment::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail::base_iterator_tail
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z
_TEXT	SEGMENT
_pFastList$ = 8						; size = 4
??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail::base_iterator_tail, COMDAT
; _this$ = ecx

; 278  : 		base_iterator_tail( TYPE* pFastList ) : m_pFastList( pFastList ) {};

	mov	eax, ecx
	mov	ecx, DWORD PTR _pFastList$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0base_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@PAV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail::base_iterator_tail
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::Destroy
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$min@W4PeaceTreatyTypes@@@std@@YAABW4PeaceTreatyTypes@@ABW41@0@Z ; std::min<enum PeaceTreatyTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@W4PeaceTreatyTypes@@@std@@YAABW4PeaceTreatyTypes@@ABW41@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@W4PeaceTreatyTypes@@@std@@YAABW4PeaceTreatyTypes@@ABW41@0@Z PROC ; std::min<enum PeaceTreatyTypes>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min@2
	mov	eax, ecx
$LN4@min@2:

; 3400 : 	}

	ret	0
??$min@W4PeaceTreatyTypes@@@std@@YAABW4PeaceTreatyTypes@@ABW41@0@Z ENDP ; std::min<enum PeaceTreatyTypes>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ; std::auto_ptr_ref<ICvDeal1>::auto_ptr_ref<ICvDeal1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z PROC ; std::auto_ptr_ref<ICvDeal1>::auto_ptr_ref<ICvDeal1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ENDP ; std::auto_ptr_ref<ICvDeal1>::auto_ptr_ref<ICvDeal1>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$00$0A@@@QBE_NABU01@@Z ; CvWeightedVector<int,1,0>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$00$0A@@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$00$0A@@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,1,0>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$00$0A@@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,1,0>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::pair<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>::pair<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::pair<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>::pair<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::pair<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>::pair<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ; std::_Dist_type<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::swap<CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::swap<CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::swap<CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Iter_random<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ	; NullMultiListNodePolicy::LIST_GetNext
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ
_TEXT	SEGMENT
?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ PROC	; NullMultiListNodePolicy::LIST_GetNext, COMDAT
; _this$ = ecx

; 62   : 	unsigned int LIST_GetNext() const{ return node.uiNext; };

	mov	eax, DWORD PTR [ecx]
	ret	0
?LIST_GetNext@NullMultiListNodePolicy@@QBEIXZ ENDP	; NullMultiListNodePolicy::LIST_GetNext
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getDEFAULT_FLAVOR_VALUE@CvGlobals@@QAEHXZ	; CvGlobals::getDEFAULT_FLAVOR_VALUE
; Function compile flags: /Ogtpy
;	COMDAT ?getDEFAULT_FLAVOR_VALUE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getDEFAULT_FLAVOR_VALUE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getDEFAULT_FLAVOR_VALUE, COMDAT
; _this$ = ecx

; 929  : 		return m_iDEFAULT_FLAVOR_VALUE;

	mov	eax, DWORD PTR [ecx+1864]

; 930  : 	}

	ret	0
?getDEFAULT_FLAVOR_VALUE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getDEFAULT_FLAVOR_VALUE
_TEXT	ENDS
PUBLIC	?getARMISTICE_GPT_DIVISOR@CvGlobals@@QAEHXZ	; CvGlobals::getARMISTICE_GPT_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getARMISTICE_GPT_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getARMISTICE_GPT_DIVISOR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getARMISTICE_GPT_DIVISOR, COMDAT
; _this$ = ecx

; 4101 : 		return m_iARMISTICE_GPT_DIVISOR;

	mov	eax, DWORD PTR [ecx+5028]

; 4102 : 	}

	ret	0
?getARMISTICE_GPT_DIVISOR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getARMISTICE_GPT_DIVISOR
_TEXT	ENDS
PUBLIC	?getEACH_GOLD_VALUE_PERCENT@CvGlobals@@QAEHXZ	; CvGlobals::getEACH_GOLD_VALUE_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getEACH_GOLD_VALUE_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEACH_GOLD_VALUE_PERCENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getEACH_GOLD_VALUE_PERCENT, COMDAT
; _this$ = ecx

; 5141 : 		return m_iEACH_GOLD_VALUE_PERCENT;

	mov	eax, DWORD PTR [ecx+6068]

; 5142 : 	}

	ret	0
?getEACH_GOLD_VALUE_PERCENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getEACH_GOLD_VALUE_PERCENT
_TEXT	ENDS
PUBLIC	?getEACH_GOLD_PER_TURN_VALUE_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getEACH_GOLD_PER_TURN_VALUE_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getEACH_GOLD_PER_TURN_VALUE_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEACH_GOLD_PER_TURN_VALUE_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getEACH_GOLD_PER_TURN_VALUE_PERCENT, COMDAT
; _this$ = ecx

; 5145 : 		return m_iEACH_GOLD_PER_TURN_VALUE_PERCENT;

	mov	eax, DWORD PTR [ecx+6072]

; 5146 : 	}

	ret	0
?getEACH_GOLD_PER_TURN_VALUE_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getEACH_GOLD_PER_TURN_VALUE_PERCENT
_TEXT	ENDS
PUBLIC	?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ	; CvGlobals::getSTANDARD_GAMESPEED
; Function compile flags: /Ogtpy
;	COMDAT ?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ PROC		; CvGlobals::getSTANDARD_GAMESPEED, COMDAT
; _this$ = ecx

; 7247 : 		return m_iSTANDARD_GAMESPEED;

	mov	eax, DWORD PTR [ecx+8464]

; 7248 : 	}

	ret	0
?getSTANDARD_GAMESPEED@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getSTANDARD_GAMESPEED
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?GetLuxuryHappinessRetention@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetLuxuryHappinessRetention
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetLuxuryHappinessRetention@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetLuxuryHappinessRetention@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetLuxuryHappinessRetention, COMDAT
; _this$ = ecx

; 643  : 		return m_iLuxuryHappinessRetention;

	mov	eax, DWORD PTR [ecx+256]

; 644  : 	};

	ret	0
?GetLuxuryHappinessRetention@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetLuxuryHappinessRetention
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??1CvDealAI@@QAE@XZ				; CvDealAI::~CvDealAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ??1CvDealAI@@QAE@XZ
_TEXT	SEGMENT
??1CvDealAI@@QAE@XZ PROC				; CvDealAI::~CvDealAI, COMDAT
; _this$ = ecx

; 35   : 	Uninit();
; 36   : }

	ret	0
??1CvDealAI@@QAE@XZ ENDP				; CvDealAI::~CvDealAI
_TEXT	ENDS
PUBLIC	?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z		; CvDealAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z PROC		; CvDealAI::Init, COMDAT
; _this$ = ecx

; 41   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   : 
; 43   : 	Reset();

	mov	DWORD PTR [ecx+4], 0

; 44   : }

	ret	4
?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvDealAI::Init
_TEXT	ENDS
PUBLIC	?Read@CvDealAI@@QAEXAAVFDataStream@@@Z		; CvDealAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvDealAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvDealAI@@QAEXAAVFDataStream@@@Z PROC		; CvDealAI::Read, COMDAT
; _this$ = ecx

; 60   : 	// Version number to maintain backwards compatibility
; 61   : 	uint uiVersion;
; 62   : 	kStream >> uiVersion;

	mov	ecx, DWORD PTR _kStream$[esp-4]
	lea	eax, DWORD PTR _uiVersion$[esp-4]
	push	eax
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 63   : }

	ret	4
?Read@CvDealAI@@QAEXAAVFDataStream@@@Z ENDP		; CvDealAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvDealAI@@QBEXAAVFDataStream@@@Z		; CvDealAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvDealAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvDealAI@@QBEXAAVFDataStream@@@Z PROC		; CvDealAI::Write, COMDAT
; _this$ = ecx

; 67   : {

	push	ecx

; 68   : 	// Current version number
; 69   : 	uint uiVersion = 1;
; 70   : 	kStream << uiVersion;

	mov	ecx, DWORD PTR _kStream$[esp]
	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	DWORD PTR _uiVersion$[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : }

	pop	ecx
	ret	4
?Write@CvDealAI@@QBEXAAVFDataStream@@@Z ENDP		; CvDealAI::Write
_TEXT	ENDS
PUBLIC	?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z		; CvDealAI::DoTradeScreenClosed
EXTRN	?DoCancelWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::DoCancelWantsResearchAgreementWithPlayer
EXTRN	?IsCanMakeResearchAgreementRightNow@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsCanMakeResearchAgreementRightNow
EXTRN	?IsWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantsResearchAgreementWithPlayer
EXTRN	?ClearDealToRenew@CvDiplomacyAI@@QAEXXZ:PROC	; CvDiplomacyAI::ClearDealToRenew
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
; Function compile flags: /Ogtpy
;	COMDAT ?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z
_TEXT	SEGMENT
_bAIWasMakingOffer$ = 8					; size = 1
?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z PROC		; CvDealAI::DoTradeScreenClosed, COMDAT
; _this$ = ecx

; 3993 : {

	push	esi
	mov	esi, ecx

; 3994 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 3995 : 
; 3996 : 	// Reset cached values each time screen closed
; 3997 : 	SetCachedValueOfPeaceWithHuman(0);

	mov	DWORD PTR [esi+4], 0

; 3998 : 
; 3999 : 	GC.GetEngineUserInterface()->SetAIRequestingConcessions(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+464]
	push	0
	call	edx

; 4000 : 	GC.GetEngineUserInterface()->SetHumanMakingDemand(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+472]
	push	0
	call	edx

; 4001 : 
; 4002 : #ifdef AUI_WARNING_FIXES
; 4003 : 	CvDiplomacyAI* pDiplomacyAI = GetPlayer()->GetDiplomacyAI();
; 4004 : 	pDiplomacyAI->ClearDealToRenew();
; 4005 : 
; 4006 : 	if (bAIWasMakingOffer)
; 4007 : 	{
; 4008 : 		// If AI was planning on a mutual Research Agreement, cancel it because the human left :(
; 4009 : 		// May want to do this slightly differently, as we can't be 100% sure this is what the AI was asking about (although if we make it through both of the following if statements there's an awful lot of circumstantial evidence)
; 4010 : 		if (pDiplomacyAI->IsWantsResearchAgreementWithPlayer(eActivePlayer))
; 4011 : 		{
; 4012 : 			if (pDiplomacyAI->IsCanMakeResearchAgreementRightNow(eActivePlayer))
; 4013 : 			{
; 4014 : 				pDiplomacyAI->DoCancelWantsResearchAgreementWithPlayer(eActivePlayer);
; 4015 : #else
; 4016 : 	GetPlayer()->GetDiplomacyAI()->ClearDealToRenew();

	mov	ecx, DWORD PTR [esi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ClearDealToRenew@CvDiplomacyAI@@QAEXXZ	; CvDiplomacyAI::ClearDealToRenew

; 4017 : 
; 4018 : 	if(bAIWasMakingOffer)

	cmp	BYTE PTR _bAIWasMakingOffer$[esp+4], 0
	je	SHORT $LN1@DoTradeScr

; 4019 : 	{
; 4020 : 		// If AI was planning on a mutual Research Agreement, cancel it because the human left :(
; 4021 : 		// May want to do this slightly differently, as we can't be 100% sure this is what the AI was asking about (although if we make it through both of the following if statements there's an awful lot of circumstantial evidence)
; 4022 : 		if(GetPlayer()->GetDiplomacyAI()->IsWantsResearchAgreementWithPlayer(eActivePlayer))

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantsResearchAgreementWithPlayer
	test	al, al
	je	SHORT $LN1@DoTradeScr

; 4023 : 		{
; 4024 : 			if(GetPlayer()->GetDiplomacyAI()->IsCanMakeResearchAgreementRightNow(eActivePlayer))

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsCanMakeResearchAgreementRightNow@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsCanMakeResearchAgreementRightNow
	test	al, al
	je	SHORT $LN1@DoTradeScr

; 4025 : 			{
; 4026 : 				GetPlayer()->GetDiplomacyAI()->DoCancelWantsResearchAgreementWithPlayer(eActivePlayer);

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoCancelWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::DoCancelWantsResearchAgreementWithPlayer
$LN1@DoTradeScr:
	pop	edi
	pop	esi

; 4027 : #endif
; 4028 : 			}
; 4029 : 		}
; 4030 : 	}
; 4031 : }

	ret	4
?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z ENDP		; CvDealAI::DoTradeScreenClosed
_TEXT	ENDS
PUBLIC	?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ ; FFastList<CvTradedItem,21,0>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ PROC	; FFastList<CvTradedItem,21,0>::size, COMDAT
; _this$ = ecx

; 189  : 	unsigned int size() const{ return BASE_TYPE::size(); };

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?size@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBEIXZ ENDP	; FFastList<CvTradedItem,21,0>::size
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@H$00$0A@@@QBEABHI@Z ; CvWeightedVector<int,1,0>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@H$00$0A@@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$00$0A@@@QBEABHI@Z PROC	; CvWeightedVector<int,1,0>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$00$0A@@@QBEABHI@Z ENDP	; CvWeightedVector<int,1,0>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$00$0A@@@QAEHXZ	; CvWeightedVector<int,1,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$00$0A@@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$00$0A@@@QAEHXZ PROC		; CvWeightedVector<int,1,0>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$00$0A@@@QAEHXZ ENDP		; CvWeightedVector<int,1,0>::size
_TEXT	ENDS
PUBLIC	??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[], COMDAT
; _this$ = ecx

; 269  : 		return m_vec[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+8]

; 270  : 	}

	ret	4
??A?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@I@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::operator[]
_TEXT	ENDS
PUBLIC	??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator, COMDAT
; _this$ = ecx

; 381  : 		~iterator(){};

	ret	0
??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ
_TEXT	SEGMENT
??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*, COMDAT
; _this$ = ecx

; 384  : 			return m_pFastList->get_allocator()[ m_uiCurrPos ];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+8]

; 385  : 		};

	ret	0
??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; BaseVector<CvLeagueAI::VoteCommitment,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z PROC ; BaseVector<CvLeagueAI::VoteCommitment,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	npad	2
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	ecx, esi
	call	??1VoteCommitment@CvLeagueAI@@QAE@XZ	; CvLeagueAI::VoteCommitment::~VoteCommitment
	add	esi, 20					; 00000014H
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ENDP ; BaseVector<CvLeagueAI::VoteCommitment,0>::Destroy
_TEXT	ENDS
PUBLIC	??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>, COMDAT
; _this$ = ecx

; 293  : 		explicit base_iterator() : m_uiCurrPos( ANCHOR_NODE_INDEX ), TAIL(NULL) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::Free
_TEXT	ENDS
PUBLIC	??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>, COMDAT
; _this$ = ecx

; 295  : 			: m_uiCurrPos( uiPos ), TAIL( pVec ) {};

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>
_TEXT	ENDS
PUBLIC	??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ ; std::auto_ptr<ICvDeal1>::operator<ICvDeal1> std::auto_ptr_ref<ICvDeal1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ PROC ; std::auto_ptr<ICvDeal1>::operator<ICvDeal1> std::auto_ptr_ref<ICvDeal1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ ENDP ; std::auto_ptr<ICvDeal1>::operator<ICvDeal1> std::auto_ptr_ref<ICvDeal1>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::iter_swap<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_
	push	esi
$LL8@unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_
	pop	esi
$LN7@unchecked_:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ		; CvDealAI::GetTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ PROC		; CvDealAI::GetTeam, COMDAT
; _this$ = ecx

; 82   : 	return m_pPlayer->getTeam();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN7@GetTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 83   : }

	ret	0

; 82   : 	return m_pPlayer->getTeam();

$LN7@GetTeam:
	or	eax, -1

; 83   : }

	ret	0
?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ ENDP		; CvDealAI::GetTeam
_TEXT	ENDS
PUBLIC	?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z ; CvDealAI::DoAcceptedDeal
EXTRN	??1CvDeal@@UAE@XZ:PROC				; CvDeal::~CvDeal
EXTRN	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ:PROC ; CvDeal::GetPeaceTreatyType
EXTRN	?ChangeRecentTradeValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeRecentTradeValue
EXTRN	?ChangeRecentAssistValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeRecentAssistValue
EXTRN	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ:PROC ; CvDeal::GetRequestingPlayer
EXTRN	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetDiploStringForMessage
EXTRN	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ:PROC ; CvDeal::GetDemandingPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z:PROC ; CvGameDeals::FinalizeDeal
EXTRN	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z:PROC ; CvGameDeals::AddProposedDeal
EXTRN	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ:PROC ; CvGame::GetGameDeals
EXTRN	??0CvDeal@@QAE@ABV0@@Z:PROC			; CvDeal::CvDeal
EXTRN	?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z:PROC ; CvGameDeals::PrepareRenewDeal
EXTRN	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z:PROC ; CvDiplomacyAI::GetDealToRenew
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z$0
__ehfuncinfo$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
_TEXT	SEGMENT
_iDealType$ = -20					; size = 4
$T225562 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T225654 = 8						; size = 4
$T225616 = 8						; size = 4
_szText$221954 = 8					; size = 4
_eFromPlayer$ = 8					; size = 4
_kDeal$ = 12						; size = 4
_iDealValueToMe$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z PROC ; CvDealAI::DoAcceptedDeal, COMDAT
; _this$ = ecx

; 191  : {

	push	-1
	push	__ehhandler$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 192  : 	int iDealType = -1;
; 193  : 	if(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(&iDealType))

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR _iDealType$[esp+36]
	or	edi, -1
	push	eax
	mov	DWORD PTR _iDealType$[esp+40], edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew

; 196  : 		{
; 197  : 			// make the deal not remove resources when processed
; 198  : 			CvGameDeals::PrepareRenewDeal(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(), &kDeal);

	mov	ebp, DWORD PTR _kDeal$[esp+32]
	test	eax, eax
	je	SHORT $LN16@DoAccepted

; 194  : 	{
; 195  : 		if (iDealType != 0) // if it's not a historic deal

	cmp	DWORD PTR _iDealType$[esp+36], 0
	je	SHORT $LN15@DoAccepted

; 196  : 		{
; 197  : 			// make the deal not remove resources when processed
; 198  : 			CvGameDeals::PrepareRenewDeal(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(), &kDeal);

	mov	ecx, DWORD PTR [esi]
	push	ebp
	push	0
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	push	eax
	call	?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z ; CvGameDeals::PrepareRenewDeal
	add	esp, 8
$LN15@DoAccepted:

; 199  : 		}
; 200  : 		m_pPlayer->GetDiplomacyAI()->ClearDealToRenew();

	mov	ecx, DWORD PTR [esi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ClearDealToRenew@CvDiplomacyAI@@QAEXXZ	; CvDiplomacyAI::ClearDealToRenew
$LN16@DoAccepted:

; 201  : 	}
; 202  : 
; 203  : 	GC.getGame().GetGameDeals()->AddProposedDeal(kDeal);

	sub	esp, 76					; 0000004cH
	mov	ecx, esp
	mov	DWORD PTR $T225562[esp+112], esp
	push	ebp
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR __$EHRec$[esp+120], 0
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+120], edi
	call	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z ; CvGameDeals::AddProposedDeal

; 204  : 	GC.getGame().GetGameDeals()->FinalizeDeal(eFromPlayer, GetPlayer()->GetID(), true);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	edi, DWORD PTR _eFromPlayer$[esp+32]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	push	eax
	push	edi
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal

; 205  : 
; 206  : 	if(GET_PLAYER(eFromPlayer).isHuman())

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN3@DoAccepted

; 207  : 	{
; 208  : 		iDealValueToMe -= GetCachedValueOfPeaceWithHuman();

	mov	ebx, DWORD PTR _iDealValueToMe$[esp+32]
	sub	ebx, DWORD PTR [esi+4]

; 209  : 
; 210  : 		// Reset cached values
; 211  : 		SetCachedValueOfPeaceWithHuman(0);

	mov	DWORD PTR [esi+4], 0

; 212  : 
; 213  : 		LeaderheadAnimationTypes eAnimation;
; 214  : 		// This signals Lua to do some interface cleanup, we only want to do this on the local machine.
; 215  : 		if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, edi
	jne	SHORT $LN13@DoAccepted

; 216  : 			gDLL->DoClearDiplomacyTradeTable();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+732]
	call	eax
$LN13@DoAccepted:

; 217  : 
; 218  : 		DiploUIStateTypes eUIState = NO_DIPLO_UI_STATE;
; 219  : 
; 220  : 		const char* szText = 0;
; 221  : 
; 222  : 		// We made a demand and they gave in
; 223  : 		if(kDeal.GetDemandingPlayer() == GetPlayer()->GetID())

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, ebp
	mov	DWORD PTR $T225616[esp+32], edx
	call	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetDemandingPlayer
	cmp	eax, DWORD PTR $T225616[esp+32]
	jne	SHORT $LN12@DoAccepted

; 224  : 		{
; 225  : 			if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, edi
	jne	$LN2@DoAccepted

; 226  : 			{
; 227  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_ACCEPT_AI_DEMAND);

	mov	ecx, DWORD PTR [esi]
	push	-1
	push	136					; 00000088H
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage

; 228  : 				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_POSITIVE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+736]
	push	-1
	push	30					; 0000001eH
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	14					; 0000000eH
	push	eax
	call	edx

; 281  : 	}
; 282  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	20					; 00000014H
$LN12@DoAccepted:

; 229  : 			}
; 230  : 
; 231  : 			return;
; 232  : 		}
; 233  : 
; 234  : 		// We made a request and they agreed
; 235  : 		if(kDeal.GetRequestingPlayer() == GetPlayer()->GetID())

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T225654[esp+32], ecx
	mov	ecx, ebp
	call	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetRequestingPlayer
	cmp	eax, DWORD PTR $T225654[esp+32]
	jne	SHORT $LN10@DoAccepted

; 236  : 		{
; 237  : 			if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, edi
	jne	SHORT $LN9@DoAccepted

; 238  : 			{
; 239  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_THANKFUL);

	mov	ecx, DWORD PTR [esi]
	push	-1
	push	69					; 00000045H
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage

; 240  : 				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+736]
	push	-1
	push	30					; 0000001eH
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	12					; 0000000cH
	push	eax
	call	edx
$LN9@DoAccepted:

; 241  : 			}
; 242  : 			GetPlayer()->GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -iDealValueToMe);

	mov	ecx, DWORD PTR [esi]
	neg	ebx
	push	ebx
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeRecentAssistValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeRecentAssistValue

; 281  : 	}
; 282  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	20					; 00000014H
$LN10@DoAccepted:

; 243  : 			return;
; 244  : 		}
; 245  : 
; 246  : 		eUIState = DIPLO_UI_STATE_BLANK_DISCUSSION;
; 247  : 
; 248  : 		// Good deal for us
; 249  : 		if(iDealValueToMe >= 100 ||
; 250  : 		        iValueTheyreOffering > (iValueImOffering * 5))	// A deal can be generous if we're getting a lot overall, OR a lot more than we're giving up

	cmp	ebx, 100				; 00000064H
	jge	SHORT $LN7@DoAccepted
	mov	eax, DWORD PTR _iValueImOffering$[esp+32]
	lea	eax, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR _iValueTheyreOffering$[esp+32], eax
	jg	SHORT $LN7@DoAccepted

; 255  : 		}
; 256  : 		// Acceptable deal for us
; 257  : 		else
; 258  : 		{
; 259  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_ACCEPT_ACCEPTABLE);

	mov	ecx, DWORD PTR [esi]
	push	-1
	push	135					; 00000087H
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$221954[esp+32], eax

; 260  : 			eAnimation = LEADERHEAD_ANIM_YES;
; 261  : 			GetPlayer()->GetDiplomacyAI()->ChangeRecentTradeValue(eFromPlayer, (iDealValueToMe / 2));

	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	jmp	SHORT $LN115@DoAccepted
$LN7@DoAccepted:

; 251  : 		{
; 252  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_ACCEPT_GENEROUS);

	mov	ecx, DWORD PTR [esi]
	push	-1
	push	134					; 00000086H
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$221954[esp+32], eax

; 253  : 			eAnimation = LEADERHEAD_ANIM_YES;
; 254  : 			GetPlayer()->GetDiplomacyAI()->ChangeRecentTradeValue(eFromPlayer, iDealValueToMe);

	push	ebx
$LN115@DoAccepted:
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	ebp, 16					; 00000010H
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeRecentTradeValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeRecentTradeValue

; 262  : 		}
; 263  : 
; 264  : 		if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, edi
	jne	SHORT $LN5@DoAccepted

; 265  : 			GC.GetEngineUserInterface()->SetOfferTradeRepeatCount(0);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+492]
	push	0
	call	eax
$LN5@DoAccepted:

; 266  : 
; 267  : 		// If this was a peace deal then use that animation instead
; 268  : 		if(kDeal.GetPeaceTreatyType() != NO_PEACE_TREATY_TYPE)

	mov	ecx, DWORD PTR _kDeal$[esp+32]
	call	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
	cmp	eax, -1
	je	SHORT $LN4@DoAccepted

; 269  : 		{
; 270  : 			eAnimation = LEADERHEAD_ANIM_PEACEFUL;

	mov	ebp, 3
$LN4@DoAccepted:

; 271  : 		}
; 272  : 
; 273  : 		// Send message back to diplo UI
; 274  : 		if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, edi
	jne	SHORT $LN3@DoAccepted

; 275  : 			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), eUIState, szText, eAnimation);

	mov	eax, DWORD PTR _szText$221954[esp+32]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+736]
	push	-1
	push	ebp
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	12					; 0000000cH
	push	eax
	call	edx
$LN3@DoAccepted:

; 276  : 	}
; 277  : 
; 278  : 	if(GC.getGame().getActivePlayer() == eFromPlayer || GC.getGame().getActivePlayer() == GetPlayer()->GetID())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, edi
	je	SHORT $LN1@DoAccepted
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, esi
	jne	SHORT $LN2@DoAccepted
$LN1@DoAccepted:

; 279  : 	{
; 280  : 		GC.GetEngineUserInterface()->makeInterfaceDirty();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+264]
	call	eax
$LN2@DoAccepted:

; 281  : 	}
; 282  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z$0:
	mov	ecx, DWORD PTR $T225562[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__ehhandler$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z ENDP ; CvDealAI::DoAcceptedDeal
PUBLIC	?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z ; CvDealAI::DoAcceptedDemand
; Function compile flags: /Ogtpy
;	COMDAT ?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z
_TEXT	SEGMENT
$T225769 = -4						; size = 4
_eFromPlayer$ = 8					; size = 4
_kDeal$ = 12						; size = 4
?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z PROC ; CvDealAI::DoAcceptedDemand, COMDAT
; _this$ = ecx

; 497  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 498  : 	CvGame& kGame = GC.getGame();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, ecx
	push	edi

; 499  : 	CvGameDeals* pGameDeals = kGame.GetGameDeals();

	mov	ecx, esi
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals

; 500  : 	const PlayerTypes eActivePlayer = kGame.getActivePlayer();

	mov	ecx, esi
	mov	edi, eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 501  : 	const PlayerTypes ePlayer = GetPlayer()->GetID();
; 502  : 
; 503  : 	pGameDeals->AddProposedDeal(kDeal);

	mov	edx, DWORD PTR _kDeal$[esp+16]
	sub	esp, 76					; 0000004cH
	mov	esi, eax
	mov	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax+44]
	mov	ecx, esp
	mov	DWORD PTR $T225769[esp+96], esp
	push	edx
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	ecx, edi
	call	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z ; CvGameDeals::AddProposedDeal

; 504  : 	pGameDeals->FinalizeDeal(eFromPlayer, ePlayer, true);

	mov	ebp, DWORD PTR _eFromPlayer$[esp+16]
	push	1
	push	ebx
	push	ebp
	mov	ecx, edi
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal

; 505  : 	if(eActivePlayer == eFromPlayer || eActivePlayer == ePlayer)

	cmp	esi, ebp
	je	SHORT $LN1@DoAccepted@2
	cmp	esi, ebx
	jne	SHORT $LN2@DoAccepted@2
$LN1@DoAccepted@2:

; 506  : 	{
; 507  : 		GC.GetEngineUserInterface()->makeInterfaceDirty();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+264]
	call	edx
$LN2@DoAccepted@2:

; 508  : 	}
; 509  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z ENDP ; CvDealAI::DoAcceptedDemand
_TEXT	ENDS
PUBLIC	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
EXTRN	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ:PROC	; CvPlayer::GetDealAI
EXTRN	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMajorCivOpinion
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z
_TEXT	SEGMENT
_iDivisor$ = -8						; size = 4
_this$ = -4						; size = 4
_iGoldOrValue$ = 8					; size = 4
_bNumGoldFromValue$ = 12				; size = 1
_bFromMe$ = 16						; size = 1
_eOtherPlayer$ = 20					; size = 4
_bUseEvenValue$ = 24					; size = 1
_bRoundUp$ = 28						; size = 1
?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z PROC ; CvDealAI::GetGoldForForValueExchange, COMDAT
; _this$ = ecx

; 896  : {

	sub	esp, 8
	push	ebx

; 897  : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of Gold with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 898  : 
; 899  : 	int iMultiplier;
; 900  : 	int iDivisor;
; 901  : 
; 902  : 	// We passed in Value, we want to know how much Gold we get for it
; 903  : 	if(bNumGoldFromValue)

	mov	bl, BYTE PTR _bNumGoldFromValue$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+24], ecx
	test	bl, bl
	je	SHORT $LN28@GetGoldFor

; 904  : 	{
; 905  : 		iMultiplier = 100;
; 906  : 		iDivisor = /*100*/ GC.getEACH_GOLD_VALUE_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6068
	mov	ebp, 100				; 00000064H
	mov	DWORD PTR _iDivisor$[esp+24], eax

; 907  : 		// Protect against a modder setting this to 0
; 908  : 		if(iDivisor == 0)

	test	eax, eax
	jne	SHORT $LN26@GetGoldFor

; 909  : 			iDivisor = 1;

	mov	DWORD PTR _iDivisor$[esp+24], 1

; 910  : 	}
; 911  : 	// We passed in an amount of Gold, we want to know how much it's worth
; 912  : 	else

	jmp	SHORT $LN26@GetGoldFor
$LN28@GetGoldFor:

; 913  : 	{
; 914  : 		iMultiplier = /*100*/ GC.getEACH_GOLD_VALUE_PERCENT();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6068

; 915  : 		iDivisor = 100;

	mov	DWORD PTR _iDivisor$[esp+24], 100	; 00000064H
$LN26@GetGoldFor:

; 916  : 	}
; 917  : 
; 918  : 	// Convert based on the rules above
; 919  : 	int iReturnValue = iGoldOrValue * iMultiplier;

	imul	ebp, DWORD PTR _iGoldOrValue$[esp+20]

; 920  : 
; 921  : 	int iModifier;
; 922  : 
; 923  : 	// While we have a big number shall we apply some modifiers to it?
; 924  : 	if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+20], 0
	mov	edi, DWORD PTR _eOtherPlayer$[esp+20]
	je	$LN3@GetGoldFor

; 925  : 	{
; 926  : 		// Approach is important
; 927  : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	mov	ecx, DWORD PTR [ecx]
	push	1
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN17@GetGoldFor
	jmp	DWORD PTR $LN49@GetGoldFor[eax*4]
$LN22@GetGoldFor:

; 928  : 		{
; 929  : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 930  : 			iModifier = 150;

	mov	esi, 150				; 00000096H

; 931  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN21@GetGoldFor:

; 932  : 		case MAJOR_CIV_APPROACH_GUARDED:
; 933  : 			iModifier = 110;

	mov	esi, 110				; 0000006eH

; 934  : 			break;
; 935  : 		case MAJOR_CIV_APPROACH_AFRAID:
; 936  : 			iModifier = 100;
; 937  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN17@GetGoldFor:

; 938  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 939  : 			iModifier = 100;
; 940  : 			break;
; 941  : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 942  : 			iModifier = 100;
; 943  : 			break;
; 944  : 		default:
; 945  : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 946  : 			iModifier = 100;

	mov	esi, 100				; 00000064H
$LN23@GetGoldFor:

; 947  : 			break;
; 948  : 		}
; 949  : 
; 950  : 		// See whether we should multiply or divide
; 951  : 		if(!bNumGoldFromValue)

	test	bl, bl
	jne	SHORT $LN16@GetGoldFor

; 952  : 		{
; 953  : 			iReturnValue *= iModifier;

	mov	ecx, esi
	imul	ecx, ebp

; 954  : 			iReturnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx

; 955  : 		}
; 956  : 		else

	jmp	SHORT $LN15@GetGoldFor
$LN16@GetGoldFor:

; 957  : 		{
; 958  : 			iReturnValue *= 100;

	mov	eax, ebp
	imul	eax, 100				; 00000064H

; 959  : 			iReturnValue /= iModifier;

	cdq
	idiv	esi
	mov	ebp, eax
$LN15@GetGoldFor:

; 960  : 		}
; 961  : 
; 962  : 		// Opinion also matters
; 963  : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	cmp	eax, 6
	ja	SHORT $LN5@GetGoldFor
	jmp	DWORD PTR $LN50@GetGoldFor[eax*4]
$LN12@GetGoldFor:

; 964  : 		{
; 965  : 		case MAJOR_CIV_OPINION_ALLY:
; 966  : 			iModifier = 100;

	mov	esi, 100				; 00000064H

; 967  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN8@GetGoldFor:

; 968  : 		case MAJOR_CIV_OPINION_FRIEND:
; 969  : 			iModifier = 100;
; 970  : 			break;
; 971  : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 972  : 			iModifier = 100;
; 973  : 			break;
; 974  : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 975  : 			iModifier = 100;
; 976  : 			break;
; 977  : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 978  : 			iModifier = 115;

	mov	esi, 115				; 00000073H

; 979  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN7@GetGoldFor:

; 980  : 		case MAJOR_CIV_OPINION_ENEMY:
; 981  : 			iModifier = 140;

	mov	esi, 140				; 0000008cH

; 982  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN6@GetGoldFor:

; 983  : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 984  : 			iModifier = 200;

	mov	esi, 200				; 000000c8H

; 985  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN5@GetGoldFor:

; 986  : 		default:
; 987  : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 988  : 			iReturnValue *= 100;

	imul	ebp, 100				; 00000064H
$LN13@GetGoldFor:

; 989  : 			break;
; 990  : 		}
; 991  : 
; 992  : 		// See whether we should multiply or divide
; 993  : 		if(!bNumGoldFromValue)

	test	bl, bl
	jne	SHORT $LN4@GetGoldFor

; 994  : 		{
; 995  : 			iReturnValue *= iModifier;

	imul	esi, ebp

; 996  : 			iReturnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx

; 997  : 		}
; 998  : 		else

	jmp	SHORT $LN3@GetGoldFor
$LN4@GetGoldFor:

; 999  : 		{
; 1000 : 			iReturnValue *= 100;

	mov	eax, ebp
	imul	eax, 100				; 00000064H

; 1001 : 			iReturnValue /= iModifier;

	cdq
	idiv	esi
	mov	ebp, eax
$LN3@GetGoldFor:

; 1002 : 		}
; 1003 : 	}
; 1004 : 
; 1005 : 	// Sometimes we want to round up.  Let's say a the AI offers a deal to the human.  We have to ensure that the human can also offer that deal back and the AI will accept (and vice versa)
; 1006 : 	if(bRoundUp)

	mov	ebx, DWORD PTR _bRoundUp$[esp+20]
	test	bl, bl
	je	SHORT $LN2@GetGoldFor

; 1007 : 	{
; 1008 : 		iReturnValue += 99;

	add	ebp, 99					; 00000063H
$LN2@GetGoldFor:

; 1009 : 	}
; 1010 : 
; 1011 : 	iReturnValue /= iDivisor;

	mov	eax, ebp
	cdq
	idiv	DWORD PTR _iDivisor$[esp+24]

; 1012 : 
; 1013 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1014 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+20], 0
	mov	esi, eax
	je	SHORT $LN47@GetGoldFor

; 1015 : 	{
; 1016 : 		iReturnValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetGoldForForValueExchange(iGoldOrValue, bNumGoldFromValue, !bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false, bRoundUp);

	mov	ecx, DWORD PTR _this$[esp+24]
	imul	edi, 63236				; 0000f704H
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR _bFromMe$[esp+20], 0
	push	ebx
	push	0
	push	eax
	sete	al
	movzx	edx, al
	mov	eax, DWORD PTR _bNumGoldFromValue$[esp+32]
	push	edx
	mov	edx, DWORD PTR _iGoldOrValue$[esp+36]
	push	eax
	mov	ecx, edi
	push	edx
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	add	eax, esi
	pop	edi

; 1017 : 
; 1018 : 		iReturnValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1022 : }

	add	esp, 8
	ret	24					; 00000018H
$LN47@GetGoldFor:
	pop	edi

; 1019 : 	}
; 1020 : 
; 1021 : 	return iReturnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1022 : }

	add	esp, 8
	ret	24					; 00000018H
	npad	1
$LN49@GetGoldFor:
	DD	$LN22@GetGoldFor
	DD	$LN17@GetGoldFor
	DD	$LN21@GetGoldFor
	DD	$LN17@GetGoldFor
	DD	$LN17@GetGoldFor
	DD	$LN17@GetGoldFor
$LN50@GetGoldFor:
	DD	$LN6@GetGoldFor
	DD	$LN7@GetGoldFor
	DD	$LN8@GetGoldFor
	DD	$LN12@GetGoldFor
	DD	$LN12@GetGoldFor
	DD	$LN12@GetGoldFor
	DD	$LN12@GetGoldFor
?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ENDP ; CvDealAI::GetGoldForForValueExchange
_TEXT	ENDS
PUBLIC	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
; Function compile flags: /Ogtpy
;	COMDAT ?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iDivisor$ = -4						; size = 4
_iGPTorValue$ = 8					; size = 4
_bNumGPTFromValue$ = 12					; size = 1
_iPostCalculationDurationDivider$ = 16			; size = 4
_iNumTurns$ = 16					; size = 4
_bFromMe$ = 20						; size = 1
_eOtherPlayer$ = 24					; size = 4
_bUseEvenValue$ = 28					; size = 1
_bRoundUp$ = 32						; size = 1
?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z PROC ; CvDealAI::GetGPTforForValueExchange, COMDAT
; _this$ = ecx

; 1026 : {

	sub	esp, 8

; 1027 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of GPT with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1028 : 
; 1029 : 	int iPreCalculationDurationMultiplier;
; 1030 : 	int iMultiplier;
; 1031 : 	int iDivisor;
; 1032 : 	int iPostCalculationDurationDivider;
; 1033 : 
; 1034 : 	// We passed in Value, we want to know how much GPT we get for it
; 1035 : 	if(bNumGPTFromValue)

	mov	dl, BYTE PTR _bNumGPTFromValue$[esp+4]
	push	ebx
	push	ebp

; 1036 : 	{
; 1037 : 		iPreCalculationDurationMultiplier = 1;
; 1038 : 		iMultiplier = 100;
; 1039 : 		iDivisor = /*80*/ GC.getEACH_GOLD_PER_TURN_VALUE_PERCENT();
; 1040 : 		iPostCalculationDurationDivider = iNumTurns;	// Divide value by number of turns to get GPT

	mov	ebp, DWORD PTR _iNumTurns$[esp+12]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+24], ecx
	test	dl, dl
	je	SHORT $LN29@GetGPTforF
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6072
	mov	ecx, 1
	lea	eax, DWORD PTR [ecx+99]
	mov	DWORD PTR _iDivisor$[esp+24], esi
	mov	DWORD PTR _iPostCalculationDurationDivider$[esp+20], ebp

; 1041 : 
; 1042 : 		// Example: want amount of GPT for 100 value.
; 1043 : 		// 100v * 1 = 100
; 1044 : 		// 100 * 100 / 80 = 125
; 1045 : 		// 125 / 20 turns = 6.25GPT
; 1046 : 	}
; 1047 : 	// We passed in an amount of GPT, we want to know how much it's worth
; 1048 : 	else

	jmp	SHORT $LN28@GetGPTforF
$LN29@GetGPTforF:

; 1049 : 	{
; 1050 : 		iPreCalculationDurationMultiplier = iNumTurns;	// Multiply GPT by number of turns to get value
; 1051 : 		iMultiplier = /*80*/ GC.getEACH_GOLD_PER_TURN_VALUE_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6072
	mov	ecx, ebp

; 1052 : 		iDivisor = 100;

	mov	DWORD PTR _iDivisor$[esp+24], 100	; 00000064H

; 1053 : 		iPostCalculationDurationDivider = 1;

	mov	DWORD PTR _iPostCalculationDurationDivider$[esp+20], 1
$LN28@GetGPTforF:

; 1054 : 
; 1055 : 		// Example: want value for 6 GPT
; 1056 : 		// 6GPT * 20 turns = 120
; 1057 : 		// 120 * 80 / 100 = 96
; 1058 : 		// 96 / 1 = 96v
; 1059 : 	}
; 1060 : 
; 1061 : 	// Convert based on the rules above
; 1062 : 	int iReturnValue = iGPTorValue * iPreCalculationDurationMultiplier;
; 1063 : 	iReturnValue *= iMultiplier;
; 1064 : 
; 1065 : 	// While we have a big number shall we apply some modifiers to it?
; 1066 : 	if(bFromMe)

	mov	edi, DWORD PTR _eOtherPlayer$[esp+20]
	imul	eax, ecx
	imul	eax, DWORD PTR _iGPTorValue$[esp+20]
	cmp	BYTE PTR _bFromMe$[esp+20], 0
	je	$LN3@GetGPTforF

; 1067 : 	{
; 1068 : 		// AI values it's GPT more highly because it's easy to exploit this
; 1069 : 		// See whether we should multiply or divide
; 1070 : 		if(!bNumGPTFromValue)

	test	dl, dl
	jne	SHORT $LN26@GetGPTforF

; 1071 : 		{
; 1072 : 			iReturnValue *= 130;

	imul	eax, 130				; 00000082H

; 1073 : 			iReturnValue /= 100;

	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5

; 1074 : 		}
; 1075 : 		else

	jmp	SHORT $LN49@GetGPTforF
$LN26@GetGPTforF:

; 1076 : 		{
; 1077 : 			iReturnValue *= 100;

	imul	eax, 100				; 00000064H

; 1078 : 			iReturnValue /= 130;

	mov	ecx, eax
	mov	eax, 2114445439				; 7e07e07fH
	imul	ecx
	sar	edx, 6
$LN49@GetGPTforF:

; 1079 : 		}
; 1080 : 
; 1081 : 		int iModifier;
; 1082 : 
; 1083 : 		// Approach is important
; 1084 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax]
	mov	esi, edx
	push	1
	shr	esi, 31					; 0000001fH
	push	edi
	add	esi, edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN17@GetGPTforF
	jmp	DWORD PTR $LN51@GetGPTforF[eax*4]
$LN22@GetGPTforF:

; 1085 : 		{
; 1086 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1087 : 			iModifier = 150;

	mov	ecx, 150				; 00000096H

; 1088 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN21@GetGPTforF:

; 1089 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1090 : 			iModifier = 110;

	mov	ecx, 110				; 0000006eH

; 1091 : 			break;
; 1092 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1093 : 			iModifier = 100;
; 1094 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN17@GetGPTforF:

; 1095 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1096 : 			iModifier = 100;
; 1097 : 			break;
; 1098 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1099 : 			iModifier = 100;
; 1100 : 			break;
; 1101 : 		default:
; 1102 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1103 : 			iModifier = 100;

	mov	ecx, 100				; 00000064H
$LN23@GetGPTforF:

; 1104 : 			break;
; 1105 : 		}
; 1106 : 
; 1107 : 		// See whether we should multiply or divide
; 1108 : 		if(!bNumGPTFromValue)

	mov	bl, BYTE PTR _bNumGPTFromValue$[esp+20]
	test	bl, bl
	jne	SHORT $LN16@GetGPTforF

; 1109 : 		{
; 1110 : 			iReturnValue *= iModifier;

	imul	ecx, esi

; 1111 : 			iReturnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1112 : 		}
; 1113 : 		else

	jmp	SHORT $LN15@GetGPTforF
$LN16@GetGPTforF:

; 1114 : 		{
; 1115 : 			iReturnValue *= 100;

	mov	eax, esi
	imul	eax, 100				; 00000064H

; 1116 : 			iReturnValue /= iModifier;

	cdq
	idiv	ecx
	mov	esi, eax
$LN15@GetGPTforF:

; 1117 : 		}
; 1118 : 
; 1119 : 		// Opinion also matters
; 1120 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	ecx, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	cmp	eax, 6
	ja	SHORT $LN5@GetGPTforF
	jmp	DWORD PTR $LN52@GetGPTforF[eax*4]
$LN8@GetGPTforF:

; 1121 : 		{
; 1122 : 		case MAJOR_CIV_OPINION_ALLY:
; 1123 : 			iModifier = 100;
; 1124 : 			break;
; 1125 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1126 : 			iModifier = 100;
; 1127 : 			break;
; 1128 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1129 : 			iModifier = 100;
; 1130 : 			break;
; 1131 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1132 : 			iModifier = 100;
; 1133 : 			break;
; 1134 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1135 : 			iModifier = 115;

	mov	ecx, 115				; 00000073H

; 1136 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN7@GetGPTforF:

; 1137 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1138 : 			iModifier = 140;

	mov	ecx, 140				; 0000008cH

; 1139 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN6@GetGPTforF:

; 1140 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1141 : 			iModifier = 200;

	mov	ecx, 200				; 000000c8H

; 1142 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN5@GetGPTforF:

; 1143 : 		default:
; 1144 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1145 : 			iModifier = 100;

	mov	ecx, 100				; 00000064H
$LN13@GetGPTforF:

; 1146 : 			break;
; 1147 : 		}
; 1148 : 
; 1149 : 		// See whether we should multiply or divide
; 1150 : 		if(!bNumGPTFromValue)

	test	bl, bl
	jne	SHORT $LN4@GetGPTforF

; 1151 : 		{
; 1152 : 			iReturnValue *= iModifier;

	imul	ecx, esi

; 1153 : 			iReturnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1154 : 		}
; 1155 : 		else

	jmp	SHORT $LN3@GetGPTforF
$LN4@GetGPTforF:

; 1156 : 		{
; 1157 : 			iReturnValue *= 100;

	mov	eax, esi
	imul	eax, 100				; 00000064H

; 1158 : 			iReturnValue /= iModifier;

	cdq
	idiv	ecx
$LN3@GetGPTforF:

; 1159 : 		}
; 1160 : 	}
; 1161 : 
; 1162 : 	// Sometimes we want to round up.  Let's say a the AI offers a deal to the human.  We have to ensure that the human can also offer that deal back and the AI will accept (and vice versa)
; 1163 : 	if(bRoundUp)

	mov	ebx, DWORD PTR _bRoundUp$[esp+20]
	test	bl, bl
	je	SHORT $LN2@GetGPTforF

; 1164 : 	{
; 1165 : 		iReturnValue += 99;

	add	eax, 99					; 00000063H
$LN2@GetGPTforF:

; 1166 : 	}
; 1167 : 
; 1168 : 	iReturnValue /= iDivisor;

	cdq
	idiv	DWORD PTR _iDivisor$[esp+24]

; 1169 : 
; 1170 : 	iReturnValue /= iPostCalculationDurationDivider;

	cdq
	idiv	DWORD PTR _iPostCalculationDurationDivider$[esp+20]

; 1171 : 
; 1172 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1173 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+20], 0
	mov	esi, eax
	je	SHORT $LN48@GetGPTforF

; 1174 : 	{
; 1175 : 		iReturnValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetGPTforForValueExchange(iGPTorValue, bNumGPTFromValue, iNumTurns, !bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false, bRoundUp);

	mov	edx, DWORD PTR _this$[esp+24]
	imul	edi, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	BYTE PTR _bFromMe$[esp+20], 0
	push	ebx
	push	0
	push	eax
	sete	dl
	movzx	eax, dl
	mov	edx, DWORD PTR _bNumGPTFromValue$[esp+32]
	push	eax
	mov	eax, DWORD PTR _iGPTorValue$[esp+36]
	push	ebp
	push	edx
	mov	ecx, edi
	push	eax
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	add	eax, esi
	pop	edi

; 1176 : 
; 1177 : 		iReturnValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1181 : }

	add	esp, 8
	ret	28					; 0000001cH
$LN48@GetGPTforF:
	pop	edi

; 1178 : 	}
; 1179 : 
; 1180 : 	return iReturnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1181 : }

	add	esp, 8
	ret	28					; 0000001cH
$LN51@GetGPTforF:
	DD	$LN22@GetGPTforF
	DD	$LN17@GetGPTforF
	DD	$LN21@GetGPTforF
	DD	$LN17@GetGPTforF
	DD	$LN17@GetGPTforF
	DD	$LN17@GetGPTforF
$LN52@GetGPTforF:
	DD	$LN6@GetGPTforF
	DD	$LN7@GetGPTforF
	DD	$LN8@GetGPTforF
	DD	$LN5@GetGPTforF
	DD	$LN5@GetGPTforF
	DD	$LN5@GetGPTforF
	DD	$LN5@GetGPTforF
?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ENDP ; CvDealAI::GetGPTforForValueExchange
_TEXT	ENDS
PUBLIC	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue
EXTRN	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z:PROC ; CvTeam::IsResourceObsolete
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?getHappiness@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getHappiness
EXTRN	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z:PROC ; CvGameLeagues::IsLuxuryHappinessBanned
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T225871 = -4						; size = 4
$T225870 = 8						; size = 4
_eResource$ = 8						; size = 4
_iResourceQuantity$ = 12				; size = 4
_iNumTurns$ = 16					; size = 4
_bFromMe$ = 20						; size = 1
_eOtherPlayer$ = 24					; size = 4
?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z PROC ; CvDealAI::GetResourceValue, COMDAT
; _this$ = ecx

; 1185 : {

	push	ecx
	push	ebx

; 1186 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Resource with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1187 : 
; 1188 : 	int iItemValue = 0;
; 1189 : 
; 1190 : 	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	ebx, DWORD PTR _eResource$[esp+4]
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	edi, eax

; 1191 : 	CvAssert(pkResourceInfo != NULL);
; 1192 : 	if (pkResourceInfo == NULL)

	test	edi, edi
	jne	SHORT $LN33@GetResourc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1313 : }

	pop	ecx
	ret	20					; 00000014H
$LN33@GetResourc:

; 1193 : 		return 0;
; 1194 : 
; 1195 : 	ResourceUsageTypes eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, edi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 1196 : 
; 1197 : 	// Luxury Resource
; 1198 : 	if(eUsage == RESOURCEUSAGE_LUXURY)

	cmp	eax, 2
	jne	SHORT $LN32@GetResourc

; 1199 : 	{
; 1200 : 		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetPlayer()->GetID(), eResource))

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	test	al, al

; 1201 : 		{
; 1202 : 			iItemValue = 0;
; 1203 : 		}
; 1204 : 		else

	jne	$LN21@GetResourc

; 1205 : 		{
; 1206 : 			int iHappinessFromResource = pkResourceInfo->getHappiness();

	mov	ecx, edi
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness
	mov	esi, eax
	imul	esi, DWORD PTR _iResourceQuantity$[esp+16]

; 1207 : 			iItemValue += (iResourceQuantity * iHappinessFromResource * iNumTurns * 2);	// Ex: 1 Silk for 4 Happiness * 30 turns * 2 = 240

	imul	esi, DWORD PTR _iNumTurns$[esp+16]
	add	esi, esi

; 1208 : 
; 1209 : 			// If we only have 1 of a Luxury then we value it much more
; 1210 : 			if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+16], 0
	je	$LN19@GetResourc

; 1211 : 			{
; 1212 : 				if(GetPlayer()->getNumResourceAvailable(eResource) == 1)

	mov	ecx, DWORD PTR [ebp]
	push	1
	push	ebx
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, 1
	jne	$LN20@GetResourc

; 1213 : 				{
; 1214 : 					iItemValue *= 3;
; 1215 : 					if(GetPlayer()->GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)

	mov	ecx, DWORD PTR [ebp]
	lea	esi, DWORD PTR [esi+esi*2]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+256], 0
	jle	$LN20@GetResourc

; 1216 : 					{
; 1217 : 						iItemValue /= 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax

; 1218 : 					}
; 1219 : 				}
; 1220 : 			}
; 1221 : 		}

	jmp	$LN20@GetResourc
$LN32@GetResourc:

; 1222 : 	}
; 1223 : 	// Strategic Resource
; 1224 : 	else if(eUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	eax, 1
	jne	$LN20@GetResourc

; 1225 : 	{
; 1226 : 		//tricksy humans trying to sploit us
; 1227 : 		if(!bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+16], 0
	jne	SHORT $LN81@GetResourc

; 1228 : 		{
; 1229 : 			// if we already have a big surplus of this resource
; 1230 : 			if(GetPlayer()->getNumResourceAvailable(eResource) > GetPlayer()->getNumCities())

	mov	esi, DWORD PTR [ebp]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	ecx, esi
	mov	edi, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	edi, eax
	jle	SHORT $LN23@GetResourc

; 1231 : 			{
; 1232 : 				iResourceQuantity = 0;

	xor	esi, esi

; 1233 : 			}
; 1234 : 			else

	jmp	SHORT $LN22@GetResourc
$LN23@GetResourc:

; 1235 : 			{
; 1236 : 				iResourceQuantity = min(max(5,GetPlayer()->getNumCities()), iResourceQuantity);

	mov	ecx, DWORD PTR [ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR $T225870[esp+16], eax
	cmp	eax, 5
	mov	DWORD PTR $T225871[esp+20], 5
	lea	eax, DWORD PTR $T225870[esp+16]
	jg	SHORT $LN59@GetResourc
	lea	eax, DWORD PTR $T225871[esp+20]
$LN59@GetResourc:
	mov	ecx, DWORD PTR _iResourceQuantity$[esp+16]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN62@GetResourc
	lea	eax, DWORD PTR _iResourceQuantity$[esp+16]
$LN62@GetResourc:
	mov	esi, DWORD PTR [eax]
	jmp	SHORT $LN22@GetResourc
$LN81@GetResourc:
	mov	esi, DWORD PTR _iResourceQuantity$[esp+16]
$LN22@GetResourc:

; 1237 : 			}
; 1238 : 		}
; 1239 : 		if(!GET_TEAM(GetPlayer()->getTeam()).IsResourceObsolete(eResource))

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN70@GetResourc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN71@GetResourc
$LN70@GetResourc:
	or	eax, -1
$LN71@GetResourc:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	mov	ecx, eax
	call	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ; CvTeam::IsResourceObsolete
	test	al, al
	jne	SHORT $LN21@GetResourc

; 1240 : 		{
; 1241 : 			iItemValue += (iResourceQuantity * iNumTurns * 150 / 100);	// Ex: 5 Iron for 30 turns * 2 = value of 300

	imul	esi, DWORD PTR _iNumTurns$[esp+16]
	imul	esi, 150				; 00000096H
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1242 : 		}
; 1243 : 		else

	jmp	SHORT $LN20@GetResourc
$LN21@GetResourc:

; 1244 : 		{
; 1245 : 			iItemValue = 0;

	xor	esi, esi
$LN20@GetResourc:

; 1246 : 		}
; 1247 : 	}
; 1248 : 
; 1249 : 	// Increase value if it's from us and we don't like the guy
; 1250 : 	if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+16], 0
	je	$LN19@GetResourc

; 1251 : 	{
; 1252 : 		int iModifier = 0;
; 1253 : 
; 1254 : 		// Opinion also matters
; 1255 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	ebx, DWORD PTR _eOtherPlayer$[esp+16]
	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	cmp	eax, 6
	ja	SHORT $LN9@GetResourc
	jmp	DWORD PTR $LN82@GetResourc[eax*4]
$LN12@GetResourc:

; 1256 : 		{
; 1257 : 		case MAJOR_CIV_OPINION_ALLY:
; 1258 : 			iModifier = 100;
; 1259 : 			break;
; 1260 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1261 : 			iModifier = 100;
; 1262 : 			break;
; 1263 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1264 : 			iModifier = 100;
; 1265 : 			break;
; 1266 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1267 : 			iModifier = 100;
; 1268 : 			break;
; 1269 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1270 : 			iModifier = 175;

	mov	edi, 175				; 000000afH

; 1271 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN11@GetResourc:

; 1272 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1273 : 			iModifier = 400;

	mov	edi, 400				; 00000190H

; 1274 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN10@GetResourc:

; 1275 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1276 : 			iModifier = 1000;

	mov	edi, 1000				; 000003e8H

; 1277 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN9@GetResourc:

; 1278 : 		default:
; 1279 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Resource valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1280 : 			iModifier = 100;

	mov	edi, 100				; 00000064H
$LN17@GetResourc:

; 1281 : 			break;
; 1282 : 		}
; 1283 : 
; 1284 : 		// Approach is important
; 1285 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	mov	ecx, DWORD PTR [ebp]
	push	1
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN1@GetResourc
	jmp	DWORD PTR $LN83@GetResourc[eax*4]
$LN6@GetResourc:

; 1286 : 		{
; 1287 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1288 : 			iModifier += 300;

	add	edi, 300				; 0000012cH

; 1289 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN5@GetResourc:

; 1290 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1291 : 			iModifier += 150;

	add	edi, 150				; 00000096H

; 1292 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN4@GetResourc:

; 1293 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1294 : 			iModifier = 200;	// Forced value

	mov	edi, 200				; 000000c8H

; 1295 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN1@GetResourc:

; 1296 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1297 : 			iModifier = 200;	// Forced value
; 1298 : 			break;
; 1299 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1300 : 			iModifier += 100;
; 1301 : 			break;
; 1302 : 		default:
; 1303 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Resource valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1304 : 			iModifier += 100;

	add	edi, 100				; 00000064H
$LN7@GetResourc:

; 1305 : 			break;
; 1306 : 		}
; 1307 : 
; 1308 : 		iItemValue *= iModifier;

	imul	edi, esi

; 1309 : 		iItemValue /= 200;	// 200 because we've added two mods together

	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN19@GetResourc:
	pop	edi

; 1310 : 	}
; 1311 : 
; 1312 : 	return iItemValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1313 : }

	pop	ecx
	ret	20					; 00000014H
	npad	2
$LN82@GetResourc:
	DD	$LN10@GetResourc
	DD	$LN11@GetResourc
	DD	$LN12@GetResourc
	DD	$LN9@GetResourc
	DD	$LN9@GetResourc
	DD	$LN9@GetResourc
	DD	$LN9@GetResourc
$LN83@GetResourc:
	DD	$LN6@GetResourc
	DD	$LN1@GetResourc
	DD	$LN5@GetResourc
	DD	$LN4@GetResourc
	DD	$LN4@GetResourc
	DD	$LN1@GetResourc
?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ENDP ; CvDealAI::GetResourceValue
_TEXT	ENDS
PUBLIC	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
EXTRN	?IsOriginalMajorCapital@CvCity@@QBE_NXZ:PROC	; CvCity::IsOriginalMajorCapital
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarProjection
EXTRN	?hasActiveWorldWonder@CvCity@@QBE_NXZ:PROC	; CvCity::hasActiveWorldWonder
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getMaxTurns@CvGame@@QBEHXZ:PROC		; CvGame::getMaxTurns
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getNonObsoleteResourceType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?GetCityPurchaseID@CvPlot@@QAEHXZ:PROC		; CvPlot::GetCityPurchaseID
EXTRN	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z:PROC ; CvCityCitizens::GetCityPlotFromIndex
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?GetBuyPlotCost@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetBuyPlotCost
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_iGoldValueOfResourcePlots$222482 = -40			; size = 4
_this$ = -36						; size = 4
_iGoldValueOfImprovedPlots$222481 = -32			; size = 4
_iGoldValueOfPlots$222480 = -28				; size = 4
_pCity$ = -24						; size = 4
_goldPerPlot$222479 = -20				; size = 4
_iI$222483 = -16					; size = 4
$T225980 = -12						; size = 4
$T225978 = -12						; size = 4
_eUsage$222495 = -12					; size = 4
$T225979 = -8						; size = 4
_iNumTurns$222498 = -8					; size = 4
_iCityLoop$222527 = -4					; size = 4
_eResource$222491 = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_bFromMe$ = 16						; size = 1
_eOtherPlayer$ = 20					; size = 4
_bUseEvenValue$ = 24					; size = 1
?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z PROC	; CvDealAI::GetCityValue, COMDAT
; _this$ = ecx

; 1317 : {

	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1318 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of City with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1319 : 
; 1320 : 	int iItemValue = 0;
; 1321 : 
; 1322 : 	CvCity* pCity = GC.getMap().plot(iX, iY)->getPlotCity();

	mov	edi, DWORD PTR _iX$[esp+52]
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+56], ecx
	cmp	edi, -2147483647			; 80000001H
	je	$LN191@GetCityVal
	cmp	DWORD PTR _iY$[esp+52], -2147483647	; 80000001H
	je	$LN191@GetCityVal
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ebp+4020]
	cmp	BYTE PTR [ebp+4056], bl
	je	SHORT $LN54@GetCityVal
	test	edi, edi
	jge	SHORT $LN56@GetCityVal
	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN58@GetCityVal
$LN56@GetCityVal:
	cmp	edi, ecx
	jl	SHORT $LN54@GetCityVal
	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN58@GetCityVal
$LN54@GetCityVal:
	mov	esi, edi
$LN58@GetCityVal:
	mov	edi, DWORD PTR [ebp+4024]
	mov	eax, DWORD PTR _iY$[esp+52]
	cmp	BYTE PTR [ebp+4057], bl
	je	SHORT $LN64@GetCityVal
	test	eax, eax
	jge	SHORT $LN66@GetCityVal
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN68@GetCityVal
$LN66@GetCityVal:
	cmp	eax, edi
	jl	SHORT $LN64@GetCityVal
	cdq
	idiv	edi
	jmp	SHORT $LN68@GetCityVal
$LN64@GetCityVal:
	mov	edx, eax
$LN68@GetCityVal:
	test	esi, esi
	jl	SHORT $LN48@GetCityVal
	cmp	esi, ecx
	jge	SHORT $LN48@GetCityVal
	test	edx, edx
	jl	SHORT $LN48@GetCityVal
	cmp	edx, edi
	jge	SHORT $LN48@GetCityVal
	mov	edi, DWORD PTR _iX$[esp+52]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	jmp	SHORT $LN46@GetCityVal
$LN48@GetCityVal:
	mov	edi, DWORD PTR _iX$[esp+52]
$LN191@GetCityVal:
	xor	ecx, ecx
$LN46@GetCityVal:
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	$LN197@GetCityVal
	cmp	eax, 64					; 00000040H
	jge	$LN197@GetCityVal
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax
	mov	DWORD PTR _pCity$[esp+56], edi

; 1323 : 
; 1324 : 	if(pCity != NULL)

	test	edi, edi
	je	$LN199@GetCityVal

; 1325 : 	{
; 1326 : 		iItemValue = 440 + (pCity->getPopulation() * 200);

	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation

; 1327 : 
; 1328 : 		// add in the value of every plot this city owns (plus improvements and resources)
; 1329 : 		// okay, I'm only going to count in the 3-rings plots since we can't actually use any others (I realize there may be a resource way out there)
; 1330 : 
; 1331 : 		int goldPerPlot = GetPlayer()->GetBuyPlotCost(); // this is how much ANY plot is worth to me right now

	mov	edx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [edx]
	mov	ebx, eax
	imul	ebx, 200				; 000000c8H
	add	ebx, 440				; 000001b8H
	call	?GetBuyPlotCost@CvPlayer@@QBEHXZ	; CvPlayer::GetBuyPlotCost

; 1332 : 
; 1333 : 		int iGoldValueOfPlots = 0;

	xor	ebp, ebp
	mov	DWORD PTR _goldPerPlot$222479[esp+56], eax
	mov	DWORD PTR _iGoldValueOfPlots$222480[esp+56], ebp

; 1334 : 		int iGoldValueOfImprovedPlots = 0;

	mov	DWORD PTR _iGoldValueOfImprovedPlots$222481[esp+56], ebp

; 1335 : 		int iGoldValueOfResourcePlots = 0;

	mov	DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56], ebp

; 1336 : 		for(int iI = 0; iI < NUM_CITY_PLOTS; iI++)

	mov	DWORD PTR _iI$222483[esp+56], ebp
	jmp	SHORT $LN34@GetCityVal
$LL202@GetCityVal:
	mov	edi, DWORD PTR _pCity$[esp+56]
$LN34@GetCityVal:

; 1337 : 		{
; 1338 : 			CvPlot* pLoopPlot = pCity->GetCityCitizens()->GetCityPlotFromIndex(iI);

	push	ebp
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
	mov	esi, eax

; 1339 : 			if(NULL != pLoopPlot && pCity->GetID() == pLoopPlot->GetCityPurchaseID())

	test	esi, esi
	je	$LN33@GetCityVal
	mov	edi, DWORD PTR [edi+120]
	mov	ecx, esi
	call	?GetCityPurchaseID@CvPlot@@QAEHXZ	; CvPlot::GetCityPurchaseID
	cmp	edi, eax
	jne	$LN33@GetCityVal

; 1340 : 			{
; 1341 : 				if(iI > 6)

	cmp	ebp, 6
	jle	SHORT $LN203@GetCityVal

; 1342 : 				{
; 1343 : 					iGoldValueOfPlots += goldPerPlot; // this is a bargain, but at least it's in the ballpark

	mov	eax, DWORD PTR _goldPerPlot$222479[esp+56]
	add	DWORD PTR _iGoldValueOfPlots$222480[esp+56], eax
$LN203@GetCityVal:

; 1344 : 				}
; 1345 : 				if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN29@GetCityVal

; 1346 : 				{
; 1347 : 					iGoldValueOfImprovedPlots += goldPerPlot * 25;

	mov	ecx, DWORD PTR _goldPerPlot$222479[esp+56]
	imul	ecx, 25					; 00000019H
	add	DWORD PTR _iGoldValueOfImprovedPlots$222481[esp+56], ecx
$LN29@GetCityVal:

; 1348 : 				}
; 1349 : 				ResourceTypes eResource = pLoopPlot->getNonObsoleteResourceType(GetPlayer()->getTeam());

	mov	edx, DWORD PTR _this$[esp+56]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN99@GetCityVal
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN100@GetCityVal
$LN99@GetCityVal:
	or	eax, -1
$LN100@GetCityVal:
	push	eax
	mov	ecx, esi
	call	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
	mov	DWORD PTR _eResource$222491[esp+56], eax

; 1350 : 				if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	$LN33@GetCityVal

; 1351 : 				{
; 1352 : 					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ebp, eax

; 1353 : 					if (pkResourceInfo)

	test	ebp, ebp
	je	$LN33@GetCityVal

; 1354 : 					{
; 1355 : 						ResourceUsageTypes eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, ebp
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 1356 : 						int iResourceQuantity = pLoopPlot->getNumResource();

	mov	ecx, esi
	mov	DWORD PTR _eUsage$222495[esp+56], eax
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	edi, eax

; 1357 : 						// Luxury Resource
; 1358 : 						if(eUsage == RESOURCEUSAGE_LUXURY)

	mov	eax, DWORD PTR _eUsage$222495[esp+56]
	cmp	eax, 2
	jne	$LN26@GetCityVal

; 1359 : 						{
; 1360 : #ifdef AUI_WARNING_FIXES
; 1361 : 							int iNumTurns = MIN(1, GC.getGame().getMaxTurns() - GC.getGame().getGameTurn());
; 1362 : 							iNumTurns = MAX(120, iNumTurns); // let's not go hog wild here
; 1363 : #else
; 1364 : 							int iNumTurns = min(1,GC.getGame().getMaxTurns() - GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getMaxTurns@CvGame@@QBEHXZ		; CvGame::getMaxTurns
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	esi, eax
	cmp	esi, 1
	mov	DWORD PTR $T225978[esp+56], esi
	mov	DWORD PTR $T225979[esp+56], 1
	lea	eax, DWORD PTR $T225978[esp+56]
	jl	SHORT $LN111@GetCityVal
	lea	eax, DWORD PTR $T225979[esp+56]
$LN111@GetCityVal:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iNumTurns$222498[esp+56], eax

; 1365 : 							iNumTurns = max(120,iNumTurns); // let's not go hog wild here

	cmp	eax, 120				; 00000078H
	mov	DWORD PTR $T225980[esp+56], 120		; 00000078H
	lea	eax, DWORD PTR _iNumTurns$222498[esp+56]
	jg	SHORT $LN115@GetCityVal
	lea	eax, DWORD PTR $T225980[esp+56]
$LN115@GetCityVal:
	mov	esi, DWORD PTR [eax]

; 1366 : #endif
; 1367 : 							int iHappinessFromResource = pkResourceInfo->getHappiness();

	mov	ecx, ebp
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness

; 1368 : 							iGoldValueOfResourcePlots += (iResourceQuantity * iHappinessFromResource * iNumTurns * 2);	// Ex: 1 Silk for 4 Happiness * 30 turns * 2 = 240

	imul	eax, esi
	mov	esi, eax
	mov	eax, DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56]
	imul	esi, edi

; 1369 : 							// If we only have 1 of a Luxury then we value it much more
; 1370 : 							if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+52], 0
	lea	ecx, DWORD PTR [eax+esi*2]
	mov	DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56], ecx
	je	SHORT $LN33@GetCityVal

; 1371 : 							{
; 1372 : 								if(GetPlayer()->getNumResourceAvailable(eResource) == 1)

	mov	edx, DWORD PTR _this$[esp+56]
	mov	eax, DWORD PTR _eResource$222491[esp+56]
	mov	ecx, DWORD PTR [edx]
	push	1
	push	eax
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, 1
	jne	SHORT $LN33@GetCityVal

; 1373 : 								{
; 1374 : 									iGoldValueOfResourcePlots += (iResourceQuantity * iHappinessFromResource * iNumTurns * 4);

	mov	ecx, DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56]
	lea	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56], edx

; 1375 : 								}
; 1376 : 							}
; 1377 : 						}

	jmp	SHORT $LN33@GetCityVal
$LN26@GetCityVal:

; 1378 : 						// Strategic Resource
; 1379 : 						else if(eUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	eax, 1
	jne	SHORT $LN33@GetCityVal

; 1380 : 						{
; 1381 : 							int iNumTurns = 60; // okay, this is a reasonable estimate
; 1382 : 							iGoldValueOfResourcePlots += (iResourceQuantity * iNumTurns * 150 / 100);

	imul	edi, 9000				; 00002328H
	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56], eax
$LN33@GetCityVal:
	mov	ebp, DWORD PTR _iI$222483[esp+56]
	inc	ebp
	cmp	ebp, 37					; 00000025H
	mov	DWORD PTR _iI$222483[esp+56], ebp
	jl	$LL202@GetCityVal

; 1383 : 						}
; 1384 : 					}
; 1385 : 				}
; 1386 : 			}
; 1387 : 		}
; 1388 : 		iGoldValueOfImprovedPlots /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	DWORD PTR _iGoldValueOfImprovedPlots$222481[esp+56]
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1389 : 
; 1390 : 		iItemValue = iItemValue + iGoldValueOfPlots + iGoldValueOfImprovedPlots + iGoldValueOfResourcePlots;

	add	ecx, DWORD PTR _iGoldValueOfResourcePlots$222482[esp+56]
	add	ecx, DWORD PTR _iGoldValueOfPlots$222480[esp+56]
	add	ebx, ecx

; 1391 : 
; 1392 : 		// add in the (gold) value of the buildings (Or should we?  Will they transfer?)
; 1393 : 
; 1394 : 		// From this player - add extra weight (don't want the human giving the AI a bit of gold for good cities)
; 1395 : 		if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+52], 0
	je	$LN21@GetCityVal

; 1396 : 		{
; 1397 : 			// Wonders are nice
; 1398 : 			if(pCity->hasActiveWorldWonder())

	mov	ecx, DWORD PTR _pCity$[esp+56]
	call	?hasActiveWorldWonder@CvCity@@QBE_NXZ	; CvCity::hasActiveWorldWonder
	test	al, al
	je	SHORT $LN20@GetCityVal

; 1399 : 				iItemValue *= 2;

	add	ebx, ebx
$LN20@GetCityVal:

; 1400 : 
; 1401 : 			// Adjust for how well a war against this player would go (or is going)
; 1402 : 			switch(GetPlayer()->GetDiplomacyAI()->GetWarProjection(eOtherPlayer))

	mov	edi, DWORD PTR _this$[esp+56]
	mov	esi, DWORD PTR _eOtherPlayer$[esp+52]
	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection
	cmp	eax, 5
	ja	SHORT $LN11@GetCityVal
	jmp	DWORD PTR $LN204@GetCityVal[eax*4]
$LN17@GetCityVal:

; 1403 : 			{
; 1404 : 			case WAR_PROJECTION_DESTRUCTION:
; 1405 : 				iItemValue *= 100;

	imul	ebx, 100				; 00000064H

; 1406 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN16@GetCityVal:

; 1407 : 			case WAR_PROJECTION_DEFEAT:
; 1408 : 				iItemValue *= 180;

	imul	ebx, 180				; 000000b4H

; 1409 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN15@GetCityVal:

; 1410 : 			case WAR_PROJECTION_STALEMATE:
; 1411 : 				iItemValue *= 220;

	imul	ebx, 220				; 000000dcH

; 1412 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN14@GetCityVal:

; 1413 : 			case WAR_PROJECTION_UNKNOWN:
; 1414 : 				iItemValue *= 250;

	imul	ebx, 250				; 000000faH

; 1415 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN13@GetCityVal:

; 1416 : 			case WAR_PROJECTION_GOOD:
; 1417 : 				iItemValue *= 400;

	imul	ebx, 400				; 00000190H

; 1418 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN11@GetCityVal:

; 1419 : 			case WAR_PROJECTION_VERY_GOOD:
; 1420 : 				iItemValue *= 400;
; 1421 : 				break;
; 1422 : 			default:
; 1423 : 				CvAssertMsg(false, "DEAL_AI: AI player has no valid War Projection for City valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1424 : 				iItemValue *= 300;

	imul	ebx, 300				; 0000012cH
$LN18@GetCityVal:

; 1425 : 				break;
; 1426 : 			}
; 1427 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ebx

; 1428 : 
; 1429 : 			// AI players should be less willing to trade cities when not at war
; 1430 : 			if(!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eOtherPlayer).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	mov	edx, esi
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN126@GetCityVal
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN127@GetCityVal
$LN126@GetCityVal:
	or	ecx, -1
$LN127@GetCityVal:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN137@GetCityVal
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN138@GetCityVal
$LN137@GetCityVal:
	or	eax, -1
$LN138@GetCityVal:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN41@GetCityVal

; 1431 : 			{
; 1432 : 				iItemValue *= 2;

	add	ebx, ebx

; 1433 : 			}
; 1434 : 
; 1435 : 		}	// END bFromMe
; 1436 : 		else

	jmp	$LN41@GetCityVal
$LN21@GetCityVal:

; 1437 : 		{
; 1438 : 			CvPlayerAI& theOtherPlayer = GET_PLAYER(eOtherPlayer);

	mov	esi, DWORD PTR _eOtherPlayer$[esp+52]

; 1439 : 			if(!GET_TEAM(GetTeam()).isAtWar(theOtherPlayer.getTeam()))

	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN150@GetCityVal
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN151@GetCityVal
$LN150@GetCityVal:
	or	ecx, -1
$LN151@GetCityVal:
	mov	edi, DWORD PTR _this$[esp+56]
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN161@GetCityVal
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN162@GetCityVal
$LN161@GetCityVal:
	or	eax, -1
$LN162@GetCityVal:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN196@GetCityVal

; 1440 : 			{
; 1441 : 				if(theOtherPlayer.isHuman())  // he is obviously trying to trick us

	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN196@GetCityVal

; 1442 : 				{
; 1443 : 					CvCity* pLoopCity;
; 1444 : 					int iCityLoop;
; 1445 : 					int iBestDistance = 99;
; 1446 : 					for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iCityLoop$222527[esp+60]
	push	eax
	mov	esi, 99					; 00000063H
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN39@GetCityVal
	npad	8
$LL6@GetCityVal:

; 1447 : 					{
; 1448 : 						int iDistFromThisCity = plotDistance(iX, iY, pLoopCity->getX(), pLoopCity->getY());

	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	mov	eax, DWORD PTR _iY$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR _iX$[esp+56]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1449 : 						if(iDistFromThisCity < iBestDistance)

	cmp	eax, esi
	jge	SHORT $LN5@GetCityVal

; 1450 : 						{
; 1451 : 							iBestDistance = iDistFromThisCity;

	mov	esi, eax
$LN5@GetCityVal:

; 1442 : 				{
; 1443 : 					CvCity* pLoopCity;
; 1444 : 					int iCityLoop;
; 1445 : 					int iBestDistance = 99;
; 1446 : 					for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	edx, DWORD PTR _iCityLoop$222527[esp+60]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL6@GetCityVal

; 1452 : 						}
; 1453 : 					}
; 1454 : 					iBestDistance = (iBestDistance > 4) ? iBestDistance : 5;

	cmp	esi, 4
	jg	SHORT $LN39@GetCityVal
	mov	esi, 5
$LN39@GetCityVal:

; 1455 : 					iItemValue /= iBestDistance - 4;

	mov	eax, ebx
	add	esi, -4					; fffffffcH
	cdq
	idiv	esi
	mov	ebx, eax

; 1456 : 					iItemValue = (iItemValue >= 100) ? iItemValue : 100;

	cmp	ebx, 100				; 00000064H
	jge	SHORT $LN196@GetCityVal
	mov	ebx, 100				; 00000064H
$LN196@GetCityVal:
	mov	esi, DWORD PTR _eOtherPlayer$[esp+52]
$LN41@GetCityVal:

; 1457 : 				}
; 1458 : 			}
; 1459 : 		}
; 1460 : 
; 1461 : 		// slewis - Due to rule changes, value of major capitals should go up quite a bit because someone can win the game by owning them
; 1462 : 		if (pCity->IsOriginalMajorCapital())

	mov	ecx, DWORD PTR _pCity$[esp+56]
	call	?IsOriginalMajorCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalMajorCapital

; 1463 : 		{
; 1464 : 			iItemValue *= 2;

	mov	edi, DWORD PTR _iX$[esp+52]
	test	al, al
	je	SHORT $LN2@GetCityVal
	add	ebx, ebx
	jmp	SHORT $LN2@GetCityVal
$LN199@GetCityVal:
	mov	edi, DWORD PTR _iX$[esp+52]
$LN197@GetCityVal:
	mov	esi, DWORD PTR _eOtherPlayer$[esp+52]
$LN2@GetCityVal:

; 1465 : 		}
; 1466 : 	}
; 1467 : 
; 1468 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1469 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+52], 0
	je	SHORT $LN190@GetCityVal

; 1470 : 	{
; 1471 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetCityValue(iX, iY, !bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	eax, DWORD PTR _this$[esp+56]
	imul	esi, 63236				; 0000f704H
	mov	ecx, DWORD PTR [eax]
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+44]
	cmp	BYTE PTR _bFromMe$[esp+52], 0
	push	0
	push	eax
	sete	dl
	movzx	eax, dl
	mov	edx, DWORD PTR _iY$[esp+60]
	push	eax
	push	edx
	mov	ecx, esi
	push	edi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	add	eax, ebx
	pop	edi

; 1472 : 
; 1473 : 		iItemValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1477 : }

	add	esp, 40					; 00000028H
	ret	20					; 00000014H
$LN190@GetCityVal:
	pop	edi
	pop	esi
	pop	ebp

; 1474 : 	}
; 1475 : 
; 1476 : 	return iItemValue;

	mov	eax, ebx
	pop	ebx

; 1477 : }

	add	esp, 40					; 00000028H
	ret	20					; 00000014H
	npad	3
$LN204@GetCityVal:
	DD	$LN17@GetCityVal
	DD	$LN16@GetCityVal
	DD	$LN15@GetCityVal
	DD	$LN14@GetCityVal
	DD	$LN13@GetCityVal
	DD	$LN13@GetCityVal
?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ENDP	; CvDealAI::GetCityValue
_TEXT	ENDS
PUBLIC	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue
EXTRN	?IsCramped@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsCramped
EXTRN	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceLevel
EXTRN	?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsToBeInfluentialOn
EXTRN	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsInfluentialOn
EXTRN	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z:PROC ; CvPlayerCulture::GetCivLowestInfluence
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z:PROC ; CvPlayer::GetProximityToPlayer
EXTRN	?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceOn
EXTRN	?GetTourism@CvPlayerCulture@@QAEHXZ:PROC	; CvPlayerCulture::GetTourism
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z:PROC ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?GetNumOurEnemiesPlayerAtWarWith@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetNumOurEnemiesPlayerAtWarWith
; Function compile flags: /Ogtpy
;	COMDAT ?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_bFromMe$ = 8						; size = 1
tv288 = 12						; size = 4
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetOpenBordersValue, COMDAT
; _this$ = ecx

; 1535 : {

	push	ebp
	push	edi

; 1536 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of Open Borders with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1537 : 
; 1538 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true);

	mov	edi, DWORD PTR _eOtherPlayer$[esp+4]
	mov	ebp, ecx
	mov	ecx, DWORD PTR [ebp]
	push	1
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 1539 : 
; 1540 : 	// If we're friends, then OB is always equally valuable to both parties
; 1541 : 	if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)

	cmp	eax, 5
	jne	SHORT $LN43@GetOpenBor
	pop	edi

; 1542 : 		return 50;

	mov	eax, 50					; 00000032H
	pop	ebp

; 1720 : }

	ret	12					; 0000000cH
$LN43@GetOpenBor:

; 1543 : 
; 1544 : 	int iItemValue = 0;
; 1545 : 
; 1546 : 	// Me giving Open Borders to the other guy
; 1547 : 	if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+4], 0
	push	ebx
	push	esi
	je	$LN42@GetOpenBor

; 1548 : 	{
; 1549 : 		// Approach is important
; 1550 : 		switch(eApproach)

	dec	eax
	cmp	eax, 5
	ja	SHORT $LN34@GetOpenBor
	jmp	DWORD PTR $LN99@GetOpenBor[eax*4]
$LN39@GetOpenBor:

; 1551 : 		{
; 1552 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1553 : 			iItemValue = 1000;

	mov	esi, 1000				; 000003e8H

; 1554 : 			break;
; 1555 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1556 : 			iItemValue = 100;
; 1557 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN37@GetOpenBor:

; 1558 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1559 : 			iItemValue = 20;

	mov	esi, 20					; 00000014H

; 1560 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN36@GetOpenBor:

; 1561 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1562 : 			iItemValue = 50;

	mov	esi, 50					; 00000032H

; 1563 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN35@GetOpenBor:

; 1564 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1565 : 			iItemValue = 75;

	mov	esi, 75					; 0000004bH

; 1566 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN34@GetOpenBor:

; 1567 : 		default:
; 1568 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Open Borders valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1569 : 			iItemValue = 100;

	mov	esi, 100				; 00000064H
$LN40@GetOpenBor:

; 1570 : 			break;
; 1571 : 		}
; 1572 : 
; 1573 : 		// Opinion also matters
; 1574 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	cmp	eax, 6
	ja	SHORT $LN91@GetOpenBor
	jmp	DWORD PTR $LN100@GetOpenBor[eax*4]
$LN31@GetOpenBor:

; 1575 : 		{
; 1576 : 		case MAJOR_CIV_OPINION_ALLY:
; 1577 : 			iItemValue = 0;

	xor	esi, esi

; 1578 : 			break;

	jmp	SHORT $LN91@GetOpenBor
$LN30@GetOpenBor:

; 1579 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1580 : 			iItemValue *= 35;

	imul	esi, 35					; 00000023H
$LN96@GetOpenBor:

; 1581 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax

; 1582 : 			break;

	jmp	SHORT $LN91@GetOpenBor
$LN29@GetOpenBor:

; 1583 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1584 : 			iItemValue *= 70;

	imul	esi, 70					; 00000046H
$LN97@GetOpenBor:

; 1585 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 1586 : 			break;

	jmp	SHORT $LN91@GetOpenBor
$LN27@GetOpenBor:

; 1587 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1588 : 			break;
; 1589 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1590 : 			iItemValue *= 150;

	imul	esi, 150				; 00000096H

; 1591 : 			iItemValue /= 100;
; 1592 : 			break;

	jmp	SHORT $LN96@GetOpenBor
$LN26@GetOpenBor:

; 1593 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1594 : 			iItemValue *= 400;

	imul	esi, 400				; 00000190H

; 1595 : 			iItemValue /= 100;
; 1596 : 			break;

	jmp	SHORT $LN97@GetOpenBor
$LN25@GetOpenBor:

; 1597 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1598 : 			iItemValue = 10000;

	mov	esi, 10000				; 00002710H
$LN91@GetOpenBor:

; 1599 : 			break;
; 1600 : 		default:
; 1601 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Open Borders valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1602 : 			break;
; 1603 : 		}
; 1604 : 
; 1605 : 		// If they're at war with our enemies then we're more likely to give them OB
; 1606 : 		int iNumEnemiesAtWarWith = GetPlayer()->GetDiplomacyAI()->GetNumOurEnemiesPlayerAtWarWith(eOtherPlayer);

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumOurEnemiesPlayerAtWarWith@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumOurEnemiesPlayerAtWarWith

; 1607 : 		if(iNumEnemiesAtWarWith >= 2)

	cmp	eax, 2
	jl	SHORT $LN23@GetOpenBor

; 1608 : 		{
; 1609 : 			iItemValue *= 10;

	lea	esi, DWORD PTR [esi+esi*4]
	add	esi, esi

; 1610 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
	jmp	SHORT $LN21@GetOpenBor
$LN23@GetOpenBor:

; 1611 : 		}
; 1612 : 		else if(iNumEnemiesAtWarWith == 1)

	cmp	eax, 1
	jne	SHORT $LN21@GetOpenBor

; 1613 : 		{
; 1614 : 			iItemValue *= 25;

	imul	esi, 25					; 00000019H

; 1615 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx
$LN21@GetOpenBor:

; 1616 : 		}
; 1617 : 
; 1618 : 		// Do we think he's going for culture victory?
; 1619 : 		AIGrandStrategyTypes eCultureStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET $SG222596
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebx, eax

; 1620 : 		if (eCultureStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eOtherPlayer) == eCultureStrategy)

	cmp	ebx, -1
	je	$LN90@GetOpenBor
	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy
	cmp	eax, ebx
	jne	$LN90@GetOpenBor

; 1621 : 		{
; 1622 : 			CvPlayer &kOtherPlayer = GET_PLAYER(eOtherPlayer);

	mov	ebx, edi
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1623 : 
; 1624 : 			// If he has tourism and he's not influential on us yet, resist!
; 1625 : 			if (kOtherPlayer.GetCulture()->GetTourism() > 0 && kOtherPlayer.GetCulture()->GetInfluenceOn(GetPlayer()->GetID()) < INFLUENCE_LEVEL_INFLUENTIAL)

	mov	ecx, ebx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	test	eax, eax
	jle	$LN90@GetOpenBor
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, ebx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceOn
	cmp	eax, 4
	jge	$LN90@GetOpenBor

; 1626 : 			{
; 1627 : 				iItemValue *= 500;

	imul	esi, 500				; 000001f4H

; 1628 : 				iItemValue /= 100;
; 1629 : 			}
; 1630 : 		}
; 1631 : 	}
; 1632 : 	// Other guy giving me Open Borders
; 1633 : 	else

	jmp	$LN98@GetOpenBor
$LN42@GetOpenBor:

; 1634 : 	{
; 1635 : 		// Proximity is very important
; 1636 : 		switch(GetPlayer()->GetProximityToPlayer(eOtherPlayer))

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, 3
	ja	SHORT $LN11@GetOpenBor
	jmp	DWORD PTR $LN101@GetOpenBor[eax*4]
$LN15@GetOpenBor:

; 1637 : 		{
; 1638 : 		case PLAYER_PROXIMITY_DISTANT:
; 1639 : 			iItemValue = 5;

	mov	esi, 5

; 1640 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN14@GetOpenBor:

; 1641 : 		case PLAYER_PROXIMITY_FAR:
; 1642 : 			iItemValue = 10;

	mov	esi, 10					; 0000000aH

; 1643 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN13@GetOpenBor:

; 1644 : 		case PLAYER_PROXIMITY_CLOSE:
; 1645 : 			iItemValue = 15;

	mov	esi, 15					; 0000000fH

; 1646 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN12@GetOpenBor:

; 1647 : 		case PLAYER_PROXIMITY_NEIGHBORS:
; 1648 : 			iItemValue = 30;

	mov	esi, 30					; 0000001eH

; 1649 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN11@GetOpenBor:

; 1650 : 		default:
; 1651 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Proximity for Open Borders valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1652 : 			iItemValue = 0;

	xor	esi, esi
$LN16@GetOpenBor:

; 1653 : 			break;
; 1654 : 		}
; 1655 : 
; 1656 : 		// Reduce value by half if the other guy only has a single City
; 1657 : 		if(GET_PLAYER(eOtherPlayer).getNumCities() == 1)

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jne	SHORT $LN10@GetOpenBor

; 1658 : 		{
; 1659 : 			iItemValue *= 50;

	imul	esi, 50					; 00000032H

; 1660 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx
$LN10@GetOpenBor:

; 1661 : 		}
; 1662 : 
; 1663 : 		// Boost value greatly if we are going for a culture win
; 1664 : 		// If going for culture win always want open borders against civs we need influence on
; 1665 : 		AIGrandStrategyTypes eCultureStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET $SG222613
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebx, eax

; 1666 : #ifdef AUI_WARNING_FIXES
; 1667 : 		const CvPlayerCulture* pPlayerCulture = GetPlayer()->GetCulture();
; 1668 : 		if (eCultureStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eCultureStrategy && pPlayerCulture->GetTourism() > 0)
; 1669 : 		{
; 1670 : 			// The civ we need influence on the most should ALWAYS be included
; 1671 : 			if (pPlayerCulture->GetCivLowestInfluence(false /*bCheckOpenBorders*/) == eOtherPlayer)
; 1672 : #else
; 1673 : 		if (eCultureStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eCultureStrategy && GetPlayer()->GetCulture()->GetTourism() > 0 )

	cmp	ebx, -1
	je	$LN90@GetOpenBor
	mov	ecx, DWORD PTR [ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, ebx
	jne	$LN90@GetOpenBor
	mov	ecx, DWORD PTR [ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	test	eax, eax
	jle	$LN90@GetOpenBor

; 1674 : 		{
; 1675 : 			// The civ we need influence on the most should ALWAYS be included
; 1676 : 			if (GetPlayer()->GetCulture()->GetCivLowestInfluence(false /*bCheckOpenBorders*/) == eOtherPlayer)

	mov	ecx, DWORD PTR [ebp]
	push	0
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z ; CvPlayerCulture::GetCivLowestInfluence
	cmp	eax, edi
	jne	SHORT $LN8@GetOpenBor

; 1677 : #endif
; 1678 : 			{
; 1679 : 				iItemValue *= 1000;

	imul	esi, 1000				; 000003e8H

; 1680 : 				iItemValue /= 100;

	jmp	SHORT $LN98@GetOpenBor
$LN8@GetOpenBor:

; 1681 : 			}
; 1682 : 
; 1683 : 			// If have influence over half the civs, want OB with the other half
; 1684 : #ifdef AUI_WARNING_FIXES
; 1685 : 			else if (pPlayerCulture->GetNumCivsToBeInfluentialOn() <= pPlayerCulture->GetNumCivsInfluentialOn())
; 1686 : 			{
; 1687 : 				if (pPlayerCulture->GetInfluenceLevel(eOtherPlayer) < INFLUENCE_LEVEL_INFLUENTIAL)
; 1688 : #else
; 1689 : 			else if (GetPlayer()->GetCulture()->GetNumCivsToBeInfluentialOn() <= GetPlayer()->GetCulture()->GetNumCivsInfluentialOn())

	mov	ebx, DWORD PTR [ebp]
	mov	ecx, ebx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	mov	ecx, ebx
	mov	DWORD PTR tv288[esp+12], eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsToBeInfluentialOn
	mov	ecx, DWORD PTR tv288[esp+12]
	cmp	eax, ecx

; 1690 : 			{
; 1691 : 				if (GetPlayer()->GetCulture()->GetInfluenceLevel(eOtherPlayer) < INFLUENCE_LEVEL_INFLUENTIAL)

	mov	ecx, DWORD PTR [ebp]
	push	edi
	jg	SHORT $LN6@GetOpenBor
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	cmp	eax, 4
	jge	SHORT $LN90@GetOpenBor

; 1692 : #endif
; 1693 : 				{
; 1694 : 					iItemValue *= 500;

	imul	esi, 500				; 000001f4H

; 1695 : 					iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 1696 : 				}
; 1697 : 			}

	jmp	SHORT $LN90@GetOpenBor
$LN6@GetOpenBor:

; 1698 : 
; 1699 : 			else if (GetPlayer()->GetProximityToPlayer(eOtherPlayer) == PLAYER_PROXIMITY_NEIGHBORS)

	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, 3
	jne	SHORT $LN90@GetOpenBor

; 1700 : 			{
; 1701 : 				// If we're cramped then we want OB more with our neighbors
; 1702 : 				if(GetPlayer()->IsCramped())

	mov	ecx, DWORD PTR [ebp]
	call	?IsCramped@CvPlayer@@QBE_NXZ		; CvPlayer::IsCramped
	test	al, al
	je	SHORT $LN90@GetOpenBor

; 1703 : 				{
; 1704 : 					iItemValue *= 300;

	imul	esi, 300				; 0000012cH
$LN98@GetOpenBor:

; 1705 : 					iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN90@GetOpenBor:

; 1706 : 				}
; 1707 : 			}
; 1708 : 		}
; 1709 : 	}
; 1710 : 
; 1711 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1712 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+12], 0
	je	SHORT $LN1@GetOpenBor

; 1713 : 	{
; 1714 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetOpenBordersValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR [ebp]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+44]
	cmp	BYTE PTR _bFromMe$[esp+12], 0
	push	0
	push	eax
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, edi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue
	add	eax, esi

; 1715 : 
; 1716 : 		iItemValue /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
$LN1@GetOpenBor:

; 1717 : 	}
; 1718 : 
; 1719 : 	return iItemValue;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 1720 : }

	ret	12					; 0000000cH
	npad	2
$LN99@GetOpenBor:
	DD	$LN39@GetOpenBor
	DD	$LN34@GetOpenBor
	DD	$LN34@GetOpenBor
	DD	$LN37@GetOpenBor
	DD	$LN36@GetOpenBor
	DD	$LN35@GetOpenBor
$LN100@GetOpenBor:
	DD	$LN25@GetOpenBor
	DD	$LN26@GetOpenBor
	DD	$LN27@GetOpenBor
	DD	$LN91@GetOpenBor
	DD	$LN29@GetOpenBor
	DD	$LN30@GetOpenBor
	DD	$LN31@GetOpenBor
$LN101@GetOpenBor:
	DD	$LN15@GetOpenBor
	DD	$LN14@GetOpenBor
	DD	$LN13@GetOpenBor
	DD	$LN12@GetOpenBor
?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetOpenBordersValue
_TEXT	ENDS
PUBLIC	?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetDefensivePactValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetDefensivePactValue, COMDAT
; _this$ = ecx

; 1724 : {

	push	ebx

; 1725 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Defensive Pact with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1726 : 
; 1727 : 	int iItemValue;
; 1728 : 
; 1729 : 	// What is a Defensive Pact with eOtherPlayer worth to US?
; 1730 : 	if(!bFromMe)

	mov	bl, BYTE PTR _bFromMe$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _eOtherPlayer$[esp+8]
	push	edi
	mov	ebp, ecx
	test	bl, bl
	jne	SHORT $LN13@GetDefensi

; 1731 : 	{
; 1732 : 		iItemValue = 100;

	mov	edi, 100				; 00000064H

; 1733 : 		//	// How strong are they compared to us?
; 1734 : 		//	switch (GetPlayer()->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eOtherPlayer))
; 1735 : 		//	{
; 1736 : 		//	case STRENGTH_PATHETIC:
; 1737 : 		//		iItemValue = 10;
; 1738 : 		//		break;
; 1739 : 		//	case STRENGTH_WEAK:
; 1740 : 		//		iItemValue = 40;
; 1741 : 		//		break;
; 1742 : 		//	case STRENGTH_POOR:
; 1743 : 		//		iItemValue = 70;
; 1744 : 		//		break;
; 1745 : 		//	case STRENGTH_AVERAGE:
; 1746 : 		//		iItemValue = 100;
; 1747 : 		//		break;
; 1748 : 		//	case STRENGTH_STRONG:
; 1749 : 		//		iItemValue = 130;
; 1750 : 		//		break;
; 1751 : 		//	case STRENGTH_POWERFUL:
; 1752 : 		//		iItemValue = 150;
; 1753 : 		//		break;
; 1754 : 		//	case STRENGTH_IMMENSE:
; 1755 : 		//		iItemValue = 200;
; 1756 : 		//		break;
; 1757 : 		//	default:
; 1758 : 		//		CvAssertMsg(false, "DEAL_AI: AI player has no valid MilitaryStrengthComparedToUs for Defensive Pact valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1759 : 		//		iItemValue = 100;
; 1760 : 		//		break;
; 1761 : 		//	}
; 1762 : 	}
; 1763 : 	// How much do we value giving away a Defensive Pact?
; 1764 : 	else

	jmp	SHORT $LN10@GetDefensi
$LN13@GetDefensi:

; 1765 : 	{
; 1766 : 		// Opinion also matters
; 1767 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	cmp	eax, 6
	ja	SHORT $LN2@GetDefensi
	jmp	DWORD PTR $LN28@GetDefensi[eax*4]
$LN9@GetDefensi:

; 1768 : 		{
; 1769 : 		case MAJOR_CIV_OPINION_ALLY:
; 1770 : 			iItemValue = 100;

	mov	edi, 100				; 00000064H

; 1771 : 			break;

	jmp	SHORT $LN10@GetDefensi
$LN2@GetDefensi:

; 1772 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1773 : 			iItemValue = 100;
; 1774 : 			break;
; 1775 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1776 : 			iItemValue = 100;
; 1777 : 			break;
; 1778 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1779 : 			iItemValue = 100000;
; 1780 : 			break;
; 1781 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1782 : 			iItemValue = 100000;
; 1783 : 			break;
; 1784 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1785 : 			iItemValue = 100000;
; 1786 : 			break;
; 1787 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1788 : 			iItemValue = 100000;
; 1789 : 			break;
; 1790 : 		default:
; 1791 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Defensive Pact valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1792 : 			iItemValue = 100000;

	mov	edi, 100000				; 000186a0H
$LN10@GetDefensi:

; 1793 : 			break;
; 1794 : 		}
; 1795 : 
; 1796 : 		// Approach is important
; 1797 : 		//switch (GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))
; 1798 : 		//{
; 1799 : 		//case MAJOR_CIV_APPROACH_HOSTILE:
; 1800 : 		//	iItemValue *= 200;	// Value should already be increased above by Opinion as well
; 1801 : 		//	break;
; 1802 : 		//case MAJOR_CIV_APPROACH_GUARDED:
; 1803 : 		//	iItemValue *= 100;	// If we're guarded against someone, getting a Defensive Pact is kinda nice
; 1804 : 		//	break;
; 1805 : 		//case MAJOR_CIV_APPROACH_AFRAID:
; 1806 : 		//	iItemValue *= 80;		// If we're afraid of eOtherPlayer, we couldn't be happier to sign a Defensive Pact with them!
; 1807 : 		//	break;
; 1808 : 		//case MAJOR_CIV_APPROACH_FRIENDLY:
; 1809 : 		//	iItemValue *= 100;
; 1810 : 		//	break;
; 1811 : 		//case MAJOR_CIV_APPROACH_NEUTRAL:
; 1812 : 		//	iItemValue *= 100;
; 1813 : 		//	break;
; 1814 : 		//default:
; 1815 : 		//	CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Defensive Pact valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1816 : 		//	iItemValue *= 100;
; 1817 : 		//	break;
; 1818 : 		//}
; 1819 : 		//iItemValue /= 100;
; 1820 : 	}
; 1821 : 
; 1822 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1823 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+12], 0
	je	SHORT $LN26@GetDefensi

; 1824 : 	{
; 1825 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetDefensivePactValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	eax, DWORD PTR [ebp]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	push	0
	test	bl, bl
	push	eax
	sete	dl
	movzx	eax, dl
	mov	ecx, esi
	push	eax
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetDefensivePactValue
	add	eax, edi
	pop	edi

; 1826 : 
; 1827 : 		iItemValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1831 : }

	ret	12					; 0000000cH
$LN26@GetDefensi:

; 1828 : 	}
; 1829 : 
; 1830 : 	return iItemValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1831 : }

	ret	12					; 0000000cH
	npad	1
$LN28@GetDefensi:
	DD	$LN2@GetDefensi
	DD	$LN2@GetDefensi
	DD	$LN2@GetDefensi
	DD	$LN2@GetDefensi
	DD	$LN9@GetDefensi
	DD	$LN9@GetDefensi
	DD	$LN9@GetDefensi
?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetDefensivePactValue
_TEXT	ENDS
PUBLIC	?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetResearchAgreementValue
EXTRN	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ:PROC	; CvTeam::GetCurrentEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
$T226501 = 8						; size = 4
_bFromMe$ = 8						; size = 1
$T226502 = 12						; size = 4
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetResearchAgreementValue, COMDAT
; _this$ = ecx

; 1835 : {

	push	ebx

; 1836 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Research Agreement with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1837 : 
; 1838 : 	int iItemValue = 100;
; 1839 : 
; 1840 : 	if(bFromMe)

	mov	bl, BYTE PTR _bFromMe$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _eOtherPlayer$[esp+12]
	mov	ebp, ecx
	mov	esi, 100				; 00000064H
	test	bl, bl
	je	$LN10@GetResearc

; 1841 : 	{
; 1842 : 		// if they are ahead of me in tech by one or more eras ratchet up the value since they are more likely to get a good tech than I am
; 1843 : 		EraTypes eMyEra = GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@GetResearc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN20@GetResearc
$LN19@GetResearc:
	or	eax, -1
$LN20@GetResearc:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra

; 1844 : 		EraTypes eTheirEra = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	mov	eax, edi
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN32@GetResearc
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN33@GetResearc
$LN32@GetResearc:
	or	eax, -1
$LN33@GetResearc:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra

; 1845 : 
; 1846 : 		int iAdditionalValue = iItemValue * max(0,(int)(eTheirEra-eMyEra));

	sub	eax, esi
	mov	DWORD PTR $T226501[esp+12], eax
	test	eax, eax
	mov	DWORD PTR $T226502[esp+12], 0
	lea	eax, DWORD PTR $T226501[esp+12]
	jg	SHORT $LN42@GetResearc
	lea	eax, DWORD PTR $T226502[esp+12]
$LN42@GetResearc:

; 1847 : 		iItemValue += iAdditionalValue;

	mov	esi, DWORD PTR [eax]

; 1848 : 
; 1849 : 		// Approach is important
; 1850 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	mov	ecx, DWORD PTR [ebp]
	push	1
	inc	esi
	push	edi
	imul	esi, 100				; 00000064H
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN2@GetResearc
	jmp	DWORD PTR $LN55@GetResearc[eax*4]
$LN7@GetResearc:

; 1851 : 		{
; 1852 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1853 : 			iItemValue *= 1000;

	imul	esi, 1000				; 000003e8H

; 1854 : 			break;
; 1855 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1856 : 			iItemValue *= 100;
; 1857 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN5@GetResearc:

; 1858 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1859 : 			iItemValue *= 80;

	lea	esi, DWORD PTR [esi+esi*4]
	shl	esi, 4

; 1860 : 			break;
; 1861 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1862 : 			iItemValue *= 100;
; 1863 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN2@GetResearc:

; 1864 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1865 : 			iItemValue *= 100;
; 1866 : 			break;
; 1867 : 		default:
; 1868 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Research Agreement valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1869 : 			iItemValue *= 100;

	imul	esi, 100				; 00000064H
$LN8@GetResearc:

; 1870 : 			break;
; 1871 : 		}
; 1872 : 		iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@GetResearc:

; 1873 : 
; 1874 : 	}
; 1875 : 
; 1876 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1877 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+12], 0
	je	SHORT $LN53@GetResearc

; 1878 : 	{
; 1879 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetResearchAgreementValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	edx, DWORD PTR [ebp]
	imul	edi, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+44]
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	test	bl, bl
	sete	al
	movzx	edx, al
	mov	ecx, edi
	push	edx
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetResearchAgreementValue
	add	eax, esi
	pop	edi

; 1880 : 
; 1881 : 		iItemValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1885 : }

	ret	12					; 0000000cH
$LN53@GetResearc:
	pop	edi

; 1882 : 	}
; 1883 : 
; 1884 : 	return iItemValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1885 : }

	ret	12					; 0000000cH
$LN55@GetResearc:
	DD	$LN7@GetResearc
	DD	$LN2@GetResearc
	DD	$LN2@GetResearc
	DD	$LN5@GetResearc
	DD	$LN2@GetResearc
	DD	$LN2@GetResearc
?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetResearchAgreementValue
_TEXT	ENDS
PUBLIC	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetTradeAgreementValue, COMDAT
; _this$ = ecx

; 1889 : {

	push	ebx

; 1890 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Trade Agreement with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1891 : 
; 1892 : 	int iItemValue = 100;
; 1893 : 
; 1894 : 	if(bFromMe)

	mov	bl, BYTE PTR _bFromMe$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _eOtherPlayer$[esp+8]
	push	edi
	mov	ebp, ecx
	mov	edi, 100				; 00000064H
	test	bl, bl
	je	SHORT $LN10@GetTradeAg

; 1895 : 	{
; 1896 : 		// Approach is important
; 1897 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	mov	ecx, DWORD PTR [ebp]
	push	1
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN2@GetTradeAg
	jmp	DWORD PTR $LN25@GetTradeAg[eax*4]
$LN7@GetTradeAg:

; 1898 : 		{
; 1899 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1900 : 			iItemValue *= 250;

	mov	ecx, 25000				; 000061a8H

; 1901 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN6@GetTradeAg:

; 1902 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1903 : 			iItemValue *= 130;

	mov	ecx, 13000				; 000032c8H

; 1904 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN5@GetTradeAg:

; 1905 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1906 : 			iItemValue *= 80;

	mov	ecx, 8000				; 00001f40H

; 1907 : 			break;
; 1908 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1909 : 			iItemValue *= 100;
; 1910 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN3@GetTradeAg:

; 1911 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1912 : 			iItemValue *= 110;

	mov	ecx, 11000				; 00002af8H

; 1913 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN2@GetTradeAg:

; 1914 : 		default:
; 1915 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Research Agreement valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1916 : 			iItemValue *= 100;

	mov	ecx, 10000				; 00002710H
$LN8@GetTradeAg:

; 1917 : 			break;
; 1918 : 		}
; 1919 : 		iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
$LN10@GetTradeAg:

; 1920 : 	}
; 1921 : 
; 1922 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1923 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+12], 0
	je	SHORT $LN23@GetTradeAg

; 1924 : 	{
; 1925 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetTradeAgreementValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	eax, DWORD PTR [ebp]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	push	0
	test	bl, bl
	push	eax
	sete	dl
	movzx	eax, dl
	mov	ecx, esi
	push	eax
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
	add	eax, edi
	pop	edi

; 1926 : 
; 1927 : 		iItemValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1931 : }

	ret	12					; 0000000cH
$LN23@GetTradeAg:

; 1928 : 	}
; 1929 : 
; 1930 : 	return iItemValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1931 : }

	ret	12					; 0000000cH
	npad	2
$LN25@GetTradeAg:
	DD	$LN7@GetTradeAg
	DD	$LN2@GetTradeAg
	DD	$LN6@GetTradeAg
	DD	$LN5@GetTradeAg
	DD	$LN2@GetTradeAg
	DD	$LN3@GetTradeAg
?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetTradeAgreementValue
_TEXT	ENDS
PUBLIC	?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyPeaceValue
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pDiploAI$ = -12					; size = 4
_eWarProjection$ = -8					; size = 4
_eOurEra$ = -4						; size = 4
_bFromMe$ = 8						; size = 1
_eOpinionTowardsAskingPlayer$ = 12			; size = 4
_eOtherPlayer$ = 12					; size = 4
_eOpinionTowardsWarPlayer$ = 16				; size = 4
_eWithTeam$ = 16					; size = 4
?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDealAI::GetThirdPartyPeaceValue, COMDAT
; _this$ = ecx

; 1980 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebx, ecx

; 1981 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Third Party Peace with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1982 : 
; 1983 : 	int iItemValue = 0;
; 1984 : 
; 1985 : 	CvDiplomacyAI* pDiploAI = GetPlayer()->GetDiplomacyAI();

	mov	ecx, DWORD PTR [ebx]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+32], ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	esi, eax

; 1986 : 
; 1987 : 	PlayerTypes eWithPlayer = NO_PLAYER;
; 1988 : 
; 1989 : 	// find the first player associated with the team
; 1990 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	xor	edi, edi
	mov	DWORD PTR _pDiploAI$[esp+32], esi
	add	ecx, 44					; 0000002cH
	npad	5
$LL28@GetThirdPa:

; 1991 : 	{
; 1992 : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 1993 : 		if (GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).getTeam() == eWithTeam) 

	cmp	BYTE PTR [ecx+2212], 0
	je	SHORT $LN27@GetThirdPa
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN45@GetThirdPa
	mov	ebp, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	jmp	SHORT $LN46@GetThirdPa
$LN45@GetThirdPa:
	or	eax, -1
$LN46@GetThirdPa:
	cmp	eax, DWORD PTR _eWithTeam$[esp+28]
	je	SHORT $LN94@GetThirdPa
$LN27@GetThirdPa:

; 1986 : 
; 1987 : 	PlayerTypes eWithPlayer = NO_PLAYER;
; 1988 : 
; 1989 : 	// find the first player associated with the team
; 1990 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	inc	edi
	add	ecx, 63236				; 0000f704H
	cmp	edi, 63					; 0000003fH
	jb	SHORT $LL28@GetThirdPa
	pop	edi
	pop	esi
	pop	ebp

; 2002 : 	{
; 2003 : 		return 0;

	xor	eax, eax
	pop	ebx

; 2092 : 	}
; 2093 : 
; 2094 : 	return iItemValue;
; 2095 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN94@GetThirdPa:

; 1994 : 		{
; 1995 : 			eWithPlayer = ePlayer;
; 1996 : 			break;
; 1997 : 		}
; 1998 : 	}
; 1999 : 
; 2000 : 	CvAssertMsg(eWithPlayer != NO_PLAYER, "eWithPlayer could not be found");
; 2001 : 	if (eWithPlayer == NO_PLAYER)

	cmp	edi, -1
	jne	SHORT $LN24@GetThirdPa
$LN96@GetThirdPa:
	pop	edi
	pop	esi
	pop	ebp

; 2002 : 	{
; 2003 : 		return 0;

	xor	eax, eax
	pop	ebx

; 2092 : 	}
; 2093 : 
; 2094 : 	return iItemValue;
; 2095 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN24@GetThirdPa:

; 2004 : 	}
; 2005 : 
; 2006 : 	WarProjectionTypes eWarProjection = pDiploAI->GetWarProjection(eWithPlayer);

	push	edi
	mov	ecx, esi
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection
	mov	DWORD PTR _eWarProjection$[esp+32], eax

; 2007 : 
; 2008 : 	EraTypes eOurEra = GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN56@GetThirdPa
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN57@GetThirdPa
$LN56@GetThirdPa:
	or	eax, -1
$LN57@GetThirdPa:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra

; 2009 : 
; 2010 : 	MajorCivOpinionTypes eOpinionTowardsAskingPlayer = pDiploAI->GetMajorCivOpinion(eOtherPlayer);

	mov	ebp, DWORD PTR _eOtherPlayer$[esp+28]
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _eOurEra$[esp+36], eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion

; 2011 : 	MajorCivOpinionTypes eOpinionTowardsWarPlayer = NO_MAJOR_CIV_OPINION_TYPE;
; 2012 : 
; 2013 : 	bool bMinor = false;
; 2014 : 
; 2015 : 	// Minor
; 2016 : 	if(GET_PLAYER(eWithPlayer).isMinorCiv())

	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	mov	DWORD PTR _eOpinionTowardsAskingPlayer$[esp+28], eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR _eOpinionTowardsWarPlayer$[esp+28], -1
	xor	bl, bl
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN23@GetThirdPa

; 2017 : 	{
; 2018 : 		// if we're at war with the opponent, then this must be a peace deal. In this case we should evaluate minor civ peace deals as zero
; 2019 : 		if (GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eOtherPlayer).getTeam()))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN71@GetThirdPa
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN72@GetThirdPa
$LN71@GetThirdPa:
	or	ecx, -1
$LN72@GetThirdPa:
	mov	edi, DWORD PTR _this$[esp+32]
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN80@GetThirdPa
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN81@GetThirdPa
$LN80@GetThirdPa:
	or	eax, -1
$LN81@GetThirdPa:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN21@GetThirdPa

; 2020 : 		{
; 2021 : 			PlayerTypes eMinorAlly = GET_PLAYER(eWithPlayer).GetMinorCivAI()->GetAlly();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 2022 : 			// if they are allied with the city state or we are allied with the city state
; 2023 : 			if (eMinorAlly == eOtherPlayer || eMinorAlly == m_pPlayer->GetID())

	cmp	eax, ebp
	je	$LN96@GetThirdPa
	mov	ecx, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+44]

; 2024 : 			{
; 2025 : 				return 0;

	je	$LN96@GetThirdPa
$LN21@GetThirdPa:

; 2026 : 			}
; 2027 : 		}
; 2028 : 
; 2029 : 		bMinor = true;
; 2030 : 	}
; 2031 : 	// Major
; 2032 : 	else

	mov	edx, DWORD PTR _eOpinionTowardsWarPlayer$[esp+28]
	mov	bl, 1
	jmp	SHORT $LN19@GetThirdPa
$LN23@GetThirdPa:

; 2033 : 		eOpinionTowardsWarPlayer = pDiploAI->GetMajorCivOpinion(eWithPlayer);

	mov	ecx, DWORD PTR _pDiploAI$[esp+32]
	push	edi
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	edx, eax
$LN19@GetThirdPa:

; 2034 : 
; 2035 : 	// From me
; 2036 : 	if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+28], 0
	je	$LN18@GetThirdPa

; 2037 : 	{
; 2038 : 		if(eWarProjection == WAR_PROJECTION_VERY_GOOD)

	mov	eax, DWORD PTR _eWarProjection$[esp+32]
	cmp	eax, 5
	jne	SHORT $LN17@GetThirdPa

; 2039 : 			iItemValue = 600;

	mov	eax, 600				; 00000258H
	jmp	SHORT $LN13@GetThirdPa
$LN17@GetThirdPa:

; 2040 : 		else if(eWarProjection == WAR_PROJECTION_GOOD)

	cmp	eax, 4
	jne	SHORT $LN15@GetThirdPa

; 2041 : 			iItemValue = 400;

	mov	eax, 400				; 00000190H
	jmp	SHORT $LN13@GetThirdPa
$LN15@GetThirdPa:

; 2042 : 		else if(eWarProjection == WAR_PROJECTION_UNKNOWN)

	sub	eax, 3
	neg	eax
	sbb	eax, eax
	and	eax, -50				; ffffffceH
	add	eax, 250				; 000000faH
$LN13@GetThirdPa:

; 2043 : 			iItemValue = 250;
; 2044 : 		else
; 2045 : 			iItemValue = 200;
; 2046 : 
; 2047 : 		// Add 50 gold per era
; 2048 : 		int iExtraCost = eOurEra * 50;

	mov	ecx, DWORD PTR _eOurEra$[esp+32]
	imul	ecx, 50					; 00000032H

; 2049 : 		iItemValue += iExtraCost;

	add	eax, ecx

; 2050 : 
; 2051 : 		// Minors
; 2052 : 		if(bMinor)

	test	bl, bl
	jne	SHORT $LN7@GetThirdPa

; 2053 : 		{
; 2054 : 		}
; 2055 : 		// Majors
; 2056 : 		else
; 2057 : 		{
; 2058 : 			// Modify for our feelings towards the player we're at war with
; 2059 : 			if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)

	test	edx, edx
	jne	SHORT $LN9@GetThirdPa

; 2060 : 			{
; 2061 : 				iItemValue *= 300;

	mov	ecx, eax
	imul	ecx, 300				; 0000012cH

; 2062 : 				iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jmp	SHORT $LN7@GetThirdPa
$LN9@GetThirdPa:

; 2063 : 			}
; 2064 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_ENEMY)

	cmp	edx, 1
	jne	SHORT $LN7@GetThirdPa

; 2065 : 			{
; 2066 : 				iItemValue *= 200;

	mov	ecx, eax
	imul	ecx, 200				; 000000c8H

; 2067 : 				iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, ecx
$LN7@GetThirdPa:

; 2068 : 			}
; 2069 : 		}
; 2070 : 
; 2071 : 		// Modify for our feelings towards the asking player
; 2072 : 		if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_ALLY)

	mov	ecx, DWORD PTR _eOpinionTowardsAskingPlayer$[esp+28]
	cmp	ecx, 6
	jne	SHORT $LN6@GetThirdPa

; 2073 : 		{
; 2074 : 			iItemValue *= 30;

	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	add	ecx, ecx

; 2075 : 			iItemValue /= 100;

	jmp	SHORT $LN99@GetThirdPa
$LN6@GetThirdPa:

; 2076 : 		}
; 2077 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FRIEND)

	cmp	ecx, 5
	jne	SHORT $LN4@GetThirdPa

; 2078 : 		{
; 2079 : 			iItemValue *= 50;

	mov	ecx, eax
	imul	ecx, 50					; 00000032H

; 2080 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	ecx, edx
	pop	esi
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 2092 : 	}
; 2093 : 
; 2094 : 	return iItemValue;
; 2095 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN4@GetThirdPa:

; 2081 : 		}
; 2082 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FAVORABLE)

	cmp	ecx, 4
	jne	SHORT $LN29@GetThirdPa

; 2083 : 		{
; 2084 : 			iItemValue *= 75;

	mov	ecx, eax
	imul	ecx, 75					; 0000004bH
$LN99@GetThirdPa:

; 2085 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebp
	add	eax, edx
	pop	ebx

; 2092 : 	}
; 2093 : 
; 2094 : 	return iItemValue;
; 2095 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN18@GetThirdPa:

; 2086 : 		}
; 2087 : 	}
; 2088 : 	// From them
; 2089 : 	else
; 2090 : 	{
; 2091 : 		iItemValue = -10000;

	mov	eax, -10000				; ffffd8f0H
$LN29@GetThirdPa:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2092 : 	}
; 2093 : 
; 2094 : 	return iItemValue;
; 2095 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDealAI::GetThirdPartyPeaceValue
_TEXT	ENDS
PUBLIC	?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyWarValue
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z:PROC ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias
; Function compile flags: /Ogtpy
;	COMDAT ?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eWithPlayer$ = -12					; size = 4
_pDiploAI$ = -8						; size = 4
_iWarApproachWeight$ = -4				; size = 4
_bFromMe$ = 8						; size = 1
_eOpinionTowardsAskingPlayer$ = 12			; size = 4
_eOtherPlayer$ = 12					; size = 4
_eMinorApproachTowardsWarPlayer$ = 16			; size = 4
_eWithTeam$ = 16					; size = 4
?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDealAI::GetThirdPartyWarValue, COMDAT
; _this$ = ecx

; 2099 : {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	edi, ecx

; 2100 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Third Party War with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2101 : 
; 2102 : 	int iItemValue = 0;
; 2103 : 
; 2104 : 	CvDiplomacyAI* pDiploAI = GetPlayer()->GetDiplomacyAI();

	mov	ecx, DWORD PTR [edi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	esi, eax

; 2105 : 
; 2106 : 	// How much does this AI like to go to war? If it's a 3 or less, never accept
; 2107 : 	int iWarApproachWeight = pDiploAI->GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR);

	push	0
	mov	ecx, esi
	mov	DWORD PTR _pDiploAI$[esp+24], esi
	call	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias

; 2108 : 	if(bFromMe && iWarApproachWeight < 4)

	cmp	BYTE PTR _bFromMe$[esp+16], 0
	mov	DWORD PTR _iWarApproachWeight$[esp+20], eax
	je	SHORT $LN38@GetThirdPa@2
	cmp	eax, 4
	jge	SHORT $LN38@GetThirdPa@2
	pop	edi

; 2109 : 		return 100000;

	mov	eax, 100000				; 000186a0H
	pop	esi

; 2240 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN38@GetThirdPa@2:

; 2110 : 
; 2111 : 
; 2112 : 	PlayerTypes eWithPlayer = NO_PLAYER;

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes

; 2113 : 	// find the first player associated with the team
; 2114 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	xor	ecx, ecx
	push	ebp
	mov	DWORD PTR _eWithPlayer$[esp+28], -1
	add	edx, 44					; 0000002cH
$LL75@GetThirdPa@2:

; 2115 : 	{
; 2116 : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 2117 : 		if (GET_PLAYER(ePlayer).getTeam() == eWithTeam) 

	mov	eax, DWORD PTR [edx]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN49@GetThirdPa@2
	mov	ebp, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	jmp	SHORT $LN50@GetThirdPa@2
$LN49@GetThirdPa@2:
	or	eax, -1
$LN50@GetThirdPa@2:
	cmp	eax, DWORD PTR _eWithTeam$[esp+24]
	je	SHORT $LN72@GetThirdPa@2
	inc	ecx
	add	edx, 63236				; 0000f704H
	cmp	ecx, 63					; 0000003fH
	jb	SHORT $LL75@GetThirdPa@2
	jmp	SHORT $LN35@GetThirdPa@2
$LN72@GetThirdPa@2:

; 2118 : 		{
; 2119 : 			eWithPlayer = ePlayer;

	mov	DWORD PTR _eWithPlayer$[esp+28], ecx
$LN35@GetThirdPa@2:

; 2120 : 			break;
; 2121 : 		}
; 2122 : 	}
; 2123 : 	WarProjectionTypes eWarProjection = pDiploAI->GetWarProjection(eWithPlayer);

	mov	eax, DWORD PTR _eWithPlayer$[esp+28]
	push	eax
	mov	ecx, esi
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection

; 2124 : 
; 2125 : 	EraTypes eOurEra = GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR [edi]
	mov	ebp, eax
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN60@GetThirdPa@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN61@GetThirdPa@2
$LN60@GetThirdPa@2:
	or	eax, -1
$LN61@GetThirdPa@2:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra

; 2126 : 
; 2127 : 	MajorCivOpinionTypes eOpinionTowardsAskingPlayer = pDiploAI->GetMajorCivOpinion(eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$[esp+24]
	push	edx
	mov	ecx, esi
	mov	edi, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion

; 2128 : 	MajorCivOpinionTypes eOpinionTowardsWarPlayer = NO_MAJOR_CIV_OPINION_TYPE;
; 2129 : 	MinorCivApproachTypes eMinorApproachTowardsWarPlayer = NO_MINOR_CIV_APPROACH;
; 2130 : 
; 2131 : 	bool bMinor = false;
; 2132 : 
; 2133 : 	// Minor
; 2134 : 	if(GET_PLAYER(eWithPlayer).isMinorCiv())

	mov	ecx, DWORD PTR _eWithPlayer$[esp+28]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	or	esi, -1
	mov	DWORD PTR _eOpinionTowardsAskingPlayer$[esp+24], eax
	mov	DWORD PTR _eMinorApproachTowardsWarPlayer$[esp+24], esi
	xor	bl, bl
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN33@GetThirdPa@2

; 2135 : 	{
; 2136 : 		bMinor = true;
; 2137 : 		eMinorApproachTowardsWarPlayer = pDiploAI->GetMinorCivApproach(eWithPlayer);

	mov	eax, DWORD PTR _eWithPlayer$[esp+28]
	mov	ecx, DWORD PTR _pDiploAI$[esp+28]
	push	eax
	mov	bl, 1
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	mov	DWORD PTR _eMinorApproachTowardsWarPlayer$[esp+24], eax

; 2138 : 	}
; 2139 : 	// Major
; 2140 : 	else

	jmp	SHORT $LN32@GetThirdPa@2
$LN33@GetThirdPa@2:

; 2141 : 		eOpinionTowardsWarPlayer = pDiploAI->GetMajorCivOpinion(eWithPlayer);

	mov	ecx, DWORD PTR _eWithPlayer$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[esp+32]
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	esi, eax
$LN32@GetThirdPa@2:

; 2142 : 
; 2143 : 	// From me
; 2144 : 	if(bFromMe)

	cmp	BYTE PTR _bFromMe$[esp+24], 0
	je	$LN31@GetThirdPa@2

; 2145 : 	{
; 2146 : 		if(eWarProjection >= WAR_PROJECTION_GOOD)

	cmp	ebp, 4
	jl	SHORT $LN30@GetThirdPa@2

; 2147 : 			iItemValue = 400;

	mov	ecx, 400				; 00000190H
	jmp	SHORT $LN26@GetThirdPa@2
$LN30@GetThirdPa@2:

; 2148 : 		else if(eWarProjection == WAR_PROJECTION_UNKNOWN)

	cmp	ebp, 3
	jne	SHORT $LN28@GetThirdPa@2

; 2149 : 			iItemValue = 600;

	mov	ecx, 600				; 00000258H
	jmp	SHORT $LN26@GetThirdPa@2
$LN28@GetThirdPa@2:

; 2150 : 		else if(eWarProjection == WAR_PROJECTION_STALEMATE)

	sub	ebp, 2
	neg	ebp
	sbb	ebp, ebp
	and	ebp, 49000				; 0000bf68H
	add	ebp, 1000				; 000003e8H
	mov	ecx, ebp
$LN26@GetThirdPa@2:

; 2151 : 			iItemValue = 1000;
; 2152 : 		else
; 2153 : 			iItemValue = 50000;
; 2154 : 
; 2155 : 		// Add 50 gold per era
; 2156 : 		int iExtraCost = eOurEra * 50;
; 2157 : 		iItemValue += iExtraCost;
; 2158 : 
; 2159 : 		// Modify based on our War Approach
; 2160 : 		int iWarBias = /*5*/ GC.getDEFAULT_FLAVOR_VALUE() - iWarApproachWeight;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1864
	imul	edi, 50					; 00000032H
	sub	eax, DWORD PTR _iWarApproachWeight$[esp+28]
	add	ecx, edi

; 2161 : 		int iWarMod = iWarBias * 10;	// EX: 5 - War Approach of 9 = -4 * 10 = -40% cost
; 2162 : 		iWarMod *= iItemValue;
; 2163 : 		iWarMod /= 100;
; 2164 : 
; 2165 : 		iItemValue += iWarMod;

	imul	eax, ecx
	lea	edx, DWORD PTR [eax+eax*4]
	add	edx, edx
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	ecx, eax

; 2166 : 
; 2167 : 		// Minor
; 2168 : 		if(bMinor)

	test	bl, bl
	je	SHORT $LN24@GetThirdPa@2

; 2169 : 		{
; 2170 : 			if(eMinorApproachTowardsWarPlayer == MINOR_CIV_APPROACH_FRIENDLY)

	mov	eax, DWORD PTR _eMinorApproachTowardsWarPlayer$[esp+24]
	cmp	eax, 1
	jne	SHORT $LN23@GetThirdPa@2

; 2171 : 				iItemValue = 100000;

	mov	ecx, 100000				; 000186a0H
	jmp	SHORT $LN74@GetThirdPa@2
$LN23@GetThirdPa@2:

; 2172 : 			else if(eMinorApproachTowardsWarPlayer == MINOR_CIV_APPROACH_PROTECTIVE)

	cmp	eax, 2
	jne	SHORT $LN74@GetThirdPa@2

; 2173 : 				iItemValue = 100000;

	mov	ecx, 100000				; 000186a0H

; 2174 : 		}
; 2175 : 		// Major
; 2176 : 		else

	jmp	SHORT $LN74@GetThirdPa@2
$LN24@GetThirdPa@2:

; 2177 : 		{
; 2178 : 			// Modify for our feelings towards the player we're would go to war with
; 2179 : 			if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)

	test	esi, esi
	jne	SHORT $LN19@GetThirdPa@2

; 2180 : 			{
; 2181 : 				iItemValue *= 25;

	imul	ecx, 25					; 00000019H

; 2182 : 				iItemValue /= 100;

	jmp	SHORT $LN76@GetThirdPa@2
$LN19@GetThirdPa@2:

; 2183 : 			}
; 2184 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_ENEMY)

	cmp	esi, 1
	jne	SHORT $LN17@GetThirdPa@2

; 2185 : 			{
; 2186 : 				iItemValue *= 50;

	imul	ecx, 50					; 00000032H

; 2187 : 				iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
	jmp	SHORT $LN74@GetThirdPa@2
$LN17@GetThirdPa@2:

; 2188 : 			}
; 2189 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_COMPETITOR)

	cmp	esi, 2
	jne	SHORT $LN74@GetThirdPa@2

; 2190 : 			{
; 2191 : 				iItemValue *= 75;

	imul	ecx, 75					; 0000004bH
$LN76@GetThirdPa@2:

; 2192 : 				iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN74@GetThirdPa@2:

; 2193 : 			}
; 2194 : 		}
; 2195 : 
; 2196 : 		// Modify for our feelings towards the asking player
; 2197 : 		if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_ALLY)

	mov	eax, DWORD PTR _eOpinionTowardsAskingPlayer$[esp+24]
	cmp	eax, 6
	jne	SHORT $LN14@GetThirdPa@2

; 2198 : 		{
; 2199 : 			iItemValue *= 50;

	imul	ecx, 50					; 00000032H

; 2200 : 			iItemValue /= 100;

	jmp	SHORT $LN78@GetThirdPa@2
$LN14@GetThirdPa@2:

; 2201 : 		}
; 2202 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FRIEND)

	cmp	eax, 5
	jne	SHORT $LN12@GetThirdPa@2

; 2203 : 		{
; 2204 : 			iItemValue *= 75;

	imul	ecx, 75					; 0000004bH

; 2205 : 			iItemValue /= 100;

	jmp	SHORT $LN77@GetThirdPa@2
$LN12@GetThirdPa@2:

; 2206 : 		}
; 2207 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FAVORABLE)

	cmp	eax, 4
	jne	SHORT $LN10@GetThirdPa@2

; 2208 : 		{
; 2209 : 			iItemValue *= 85;

	imul	ecx, 85					; 00000055H
$LN78@GetThirdPa@2:

; 2210 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	ebp
	mov	eax, edx
	pop	ebx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	edi
	mov	ecx, eax
	pop	esi

; 2240 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN10@GetThirdPa@2:

; 2211 : 		}
; 2212 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_COMPETITOR)

	cmp	eax, 2
	jne	SHORT $LN2@GetThirdPa@2

; 2213 : 		{
; 2214 : 			iItemValue *= 125;

	imul	ecx, 125				; 0000007dH
$LN77@GetThirdPa@2:

; 2215 : 			iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	ebp
	mov	ecx, edx
	pop	ebx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	pop	edi

; 2233 : 				iItemValue = 100;
; 2234 : 			else
; 2235 : 				iItemValue = -100000;
; 2236 : 		}
; 2237 : 	}
; 2238 : 
; 2239 : 	return iItemValue;

	mov	eax, ecx
	pop	esi

; 2240 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN31@GetThirdPa@2:

; 2216 : 		}
; 2217 : 	}
; 2218 : 
; 2219 : 	// From them
; 2220 : 	else
; 2221 : 	{
; 2222 : 		// Minor
; 2223 : 		if(bMinor)

	test	bl, bl
	je	SHORT $LN6@GetThirdPa@2
	pop	ebp
	pop	ebx

; 2224 : 			iItemValue = -100000;

	mov	ecx, -100000				; fffe7960H
	pop	edi

; 2233 : 				iItemValue = 100;
; 2234 : 			else
; 2235 : 				iItemValue = -100000;
; 2236 : 		}
; 2237 : 	}
; 2238 : 
; 2239 : 	return iItemValue;

	mov	eax, ecx
	pop	esi

; 2240 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN6@GetThirdPa@2:

; 2225 : 
; 2226 : 		// Major
; 2227 : 		else
; 2228 : 		{
; 2229 : 			// Modify for our feelings towards the player they would go to war with
; 2230 : 			if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)

	test	esi, esi
	jne	SHORT $LN4@GetThirdPa@2
	pop	ebp
	pop	ebx

; 2231 : 				iItemValue = 200;

	mov	ecx, 200				; 000000c8H
	pop	edi

; 2233 : 				iItemValue = 100;
; 2234 : 			else
; 2235 : 				iItemValue = -100000;
; 2236 : 		}
; 2237 : 	}
; 2238 : 
; 2239 : 	return iItemValue;

	mov	eax, ecx
	pop	esi

; 2240 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN4@GetThirdPa@2:

; 2232 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_ENEMY)

	dec	esi
	neg	esi
	sbb	esi, esi
	and	esi, -100100				; fffe78fcH
	add	esi, 100				; 00000064H
	mov	ecx, esi
$LN2@GetThirdPa@2:
	pop	ebp
	pop	ebx
	pop	edi

; 2233 : 				iItemValue = 100;
; 2234 : 			else
; 2235 : 				iItemValue = -100000;
; 2236 : 		}
; 2237 : 	}
; 2238 : 
; 2239 : 	return iItemValue;

	mov	eax, ecx
	pop	esi

; 2240 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDealAI::GetThirdPartyWarValue
_TEXT	ENDS
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue
EXTRN	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z:PROC ; CvLeague::CalculateStartingVotesForMember
EXTRN	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ:PROC ; CvGameLeagues::GetActiveLeague
EXTRN	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ:PROC	; CvGameLeagues::GetNumActiveLeagues
EXTRN	?EvaluateAlignment@CvLeagueAI@@QAE?AW4AlignmentLevels@1@W4PlayerTypes@@@Z:PROC ; CvLeagueAI::EvaluateAlignment
EXTRN	?EvaluateVoteForTrade@CvLeagueAI@@QAE?AW4DesireLevels@1@HHH_N@Z:PROC ; CvLeagueAI::EvaluateVoteForTrade
EXTRN	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ:PROC ; CvPlayer::GetLeagueAI
EXTRN	__fltused:DWORD
;	COMDAT __real@3e800000
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
CONST	ENDS
;	COMDAT ?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z
_TEXT	SEGMENT
tv325 = -4						; size = 4
_bFromMe$ = 8						; size = 1
_iValue$ = 12						; size = 4
_eOtherPlayer$ = 12					; size = 4
_iProposalID$ = 16					; size = 4
_iVoteChoice$ = 20					; size = 4
tv347 = 24						; size = 4
$T226870 = 24						; size = 4
_fVotesRatio$222856 = 24				; size = 4
_iNumVotes$ = 24					; size = 4
_bRepeal$ = 28						; size = 1
_bUseEvenValue$ = 32					; size = 1
?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z PROC ; CvDealAI::GetVoteCommitmentValue, COMDAT
; _this$ = ecx

; 2244 : {

	push	ecx

; 2245 : 	int iValue = 0;
; 2246 : 
; 2247 : 	// Giving our votes to them - Higher value for voting on things we dislike
; 2248 : 	if (bFromMe)

	cmp	BYTE PTR _bFromMe$[esp], 0
	push	ebx

; 2249 : 	{
; 2250 : 		// Adjust based on LeagueAI
; 2251 : 		CvLeagueAI::DesireLevels eDesire = GetPlayer()->GetLeagueAI()->EvaluateVoteForTrade(iProposalID, iVoteChoice, iNumVotes, bRepeal);

	mov	ebx, DWORD PTR _iNumVotes$[esp+4]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _eOtherPlayer$[esp+12]
	mov	ebp, ecx
	mov	ecx, DWORD PTR [ebp]
	push	edi
	je	$LN39@GetVoteCom
	mov	eax, DWORD PTR _bRepeal$[esp+16]
	mov	edx, DWORD PTR _iVoteChoice$[esp+16]
	push	eax
	mov	eax, DWORD PTR _iProposalID$[esp+20]
	push	ebx
	push	edx
	push	eax
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?EvaluateVoteForTrade@CvLeagueAI@@QAE?AW4DesireLevels@1@HHH_N@Z ; CvLeagueAI::EvaluateVoteForTrade

; 2252 : 		switch(eDesire)

	cmp	eax, 8
	ja	SHORT $LN31@GetVoteCom
	jmp	DWORD PTR $LN75@GetVoteCom[eax*4]
$LN35@GetVoteCom:

; 2253 : 		{
; 2254 : 		case CvLeagueAI::DESIRE_NEVER:
; 2255 : 		case CvLeagueAI::DESIRE_STRONG_DISLIKE:
; 2256 : 			iValue += 100000;
; 2257 : 			break;
; 2258 : 		case CvLeagueAI::DESIRE_DISLIKE:
; 2259 : 			iValue += 300;

	mov	edi, 300				; 0000012cH

; 2260 : 			break;

	jmp	SHORT $LN72@GetVoteCom
$LN34@GetVoteCom:

; 2261 : 		case CvLeagueAI::DESIRE_WEAK_DISLIKE:
; 2262 : 			iValue += 200;

	mov	edi, 200				; 000000c8H

; 2263 : 			break;

	jmp	SHORT $LN72@GetVoteCom
$LN33@GetVoteCom:

; 2264 : 		case CvLeagueAI::DESIRE_NEUTRAL:
; 2265 : 		case CvLeagueAI::DESIRE_WEAK_LIKE:
; 2266 : 		case CvLeagueAI::DESIRE_LIKE:
; 2267 : 			iValue += 150;

	mov	edi, 150				; 00000096H

; 2268 : 			break;

	jmp	SHORT $LN72@GetVoteCom
$LN32@GetVoteCom:

; 2269 : 		case CvLeagueAI::DESIRE_STRONG_LIKE:
; 2270 : 		case CvLeagueAI::DESIRE_ALWAYS:
; 2271 : 			iValue += 50;

	mov	edi, 50					; 00000032H

; 2272 : 			break;

	jmp	SHORT $LN72@GetVoteCom
$LN31@GetVoteCom:

; 2273 : 		default:
; 2274 : 			iValue += 100000;

	mov	edi, 100000				; 000186a0H
$LN72@GetVoteCom:
	mov	DWORD PTR _iValue$[esp+16], edi

; 2275 : 			break;
; 2276 : 		}
; 2277 : 
; 2278 : 		// Adjust based on relationship
; 2279 : 		CvAssert(eOtherPlayer != NO_PLAYER);
; 2280 : 		if (eOtherPlayer != NO_PLAYER)

	cmp	esi, -1
	je	$LN68@GetVoteCom

; 2281 : 		{
; 2282 : 			CvLeagueAI::AlignmentLevels eAlignment = GetPlayer()->GetLeagueAI()->EvaluateAlignment(eOtherPlayer);

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?EvaluateAlignment@CvLeagueAI@@QAE?AW4AlignmentLevels@1@W4PlayerTypes@@@Z ; CvLeagueAI::EvaluateAlignment

; 2283 : 			switch (eAlignment)

	cmp	eax, 10					; 0000000aH
	ja	SHORT $LN19@GetVoteCom
	jmp	DWORD PTR $LN76@GetVoteCom[eax*4]
$LN27@GetVoteCom:

; 2284 : 			{
; 2285 : 			case CvLeagueAI::ALIGNMENT_LIBERATOR:
; 2286 : 			case CvLeagueAI::ALIGNMENT_LEADER:
; 2287 : 				iValue += -50;

	sub	edi, 50					; 00000032H

; 2288 : 				break;

	jmp	SHORT $LN73@GetVoteCom
$LN25@GetVoteCom:

; 2289 : 			case CvLeagueAI::ALIGNMENT_SELF:
; 2290 : 				CvAssertMsg(false, "ALIGNMENT_SELF found when evaluating a trade deal for delegates. Please send Anton your save file and version.");
; 2291 : 				break;
; 2292 : 			case CvLeagueAI::ALIGNMENT_ALLY:
; 2293 : 				iValue += -35;

	sub	edi, 35					; 00000023H

; 2294 : 				break;

	jmp	SHORT $LN73@GetVoteCom
$LN24@GetVoteCom:

; 2295 : 			case CvLeagueAI::ALIGNMENT_CONFIDANT:
; 2296 : 			case CvLeagueAI::ALIGNMENT_FRIEND:
; 2297 : 				iValue += -25;

	sub	edi, 25					; 00000019H

; 2298 : 				break;

	jmp	SHORT $LN73@GetVoteCom
$LN22@GetVoteCom:

; 2299 : 			case CvLeagueAI::ALIGNMENT_NEUTRAL:
; 2300 : 				break;
; 2301 : 			case CvLeagueAI::ALIGNMENT_RIVAL:
; 2302 : 				iValue += 25;

	add	edi, 25					; 00000019H

; 2303 : 				break;

	jmp	SHORT $LN73@GetVoteCom
$LN21@GetVoteCom:

; 2304 : 			case CvLeagueAI::ALIGNMENT_HATRED:
; 2305 : 				iValue += 50;

	add	edi, 50					; 00000032H

; 2306 : 				break;

	jmp	SHORT $LN73@GetVoteCom
$LN20@GetVoteCom:

; 2307 : 			case CvLeagueAI::ALIGNMENT_ENEMY:
; 2308 : 			case CvLeagueAI::ALIGNMENT_WAR:
; 2309 : 				iValue += 100000;

	add	edi, 100000				; 000186a0H
$LN73@GetVoteCom:
	mov	DWORD PTR _iValue$[esp+16], edi
$LN19@GetVoteCom:

; 2310 : 				break;
; 2311 : 			default:
; 2312 : 				break;
; 2313 : 			}
; 2314 : 
; 2315 : 			MajorCivApproachTypes eOtherPlayerApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 2316 : 			if (eOtherPlayerApproach == MAJOR_CIV_APPROACH_HOSTILE || eOtherPlayerApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	eax, 1
	je	SHORT $LN67@GetVoteCom
	test	eax, eax
	jne	$LN68@GetVoteCom
$LN67@GetVoteCom:

; 2317 : 			{
; 2318 : 				iValue += 100000;

	add	edi, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[esp+16], edi

; 2319 : 			}
; 2320 : 		}
; 2321 : 	}
; 2322 : 	// Giving their votes to us - Higher value for voting on things we like
; 2323 : 	else

	jmp	$LN68@GetVoteCom
$LN39@GetVoteCom:

; 2324 : 	{
; 2325 : 		// Adjust based on LeagueAI
; 2326 : 		CvLeagueAI::DesireLevels eDesire = GetPlayer()->GetLeagueAI()->EvaluateVoteForTrade(iProposalID, iVoteChoice, iNumVotes, bRepeal);

	mov	edx, DWORD PTR _bRepeal$[esp+16]
	mov	eax, DWORD PTR _iVoteChoice$[esp+16]
	push	edx
	mov	edx, DWORD PTR _iProposalID$[esp+20]
	push	ebx
	push	eax
	push	edx
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?EvaluateVoteForTrade@CvLeagueAI@@QAE?AW4DesireLevels@1@HHH_N@Z ; CvLeagueAI::EvaluateVoteForTrade

; 2327 : 		switch(eDesire)

	cmp	eax, 8
	ja	SHORT $LN8@GetVoteCom
	jmp	DWORD PTR $LN77@GetVoteCom[eax*4]
$LN12@GetVoteCom:

; 2328 : 		{
; 2329 : 		case CvLeagueAI::DESIRE_NEVER:
; 2330 : 		case CvLeagueAI::DESIRE_STRONG_DISLIKE:
; 2331 : 		case CvLeagueAI::DESIRE_WEAK_DISLIKE:
; 2332 : 		case CvLeagueAI::DESIRE_NEUTRAL:
; 2333 : 			iValue += -100000;
; 2334 : 			break;
; 2335 : 		case CvLeagueAI::DESIRE_WEAK_LIKE:
; 2336 : 			iValue += 50;

	mov	edi, 50					; 00000032H

; 2337 : 			break;

	jmp	SHORT $LN74@GetVoteCom
$LN11@GetVoteCom:

; 2338 : 		case CvLeagueAI::DESIRE_LIKE:
; 2339 : 			iValue += 100;

	mov	edi, 100				; 00000064H

; 2340 : 			break;

	jmp	SHORT $LN74@GetVoteCom
$LN10@GetVoteCom:

; 2341 : 		case CvLeagueAI::DESIRE_STRONG_LIKE:
; 2342 : 			iValue += 150;

	mov	edi, 150				; 00000096H

; 2343 : 			break;

	jmp	SHORT $LN74@GetVoteCom
$LN9@GetVoteCom:

; 2344 : 		case CvLeagueAI::DESIRE_ALWAYS:
; 2345 : 			iValue += 200;

	mov	edi, 200				; 000000c8H

; 2346 : 			break;

	jmp	SHORT $LN74@GetVoteCom
$LN8@GetVoteCom:

; 2347 : 		default:
; 2348 : 			iValue += -100000;

	mov	edi, -100000				; fffe7960H
$LN74@GetVoteCom:

; 2349 : 			break;
; 2350 : 		}
; 2351 : 
; 2352 : 		// Adjust based on their vote total - Having lots of votes left means they could counter these ones and exploit us
; 2353 : #ifndef AUI_LEAGUES_FIX_POSSIBLE_DEALLOCATION_CRASH
; 2354 : 		if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _iValue$[esp+16], edi
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ ; CvGameLeagues::GetNumActiveLeagues
	test	eax, eax
	jle	SHORT $LN68@GetVoteCom

; 2355 : #endif
; 2356 : 		{
; 2357 : 			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ ; CvGameLeagues::GetActiveLeague

; 2358 : 			if (pLeague)

	test	eax, eax
	je	SHORT $LN68@GetVoteCom

; 2359 : 			{
; 2360 : 				float fVotesRatio = (float)iNumVotes / (float)pLeague->CalculateStartingVotesForMember(eOtherPlayer);

	fild	DWORD PTR _iNumVotes$[esp+16]
	push	0
	push	esi
	mov	ecx, eax
	fstp	DWORD PTR tv325[esp+28]
	call	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z ; CvLeague::CalculateStartingVotesForMember
	mov	DWORD PTR tv347[esp+16], eax
	fild	DWORD PTR tv347[esp+16]
	fdivr	DWORD PTR tv325[esp+20]
	fstp	DWORD PTR _fVotesRatio$222856[esp+16]

; 2361 : 				if (fVotesRatio > 0.5f)

	fld	DWORD PTR _fVotesRatio$222856[esp+16]
	fld	DWORD PTR __real@3f000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN70@GetVoteCom

; 2362 : 				{
; 2363 : 					// More than half their votes...they probably aren't going to screw us
; 2364 : 				}
; 2365 : 				else if (fVotesRatio > 0.25f)

	fld	DWORD PTR __real@3e800000
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@GetVoteCom

; 2366 : 				{
; 2367 : 					// They have a lot of remaining votes
; 2368 : 					iValue += -20;

	sub	edi, 20					; 00000014H
	mov	DWORD PTR _iValue$[esp+16], edi

; 2369 : 				}
; 2370 : 				else

	jmp	SHORT $LN68@GetVoteCom
$LN3@GetVoteCom:

; 2371 : 				{
; 2372 : 					// They have a hoard of votes
; 2373 : 					iValue += -40;

	sub	edi, 40					; 00000028H
	mov	DWORD PTR _iValue$[esp+16], edi
	jmp	SHORT $LN68@GetVoteCom
$LN70@GetVoteCom:
	fstp	ST(0)
$LN68@GetVoteCom:

; 2374 : 				}
; 2375 : 			}
; 2376 : 		}
; 2377 : 	}
; 2378 : 
; 2379 : 	iValue = MAX(iValue, 0);

	mov	DWORD PTR $T226870[esp+16], 0
	lea	eax, DWORD PTR $T226870[esp+16]
	test	edi, edi
	jl	SHORT $LN57@GetVoteCom
	lea	eax, DWORD PTR _iValue$[esp+16]
$LN57@GetVoteCom:

; 2380 : 
; 2381 : 	// Adjust based on how many votes
; 2382 : 	iValue *= iNumVotes;

	mov	edi, DWORD PTR [eax]
	imul	edi, ebx

; 2383 : 
; 2384 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 2385 : 	if (bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+16], 0
	je	SHORT $LN66@GetVoteCom

; 2386 : 	{
; 2387 : 		iValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetVoteCommitmentValue(!bFromMe, GetPlayer()->GetID(), iProposalID, iVoteChoice, iNumVotes, bRepeal, /*bUseEvenValue*/ false);

	mov	edx, DWORD PTR _bRepeal$[esp+16]
	imul	esi, 63236				; 0000f704H
	mov	eax, DWORD PTR [ebp]
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	BYTE PTR _bFromMe$[esp+16], 0
	push	0
	push	edx
	mov	edx, DWORD PTR _iVoteChoice$[esp+24]
	push	ebx
	push	edx
	mov	edx, DWORD PTR _iProposalID$[esp+32]
	push	edx
	push	eax
	sete	al
	movzx	edx, al
	mov	ecx, esi
	push	edx
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue
	add	eax, edi
	pop	edi

; 2388 : 
; 2389 : 		iValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 2393 : }

	pop	ecx
	ret	28					; 0000001cH
$LN66@GetVoteCom:

; 2390 : 	}
; 2391 : 
; 2392 : 	return iValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2393 : }

	pop	ecx
	ret	28					; 0000001cH
	npad	3
$LN75@GetVoteCom:
	DD	$LN31@GetVoteCom
	DD	$LN31@GetVoteCom
	DD	$LN35@GetVoteCom
	DD	$LN34@GetVoteCom
	DD	$LN33@GetVoteCom
	DD	$LN33@GetVoteCom
	DD	$LN33@GetVoteCom
	DD	$LN32@GetVoteCom
	DD	$LN32@GetVoteCom
$LN76@GetVoteCom:
	DD	$LN20@GetVoteCom
	DD	$LN20@GetVoteCom
	DD	$LN21@GetVoteCom
	DD	$LN22@GetVoteCom
	DD	$LN19@GetVoteCom
	DD	$LN24@GetVoteCom
	DD	$LN24@GetVoteCom
	DD	$LN25@GetVoteCom
	DD	$LN19@GetVoteCom
	DD	$LN27@GetVoteCom
	DD	$LN27@GetVoteCom
$LN77@GetVoteCom:
	DD	$LN8@GetVoteCom
	DD	$LN8@GetVoteCom
	DD	$LN8@GetVoteCom
	DD	$LN8@GetVoteCom
	DD	$LN8@GetVoteCom
	DD	$LN12@GetVoteCom
	DD	$LN11@GetVoteCom
	DD	$LN10@GetVoteCom
	DD	$LN9@GetVoteCom
?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ENDP ; CvDealAI::GetVoteCommitmentValue
_TEXT	ENDS
PUBLIC	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty
EXTRN	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z:PROC ; CvDeal::AddThirdPartyPeace
EXTRN	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z:PROC ; CvDeal::IsPossibleToTradeItem
EXTRN	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvDeal::IsThirdPartyPeaceTrade
EXTRN	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPermanentWar
EXTRN	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getPeaceDealDuration
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_iPeaceDuration$ = -8					; size = 4
tv598 = -4						; size = 4
_eToPlayer$ = 8						; size = 4
_pDeal$ = 12						; size = 4
?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::DoAddPlayersAlliesToTreaty, COMDAT
; _this$ = ecx

; 3627 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 3628 : 	int iPeaceDuration = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	mov	ebx, DWORD PTR _pDeal$[esp+20]
	mov	edi, 1391192				; 00153a58H
	mov	DWORD PTR _iPeaceDuration$[esp+24], eax
	mov	DWORD PTR tv598[esp+24], edi
	npad	4
$LL13@DoAddPlaye:

; 3629 : 	PlayerTypes eMinor;
; 3630 : 	CvPlayer* pMinor;
; 3631 : 	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
; 3632 : 	{
; 3633 : 		eMinor = (PlayerTypes) iMinorLoop;
; 3634 : 		pMinor = &GET_PLAYER(eMinor);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	edi, eax

; 3635 : 
; 3636 : 		// Minor not alive?
; 3637 : 		if(!pMinor->isAlive())

	cmp	BYTE PTR [edi+2256], 0
	je	$LN12@DoAddPlaye

; 3638 : 			continue;
; 3639 : 
; 3640 : 		PlayerTypes eAlly = pMinor->GetMinorCivAI()->GetAlly();

	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 3641 : 		// ally of other player
; 3642 : 		if (eAlly == eToPlayer)

	cmp	eax, DWORD PTR _eToPlayer$[esp+20]
	jne	$LN9@DoAddPlaye

; 3643 : 		{
; 3644 : 			// if they are not at war with us, continue
; 3645 : 			if (!GET_TEAM(GetTeam()).isAtWar(pMinor->getTeam()))

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN28@DoAddPlaye
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@DoAddPlaye
$LN28@DoAddPlaye:
	or	esi, -1
$LN29@DoAddPlaye:
	mov	ecx, ebp
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN12@DoAddPlaye

; 3646 : 			{
; 3647 : 				continue;
; 3648 : 			}
; 3649 : 
; 3650 : 			// if they are always at war with us, continue
; 3651 : 			if (pMinor->GetMinorCivAI()->IsPermanentWar(GetTeam()))

	mov	ecx, ebp
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	push	eax
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	test	al, al
	jne	$LN12@DoAddPlaye

; 3652 : 			{
; 3653 : 				continue;
; 3654 : 			}
; 3655 : 
; 3656 : 			// Add peace with this minor to the deal
; 3657 : 			// slewis - if there is not a peace deal with them already on the table and we can trade it
; 3658 : 			if(!pDeal->IsThirdPartyPeaceTrade(GetPlayer()->GetID(), pMinor->getTeam()) && pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), eToPlayer, TRADE_ITEM_THIRD_PARTY_PEACE, pMinor->getTeam()))

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@DoAddPlaye
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN40@DoAddPlaye
$LN39@DoAddPlaye:
	or	ecx, -1
$LN40@DoAddPlaye:
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyPeaceTrade
	test	al, al
	jne	$LN12@DoAddPlaye
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@DoAddPlaye
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN55@DoAddPlaye
$LN54@DoAddPlaye:
	or	ecx, -1
$LN55@DoAddPlaye:
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	ecx
	mov	ecx, DWORD PTR _eToPlayer$[esp+44]
	push	14					; 0000000eH
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	$LN12@DoAddPlaye

; 3659 : 			{
; 3660 : 				pDeal->AddThirdPartyPeace(GetPlayer()->GetID(), pMinor->getTeam(), iPeaceDuration);

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN69@DoAddPlaye
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _iPeaceDuration$[esp+24]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx

; 3661 : 			}
; 3662 : 		}

	jmp	$LN147@DoAddPlaye

; 3659 : 			{
; 3660 : 				pDeal->AddThirdPartyPeace(GetPlayer()->GetID(), pMinor->getTeam(), iPeaceDuration);

$LN69@DoAddPlaye:
	mov	edx, DWORD PTR _iPeaceDuration$[esp+24]
	or	eax, -1
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx

; 3661 : 			}
; 3662 : 		}

	jmp	$LN147@DoAddPlaye
$LN9@DoAddPlaye:

; 3663 : 		// ally with us
; 3664 : 		else if (eAlly == GetPlayer()->GetID())

	mov	edx, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [edx+44]
	jne	$LN12@DoAddPlaye

; 3665 : 		{
; 3666 : 			// if they are not at war with the opponent, continue
; 3667 : 			if (!GET_TEAM(GET_PLAYER(eToPlayer).getTeam()).isAtWar(pMinor->getTeam()))

	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN90@DoAddPlaye
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN91@DoAddPlaye
$LN90@DoAddPlaye:
	or	ecx, -1
$LN91@DoAddPlaye:
	mov	esi, DWORD PTR _eToPlayer$[esp+20]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	mov	eax, DWORD PTR [esi+eax+44]
	add	esi, 44					; 0000002cH
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN101@DoAddPlaye
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN102@DoAddPlaye
$LN101@DoAddPlaye:
	or	eax, -1
$LN102@DoAddPlaye:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN12@DoAddPlaye

; 3668 : 			{
; 3669 : 				continue;
; 3670 : 			}
; 3671 : 
; 3672 : 			// if they are always at war with them, continue
; 3673 : 			if (pMinor->GetMinorCivAI()->IsPermanentWar(GET_PLAYER(eToPlayer).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+eax]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN114@DoAddPlaye
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN115@DoAddPlaye
$LN114@DoAddPlaye:
	or	eax, -1
$LN115@DoAddPlaye:
	push	eax
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	test	al, al
	jne	$LN12@DoAddPlaye

; 3674 : 			{
; 3675 : 				continue;
; 3676 : 			}
; 3677 : 
; 3678 : 			// Add peace with this minor to the deal
; 3679 : 			// slewis - if there is not a peace deal with them already on the table and we can trade it
; 3680 : 			if(!pDeal->IsThirdPartyPeaceTrade(eToPlayer, pMinor->getTeam()) && pDeal->IsPossibleToTradeItem(eToPlayer, GetPlayer()->GetID(), TRADE_ITEM_THIRD_PARTY_PEACE, pMinor->getTeam()))

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN123@DoAddPlaye
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN124@DoAddPlaye
$LN123@DoAddPlaye:
	or	eax, -1
$LN124@DoAddPlaye:
	push	eax
	mov	eax, DWORD PTR _eToPlayer$[esp+24]
	push	eax
	mov	ecx, ebx
	call	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyPeaceTrade
	test	al, al
	jne	SHORT $LN12@DoAddPlaye
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN132@DoAddPlaye
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN133@DoAddPlaye
$LN132@DoAddPlaye:
	or	ecx, -1
$LN133@DoAddPlaye:
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	ecx
	mov	ecx, DWORD PTR _eToPlayer$[esp+44]
	push	14					; 0000000eH
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN12@DoAddPlaye

; 3681 : 			{
; 3682 : 				pDeal->AddThirdPartyPeace(eToPlayer, pMinor->getTeam(), iPeaceDuration);

	mov	edx, DWORD PTR _iPeaceDuration$[esp+24]
	push	edx
	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	eax, DWORD PTR _eToPlayer$[esp+28]
	push	eax
$LN147@DoAddPlaye:
	mov	ecx, ebx
	call	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::AddThirdPartyPeace
$LN12@DoAddPlaye:
	mov	edi, DWORD PTR tv598[esp+24]
	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	mov	DWORD PTR tv598[esp+24], edi
	jl	$LL13@DoAddPlaye
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3683 : 			}
; 3684 : 		}
; 3685 : 	}
; 3686 : }

	add	esp, 8
	ret	8
?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::DoAddPlayersAlliesToTreaty
_TEXT	ENDS
PUBLIC	?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeDemand
EXTRN	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddGoldTrade
EXTRN	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z:PROC ; CvDeal::GetGoldAvailable
EXTRN	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::SetDemandingPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_iMaxGold$ = 8						; size = 4
_eOtherPlayer$ = 8					; size = 4
_iGold$ = 12						; size = 4
_pDeal$ = 12						; size = 4
?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeDemand, COMDAT
; _this$ = ecx

; 3690 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 3691 : 	CvAssert(eOtherPlayer >= 0);
; 3692 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3693 : 
; 3694 : 	// Set that this CvDeal is a demand
; 3695 : 	pDeal->SetDemandingPlayer(GetPlayer()->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pDeal$[esp+12]
	push	ecx
	mov	ecx, edi
	call	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetDemandingPlayer

; 3696 : 
; 3697 : 	int iGold = pDeal->GetGoldAvailable(eOtherPlayer, TRADE_ITEM_GOLD);

	mov	ebx, DWORD PTR _eOtherPlayer$[esp+12]
	push	0
	push	ebx
	mov	ecx, edi
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable

; 3698 : 
; 3699 : 	// Don't ask for too much
; 3700 : 	int iMaxGold = 200 + (GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetCurrentEra() * 150);

	mov	edx, ebx
	imul	edx, 63236				; 0000f704H
	mov	esi, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edx+eax+44]
	mov	DWORD PTR _iGold$[esp+12], esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@IsMakeDema
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN17@IsMakeDema
$LN16@IsMakeDema:
	or	eax, -1
$LN17@IsMakeDema:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	imul	eax, 150				; 00000096H
	add	eax, 200				; 000000c8H
	mov	DWORD PTR _iMaxGold$[esp+12], eax

; 3701 : 	iGold = min(iMaxGold, iGold);

	cmp	esi, eax
	lea	eax, DWORD PTR _iGold$[esp+12]
	jl	SHORT $LN26@IsMakeDema
	lea	eax, DWORD PTR _iMaxGold$[esp+12]
$LN26@IsMakeDema:
	mov	esi, DWORD PTR [eax]

; 3702 : 
; 3703 : 	if(pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_GOLD, iGold))

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	esi
	push	0
	push	eax
	push	ebx
	mov	ecx, edi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN1@IsMakeDema

; 3704 : 	{
; 3705 : 		pDeal->AddGoldTrade(eOtherPlayer, iGold);

	push	esi
	push	ebx
	mov	ecx, edi
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
	pop	edi
	pop	esi
	pop	ebp

; 3706 : 
; 3707 : 		return true;

	mov	al, 1
	pop	ebx

; 3711 : }

	ret	8
$LN1@IsMakeDema:
	pop	edi
	pop	esi
	pop	ebp

; 3708 : 	}
; 3709 : 
; 3710 : 	return false;

	xor	al, al
	pop	ebx

; 3711 : }

	ret	8
?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeDemand
_TEXT	ENDS
PUBLIC	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::~iterator, COMDAT
; _this$ = ecx

; 136  : 		~iterator(){};

	ret	0
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::~iterator
_TEXT	ENDS
PUBLIC	??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ ; FFastList<CvTradedItem,21,0>::iterator::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ
_TEXT	SEGMENT
??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::operator->, COMDAT
; _this$ = ecx

; 139  : 		T* operator->(){  return &( BASE_TYPE::iterator::operator*().data );  };

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx+8]
	ret	0
??Citerator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAEPAUCvTradedItem@@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::operator->
_TEXT	ENDS
PUBLIC	??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++, COMDAT
; _this$ = ecx

; 310  : 		base_iterator& operator++(){

	mov	eax, ecx

; 311  : 			if( m_uiCurrPos == ANCHOR_NODE_INDEX ){

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 268435455				; 0fffffffH
	jne	SHORT $LN2@operator@2

; 312  : 				m_uiCurrPos = m_pFastList->m_uiFirst;

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], edx

; 315  : 			}
; 316  : 			return *this;
; 317  : 		};

	ret	0
$LN2@operator@2:

; 313  : 			}else{
; 314  : 				m_uiCurrPos = m_pFastList->get_allocator()[ m_uiCurrPos ].LIST_GetNext();

	mov	edx, DWORD PTR [eax]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+4], ecx

; 315  : 			}
; 316  : 			return *this;
; 317  : 		};

	ret	0
??E?$base_iterator@Vbase_iterator_tail@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAV01@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator<FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::base_iterator_tail>::operator++
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z PROC ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	ebx, DWORD PTR _pVal$[esp]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _uiNumElements$[esp+8]
	mov	ebp, ecx
	test	edi, edi
	jbe	SHORT $LN5@Free@2
	push	esi
	mov	esi, ebx
$LL7@Free@2:
	mov	ecx, esi
	call	??1VoteCommitment@CvLeagueAI@@QAE@XZ	; CvLeagueAI::VoteCommitment::~VoteCommitment
	add	esi, 20					; 00000014H
	sub	edi, 1
	jne	SHORT $LL7@Free@2
	pop	esi
$LN5@Free@2:

; 811  : 		if( pVal != (T*)m_aData )

	add	ebp, 12					; 0000000cH
	cmp	ebx, ebp
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free@2:
	pop	edi
	pop	ebp
	pop	ebx

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ENDP ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator, COMDAT
; _this$ = ecx

; 378  : 		explicit iterator(){};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
_TEXT	ENDS
PUBLIC	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator, COMDAT
; _this$ = ecx

; 379  : 		explicit iterator( unsigned int uiPos, TYPE* pVec )

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@IPAV1@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	mov	ebx, 1
	jne	SHORT $LN33@GrowSize
	mov	DWORD PTR [esi+8], ebx
$LN33@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	4
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN36@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN36@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	edi

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, ebx
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], ebx
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jbe	SHORT $LN1@GrowSize
	mov	eax, ebp
$LL41@GrowSize:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [eax], edi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
$LN12@GrowSize:
	add	ecx, ebx
	add	eax, 8
	cmp	ecx, DWORD PTR [esi+4]
	jb	SHORT $LL41@GrowSize
$LN1@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	pop	edi
	cmp	eax, ecx
	je	SHORT $LN40@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN40@GrowSize:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+20], bl
	mov	DWORD PTR [esi], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
PUBLIC	?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetEmbassyValue
EXTRN	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::GetDealDuration
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetEmbassyValue, COMDAT
; _this$ = ecx

; 1482 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Embassy with oneself.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
; 1483 : 
; 1484 : 	int iItemValue = 35;
; 1485 : 
; 1486 : 	// Scale up or down by deal duration at this game speed
; 1487 : 	CvGameSpeedInfo *pkStdSpeedInfo = GC.getGameSpeedInfo((GameSpeedTypes)GC.getSTANDARD_GAMESPEED());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8464
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, 35					; 00000023H
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
	mov	edi, eax

; 1488 : 	if (pkStdSpeedInfo)

	test	edi, edi
	je	SHORT $LN11@GetEmbassy

; 1489 : 	{
; 1490 : 		iItemValue *= GC.getGame().getGameSpeedInfo().GetDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::GetDealDuration
	mov	esi, eax

; 1491 : 		iItemValue /= pkStdSpeedInfo->GetDealDuration();

	mov	ecx, edi
	imul	esi, 35					; 00000023H
	call	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::GetDealDuration
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, eax
$LN11@GetEmbassy:

; 1492 : 	}
; 1493 : 
; 1494 : 	if(bFromMe)  // giving the other player an embassy in my capital

	mov	bl, BYTE PTR _bFromMe$[esp+12]
	mov	edi, DWORD PTR _eOtherPlayer$[esp+12]
	test	bl, bl
	je	SHORT $LN10@GetEmbassy

; 1495 : 	{
; 1496 : 		// Approach is important
; 1497 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	mov	ecx, DWORD PTR [ebp]
	push	1
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN2@GetEmbassy
	jmp	DWORD PTR $LN30@GetEmbassy[eax*4]
$LN7@GetEmbassy:

; 1498 : 		{
; 1499 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1500 : 			iItemValue *= 250;

	imul	esi, 250				; 000000faH

; 1501 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN6@GetEmbassy:

; 1502 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1503 : 			iItemValue *= 130;

	imul	esi, 130				; 00000082H

; 1504 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN5@GetEmbassy:

; 1505 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1506 : 			iItemValue *= 80;

	lea	esi, DWORD PTR [esi+esi*4]
	shl	esi, 4

; 1507 : 			break;
; 1508 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1509 : 			iItemValue *= 100;
; 1510 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN2@GetEmbassy:

; 1511 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1512 : 			iItemValue *= 100;
; 1513 : 			break;
; 1514 : 		default:
; 1515 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Research Agreement valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1516 : 			iItemValue *= 100;

	imul	esi, 100				; 00000064H
$LN8@GetEmbassy:

; 1517 : 			break;
; 1518 : 		}
; 1519 : 		iItemValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@GetEmbassy:

; 1520 : 	}
; 1521 : 
; 1522 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1523 : 	if(bUseEvenValue)

	cmp	BYTE PTR _bUseEvenValue$[esp+12], 0
	je	SHORT $LN28@GetEmbassy

; 1524 : 	{
; 1525 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetTradeAgreementValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	edx, DWORD PTR [ebp]
	imul	edi, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+44]
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	test	bl, bl
	sete	al
	movzx	edx, al
	mov	ecx, edi
	push	edx
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
	add	eax, esi
	pop	edi

; 1526 : 
; 1527 : 		iItemValue /= 2;

	cdq
	pop	esi
	sub	eax, edx
	pop	ebp
	sar	eax, 1
	pop	ebx

; 1531 : }

	ret	12					; 0000000cH
$LN28@GetEmbassy:
	pop	edi

; 1528 : 	}
; 1529 : 
; 1530 : 	return iItemValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1531 : }

	ret	12					; 0000000cH
	npad	3
$LN30@GetEmbassy:
	DD	$LN7@GetEmbassy
	DD	$LN2@GetEmbassy
	DD	$LN6@GetEmbassy
	DD	$LN5@GetEmbassy
	DD	$LN2@GetEmbassy
	DD	$LN2@GetEmbassy
?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetEmbassyValue
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free

; 619  : 	};

	ret	0
??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
_TEXT	ENDS
PUBLIC	??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::iterator, COMDAT
; _this$ = ecx

; 133  : 		explicit iterator(){};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	0
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$00$0A@@@QAE@XZ		; CvWeightedVector<int,1,0>::CvWeightedVector<int,1,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@H$00$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$00$0A@@@QAE@XZ PROC		; CvWeightedVector<int,1,0>::CvWeightedVector<int,1,0>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$00$0A@@@QAE@XZ ENDP		; CvWeightedVector<int,1,0>::CvWeightedVector<int,1,0>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$00$0A@@@QAE@XZ		; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$00$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$00$0A@@@QAE@XZ PROC		; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@H$00$0A@@@QAE@XZ ENDP		; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
_TEXT	ENDS
PUBLIC	??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z ; FFastList<CvTradedItem,21,0>::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z
_TEXT	SEGMENT
_uiPos$ = 8						; size = 4
_pVec$ = 12						; size = 4
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z PROC ; FFastList<CvTradedItem,21,0>::iterator::iterator, COMDAT
; _this$ = ecx

; 134  : 		explicit iterator( unsigned int uiPos, TYPE* pVec ) 

	mov	edx, DWORD PTR _uiPos$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pVec$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@IPAV1@@Z ENDP ; FFastList<CvTradedItem,21,0>::iterator::iterator
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+20], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__Tmp$227866 = -24					; size = 8
__Tmp$227795 = -16					; size = 8
__Tmp$227821 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$227795[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$227795[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227821[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$227821[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$227866[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$227866[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$227866[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$227866[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::make_heap<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::make_heap<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::pop_heap<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z
_TEXT	SEGMENT
_eItem$ = 8						; size = 4
_bFromMe$ = 12						; size = 1
_eOtherPlayer$ = 16					; size = 4
_iData1$ = 20						; size = 4
_iData2$ = 24						; size = 4
_iData3$ = 28						; size = 4
_bFlag1$ = 32						; size = 1
_iDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z PROC ; CvDealAI::GetTradeItemValue, COMDAT
; _this$ = ecx

; 855  : 	CvAssert(eOtherPlayer >= 0);
; 856  : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 857  : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to get deal item value for trading to oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 858  : 	CvAssertMsg(eItem != TRADE_ITEM_NONE, "DEAL_AI: Trying to get value of TRADE_ITEM_NONE.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 859  : 
; 860  : 	int iItemValue = 0;
; 861  : 
; 862  : 	if(eItem == TRADE_ITEM_GOLD)

	mov	edx, DWORD PTR _eItem$[esp-4]
	xor	eax, eax
	test	edx, edx
	jne	SHORT $LN25@GetTradeIt

; 863  : 		iItemValue = GetGoldForForValueExchange(/*Gold Amount*/ iData1, /*bNumGoldFromValue*/ false, bFromMe, eOtherPlayer, bUseEvenValue, /*bRoundUp*/ false);

	mov	eax, DWORD PTR _bUseEvenValue$[esp-4]
	push	edx
	mov	edx, DWORD PTR _eOtherPlayer$[esp]
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp+4]
	push	edx
	mov	edx, DWORD PTR _iData1$[esp+8]
	push	eax
	push	0
	push	edx
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN25@GetTradeIt:

; 864  : 	else if(eItem == TRADE_ITEM_GOLD_PER_TURN)

	cmp	edx, 1
	jne	SHORT $LN23@GetTradeIt

; 865  : 		iItemValue = GetGPTforForValueExchange(/*Gold Per Turn Amount*/ iData1, /*bNumGPTFromValue*/ false, iDuration, bFromMe, eOtherPlayer, bUseEvenValue, /*bRoundUp*/ false);

	mov	eax, DWORD PTR _bUseEvenValue$[esp-4]
	mov	edx, DWORD PTR _eOtherPlayer$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp+4]
	push	edx
	mov	edx, DWORD PTR _iDuration$[esp+8]
	push	eax
	mov	eax, DWORD PTR _iData1$[esp+12]
	push	edx
	push	0
	push	eax
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN23@GetTradeIt:

; 866  : 	else if(eItem == TRADE_ITEM_RESOURCES)

	cmp	edx, 3
	jne	SHORT $LN21@GetTradeIt

; 867  : 		iItemValue = GetResourceValue(/*ResourceType*/ (ResourceTypes) iData1, /*Quantity*/ iData2, iDuration, bFromMe, eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$[esp-4]
	mov	eax, DWORD PTR _bFromMe$[esp-4]
	push	edx
	mov	edx, DWORD PTR _iDuration$[esp]
	push	eax
	mov	eax, DWORD PTR _iData2$[esp+4]
	push	edx
	mov	edx, DWORD PTR _iData1$[esp+8]
	push	eax
	push	edx
	call	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN21@GetTradeIt:

; 868  : 	else if(eItem == TRADE_ITEM_CITIES)

	cmp	edx, 4
	jne	SHORT $LN19@GetTradeIt

; 869  : 		iItemValue = GetCityValue(/*iX*/ iData1, /*iY*/ iData2, bFromMe, eOtherPlayer, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp-4]
	mov	edx, DWORD PTR _eOtherPlayer$[esp-4]
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp]
	push	edx
	mov	edx, DWORD PTR _iData2$[esp+4]
	push	eax
	mov	eax, DWORD PTR _iData1$[esp+8]
	push	edx
	push	eax
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN19@GetTradeIt:

; 870  : 	else if(eItem == TRADE_ITEM_ALLOW_EMBASSY)

	cmp	edx, 17					; 00000011H
	jne	SHORT $LN17@GetTradeIt

; 871  : 		iItemValue = GetEmbassyValue(bFromMe, eOtherPlayer, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp-4]
	mov	eax, DWORD PTR _eOtherPlayer$[esp-4]
	push	edx
	mov	edx, DWORD PTR _bFromMe$[esp]
	push	eax
	push	edx
	call	?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetEmbassyValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN17@GetTradeIt:

; 872  : 	else if(eItem == TRADE_ITEM_OPEN_BORDERS)

	cmp	edx, 6
	jne	SHORT $LN15@GetTradeIt

; 873  : 		iItemValue = GetOpenBordersValue(bFromMe, eOtherPlayer, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp-4]
	mov	edx, DWORD PTR _eOtherPlayer$[esp-4]
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp]
	push	edx
	push	eax
	call	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN15@GetTradeIt:

; 874  : 	else if(eItem == TRADE_ITEM_DEFENSIVE_PACT)

	cmp	edx, 7
	jne	SHORT $LN13@GetTradeIt

; 875  : 		iItemValue = GetDefensivePactValue(bFromMe, eOtherPlayer, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp-4]
	mov	eax, DWORD PTR _eOtherPlayer$[esp-4]
	push	edx
	mov	edx, DWORD PTR _bFromMe$[esp]
	push	eax
	push	edx
	call	?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetDefensivePactValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN13@GetTradeIt:

; 876  : 	else if(eItem == TRADE_ITEM_RESEARCH_AGREEMENT)

	cmp	edx, 8
	jne	SHORT $LN11@GetTradeIt

; 877  : 		iItemValue = GetResearchAgreementValue(bFromMe, eOtherPlayer, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp-4]
	mov	edx, DWORD PTR _eOtherPlayer$[esp-4]
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp]
	push	edx
	push	eax
	call	?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetResearchAgreementValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN11@GetTradeIt:

; 878  : 	else if(eItem == TRADE_ITEM_TRADE_AGREEMENT)

	cmp	edx, 9
	jne	SHORT $LN9@GetTradeIt

; 879  : 		iItemValue = GetTradeAgreementValue(bFromMe, eOtherPlayer, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp-4]
	mov	eax, DWORD PTR _eOtherPlayer$[esp-4]
	push	edx
	mov	edx, DWORD PTR _bFromMe$[esp]
	push	eax
	push	edx
	call	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN9@GetTradeIt:

; 880  : 	else if(eItem == TRADE_ITEM_PEACE_TREATY)

	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@GetTradeIt

; 881  : 		iItemValue = GetPeaceTreatyValue(eOtherPlayer);

	xor	eax, eax

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN7@GetTradeIt:

; 882  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_PEACE)

	cmp	edx, 14					; 0000000eH
	jne	SHORT $LN5@GetTradeIt

; 883  : 		iItemValue = GetThirdPartyPeaceValue(bFromMe, eOtherPlayer, /*eWithTeam*/ (TeamTypes) iData1);

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	edx, DWORD PTR _eOtherPlayer$[esp-4]
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp]
	push	edx
	push	eax
	call	?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyPeaceValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN5@GetTradeIt:

; 884  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_WAR)

	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN3@GetTradeIt

; 885  : 		iItemValue = GetThirdPartyWarValue(bFromMe, eOtherPlayer, /*eWithTeam*/ (TeamTypes) iData1);

	mov	edx, DWORD PTR _iData1$[esp-4]
	mov	eax, DWORD PTR _eOtherPlayer$[esp-4]
	push	edx
	mov	edx, DWORD PTR _bFromMe$[esp]
	push	eax
	push	edx
	call	?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyWarValue

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
$LN3@GetTradeIt:

; 886  : 	else if(eItem == TRADE_ITEM_VOTE_COMMITMENT)

	cmp	edx, 19					; 00000013H
	jne	SHORT $LN1@GetTradeIt

; 887  : 		iItemValue = GetVoteCommitmentValue(bFromMe, eOtherPlayer, iData1, iData2, iData3, bFlag1, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp-4]
	mov	edx, DWORD PTR _bFlag1$[esp-4]
	push	eax
	mov	eax, DWORD PTR _iData3$[esp]
	push	edx
	mov	edx, DWORD PTR _iData2$[esp+4]
	push	eax
	mov	eax, DWORD PTR _iData1$[esp+8]
	push	edx
	mov	edx, DWORD PTR _eOtherPlayer$[esp+12]
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp+16]
	push	edx
	push	eax
	call	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue
$LN1@GetTradeIt:

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;
; 892  : }

	ret	36					; 00000024H
?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ENDP ; CvDealAI::GetTradeItemValue
_TEXT	ENDS
PUBLIC	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::begin, COMDAT
; _this$ = ecx

; 199  : 	iterator begin(){ return iterator( m_uiFirst, this ); };

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], ecx
	ret	4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::end, COMDAT
; _this$ = ecx

; 200  : 	iterator end(){ return iterator( ANCHOR_NODE_INDEX, this ); };

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 268435455		; 0fffffffH
	ret	4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::end
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@H$00$0A@@@QAEIABHH@Z ; CvWeightedVector<int,1,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@H$00$0A@@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$00$0A@@@QAEIABHH@Z PROC	; CvWeightedVector<int,1,0>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+20], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@2
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
$LN5@push_back@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@2
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@2:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$00$0A@@@QAEIABHH@Z ENDP	; CvWeightedVector<int,1,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z ; CvDealAI::DoHumanDemand
EXTRN	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z:PROC ; CvGlobals::WrapDealPointer
EXTRN	?DoFromUIDiploEvent@CvGame@@QAEXW4FromUIDiploEventTypes@@W4PlayerTypes@@HH@Z:PROC ; CvGame::DoFromUIDiploEvent
EXTRN	?CalculateBaseNetGold@CvTreasury@@QAEHXZ:PROC	; CvTreasury::CalculateBaseNetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?getAsyncRandNum@CvGame@@QAEHHPBD@Z:PROC	; CvGame::getAsyncRandNum
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?GetMilitaryAggressivePosture@CvDiplomacyAI@@QBE?AW4AggressivePostureTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMilitaryAggressivePosture
EXTRN	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs
EXTRN	?IsDemandTooSoon@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDemandTooSoon
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$2
__ehfuncinfo$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_eResponse$ = -128					; size = 4
_iValueWillingToGiveUp$ = -124				; size = 4
_iGPT$222010 = -120					; size = 4
_eMilitaryStrength$221979 = -120			; size = 4
_iModdedGoldValue$222012 = -116				; size = 4
_eMilitaryPosture$221980 = -116				; size = 4
_eFromPlayer$ = -112					; size = 4
_pDllDeal$222151 = -108					; size = 4
_eMyPlayer$ = -108					; size = 4
_this$ = -104						; size = 4
$T228163 = -100						; size = 4
_iTempGold$222011 = -100				; size = 4
$T228162 = -96						; size = 8
$T228160 = -96						; size = 8
_kDeal$222149 = -88					; size = 76
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::DoHumanDemand, COMDAT
; _this$ = ecx

; 286  : {

	push	-1
	push	__ehhandler$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	mov	esi, ecx

; 287  : 	DemandResponseTypes eResponse = NO_DEMAND_RESPONSE_TYPE;
; 288  : 
; 289  : 	PlayerTypes eFromPlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _this$[esp+140], esi
	mov	DWORD PTR _eResponse$[esp+140], -1
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	ebx, eax

; 290  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]

; 291  : 
; 292  : 	int iValueWillingToGiveUp = 0;
; 293  : 
; 294  : 	CvDiplomacyAI* pDiploAI = GET_PLAYER(eMyPlayer).GetDiplomacyAI();

	mov	edi, eax
	imul	edi, 63236				; 0000f704H
	mov	DWORD PTR _eMyPlayer$[esp+140], eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR _eFromPlayer$[esp+140], ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	esi, eax

; 295  : 	// Too soon for another demand?
; 296  : 	if(pDiploAI->IsDemandTooSoon(eFromPlayer))

	push	ebx
	mov	ecx, esi
	call	?IsDemandTooSoon@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDemandTooSoon
	test	al, al
	je	SHORT $LN44@DoHumanDem

; 297  : 		eResponse = DEMAND_RESPONSE_REFUSE_TOO_SOON;

	mov	DWORD PTR _eResponse$[esp+140], 4

; 298  : 
; 299  : 	// Not too soon for a demand
; 300  : 	else

	jmp	$LN3@DoHumanDem
$LN44@DoHumanDem:
	push	ebp

; 301  : 	{
; 302  : 		MajorCivApproachTypes eApproach = pDiploAI->GetMajorCivApproach(eFromPlayer, /*bHideTrueFeelings*/ true);

	push	1
	push	ebx
	mov	ecx, esi
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 303  : 		StrengthTypes eMilitaryStrength = pDiploAI->GetPlayerMilitaryStrengthComparedToUs(eFromPlayer);

	push	ebx
	mov	ecx, esi
	mov	ebp, eax
	call	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs

; 304  : 		AggressivePostureTypes eMilitaryPosture = pDiploAI->GetMilitaryAggressivePosture(eFromPlayer);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _eMilitaryStrength$221979[esp+148], eax
	call	?GetMilitaryAggressivePosture@CvDiplomacyAI@@QBE?AW4AggressivePostureTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMilitaryAggressivePosture

; 305  : 		PlayerProximityTypes eProximity = GET_PLAYER(eMyPlayer).GetProximityToPlayer(eFromPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	push	ebx
	mov	DWORD PTR _eMilitaryPosture$221980[esp+148], eax
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer

; 306  : 
; 307  : 		// Unforgivable: AI will never give in
; 308  : 		if(pDiploAI->GetMajorCivOpinion(eFromPlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)

	push	ebx
	mov	ecx, esi
	mov	edi, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	test	eax, eax
	jne	SHORT $LN42@DoHumanDem

; 309  : 			eResponse = DEMAND_RESPONSE_REFUSE_HOSTILE;

	mov	DWORD PTR _eResponse$[esp+144], 2
	jmp	$LN200@DoHumanDem
$LN42@DoHumanDem:

; 310  : 
; 311  : 		// Hostile: AI will never give in
; 312  : 		else if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)

	mov	eax, 1
	cmp	ebp, eax
	jne	SHORT $LN40@DoHumanDem

; 313  : 			eResponse = DEMAND_RESPONSE_REFUSE_HOSTILE;

	mov	DWORD PTR _eResponse$[esp+144], 2
	jmp	$LN200@DoHumanDem
$LN40@DoHumanDem:

; 314  : 
; 315  : 		// Our military is stronger: AI will never give in
; 316  : 		else if(eMilitaryStrength < STRENGTH_AVERAGE)

	cmp	DWORD PTR _eMilitaryStrength$221979[esp+144], 3
	jge	SHORT $LN38@DoHumanDem

; 317  : 			eResponse = DEMAND_RESPONSE_REFUSE_WEAK;

	mov	DWORD PTR _eResponse$[esp+144], eax
	jmp	$LN200@DoHumanDem
$LN38@DoHumanDem:

; 318  : 
; 319  : 		// They are very far away and have no units near us (from what we can tell): AI will never give in
; 320  : 		else if(eProximity <= PLAYER_PROXIMITY_FAR && eMilitaryPosture == AGGRESSIVE_POSTURE_NONE)

	cmp	edi, eax
	jg	SHORT $LN197@DoHumanDem
	cmp	DWORD PTR _eMilitaryPosture$221980[esp+144], 0
	jne	SHORT $LN197@DoHumanDem

; 321  : 			eResponse = DEMAND_RESPONSE_REFUSE_WEAK;

	mov	DWORD PTR _eResponse$[esp+144], eax

; 322  : 
; 323  : 		// Willing to give in to demand
; 324  : 		else

	jmp	$LN200@DoHumanDem
$LN197@DoHumanDem:

; 325  : 		{
; 326  : 			// Initial odds of giving in to ANY demand are based on the player's boldness (which is also tied to the player's likelihood of going for world conquest)
; 327  : 			int iOddsOfGivingIn = (10 - pDiploAI->GetBoldness()) * 10;

	mov	ecx, esi
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	mov	edx, 10					; 0000000aH
	mov	ecx, edx
	sub	ecx, eax
	lea	esi, DWORD PTR [ecx+ecx*4]

; 328  : 
; 329  : 			iValueWillingToGiveUp = 0;

	xor	edi, edi
	add	esi, esi
	mov	DWORD PTR _iValueWillingToGiveUp$[esp+144], edi

; 330  : 
; 331  : 			// If we're afraid we're more likely to give in
; 332  : 			if(eApproach == MAJOR_CIV_APPROACH_AFRAID)

	cmp	ebp, 4
	jne	SHORT $LN34@DoHumanDem

; 333  : 			{
; 334  : 				iOddsOfGivingIn += 50;

	add	esi, 50					; 00000032H

; 335  : 				iValueWillingToGiveUp += 200;
; 336  : 			}
; 337  : 			// Not afraid
; 338  : 			else

	jmp	SHORT $LN201@DoHumanDem
$LN34@DoHumanDem:

; 339  : 			{
; 340  : 				// How strong are they compared to us?
; 341  : 				switch(eMilitaryStrength)

	mov	eax, DWORD PTR _eMilitaryStrength$221979[esp+144]
	cmp	eax, 6
	ja	SHORT $LN23@DoHumanDem
	jmp	DWORD PTR $LN203@DoHumanDem[eax*4]
$LN30@DoHumanDem:

; 342  : 				{
; 343  : 				case STRENGTH_PATHETIC:
; 344  : 					iOddsOfGivingIn += -100;

	sub	esi, 100				; 00000064H

; 345  : 					iValueWillingToGiveUp += 10;

	mov	DWORD PTR _iValueWillingToGiveUp$[esp+144], edx

; 346  : 					break;

	jmp	SHORT $LN23@DoHumanDem
$LN28@DoHumanDem:

; 347  : 				case STRENGTH_WEAK:
; 348  : 					iOddsOfGivingIn += -100;
; 349  : 					iValueWillingToGiveUp += 10;
; 350  : 					break;
; 351  : 				case STRENGTH_POOR:
; 352  : 					iOddsOfGivingIn += -100;

	sub	esi, 100				; 00000064H

; 353  : 					iValueWillingToGiveUp += 20;

	mov	DWORD PTR _iValueWillingToGiveUp$[esp+144], 20 ; 00000014H

; 354  : 					break;

	jmp	SHORT $LN23@DoHumanDem
$LN27@DoHumanDem:

; 355  : 				case STRENGTH_AVERAGE:
; 356  : 					iOddsOfGivingIn += -10;

	sub	esi, edx

; 357  : 					iValueWillingToGiveUp += 50;

	mov	DWORD PTR _iValueWillingToGiveUp$[esp+144], 50 ; 00000032H

; 358  : 					break;

	jmp	SHORT $LN23@DoHumanDem
$LN26@DoHumanDem:

; 359  : 				case STRENGTH_STRONG:
; 360  : 					iOddsOfGivingIn += 10;

	add	esi, edx

; 361  : 					iValueWillingToGiveUp += 120;

	mov	DWORD PTR _iValueWillingToGiveUp$[esp+144], 120 ; 00000078H

; 362  : 					break;

	jmp	SHORT $LN23@DoHumanDem
$LN25@DoHumanDem:

; 363  : 				case STRENGTH_POWERFUL:
; 364  : 					iOddsOfGivingIn += 20;

	add	esi, 20					; 00000014H

; 365  : 					iValueWillingToGiveUp += 200;
; 366  : 					break;

	jmp	SHORT $LN201@DoHumanDem
$LN24@DoHumanDem:

; 367  : 				case STRENGTH_IMMENSE:
; 368  : 					iOddsOfGivingIn += 35;

	add	esi, 35					; 00000023H
$LN201@DoHumanDem:

; 369  : 					iValueWillingToGiveUp += 200;

	mov	DWORD PTR _iValueWillingToGiveUp$[esp+144], 200 ; 000000c8H
$LN23@DoHumanDem:

; 370  : 					break;
; 371  : 				default:
; 372  : 					break;
; 373  : 				}
; 374  : 			}
; 375  : 
; 376  : 			// IMPORTANT NOTE: This APPEARS to be very bad for multiplayer, but the only changes made to the game state are the fact that the human
; 377  : 			// made a demand, and if the deal went through. These are both sent over the network later in this function.
; 378  : 
; 379  : 			int iAsyncRand = GC.getGame().getAsyncRandNum(100, "Deal AI: ASYNC RAND call to determine if AI will give into a human demand.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222006
	push	100					; 00000064H
	call	?getAsyncRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getAsyncRandNum

; 380  : 
; 381  : 			// Are they going to say no matter what?
; 382  : 			if(iAsyncRand > iOddsOfGivingIn)

	cmp	eax, esi
	jle	SHORT $LN194@DoHumanDem

; 383  : 				eResponse = DEMAND_RESPONSE_REFUSE_HOSTILE;

	mov	DWORD PTR _eResponse$[esp+144], 2

; 384  : 		}
; 385  : 	}
; 386  : 
; 387  : 	// Possibility exists that the AI will accept
; 388  : #ifdef AUI_WARNING_FIXES
; 389  : 	if (eResponse == NO_DEMAND_RESPONSE_TYPE)
; 390  : #else
; 391  : 	if(eResponse == NO_DEAL_RESPONSE_TYPE)

	jmp	$LN200@DoHumanDem
$LN194@DoHumanDem:

; 392  : #endif
; 393  : 	{
; 394  : 		int iValueDemanded = 0;
; 395  : 
; 396  : 		int iGPT = GetPlayer()->GetTreasury()->CalculateBaseNetGold();

	mov	edx, DWORD PTR _this$[esp+144]
	mov	ecx, DWORD PTR [edx]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?CalculateBaseNetGold@CvTreasury@@QAEHXZ ; CvTreasury::CalculateBaseNetGold

; 397  : 		int iTempGold;
; 398  : 		int iModdedGoldValue;
; 399  : 
; 400  : 		// Loop through items in this deal
; 401  : 		TradedItemList::iterator it;
; 402  : 		for(it = pDeal->m_TradedItems.begin(); it != pDeal->m_TradedItems.end(); ++it)

	mov	esi, DWORD PTR _pDeal$[esp+140]
	mov	DWORD PTR _iGPT$222010[esp+144], eax
	lea	eax, DWORD PTR $T228160[esp+144]
	add	esi, 44					; 0000002cH
	push	eax
	mov	ecx, esi
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T228162[esp+144]
	push	ecx
	mov	ecx, esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	setne	al
	test	al, al
	je	$LN195@DoHumanDem
	npad	4
$LL74@DoHumanDem:

; 403  : 		{
; 404  : 			// Item from this AI
; 405  : 			if(it->m_eFromPlayer == eMyPlayer)

	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR _eMyPlayer$[esp+144]
	mov	esi, ebx
	imul	esi, 44					; 0000002cH
	cmp	DWORD PTR [esi+edx+36], ecx
	lea	eax, DWORD PTR [esi+edx]
	jne	$LN19@DoHumanDem

; 406  : 			{
; 407  : 				switch(it->m_eItemType)

	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, 6
	ja	$LN5@DoHumanDem
	jmp	DWORD PTR $LN204@DoHumanDem[ecx*4]
$LN14@DoHumanDem:

; 408  : 				{
; 409  : 					// Gold
; 410  : 				case TRADE_ITEM_GOLD:
; 411  : 				{
; 412  : 					iTempGold = it->m_iData1;
; 413  : 					if (iGPT > 0)

	cmp	DWORD PTR _iGPT$222010[esp+144], 0
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _iTempGold$222011[esp+144], ecx
	jle	SHORT $LN13@DoHumanDem

; 414  : 						iModdedGoldValue = iTempGold * 10 / iGPT;

	lea	eax, DWORD PTR [ecx+ecx*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR _iGPT$222010[esp+144]

; 415  : 					else

	jmp	SHORT $LN202@DoHumanDem
$LN13@DoHumanDem:

; 416  : 						iModdedGoldValue = 0;

	xor	eax, eax
$LN202@DoHumanDem:
	mov	DWORD PTR _iModdedGoldValue$222012[esp+144], eax

; 417  : 
; 418  : 					iValueDemanded += max(iTempGold, iModdedGoldValue);

	cmp	ecx, eax
	lea	eax, DWORD PTR _iModdedGoldValue$222012[esp+144]
	jl	SHORT $LN121@DoHumanDem
	lea	eax, DWORD PTR _iTempGold$222011[esp+144]
$LN121@DoHumanDem:
	add	edi, DWORD PTR [eax]

; 419  : 					break;

	jmp	SHORT $LN19@DoHumanDem
$LN11@DoHumanDem:

; 420  : 				}
; 421  : 
; 422  : 				// GPT
; 423  : 				case TRADE_ITEM_GOLD_PER_TURN:
; 424  : 				{
; 425  : 					iValueDemanded += (it->m_iData1 * it->m_iDuration * 80 / 100);

	mov	eax, DWORD PTR [esi+edx+20]
	imul	eax, DWORD PTR [esi+edx+12]
	lea	ecx, DWORD PTR [esi+edx]
	lea	ecx, DWORD PTR [eax+eax*4]
	shl	ecx, 4
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	edi, eax

; 426  : 					break;

	jmp	SHORT $LN19@DoHumanDem
$LN10@DoHumanDem:

; 427  : 				}
; 428  : 
; 429  : 				// Resources
; 430  : 				case TRADE_ITEM_RESOURCES:
; 431  : 				{
; 432  : 					ResourceTypes eResource = (ResourceTypes) it->m_iData1;

	mov	eax, DWORD PTR [eax+20]

; 433  : 					ResourceUsageTypes eUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 434  : 
; 435  : 					if(eUsage == RESOURCEUSAGE_LUXURY)

	cmp	eax, 2
	jne	SHORT $LN9@DoHumanDem

; 436  : 						iValueDemanded += 200;

	add	edi, 200				; 000000c8H
	jmp	SHORT $LN19@DoHumanDem
$LN9@DoHumanDem:

; 437  : 					else if(eUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	eax, 1
	jne	SHORT $LN19@DoHumanDem

; 438  : 						iValueDemanded += (40 * it->m_iData2);

	mov	ecx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [esi+ecx+24]
	lea	edx, DWORD PTR [eax+eax*4]
	lea	edi, DWORD PTR [edi+edx*8]

; 439  : 
; 440  : 					break;

	jmp	SHORT $LN19@DoHumanDem
$LN6@DoHumanDem:

; 441  : 				}
; 442  : 
; 443  : 				// Open Borders
; 444  : 				case TRADE_ITEM_OPEN_BORDERS:
; 445  : 				{
; 446  : 					iValueDemanded += 50;

	add	edi, 50					; 00000032H

; 447  : 					break;

	jmp	SHORT $LN19@DoHumanDem
$LN5@DoHumanDem:

; 448  : 				}
; 449  : 
; 450  : 				case TRADE_ITEM_CITIES:
; 451  : 				case TRADE_ITEM_DEFENSIVE_PACT:
; 452  : 				case TRADE_ITEM_RESEARCH_AGREEMENT:
; 453  : 				case TRADE_ITEM_PERMANENT_ALLIANCE:
; 454  : 				case TRADE_ITEM_THIRD_PARTY_PEACE:
; 455  : 				case TRADE_ITEM_THIRD_PARTY_WAR:
; 456  : 				case TRADE_ITEM_THIRD_PARTY_EMBARGO:
; 457  : 				default:
; 458  : 					eResponse = DEMAND_RESPONSE_REFUSE_TOO_MUCH;

	mov	DWORD PTR _eResponse$[esp+144], 3
$LN19@DoHumanDem:

; 397  : 		int iTempGold;
; 398  : 		int iModdedGoldValue;
; 399  : 
; 400  : 		// Loop through items in this deal
; 401  : 		TradedItemList::iterator it;
; 402  : 		for(it = pDeal->m_TradedItems.begin(); it != pDeal->m_TradedItems.end(); ++it)

	cmp	ebx, 268435455				; 0fffffffH
	jne	SHORT $LN75@DoHumanDem
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN193@DoHumanDem
$LN75@DoHumanDem:
	mov	eax, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [esi+eax]
$LN193@DoHumanDem:
	lea	ecx, DWORD PTR $T228162[esp+144]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[esp+144]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebx, DWORD PTR [eax+4]
	setne	al
	test	al, al
	jne	$LL74@DoHumanDem

; 459  : 					break;
; 460  : 				}
; 461  : 			}
; 462  : 		}
; 463  : 
; 464  : 		// No illegal items in the demand
; 465  : #ifdef AUI_WARNING_FIXES
; 466  : 		if (eResponse == NO_DEMAND_RESPONSE_TYPE)
; 467  : #else
; 468  : 		if(eResponse == NO_DEAL_RESPONSE_TYPE)

	cmp	DWORD PTR _eResponse$[esp+144], -1
	jne	SHORT $LN198@DoHumanDem
$LN195@DoHumanDem:

; 469  : #endif
; 470  : 		{
; 471  : 			if(iValueDemanded <= iValueWillingToGiveUp)

	xor	edx, edx
	cmp	edi, DWORD PTR _iValueWillingToGiveUp$[esp+144]
	setle	dl
	dec	edx
	and	edx, 3
	mov	DWORD PTR _eResponse$[esp+144], edx
$LN198@DoHumanDem:
	mov	ebx, DWORD PTR _eFromPlayer$[esp+144]
$LN200@DoHumanDem:
	pop	ebp
$LN3@DoHumanDem:

; 472  : 				eResponse = DEMAND_RESPONSE_ACCEPT;
; 473  : 			else
; 474  : 				eResponse = DEMAND_RESPONSE_REFUSE_TOO_MUCH;
; 475  : 		}
; 476  : 	}
; 477  : 
; 478  : 	// Have to sent AI response through the network  - it affects AI behavior
; 479  : 	GC.getGame().DoFromUIDiploEvent(FROM_UI_DIPLO_EVENT_HUMAN_DEMAND, eMyPlayer, /*iData1*/ eResponse, -1);

	mov	edi, DWORD PTR _eResponse$[esp+140]
	mov	eax, DWORD PTR _eMyPlayer$[esp+140]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	-1
	push	edi
	push	eax
	push	24					; 00000018H
	call	?DoFromUIDiploEvent@CvGame@@QAEXW4FromUIDiploEventTypes@@W4PlayerTypes@@HH@Z ; CvGame::DoFromUIDiploEvent

; 480  : 
; 481  : 	// Demand agreed to
; 482  : 	if(eResponse == DEMAND_RESPONSE_ACCEPT)

	test	edi, edi
	jne	$LN196@DoHumanDem

; 483  : 	{
; 484  : 		CvDeal kDeal = *pDeal;

	mov	ecx, DWORD PTR _pDeal$[esp+136]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$222149[esp+144]
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal

; 485  : 		//gDLL->sendNetDealAccepted(eFromPlayer, GetPlayer()->GetID(), kDeal, -1, -1, -1);
; 486  : 		GC.GetEngineUserInterface()->SetDealInTransit(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+564]
	push	1
	mov	DWORD PTR __$EHRec$[esp+152], edi
	call	eax

; 487  : 
; 488  : 		auto_ptr<ICvDeal1> pDllDeal = GC.WrapDealPointer(&kDeal);

	lea	ecx, DWORD PTR _kDeal$222149[esp+140]
	push	ecx
	lea	edx, DWORD PTR $T228163[esp+144]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z ; CvGlobals::WrapDealPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR _pDllDeal$222151[esp+140], esi
	mov	eax, DWORD PTR $T228163[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 1
	test	eax, eax
	je	SHORT $LN174@DoHumanDem
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN174@DoHumanDem:

; 489  : 		gDLL->sendNetDemandAccepted(eFromPlayer, GetPlayer()->GetID(), pDllDeal.get());

	mov	eax, DWORD PTR _this$[esp+140]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+364]
	push	ebx
	call	eax

; 490  : 	}

	mov	BYTE PTR __$EHRec$[esp+148], 0
	test	esi, esi
	je	SHORT $LN189@DoHumanDem
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN189@DoHumanDem:
	lea	ecx, DWORD PTR _kDeal$222149[esp+140]
	mov	DWORD PTR __$EHRec$[esp+148], -1
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
$LN196@DoHumanDem:

; 491  : 
; 492  : 	return eResponse;
; 493  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+140]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 128				; 00000080H
	ret	4
	npad	1
$LN203@DoHumanDem:
	DD	$LN30@DoHumanDem
	DD	$LN30@DoHumanDem
	DD	$LN28@DoHumanDem
	DD	$LN27@DoHumanDem
	DD	$LN26@DoHumanDem
	DD	$LN25@DoHumanDem
	DD	$LN24@DoHumanDem
$LN204@DoHumanDem:
	DD	$LN14@DoHumanDem
	DD	$LN11@DoHumanDem
	DD	$LN5@DoHumanDem
	DD	$LN10@DoHumanDem
	DD	$LN5@DoHumanDem
	DD	$LN5@DoHumanDem
	DD	$LN6@DoHumanDem
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _kDeal$222149[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$2:
	lea	ecx, DWORD PTR _pDllDeal$222151[ebp]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
__ehhandler$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::DoHumanDemand
PUBLIC	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z	; CvDealAI::GetDealValue
EXTRN	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z:PROC ; CvDeal::GetOtherPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z
_TEXT	SEGMENT
_iDealValue$ = -24					; size = 4
_eMyPlayer$ = -20					; size = 4
_bFromMe$ = -16						; size = 1
_this$ = -12						; size = 4
$T228579 = -8						; size = 8
$T228577 = -8						; size = 8
_pDeal$ = 8						; size = 4
_iValueImOffering$ = 12					; size = 4
_iValueTheyreOffering$ = 16				; size = 4
_bUseEvenValue$ = 20					; size = 1
?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z PROC	; CvDealAI::GetDealValue, COMDAT
; _this$ = ecx

; 802  : {

	sub	esp, 24					; 00000018H

; 803  : 	int iDealValue = 0;
; 804  : 	iValueImOffering = 0;

	mov	eax, DWORD PTR _iValueImOffering$[esp+20]

; 805  : 	iValueTheyreOffering = 0;

	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+20]
	push	ebx
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR [eax], ebx
	push	esi

; 806  : 
; 807  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 808  : 
; 809  : 	int iItemValue;
; 810  : 
; 811  : 	bool bFromMe;
; 812  : 	PlayerTypes eOtherPlayer;
; 813  : 
; 814  : 	eOtherPlayer = pDeal->m_eFromPlayer == eMyPlayer ? pDeal->m_eToPlayer : pDeal->m_eFromPlayer;
; 815  : 
; 816  : 	TradedItemList::iterator it;
; 817  : 	for(it = pDeal->m_TradedItems.begin(); it != pDeal->m_TradedItems.end(); ++it)

	mov	esi, DWORD PTR _pDeal$[esp+32]
	mov	DWORD PTR [edx], ebx
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _this$[esp+36], ecx
	mov	ecx, DWORD PTR [eax+44]
	push	edi
	lea	edx, DWORD PTR $T228577[esp+40]
	mov	DWORD PTR _eMyPlayer$[esp+40], ecx
	add	esi, 44					; 0000002cH
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _iDealValue$[esp+44], ebx
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	edi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T228579[esp+40]
	push	eax
	mov	ecx, esi
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebp, DWORD PTR [eax+4]
	je	$LN122@GetDealVal
$LL123@GetDealVal:

; 818  : 	{
; 819  : 		if(eMyPlayer == it->m_eFromPlayer)

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, ebp
	imul	esi, 44					; 0000002cH
	mov	eax, DWORD PTR [esi+ecx+36]
	cmp	DWORD PTR _eMyPlayer$[esp+40], eax
	jne	SHORT $LN4@GetDealVal

; 820  : 		{
; 821  : 			bFromMe = true;
; 822  : 			eOtherPlayer = pDeal->GetOtherPlayer(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$[esp+40]
	mov	ecx, DWORD PTR _pDeal$[esp+36]
	mov	bl, 1
	push	edx
	mov	BYTE PTR _bFromMe$[esp+44], bl
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer

; 823  : 		}
; 824  : 		else

	jmp	SHORT $LN3@GetDealVal
$LN4@GetDealVal:

; 825  : 		{
; 826  : 			bFromMe = false;

	xor	bl, bl
	mov	BYTE PTR _bFromMe$[esp+40], bl
$LN3@GetDealVal:

; 827  : 			eOtherPlayer = it->m_eFromPlayer;
; 828  : 		}
; 829  : 
; 830  : 		// Multiplier is -1 if we're giving something away, 1 if we're receiving something
; 831  : 		int iValueMultiplier = bFromMe ? -1 : 1;
; 832  : 
; 833  : 		iItemValue = GetTradeItemValue(it->m_eItemType, bFromMe, eOtherPlayer, it->m_iData1, it->m_iData2, it->m_iData3, it->m_bFlag1, it->m_iDuration, bUseEvenValue);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _bUseEvenValue$[esp+36]
	push	edx
	mov	edx, DWORD PTR [esi+ecx+12]
	lea	ecx, DWORD PTR [esi+ecx+8]
	push	edx
	movzx	edx, BYTE PTR [ecx+24]
	push	edx
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx]
	push	edx
	push	eax
	mov	eax, DWORD PTR _bFromMe$[esp+68]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+76]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	xor	edx, edx
	test	bl, bl
	sete	dl
	lea	edx, DWORD PTR [edx+edx-1]

; 834  : 
; 835  : 		iItemValue *= iValueMultiplier;

	imul	eax, edx

; 836  : 		iDealValue += iItemValue;

	add	DWORD PTR _iDealValue$[esp+40], eax

; 837  : 
; 838  : 		// Figure out who's offering what, and keep track of the overall value on both sides of the deal
; 839  : 		if(iItemValue < 0)

	test	eax, eax
	jge	SHORT $LN2@GetDealVal

; 840  : 		{
; 841  : 			iValueImOffering -= iItemValue;

	mov	ecx, DWORD PTR _iValueImOffering$[esp+36]
	sub	DWORD PTR [ecx], eax

; 842  : 		}
; 843  : 		else

	jmp	SHORT $LN6@GetDealVal
$LN2@GetDealVal:

; 844  : 		{
; 845  : 			iValueTheyreOffering += iItemValue;

	mov	ecx, DWORD PTR _iValueTheyreOffering$[esp+36]
	add	DWORD PTR [ecx], eax
$LN6@GetDealVal:

; 806  : 
; 807  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 808  : 
; 809  : 	int iItemValue;
; 810  : 
; 811  : 	bool bFromMe;
; 812  : 	PlayerTypes eOtherPlayer;
; 813  : 
; 814  : 	eOtherPlayer = pDeal->m_eFromPlayer == eMyPlayer ? pDeal->m_eToPlayer : pDeal->m_eFromPlayer;
; 815  : 
; 816  : 	TradedItemList::iterator it;
; 817  : 	for(it = pDeal->m_TradedItems.begin(); it != pDeal->m_TradedItems.end(); ++it)

	cmp	ebp, 268435455				; 0fffffffH
	jne	SHORT $LN27@GetDealVal
	mov	ebp, DWORD PTR [edi+24]
	jmp	SHORT $LN121@GetDealVal
$LN27@GetDealVal:
	mov	eax, DWORD PTR [edi+8]
	mov	ebp, DWORD PTR [esi+eax]
$LN121@GetDealVal:
	lea	ecx, DWORD PTR $T228579[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[esp+40]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	cmp	ebp, DWORD PTR [eax+4]
	jne	$LL123@GetDealVal

; 846  : 		}
; 847  : 	}
; 848  : 
; 849  : 	return iDealValue;

	mov	eax, DWORD PTR _iDealValue$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 850  : }

	add	esp, 24					; 00000018H
	ret	16					; 00000010H
$LN122@GetDealVal:
	pop	edi
	pop	esi
	pop	ebp

; 846  : 		}
; 847  : 	}
; 848  : 
; 849  : 	return iDealValue;

	mov	eax, ebx
	pop	ebx

; 850  : }

	add	esp, 24					; 00000018H
	ret	16					; 00000010H
?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ENDP	; CvDealAI::GetDealValue
_TEXT	ENDS
PUBLIC	?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToThem
EXTRN	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z:PROC ; CvDeal::AddVoteCommitment
EXTRN	?GetDesiredVoteCommitments@CvLeagueAI@@QAE?AV?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@W4PlayerTypes@@@Z:PROC ; CvLeagueAI::GetDesiredVoteCommitments
EXTRN	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsVoteCommitmentTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0
__ehfuncinfo$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
_bRepeal$222889 = -116					; size = 1
_eMyPlayer$222878 = -112				; size = 4
_vDesiredCommitments$222880 = -108			; size = 96
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
tv779 = 16						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddVoteCommitmentToThem, COMDAT
; _this$ = ecx

; 2397 : {

	push	-1
	push	__ehhandler$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 108				; 0000006cH

; 2398 : 	CvAssert(eThem >= 0);
; 2399 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2400 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Vote Commitment to Them, but them is us. Please send Anton your save file and version.");
; 2401 : 
; 2402 : 	if(!bDontChangeTheirExistingItems)

	cmp	BYTE PTR _bDontChangeTheirExistingItems$[esp+116], 0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+124], esi
	jne	$LN247@DoAddVoteC

; 2403 : 	{
; 2404 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[esp+120]
	cmp	DWORD PTR [eax], 0
	jge	$LN247@DoAddVoteC

; 2405 : 		{
; 2406 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [eax+44]
	push	ebp

; 2407 : 
; 2408 : 			// Can't already be a Vote Commitment in the Deal
; 2409 : 			if(!pDeal->IsVoteCommitmentTrade(eThem) && !pDeal->IsVoteCommitmentTrade(eMyPlayer))

	mov	ebp, DWORD PTR _pDeal$[esp+128]
	push	edi
	mov	edi, DWORD PTR _eThem$[esp+132]
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR _eMyPlayer$222878[esp+140], ebx
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	test	al, al
	jne	$LN269@DoAddVoteC
	push	ebx
	mov	ecx, ebp
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	test	al, al
	jne	$LN269@DoAddVoteC

; 2410 : 			{
; 2411 : 				CvLeagueAI::VoteCommitmentList vDesiredCommitments = GetPlayer()->GetLeagueAI()->GetDesiredVoteCommitments(eThem);

	mov	ecx, DWORD PTR [esi]
	push	edi
	lea	edx, DWORD PTR _vDesiredCommitments$222880[esp+140]
	push	edx
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDesiredVoteCommitments@CvLeagueAI@@QAE?AV?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@W4PlayerTypes@@@Z ; CvLeagueAI::GetDesiredVoteCommitments

; 2412 : 				for (CvLeagueAI::VoteCommitmentList::iterator it = vDesiredCommitments.begin(); it != vDesiredCommitments.end(); ++it)

	mov	ebp, DWORD PTR _vDesiredCommitments$222880[esp+140]
	mov	ecx, DWORD PTR _vDesiredCommitments$222880[esp+136]
	lea	eax, DWORD PTR [ebp+ebp*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __$EHRec$[esp+144], 0
	cmp	ecx, edx
	je	$LN267@DoAddVoteC
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv779[esp+132], eax
$LL5@DoAddVoteC:

; 2413 : 				{
; 2414 : 					int iProposalID = it->iResolutionID;
; 2415 : 					int iVoteChoice = it->iVoteChoice;
; 2416 : 					int iNumVotes = it->iNumVotes;
; 2417 : 					bool bRepeal = !it->bEnact;

	cmp	BYTE PTR [eax+8], 0
	mov	esi, DWORD PTR [eax-4]
	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	sete	dl
	mov	BYTE PTR _bRepeal$222889[esp+136], dl

; 2418 : 
; 2419 : 					if (iProposalID != -1 && pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_VOTE_COMMITMENT, iProposalID, iVoteChoice, iNumVotes, bRepeal))

	cmp	esi, -1
	je	$LN4@DoAddVoteC
	mov	ebp, DWORD PTR _bRepeal$222889[esp+136]
	mov	eax, DWORD PTR _eMyPlayer$222878[esp+136]
	mov	ecx, DWORD PTR _eThem$[esp+132]
	push	0
	push	1
	push	ebp
	push	ebx
	push	edi
	push	esi
	push	19					; 00000013H
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[esp+168]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN266@DoAddVoteC

; 2420 : 					{
; 2421 : 						int iItemValue = GetTradeItemValue(TRADE_ITEM_VOTE_COMMITMENT, /*bFromMe*/ false, eThem, iProposalID, iVoteChoice, iNumVotes, bRepeal, -1, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+132]
	mov	eax, DWORD PTR _eThem$[esp+132]
	mov	ecx, DWORD PTR _this$[esp+136]
	push	edx
	push	ebp
	push	ebx
	push	edi
	push	esi
	push	eax
	push	0
	call	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue

; 2422 : 
; 2423 : 						// If adding this to the deal doesn't take it over the limit, do it
; 2424 : 						if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	ecx, DWORD PTR _iTotalValue$[esp+132]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	cmp	edx, DWORD PTR _iAmountOverWeWillRequest$[esp+132]
	jg	SHORT $LN266@DoAddVoteC

; 2425 : 						{
; 2426 : 							pDeal->AddVoteCommitment(eThem, iProposalID, iVoteChoice, iNumVotes, bRepeal);

	mov	eax, DWORD PTR _eThem$[esp+132]
	push	ebp
	push	ebx
	push	edi
	push	esi
	mov	esi, DWORD PTR _pDeal$[esp+148]
	push	eax
	mov	ecx, esi
	call	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::AddVoteCommitment

; 2427 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+132]
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+132]
	mov	eax, DWORD PTR _iValueImOffering$[esp+132]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+140]
	push	edx
	push	eax
	push	esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+132]
	mov	DWORD PTR [ecx], eax
$LN266@DoAddVoteC:
	mov	eax, DWORD PTR tv779[esp+132]
	mov	ecx, DWORD PTR _vDesiredCommitments$222880[esp+136]
	mov	ebp, DWORD PTR _vDesiredCommitments$222880[esp+140]
$LN4@DoAddVoteC:
	add	eax, 20					; 00000014H
	lea	edx, DWORD PTR [ebp+ebp*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	lea	esi, DWORD PTR [eax-8]
	mov	DWORD PTR tv779[esp+132], eax
	cmp	esi, edx
	jne	$LL5@DoAddVoteC
$LN267@DoAddVoteC:

; 2428 : 						}
; 2429 : 					}
; 2430 : 				}
; 2431 : 			}

	mov	DWORD PTR __$EHRec$[esp+144], -1
	mov	edi, ecx
	test	ebp, ebp
	jbe	SHORT $LN251@DoAddVoteC
	mov	esi, ecx
$LL253@DoAddVoteC:
	mov	ecx, esi
	call	??1VoteCommitment@CvLeagueAI@@QAE@XZ	; CvLeagueAI::VoteCommitment::~VoteCommitment
	add	esi, 20					; 00000014H
	sub	ebp, 1
	jne	SHORT $LL253@DoAddVoteC
$LN251@DoAddVoteC:
	lea	eax, DWORD PTR _vDesiredCommitments$222880[esp+148]
	cmp	edi, eax
	je	SHORT $LN269@DoAddVoteC
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN269@DoAddVoteC:
	pop	edi
	pop	ebp
	pop	ebx
$LN247@DoAddVoteC:

; 2432 : 		}
; 2433 : 	}
; 2434 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 120				; 00000078H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0:
	lea	ecx, DWORD PTR _vDesiredCommitments$222880[ebp]
	jmp	??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
__ehhandler$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddVoteCommitmentToThem
PUBLIC	?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToUs
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0
__ehfuncinfo$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_eMyPlayer$222906 = -120				; size = 4
_this$ = -116						; size = 4
_bRepeal$222917 = -112					; size = 1
_vDesiredCommitments$222908 = -108			; size = 96
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
tv557 = 16						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddVoteCommitmentToUs, COMDAT
; _this$ = ecx

; 2438 : {

	push	-1
	push	__ehhandler$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 108				; 0000006cH

; 2439 : 	CvAssert(eThem >= 0);
; 2440 : 	CvAssert(eThem < MAX_MAJOR_CIVS)
; 2441 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Vote Commitment to Us, but them is us. Please send Anton your save file and version.");
; 2442 : 
; 2443 : 	if(!bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp+116], 0
	mov	DWORD PTR _this$[esp+120], ecx
	jne	$LN125@DoAddVoteC@2

; 2444 : 	{
; 2445 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp+116]
	cmp	DWORD PTR [eax], 0
	jle	$LN125@DoAddVoteC@2

; 2446 : 		{
; 2447 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	eax, DWORD PTR [ecx]
	push	ebx

; 2448 : 
; 2449 : 			// Can't already be a Vote Commitment in the Deal
; 2450 : 			if(!pDeal->IsVoteCommitmentTrade(eThem) && !pDeal->IsVoteCommitmentTrade(eMyPlayer))

	mov	ebx, DWORD PTR _pDeal$[esp+120]
	push	esi
	mov	esi, DWORD PTR [eax+44]
	push	edi
	mov	edi, DWORD PTR _eThem$[esp+128]
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR _eMyPlayer$222906[esp+136], esi
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	test	al, al
	jne	$LN147@DoAddVoteC@2
	push	esi
	mov	ecx, ebx
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	test	al, al
	jne	$LN147@DoAddVoteC@2

; 2451 : 			{
; 2452 : 				CvLeagueAI::VoteCommitmentList vDesiredCommitments = GET_PLAYER(eThem).GetLeagueAI()->GetDesiredVoteCommitments(eMyPlayer);

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	esi
	lea	edx, DWORD PTR _vDesiredCommitments$222908[esp+140]
	push	edx
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDesiredVoteCommitments@CvLeagueAI@@QAE?AV?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@W4PlayerTypes@@@Z ; CvLeagueAI::GetDesiredVoteCommitments

; 2453 : 				for (CvLeagueAI::VoteCommitmentList::iterator it = vDesiredCommitments.begin(); it != vDesiredCommitments.end(); ++it)

	mov	ebp, DWORD PTR _vDesiredCommitments$222908[esp+140]
	mov	ecx, DWORD PTR _vDesiredCommitments$222908[esp+136]
	lea	eax, DWORD PTR [ebp+ebp*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __$EHRec$[esp+144], 0
	cmp	ecx, edx
	je	$LN145@DoAddVoteC@2
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv557[esp+132], eax
$LL5@DoAddVoteC@2:

; 2454 : 				{
; 2455 : 					int iProposalID = it->iResolutionID;
; 2456 : 					int iVoteChoice = it->iVoteChoice;
; 2457 : 					int iNumVotes = it->iNumVotes;
; 2458 : 					bool bRepeal = !it->bEnact;

	cmp	BYTE PTR [eax+8], 0
	mov	esi, DWORD PTR [eax-4]
	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	sete	dl
	mov	BYTE PTR _bRepeal$222917[esp+136], dl

; 2459 : 
; 2460 : 					if (iProposalID != -1 && pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_VOTE_COMMITMENT, iProposalID, iVoteChoice, iNumVotes, bRepeal))

	cmp	esi, -1
	je	$LN4@DoAddVoteC@2
	mov	ebp, DWORD PTR _bRepeal$222917[esp+136]
	mov	eax, DWORD PTR _eThem$[esp+132]
	mov	ecx, DWORD PTR _eMyPlayer$222906[esp+136]
	push	0
	push	1
	push	ebp
	push	ebx
	push	edi
	push	esi
	push	19					; 00000013H
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[esp+168]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN144@DoAddVoteC@2

; 2461 : 					{
; 2462 : 						int iItemValue = GetTradeItemValue(TRADE_ITEM_VOTE_COMMITMENT, /*bFromMe*/ true, eThem, iProposalID, iVoteChoice, iNumVotes, bRepeal, -1, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+132]
	mov	eax, DWORD PTR _eThem$[esp+132]
	mov	ecx, DWORD PTR _this$[esp+136]
	push	edx
	push	ebp
	push	ebx
	push	edi
	push	esi
	push	eax
	push	1
	call	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue

; 2463 : 
; 2464 : 						// If adding this to the deal doesn't take it under the min limit, do it
; 2465 : 						if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	ecx, DWORD PTR _iTotalValue$[esp+132]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[esp+132]
	jl	SHORT $LN144@DoAddVoteC@2

; 2466 : 						{
; 2467 : 							pDeal->AddVoteCommitment(eMyPlayer, iProposalID, iVoteChoice, iNumVotes, bRepeal);

	mov	eax, DWORD PTR _eMyPlayer$222906[esp+136]
	push	ebp
	push	ebx
	push	edi
	push	esi
	mov	esi, DWORD PTR _pDeal$[esp+148]
	push	eax
	mov	ecx, esi
	call	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::AddVoteCommitment

; 2468 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+132]
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+132]
	mov	eax, DWORD PTR _iValueImOffering$[esp+132]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+140]
	push	edx
	push	eax
	push	esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+132]
	mov	DWORD PTR [ecx], eax
$LN144@DoAddVoteC@2:
	mov	eax, DWORD PTR tv557[esp+132]
	mov	ecx, DWORD PTR _vDesiredCommitments$222908[esp+136]
	mov	ebp, DWORD PTR _vDesiredCommitments$222908[esp+140]
$LN4@DoAddVoteC@2:
	add	eax, 20					; 00000014H
	lea	edx, DWORD PTR [ebp+ebp*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	lea	esi, DWORD PTR [eax-8]
	mov	DWORD PTR tv557[esp+132], eax
	cmp	esi, edx
	jne	$LL5@DoAddVoteC@2
$LN145@DoAddVoteC@2:

; 2469 : 						}
; 2470 : 					}
; 2471 : 				}
; 2472 : 			}

	mov	DWORD PTR __$EHRec$[esp+144], -1
	mov	edi, ecx
	test	ebp, ebp
	jbe	SHORT $LN129@DoAddVoteC@2
	mov	esi, ecx
	npad	5
$LL131@DoAddVoteC@2:
	mov	ecx, esi
	call	??1VoteCommitment@CvLeagueAI@@QAE@XZ	; CvLeagueAI::VoteCommitment::~VoteCommitment
	add	esi, 20					; 00000014H
	sub	ebp, 1
	jne	SHORT $LL131@DoAddVoteC@2
$LN129@DoAddVoteC@2:
	lea	eax, DWORD PTR _vDesiredCommitments$222908[esp+148]
	pop	ebp
	cmp	edi, eax
	je	SHORT $LN147@DoAddVoteC@2
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN147@DoAddVoteC@2:
	pop	edi
	pop	esi
	pop	ebx
$LN125@DoAddVoteC@2:

; 2473 : 		}
; 2474 : 	}
; 2475 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	mov	DWORD PTR fs:0, ecx
	add	esp, 120				; 00000078H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0:
	lea	ecx, DWORD PTR _vDesiredCommitments$222908[ebp]
	jmp	??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
__ehhandler$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddVoteCommitmentToUs
PUBLIC	?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToThem
EXTRN	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z:PROC ; CvDeal::AddResourceTrade
EXTRN	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z:PROC ; CvDeal::ChangeResourceTrade
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
$T230039 = 8						; size = 4
_pDeal$ = 8						; size = 4
_iResourceQuantity$222939 = 12				; size = 4
_eThem$ = 12						; size = 4
_eMyPlayer$222935 = 16					; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddResourceToThem, COMDAT
; _this$ = ecx

; 2479 : {

	push	ecx

; 2480 : 	CvAssert(eThem >= 0);
; 2481 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2482 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Resource to Them, but them is us.  Please show Jon");
; 2483 : 
; 2484 : 	if(!bDontChangeTheirExistingItems)

	cmp	BYTE PTR _bDontChangeTheirExistingItems$[esp], 0
	mov	DWORD PTR _this$[esp+4], ecx
	jne	$LN7@DoAddResou

; 2485 : 	{
; 2486 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[esp]
	cmp	DWORD PTR [eax], 0
	jge	$LN7@DoAddResou

; 2487 : 		{
; 2488 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ecx]
	push	ebx
	mov	ebx, DWORD PTR [ecx+44]
	push	ebp
	push	esi
	push	edi

; 2489 : 
; 2490 : 			int iItemValue;
; 2491 : 
; 2492 : #ifdef AUI_WARNING_FIXES
; 2493 : 			uint iResourceLoop;
; 2494 : #else
; 2495 : 			int iResourceLoop;
; 2496 : #endif
; 2497 : 			ResourceTypes eResource;
; 2498 : 			int iResourceQuantity;
; 2499 : 
; 2500 : 			// Look to trade Luxuries first
; 2501 : 			for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eMyPlayer$222935[esp+16], ebx
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	esi, DWORD PTR _eThem$[esp+16]
	mov	ebp, DWORD PTR _pDeal$[esp+16]
	test	eax, eax
	jle	$LN17@DoAddResou
	jmp	SHORT $LN19@DoAddResou
	npad	9
$LL489@DoAddResou:
	mov	ebx, DWORD PTR _eMyPlayer$222935[esp+16]
$LN19@DoAddResou:

; 2502 : 			{
; 2503 : 				eResource = (ResourceTypes) iResourceLoop;
; 2504 : 
; 2505 : 				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2506 : 				if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)

	test	eax, eax
	je	$LN18@DoAddResou
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	$LN18@DoAddResou

; 2507 : 					continue;
; 2508 : 
; 2509 : 				iResourceQuantity = GET_PLAYER(eThem).getNumResourceAvailable(eResource, false);

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	edi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable

; 2510 : 
; 2511 : 				// Don't bother looking at this Resource if the other player doesn't even have any of it
; 2512 : 				if(iResourceQuantity <= 0)

	test	eax, eax
	jle	$LN18@DoAddResou

; 2513 : 					continue;
; 2514 : 
; 2515 : 				// Don't bother if we wouldn't get Happiness from it due to World Congress
; 2516 : 				if(GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(eMyPlayer, eResource))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	push	ebx
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	test	al, al
	jne	SHORT $LN18@DoAddResou

; 2517 : 					continue;
; 2518 : 
; 2519 : 				// Quantity is always 1 if it's a Luxury, 5 if Strategic
; 2520 : 				iResourceQuantity = 1;
; 2521 : 
; 2522 : 				// See if they can actually trade it to us
; 2523 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	push	0
	push	1
	push	0
	push	-1
	push	1
	push	edi
	push	3
	push	ebx
	push	esi
	mov	ecx, ebp
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN18@DoAddResou

; 2524 : 				{
; 2525 : 					iItemValue = GetTradeItemValue(TRADE_ITEM_RESOURCES, /*bFromMe*/ false, eThem, eResource, iResourceQuantity, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	mov	ebx, DWORD PTR _iDealDuration$[esp+16]
	mov	ecx, DWORD PTR _this$[esp+20]
	push	esi
	push	0
	push	ebx
	push	1
	push	edi
	call	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue

; 2526 : 
; 2527 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2528 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	mov	ecx, DWORD PTR [edx]
	add	ecx, eax
	cmp	ecx, DWORD PTR _iAmountOverWeWillRequest$[esp+16]
	jg	SHORT $LN18@DoAddResou

; 2529 : 					{
; 2530 : 						// Try to change the current item if it already exists, otherwise add it
; 2531 : 						if(!pDeal->ChangeResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration))

	push	ebx
	push	1
	push	edi
	push	esi
	mov	ecx, ebp
	call	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
	test	al, al
	jne	SHORT $LN18@DoAddResou

; 2532 : 						{
; 2533 : 							pDeal->AddResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration);

	push	ebx
	push	1
	push	edi
	push	esi
	mov	ecx, ebp
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 2534 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+16]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+32]
	push	ebp
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	mov	DWORD PTR [edx], eax
$LN18@DoAddResou:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	$LL489@DoAddResou
$LN17@DoAddResou:

; 2535 : 						}
; 2536 : 					}
; 2537 : 				}
; 2538 : 			}
; 2539 : 
; 2540 : 			// Now look at Strategic Resources
; 2541 : 			for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN491@DoAddResou
	npad	5
$LL490@DoAddResou:

; 2542 : 			{
; 2543 : 				eResource = (ResourceTypes) iResourceLoop;
; 2544 : 
; 2545 : 				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2546 : 				if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	test	eax, eax
	je	$LN8@DoAddResou
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	je	$LN8@DoAddResou

; 2547 : 					continue;
; 2548 : 
; 2549 : 				iResourceQuantity = GET_PLAYER(eThem).getNumResourceAvailable(eResource, false);

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	edi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iResourceQuantity$222939[esp+16], eax

; 2550 : 
; 2551 : 				// Don't bother looking at this Resource if the other player doesn't even have any of it
; 2552 : 				if(iResourceQuantity <= 0)

	test	eax, eax
	jle	$LN8@DoAddResou

; 2553 : 					continue;
; 2554 : 
; 2555 : 				// Quantity is always 1 if it's a Luxury, 5 if Strategic
; 2556 : 				iResourceQuantity = min(5, iResourceQuantity);	// 5 or what they have, whichever is less

	cmp	eax, 5
	mov	DWORD PTR $T230039[esp+16], 5
	lea	eax, DWORD PTR _iResourceQuantity$222939[esp+16]
	jl	SHORT $LN260@DoAddResou
	lea	eax, DWORD PTR $T230039[esp+16]
$LN260@DoAddResou:
	mov	ebx, DWORD PTR [eax]

; 2557 : 
; 2558 : 				// See if they can actually trade it to us
; 2559 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	mov	eax, DWORD PTR _eMyPlayer$222935[esp+16]
	push	0
	push	1
	push	0
	push	-1
	push	ebx
	push	edi
	push	3
	push	eax
	push	esi
	mov	ecx, ebp
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN8@DoAddResou

; 2560 : 				{
; 2561 : 					iItemValue = GetTradeItemValue(TRADE_ITEM_RESOURCES, /*bFromMe*/ false, eThem, eResource, iResourceQuantity, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	mov	ecx, DWORD PTR _iDealDuration$[esp+16]
	push	esi
	push	0
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+32]
	push	ebx
	push	edi
	call	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue

; 2562 : 
; 2563 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2564 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	mov	ecx, DWORD PTR [edx]
	add	ecx, eax
	cmp	ecx, DWORD PTR _iAmountOverWeWillRequest$[esp+16]
	jg	SHORT $LN8@DoAddResou

; 2565 : 					{
; 2566 : 						// Try to change the current item if it already exists, otherwise add it
; 2567 : 						if(!pDeal->ChangeResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration))

	mov	edx, DWORD PTR _iDealDuration$[esp+16]
	push	edx
	push	ebx
	push	edi
	push	esi
	mov	ecx, ebp
	call	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
	test	al, al
	jne	SHORT $LN8@DoAddResou

; 2568 : 						{
; 2569 : 							pDeal->AddResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration);

	mov	eax, DWORD PTR _iDealDuration$[esp+16]
	push	eax
	push	ebx
	push	edi
	push	esi
	mov	ecx, ebp
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 2570 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	eax, DWORD PTR _iValueImOffering$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+24]
	push	edx
	push	eax
	push	ebp
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+16]
	mov	DWORD PTR [ecx], eax
$LN8@DoAddResou:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	$LL490@DoAddResou
$LN491@DoAddResou:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN7@DoAddResou:

; 2571 : 						}
; 2572 : 					}
; 2573 : 				}
; 2574 : 			}
; 2575 : 		}
; 2576 : 	}
; 2577 : }

	pop	ecx
	ret	36					; 00000024H
?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddResourceToThem
_TEXT	ENDS
PUBLIC	?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T231413 = -4						; size = 4
_iResourceQuantity$222981 = 8				; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
tv458 = 16						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddResourceToUs, COMDAT
; _this$ = ecx

; 2581 : {

	sub	esp, 8

; 2582 : 	CvAssert(eThem >= 0);
; 2583 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2584 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Resource to Us, but them is us.  Please show Jon");
; 2585 : 
; 2586 : 	if(!bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp+4], 0
	mov	DWORD PTR _this$[esp+8], ecx
	jne	$LN9@DoAddResou@2

; 2587 : 	{
; 2588 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp+4]
	cmp	DWORD PTR [eax], 0
	jle	$LN9@DoAddResou@2

; 2589 : 		{
; 2590 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR [ecx+44]
	push	esi

; 2591 : 
; 2592 : 			int iItemValue;
; 2593 : 
; 2594 : 			ResourceTypes eResource;
; 2595 : 			int iResourceQuantity;
; 2596 : #ifdef AUI_WARNING_FIXES
; 2597 : 			for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2598 : #else
; 2599 : 			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN132@DoAddResou@2
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	push	ebx
	mov	ebx, DWORD PTR _pDeal$[esp+16]
	push	edi
	mov	DWORD PTR tv458[esp+20], ecx
	jmp	SHORT $LN11@DoAddResou@2
	npad	3
$LL131@DoAddResou@2:
	mov	ecx, DWORD PTR tv458[esp+20]
$LN11@DoAddResou@2:

; 2600 : #endif
; 2601 : 			{
; 2602 : 				eResource = (ResourceTypes) iResourceLoop;
; 2603 : 				iResourceQuantity = GET_PLAYER(eMyPlayer).getNumResourceAvailable(eResource, false);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	add	ecx, edx
	push	esi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	edi, eax
	mov	DWORD PTR _iResourceQuantity$222981[esp+20], edi

; 2604 : 
; 2605 : 				// Don't bother looking at this Resource if we don't even have any of it
; 2606 : 				if(iResourceQuantity == 0)

	test	edi, edi
	je	$LN10@DoAddResou@2

; 2607 : 				{
; 2608 : 					continue;
; 2609 : 				}
; 2610 : 
; 2611 : 				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2612 : 				if (pkResourceInfo == NULL)

	test	eax, eax
	je	$LN10@DoAddResou@2

; 2613 : 					continue;
; 2614 : 
; 2615 : 				// Quantity is always 1 if it's a Luxury, 5 if Strategic
; 2616 : 				if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN6@DoAddResou@2

; 2617 : 				{
; 2618 : 					iResourceQuantity = 1;
; 2619 : 
; 2620 : 					// Don't bother if they wouldn't get Happiness from it due to World Congress
; 2621 : 					if(GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(eThem, eResource))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	edi, DWORD PTR [eax-1]
	mov	eax, DWORD PTR _eThem$[esp+20]
	push	esi
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	test	al, al
	jne	$LN10@DoAddResou@2

; 2622 : 						continue;
; 2623 : 				}
; 2624 : 				else

	jmp	SHORT $LN4@DoAddResou@2
$LN6@DoAddResou@2:

; 2625 : 				{
; 2626 : 					iResourceQuantity = min(5, iResourceQuantity);	// 5 or what we have, whichever is less

	cmp	edi, 5
	mov	DWORD PTR $T231413[esp+24], 5
	lea	eax, DWORD PTR _iResourceQuantity$222981[esp+20]
	jl	SHORT $LN29@DoAddResou@2
	lea	eax, DWORD PTR $T231413[esp+24]
$LN29@DoAddResou@2:
	mov	edi, DWORD PTR [eax]
$LN4@DoAddResou@2:

; 2627 : 				}
; 2628 : 
; 2629 : 				// See if we can actually trade it to them
; 2630 : 				if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	mov	ecx, DWORD PTR _eThem$[esp+20]
	push	0
	push	1
	push	0
	push	-1
	push	edi
	push	esi
	push	3
	push	ecx
	push	ebp
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN10@DoAddResou@2

; 2631 : 				{
; 2632 : 					iItemValue = GetTradeItemValue(TRADE_ITEM_RESOURCES, /*bFromMe*/ true, eThem, eResource, iResourceQuantity, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	mov	edx, DWORD PTR _eThem$[esp+20]
	mov	eax, DWORD PTR _iDealDuration$[esp+20]
	mov	ecx, DWORD PTR _this$[esp+24]
	push	edx
	push	1
	push	eax
	push	edi
	push	esi
	call	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue

; 2633 : 
; 2634 : 					// If adding this to the deal doesn't take it under the min limit, do it
; 2635 : 					if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	ecx, DWORD PTR _iTotalValue$[esp+20]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[esp+20]
	jl	SHORT $LN10@DoAddResou@2

; 2636 : 					{
; 2637 : 						// Try to change the current item if it already exists, otherwise add it
; 2638 : 						if(!pDeal->ChangeResourceTrade(eMyPlayer, eResource, iResourceQuantity, iDealDuration))

	mov	eax, DWORD PTR _iDealDuration$[esp+20]
	push	eax
	push	edi
	push	esi
	push	ebp
	mov	ecx, ebx
	call	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
	test	al, al
	jne	SHORT $LN10@DoAddResou@2

; 2639 : 						{
; 2640 : 							pDeal->AddResourceTrade(eMyPlayer, eResource, iResourceQuantity, iDealDuration);

	mov	ecx, DWORD PTR _iDealDuration$[esp+20]
	push	ecx
	push	edi
	push	esi
	push	ebp
	mov	ecx, ebx
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 2641 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+20]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+20]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+20]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+36]
	push	ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+20]
	mov	DWORD PTR [edx], eax
$LN10@DoAddResou@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	$LL131@DoAddResou@2
	pop	edi
	pop	ebx
$LN132@DoAddResou@2:
	pop	esi
	pop	ebp
$LN9@DoAddResou@2:

; 2642 : 						}
; 2643 : 					}
; 2644 : 				}
; 2645 : 			}
; 2646 : 		}
; 2647 : 	}
; 2648 : }

	add	esp, 8
	ret	36					; 00000024H
?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddResourceToUs
_TEXT	ENDS
PUBLIC	?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToThem
EXTRN	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::AddAllowEmbassy
EXTRN	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsAllowEmbassyTrade
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddEmbassyToThem, COMDAT
; _this$ = ecx

; 2654 : 	CvAssert(eThem >= 0);
; 2655 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2656 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Embassy to Them, but them is us.  Please show Jon");
; 2657 : 
; 2658 : 	if(!bDontChangeTheirExistingItems)

	cmp	BYTE PTR _bDontChangeTheirExistingItems$[esp-4], 0
	push	edi
	mov	edi, ecx
	jne	$LN1@DoAddEmbas

; 2659 : 	{
; 2660 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[esp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN1@DoAddEmbas
	push	ebx

; 2661 : 		{
; 2662 : 			if(!pDeal->IsAllowEmbassyTrade(eThem))

	mov	ebx, DWORD PTR _pDeal$[esp+4]
	push	esi
	mov	esi, DWORD PTR _eThem$[esp+8]
	push	esi
	mov	ecx, ebx
	call	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsAllowEmbassyTrade
	test	al, al
	jne	SHORT $LN235@DoAddEmbas

; 2663 : 			{
; 2664 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]

; 2665 : 
; 2666 : 				// See if they can actually trade it to us
; 2667 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_ALLOW_EMBASSY))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	push	eax
	push	esi
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN235@DoAddEmbas
	push	ebp

; 2668 : 				{
; 2669 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_ALLOW_EMBASSY, /*bFromMe*/ false, eThem, -1, -1, -1, /*bFlag1*/false, -1, bUseEvenValue);

	mov	ebp, DWORD PTR _bUseEvenValue$[esp+12]
	push	ebp
	push	esi
	push	0
	mov	ecx, edi
	call	?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetEmbassyValue

; 2670 : 
; 2671 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2672 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	edx, DWORD PTR _iTotalValue$[esp+12]
	mov	ecx, DWORD PTR [edx]
	add	ecx, eax
	cmp	ecx, DWORD PTR _iAmountOverWeWillRequest$[esp+12]
	jg	SHORT $LN237@DoAddEmbas

; 2673 : 					{
; 2674 : 						pDeal->AddAllowEmbassy(eThem);

	push	esi
	mov	ecx, ebx
	call	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddAllowEmbassy

; 2675 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	eax, DWORD PTR _iValueImOffering$[esp+12]
	push	ebp
	push	edx
	push	eax
	push	ebx
	mov	ecx, edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+12]
	mov	DWORD PTR [ecx], eax
$LN237@DoAddEmbas:
	pop	ebp
$LN235@DoAddEmbas:
	pop	esi
	pop	ebx
$LN1@DoAddEmbas:
	pop	edi

; 2676 : 					}
; 2677 : 				}
; 2678 : 			}
; 2679 : 		}
; 2680 : 	}
; 2681 : }

	ret	32					; 00000020H
?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddEmbassyToThem
_TEXT	ENDS
PUBLIC	?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddEmbassyToUs, COMDAT
; _this$ = ecx

; 2686 : 	CvAssert(eThem >= 0);
; 2687 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2688 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Embassy to Us, but them is us.  Please show Jon");
; 2689 : 
; 2690 : 	if(!bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp-4], 0
	push	ebp
	mov	ebp, ecx
	jne	$LN1@DoAddEmbas@2

; 2691 : 	{
; 2692 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1@DoAddEmbas@2

; 2693 : 		{
; 2694 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ebp]
	push	esi

; 2695 : 
; 2696 : 			if(!pDeal->IsAllowEmbassyTrade(eMyPlayer))

	mov	esi, DWORD PTR _pDeal$[esp+4]
	push	edi
	mov	edi, DWORD PTR [ecx+44]
	push	edi
	mov	ecx, esi
	call	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsAllowEmbassyTrade
	test	al, al
	jne	SHORT $LN113@DoAddEmbas@2
	push	ebx

; 2697 : 			{
; 2698 : 				// See if we can actually trade it to them
; 2699 : 				if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_ALLOW_EMBASSY))

	mov	ebx, DWORD PTR _eThem$[esp+12]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN115@DoAddEmbas@2

; 2700 : 				{
; 2701 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_ALLOW_EMBASSY, /*bFromMe*/ true, eThem, -1, -1, -1, /*bFlag1*/false, -1, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+12]
	push	edx
	push	ebx
	push	1
	mov	ecx, ebp
	call	?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetEmbassyValue

; 2702 : 
; 2703 : 					// If adding this to the deal doesn't take it under the min limit, do it
; 2704 : 					if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	ebx, DWORD PTR _iTotalValue$[esp+12]
	mov	ecx, DWORD PTR [ebx]
	sub	ecx, eax
	cmp	ecx, DWORD PTR _iAmountUnderWeWillOffer$[esp+12]
	jl	SHORT $LN115@DoAddEmbas@2

; 2705 : 					{
; 2706 : 						pDeal->AddAllowEmbassy(eMyPlayer);

	push	edi
	mov	ecx, esi
	call	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddAllowEmbassy

; 2707 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+12]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+12]
	push	edx
	push	eax
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	DWORD PTR [ebx], eax
$LN115@DoAddEmbas@2:
	pop	ebx
$LN113@DoAddEmbas@2:
	pop	edi
	pop	esi
$LN1@DoAddEmbas@2:
	pop	ebp

; 2708 : 					}
; 2709 : 				}
; 2710 : 			}
; 2711 : 		}
; 2712 : 	}
; 2713 : }

	ret	32					; 00000020H
?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddEmbassyToUs
_TEXT	ENDS
PUBLIC	?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToThem
EXTRN	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddOpenBorders
EXTRN	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsOpenBordersTrade
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddOpenBordersToThem, COMDAT
; _this$ = ecx

; 2718 : 	CvAssert(eThem >= 0);
; 2719 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2720 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Open Borders to Them, but them is us.  Please show Jon");
; 2721 : 
; 2722 : 	if(!bDontChangeTheirExistingItems)

	cmp	BYTE PTR _bDontChangeTheirExistingItems$[esp-4], 0
	push	edi
	mov	edi, ecx
	jne	$LN1@DoAddOpenB

; 2723 : 	{
; 2724 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[esp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN1@DoAddOpenB
	push	ebx

; 2725 : 		{
; 2726 : 			if(!pDeal->IsOpenBordersTrade(eThem))

	mov	ebx, DWORD PTR _pDeal$[esp+4]
	push	esi
	mov	esi, DWORD PTR _eThem$[esp+8]
	push	esi
	mov	ecx, ebx
	call	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsOpenBordersTrade
	test	al, al
	jne	SHORT $LN235@DoAddOpenB

; 2727 : 			{
; 2728 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]

; 2729 : 
; 2730 : 				// See if they can actually trade it to us
; 2731 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_OPEN_BORDERS))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	push	eax
	push	esi
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN235@DoAddOpenB
	push	ebp

; 2732 : 				{
; 2733 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_OPEN_BORDERS, /*bFromMe*/ false, eThem, -1, -1, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	mov	ebp, DWORD PTR _bUseEvenValue$[esp+12]
	push	ebp
	push	esi
	push	0
	mov	ecx, edi
	call	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue

; 2734 : 
; 2735 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2736 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	edx, DWORD PTR _iTotalValue$[esp+12]
	mov	ecx, DWORD PTR [edx]
	add	ecx, eax
	cmp	ecx, DWORD PTR _iAmountOverWeWillRequest$[esp+12]
	jg	SHORT $LN237@DoAddOpenB

; 2737 : 					{
; 2738 : 						pDeal->AddOpenBorders(eThem, iDealDuration);

	mov	edx, DWORD PTR _iDealDuration$[esp+12]
	push	edx
	push	esi
	mov	ecx, ebx
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders

; 2739 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+12]
	push	ebp
	push	eax
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+12]
	mov	DWORD PTR [edx], eax
$LN237@DoAddOpenB:
	pop	ebp
$LN235@DoAddOpenB:
	pop	esi
	pop	ebx
$LN1@DoAddOpenB:
	pop	edi

; 2740 : 					}
; 2741 : 				}
; 2742 : 			}
; 2743 : 		}
; 2744 : 	}
; 2745 : }

	ret	36					; 00000024H
?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddOpenBordersToThem
_TEXT	ENDS
PUBLIC	?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddOpenBordersToUs, COMDAT
; _this$ = ecx

; 2750 : 	CvAssert(eThem >= 0);
; 2751 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2752 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Open Borders to Us, but them is us.  Please show Jon");
; 2753 : 
; 2754 : 	if(!bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp-4], 0
	push	ebp
	mov	ebp, ecx
	jne	$LN1@DoAddOpenB@2

; 2755 : 	{
; 2756 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1@DoAddOpenB@2

; 2757 : 		{
; 2758 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ebp]
	push	esi

; 2759 : 
; 2760 : 			if(!pDeal->IsOpenBordersTrade(eMyPlayer))

	mov	esi, DWORD PTR _pDeal$[esp+4]
	push	edi
	mov	edi, DWORD PTR [ecx+44]
	push	edi
	mov	ecx, esi
	call	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsOpenBordersTrade
	test	al, al
	jne	SHORT $LN113@DoAddOpenB@2
	push	ebx

; 2761 : 			{
; 2762 : 				// See if we can actually trade it to them
; 2763 : 				if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_OPEN_BORDERS))

	mov	ebx, DWORD PTR _eThem$[esp+12]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN115@DoAddOpenB@2

; 2764 : 				{
; 2765 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_OPEN_BORDERS, /*bFromMe*/ true, eThem, -1, -1, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+12]
	push	edx
	push	ebx
	push	1
	mov	ecx, ebp
	call	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue

; 2766 : 
; 2767 : 					// If adding this to the deal doesn't take it under the min limit, do it
; 2768 : 					if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	ebx, DWORD PTR _iTotalValue$[esp+12]
	mov	ecx, DWORD PTR [ebx]
	sub	ecx, eax
	cmp	ecx, DWORD PTR _iAmountUnderWeWillOffer$[esp+12]
	jl	SHORT $LN115@DoAddOpenB@2

; 2769 : 					{
; 2770 : 						pDeal->AddOpenBorders(eMyPlayer, iDealDuration);

	mov	edx, DWORD PTR _iDealDuration$[esp+12]
	push	edx
	push	edi
	mov	ecx, esi
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders

; 2771 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp+12]
	mov	ecx, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	edx, DWORD PTR _iValueImOffering$[esp+12]
	push	eax
	push	ecx
	push	edx
	push	esi
	mov	ecx, ebp
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	DWORD PTR [ebx], eax
$LN115@DoAddOpenB@2:
	pop	ebx
$LN113@DoAddOpenB@2:
	pop	edi
	pop	esi
$LN1@DoAddOpenB@2:
	pop	ebp

; 2772 : 					}
; 2773 : 				}
; 2774 : 			}
; 2775 : 		}
; 2776 : 	}
; 2777 : }

	ret	36					; 00000024H
?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddOpenBordersToUs
_TEXT	ENDS
PUBLIC	?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToThem
EXTRN	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z:PROC ; CvDeal::ChangeGoldTrade
EXTRN	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z:PROC ; CvDeal::GetGoldTrade
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNumGold$223340 = 8					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
$T233675 = 16						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z PROC ; CvDealAI::DoAddGoldToThem, COMDAT
; _this$ = ecx

; 2893 : {

	push	ecx

; 2894 : 	CvAssert(eThem >= 0);
; 2895 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2896 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Gold to Them, but them is us.  Please show Jon");
; 2897 : 
; 2898 : 	if(!bDontChangeTheirExistingItems)

	cmp	BYTE PTR _bDontChangeTheirExistingItems$[esp], 0
	mov	DWORD PTR _this$[esp+4], ecx
	jne	$LN2@DoAddGoldT
	push	esi

; 2899 : 	{
; 2900 : 		if(iTotalValue < 0)

	mov	esi, DWORD PTR _iTotalValue$[esp+4]
	cmp	DWORD PTR [esi], 0
	jge	$LN63@DoAddGoldT

; 2901 : 		{
; 2902 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	push	ebx

; 2903 : 
; 2904 : 			// Can't already be Gold from the other player in the Deal
; 2905 : 			if(pDeal->GetGoldTrade(eMyPlayer) == 0)

	mov	ebx, DWORD PTR _pDeal$[esp+8]
	push	eax
	mov	ecx, ebx
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	$LN64@DoAddGoldT

; 2906 : 			{
; 2907 : 				int iNumGold = GetGoldForForValueExchange(-iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6068
	push	ebp
	push	edi
	mov	edi, DWORD PTR [esi]
	neg	edi
	test	ecx, ecx
	jne	SHORT $LN39@DoAddGoldT
	mov	ecx, 1
$LN39@DoAddGoldT:
	mov	eax, edi
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	cmp	BYTE PTR _bUseEvenValue$[esp+16], 0
	mov	ebp, DWORD PTR _eThem$[esp+16]
	mov	esi, eax
	je	SHORT $LN13@DoAddGoldT
	mov	ecx, DWORD PTR _this$[esp+20]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	push	0
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	push	1
	push	1
	push	edi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	add	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
$LN13@DoAddGoldT:

; 2908 : 				int iNumGoldAlreadyInTrade = pDeal->GetGoldTrade(eThem);

	push	ebp
	mov	ecx, ebx
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	edi, eax

; 2909 : 				iNumGold += iNumGoldAlreadyInTrade;
; 2910 : 				iNumGold = min(iNumGold, pDeal->GetGoldAvailable(eThem, TRADE_ITEM_GOLD));

	push	0
	add	esi, edi
	push	ebp
	mov	ecx, ebx
	mov	DWORD PTR _iNumGold$223340[esp+24], esi
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR $T233675[esp+16], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T233675[esp+16]
	jl	SHORT $LN62@DoAddGoldT
	lea	eax, DWORD PTR _iNumGold$223340[esp+16]
$LN62@DoAddGoldT:
	mov	esi, DWORD PTR [eax]

; 2911 : 				//iNumGold = min(iNumGold, GET_PLAYER(eThem).GetTreasury()->GetGold());
; 2912 : 
; 2913 : 				if(iNumGold != iNumGoldAlreadyInTrade && !pDeal->ChangeGoldTrade(eThem, iNumGold))

	cmp	esi, edi
	je	SHORT $LN1@DoAddGoldT
	push	esi
	push	ebp
	mov	ecx, ebx
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade
	test	al, al
	jne	SHORT $LN1@DoAddGoldT

; 2914 : 				{
; 2915 : 					pDeal->AddGoldTrade(eThem, iNumGold);

	push	esi
	push	ebp
	mov	ecx, ebx
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
$LN1@DoAddGoldT:

; 2916 : 				}
; 2917 : 
; 2918 : 				iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp+16]
	mov	ecx, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	edx, DWORD PTR _iValueImOffering$[esp+16]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+28]
	push	edx
	push	ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+16]
	pop	edi
	mov	DWORD PTR [ecx], eax
	pop	ebp
$LN64@DoAddGoldT:
	pop	ebx
$LN63@DoAddGoldT:
	pop	esi
$LN2@DoAddGoldT:

; 2919 : 			}
; 2920 : 		}
; 2921 : 	}
; 2922 : }

	pop	ecx
	ret	28					; 0000001cH
?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ENDP ; CvDealAI::DoAddGoldToThem
_TEXT	ENDS
PUBLIC	?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDeal$ = 8						; size = 4
_iNumGold$223358 = 12					; size = 4
_eThem$ = 12						; size = 4
$T233785 = 16						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z PROC ; CvDealAI::DoAddGoldToUs, COMDAT
; _this$ = ecx

; 2926 : {

	push	ecx

; 2927 : 	CvAssert(eThem >= 0);
; 2928 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2929 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Gold to Us, but them is us.  Please show Jon");
; 2930 : 
; 2931 : 	if(!bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp], 0
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+8], edi
	jne	$LN2@DoAddGoldT@2

; 2932 : 	{
; 2933 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp+4]
	cmp	DWORD PTR [eax], 0
	jle	$LN2@DoAddGoldT@2
	push	ebx

; 2934 : 		{
; 2935 : 			// Can't already be Gold from the other player in the Deal
; 2936 : 			if(pDeal->GetGoldTrade(eThem) == 0)

	mov	ebx, DWORD PTR _pDeal$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _eThem$[esp+12]
	push	ebp
	mov	ecx, ebx
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	$LN17@DoAddGoldT@2

; 2937 : 			{
; 2938 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 2939 : 
; 2940 : 				int iNumGold = GetGoldForForValueExchange(iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ false);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+12]
	mov	ecx, DWORD PTR [edi]
	push	esi
	mov	esi, DWORD PTR [ecx+44]
	push	eax
	mov	eax, DWORD PTR _iTotalValue$[esp+20]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ebp
	push	1
	push	1
	push	ecx
	mov	ecx, edi
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange

; 2941 : 				int iNumGoldAlreadyInTrade = pDeal->GetGoldTrade(eMyPlayer);

	push	esi
	mov	ecx, ebx
	mov	edi, eax
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	ebp, eax

; 2942 : 				iNumGold += iNumGoldAlreadyInTrade;
; 2943 : 				iNumGold = min(iNumGold, pDeal->GetGoldAvailable(eMyPlayer, TRADE_ITEM_GOLD));

	push	0
	add	edi, ebp
	push	esi
	mov	ecx, ebx
	mov	DWORD PTR _iNumGold$223358[esp+24], edi
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR $T233785[esp+16], eax
	cmp	eax, edi
	lea	eax, DWORD PTR $T233785[esp+16]
	jl	SHORT $LN16@DoAddGoldT@2
	lea	eax, DWORD PTR _iNumGold$223358[esp+16]
$LN16@DoAddGoldT@2:
	mov	edi, DWORD PTR [eax]

; 2944 : 				//iNumGold = min(iNumGold, GET_PLAYER(eMyPlayer).GetTreasury()->GetGold());
; 2945 : 
; 2946 : 				if(iNumGold != iNumGoldAlreadyInTrade && !pDeal->ChangeGoldTrade(eMyPlayer, iNumGold))

	cmp	edi, ebp
	je	SHORT $LN1@DoAddGoldT@2
	push	edi
	push	esi
	mov	ecx, ebx
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade
	test	al, al
	jne	SHORT $LN1@DoAddGoldT@2

; 2947 : 				{
; 2948 : 					pDeal->AddGoldTrade(eMyPlayer, iNumGold);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
$LN1@DoAddGoldT@2:

; 2949 : 				}
; 2950 : 
; 2951 : 				iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+16]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+32]
	push	ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	mov	DWORD PTR [edx], eax
	pop	esi
$LN17@DoAddGoldT@2:
	pop	ebp
	pop	ebx
$LN2@DoAddGoldT@2:
	pop	edi

; 2952 : 			}
; 2953 : 		}
; 2954 : 	}
; 2955 : }

	pop	ecx
	ret	28					; 0000001cH
?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ENDP ; CvDealAI::DoAddGoldToUs
_TEXT	ENDS
PUBLIC	?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToThem
EXTRN	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z:PROC ; CvDeal::AddGoldPerTurnTrade
EXTRN	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z:PROC ; CvDeal::ChangeGoldPerTurnTrade
EXTRN	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z:PROC ; CvDeal::GetGoldPerTurnTrade
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
$T233812 = 16						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iNumGPT$223378 = 32					; size = 4
_iDealDuration$ = 32					; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddGPTToThem, COMDAT
; _this$ = ecx

; 2959 : {

	push	ecx

; 2960 : 	CvAssert(eThem >= 0);
; 2961 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2962 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add GPT to Them, but them is us.  Please show Jon");
; 2963 : 
; 2964 : 	if(!bDontChangeTheirExistingItems)

	cmp	BYTE PTR _bDontChangeTheirExistingItems$[esp], 0
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+8], edi
	jne	$LN2@DoAddGPTTo
	push	esi

; 2965 : 	{
; 2966 : 		if(iTotalValue < 0)

	mov	esi, DWORD PTR _iTotalValue$[esp+8]
	cmp	DWORD PTR [esi], 0
	jge	$LN70@DoAddGPTTo

; 2967 : 		{
; 2968 : 			if(GET_PLAYER(eThem).calculateGoldRate() > 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ebp, DWORD PTR _eThem$[esp+12]
	imul	ebp, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	test	eax, eax
	jle	$LN71@DoAddGPTTo

; 2969 : 			{
; 2970 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]

; 2971 : 
; 2972 : 				// Can't already be GPT from the other player in the Deal
; 2973 : 				if(pDeal->GetGoldPerTurnTrade(eMyPlayer) == 0)

	mov	ecx, DWORD PTR _pDeal$[esp+12]
	push	eax
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	test	eax, eax
	jne	$LN71@DoAddGPTTo

; 2974 : 				{
; 2975 : 					int iNumGPT = GetGPTforForValueExchange(-iTotalValue, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ false);

	mov	edi, DWORD PTR [esi]
	neg	edi
	mov	eax, edi
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6072
	push	ebx
	mov	ebx, DWORD PTR _iDealDuration$[esp+16]
	cdq
	idiv	ebx
	cmp	BYTE PTR _bUseEvenValue$[esp+16], 0
	mov	esi, eax
	je	SHORT $LN16@DoAddGPTTo
	mov	edx, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	0
	push	eax
	push	1
	push	ebx
	push	1
	add	ecx, ebp
	push	edi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	add	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
$LN16@DoAddGPTTo:

; 2976 : 					int iNumGPTAlreadyInTrade = pDeal->GetGoldPerTurnTrade(eThem);

	mov	edx, DWORD PTR _eThem$[esp+16]
	mov	ecx, DWORD PTR _pDeal$[esp+16]
	push	edx
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	edi, eax

; 2977 : 					iNumGPT += iNumGPTAlreadyInTrade;
; 2978 : 					iNumGPT = min(iNumGPT, GET_PLAYER(eThem).calculateGoldRate());

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, edi
	lea	ecx, DWORD PTR [eax+ebp]
	mov	DWORD PTR _iNumGPT$223378[esp+16], esi
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	mov	DWORD PTR $T233812[esp+16], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T233812[esp+16]
	jl	SHORT $LN68@DoAddGPTTo
	lea	eax, DWORD PTR _iNumGPT$223378[esp+16]
$LN68@DoAddGPTTo:
	mov	esi, DWORD PTR [eax]

; 2979 : 
; 2980 : 					if(iNumGPT != iNumGPTAlreadyInTrade && !pDeal->ChangeGoldPerTurnTrade(eThem, iNumGPT, iDealDuration))

	cmp	esi, edi
	mov	edi, DWORD PTR _pDeal$[esp+16]
	je	SHORT $LN1@DoAddGPTTo
	mov	ebp, DWORD PTR _eThem$[esp+16]
	push	ebx
	push	esi
	push	ebp
	mov	ecx, edi
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade
	test	al, al
	jne	SHORT $LN1@DoAddGPTTo

; 2981 : 					{
; 2982 : 						pDeal->AddGoldPerTurnTrade(eThem, iNumGPT, iDealDuration);

	push	ebx
	push	esi
	push	ebp
	mov	ecx, edi
	call	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
$LN1@DoAddGPTTo:

; 2983 : 					}
; 2984 : 
; 2985 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	eax, DWORD PTR _iValueImOffering$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+24]
	push	edx
	push	eax
	push	edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+16]
	mov	DWORD PTR [ecx], eax
	pop	ebx
$LN71@DoAddGPTTo:
	pop	ebp
$LN70@DoAddGPTTo:
	pop	esi
$LN2@DoAddGPTTo:
	pop	edi

; 2986 : 				}
; 2987 : 			}
; 2988 : 		}
; 2989 : 	}
; 2990 : }

	pop	ecx
	ret	32					; 00000020H
?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddGPTToThem
_TEXT	ENDS
PUBLIC	?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDeal$ = 8						; size = 4
_iNumGPT$223398 = 12					; size = 4
_eThem$ = 12						; size = 4
$T233934 = 16						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iDealDuration$ = 32					; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddGPTToUs, COMDAT
; _this$ = ecx

; 2994 : {

	push	ecx

; 2995 : 	CvAssert(eThem >= 0);
; 2996 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2997 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add GPT to Us, but them is us.  Please show Jon");
; 2998 : 
; 2999 : 	if(!bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+8], ebx
	jne	$LN2@DoAddGPTTo@2

; 3000 : 	{
; 3001 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp+4]
	cmp	DWORD PTR [eax], 0
	jle	$LN2@DoAddGPTTo@2

; 3002 : 		{
; 3003 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ebx]

; 3004 : 
; 3005 : 			if(GET_PLAYER(eMyPlayer).calculateGoldRate() > 0)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ebp, DWORD PTR [ecx+44]
	push	edi
	mov	edi, ebp
	imul	edi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+edx]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	test	eax, eax
	jle	$LN23@DoAddGPTTo@2

; 3006 : 			{
; 3007 : 				// Can't already be GPT from the other player in the Deal
; 3008 : 				if(pDeal->GetGoldPerTurnTrade(eThem) == 0)

	mov	ecx, DWORD PTR _pDeal$[esp+12]
	push	esi
	mov	esi, DWORD PTR _eThem$[esp+16]
	push	esi
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	test	eax, eax
	jne	$LN25@DoAddGPTTo@2

; 3009 : 				{
; 3010 : 					int iNumGPT = GetGPTforForValueExchange(iTotalValue, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ false);

	mov	ecx, DWORD PTR _iDealDuration$[esp+16]
	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	push	eax
	mov	eax, DWORD PTR _bUseEvenValue$[esp+20]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	push	1
	push	ecx
	push	1
	push	eax
	mov	ecx, ebx
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange

; 3011 : 					int iNumGPTAlreadyInTrade = pDeal->GetGoldPerTurnTrade(eMyPlayer);

	mov	ecx, DWORD PTR _pDeal$[esp+16]
	push	ebp
	mov	esi, eax
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade

; 3012 : 					iNumGPT += iNumGPTAlreadyInTrade;
; 3013 : 					iNumGPT = min(iNumGPT, GET_PLAYER(eMyPlayer).calculateGoldRate());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, eax
	add	esi, ebx
	add	ecx, edi
	mov	DWORD PTR _iNumGPT$223398[esp+16], esi
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	mov	DWORD PTR $T233934[esp+16], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T233934[esp+16]
	jl	SHORT $LN21@DoAddGPTTo@2
	lea	eax, DWORD PTR _iNumGPT$223398[esp+16]
$LN21@DoAddGPTTo@2:
	mov	esi, DWORD PTR [eax]

; 3014 : 
; 3015 : 					if(iNumGPT != iNumGPTAlreadyInTrade && !pDeal->ChangeGoldPerTurnTrade(eMyPlayer, iNumGPT, iDealDuration))

	mov	edi, DWORD PTR _pDeal$[esp+16]
	cmp	esi, ebx
	je	SHORT $LN1@DoAddGPTTo@2
	mov	ebx, DWORD PTR _iDealDuration$[esp+16]
	push	ebx
	push	esi
	push	ebp
	mov	ecx, edi
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade
	test	al, al
	jne	SHORT $LN1@DoAddGPTTo@2

; 3016 : 					{
; 3017 : 						pDeal->AddGoldPerTurnTrade(eMyPlayer, iNumGPT, iDealDuration);

	push	ebx
	push	esi
	push	ebp
	mov	ecx, edi
	call	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
$LN1@DoAddGPTTo@2:

; 3018 : 					}
; 3019 : 
; 3020 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+16]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+32]
	push	edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	mov	DWORD PTR [edx], eax
$LN25@DoAddGPTTo@2:
	pop	esi
$LN23@DoAddGPTTo@2:
	pop	edi
	pop	ebp
$LN2@DoAddGPTTo@2:
	pop	ebx

; 3021 : 				}
; 3022 : 			}
; 3023 : 		}
; 3024 : 	}
; 3025 : }

	pop	ecx
	ret	32					; 00000020H
?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddGPTToUs
_TEXT	ENDS
PUBLIC	?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromThem
EXTRN	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z:PROC ; CvDeal::RemoveByType
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDeal$ = 8						; size = 4
_iNumGoldPerTurnToRemove$223414 = 12			; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_iNumGoldPerTurnInThisDeal$223415 = 28			; size = 4
_iDealDuration$ = 28					; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z PROC ; CvDealAI::DoRemoveGPTFromThem, COMDAT
; _this$ = ecx

; 3029 : {

	push	ecx

; 3030 : 	CvAssert(eThem >= 0);
; 3031 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3032 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove GPT from Them, but them is us.  Please show Jon");
; 3033 : 
; 3034 : //	if (!bDontChangeTheirExistingItems)
; 3035 : 	{
; 3036 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[esp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+4], ecx
	test	eax, eax
	jle	$LN2@DoRemoveGP

; 3037 : 		{
; 3038 : 			// Try to remove a bit more than the actual value discrepancy, as this should get us closer to even in the long-run
; 3039 : 			int iValueToRemove = iTotalValue * 150;

	imul	eax, 150				; 00000096H

; 3040 : 			iValueToRemove /= 100;

	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	push	ebx
	sar	edx, 5
	push	ebp
	push	esi
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 3041 : 
; 3042 : 			int iNumGoldPerTurnToRemove = GetGPTforForValueExchange(iValueToRemove, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ true);

	mov	eax, esi
	imul	eax, 100				; 00000064H
	add	eax, 99					; 00000063H
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6072
	mov	ebp, DWORD PTR _iDealDuration$[esp+12]
	mov	ebx, DWORD PTR _eThem$[esp+12]
	push	edi
	cdq
	idiv	ebp
	cmp	BYTE PTR _bUseEvenValue$[esp+16], 0
	mov	edi, eax
	je	SHORT $LN8@DoRemoveGP
	mov	ecx, DWORD PTR _this$[esp+20]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	push	1
	push	0
	mov	ecx, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	push	1
	push	ebp
	push	1
	push	esi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	add	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
$LN8@DoRemoveGP:

; 3043 : 
; 3044 : 			int iNumGoldPerTurnInThisDeal = pDeal->GetGoldPerTurnTrade(eThem);

	mov	esi, DWORD PTR _pDeal$[esp+16]
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _iNumGoldPerTurnToRemove$223414[esp+20], edi
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	DWORD PTR _iNumGoldPerTurnInThisDeal$223415[esp+16], eax

; 3045 : 			if(iNumGoldPerTurnInThisDeal > 0)

	test	eax, eax
	jle	SHORT $LN59@DoRemoveGP

; 3046 : 			{
; 3047 : 				// Found some GoldPerTurn to remove
; 3048 : 				iNumGoldPerTurnToRemove = min(iNumGoldPerTurnToRemove, iNumGoldPerTurnInThisDeal);

	cmp	eax, edi
	lea	ecx, DWORD PTR _iNumGoldPerTurnInThisDeal$223415[esp+16]
	jl	SHORT $LN58@DoRemoveGP
	lea	ecx, DWORD PTR _iNumGoldPerTurnToRemove$223414[esp+16]
$LN58@DoRemoveGP:

; 3049 : 				iNumGoldPerTurnInThisDeal -= iNumGoldPerTurnToRemove;

	sub	eax, DWORD PTR [ecx]

; 3050 : 
; 3051 : 				// Removing ALL GoldPerTurn, so just erase the item from the deal
; 3052 : 				if(iNumGoldPerTurnInThisDeal == 0)
; 3053 : 				{
; 3054 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD_PER_TURN);

	mov	ecx, esi
	jne	SHORT $LN3@DoRemoveGP
	push	-1
	push	1
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3055 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	eax, DWORD PTR _bUseEvenValue$[esp+16]
	mov	ecx, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	edx, DWORD PTR _iValueImOffering$[esp+16]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+28]
	push	edx
	push	esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], eax
	pop	ebx

; 3066 : 				}
; 3067 : 			}
; 3068 : 		}
; 3069 : 	}
; 3070 : }

	pop	ecx
	ret	28					; 0000001cH
$LN3@DoRemoveGP:

; 3056 : 				}
; 3057 : 				// Remove some of the GoldPerTurn from the deal
; 3058 : 				else
; 3059 : 				{
; 3060 : 					if(!pDeal->ChangeGoldPerTurnTrade(eThem, iNumGoldPerTurnInThisDeal, iDealDuration))

	push	ebp
	push	eax
	push	ebx
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade

; 3061 : 					{
; 3062 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove GoldPerTurn from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3063 : 					}
; 3064 : 
; 3065 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+16]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+32]
	push	esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+16]
	mov	DWORD PTR [edx], eax
$LN59@DoRemoveGP:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN2@DoRemoveGP:

; 3066 : 				}
; 3067 : 			}
; 3068 : 		}
; 3069 : 	}
; 3070 : }

	pop	ecx
	ret	28					; 0000001cH
?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ENDP ; CvDealAI::DoRemoveGPTFromThem
_TEXT	ENDS
PUBLIC	?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
_iNumGoldPerTurnInThisDeal$223434 = 12			; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_iDealDuration$ = 28					; size = 4
_bUseEvenValue$ = 32					; size = 1
_iNumGoldPerTurnToRemove$223432 = 32			; size = 4
?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z PROC ; CvDealAI::DoRemoveGPTFromUs, COMDAT
; _this$ = ecx

; 3075 : 	CvAssert(eThem >= 0);
; 3076 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3077 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove GPT from Us, but them is us.  Please show Jon");
; 3078 : 
; 3079 : //	if (!bDontChangeMyExistingItems)
; 3080 : 	{
; 3081 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[esp-4]
	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jge	$LN2@DoRemoveGP@2

; 3082 : 		{
; 3083 : 			// Try to remove a bit more than the actual value discrepancy, as this should get us closer to even in the long-run
; 3084 : 			int iValueToRemove = -iTotalValue * 150;

	imul	eax, -150				; ffffff6aH

; 3085 : 			iValueToRemove /= 100;

	mov	ecx, eax
	push	ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3086 : 
; 3087 : 			int iNumGoldPerTurnToRemove = GetGPTforForValueExchange(iValueToRemove, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ true);

	mov	ecx, DWORD PTR _eThem$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _bUseEvenValue$[esp+8]
	push	edi
	push	1
	sar	edx, 5
	push	ebp
	mov	eax, edx
	push	ecx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR _iDealDuration$[esp+24]
	push	1
	push	edx
	push	1
	push	eax
	mov	ecx, esi
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange

; 3088 : 
; 3089 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 3090 : 
; 3091 : 			int iNumGoldPerTurnInThisDeal = pDeal->GetGoldPerTurnTrade(eMyPlayer);

	mov	edi, DWORD PTR _pDeal$[esp+12]
	mov	DWORD PTR _iNumGoldPerTurnToRemove$223432[esp+12], eax
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+44]
	push	ebx
	mov	ecx, edi
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	DWORD PTR _iNumGoldPerTurnInThisDeal$223434[esp+12], eax

; 3092 : 			if(iNumGoldPerTurnInThisDeal > 0)

	test	eax, eax
	jle	SHORT $LN18@DoRemoveGP@2

; 3093 : 			{
; 3094 : 				// Found some GoldPerTurn to remove
; 3095 : 				iNumGoldPerTurnToRemove = min(iNumGoldPerTurnToRemove, iNumGoldPerTurnInThisDeal);

	cmp	eax, DWORD PTR _iNumGoldPerTurnToRemove$223432[esp+12]
	lea	ecx, DWORD PTR _iNumGoldPerTurnInThisDeal$223434[esp+12]
	jl	SHORT $LN17@DoRemoveGP@2
	lea	ecx, DWORD PTR _iNumGoldPerTurnToRemove$223432[esp+12]
$LN17@DoRemoveGP@2:

; 3096 : 				iNumGoldPerTurnInThisDeal -= iNumGoldPerTurnToRemove;

	sub	eax, DWORD PTR [ecx]

; 3097 : 
; 3098 : 				// Removing ALL GoldPerTurn, so just erase the item from the deal
; 3099 : 				if(iNumGoldPerTurnInThisDeal == 0)
; 3100 : 				{
; 3101 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD_PER_TURN);

	mov	ecx, edi
	jne	SHORT $LN3@DoRemoveGP@2
	push	-1
	push	1
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3102 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	edx, DWORD PTR _iValueImOffering$[esp+12]
	push	ebp
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+12]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR [ecx], eax
	pop	esi

; 3113 : 				}
; 3114 : 			}
; 3115 : 		}
; 3116 : 	}
; 3117 : }

	ret	28					; 0000001cH
$LN3@DoRemoveGP@2:

; 3103 : 				}
; 3104 : 				// Remove some of the GoldPerTurn from the deal
; 3105 : 				else
; 3106 : 				{
; 3107 : 					if(!pDeal->ChangeGoldPerTurnTrade(eMyPlayer, iNumGoldPerTurnInThisDeal, iDealDuration))

	mov	edx, DWORD PTR _iDealDuration$[esp+12]
	push	edx
	push	eax
	push	ebx
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade

; 3108 : 					{
; 3109 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove GoldPerTurn from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3110 : 					}
; 3111 : 
; 3112 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+12]
	push	ebp
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+12]
	mov	DWORD PTR [edx], eax
$LN18@DoRemoveGP@2:
	pop	edi
	pop	ebp
	pop	ebx
$LN2@DoRemoveGP@2:
	pop	esi

; 3113 : 				}
; 3114 : 			}
; 3115 : 		}
; 3116 : 	}
; 3117 : }

	ret	28					; 0000001cH
?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ENDP ; CvDealAI::DoRemoveGPTFromUs
_TEXT	ENDS
PUBLIC	?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromThem
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z
_TEXT	SEGMENT
$T234099 = -4						; size = 4
_iNumGoldInThisDeal$223449 = 8				; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_bUseEvenValue$ = 28					; size = 1
?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z PROC ; CvDealAI::DoRemoveGoldFromThem, COMDAT
; _this$ = ecx

; 3121 : {

	push	ecx
	push	ebx
	push	esi

; 3122 : 	CvAssert(eThem >= 0);
; 3123 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3124 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove Gold from Them, but them is us.  Please show Jon");
; 3125 : 
; 3126 : //	if (!bDontChangeTheirExistingItems)
; 3127 : 	{
; 3128 : 		if(iTotalValue > 0)

	mov	esi, DWORD PTR _iTotalValue$[esp+8]
	cmp	DWORD PTR [esi], 0
	mov	ebx, ecx
	jle	$LN2@DoRemoveGo

; 3129 : 		{
; 3130 : 			int iNumGoldInThisDeal = pDeal->GetGoldTrade(eThem);

	mov	eax, DWORD PTR _eThem$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _pDeal$[esp+12]
	push	eax
	mov	ecx, ebp
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	DWORD PTR _iNumGoldInThisDeal$223449[esp+12], eax

; 3131 : 			if(iNumGoldInThisDeal > 0)

	test	eax, eax
	jle	$LN58@DoRemoveGo

; 3132 : 			{
; 3133 : 				// Found some Gold to remove
; 3134 : 				int iNumGoldToRemove = min(iNumGoldInThisDeal, GetGoldForForValueExchange(iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ true));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6068
	push	edi
	mov	edi, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $LN34@DoRemoveGo
	mov	ecx, 1
$LN34@DoRemoveGo:
	mov	eax, edi
	imul	eax, 100				; 00000064H
	add	eax, 99					; 00000063H
	cdq
	idiv	ecx
	cmp	BYTE PTR _bUseEvenValue$[esp+16], 0
	mov	esi, eax
	je	SHORT $LN8@DoRemoveGo
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _eThem$[esp+16]
	push	1
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	push	1
	push	1
	push	edi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	add	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
$LN8@DoRemoveGo:
	mov	eax, DWORD PTR _iNumGoldInThisDeal$223449[esp+16]
	cmp	esi, eax
	mov	DWORD PTR $T234099[esp+20], esi
	pop	edi
	lea	ecx, DWORD PTR $T234099[esp+16]
	jl	SHORT $LN57@DoRemoveGo
	lea	ecx, DWORD PTR _iNumGoldInThisDeal$223449[esp+12]
$LN57@DoRemoveGo:

; 3135 : 				iNumGoldInThisDeal -= iNumGoldToRemove;

	sub	eax, DWORD PTR [ecx]

; 3136 : 
; 3137 : 				// Removing ALL Gold, so just erase the item from the deal
; 3138 : 				if(iNumGoldInThisDeal == 0)
; 3139 : 				{
; 3140 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD);

	mov	ecx, ebp
	jne	SHORT $LN3@DoRemoveGo
	push	-1
	push	0
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3141 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+12]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+12]
	push	edx
	push	eax
	push	ecx
	push	ebp
	mov	ecx, ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[esp+12]
	pop	ebp
	pop	esi
	mov	DWORD PTR [edx], eax
	pop	ebx

; 3152 : 				}
; 3153 : 			}
; 3154 : 		}
; 3155 : 	}
; 3156 : }

	pop	ecx
	ret	24					; 00000018H
$LN3@DoRemoveGo:

; 3142 : 				}
; 3143 : 				// Remove some of the Gold from the deal
; 3144 : 				else
; 3145 : 				{
; 3146 : 					if(!pDeal->ChangeGoldTrade(eThem, iNumGoldInThisDeal))

	push	eax
	mov	eax, DWORD PTR _eThem$[esp+16]
	push	eax
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade

; 3147 : 					{
; 3148 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove Gold from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3149 : 					}
; 3150 : 
; 3151 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+12]
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+12]
	mov	eax, DWORD PTR _iValueImOffering$[esp+12]
	push	ecx
	push	edx
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[esp+12]
	mov	DWORD PTR [ecx], eax
$LN58@DoRemoveGo:
	pop	ebp
$LN2@DoRemoveGo:
	pop	esi
	pop	ebx

; 3152 : 				}
; 3153 : 			}
; 3154 : 		}
; 3155 : 	}
; 3156 : }

	pop	ecx
	ret	24					; 00000018H
?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ENDP ; CvDealAI::DoRemoveGoldFromThem
_TEXT	ENDS
PUBLIC	?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromUs
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z
_TEXT	SEGMENT
_eMyPlayer$223466 = -4					; size = 4
_iNumGoldInThisDeal$223467 = 8				; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
$T234196 = 16						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_bUseEvenValue$ = 28					; size = 1
?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z PROC ; CvDealAI::DoRemoveGoldFromUs, COMDAT
; _this$ = ecx

; 3160 : {

	push	ecx
	push	ebp

; 3161 : 	CvAssert(eThem >= 0);
; 3162 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3163 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove Gold from Us, but them is us.  Please show Jon");
; 3164 : 
; 3165 : //	if (!bDontChangeMyExistingItems)
; 3166 : 	{
; 3167 : 		if(iTotalValue < 0)

	mov	ebp, DWORD PTR _iTotalValue$[esp+4]
	cmp	DWORD PTR [ebp], 0
	push	edi
	mov	edi, ecx
	jge	$LN2@DoRemoveGo@2

; 3168 : 		{
; 3169 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	ebx

; 3170 : 
; 3171 : 			int iNumGoldInThisDeal = pDeal->GetGoldTrade(eMyPlayer);

	mov	ebx, DWORD PTR _pDeal$[esp+12]
	push	esi
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _eMyPlayer$223466[esp+24], eax
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	esi, eax
	mov	DWORD PTR _iNumGoldInThisDeal$223467[esp+16], esi

; 3172 : 			if(iNumGoldInThisDeal > 0)

	test	esi, esi
	jle	$LN18@DoRemoveGo@2

; 3173 : 			{
; 3174 : 				// Found some Gold to remove
; 3175 : 				int iNumGoldToRemove = min(iNumGoldInThisDeal, GetGoldForForValueExchange(-iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ true));

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	edx, DWORD PTR _eThem$[esp+16]
	mov	eax, DWORD PTR [ebp]
	push	1
	push	ecx
	push	edx
	push	1
	push	1
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	mov	DWORD PTR $T234196[esp+16], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T234196[esp+16]
	jl	SHORT $LN17@DoRemoveGo@2
	lea	eax, DWORD PTR _iNumGoldInThisDeal$223467[esp+16]
$LN17@DoRemoveGo@2:

; 3176 : 				iNumGoldInThisDeal -= iNumGoldToRemove;

	sub	esi, DWORD PTR [eax]

; 3177 : 
; 3178 : 				// Removing ALL Gold, so just erase the item from the deal
; 3179 : 				if(iNumGoldInThisDeal == 0)

	jne	SHORT $LN3@DoRemoveGo@2

; 3180 : 				{
; 3181 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD);

	push	-1
	push	esi
	mov	ecx, ebx
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3182 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	eax, DWORD PTR _iValueImOffering$[esp+16]
	push	ecx
	push	edx
	push	eax

; 3188 : 					{
; 3189 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove Gold from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3190 : 					}
; 3191 : 
; 3192 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	push	ebx
	mov	ecx, edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	pop	esi
	pop	ebx
	pop	edi
	mov	DWORD PTR [ebp], eax
	pop	ebp

; 3193 : 				}
; 3194 : 			}
; 3195 : 		}
; 3196 : 	}
; 3197 : }

	pop	ecx
	ret	24					; 00000018H
$LN3@DoRemoveGo@2:

; 3183 : 				}
; 3184 : 				// Remove some of the Gold from the deal
; 3185 : 				else
; 3186 : 				{
; 3187 : 					if(!pDeal->ChangeGoldTrade(eMyPlayer, iNumGoldInThisDeal))

	mov	ecx, DWORD PTR _eMyPlayer$223466[esp+20]
	push	esi
	push	ecx
	mov	ecx, ebx
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade

; 3188 : 					{
; 3189 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove Gold from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3190 : 					}
; 3191 : 
; 3192 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	edx, DWORD PTR _bUseEvenValue$[esp+16]
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+16]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+16]
	push	edx
	push	eax
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	DWORD PTR [ebp], eax
$LN18@DoRemoveGo@2:
	pop	esi
	pop	ebx
$LN2@DoRemoveGo@2:
	pop	edi
	pop	ebp

; 3193 : 				}
; 3194 : 			}
; 3195 : 		}
; 3196 : 	}
; 3197 : }

	pop	ecx
	ret	24					; 00000018H
?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ENDP ; CvDealAI::DoRemoveGoldFromUs
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsPeaceTreatyTrade
EXTRN	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ:PROC ; CvDeal::GetSurrenderingPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
_eOtherPlayer$ = 12					; size = 4
_iTotalValueToMe$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_iAmountOverWeWillRequest$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bCantMatchOffer$ = 36					; size = 4
?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z PROC ; CvDealAI::IsDealWithHumanAcceptable, COMDAT
; _this$ = ecx

; 514  : 	CvAssertMsg(GET_PLAYER(eOtherPlayer).isHuman(), "DEAL_AI: Trying to see if AI will accept a deal with human player... but it's not human.  Please show Jon.");
; 515  : 
; 516  : 	int iPercentOverWeWillRequest;
; 517  : 	int iPercentUnderWeWillOffer;
; 518  : 
; 519  : 	bCantMatchOffer = false;

	mov	eax, DWORD PTR _bCantMatchOffer$[esp-4]
	push	ebx

; 520  : 
; 521  : 	// Deal leeway with human
; 522  : 	iPercentOverWeWillRequest = GetDealPercentLeewayWithHuman();
; 523  : 	iPercentUnderWeWillOffer = 0;
; 524  : 
; 525  : 	// Now do the valuation
; 526  : 	iTotalValueToMe = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	mov	ebx, DWORD PTR _iValueTheyreOffering$[esp]
	push	ebp
	mov	ebp, DWORD PTR _iValueImOffering$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pDeal$[esp+12]
	push	0
	push	ebx
	push	ebp
	push	edi
	mov	esi, ecx
	mov	BYTE PTR [eax], 0
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValueToMe$[esp+12]

; 527  : 
; 528  : 	// If no Gold in deal and within value of 1 GPT, then it's close enough
; 529  : 	if (pDeal->GetGoldTrade(eOtherPlayer) == 0 && pDeal->GetGoldTrade(m_pPlayer->GetID()) == 0)

	mov	edx, DWORD PTR _eOtherPlayer$[esp+12]
	mov	DWORD PTR [ecx], eax
	push	edx
	mov	ecx, edi
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	SHORT $LN11@IsDealWith
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	SHORT $LN11@IsDealWith

; 530  : 	{
; 531  : 		int iOneGPT = 25;
; 532  : 		int iDiff = abs(iValueTheyreOffering - iValueImOffering);

	mov	eax, DWORD PTR [ebx]
	sub	eax, DWORD PTR [ebp]
	cdq
	xor	eax, edx
	sub	eax, edx

; 533  : 		if (iDiff < iOneGPT)

	cmp	eax, 25					; 00000019H

; 534  : 		{
; 535  : 			return true;

	jl	SHORT $LN37@IsDealWith
$LN11@IsDealWith:

; 536  : 		}
; 537  : 	}
; 538  : 
; 539  : 	int iDealSumValue = iValueImOffering + iValueTheyreOffering;

	mov	eax, DWORD PTR [ebp]
	add	eax, DWORD PTR [ebx]

; 540  : 
; 541  : 	iAmountOverWeWillRequest = iDealSumValue;
; 542  : 	iAmountOverWeWillRequest *= iPercentOverWeWillRequest;
; 543  : 	iAmountOverWeWillRequest /= 100;

	mov	ebp, DWORD PTR _iAmountOverWeWillRequest$[esp+12]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 544  : 
; 545  : 	iAmountUnderWeWillOffer = iDealSumValue;
; 546  : 	iAmountUnderWeWillOffer *= iPercentUnderWeWillOffer;
; 547  : 	iAmountUnderWeWillOffer /= 100;

	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[esp+12]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [edx], 0

; 548  : 
; 549  : 	// We're surrendering
; 550  : 	if(pDeal->GetSurrenderingPlayer() == GetPlayer()->GetID())

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+44]
	mov	ecx, edi
	call	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
	cmp	eax, ebx
	jne	SHORT $LN10@IsDealWith

; 551  : 	{
; 552  : 		if (iTotalValueToMe >= GetCachedValueOfPeaceWithHuman())

	mov	ecx, DWORD PTR _iTotalValueToMe$[esp+12]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN1@IsDealWith
$LN37@IsDealWith:
	pop	edi
	pop	esi
	pop	ebp

; 553  : 		{
; 554  : 			return true;

	mov	al, 1
	pop	ebx

; 585  : }

	ret	32					; 00000020H
$LN10@IsDealWith:

; 555  : 		}
; 556  : 	}
; 557  : 
; 558  : 	// Peace deal where we're not surrendering, value must equal cached value
; 559  : 	else if (pDeal->IsPeaceTreatyTrade(eOtherPlayer))

	mov	ebx, DWORD PTR _eOtherPlayer$[esp+12]
	push	ebx
	mov	ecx, edi
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	test	al, al
	je	SHORT $LN7@IsDealWith

; 560  : 	{
; 561  : #ifdef NQM_AI_GIMP_ALWAYS_WHITE_PEACE
; 562  : 		int iPeaceValueRequired = GetCachedValueOfPeaceWithHuman();
; 563  : 		if (GC.getGame().isOption("GAMEOPTION_AI_GIMP_ALWAYS_WHITE_PEACE") && iPeaceValueRequired > 0 && GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [esi+4]
	push	OFFSET $SG222190
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN6@IsDealWith
	test	esi, esi
	jle	SHORT $LN6@IsDealWith
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebx
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN6@IsDealWith

; 564  : 			iPeaceValueRequired = 0;

	xor	esi, esi
$LN6@IsDealWith:

; 565  : 		if (iTotalValueToMe >= iPeaceValueRequired)

	mov	eax, DWORD PTR _iTotalValueToMe$[esp+12]
	cmp	DWORD PTR [eax], esi
	jl	SHORT $LN1@IsDealWith
	pop	edi
	pop	esi
	pop	ebp

; 566  : #else
; 567  : 		if (iTotalValueToMe >= GetCachedValueOfPeaceWithHuman())
; 568  : #endif
; 569  : 		{
; 570  : 			return true;

	mov	al, 1
	pop	ebx

; 585  : }

	ret	32					; 00000020H
$LN7@IsDealWith:

; 571  : 		}
; 572  : 	}
; 573  : 
; 574  : 	// If we've gotten the deal to a point where we're happy, offer it up
; 575  : 	else if(iTotalValueToMe <= iAmountOverWeWillRequest && iTotalValueToMe >= iAmountUnderWeWillOffer)

	mov	ecx, DWORD PTR _iTotalValueToMe$[esp+12]
	mov	eax, DWORD PTR [ecx]
	mov	ebp, DWORD PTR [ebp]
	cmp	eax, ebp
	jg	SHORT $LN36@IsDealWith
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[esp+12]
	cmp	eax, DWORD PTR [edx]

; 576  : 	{
; 577  : 		return true;

	jge	SHORT $LN37@IsDealWith

; 578  : 	}
; 579  : 	else if (iTotalValueToMe > iAmountOverWeWillRequest)

	cmp	eax, ebp
	jle	SHORT $LN1@IsDealWith
$LN36@IsDealWith:

; 580  : 	{
; 581  : 		bCantMatchOffer = true;

	mov	eax, DWORD PTR _bCantMatchOffer$[esp+12]
	mov	BYTE PTR [eax], 1
$LN1@IsDealWith:
	pop	edi
	pop	esi
	pop	ebp

; 582  : 	}
; 583  : 
; 584  : 	return false;

	xor	al, al
	pop	ebx

; 585  : }

	ret	32					; 00000020H
?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ENDP ; CvDealAI::IsDealWithHumanAcceptable
_TEXT	ENDS
PUBLIC	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
EXTRN	?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z:PROC ; CvGameDeals::SetTempDeal
EXTRN	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ:PROC	; CvGameDeals::GetTempDeal
EXTRN	?GetDealDuration@CvGame@@QAEHXZ:PROC		; CvGame::GetDealDuration
; Function compile flags: /Ogtpy
;	COMDAT ?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_bMakeOffer$ = -21					; size = 1
_iEvenValueTheyreOffering$ = -20			; size = 4
_iEvenValueImOffering$ = -16				; size = 4
_iTotalValue$ = -12					; size = 4
_iDealDuration$ = -8					; size = 4
_iAmountUnderWeWillOffer$ = -4				; size = 4
_iValueTheyThinkTheyreOffering$222247 = 8		; size = 4
_iValueIThinkImOffering$222243 = 8			; size = 4
_pDeal$ = 8						; size = 4
_iValueTheyThinkTheyreGetting$222248 = 12		; size = 4
_iValueIThinkImGetting$222244 = 12			; size = 4
_eOtherPlayer$ = 12					; size = 4
?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z PROC ; CvDealAI::DoEqualizeDealWithAI, COMDAT
; _this$ = ecx

; 686  : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 687  : #ifdef CVASSERT_ENABLE
; 688  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 689  : 	DEBUG_VARIABLE(eMyPlayer);
; 690  : 
; 691  : 	CvAssert(eOtherPlayer >= 0);
; 692  : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 693  : 	CvAssertMsg(eMyPlayer != eOtherPlayer, "DEAL_AI: Trying to equalize AI deal, but both players are the same.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 694  : #endif
; 695  : 
; 696  : 	int iEvenValueImOffering;
; 697  : 	int iEvenValueTheyreOffering;
; 698  : 	int iTotalValue = GetDealValue(pDeal, iEvenValueImOffering, iEvenValueTheyreOffering, /*bUseEvenValue*/ true);

	mov	ebp, DWORD PTR _pDeal$[esp+28]
	push	esi
	push	edi
	push	1
	mov	esi, ecx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[esp+48]
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 699  : 
; 700  : 	int iDealDuration = GC.getGame().GetDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	mov	DWORD PTR _iTotalValue$[esp+40], edi
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration

; 701  : 
; 702  : 	bool bMakeOffer = false;
; 703  : 
; 704  : 	/////////////////////////////
; 705  : 	// Outline the boundaries for an acceptable deal
; 706  : 	/////////////////////////////
; 707  : 
; 708  : 	int iPercentOverWeWillRequest = GetDealPercentLeewayWithAI();
; 709  : 	int iPercentUnderWeWillOffer = -GetDealPercentLeewayWithAI();
; 710  : 
; 711  : 	int iDealSumValue = iEvenValueImOffering + iEvenValueTheyreOffering;

	mov	edx, DWORD PTR _iEvenValueTheyreOffering$[esp+40]
	mov	DWORD PTR _iDealDuration$[esp+40], eax
	mov	eax, DWORD PTR _iEvenValueImOffering$[esp+40]
	lea	ecx, DWORD PTR [eax+edx]

; 712  : 
; 713  : 	int iAmountOverWeWillRequest = iDealSumValue;
; 714  : 	iAmountOverWeWillRequest *= iPercentOverWeWillRequest;

	mov	edx, ecx

; 715  : 	iAmountOverWeWillRequest /= 100;
; 716  : 
; 717  : 	int iAmountUnderWeWillOffer = iDealSumValue;
; 718  : 	iAmountUnderWeWillOffer *= iPercentUnderWeWillOffer;

	imul	ecx, -25				; ffffffe7H
	imul	edx, 25					; 00000019H
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 719  : 	iAmountUnderWeWillOffer /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 720  : 
; 721  : 	// Deal is already even enough for us
; 722  : 	if(iTotalValue <= iAmountOverWeWillRequest && iTotalValue >= iAmountUnderWeWillOffer)

	cmp	edi, ebx
	mov	BYTE PTR _bMakeOffer$[esp+40], 0
	mov	DWORD PTR _iAmountUnderWeWillOffer$[esp+40], eax
	jg	SHORT $LN6@DoEqualize
	cmp	edi, eax
	jl	SHORT $LN6@DoEqualize

; 723  : 	{
; 724  : 		bMakeOffer = true;

	mov	BYTE PTR _bMakeOffer$[esp+40], 1
$LN6@DoEqualize:

; 725  : 	}
; 726  : 
; 727  : 	// If we set this pointer again it clears the data out!
; 728  : 	if(pDeal != GC.getGame().GetGameDeals()->GetTempDeal())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ; CvGameDeals::GetTempDeal
	cmp	ebp, eax
	je	SHORT $LN5@DoEqualize

; 729  : 	{
; 730  : 		GC.getGame().GetGameDeals()->SetTempDeal(pDeal);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z ; CvGameDeals::SetTempDeal
$LN5@DoEqualize:

; 731  : 	}
; 732  : 
; 733  : 	CvDeal* pCounterDeal = GC.getGame().GetGameDeals()->GetTempDeal();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ; CvGameDeals::GetTempDeal

; 734  : 
; 735  : 	if(!bMakeOffer)

	cmp	BYTE PTR _bMakeOffer$[esp+40], 0
	mov	edi, eax
	jne	$LN377@DoEqualize

; 736  : 	{
; 737  : 		/////////////////////////////
; 738  : 		// See if there are items we can add or remove from either side to balance out the deal if it's not already even
; 739  : 		/////////////////////////////
; 740  : 
; 741  : 		bool bUseEvenValue = true;
; 742  : 
; 743  : 		DoAddVoteCommitmentToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountOverWeWillRequest, bUseEvenValue);

	mov	ebp, DWORD PTR _eOtherPlayer$[esp+36]
	push	1
	push	ebx
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+52]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+56]
	push	eax
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToThem

; 744  : 		DoAddVoteCommitmentToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	mov	ecx, DWORD PTR _iAmountUnderWeWillOffer$[esp+40]
	push	1
	push	ecx
	lea	edx, DWORD PTR _iEvenValueTheyreOffering$[esp+48]
	push	edx
	lea	eax, DWORD PTR _iEvenValueImOffering$[esp+52]
	push	eax
	lea	ecx, DWORD PTR _iTotalValue$[esp+56]
	push	ecx
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToUs

; 745  : 
; 746  : 		DoAddResourceToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	mov	edx, DWORD PTR _iDealDuration$[esp+40]
	push	1
	push	edx
	push	ebx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[esp+52]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[esp+56]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[esp+60]
	push	edx
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToThem

; 747  : 		DoAddResourceToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	mov	ebx, DWORD PTR _iDealDuration$[esp+40]
	mov	eax, DWORD PTR _iAmountUnderWeWillOffer$[esp+40]
	push	1
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+52]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+56]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+60]
	push	eax
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToUs

; 748  : 
; 749  : 		DoAddOpenBordersToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ true, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);
; 750  : 		DoAddOpenBordersToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ true, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);
; 751  : 
; 752  : 		DoAddGPTToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	push	1
	push	ebx
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+52]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+56]
	push	eax
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToThem

; 753  : 		DoAddGPTToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	push	1
	push	ebx
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+52]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+56]
	push	eax
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToUs

; 754  : 
; 755  : 		DoAddGoldToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	push	1
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+44]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+48]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+52]
	push	eax
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToThem

; 756  : 		DoAddGoldToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	push	1
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+44]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+48]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+52]
	push	eax
	push	0
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToUs

; 757  : 
; 758  : 		DoRemoveGPTFromThem(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	push	1
	push	ebx
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+52]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+56]
	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromThem

; 759  : 		DoRemoveGPTFromUs(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	push	1
	push	ebx
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+52]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+56]
	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromUs

; 760  : 
; 761  : 		DoRemoveGoldFromUs(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	push	1
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+44]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+48]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+52]
	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromUs

; 762  : 		DoRemoveGoldFromThem(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	push	1
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[esp+44]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[esp+48]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[esp+52]
	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromThem

; 763  : 
; 764  : 		// Make sure we haven't removed everything from the deal!
; 765  : 		if(pCounterDeal->m_TradedItems.size() > 0)

	cmp	DWORD PTR [edi+64], 0
	jbe	$LN377@DoEqualize

; 766  : 		{
; 767  : 			int iValueIThinkImOffering, iValueIThinkImGetting;
; 768  : 			GetDealValue(pDeal, iValueIThinkImOffering, iValueIThinkImGetting, /*bUseEvenValue*/ false);

	mov	edi, DWORD PTR _pDeal$[esp+36]
	push	0
	lea	ecx, DWORD PTR _iValueIThinkImGetting$222244[esp+40]
	push	ecx
	lea	edx, DWORD PTR _iValueIThinkImOffering$222243[esp+44]
	push	edx
	push	edi
	mov	ecx, esi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 769  : 
; 770  : 			// We don't think we're getting enough for what's on our side of the table
; 771  : 			int iLowEndOfWhatIWillAccept = iValueIThinkImOffering - (iValueIThinkImOffering * -iPercentUnderWeWillOffer / 100);

	mov	ecx, DWORD PTR _iValueIThinkImOffering$222243[esp+36]
	mov	edx, ecx
	imul	edx, 25					; 00000019H
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	ecx, eax

; 772  : 			if(iValueIThinkImGetting < iLowEndOfWhatIWillAccept)

	cmp	DWORD PTR _iValueIThinkImGetting$222244[esp+36], ecx
	jge	SHORT $LN2@DoEqualize
$LN378@DoEqualize:
	pop	edi
	pop	esi
	pop	ebp

; 773  : 			{
; 774  : 				return false;

	xor	al, al
	pop	ebx

; 792  : }

	add	esp, 24					; 00000018H
	ret	8
$LN2@DoEqualize:

; 775  : 			}
; 776  : 
; 777  : 			int iValueTheyThinkTheyreOffering, iValueTheyThinkTheyreGetting;
; 778  : 			GET_PLAYER(eOtherPlayer).GetDealAI()->GetDealValue(pDeal, iValueTheyThinkTheyreOffering, iValueTheyThinkTheyreGetting, /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebp, 63236				; 0000f704H
	push	0
	lea	edx, DWORD PTR _iValueTheyThinkTheyreGetting$222248[esp+40]
	push	edx
	lea	eax, DWORD PTR _iValueTheyThinkTheyreOffering$222247[esp+44]
	push	eax
	add	ecx, ebp
	push	edi
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 779  : 
; 780  : 			// They don't think they're getting enough for what's on their side of the table
; 781  : 			int iLowEndOfWhatTheyWillAccept = iValueTheyThinkTheyreOffering - (iValueTheyThinkTheyreOffering * GET_PLAYER(eOtherPlayer).GetDealAI()->GetDealPercentLeewayWithAI() / 100);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, DWORD PTR _iValueTheyThinkTheyreOffering$222247[esp+36]
	mov	edx, ecx
	imul	edx, 25					; 00000019H
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	ecx, eax

; 782  : 			if(iValueTheyThinkTheyreGetting < iLowEndOfWhatTheyWillAccept)

	cmp	DWORD PTR _iValueTheyThinkTheyreGetting$222248[esp+36], ecx

; 783  : 			{
; 784  : 				return false;

	jl	SHORT $LN378@DoEqualize

; 785  : 			}
; 786  : 
; 787  : 			bMakeOffer = true;

	mov	BYTE PTR _bMakeOffer$[esp+40], 1
$LN377@DoEqualize:

; 788  : 		}
; 789  : 	}
; 790  : 
; 791  : 	return bMakeOffer;

	mov	al, BYTE PTR _bMakeOffer$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 792  : }

	add	esp, 24					; 00000018H
	ret	8
?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ENDP ; CvDealAI::DoEqualizeDealWithAI
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z
_TEXT	SEGMENT
__Mid$223995 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$223995[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$223995[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$223995[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$223995[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Sort_heap<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z ; CvDealAI::DoHumanOfferDealToThisAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
xdata$x	SEGMENT
__unwindtable$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$2
__ehfuncinfo$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_bFromIsActivePlayer$ = -126				; size = 1
_bCantMatchOffer$ = -125				; size = 1
_iValueTheyreOffering$ = -124				; size = 4
_iValueImOffering$ = -120				; size = 4
_eResponse$ = -116					; size = 4
_iDealValueToMe$ = -112					; size = 4
_eAnimation$ = -108					; size = 4
_eUIState$ = -104					; size = 4
$T235702 = -100						; size = 4
$T235772 = -96						; size = 4
_iAmountUnderWeWillOffer$ = -96				; size = 4
_pDllDeal$221906 = -92					; size = 4
_iAmountOverWeWillRequest$ = -92			; size = 4
_kDeal$221857 = -88					; size = 76
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::DoHumanOfferDealToThisAI, COMDAT
; _this$ = ecx

; 99   : {

	push	-1
	push	__ehhandler$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	ebp
	push	esi

; 100  : 	DealOfferResponseTypes eResponse = NO_DEAL_RESPONSE_TYPE;

	or	eax, -1
	push	edi
	mov	edi, ecx

; 101  : 	DiploUIStateTypes eUIState = NO_DIPLO_UI_STATE;
; 102  : 
; 103  : 	const char* szText = "";
; 104  : 	LeaderheadAnimationTypes eAnimation = NO_LEADERHEAD_ANIM;
; 105  : 
; 106  : 	PlayerTypes eFromPlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _eResponse$[esp+144], eax
	mov	DWORD PTR _eUIState$[esp+144], eax
	mov	ebx, OFFSET $SG221843
	mov	DWORD PTR _eAnimation$[esp+144], eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 107  : 
; 108  : 	bool bFromIsActivePlayer = eFromPlayer == GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 109  : 
; 110  : 	int iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer;
; 111  : 	bool bCantMatchOffer;
; 112  : 	bool bDealAcceptable = IsDealWithHumanAcceptable(pDeal, eFromPlayer, /*Passed by reference*/ iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, bCantMatchOffer);

	mov	ebp, DWORD PTR _pDeal$[esp+140]
	cmp	esi, eax
	lea	eax, DWORD PTR _bCantMatchOffer$[esp+144]
	push	eax
	lea	ecx, DWORD PTR _iAmountUnderWeWillOffer$[esp+148]
	push	ecx
	lea	edx, DWORD PTR _iAmountOverWeWillRequest$[esp+152]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$[esp+156]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$[esp+160]
	push	ecx
	lea	edx, DWORD PTR _iDealValueToMe$[esp+164]
	push	edx
	push	esi
	push	ebp
	mov	ecx, edi
	sete	BYTE PTR _bFromIsActivePlayer$[esp+176]
	call	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable

; 113  : 
; 114  : 	// If they're actually giving us more than we're asking for (e.g. a gift) then accept the deal
; 115  : 	if(!bDealAcceptable)

	test	al, al
	jne	SHORT $LN80@DoHumanOff

; 116  : 	{
; 117  : 		if(!pDeal->IsPeaceTreatyTrade(eFromPlayer) && iValueTheyreOffering > iValueImOffering)

	push	esi
	mov	ecx, ebp
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	test	al, al
	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+144]
	jne	$LN13@DoHumanOff
	cmp	eax, DWORD PTR _iValueImOffering$[esp+144]
	jle	$LN13@DoHumanOff
$LN80@DoHumanOff:

; 118  : 		{
; 119  : 			bDealAcceptable = true;
; 120  : 		}
; 121  : 	}
; 122  : 
; 123  : 	if(bDealAcceptable)
; 124  : 	{
; 125  : 		CvDeal kDeal = *pDeal;

	push	ebp
	lea	ecx, DWORD PTR _kDeal$221857[esp+148]
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal

; 126  : 
; 127  : 		// If it's from a human, send it through the network
; 128  : 		if(GET_PLAYER(eFromPlayer).isHuman())

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+152], 0
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN12@DoHumanOff

; 129  : 		{
; 130  : 			GC.GetEngineUserInterface()->SetDealInTransit(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+564]
	push	1
	call	edx

; 131  : 			auto_ptr<ICvDeal1> pDllDeal = GC.WrapDealPointer(&kDeal);

	lea	eax, DWORD PTR _kDeal$221857[esp+144]
	push	eax
	lea	ecx, DWORD PTR $T235702[esp+148]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z ; CvGlobals::WrapDealPointer
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllDeal$221906[esp+144], ebp
	mov	eax, DWORD PTR $T235702[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 1
	test	eax, eax
	je	SHORT $LN37@DoHumanOff
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN37@DoHumanOff:

; 132  : 			gDLL->sendNetDealAccepted(eFromPlayer, GetPlayer()->GetID(), pDllDeal.get(), iDealValueToMe, iValueImOffering, iValueTheyreOffering);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+360]
	mov	DWORD PTR $T235772[esp+144], edx
	mov	edx, DWORD PTR _iValueTheyreOffering$[esp+144]
	push	edx
	mov	edx, DWORD PTR _iValueImOffering$[esp+148]
	push	edx
	mov	edx, DWORD PTR _iDealValueToMe$[esp+152]
	push	edx
	mov	edx, DWORD PTR $T235772[esp+156]
	push	ebp
	push	edx
	push	esi
	call	eax

; 133  : 		}

	mov	BYTE PTR __$EHRec$[esp+152], 0
	test	ebp, ebp
	je	SHORT $LN81@DoHumanOff
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	ebp
	call	edx

; 134  : 		// Deal between AI players, we can process it immediately
; 135  : 		else

	jmp	SHORT $LN81@DoHumanOff
$LN12@DoHumanOff:

; 136  : 		{
; 137  : 			DoAcceptedDeal(eFromPlayer, kDeal, iDealValueToMe, iValueImOffering, iValueTheyreOffering);

	mov	eax, DWORD PTR _iValueTheyreOffering$[esp+144]
	mov	ecx, DWORD PTR _iValueImOffering$[esp+144]
	mov	edx, DWORD PTR _iDealValueToMe$[esp+144]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _kDeal$221857[esp+156]
	push	eax
	push	esi
	mov	ecx, edi
	call	?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z ; CvDealAI::DoAcceptedDeal
$LN81@DoHumanOff:

; 138  : 		}
; 139  : 	}

	lea	ecx, DWORD PTR _kDeal$221857[esp+144]
	mov	DWORD PTR __$EHRec$[esp+152], -1
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal

; 140  : 	// We want more from this Deal
; 141  : 	else if(iDealValueToMe > -75 &&

	jmp	SHORT $LN6@DoHumanOff
$LN13@DoHumanOff:

; 142  : 	        iValueImOffering < (iValueTheyreOffering * 5))	// The total value of the deal might not be that bad, but if he's asking for WAY more than he's offering (e.g. something for nothing) then it's not unacceptable, but insulting

	cmp	DWORD PTR _iDealValueToMe$[esp+144], -75 ; ffffffb5H
	jle	SHORT $LN9@DoHumanOff
	lea	ecx, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR _iValueImOffering$[esp+144], ecx
	jge	SHORT $LN9@DoHumanOff

; 143  : 	{
; 144  : 		eResponse = DEAL_RESPONSE_UNACCEPTABLE;
; 145  : 		eUIState = DIPLO_UI_STATE_TRADE_AI_REJECTS_OFFER;
; 146  : 
; 147  : 		if(bFromIsActivePlayer)

	cmp	BYTE PTR _bFromIsActivePlayer$[esp+144], 0
	mov	eax, 2
	mov	DWORD PTR _eResponse$[esp+144], eax
	mov	DWORD PTR _eUIState$[esp+144], 6
	je	$LN4@DoHumanOff

; 148  : 		{
; 149  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_REJECT_UNACCEPTABLE);

	push	-1
	push	138					; 0000008aH

; 150  : 			eAnimation = LEADERHEAD_ANIM_NO;
; 151  : 		}
; 152  : 	}
; 153  : 	// Pretty bad deal for us
; 154  : 	else

	jmp	SHORT $LN85@DoHumanOff
$LN9@DoHumanOff:

; 155  : 	{
; 156  : 		eResponse = DEAL_RESPONSE_INSULTING;
; 157  : 		eUIState = DIPLO_UI_STATE_TRADE_AI_REJECTS_OFFER;
; 158  : 
; 159  : 		if(bFromIsActivePlayer)

	cmp	BYTE PTR _bFromIsActivePlayer$[esp+144], 0
	mov	eax, 3
	mov	DWORD PTR _eResponse$[esp+144], eax
	mov	DWORD PTR _eUIState$[esp+144], 6
	je	$LN4@DoHumanOff

; 160  : 		{
; 161  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_REJECT_INSULTING);

	push	-1
	push	139					; 0000008bH
$LN85@DoHumanOff:
	mov	ecx, DWORD PTR [edi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage

; 162  : 			eAnimation = LEADERHEAD_ANIM_NO;

	mov	DWORD PTR _eAnimation$[esp+144], 17	; 00000011H
	mov	ebx, eax
$LN6@DoHumanOff:

; 163  : 		}
; 164  : 	}
; 165  : 
; 166  : 	if(bFromIsActivePlayer)

	cmp	BYTE PTR _bFromIsActivePlayer$[esp+144], 0
	je	SHORT $LN77@DoHumanOff

; 167  : 	{
; 168  : 		// Modify response if the player's offered a deal lot
; 169  : 		if(eResponse >= DEAL_RESPONSE_UNACCEPTABLE)

	mov	esi, DWORD PTR _eResponse$[esp+144]
	cmp	esi, 2
	jl	SHORT $LN76@DoHumanOff

; 170  : 		{
; 171  : 			int iTimesDealOffered = GC.GetEngineUserInterface()->GetOfferTradeRepeatCount();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+488]
	call	eax

; 172  : 			if(iTimesDealOffered > 4)

	cmp	eax, 4
	jle	SHORT $LN3@DoHumanOff

; 173  : 			{
; 174  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_TRADE_TOO_MUCH);

	push	-1
	push	132					; 00000084H
	jmp	SHORT $LN86@DoHumanOff
$LN3@DoHumanOff:

; 175  : 			}
; 176  : 			else if(iTimesDealOffered > 1)

	cmp	eax, 1
	jle	SHORT $LN83@DoHumanOff

; 177  : 			{
; 178  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_TRADE);

	push	-1
	push	133					; 00000085H
$LN86@DoHumanOff:
	mov	ecx, DWORD PTR [edi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	ebx, eax
$LN83@DoHumanOff:

; 179  : 			}
; 180  : 
; 181  : 			GC.GetEngineUserInterface()->ChangeOfferTradeRepeatCount(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+496]
	push	1
	call	eax

; 182  : 			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), eUIState, szText, eAnimation);

	mov	eax, DWORD PTR _eAnimation$[esp+144]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+736]
	push	-1
	push	eax
	mov	eax, DWORD PTR _eUIState$[esp+152]
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	edx
$LN76@DoHumanOff:

; 183  : 		}
; 184  : 	}
; 185  : 
; 186  : 	return eResponse;

	mov	eax, esi

; 182  : 			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), eUIState, szText, eAnimation);

	jmp	SHORT $LN4@DoHumanOff
$LN77@DoHumanOff:

; 183  : 		}
; 184  : 	}
; 185  : 
; 186  : 	return eResponse;

	mov	eax, DWORD PTR _eResponse$[esp+144]
$LN4@DoHumanOff:

; 187  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 128				; 00000080H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _kDeal$221857[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$2:
	lea	ecx, DWORD PTR _pDllDeal$221906[ebp]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
__ehhandler$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::DoHumanOfferDealToThisAI
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::sort<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::sort<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::sort<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ	; CvWeightedVector<int,1,0>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ PROC	; CvWeightedVector<int,1,0>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ ENDP	; CvWeightedVector<int,1,0>::SortItems
_TEXT	ENDS
PUBLIC	?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddCitiesToUs
EXTRN	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddCityTrade
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0
__ehfuncinfo$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_eMyPlayer$ = -56					; size = 4
_this$ = -52						; size = 4
_pWinnerCapital$ = -48					; size = 4
$T235865 = -44						; size = 4
_iCityLoop$ = -40					; size = 4
_viCityProximities$ = -36				; size = 24
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_pLosingPlayer$ = 16					; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddCitiesToUs, COMDAT
; _this$ = ecx

; 2781 : {

	push	-1
	push	__ehhandler$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	esi, ecx

; 2782 : 	CvAssert(eThem >= 0);
; 2783 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2784 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Open Borders to Us, but them is us.  Please show Jon");
; 2785 : 
; 2786 : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	eax, DWORD PTR [esi]

; 2787 : 
; 2788 : 	// If we're not the one surrendering here, don't bother
; 2789 : 	if(pDeal->GetSurrenderingPlayer() != eMyPlayer)

	mov	ecx, DWORD PTR _pDeal$[esp+56]
	push	edi
	mov	edi, DWORD PTR [eax+44]
	mov	DWORD PTR _this$[esp+64], esi
	mov	DWORD PTR _eMyPlayer$[esp+64], edi
	call	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
	cmp	eax, edi
	jne	$LN97@DoAddCitie

; 2790 : 		return;
; 2791 : 
; 2792 : 	// Don't change things
; 2793 : 	if(bDontChangeMyExistingItems)

	cmp	BYTE PTR _bDontChangeMyExistingItems$[esp+60], 0
	jne	$LN97@DoAddCitie

; 2794 : 		return;
; 2795 : 
; 2796 : 	// We don't owe them anything
; 2797 : 	if(iTotalValue <= 0)

	mov	eax, DWORD PTR _iTotalValue$[esp+60]
	cmp	DWORD PTR [eax], 0
	jle	$LN97@DoAddCitie

; 2798 : 		return;
; 2799 : 
; 2800 : 	CvPlayer* pLosingPlayer = GetPlayer();

	mov	ecx, DWORD PTR [esi]

; 2801 : 	CvPlayer* pWinningPlayer = &GET_PLAYER(eThem);

	mov	esi, DWORD PTR _eThem$[esp+60]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pLosingPlayer$[esp+60], ecx

; 2802 : 
; 2803 : 	// If the player only has 1 City then we can't get any more from him
; 2804 : 	if(pLosingPlayer->getNumCities() == 1)

	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	je	$LN97@DoAddCitie
	push	ebx
	push	ebp

; 2805 : 		return;
; 2806 : 
; 2807 : 	//int iCityValue = 0;
; 2808 : 
; 2809 : 	int iCityDistanceFromWinnersCapital = 0;
; 2810 : 	int iWinnerCapitalX = -1, iWinnerCapitalY = -1;

	or	edi, -1

; 2811 : 
; 2812 : 	// If winner has no capital then we can't use proximity - it will stay at 0
; 2813 : 	CvCity* pWinnerCapital = pWinningPlayer->getCapitalCity();

	mov	ecx, esi
	xor	ebp, ebp
	or	ebx, edi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pWinnerCapital$[esp+72], eax

; 2814 : 	if(pWinnerCapital != NULL)

	test	eax, eax
	je	SHORT $LN33@DoAddCitie

; 2815 : 	{
; 2816 : 		iWinnerCapitalX = pWinningPlayer->getCapitalCity()->getX();

	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	edi, DWORD PTR [eax+96]

; 2817 : 		iWinnerCapitalY = pWinningPlayer->getCapitalCity()->getY();

	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ebx, DWORD PTR [eax+108]
$LN33@DoAddCitie:

; 2818 : 	}
; 2819 : 
; 2820 : 	// Create vector of the losing players' Cities so we can see which are the closest to the winner
; 2821 : 	CvWeightedVector<int> viCityProximities;

	xor	eax, eax
	lea	ecx, DWORD PTR _viCityProximities$[esp+84]
	mov	DWORD PTR _viCityProximities$[esp+76], eax
	mov	DWORD PTR _viCityProximities$[esp+80], 1
	mov	DWORD PTR _viCityProximities$[esp+72], ecx

; 2822 : 
; 2823 : 	// Loop through all of the loser's Cities
; 2824 : 	CvCity* pLoopCity;
; 2825 : 	int iCityLoop;
; 2826 : 	for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR _pLosingPlayer$[esp+68]
	push	eax
	lea	edx, DWORD PTR _iCityLoop$[esp+76]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+88], eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN8@DoAddCitie
$LL115@DoAddCitie:

; 2827 : 	{
; 2828 : 		// Get total city value of the loser
; 2829 : 		//iCityValue += GetCityValue(pLoopCity->getX(), pLoopCity->getY(), /*bFromMe*/ true, eThem, bUseEvenValue);
; 2830 : 		//iCityValue += GetCityValue(pLoopCity->getX(), pLoopCity->getY(), /*bFromMe*/ true, eThem, /*bUseEvenValue*/ true);
; 2831 : 
; 2832 : 		// If winner has no capital, Distance defaults to 0
; 2833 : 		if(pWinnerCapital != NULL)

	cmp	DWORD PTR _pWinnerCapital$[esp+72], 0
	je	SHORT $LN7@DoAddCitie

; 2834 : 		{
; 2835 : 			iCityDistanceFromWinnersCapital = plotDistance(iWinnerCapitalX, iWinnerCapitalY, pLoopCity->getX(), pLoopCity->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	eax
	push	ecx
	push	ebx
	push	edi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ebp, eax
$LN7@DoAddCitie:

; 2836 : 		}
; 2837 : 
; 2838 : 		// Don't include the capital in the list of Cities the winner can receive
; 2839 : 		if(!pLoopCity->isCapital())

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN9@DoAddCitie

; 2840 : 		{
; 2841 : 			viCityProximities.push_back(pLoopCity->GetID(), iCityDistanceFromWinnersCapital);

	mov	eax, DWORD PTR [esi+120]
	push	ebp
	lea	ecx, DWORD PTR $T235865[esp+76]
	push	ecx
	lea	ecx, DWORD PTR _viCityProximities$[esp+80]
	mov	DWORD PTR $T235865[esp+80], eax
	call	?push_back@?$CvWeightedVector@H$00$0A@@@QAEIABHH@Z ; CvWeightedVector<int,1,0>::push_back
$LN9@DoAddCitie:
	mov	ecx, DWORD PTR _pLosingPlayer$[esp+68]
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+76]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL115@DoAddCitie
$LN8@DoAddCitie:

; 2842 : 		}
; 2843 : 	}
; 2844 : 
; 2845 : 	// Sort the vector based on distance from winner's capital
; 2846 : 	viCityProximities.SortItems();

	mov	eax, DWORD PTR _viCityProximities$[esp+72]
	mov	ecx, DWORD PTR _viCityProximities$[esp+76]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>

; 2847 : 
; 2848 : 	// Loop through sorted Cities and add them to the deal if they're under the amount to give up - start from the back of the list, because that's where the CLOSEST cities are
; 2849 : 	int iSortedCityID;
; 2850 : 	//			for (int iSortedCityIndex = 0; iSortedCityIndex < viCityProximities.size(); iSortedCityIndex++)
; 2851 : 	for(int iSortedCityIndex = viCityProximities.size() - 1; iSortedCityIndex > -1 ; iSortedCityIndex--)

	mov	ebp, DWORD PTR _viCityProximities$[esp+88]
	dec	ebp
	add	esp, 12					; 0000000cH
	cmp	ebp, -1
	jle	$LN3@DoAddCitie
	mov	ebx, DWORD PTR _bUseEvenValue$[esp+68]
$LL5@DoAddCitie:

; 2852 : 	{
; 2853 : 		iSortedCityID = viCityProximities.GetElement(iSortedCityIndex);

	mov	eax, DWORD PTR _viCityProximities$[esp+72]
	mov	edi, DWORD PTR [eax+ebp*8]

; 2854 : 		pLoopCity = pLosingPlayer->getCity(iSortedCityID);

	mov	ecx, DWORD PTR _pLosingPlayer$[esp+68]
	push	edi
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 2855 : 
; 2856 : 		//iCityValue = GetCityValue(pLoopCity->getX(), pLoopCity->getY(), bMeSurrendering, eOtherPlayer, /*bUseEvenValue*/ true);
; 2857 : 
; 2858 : 		// See if we can actually trade it to them
; 2859 : 		if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))

	mov	edx, DWORD PTR _eMyPlayer$[esp+72]
	push	0
	push	1
	push	0
	push	-1
	mov	esi, eax
	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _eThem$[esp+92]
	push	4
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[esp+100]
	push	edx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN4@DoAddCitie

; 2860 : 			//if (pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_OPEN_BORDERS))
; 2861 : 		{
; 2862 : 			int iItemValue = GetCityValue(pLoopCity->getX(), pLoopCity->getY(), /*bFromMe*/ true, eThem, bUseEvenValue);

	mov	ecx, DWORD PTR _eThem$[esp+68]
	mov	eax, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+80]
	push	1
	push	eax
	push	esi
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue

; 2863 : 			//int iItemValue = GetTradeItemValue(TRADE_ITEM_CITIES, /*bFromMe*/ true, eThem, pLoopCity->getX(), pLoopCity->getY(), iDealDuration, bUseEvenValue);
; 2864 : 			//int iItemValue = GetTradeItemValue(TRADE_ITEM_OPEN_BORDERS, /*bFromMe*/ true, eThem, -1, -1, iDealDuration, bUseEvenValue);
; 2865 : 
; 2866 : 			// If adding this to the deal doesn't take it under the min limit, do it
; 2867 : 			if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	esi, DWORD PTR _iTotalValue$[esp+68]
	mov	edx, DWORD PTR [esi]
	sub	edx, eax
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[esp+68]
	jl	SHORT $LN4@DoAddCitie

; 2868 : 			{
; 2869 : 				//pDeal->AddOpenBorders(eMyPlayer, iDealDuration);
; 2870 : 				pDeal->AddCityTrade(eMyPlayer, iSortedCityID);

	mov	eax, DWORD PTR _eMyPlayer$[esp+72]
	push	edi
	mov	edi, DWORD PTR _pDeal$[esp+72]
	push	eax
	mov	ecx, edi
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade

; 2871 : 				iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	mov	ecx, DWORD PTR _iValueTheyreOffering$[esp+68]
	mov	edx, DWORD PTR _iValueImOffering$[esp+68]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+80]
	push	edx
	push	edi
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	DWORD PTR [esi], eax
$LN4@DoAddCitie:
	dec	ebp
	cmp	ebp, -1
	jg	$LL5@DoAddCitie
$LN3@DoAddCitie:

; 2872 : 			}
; 2873 : 		}
; 2874 : 
; 2875 : 		// City is worth less than what is left to be added to the deal, so add it
; 2876 : 		//if (iCityValue < iCityValueToSurrender)
; 2877 : 		//{
; 2878 : 		//	if (pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))
; 2879 : 		//	{
; 2880 : 		//		pDeal->AddCityTrade(eLosingPlayer, iSortedCityID);
; 2881 : 
; 2882 : 		//		// Remove GPT from this City so we don't give more than we can support
; 2883 : 		//		iGPTToGive -= pLoopCity->getYieldRate(YIELD_GOLD);
; 2884 : 
; 2885 : 		//		iCityValueToSurrender -= iCityValue;
; 2886 : 		//	}
; 2887 : 		//}
; 2888 : 	}
; 2889 : }

	mov	eax, DWORD PTR _viCityProximities$[esp+72]
	lea	ecx, DWORD PTR _viCityProximities$[esp+84]
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+76], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN97@DoAddCitie
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN97@DoAddCitie:
	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0:
	lea	ecx, DWORD PTR _viCityProximities$[ebp]
	jmp	??1?$CvWeightedVector@H$00$0A@@@QAE@XZ	; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
__ehhandler$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddCitiesToUs
PUBLIC	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty
EXTRN	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ:PROC ; CvCity::getOriginalOwner
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z$0
__ehfuncinfo$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
_TEXT	SEGMENT
_bGiveOpenBorders$ = -80				; size = 1
_bGiveUpStratResources$ = -79				; size = 1
_bGiveOnlyOneCity$ = -78				; size = 1
_bGiveUpLuxuryResources$ = -77				; size = 1
tv90 = -76						; size = 4
_pLosingPlayer$ = -72					; size = 4
_iCityDistanceFromWinnersCapital$223588 = -68		; size = 4
_iPercentGPTToGive$ = -68				; size = 4
_iPercentCitiesGiveUp$ = -64				; size = 4
_iSortedCityIndex$223606 = -60				; size = 4
_iWinnerCapitalY$223590 = -60				; size = 4
_iDuration$ = -60					; size = 4
_iCityLoop$ = -56					; size = 4
_this$ = -52						; size = 4
_iWinnerCapitalX$223589 = -48				; size = 4
$T236116 = -48						; size = 4
$T236117 = -44						; size = 4
_pWinnerCapital$223591 = -40				; size = 4
_pWinningPlayer$ = -40					; size = 4
_viCityProximities$223594 = -36				; size = 24
__$EHRec$ = -12						; size = 12
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
tv77 = 16						; size = 4
_eTreaty$ = 16						; size = 4
_bMeSurrendering$ = 20					; size = 1
?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z PROC ; CvDealAI::DoAddItemsToDealForPeaceTreaty, COMDAT
; _this$ = ecx

; 3339 : {

	push	-1
	push	__ehhandler$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 3340 : 	int iPercentGoldToGive = 0;
; 3341 : 	int iPercentGPTToGive = 0;
; 3342 : 	bool bGiveOpenBorders = false;
; 3343 : 	bool bGiveOnlyOneCity = false;
; 3344 : 	int iPercentCitiesGiveUp = 0; /* 100 = all but capital */
; 3345 : 	bool bGiveUpStratResources = false;
; 3346 : 	bool bGiveUpLuxuryResources = false;
; 3347 : 
; 3348 : 	// Setup what needs to be given up based on the level of the treaty
; 3349 : 	switch (eTreaty)

	mov	eax, DWORD PTR _eTreaty$[esp+76]
	push	ebx
	push	ebp
	push	esi
	xor	esi, esi
	push	edi
	dec	eax
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+96], edi
	mov	DWORD PTR _iPercentGPTToGive$[esp+96], esi
	mov	BYTE PTR _bGiveOpenBorders$[esp+96], 0
	mov	BYTE PTR _bGiveOnlyOneCity$[esp+96], 0
	mov	DWORD PTR _iPercentCitiesGiveUp$[esp+96], esi
	mov	BYTE PTR _bGiveUpStratResources$[esp+96], 0
	mov	BYTE PTR _bGiveUpLuxuryResources$[esp+96], 0
	cmp	eax, 7
	ja	SHORT $LN220@DoAddItems
	jmp	DWORD PTR $LN234@DoAddItems[eax*4]
$LN49@DoAddItems:

; 3350 : 	{
; 3351 : 	case PEACE_TREATY_WHITE_PEACE:
; 3352 : 		// White Peace: nothing changes hands
; 3353 : 		break;
; 3354 : 
; 3355 : 	case PEACE_TREATY_ARMISTICE:
; 3356 : 		iPercentGoldToGive = 50;

	mov	esi, 50					; 00000032H

; 3357 : 		iPercentGPTToGive = 50;

	mov	DWORD PTR _iPercentGPTToGive$[esp+96], esi

; 3358 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN48@DoAddItems:

; 3359 : 
; 3360 : 	case PEACE_TREATY_SETTLEMENT:
; 3361 : 		iPercentGoldToGive = 100;

	mov	esi, 100				; 00000064H

; 3362 : 		iPercentGPTToGive = 100;

	mov	DWORD PTR _iPercentGPTToGive$[esp+96], esi

; 3363 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN47@DoAddItems:

; 3364 : 
; 3365 : 	case PEACE_TREATY_BACKDOWN:
; 3366 : 		iPercentGoldToGive = 100;

	mov	esi, 100				; 00000064H

; 3367 : 		iPercentGPTToGive = 100;

	mov	DWORD PTR _iPercentGPTToGive$[esp+96], esi

; 3368 : 		bGiveOpenBorders = true;

	mov	BYTE PTR _bGiveOpenBorders$[esp+96], 1

; 3369 : 		bGiveUpStratResources = true;

	mov	BYTE PTR _bGiveUpStratResources$[esp+96], 1

; 3370 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN46@DoAddItems:

; 3371 : 
; 3372 : 	case PEACE_TREATY_SUBMISSION:
; 3373 : 		iPercentGoldToGive = 100;

	mov	esi, 100				; 00000064H

; 3374 : 		iPercentGPTToGive = 100;

	mov	DWORD PTR _iPercentGPTToGive$[esp+96], esi

; 3375 : 		bGiveOpenBorders = true;

	mov	BYTE PTR _bGiveOpenBorders$[esp+96], 1

; 3376 : 		bGiveUpStratResources = true;

	mov	BYTE PTR _bGiveUpStratResources$[esp+96], 1

; 3377 : 		bGiveUpLuxuryResources = true;

	mov	BYTE PTR _bGiveUpLuxuryResources$[esp+96], 1

; 3378 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN45@DoAddItems:

; 3379 : 
; 3380 : 	case PEACE_TREATY_SURRENDER:
; 3381 : 		bGiveOnlyOneCity = true;

	mov	BYTE PTR _bGiveOnlyOneCity$[esp+96], 1

; 3382 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN44@DoAddItems:

; 3383 : 
; 3384 : 	case PEACE_TREATY_CESSION:
; 3385 : 		iPercentCitiesGiveUp = 25;

	mov	DWORD PTR _iPercentCitiesGiveUp$[esp+96], 25 ; 00000019H

; 3386 : 		iPercentGoldToGive = 50;

	mov	esi, 50					; 00000032H

; 3387 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN43@DoAddItems:

; 3388 : 
; 3389 : 	case PEACE_TREATY_CAPITULATION:
; 3390 : 		iPercentCitiesGiveUp = 33;

	mov	DWORD PTR _iPercentCitiesGiveUp$[esp+96], 33 ; 00000021H

; 3391 : 		iPercentGoldToGive = 100;

	mov	esi, 100				; 00000064H

; 3392 : 		break;

	jmp	SHORT $LN220@DoAddItems
$LN42@DoAddItems:

; 3393 : 
; 3394 : 	case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
; 3395 : 		iPercentCitiesGiveUp = 100;

	mov	esi, 100				; 00000064H
	mov	DWORD PTR _iPercentCitiesGiveUp$[esp+96], esi
$LN220@DoAddItems:

; 3396 : 		iPercentGoldToGive = 100;
; 3397 : 		break;
; 3398 : 	}
; 3399 : 
; 3400 : 	int iDuration = GC.getGame().GetDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration

; 3401 : 
; 3402 : 	PlayerTypes eLosingPlayer = bMeSurrendering ? GetPlayer()->GetID() : eOtherPlayer;

	mov	bl, BYTE PTR _bMeSurrendering$[esp+92]
	mov	edx, DWORD PTR _eOtherPlayer$[esp+92]
	mov	DWORD PTR _iDuration$[esp+96], eax
	test	bl, bl
	je	SHORT $LN55@DoAddItems
	mov	eax, DWORD PTR [edi]
	mov	ebp, DWORD PTR [eax+44]
	mov	DWORD PTR tv77[esp+92], ebp
	jmp	SHORT $LN56@DoAddItems
$LN55@DoAddItems:
	mov	DWORD PTR tv77[esp+92], edx
	mov	ebp, edx
$LN56@DoAddItems:

; 3403 : 	CvPlayer* pLosingPlayer = &GET_PLAYER(eLosingPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, eax
	mov	DWORD PTR _pLosingPlayer$[esp+96], ecx

; 3404 : 	PlayerTypes eWinningPlayer = bMeSurrendering ? eOtherPlayer : GetPlayer()->GetID();

	test	bl, bl
	je	SHORT $LN57@DoAddItems
	mov	DWORD PTR tv90[esp+96], edx
	jmp	SHORT $LN72@DoAddItems
$LN57@DoAddItems:
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR tv90[esp+96], ecx
$LN72@DoAddItems:

; 3405 : 	CvPlayer* pWinningPlayer = &GET_PLAYER(eWinningPlayer);

	mov	edi, DWORD PTR tv90[esp+96]

; 3406 : 
; 3407 : 	DoAddPlayersAlliesToTreaty(eOtherPlayer, pDeal);

	mov	ebx, DWORD PTR _pDeal$[esp+92]
	imul	edi, 63236				; 0000f704H
	mov	ecx, DWORD PTR _this$[esp+96]
	push	ebx
	add	edi, eax
	push	edx
	mov	DWORD PTR _pWinningPlayer$[esp+104], edi
	call	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty

; 3408 : 
; 3409 : 	CvCity* pLoopCity;
; 3410 : 	int iCityLoop;
; 3411 : 
; 3412 : 	// Gold
; 3413 : 	int iGold = 0;
; 3414 : 	if (iPercentGoldToGive > 0)

	test	esi, esi
	jle	SHORT $LN224@DoAddItems

; 3415 : 	{
; 3416 : 		iGold = pDeal->GetGoldAvailable(eLosingPlayer, TRADE_ITEM_GOLD);

	push	0
	push	ebp
	mov	ecx, ebx
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable

; 3417 : 		if(iGold > 0)

	test	eax, eax
	jle	SHORT $LN224@DoAddItems

; 3418 : 		{
; 3419 : 			iGold = iGold * iPercentGoldToGive / 100;

	imul	eax, esi
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3420 : 
; 3421 : 			if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_GOLD, iGold))

	push	0
	push	1
	push	0
	sar	edx, 5
	push	-1
	mov	esi, edx
	push	-1
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	edx, DWORD PTR tv90[esp+116]
	push	esi
	push	0
	push	edx
	push	ebp
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN224@DoAddItems

; 3422 : 			{
; 3423 : 				pDeal->AddGoldTrade(eLosingPlayer, iGold);

	push	esi
	push	ebp
	mov	ecx, ebx
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
$LN224@DoAddItems:

; 3424 : 			}
; 3425 : 		}
; 3426 : 	}
; 3427 : 
; 3428 : 	// Gold per turn
; 3429 : 	int iGPT = 0;
; 3430 : 	if (iPercentGPTToGive > 0)

	cmp	DWORD PTR _iPercentGPTToGive$[esp+96], 0
	jle	SHORT $LN226@DoAddItems

; 3431 : 	{
; 3432 : 		iGPT = min(pLosingPlayer->calculateGoldRate(), pWinningPlayer->calculateGoldRate() / /*3*/ GC.getARMISTICE_GPT_DIVISOR());

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+5028
	mov	ecx, edi
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	cdq
	idiv	esi
	mov	ecx, DWORD PTR _pLosingPlayer$[esp+96]
	mov	esi, eax
	mov	DWORD PTR $T236116[esp+96], esi
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	mov	DWORD PTR $T236117[esp+96], eax
	cmp	esi, eax
	lea	eax, DWORD PTR $T236116[esp+96]
	jl	SHORT $LN83@DoAddItems
	lea	eax, DWORD PTR $T236117[esp+96]
$LN83@DoAddItems:
	mov	eax, DWORD PTR [eax]

; 3433 : 		if (iGPT > 0)

	test	eax, eax
	jle	SHORT $LN226@DoAddItems

; 3434 : 		{
; 3435 : 			iGPT = iGPT * iPercentGPTToGive / 100;

	imul	eax, DWORD PTR _iPercentGPTToGive$[esp+96]
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 3436 : 
; 3437 : 			if(iGPT > 0 && pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_GOLD_PER_TURN, iGPT, iDuration))

	test	esi, esi
	jle	SHORT $LN226@DoAddItems
	mov	edi, DWORD PTR _iDuration$[esp+96]
	mov	eax, DWORD PTR tv90[esp+96]
	push	0
	push	1
	push	0
	push	-1
	push	edi
	push	esi
	push	1
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN226@DoAddItems

; 3438 : 			{
; 3439 : 				pDeal->AddGoldPerTurnTrade(eLosingPlayer, iGPT, iDuration);

	push	edi
	push	esi
	push	ebp
	mov	ecx, ebx
	call	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
$LN226@DoAddItems:

; 3440 : 			}
; 3441 : 		}
; 3442 : 	}
; 3443 : 
; 3444 : 	// Open Borders
; 3445 : 	if (bGiveOpenBorders)

	cmp	BYTE PTR _bGiveOpenBorders$[esp+96], 0
	je	SHORT $LN230@DoAddItems

; 3446 : 	{
; 3447 : 		if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_OPEN_BORDERS))

	mov	ecx, DWORD PTR tv90[esp+96]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	push	ecx
	push	ebp
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN230@DoAddItems

; 3448 : 		{
; 3449 : 			pDeal->AddOpenBorders(eLosingPlayer, iDuration);

	mov	edx, DWORD PTR _iDuration$[esp+96]
	push	edx
	push	ebp
	mov	ecx, ebx
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders
$LN230@DoAddItems:

; 3450 : 		}
; 3451 : 	}
; 3452 : 
; 3453 : 	// Resources
; 3454 : 	ResourceUsageTypes eUsage;
; 3455 : 	ResourceTypes eResource;
; 3456 : 	int iResourceQuantity;
; 3457 : #ifdef AUI_WARNING_FIXES
; 3458 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 3459 : #else
; 3460 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN231@DoAddItems
	npad	2
$LL33@DoAddItems:

; 3461 : #endif
; 3462 : 	{
; 3463 : 		eResource = (ResourceTypes) iResourceLoop;
; 3464 : 
; 3465 : 		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 3466 : 		if (pkResourceInfo == NULL)

	test	eax, eax
	je	SHORT $LN32@DoAddItems

; 3467 : 			continue;
; 3468 : 
; 3469 : 		eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	ebp, eax

; 3470 : 
; 3471 : 		// Can't trade bonus Resources
; 3472 : 		if(eUsage == RESOURCEUSAGE_BONUS)

	test	ebp, ebp
	je	SHORT $LN222@DoAddItems

; 3473 : 		{
; 3474 : 			continue;
; 3475 : 		}
; 3476 : 
; 3477 : 		iResourceQuantity = pLosingPlayer->getNumResourceAvailable(eResource, false);

	mov	ecx, DWORD PTR _pLosingPlayer$[esp+96]
	push	0
	push	esi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	edi, eax

; 3478 : 
; 3479 : 		// Don't bother looking at this Resource if the other player doesn't even have any of it
; 3480 : 		if (iResourceQuantity == 0)

	test	edi, edi
	je	SHORT $LN222@DoAddItems

; 3481 : 		{
; 3482 : 			continue;
; 3483 : 		}
; 3484 : 
; 3485 : 		// Match with deal type
; 3486 : 		if (eUsage == RESOURCEUSAGE_LUXURY && !bGiveUpLuxuryResources)

	cmp	ebp, 2
	jne	$LN27@DoAddItems
	cmp	BYTE PTR _bGiveUpLuxuryResources$[esp+96], 0
	je	SHORT $LN222@DoAddItems

; 3498 : 		{
; 3499 : 			iResourceQuantity = 1;

	lea	edi, DWORD PTR [ebp-1]
$LN25@DoAddItems:

; 3500 : 		}
; 3501 : 
; 3502 : 		if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	mov	eax, DWORD PTR tv90[esp+96]
	mov	ecx, DWORD PTR tv77[esp+92]
	push	0
	push	1
	push	0
	push	-1
	push	edi
	push	esi
	push	3
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN222@DoAddItems

; 3503 : 		{
; 3504 : 			pDeal->AddResourceTrade(eLosingPlayer, eResource, iResourceQuantity, iDuration);

	mov	edx, DWORD PTR _iDuration$[esp+96]
	mov	eax, DWORD PTR tv77[esp+92]
	push	edx
	push	edi
	push	esi
	push	eax
	mov	ecx, ebx
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade
$LN222@DoAddItems:
	mov	ebp, DWORD PTR tv77[esp+92]
$LN32@DoAddItems:

; 3450 : 		}
; 3451 : 	}
; 3452 : 
; 3453 : 	// Resources
; 3454 : 	ResourceUsageTypes eUsage;
; 3455 : 	ResourceTypes eResource;
; 3456 : 	int iResourceQuantity;
; 3457 : #ifdef AUI_WARNING_FIXES
; 3458 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 3459 : #else
; 3460 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	$LL33@DoAddItems
$LN231@DoAddItems:

; 3505 : 		}
; 3506 : 	}
; 3507 : 
; 3508 : 	//	Give up all but capital?
; 3509 : 	if (iPercentCitiesGiveUp == 100)

	mov	eax, DWORD PTR _iPercentCitiesGiveUp$[esp+96]
	cmp	eax, 100				; 00000064H
	jne	$LN23@DoAddItems

; 3510 : 	{
; 3511 : 		// All Cities but the capital
; 3512 : 		for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	mov	edi, DWORD PTR _pLosingPlayer$[esp+96]
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[esp+100]
	push	ecx
	mov	ecx, edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN194@DoAddItems
$LL22@DoAddItems:

; 3513 : 		{
; 3514 : #ifndef AUI_DEAL_ALLOW_CAPITOL_GIFTING
; 3515 : 			if(pLoopCity->isCapital())

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN21@DoAddItems

; 3516 : 			{
; 3517 : 				continue;
; 3518 : 			}
; 3519 : #endif
; 3520 : 
; 3521 : 			if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR tv90[esp+96]
	push	0
	push	1
	push	0
	push	-1
	push	eax
	push	ecx
	push	4
	push	edx
	push	ebp
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN21@DoAddItems

; 3522 : 			{
; 3523 : 				pDeal->AddCityTrade(eLosingPlayer, pLoopCity->GetID());

	mov	eax, DWORD PTR [esi+120]
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade
$LN21@DoAddItems:
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[esp+100]
	push	ecx
	mov	ecx, edi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL22@DoAddItems
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3611 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN27@DoAddItems:

; 3487 : 		{
; 3488 : 			continue;
; 3489 : 		}
; 3490 : 
; 3491 : 		if (eUsage == RESOURCEUSAGE_STRATEGIC && !bGiveUpStratResources)

	cmp	ebp, 1
	jne	$LN25@DoAddItems
	cmp	BYTE PTR _bGiveUpStratResources$[esp+96], 0
	je	$LN222@DoAddItems

; 3492 : 		{
; 3493 : 			continue;
; 3494 : 		}
; 3495 : 
; 3496 : 		// Can only get 1 copy of a Luxury
; 3497 : 		if (eUsage == RESOURCEUSAGE_LUXURY)

	jmp	$LN25@DoAddItems
$LN23@DoAddItems:

; 3524 : 			}
; 3525 : 		}
; 3526 : 	}
; 3527 : 
; 3528 : 	// If the player only has 1 City then we can't get any more from him
; 3529 : #ifdef AUI_WARNING_FIXES
; 3530 : 	else if (iPercentCitiesGiveUp > 0 || (bGiveOnlyOneCity && pLosingPlayer->getNumCities() > 1))
; 3531 : #else
; 3532 : 	else if (iPercentCitiesGiveUp > 0 || bGiveOnlyOneCity && pLosingPlayer->getNumCities() > 1)

	test	eax, eax
	jg	SHORT $LN15@DoAddItems
	cmp	BYTE PTR _bGiveOnlyOneCity$[esp+96], 0
	je	$LN194@DoAddItems
	mov	ecx, DWORD PTR _pLosingPlayer$[esp+96]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	$LN194@DoAddItems
$LN15@DoAddItems:

; 3533 : #endif
; 3534 : 	{
; 3535 : 		int iCityValue = 0;
; 3536 : 		int iCityDistanceFromWinnersCapital = 0;
; 3537 : 		int iWinnerCapitalX = -1, iWinnerCapitalY = -1;
; 3538 : 
; 3539 : 		// If winner has no capital then we can't use proximity - it will stay at 0
; 3540 : 		CvCity* pWinnerCapital = pWinningPlayer->getCapitalCity();

	mov	ecx, DWORD PTR _pWinningPlayer$[esp+96]
	or	eax, -1
	xor	esi, esi
	xor	edi, edi
	mov	DWORD PTR _iCityDistanceFromWinnersCapital$223588[esp+96], esi
	mov	DWORD PTR _iWinnerCapitalX$223589[esp+96], eax
	mov	DWORD PTR _iWinnerCapitalY$223590[esp+96], eax
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pWinnerCapital$223591[esp+96], eax

; 3541 : 		if(pWinnerCapital != NULL)

	cmp	eax, esi
	je	SHORT $LN100@DoAddItems

; 3542 : 		{
; 3543 : 			iWinnerCapitalX = pWinnerCapital->getX();

	mov	edx, DWORD PTR [eax+96]

; 3544 : 			iWinnerCapitalY = pWinnerCapital->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR _iWinnerCapitalX$223589[esp+96], edx
	mov	DWORD PTR _iWinnerCapitalY$223590[esp+96], eax
$LN100@DoAddItems:

; 3545 : 		}
; 3546 : 
; 3547 : 		// Create vector of the losing players' Cities so we can see which are the closest to the winner
; 3548 : 		CvWeightedVector<int> viCityProximities;

	lea	ecx, DWORD PTR _viCityProximities$223594[esp+108]
	mov	DWORD PTR _viCityProximities$223594[esp+100], esi
	mov	DWORD PTR _viCityProximities$223594[esp+104], 1
	mov	DWORD PTR _viCityProximities$223594[esp+96], ecx

; 3549 : 
; 3550 : 		// Loop through all of the loser's Cities
; 3551 : 		for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR _pLosingPlayer$[esp+96]
	push	esi
	lea	edx, DWORD PTR _iCityLoop$[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN11@DoAddItems
$LL223@DoAddItems:

; 3552 : 		{
; 3553 : 			// Get total city value of the loser
; 3554 : 			iCityValue += GetCityValue(pLoopCity->getX(), pLoopCity->getY(), bMeSurrendering, eOtherPlayer, /*bUseEvenValue*/ true);

	mov	edx, DWORD PTR _eOtherPlayer$[esp+92]
	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	1
	push	edx
	mov	edx, DWORD PTR _bMeSurrendering$[esp+100]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+116]
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	add	edi, eax

; 3555 : 
; 3556 : 			// If winner has no capital, Distance defaults to 0
; 3557 : 			if(pWinnerCapital != NULL)

	cmp	DWORD PTR _pWinnerCapital$223591[esp+96], 0
	je	SHORT $LN10@DoAddItems

; 3558 : 			{
; 3559 : 				iCityDistanceFromWinnersCapital = plotDistance(iWinnerCapitalX, iWinnerCapitalY, pLoopCity->getX(), pLoopCity->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	eax
	mov	eax, DWORD PTR _iWinnerCapitalY$223590[esp+100]
	push	ecx
	mov	ecx, DWORD PTR _iWinnerCapitalX$223589[esp+104]
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iCityDistanceFromWinnersCapital$223588[esp+96], eax
$LN10@DoAddItems:

; 3560 : 			}
; 3561 : 
; 3562 : 			// Divide the distance by three if the city was originally owned by the winning player to make these cities more likely
; 3563 : 			if (pLoopCity->getOriginalOwner() == eWinningPlayer)

	mov	ecx, esi
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	cmp	eax, DWORD PTR tv90[esp+96]
	jne	SHORT $LN9@DoAddItems

; 3564 : 			{
; 3565 : 				iCityDistanceFromWinnersCapital /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR _iCityDistanceFromWinnersCapital$223588[esp+96]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iCityDistanceFromWinnersCapital$223588[esp+96], eax
$LN9@DoAddItems:

; 3566 : 			}
; 3567 : 
; 3568 : 			// Don't include the capital in the list of Cities the winner can receive
; 3569 : 			if(!pLoopCity->isCapital())

	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN12@DoAddItems

; 3570 : 			{
; 3571 : 				viCityProximities.push_back(pLoopCity->GetID(), iCityDistanceFromWinnersCapital);

	mov	esi, DWORD PTR [esi+120]
	mov	BYTE PTR _viCityProximities$223594[esp+116], al
	mov	eax, DWORD PTR _viCityProximities$223594[esp+104]
	cmp	DWORD PTR _viCityProximities$223594[esp+100], eax
	jne	SHORT $LN139@DoAddItems
	push	eax
	lea	ecx, DWORD PTR _viCityProximities$223594[esp+100]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
$LN139@DoAddItems:
	mov	ecx, DWORD PTR _viCityProximities$223594[esp+96]
	mov	edx, DWORD PTR _viCityProximities$223594[esp+100]
	lea	eax, DWORD PTR [ecx+edx*8]
	test	eax, eax
	je	SHORT $LN142@DoAddItems
	mov	ecx, DWORD PTR _iCityDistanceFromWinnersCapital$223588[esp+96]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx
$LN142@DoAddItems:
	inc	DWORD PTR _viCityProximities$223594[esp+100]
$LN12@DoAddItems:

; 3549 : 
; 3550 : 		// Loop through all of the loser's Cities
; 3551 : 		for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR _pLosingPlayer$[esp+96]
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+100]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL223@DoAddItems
	mov	ebp, DWORD PTR tv77[esp+92]
$LN11@DoAddItems:

; 3572 : 			}
; 3573 : 		}
; 3574 : 
; 3575 : 		// Sort the vector based on distance from winner's capital
; 3576 : 		viCityProximities.SortItems();

	mov	eax, DWORD PTR _viCityProximities$223594[esp+96]
	mov	ecx, DWORD PTR _viCityProximities$223594[esp+100]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3577 : 		int iSortedCityID;
; 3578 : 
; 3579 : 		// Just one city?
; 3580 : 		if (bGiveOnlyOneCity)

	cmp	BYTE PTR _bGiveOnlyOneCity$[esp+96], 0
	je	SHORT $LN7@DoAddItems

; 3581 : 		{
; 3582 : 			iSortedCityID = viCityProximities.GetElement(viCityProximities.size() - 1);

	mov	ecx, DWORD PTR _viCityProximities$223594[esp+96]
	mov	eax, DWORD PTR _viCityProximities$223594[esp+100]
	mov	eax, DWORD PTR [ecx+eax*8-8]

; 3583 : 			pDeal->AddCityTrade(eLosingPlayer, iSortedCityID);

	push	eax
	push	ebp
	mov	ecx, ebx
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade

; 3584 : 		}
; 3585 : 
; 3586 : 		else

	jmp	$LN3@DoAddItems
$LN7@DoAddItems:

; 3587 : 		{
; 3588 : 			// Determine the value of Cities to be given up
; 3589 : 			int iCityValueToSurrender = iCityValue * iPercentCitiesGiveUp / 100;

	imul	edi, DWORD PTR _iPercentCitiesGiveUp$[esp+96]
	mov	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3590 : 
; 3591 : 			// Loop through sorted Cities and add them to the deal if they're under the amount to give up - start from the back of the list, because that's where the CLOSEST cities are
; 3592 : 			for(int iSortedCityIndex = viCityProximities.size() - 1; iSortedCityIndex > -1 ; iSortedCityIndex--)

	mov	eax, DWORD PTR _viCityProximities$223594[esp+100]
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	dec	eax
	add	edi, edx
	cmp	eax, -1
	mov	DWORD PTR _iSortedCityIndex$223606[esp+96], eax
	jle	$LN3@DoAddItems
	jmp	SHORT $LN5@DoAddItems
$LL218@DoAddItems:
	mov	eax, DWORD PTR _iSortedCityIndex$223606[esp+96]
$LN5@DoAddItems:

; 3593 : 			{
; 3594 : 				iSortedCityID = viCityProximities.GetElement(iSortedCityIndex);

	mov	edx, DWORD PTR _viCityProximities$223594[esp+96]
	mov	ebp, DWORD PTR [edx+eax*8]

; 3595 : 				pLoopCity = pLosingPlayer->getCity(iSortedCityID);

	mov	ecx, DWORD PTR _pLosingPlayer$[esp+96]
	push	ebp
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 3596 : 
; 3597 : 				iCityValue = GetCityValue(pLoopCity->getX(), pLoopCity->getY(), bMeSurrendering, eOtherPlayer, /*bUseEvenValue*/ true);

	mov	edx, DWORD PTR _eOtherPlayer$[esp+92]
	push	1
	push	edx
	mov	edx, DWORD PTR _bMeSurrendering$[esp+100]
	mov	esi, eax
	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+116]
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	mov	ebx, eax

; 3598 : 
; 3599 : 				// City is worth less than what is left to be added to the deal, so add it
; 3600 : 				if(iCityValue < iCityValueToSurrender)

	cmp	ebx, edi
	jge	SHORT $LN4@DoAddItems

; 3601 : 				{
; 3602 : 					if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))

	mov	eax, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR tv77[esp+92]
	push	0
	push	1
	push	0
	push	-1
	push	eax
	mov	eax, DWORD PTR tv90[esp+116]
	push	esi
	mov	esi, DWORD PTR _pDeal$[esp+116]
	push	4
	push	eax
	push	ecx
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	je	SHORT $LN4@DoAddItems

; 3603 : 					{
; 3604 : 						pDeal->AddCityTrade(eLosingPlayer, iSortedCityID);

	mov	edx, DWORD PTR tv77[esp+92]
	push	ebp
	push	edx
	mov	ecx, esi
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade

; 3605 : 						iCityValueToSurrender -= iCityValue;

	sub	edi, ebx
$LN4@DoAddItems:
	mov	eax, DWORD PTR _iSortedCityIndex$223606[esp+96]
	dec	eax
	cmp	eax, -1
	mov	DWORD PTR _iSortedCityIndex$223606[esp+96], eax
	jg	$LL218@DoAddItems
$LN3@DoAddItems:

; 3606 : 					}
; 3607 : 				}
; 3608 : 			}
; 3609 : 		}
; 3610 : 	}

	mov	eax, DWORD PTR _viCityProximities$223594[esp+96]
	lea	ecx, DWORD PTR _viCityProximities$223594[esp+108]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	cmp	eax, ecx
	je	SHORT $LN194@DoAddItems
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN194@DoAddItems:

; 3611 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
	npad	1
$LN234@DoAddItems:
	DD	$LN49@DoAddItems
	DD	$LN48@DoAddItems
	DD	$LN47@DoAddItems
	DD	$LN46@DoAddItems
	DD	$LN45@DoAddItems
	DD	$LN44@DoAddItems
	DD	$LN43@DoAddItems
	DD	$LN42@DoAddItems
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _viCityProximities$223594[ebp]
	jmp	??1?$CvWeightedVector@H$00$0A@@@QAE@XZ	; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
__ehhandler$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ENDP ; CvDealAI::DoAddItemsToDealForPeaceTreaty
PUBLIC	?DoTradeScreenOpened@CvDealAI@@QAEXXZ		; CvDealAI::DoTradeScreenOpened
EXTRN	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddPeaceTreaty
EXTRN	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z:PROC ; CvDeal::SetPeaceTreatyType
EXTRN	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::SetSurrenderingPlayer
EXTRN	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC	; CvDeal::SetToPlayer
EXTRN	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::SetFromPlayer
EXTRN	?ClearItems@CvDeal@@QAEXXZ:PROC			; CvDeal::ClearItems
EXTRN	?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z:PROC ; CvGlobals::UnwrapDealPointer
EXTRN	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetTreatyWillingToAccept
EXTRN	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetTreatyWillingToOffer
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoTradeScreenOpened@CvDealAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTradeScreenOpened@CvDealAI@@QAEXXZ$0
__ehfuncinfo$?DoTradeScreenOpened@CvDealAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoTradeScreenOpened@CvDealAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoTradeScreenOpened@CvDealAI@@QAEXXZ
_TEXT	SEGMENT
_iValueImOffering$223738 = -28				; size = 4
_iValueTheyreOffering$223735 = -28			; size = 4
_ePeaceTreatyImWillingToOffer$223726 = -28		; size = 4
_iValueTheyreOffering$223739 = -24			; size = 4
_iValueImOffering$223734 = -24				; size = 4
_ePeaceTreatyImWillingToAccept$223727 = -24		; size = 4
_eMyPlayer$223725 = -20					; size = 4
_pUIDeal$223730 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DoTradeScreenOpened@CvDealAI@@QAEXXZ PROC		; CvDealAI::DoTradeScreenOpened, COMDAT
; _this$ = ecx

; 3923 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoTradeScreenOpened@CvDealAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebp
	push	esi
	mov	ebp, ecx

; 3924 : 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam

; 3925 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	edi, eax

; 3926 : 
; 3927 : 	if(GET_TEAM(GetTeam()).isAtWar(eActiveTeam))

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@DoTradeScr@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN20@DoTradeScr@2
$LN19@DoTradeScr@2:
	or	eax, -1
$LN20@DoTradeScr@2:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN54@DoTradeScr@2

; 3928 : 	{
; 3929 : 		PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]

; 3930 : 
; 3931 : 		PeaceTreatyTypes ePeaceTreatyImWillingToOffer = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToOffer(eActivePlayer);

	push	edi
	mov	DWORD PTR _eMyPlayer$223725[esp+44], eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToOffer

; 3932 : 		PeaceTreatyTypes ePeaceTreatyImWillingToAccept = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToAccept(eActivePlayer);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	push	edi
	mov	DWORD PTR _ePeaceTreatyImWillingToOffer$223726[esp+44], esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToAccept
	mov	DWORD PTR _ePeaceTreatyImWillingToAccept$223727[esp+40], eax

; 3933 : 
; 3934 : 		// Does the AI actually want peace?
; 3935 : 		if(ePeaceTreatyImWillingToOffer >= PEACE_TREATY_WHITE_PEACE && ePeaceTreatyImWillingToAccept >= PEACE_TREATY_WHITE_PEACE)

	test	esi, esi
	jl	$LN54@DoTradeScr@2
	test	eax, eax
	jl	$LN54@DoTradeScr@2

; 3936 : 		{
; 3937 : 			// Clear out UI deal first, we're going to add a couple things to it
; 3938 : 			auto_ptr<ICvDeal1> pUIDeal(GC.GetEngineUserInterface()->GetScratchDeal());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	push	ebx
	call	eax
	mov	DWORD PTR _pUIDeal$223730[esp+44], eax

; 3939 : 			CvDeal* pkUIDeal = GC.UnwrapDealPointer(pUIDeal.get());

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z ; CvGlobals::UnwrapDealPointer
	mov	esi, eax

; 3940 : 			pkUIDeal->ClearItems();

	mov	ecx, esi
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 3941 : 
; 3942 : 			CvDeal* pDeal = GC.getGame().GetGameDeals()->GetTempDeal();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ; CvGameDeals::GetTempDeal
	mov	ebx, eax

; 3943 : 			pDeal->ClearItems();

	mov	ecx, ebx
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 3944 : 			pDeal->SetFromPlayer(eActivePlayer);	// The order of these is very important!

	push	edi
	mov	ecx, ebx
	call	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetFromPlayer

; 3945 : 			pDeal->SetToPlayer(eMyPlayer);	// The order of these is very important!

	mov	ecx, DWORD PTR _eMyPlayer$223725[esp+44]
	push	ecx
	mov	ecx, ebx
	call	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetToPlayer

; 3946 : 
; 3947 : 			// AI is surrendering
; 3948 : 			if(ePeaceTreatyImWillingToOffer > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToOffer$223726[esp+44], 0
	jle	SHORT $LN3@DoTradeScr@2

; 3949 : 			{
; 3950 : 				pkUIDeal->SetSurrenderingPlayer(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$223725[esp+44]
	push	edx
	mov	ecx, esi
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3951 : 				pkUIDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToOffer);

	mov	eax, DWORD PTR _ePeaceTreatyImWillingToOffer$223726[esp+44]
	push	eax
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3952 : 
; 3953 : 				DoAddItemsToDealForPeaceTreaty(eActivePlayer, pDeal, ePeaceTreatyImWillingToOffer, /*bMeSurrendering*/ true);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToOffer$223726[esp+44]
	push	1
	push	ecx
	push	ebx
	push	edi
	mov	ecx, ebp
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3954 : 
; 3955 : 				// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3956 : 				int iValueImOffering, iValueTheyreOffering;
; 3957 : 				GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$223735[esp+48]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$223734[esp+52]
	push	eax
	push	ebx
	mov	ecx, ebp
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3958 : 				SetCachedValueOfPeaceWithHuman(-iValueImOffering);

	mov	eax, DWORD PTR _iValueImOffering$223734[esp+44]
	neg	eax
	mov	DWORD PTR [ebp+4], eax
	jmp	SHORT $LN46@DoTradeScr@2
$LN3@DoTradeScr@2:

; 3959 : 			}
; 3960 : 			// AI is asking human to surrender
; 3961 : 			else if(ePeaceTreatyImWillingToAccept > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToAccept$223727[esp+44], 0
	jle	SHORT $LN46@DoTradeScr@2

; 3962 : 			{
; 3963 : 				pkUIDeal->SetSurrenderingPlayer(eActivePlayer);

	push	edi
	mov	ecx, esi
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3964 : 				pkUIDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToAccept);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToAccept$223727[esp+44]
	push	ecx
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3965 : 
; 3966 : 				DoAddItemsToDealForPeaceTreaty(eActivePlayer, pDeal, ePeaceTreatyImWillingToAccept, /*bMeSurrendering*/ false);

	mov	edx, DWORD PTR _ePeaceTreatyImWillingToAccept$223727[esp+44]
	push	0
	push	edx
	push	ebx
	push	edi
	mov	ecx, ebp
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3967 : 
; 3968 : 				// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3969 : 				int iValueImOffering, iValueTheyreOffering;
; 3970 : 				GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	eax, DWORD PTR _iValueTheyreOffering$223739[esp+48]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$223738[esp+52]
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3971 : 				SetCachedValueOfPeaceWithHuman(iValueTheyreOffering);

	mov	edx, DWORD PTR _iValueTheyreOffering$223739[esp+44]
	mov	DWORD PTR [ebp+4], edx
$LN46@DoTradeScr@2:

; 3972 : 			}
; 3973 : 
; 3974 : 			pDeal->ClearItems();

	mov	ecx, ebx
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 3975 : 
; 3976 : 			// Now add peace items to the UI deal so that it's ready for us to make an offer
; 3977 : 			pkUIDeal->SetFromPlayer(eActivePlayer);	// The order of these is very important!

	push	edi
	mov	ecx, esi
	call	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetFromPlayer

; 3978 : 			pkUIDeal->SetToPlayer(eMyPlayer);	// The order of these is very important!

	mov	ebx, DWORD PTR _eMyPlayer$223725[esp+44]
	push	ebx
	mov	ecx, esi
	call	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetToPlayer

; 3979 : 			pkUIDeal->AddPeaceTreaty(eMyPlayer, GC.getGame().getGameSpeedInfo().getPeaceDealDuration());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	push	eax
	push	ebx
	mov	ecx, esi
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3980 : 			pkUIDeal->AddPeaceTreaty(eActivePlayer, GC.getGame().getGameSpeedInfo().getPeaceDealDuration());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	push	eax
	push	edi
	mov	ecx, esi
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3981 : 			
; 3982 : 			// slewis - adding third party city-states into the deal automatically
; 3983 : 			DoAddPlayersAlliesToTreaty(eActivePlayer, pkUIDeal);

	push	esi
	push	edi
	mov	ecx, ebp
	call	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty

; 3984 : 
; 3985 : 			// Start off as a white peace
; 3986 : 			pkUIDeal->SetPeaceTreatyType(PEACE_TREATY_WHITE_PEACE);

	push	0
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3987 : 		}

	mov	eax, DWORD PTR _pUIDeal$223730[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	pop	ebx
	test	eax, eax
	je	SHORT $LN54@DoTradeScr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN54@DoTradeScr@2:

; 3988 : 	}
; 3989 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTradeScreenOpened@CvDealAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _pUIDeal$223730[ebp]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
__ehhandler$?DoTradeScreenOpened@CvDealAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTradeScreenOpened@CvDealAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTradeScreenOpened@CvDealAI@@QAEXXZ ENDP		; CvDealAI::DoTradeScreenOpened
PUBLIC	?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z ; CvDealAI::IsOfferPeace
; Function compile flags: /Ogtpy
;	COMDAT ?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z
_TEXT	SEGMENT
tv327 = -12						; size = 4
_ePeaceTreatyTheyreWillingToAccept$223487 = -8		; size = 4
_iValueImOffering$223511 = -4				; size = 4
_iValueTheyreOffering$223507 = -4			; size = 4
_ePeaceTreatyImWillingToOffer$ = -4			; size = 4
_eMyPlayer$ = 8						; size = 4
_eOtherPlayer$ = 8					; size = 4
_iValueTheyreOffering$223512 = 12			; size = 4
_iValueImOffering$223506 = 12				; size = 4
_ePeaceTreatyImWillingToAccept$ = 12			; size = 4
_pDeal$ = 12						; size = 4
_ePeaceTreatyTheyreWillingToOffer$223488 = 16		; size = 4
_bEqualizingDeals$ = 16					; size = 1
?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z PROC ; CvDealAI::IsOfferPeace, COMDAT
; _this$ = ecx

; 3201 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 3202 : 	bool result = false;
; 3203 : 	CvAssert(eOtherPlayer >= 0);
; 3204 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3205 : 
; 3206 : 	// Can we actually complete this deal?
; 3207 : 
; 3208 : 	if(!pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), eOtherPlayer, TRADE_ITEM_PEACE_TREATY))

	mov	esi, DWORD PTR _pDeal$[esp+16]
	push	edi
	mov	edi, DWORD PTR _eOtherPlayer$[esp+20]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	mov	ebx, ecx
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	push	13					; 0000000dH
	push	edi
	push	eax
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	jne	SHORT $LN18@IsOfferPea
$LN66@IsOfferPea:
	pop	edi
	pop	esi

; 3209 : 	{
; 3210 : 		return false;

	xor	al, al
	pop	ebx

; 3335 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN18@IsOfferPea:

; 3211 : 	}
; 3212 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_PEACE_TREATY))

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	13					; 0000000dH
	push	eax
	push	edi
	mov	ecx, esi
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al

; 3213 : 	{
; 3214 : 		return false;

	je	SHORT $LN66@IsOfferPea

; 3215 : 	}
; 3216 : 
; 3217 : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx+44]
	push	ebp

; 3218 : 
; 3219 : 	PeaceTreatyTypes ePeaceTreatyImWillingToOffer = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToOffer(eOtherPlayer);

	push	edi
	mov	DWORD PTR _eMyPlayer$[esp+28], edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToOffer

; 3220 : 	PeaceTreatyTypes ePeaceTreatyImWillingToAccept = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToAccept(eOtherPlayer);

	mov	ecx, DWORD PTR [ebx]
	mov	ebp, eax
	push	edi
	mov	DWORD PTR _ePeaceTreatyImWillingToOffer$[esp+32], ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToAccept

; 3221 : 
; 3222 : 	// Peace between AI players
; 3223 : 	if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _ePeaceTreatyImWillingToAccept$[esp+24], eax
	mov	eax, edi
	imul	eax, 63236				; 0000f704H
	add	ecx, eax
	mov	DWORD PTR tv327[esp+28], eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN16@IsOfferPea

; 3224 : 	{
; 3225 : 		PeaceTreatyTypes ePeaceTreatyTheyreWillingToAccept = GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetTreatyWillingToAccept(eMyPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv327[esp+28]
	lea	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _eMyPlayer$[esp+24]
	push	edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToAccept

; 3226 : 		PeaceTreatyTypes ePeaceTreatyTheyreWillingToOffer = GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetTreatyWillingToOffer(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$[esp+24]
	mov	ecx, DWORD PTR tv327[esp+28]
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToAccept$223487[esp+28], eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, eax
	push	edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToOffer

; 3227 : 
; 3228 : 		// Is what we're willing to offer acceptable to eOtherPlayer?
; 3229 : 		if(ePeaceTreatyImWillingToOffer < ePeaceTreatyTheyreWillingToAccept)

	mov	edx, DWORD PTR _ePeaceTreatyTheyreWillingToAccept$223487[esp+28]
	cmp	ebp, edx
	mov	ecx, eax
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223488[esp+24], ecx

; 3230 : 		{
; 3231 : 			return false;

	jl	SHORT $LN65@IsOfferPea

; 3232 : 		}
; 3233 : 		// Is what eOtherPalyer is willing to offer acceptable to us?
; 3234 : 		if(ePeaceTreatyTheyreWillingToOffer < ePeaceTreatyImWillingToAccept)

	cmp	ecx, DWORD PTR _ePeaceTreatyImWillingToAccept$[esp+24]
	jge	SHORT $LN14@IsOfferPea
$LN65@IsOfferPea:
	pop	ebp
	pop	edi
	pop	esi

; 3235 : 		{
; 3236 : 			return false;

	xor	al, al
	pop	ebx

; 3335 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN14@IsOfferPea:

; 3237 : 		}
; 3238 : 
; 3239 : 		// If we're both willing to give something up (for whatever reason) reduce the surrender level of both parties until White Peace is on one side
; 3240 : 		if(ePeaceTreatyImWillingToOffer > PEACE_TREATY_WHITE_PEACE && ePeaceTreatyTheyreWillingToOffer > PEACE_TREATY_WHITE_PEACE)

	test	ebp, ebp
	jle	SHORT $LN13@IsOfferPea
	test	ecx, ecx
	jle	SHORT $LN13@IsOfferPea

; 3241 : 		{
; 3242 : 			int iAmountToReduce = min(ePeaceTreatyImWillingToOffer, ePeaceTreatyTheyreWillingToOffer);

	cmp	ecx, ebp
	lea	eax, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223488[esp+24]
	jl	SHORT $LN52@IsOfferPea
	lea	eax, DWORD PTR _ePeaceTreatyImWillingToOffer$[esp+28]
$LN52@IsOfferPea:
	mov	eax, DWORD PTR [eax]

; 3243 : 
; 3244 : 			ePeaceTreatyImWillingToOffer = PeaceTreatyTypes(ePeaceTreatyImWillingToOffer - iAmountToReduce);

	sub	ebp, eax

; 3245 : 			ePeaceTreatyTheyreWillingToOffer = PeaceTreatyTypes(ePeaceTreatyTheyreWillingToOffer - iAmountToReduce);

	sub	ecx, eax
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223488[esp+24], ecx
$LN13@IsOfferPea:

; 3246 : 		}
; 3247 : 
; 3248 : 		// Get the Peace in between if there's a gap
; 3249 : 		if(ePeaceTreatyImWillingToOffer > ePeaceTreatyTheyreWillingToAccept)

	cmp	ebp, edx
	jle	SHORT $LN12@IsOfferPea

; 3250 : 		{
; 3251 : 			ePeaceTreatyImWillingToOffer = PeaceTreatyTypes((ePeaceTreatyImWillingToOffer + ePeaceTreatyTheyreWillingToAccept) / 2);

	lea	eax, DWORD PTR [edx+ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebp, eax
$LN12@IsOfferPea:

; 3252 : 		}
; 3253 : 		if(ePeaceTreatyTheyreWillingToOffer > ePeaceTreatyImWillingToAccept)

	mov	eax, DWORD PTR _ePeaceTreatyImWillingToAccept$[esp+24]
	cmp	ecx, eax
	jle	SHORT $LN11@IsOfferPea

; 3254 : 		{
; 3255 : 			ePeaceTreatyTheyreWillingToOffer = PeaceTreatyTypes((ePeaceTreatyTheyreWillingToOffer + ePeaceTreatyImWillingToAccept) / 2);

	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223488[esp+24], eax
	mov	ecx, eax
$LN11@IsOfferPea:

; 3256 : 		}
; 3257 : 
; 3258 : 		CvAssertMsg(ePeaceTreatyImWillingToOffer >= PEACE_TREATY_WHITE_PEACE, "DEAL_AI: I'm offering a peace treaty with negative ID.  Please show Jon");
; 3259 : 		CvAssertMsg(ePeaceTreatyTheyreWillingToOffer >= PEACE_TREATY_WHITE_PEACE, "DEAL_AI: They're offering a peace treaty with negative ID.  Please show Jon");
; 3260 : 
; 3261 : 		// I'm surrendering in this deal
; 3262 : 		if(ePeaceTreatyImWillingToOffer > ePeaceTreatyTheyreWillingToOffer)

	cmp	ebp, ecx
	jle	SHORT $LN62@IsOfferPea

; 3263 : 		{
; 3264 : 			pDeal->SetSurrenderingPlayer(eMyPlayer);

	mov	eax, DWORD PTR _eMyPlayer$[esp+24]
	push	eax
	mov	ecx, esi
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3265 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToOffer);

	push	ebp
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3266 : 
; 3267 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyImWillingToOffer, /*bMeSurrendering*/ true);

	push	1
	jmp	SHORT $LN63@IsOfferPea
$LN62@IsOfferPea:

; 3268 : 		}
; 3269 : 		// They're surrendering in this deal
; 3270 : 		else if(ePeaceTreatyImWillingToOffer < ePeaceTreatyTheyreWillingToOffer)

	jge	SHORT $LN8@IsOfferPea

; 3271 : 		{
; 3272 : 			pDeal->SetSurrenderingPlayer(eOtherPlayer);

	push	edi
	mov	ecx, esi
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3273 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyTheyreWillingToOffer);

	mov	ebp, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223488[esp+24]
	push	ebp
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3274 : 
; 3275 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyTheyreWillingToOffer, /*bMeSurrendering*/ false);

	push	0
$LN63@IsOfferPea:
	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty
$LN8@IsOfferPea:

; 3276 : 		}
; 3277 : 
; 3278 : 		// Add the peace items to the deal so that we actually stop the war
; 3279 : 		int iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration

; 3280 : 		pDeal->AddPeaceTreaty(eMyPlayer, iPeaceTreatyLength);

	mov	ecx, DWORD PTR _eMyPlayer$[esp+24]
	mov	ebx, eax
	push	ebx
	push	ecx

; 3281 : 		pDeal->AddPeaceTreaty(eOtherPlayer, iPeaceTreatyLength);
; 3282 : 
; 3283 : 		result = true;
; 3284 : 	}
; 3285 : 
; 3286 : 	// Peace with a human
; 3287 : 	else

	jmp	$LN64@IsOfferPea
$LN16@IsOfferPea:

; 3288 : 	{
; 3289 : 		// AI is surrendering
; 3290 : 		if(ePeaceTreatyImWillingToOffer > PEACE_TREATY_WHITE_PEACE)

	test	ebp, ebp
	jle	SHORT $LN6@IsOfferPea

; 3291 : 		{
; 3292 : 			pDeal->SetSurrenderingPlayer(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$[esp+24]
	push	edx
	mov	ecx, esi
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3293 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToOffer);

	push	ebp
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3294 : 
; 3295 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyImWillingToOffer, /*bMeSurrendering*/ true);

	push	1
	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3296 : 
; 3297 : 			// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3298 : 			int iValueImOffering, iValueTheyreOffering;
; 3299 : 			GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	eax, DWORD PTR _iValueTheyreOffering$223507[esp+32]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$223506[esp+32]
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3300 : 			if (!bEqualizingDeals)

	cmp	BYTE PTR _bEqualizingDeals$[esp+24], 0
	jne	SHORT $LN1@IsOfferPea

; 3301 : 			{
; 3302 : 				SetCachedValueOfPeaceWithHuman(-iValueImOffering);

	mov	edx, DWORD PTR _iValueImOffering$223506[esp+24]
	neg	edx
	mov	DWORD PTR [ebx+4], edx

; 3303 : 			}
; 3304 : 		}

	jmp	SHORT $LN1@IsOfferPea
$LN6@IsOfferPea:

; 3305 : 		// AI is asking human to surrender
; 3306 : 		else if(ePeaceTreatyImWillingToAccept > PEACE_TREATY_WHITE_PEACE)

	mov	ebp, DWORD PTR _ePeaceTreatyImWillingToAccept$[esp+24]
	test	ebp, ebp
	jle	SHORT $LN3@IsOfferPea

; 3307 : 		{
; 3308 : 			pDeal->SetSurrenderingPlayer(eOtherPlayer);

	push	edi
	mov	ecx, esi
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3309 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToAccept);

	push	ebp
	mov	ecx, esi
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3310 : 
; 3311 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyImWillingToAccept, /*bMeSurrendering*/ false);

	push	0
	push	ebp
	push	esi
	push	edi
	mov	ecx, ebx
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3312 : 
; 3313 : 			// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3314 : 			int iValueImOffering, iValueTheyreOffering;
; 3315 : 			GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	eax, DWORD PTR _iValueTheyreOffering$223512[esp+28]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$223511[esp+36]
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3316 : 			if (!bEqualizingDeals)

	cmp	BYTE PTR _bEqualizingDeals$[esp+24], 0
	jne	SHORT $LN1@IsOfferPea

; 3317 : 			{
; 3318 : 				SetCachedValueOfPeaceWithHuman(iValueTheyreOffering);

	mov	edx, DWORD PTR _iValueTheyreOffering$223512[esp+24]
	mov	DWORD PTR [ebx+4], edx

; 3319 : 			}
; 3320 : 		}
; 3321 : 		else

	jmp	SHORT $LN1@IsOfferPea
$LN3@IsOfferPea:

; 3322 : 		{
; 3323 : 			// if the case is that we both want white peace, don't forget to add the city-states into the peace deal.
; 3324 : 			DoAddPlayersAlliesToTreaty(eOtherPlayer, pDeal);

	push	esi
	push	edi
	mov	ecx, ebx
	call	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty
$LN1@IsOfferPea:

; 3325 : 		}
; 3326 : 
; 3327 : 		int iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	mov	ebx, eax

; 3328 : 		pDeal->AddPeaceTreaty(eMyPlayer, iPeaceTreatyLength);

	mov	eax, DWORD PTR _eMyPlayer$[esp+24]
	push	ebx
	push	eax
$LN64@IsOfferPea:
	mov	ecx, esi
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3329 : 		pDeal->AddPeaceTreaty(eOtherPlayer, iPeaceTreatyLength);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty
	pop	ebp
	pop	edi
	pop	esi

; 3330 : 
; 3331 : 		result = true;
; 3332 : 	}
; 3333 : 
; 3334 : 	return result;

	mov	al, 1
	pop	ebx

; 3335 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z ENDP ; CvDealAI::IsOfferPeace
_TEXT	ENDS
PUBLIC	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
; Function compile flags: /Ogtpy
;	COMDAT ?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z
_TEXT	SEGMENT
_iValueTheyreOffering$222211 = -20			; size = 4
_iValueImOffering$222210 = -16				; size = 4
_iDealDuration$ = -12					; size = 4
_iAmountUnderWeWillOffer$222213 = -8			; size = 4
_iAmountOverWeWillRequest$222212 = -4			; size = 4
_iTotalValueToMe$222209 = 8				; size = 4
_pDeal$ = 8						; size = 4
_bMakeOffer$ = 12					; size = 1
_eOtherPlayer$ = 12					; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_bDontChangeTheirExistingItems$ = 20			; size = 1
_bDealGoodToBeginWith$ = 24				; size = 4
_bCantMatchOffer$ = 28					; size = 4
?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z PROC ; CvDealAI::DoEqualizeDealWithHuman, COMDAT
; _this$ = ecx

; 589  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 590  : 	bool bMakeOffer;
; 591  : #ifdef CVASSERT_ENABLE
; 592  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 593  : 	DEBUG_VARIABLE(eMyPlayer);
; 594  : 
; 595  : 	CvAssert(eOtherPlayer >= 0);
; 596  : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 597  : 	CvAssertMsg(eMyPlayer != eOtherPlayer, "DEAL_AI: Trying to equalize human deal, but both players are the same.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 598  : #endif
; 599  : 
; 600  : 	int iDealDuration = GC.getGame().GetDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration

; 601  : 	bCantMatchOffer = false;
; 602  : 
; 603  : 	// Is this a peace deal?
; 604  : 	if (pDeal->IsPeaceTreatyTrade(eOtherPlayer))

	mov	ebp, DWORD PTR _eOtherPlayer$[esp+32]
	mov	esi, DWORD PTR _pDeal$[esp+32]
	mov	ebx, DWORD PTR _bCantMatchOffer$[esp+32]
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _iDealDuration$[esp+40], eax
	mov	BYTE PTR [ebx], 0
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	test	al, al
	je	SHORT $LN9@DoEqualize@2

; 605  : 	{
; 606  : 		pDeal->ClearItems();

	mov	ecx, esi
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 607  : 		bMakeOffer = IsOfferPeace(eOtherPlayer, pDeal, true /*bEqualizingDeals*/);

	push	1
	push	esi
	push	ebp
	mov	ecx, edi
	call	?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z ; CvDealAI::IsOfferPeace
	pop	edi
	pop	esi
	pop	ebp

; 674  : 			{
; 675  : 				bMakeOffer = IsDealWithHumanAcceptable(pDeal, GC.getGame().getActivePlayer(), /*Passed by reference*/ iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, /*passed by reference*/bCantMatchOffer);

	mov	BYTE PTR _bMakeOffer$[esp+20], al
	pop	ebx

; 681  : }

	add	esp, 20					; 00000014H
	ret	24					; 00000018H
$LN9@DoEqualize@2:

; 608  : 	}
; 609  : 	else
; 610  : 	{
; 611  : 		int iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer;
; 612  : 		bMakeOffer = IsDealWithHumanAcceptable(pDeal, GC.getGame().getActivePlayer(), /*Passed by reference*/ iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, bCantMatchOffer);

	push	ebx
	lea	eax, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+40]
	push	eax
	lea	ecx, DWORD PTR _iAmountOverWeWillRequest$222212[esp+44]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+48]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+52]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+52]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	push	esi
	mov	ecx, edi
	call	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable

; 613  : 
; 614  : 		if (iTotalValueToMe < 0 && bDontChangeTheirExistingItems)

	cmp	DWORD PTR _iTotalValueToMe$222209[esp+32], 0
	mov	ebx, DWORD PTR _bDontChangeTheirExistingItems$[esp+32]
	mov	BYTE PTR _bMakeOffer$[esp+32], al
	jge	SHORT $LN7@DoEqualize@2
	test	bl, bl
	je	SHORT $LN7@DoEqualize@2
	pop	edi
	pop	esi
	pop	ebp

; 615  : 		{
; 616  : 			return false;

	xor	al, al
	pop	ebx

; 681  : }

	add	esp, 20					; 00000014H
	ret	24					; 00000018H
$LN7@DoEqualize@2:

; 617  : 		}
; 618  : 
; 619  : 		if(bMakeOffer)

	test	al, al
	je	SHORT $LN6@DoEqualize@2

; 620  : 		{
; 621  : 			bDealGoodToBeginWith = true;

	mov	edx, DWORD PTR _bDealGoodToBeginWith$[esp+32]

; 676  : 			}
; 677  : 		}
; 678  : 	}
; 679  : 
; 680  : 	return bMakeOffer;

	mov	al, BYTE PTR _bMakeOffer$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	BYTE PTR [edx], 1
	pop	ebx

; 681  : }

	add	esp, 20					; 00000014H
	ret	24					; 00000018H
$LN6@DoEqualize@2:

; 622  : 		}
; 623  : 		else
; 624  : 		{
; 625  : 			bDealGoodToBeginWith = false;
; 626  : 		}
; 627  : 
; 628  : 		if(!bMakeOffer)
; 629  : 		{
; 630  : 			/////////////////////////////
; 631  : 			// See if there are items we can add or remove from either side to balance out the deal if it's not already even
; 632  : 			/////////////////////////////
; 633  : 
; 634  : 			bool bUseEvenValue = false;
; 635  : 
; 636  : 			// Maybe reorder these based on the AI's priorities (e.g. if it really doesn't want to give up Strategic Resources try adding those from us last)
; 637  : 
; 638  : 			//DoAddCitiesToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);
; 639  : 
; 640  : 			DoAddVoteCommitmentToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, bUseEvenValue);

	mov	ecx, DWORD PTR _iAmountOverWeWillRequest$222212[esp+36]
	mov	eax, DWORD PTR _bDealGoodToBeginWith$[esp+32]
	push	0
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	edx
	mov	BYTE PTR [eax], 0
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+48]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToThem

; 641  : 			DoAddVoteCommitmentToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+36]
	push	0
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	eax
	mov	eax, DWORD PTR _bDontChangeMyExistingItems$[esp+44]
	lea	ecx, DWORD PTR _iValueImOffering$222210[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	edx
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToUs

; 642  : 
; 643  : 			DoAddEmbassyToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, bUseEvenValue);

	mov	ecx, DWORD PTR _iAmountOverWeWillRequest$222212[esp+36]
	push	0
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+48]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToThem

; 644  : 			DoAddEmbassyToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+36]
	push	0
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	eax
	mov	eax, DWORD PTR _bDontChangeMyExistingItems$[esp+44]
	lea	ecx, DWORD PTR _iValueImOffering$222210[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	edx
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToUs

; 645  : 
; 646  : 			DoAddResourceToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	mov	ecx, DWORD PTR _iDealDuration$[esp+36]
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$222212[esp+36]
	push	0
	push	ecx
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$222211[esp+48]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$222210[esp+52]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$222209[esp+52]
	push	edx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToThem

; 647  : 			DoAddResourceToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	mov	eax, DWORD PTR _iDealDuration$[esp+36]
	mov	ecx, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+36]
	push	0
	push	eax
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+48]
	push	edx
	mov	edx, DWORD PTR _bDontChangeMyExistingItems$[esp+48]
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+52]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+52]
	push	ecx
	push	edx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToUs

; 648  : 
; 649  : 			DoAddOpenBordersToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	mov	eax, DWORD PTR _iDealDuration$[esp+36]
	mov	ecx, DWORD PTR _iAmountOverWeWillRequest$222212[esp+36]
	push	0
	push	eax
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+48]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+52]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+52]
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToThem

; 650  : 			DoAddOpenBordersToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	mov	edx, DWORD PTR _iDealDuration$[esp+36]
	mov	eax, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+36]
	push	0
	push	edx
	push	eax
	lea	ecx, DWORD PTR _iValueTheyreOffering$222211[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _bDontChangeMyExistingItems$[esp+48]
	lea	edx, DWORD PTR _iValueImOffering$222210[esp+52]
	push	edx
	lea	eax, DWORD PTR _iTotalValueToMe$222209[esp+52]
	push	eax
	push	ecx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToUs

; 651  : 
; 652  : 			DoAddGPTToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	mov	edx, DWORD PTR _iDealDuration$[esp+36]
	push	0
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$222210[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	edx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToThem

; 653  : 			DoAddGPTToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	mov	eax, DWORD PTR _iDealDuration$[esp+36]
	push	0
	push	eax
	lea	ecx, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _bDontChangeMyExistingItems$[esp+44]
	lea	edx, DWORD PTR _iValueImOffering$222210[esp+48]
	push	edx
	lea	eax, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	eax
	push	ecx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToUs

; 654  : 
; 655  : 			DoAddGoldToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+40]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+44]
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToThem

; 656  : 			DoAddGoldToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+40]
	push	edx
	mov	edx, DWORD PTR _bDontChangeMyExistingItems$[esp+40]
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+44]
	push	ecx
	push	edx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToUs

; 657  : 
; 658  : 			if (!bDontChangeTheirExistingItems)

	test	bl, bl
	jne	SHORT $LN23@DoEqualize@2

; 659  : 			{
; 660  : 				DoRemoveGPTFromThem(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	mov	eax, DWORD PTR _iDealDuration$[esp+36]
	push	0
	push	eax
	lea	ecx, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	ecx
	lea	edx, DWORD PTR _iValueImOffering$222210[esp+48]
	push	edx
	lea	eax, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromThem
$LN23@DoEqualize@2:

; 661  : 			}
; 662  : 			if (!bDontChangeMyExistingItems)

	mov	ebx, DWORD PTR _bDontChangeMyExistingItems$[esp+32]
	test	bl, bl
	jne	SHORT $LN2@DoEqualize@2

; 663  : 			{
; 664  : 				DoRemoveGPTFromUs(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	mov	ecx, DWORD PTR _iDealDuration$[esp+36]
	push	0
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+48]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	ecx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromUs
$LN2@DoEqualize@2:

; 665  : 			}
; 666  : 
; 667  : 			DoRemoveGoldFromUs(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+40]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+44]
	push	ecx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromUs

; 668  : 			DoRemoveGoldFromThem(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$222211[esp+40]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$222210[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$222209[esp+44]
	push	ecx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromThem

; 669  : 
; 670  : 			DoAddCitiesToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+36]
	push	0
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$222211[esp+44]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$222210[esp+48]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$222209[esp+48]
	push	edx
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddCitiesToUs

; 671  : 
; 672  : 			// Make sure we haven't removed everything from the deal!
; 673  : 			if(pDeal->m_TradedItems.size() > 0)

	cmp	DWORD PTR [esi+64], 0
	jbe	SHORT $LN24@DoEqualize@2

; 674  : 			{
; 675  : 				bMakeOffer = IsDealWithHumanAcceptable(pDeal, GC.getGame().getActivePlayer(), /*Passed by reference*/ iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, /*passed by reference*/bCantMatchOffer);

	mov	eax, DWORD PTR _bCantMatchOffer$[esp+32]
	push	eax
	lea	ecx, DWORD PTR _iAmountUnderWeWillOffer$222213[esp+40]
	push	ecx
	lea	edx, DWORD PTR _iAmountOverWeWillRequest$222212[esp+44]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$222211[esp+48]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$222210[esp+52]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	edx, DWORD PTR _iTotalValueToMe$222209[esp+52]
	push	edx
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	push	esi
	mov	ecx, edi
	call	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable
	mov	BYTE PTR _bMakeOffer$[esp+32], al
$LN24@DoEqualize@2:

; 676  : 			}
; 677  : 		}
; 678  : 	}
; 679  : 
; 680  : 	return bMakeOffer;

	mov	al, BYTE PTR _bMakeOffer$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 681  : }

	add	esp, 20					; 00000014H
	ret	24					; 00000018H
?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ENDP ; CvDealAI::DoEqualizeDealWithHuman
_TEXT	ENDS
PUBLIC	?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeOfferForLuxuryResource
; Function compile flags: /Ogtpy
;	COMDAT ?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_bCantMatchOffer$223677 = 8				; size = 1
_eOtherPlayer$ = 8					; size = 4
_bUselessReferenceVariable$223676 = 12			; size = 1
_pDeal$ = 12						; size = 4
?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeOfferForLuxuryResource, COMDAT
; _this$ = ecx

; 3715 : {

	push	ebp
	push	edi

; 3716 : 	CvAssert(eOtherPlayer >= 0);
; 3717 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3718 : 
; 3719 : 	ResourceTypes eLuxuryFromThem = NO_RESOURCE;
; 3720 : 
; 3721 : 	// Don't ask for a Luxury if we're hostile or planning a war
; 3722 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	mov	edi, DWORD PTR _eOtherPlayer$[esp+4]
	mov	ebp, ecx
	mov	ecx, DWORD PTR [ebp]
	push	0
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 3723 : 	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
; 3724 : 	        eApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	eax, 1
	je	$LN12@IsMakeOffe
	test	eax, eax
	je	$LN12@IsMakeOffe
	push	esi

; 3727 : 	}
; 3728 : 
; 3729 : #ifdef AUI_WARNING_FIXES
; 3730 : 	uint iResourceLoop;
; 3731 : #else
; 3732 : 	int iResourceLoop;
; 3733 : #endif
; 3734 : 	ResourceTypes eResource;
; 3735 : 
; 3736 : 	// See if the other player has a Resource to trade
; 3737 : 	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN4@IsMakeOffe
	npad	4
$LL11@IsMakeOffe:

; 3738 : 	{
; 3739 : 		eResource = (ResourceTypes) iResourceLoop;
; 3740 : 
; 3741 : 		// Only look at Luxuries
; 3742 : 		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 3743 : 		if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)

	test	eax, eax
	je	SHORT $LN10@IsMakeOffe
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN10@IsMakeOffe

; 3744 : 		{
; 3745 : 			continue;
; 3746 : 		}
; 3747 : 
; 3748 : 		// Must not be banned by World Congress
; 3749 : 		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetPlayer()->GetID(), eResource))

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	test	al, al
	jne	SHORT $LN10@IsMakeOffe

; 3750 : 		{
; 3751 : 			continue;
; 3752 : 		}
; 3753 : 
; 3754 : 		// Any extras?
; 3755 : 		if(GET_PLAYER(eOtherPlayer).getNumResourceAvailable(eResource, false) > 1)

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	esi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, 1
	jg	SHORT $LN39@IsMakeOffe
$LN10@IsMakeOffe:

; 3727 : 	}
; 3728 : 
; 3729 : #ifdef AUI_WARNING_FIXES
; 3730 : 	uint iResourceLoop;
; 3731 : #else
; 3732 : 	int iResourceLoop;
; 3733 : #endif
; 3734 : 	ResourceTypes eResource;
; 3735 : 
; 3736 : 	// See if the other player has a Resource to trade
; 3737 : 	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL11@IsMakeOffe
$LN4@IsMakeOffe:
	pop	esi
	pop	edi

; 3786 : 		}
; 3787 : 
; 3788 : 		return bDealAcceptable;
; 3789 : 	}
; 3790 : 
; 3791 : 	return false;

	xor	al, al
	pop	ebp

; 3792 : }

	ret	8
$LN39@IsMakeOffe:

; 3756 : 		{
; 3757 : 			eLuxuryFromThem = eResource;
; 3758 : 			break;
; 3759 : 		}
; 3760 : 	}
; 3761 : 
; 3762 : 	// Extra Luxury found!
; 3763 : 	if(eLuxuryFromThem != NO_RESOURCE)

	cmp	esi, -1
	je	SHORT $LN4@IsMakeOffe

; 3764 : 	{
; 3765 : 		// Can we actually complete this deal?
; 3766 : 		if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_RESOURCES, eLuxuryFromThem, 1))

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]
	push	ebx
	mov	ebx, DWORD PTR _pDeal$[esp+12]
	push	0
	push	1
	push	0
	push	-1
	push	1
	push	esi
	push	3
	push	eax
	push	edi
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	jne	SHORT $LN3@IsMakeOffe
	pop	ebx
	pop	esi
	pop	edi
	pop	ebp

; 3792 : }

	ret	8
$LN3@IsMakeOffe:

; 3767 : 		{
; 3768 : 			return false;
; 3769 : 		}
; 3770 : 
; 3771 : 		// Seed the deal with the item we want
; 3772 : 		pDeal->AddResourceTrade(eOtherPlayer, eLuxuryFromThem, 1, GC.getGame().GetDealDuration());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	push	1
	push	esi
	push	edi
	mov	ecx, ebx
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 3773 : 
; 3774 : 		bool bDealAcceptable = false;
; 3775 : 
; 3776 : 		// AI evaluation
; 3777 : 		if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman

; 3778 : 		{
; 3779 : 			bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	mov	ecx, ebp
	test	al, al
	jne	SHORT $LN2@IsMakeOffe
	push	edi
	push	ebx
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	pop	ebx
	pop	esi
	pop	edi
	pop	ebp

; 3792 : }

	ret	8
$LN2@IsMakeOffe:

; 3780 : 		}
; 3781 : 		else
; 3782 : 		{
; 3783 : 			bool bUselessReferenceVariable;
; 3784 : 			bool bCantMatchOffer;
; 3785 : 			bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, /*bDontChangeTheirExistingItems*/ true, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	edx, DWORD PTR _bCantMatchOffer$223677[esp+12]
	push	edx
	lea	eax, DWORD PTR _bUselessReferenceVariable$223676[esp+16]
	push	eax
	push	1
	push	0
	push	edi
	push	ebx
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	pop	ebx
	pop	esi
	pop	edi
	pop	ebp

; 3792 : }

	ret	8
$LN12@IsMakeOffe:
	pop	edi

; 3725 : 	{
; 3726 : 		return false;

	xor	al, al
	pop	ebp

; 3792 : }

	ret	8
?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeOfferForLuxuryResource
_TEXT	ENDS
PUBLIC	?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::MakeOfferForEmbassy
EXTRN	?WantsEmbassyAtPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::WantsEmbassyAtPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_bCantMatchOffer$223692 = 8				; size = 1
_eOtherPlayer$ = 8					; size = 4
_bUselessReferenceVariable$223691 = 12			; size = 1
_pDeal$ = 12						; size = 4
?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::MakeOfferForEmbassy, COMDAT
; _this$ = ecx

; 3796 : {

	push	esi

; 3797 : 	CvAssert(eOtherPlayer >= 0);
; 3798 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3799 : 
; 3800 : 	// Don't ask for Open Borders if we're hostile or planning war
; 3801 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	mov	esi, DWORD PTR _eOtherPlayer$[esp]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi]
	push	0
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 3802 : 	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
; 3803 : 	        eApproach == MAJOR_CIV_APPROACH_WAR		||
; 3804 : 	        eApproach == MAJOR_CIV_APPROACH_GUARDED)

	cmp	eax, 1
	je	$LN5@MakeOfferF
	test	eax, eax
	je	$LN5@MakeOfferF
	cmp	eax, 3
	je	$LN5@MakeOfferF

; 3807 : 	}
; 3808 : 
; 3809 : 	// Can we actually complete this deal?
; 3810 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_ALLOW_EMBASSY))

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	ebx
	mov	ebx, DWORD PTR _pDeal$[esp+8]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	push	eax
	push	esi
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al

; 3811 : 	{
; 3812 : 		return false;

	je	SHORT $LN3@MakeOfferF

; 3813 : 	}
; 3814 : 
; 3815 : 	// Do we actually want OB with eOtherPlayer?
; 3816 : 	if(GetPlayer()->GetDiplomacyAI()->WantsEmbassyAtPlayer(eOtherPlayer))

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?WantsEmbassyAtPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::WantsEmbassyAtPlayer
	test	al, al
	je	SHORT $LN3@MakeOfferF

; 3817 : 	{
; 3818 : 		// Seed the deal with the item we want
; 3819 : 		pDeal->AddAllowEmbassy(eOtherPlayer);

	push	esi
	mov	ecx, ebx
	call	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddAllowEmbassy

; 3820 : 		bool bDealAcceptable = false;
; 3821 : 
; 3822 : 		// AI evaluation
; 3823 : 		if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN2@MakeOfferF

; 3824 : 		{
; 3825 : 			bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	push	esi
	push	ebx
	mov	ecx, edi
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	pop	ebx
	pop	edi
	pop	esi

; 3838 : }

	ret	8
$LN2@MakeOfferF:

; 3826 : 		}
; 3827 : 		else
; 3828 : 		{
; 3829 : 			bool bUselessReferenceVariable;
; 3830 : 			bool bCantMatchOffer;
; 3831 : 			bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, false, true, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	ecx, DWORD PTR _bCantMatchOffer$223692[esp+8]
	push	ecx
	lea	edx, DWORD PTR _bUselessReferenceVariable$223691[esp+12]
	push	edx
	push	1
	push	0
	push	esi
	push	ebx
	mov	ecx, edi
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	pop	ebx
	pop	edi
	pop	esi

; 3838 : }

	ret	8
$LN3@MakeOfferF:
	pop	ebx
	pop	edi

; 3832 : 		}
; 3833 : 
; 3834 : 		return bDealAcceptable;
; 3835 : 	}
; 3836 : 
; 3837 : 	return false;

	xor	al, al
	pop	esi

; 3838 : }

	ret	8
$LN5@MakeOfferF:
	pop	edi

; 3805 : 	{
; 3806 : 		return false;

	xor	al, al
	pop	esi

; 3838 : }

	ret	8
?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::MakeOfferForEmbassy
_TEXT	ENDS
PUBLIC	?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeOfferForOpenBorders
EXTRN	?IsWantsOpenBordersWithPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantsOpenBordersWithPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_bCantMatchOffer$223707 = 8				; size = 1
_eOtherPlayer$ = 8					; size = 4
_bUselessReferenceVariable$223706 = 12			; size = 1
_pDeal$ = 12						; size = 4
?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeOfferForOpenBorders, COMDAT
; _this$ = ecx

; 3842 : {

	push	esi

; 3843 : 	CvAssert(eOtherPlayer >= 0);
; 3844 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3845 : 
; 3846 : 	// Don't ask for Open Borders if we're hostile or planning war
; 3847 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	mov	esi, DWORD PTR _eOtherPlayer$[esp]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi]
	push	0
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 3848 : 	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
; 3849 : 	        eApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	eax, 1
	je	$LN5@IsMakeOffe@2
	test	eax, eax
	je	$LN5@IsMakeOffe@2

; 3852 : 	}
; 3853 : 
; 3854 : 	// Can we actually complete this deal?
; 3855 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_OPEN_BORDERS))

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	ebx
	mov	ebx, DWORD PTR _pDeal$[esp+8]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	push	eax
	push	esi
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al

; 3856 : 	{
; 3857 : 		return false;

	je	SHORT $LN3@IsMakeOffe@2

; 3858 : 	}
; 3859 : 
; 3860 : 	// Do we actually want OB with eOtherPlayer?
; 3861 : 	if(GetPlayer()->GetDiplomacyAI()->IsWantsOpenBordersWithPlayer(eOtherPlayer))

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantsOpenBordersWithPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantsOpenBordersWithPlayer
	test	al, al
	je	SHORT $LN3@IsMakeOffe@2

; 3862 : 	{
; 3863 : 		// Seed the deal with the item we want
; 3864 : 		pDeal->AddOpenBorders(eOtherPlayer, GC.getGame().GetDealDuration());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	push	esi
	mov	ecx, ebx
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders

; 3865 : 
; 3866 : 		bool bDealAcceptable = false;
; 3867 : 
; 3868 : 		// AI evaluation
; 3869 : 		if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN2@IsMakeOffe@2

; 3870 : 		{
; 3871 : 			bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	push	esi
	push	ebx
	mov	ecx, edi
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	pop	ebx
	pop	edi
	pop	esi

; 3884 : }

	ret	8
$LN2@IsMakeOffe@2:

; 3872 : 		}
; 3873 : 		else
; 3874 : 		{
; 3875 : 			bool bUselessReferenceVariable;
; 3876 : 			bool bCantMatchOffer;
; 3877 : 			bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, false, true, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	ecx, DWORD PTR _bCantMatchOffer$223707[esp+8]
	push	ecx
	lea	edx, DWORD PTR _bUselessReferenceVariable$223706[esp+12]
	push	edx
	push	1
	push	0
	push	esi
	push	ebx
	mov	ecx, edi
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	pop	ebx
	pop	edi
	pop	esi

; 3884 : }

	ret	8
$LN3@IsMakeOffe@2:
	pop	ebx
	pop	edi

; 3878 : 		}
; 3879 : 
; 3880 : 		return bDealAcceptable;
; 3881 : 	}
; 3882 : 
; 3883 : 	return false;

	xor	al, al
	pop	esi

; 3884 : }

	ret	8
$LN5@IsMakeOffe@2:
	pop	edi

; 3850 : 	{
; 3851 : 		return false;

	xor	al, al
	pop	esi

; 3884 : }

	ret	8
?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeOfferForOpenBorders
_TEXT	ENDS
PUBLIC	?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeOfferForResearchAgreement
EXTRN	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddResearchAgreement
; Function compile flags: /Ogtpy
;	COMDAT ?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_bCantMatchOffer$223718 = 8				; size = 1
_eOtherPlayer$ = 8					; size = 4
_bUselessReferenceVariable$223717 = 12			; size = 1
_pDeal$ = 12						; size = 4
?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeOfferForResearchAgreement, COMDAT
; _this$ = ecx

; 3888 : {

	push	ebx

; 3889 : 	CvAssert(eOtherPlayer >= 0);
; 3890 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3891 : 
; 3892 : 	// Logic for when THIS AI wants to make a RA is in the Diplo AI
; 3893 : 
; 3894 : 	// Can we actually complete this deal?
; 3895 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_RESEARCH_AGREEMENT))

	mov	ebx, DWORD PTR _pDeal$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eOtherPlayer$[esp+8]
	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	-1
	push	8
	push	eax
	push	edi
	mov	ecx, ebx
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	test	al, al
	jne	SHORT $LN3@IsMakeOffe@3
	pop	edi
	pop	esi
	pop	ebx

; 3916 : 	}
; 3917 : 
; 3918 : 	return bDealAcceptable;
; 3919 : }

	ret	8
$LN3@IsMakeOffe@3:

; 3896 : 	{
; 3897 : 		return false;
; 3898 : 	}
; 3899 : 
; 3900 : 	// Seed the deal with the item we want
; 3901 : 	pDeal->AddResearchAgreement(GetPlayer()->GetID(), GC.getGame().GetDealDuration());

	mov	ecx, DWORD PTR [esi]
	push	ebp
	mov	ebp, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddResearchAgreement

; 3902 : 	pDeal->AddResearchAgreement(eOtherPlayer, GC.getGame().GetDealDuration());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	push	edi
	mov	ecx, ebx
	call	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddResearchAgreement

; 3903 : 
; 3904 : 	bool bDealAcceptable = false;
; 3905 : 
; 3906 : 	// AI evaluation
; 3907 : 	if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	pop	ebp

; 3908 : 	{
; 3909 : 		bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	mov	ecx, esi
	test	al, al
	jne	SHORT $LN2@IsMakeOffe@3
	push	edi
	push	ebx
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	pop	edi
	pop	esi
	pop	ebx

; 3916 : 	}
; 3917 : 
; 3918 : 	return bDealAcceptable;
; 3919 : }

	ret	8
$LN2@IsMakeOffe@3:

; 3910 : 	}
; 3911 : 	else
; 3912 : 	{
; 3913 : 		bool bUselessReferenceVariable;
; 3914 : 		bool bCantMatchOffer;
; 3915 : 		bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, true, false, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	edx, DWORD PTR _bCantMatchOffer$223718[esp+8]
	push	edx
	lea	eax, DWORD PTR _bUselessReferenceVariable$223717[esp+12]
	push	eax
	push	0
	push	1
	push	edi
	push	ebx
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	pop	edi
	pop	esi
	pop	ebx

; 3916 : 	}
; 3917 : 
; 3918 : 	return bDealAcceptable;
; 3919 : }

	ret	8
?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeOfferForResearchAgreement
_TEXT	ENDS
END
