; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitMovement.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ		; CvGlobals::getMOVE_DENOMINATOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMOVE_DENOMINATOR, COMDAT
; _this$ = ecx

; 5312 : 		return m_iMOVE_DENOMINATOR;

	mov	eax, DWORD PTR [ecx+6236]

; 5313 : 	}

	ret	0
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMOVE_DENOMINATOR
_TEXT	ENDS
PUBLIC	?getHILLS_EXTRA_MOVEMENT@CvGlobals@@QAEHXZ	; CvGlobals::getHILLS_EXTRA_MOVEMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getHILLS_EXTRA_MOVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getHILLS_EXTRA_MOVEMENT@CvGlobals@@QAEHXZ PROC		; CvGlobals::getHILLS_EXTRA_MOVEMENT, COMDAT
; _this$ = ecx

; 5668 : 		return m_iHILLS_EXTRA_MOVEMENT;

	mov	eax, DWORD PTR [ecx+6592]

; 5669 : 	}

	ret	0
?getHILLS_EXTRA_MOVEMENT@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getHILLS_EXTRA_MOVEMENT
_TEXT	ENDS
PUBLIC	?getZONE_OF_CONTROL_ENABLED@CvGlobals@@QAEHXZ	; CvGlobals::getZONE_OF_CONTROL_ENABLED
; Function compile flags: /Ogtpy
;	COMDAT ?getZONE_OF_CONTROL_ENABLED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getZONE_OF_CONTROL_ENABLED@CvGlobals@@QAEHXZ PROC	; CvGlobals::getZONE_OF_CONTROL_ENABLED, COMDAT
; _this$ = ecx

; 6489 : 		return m_iZONE_OF_CONTROL_ENABLED;

	mov	eax, DWORD PTR [ecx+7360]

; 6490 : 	}

	ret	0
?getZONE_OF_CONTROL_ENABLED@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getZONE_OF_CONTROL_ENABLED
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ	; CvPlot::getPlotType
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ
_TEXT	SEGMENT
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ PROC		; CvPlot::getPlotType, COMDAT
; _this$ = ecx

; 405  : 		return (PlotTypes)m_ePlotType;

	movsx	eax, BYTE PTR [ecx+5]

; 406  : 	}

	ret	0
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ENDP		; CvPlot::getPlotType
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?isRoughGround@CvPlot@@QBE_NXZ			; CvPlot::isRoughGround
; Function compile flags: /Ogtpy
;	COMDAT ?isRoughGround@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRoughGround@CvPlot@@QBE_NXZ PROC			; CvPlot::isRoughGround, COMDAT
; _this$ = ecx

; 453  : 		if(isHills())

	mov	al, BYTE PTR [ecx+5]
	cmp	al, 1
	jne	SHORT $LN2@isRoughGro
$LN9@isRoughGro:

; 454  : 		{
; 455  : 			return true;

	mov	al, 1

; 463  : 	}

	ret	0
$LN2@isRoughGro:

; 456  : 		}
; 457  : 		if(isMountain())

	test	al, al

; 458  : 		{
; 459  : 			return true;

	je	SHORT $LN9@isRoughGro

; 460  : 		}
; 461  : 
; 462  : 		return m_bRoughFeature;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 3
	and	al, 1

; 463  : 	}

	ret	0
?isRoughGround@CvPlot@@QBE_NXZ ENDP			; CvPlot::isRoughGround
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 716  : 		return m_bMoveFriendlyWoodsAsRoad;

	mov	al, BYTE PTR [ecx+325]

; 717  : 	};

	ret	0
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?IsFasterAlongRiver@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsFasterAlongRiver
; Function compile flags: /Ogtpy
;	COMDAT ?IsFasterAlongRiver@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsFasterAlongRiver@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsFasterAlongRiver, COMDAT
; _this$ = ecx

; 720  : 		return m_bFasterAlongRiver;

	mov	al, BYTE PTR [ecx+326]

; 721  : 	};

	ret	0
?IsFasterAlongRiver@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsFasterAlongRiver
_TEXT	ENDS
PUBLIC	?IsFasterInHills@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsFasterInHills
; Function compile flags: /Ogtpy
;	COMDAT ?IsFasterInHills@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsFasterInHills@CvPlayerTraits@@QBE_NXZ PROC		; CvPlayerTraits::IsFasterInHills, COMDAT
; _this$ = ecx

; 724  : 		return m_bFasterInHills;

	mov	al, BYTE PTR [ecx+327]

; 725  : 	};

	ret	0
?IsFasterInHills@CvPlayerTraits@@QBE_NXZ ENDP		; CvPlayerTraits::IsFasterInHills
_TEXT	ENDS
PUBLIC	?IsEmbarkedToLandFlatCost@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsEmbarkedToLandFlatCost
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedToLandFlatCost@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedToLandFlatCost@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsEmbarkedToLandFlatCost, COMDAT
; _this$ = ecx

; 732  : 		return m_bEmbarkedToLandFlatCost;

	mov	al, BYTE PTR [ecx+329]

; 733  : 	};

	ret	0
?IsEmbarkedToLandFlatCost@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsEmbarkedToLandFlatCost
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebx

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	mov	ebx, DWORD PTR _iSourceY$[esp]
	push	esi
	push	edi
	test	ebx, ebx
	jl	SHORT $LN17@directionX
	mov	eax, ebx
	jmp	SHORT $LN51@directionX
$LN17@directionX:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN51@directionX:
	mov	esi, DWORD PTR _iSourceX$[esp+8]

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	mov	edi, DWORD PTR _iDestY$[esp+8]
	sar	eax, 1
	sub	esi, eax
	test	edi, edi
	jl	SHORT $LN21@directionX
	mov	eax, edi
	jmp	SHORT $LN52@directionX
$LN21@directionX:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN52@directionX:

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestX$[esp+8]
	sar	eax, 1
	sub	ecx, eax
	sub	ecx, esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [esi+4056], 0
	mov	edx, DWORD PTR [esi+4020]
	je	SHORT $LN31@directionX
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN33@directionX
	sub	ecx, edx
	jmp	SHORT $LN31@directionX
$LN33@directionX:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN35@directionX
$LN31@directionX:
	mov	eax, ecx
$LN35@directionX:

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	sub	edi, ebx
	cmp	BYTE PTR [esi+4057], 0
	mov	edx, edi
	mov	edi, DWORD PTR [esi+4024]
	je	SHORT $LN45@directionX
	mov	esi, edi
	shr	esi, 1
	cmp	edx, esi
	jle	SHORT $LN47@directionX
	sub	edx, edi
	jmp	SHORT $LN45@directionX
$LN47@directionX:
	neg	esi
	cmp	edx, esi
	jge	SHORT $LN45@directionX
	add	edx, edi
$LN45@directionX:
	pop	edi
	pop	esi
	pop	ebx

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	test	edx, edx
	jle	SHORT $LN53@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	xor	ecx, ecx
	test	eax, eax
	setge	cl
	dec	ecx
	and	ecx, 5
	mov	eax, ecx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN53@directionX:

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;
; 276  : 		}
; 277  : 		else
; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;
; 280  : 		}
; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	test	eax, eax
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	neg	eax
	sbb	eax, eax
	and	eax, 5
	dec	eax

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN8@directionX:

; 289  : 		{
; 290  : 			return NO_DIRECTION;
; 291  : 		}
; 292  : 		else
; 293  : 		{
; 294  : 			return DIRECTION_WEST;
; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)
; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	xor	edx, edx
	test	eax, eax
	setle	dl
	add	edx, 2
	mov	eax, edx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[esp-4]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	mov	eax, DWORD PTR _pFromPlot$[esp-4]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z		; CvPlot::isEnemyCity
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_kUnit$ = 8						; size = 4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z PROC		; CvPlot::isEnemyCity, COMDAT
; _this$ = ecx

; 252  : 	{

	push	esi
	mov	esi, ecx

; 253  : 		CvCity* pCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN1@isEnemyCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isEnemyCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 254  : 		if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN1@isEnemyCit

; 255  : 			return kUnit.isEnemy(pCity->getTeam(), this);

	push	esi
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR _kUnit$[esp+4]
	push	eax
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	pop	esi

; 258  : 	}

	ret	4
$LN1@isEnemyCit:

; 256  : 
; 257  : 		return false;

	xor	al, al
	pop	esi

; 258  : 	}

	ret	4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z ENDP		; CvPlot::isEnemyCity
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ; CvUnitMovement::GetCostsForMove
EXTRN	?IsAllowsSailLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsAllowsSailLand
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z:PROC ; CvTeam::getRouteChange
EXTRN	?getFlatMovementCost@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::getFlatMovementCost
EXTRN	?getMovementCost@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::getMovementCost
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
EXTRN	?isBridgeBuilding@CvTeam@@QBE_NXZ:PROC		; CvTeam::isBridgeBuilding
EXTRN	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC	; CvPlot::isValidRoute
EXTRN	?isFeatureDoubleMove@CvUnit@@QBE_NW4FeatureTypes@@@Z:PROC ; CvUnit::isFeatureDoubleMove
EXTRN	?isTerrainDoubleMove@CvUnit@@QBE_NW4TerrainTypes@@@Z:PROC ; CvUnit::isTerrainDoubleMove
EXTRN	?isHillsDoubleMove@CvUnit@@QBE_NXZ:PROC		; CvUnit::isHillsDoubleMove
EXTRN	?IsRoughTerrainEndsTurn@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsRoughTerrainEndsTurn
EXTRN	?getExtraMoveDiscount@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraMoveDiscount
EXTRN	?getMovementCost@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getMovementCost
EXTRN	?getMovementCost@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getMovementCost
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossing
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?ignoreTerrainCost@CvUnit@@QBE_NXZ:PROC		; CvUnit::ignoreTerrainCost
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmovement.cpp
;	COMDAT ?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z
_TEXT	SEGMENT
_bIgnoreTerrainCost$ = -27				; size = 1
_bFasterAlongRiver$ = -26				; size = 1
_bFasterInHills$ = -25					; size = 1
_kUnitTeam$ = -24					; size = 4
_iMoveDenominator$ = -20				; size = 4
_iFromMovementCost$217636 = -16				; size = 4
_pTraits$ = -16						; size = 4
_eFeature$ = -12					; size = 4
$T218635 = -8						; size = 4
_eTerrain$ = -4						; size = 4
tv671 = 8						; size = 4
_pUnit$ = 8						; size = 4
$T218649 = 12						; size = 4
$T218646 = 12						; size = 4
_iMovementCost$217639 = 12				; size = 4
$T218634 = 12						; size = 4
_pFeatureInfo$ = 12					; size = 4
_pFromPlot$ = 12					; size = 4
$T218648 = 16						; size = 4
$T218647 = 16						; size = 4
_eFromPlotRoute$217630 = 16				; size = 4
_bRiverCrossing$ = 16					; size = 1
_pToPlot$ = 16						; size = 4
_iBaseMoves$ = 20					; size = 4
_iRegularCost$ = 24					; size = 4
_iRouteCost$ = 28					; size = 4
_iRouteFlatCost$ = 32					; size = 4
?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z PROC ; CvUnitMovement::GetCostsForMove, COMDAT

; 10   : {

	sub	esp, 28					; 0000001cH
	push	ebx

; 11   : 	CvPlayerAI& kPlayer = GET_PLAYER(pUnit->getOwner());

	mov	ebx, DWORD PTR _pUnit$[esp+28]
	mov	ecx, DWORD PTR [ebx+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	esi
	push	edi

; 12   : 	CvPlayerTraits* pTraits = kPlayer.GetPlayerTraits();

	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 13   : 	bool bFasterAlongRiver = pTraits->IsFasterAlongRiver();

	mov	cl, BYTE PTR [eax+326]

; 14   : 	bool bFasterInHills = pTraits->IsFasterInHills();

	mov	dl, BYTE PTR [eax+327]
	mov	BYTE PTR _bFasterAlongRiver$[esp+44], cl

; 15   : 	bool bIgnoreTerrainCost = pUnit->ignoreTerrainCost();

	mov	ecx, ebx
	mov	DWORD PTR _pTraits$[esp+44], eax
	mov	BYTE PTR _bFasterInHills$[esp+44], dl
	call	?ignoreTerrainCost@CvUnit@@QBE_NXZ	; CvUnit::ignoreTerrainCost

; 16   : 	//int iBaseMoves = pUnit->baseMoves(isWater()?DOMAIN_SEA:NO_DOMAIN);
; 17   : 	TeamTypes eUnitTeam = pUnit->getTeam();

	mov	ecx, ebx
	mov	BYTE PTR _bIgnoreTerrainCost$[esp+44], al
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam

; 18   : 	CvTeam& kUnitTeam = GET_TEAM(eUnitTeam);

	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 19   : 	int iMoveDenominator = GC.getMOVE_DENOMINATOR();
; 20   : 	bool bRiverCrossing = pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot));

	mov	edi, DWORD PTR _pToPlot$[esp+40]
	movsx	ecx, WORD PTR [edi+2]
	mov	esi, DWORD PTR _pFromPlot$[esp+40]
	movsx	edx, WORD PTR [edi]
	mov	DWORD PTR _kUnitTeam$[esp+44], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	push	ecx
	movsx	ecx, WORD PTR [esi]
	mov	DWORD PTR _iMoveDenominator$[esp+48], eax
	movsx	eax, WORD PTR [esi+2]
	push	edx
	push	eax
	push	ecx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, esi
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing

; 21   : 	FeatureTypes eFeature = pToPlot->getFeatureType();

	movsx	ebp, BYTE PTR [edi+432]

; 22   : 	CvFeatureInfo* pFeatureInfo = (eFeature > NO_FEATURE) ? GC.getFeatureInfo(eFeature) : 0;

	cmp	ebp, -1
	mov	BYTE PTR _bRiverCrossing$[esp+40], al
	mov	DWORD PTR _eFeature$[esp+44], ebp
	jle	SHORT $LN27@GetCostsFo
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pFeatureInfo$[esp+40], eax
	jmp	SHORT $LN28@GetCostsFo
$LN27@GetCostsFo:
	mov	DWORD PTR _pFeatureInfo$[esp+40], 0
$LN28@GetCostsFo:

; 23   : 	TerrainTypes eTerrain = pToPlot->getTerrainType();

	movsx	eax, BYTE PTR [edi+6]

; 24   : 	CvTerrainInfo* pTerrainInfo = (eTerrain > NO_TERRAIN) ? GC.getTerrainInfo(eTerrain) : 0;

	cmp	eax, -1
	mov	DWORD PTR _eTerrain$[esp+44], eax
	jle	SHORT $LN29@GetCostsFo
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	jmp	SHORT $LN30@GetCostsFo
$LN29@GetCostsFo:
	xor	eax, eax
$LN30@GetCostsFo:

; 25   : 	
; 26   : 	
; 27   : 	
; 28   : 
; 29   : #ifdef NQ_FIX_FASTER_ALONG_RIVER
; 30   : 	if(bIgnoreTerrainCost || (bFasterAlongRiver && pToPlot->isRiver() && pFromPlot->isRiver()) || (bFasterInHills && pToPlot->isHills()))

	cmp	BYTE PTR _bIgnoreTerrainCost$[esp+44], 0
	jne	$LN137@GetCostsFo
	cmp	BYTE PTR _bFasterAlongRiver$[esp+44], 0
	je	SHORT $LN22@GetCostsFo
	cmp	BYTE PTR [edi+457], 0
	jle	SHORT $LN22@GetCostsFo
	cmp	BYTE PTR [esi+457], 0
	jg	$LN137@GetCostsFo
$LN22@GetCostsFo:
	cmp	BYTE PTR _bFasterInHills$[esp+44], 0
	je	SHORT $LN24@GetCostsFo
	cmp	BYTE PTR [edi+5], 1
	je	$LN137@GetCostsFo
$LN24@GetCostsFo:

; 36   : 	}
; 37   : 	else
; 38   : 	{
; 39   : 		iRegularCost = ((eFeature == NO_FEATURE) ? (pTerrainInfo ? pTerrainInfo->getMovementCost() : 0) : (pFeatureInfo ? pFeatureInfo->getMovementCost() : 0));

	cmp	ebp, -1
	jne	SHORT $LN35@GetCostsFo
	test	eax, eax
	je	SHORT $LN33@GetCostsFo
	mov	ecx, eax
	call	?getMovementCost@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getMovementCost
	jmp	SHORT $LN34@GetCostsFo
$LN35@GetCostsFo:
	mov	ecx, DWORD PTR _pFeatureInfo$[esp+40]
	test	ecx, ecx
	je	SHORT $LN33@GetCostsFo
	call	?getMovementCost@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getMovementCost
	jmp	SHORT $LN34@GetCostsFo
$LN33@GetCostsFo:
	xor	eax, eax
$LN34@GetCostsFo:
	mov	ebp, DWORD PTR _iRegularCost$[esp+40]
	mov	DWORD PTR [ebp], eax

; 40   : 
; 41   : 		// Hill cost, except for when a City is present here, then it just counts as flat land
; 42   : 		if((PlotTypes)pToPlot->getPlotType() == PLOT_HILLS && !pToPlot->isCity())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN136@GetCostsFo
	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN134@GetCostsFo
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN134@GetCostsFo
	mov	edx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN136@GetCostsFo
$LN134@GetCostsFo:

; 43   : 		{
; 44   : 			iRegularCost += GC.getHILLS_EXTRA_MOVEMENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6592
	add	DWORD PTR [ebp], eax
$LN136@GetCostsFo:

; 45   : 		}
; 46   : 
; 47   : 		if(iRegularCost > 0)

	cmp	DWORD PTR [ebp], 0
	jle	SHORT $LN138@GetCostsFo

; 48   : 		{
; 49   : 			iRegularCost = std::max(1, (iRegularCost - pUnit->getExtraMoveDiscount()));

	mov	ecx, ebx
	call	?getExtraMoveDiscount@CvUnit@@QBEHXZ	; CvUnit::getExtraMoveDiscount
	mov	ecx, DWORD PTR [ebp]
	sub	ecx, eax
	cmp	ecx, 1
	mov	DWORD PTR $T218634[esp+40], ecx
	mov	DWORD PTR $T218635[esp+44], 1
	lea	eax, DWORD PTR $T218634[esp+40]
	jg	SHORT $LN95@GetCostsFo
	lea	eax, DWORD PTR $T218635[esp+44]
$LN95@GetCostsFo:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebp], ecx
	jmp	SHORT $LN138@GetCostsFo
$LN137@GetCostsFo:

; 31   : #else
; 32   : 	if(bIgnoreTerrainCost || (bFasterAlongRiver && pToPlot->isRiver()) || (bFasterInHills && pToPlot->isHills()))
; 33   : #endif
; 34   : 	{
; 35   : 		iRegularCost = 1;

	mov	edx, DWORD PTR _iRegularCost$[esp+40]
	mov	DWORD PTR [edx], 1
	mov	ebp, edx
$LN138@GetCostsFo:

; 50   : 		}
; 51   : 
; 52   : 		
; 53   : 	}
; 54   : 
; 55   : 	// Is a unit's movement consumed for entering rough terrain?
; 56   : #ifdef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 57   : 	if ((pToPlot->isRoughGround() && pUnit->IsRoughTerrainEndsTurn()) || (!(bIgnoreTerrainCost || bFasterAlongRiver) && bRiverCrossing))

	mov	al, BYTE PTR [edi+5]
	cmp	al, 1
	je	SHORT $LN135@GetCostsFo
	test	al, al
	je	SHORT $LN135@GetCostsFo
	mov	al, BYTE PTR [edi+462]
	shr	al, 3
	and	al, 1
	je	SHORT $LN16@GetCostsFo
$LN135@GetCostsFo:
	mov	ecx, ebx
	call	?IsRoughTerrainEndsTurn@CvUnit@@QBE_NXZ	; CvUnit::IsRoughTerrainEndsTurn
	test	al, al
	jne	SHORT $LN17@GetCostsFo
$LN16@GetCostsFo:
	cmp	BYTE PTR _bIgnoreTerrainCost$[esp+44], 0
	jne	SHORT $LN18@GetCostsFo
	cmp	BYTE PTR _bFasterAlongRiver$[esp+44], 0
	jne	SHORT $LN18@GetCostsFo
	cmp	BYTE PTR _bRiverCrossing$[esp+40], 0
	je	SHORT $LN18@GetCostsFo
$LN17@GetCostsFo:

; 58   : #else
; 59   : 	if(pToPlot->isRoughGround() && pUnit->IsRoughTerrainEndsTurn())
; 60   : #endif
; 61   : 	{
; 62   : 		iRegularCost = INT_MAX;

	mov	DWORD PTR [ebp], 2147483647		; 7fffffffH

; 63   : 	}
; 64   : 	else

	jmp	SHORT $LN139@GetCostsFo
$LN18@GetCostsFo:

; 65   : 	{
; 66   : #ifndef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 67   : 		if(!(bIgnoreTerrainCost || bFasterAlongRiver) && bRiverCrossing)
; 68   : 		{
; 69   : 			iRegularCost += GC.getRIVER_EXTRA_MOVEMENT();
; 70   : 		}
; 71   : #endif
; 72   : 		iRegularCost *= iMoveDenominator;

	mov	ecx, DWORD PTR [ebp]
	imul	ecx, DWORD PTR _iMoveDenominator$[esp+44]
	mov	DWORD PTR [ebp], ecx

; 73   : 
; 74   : 		if(pToPlot->isHills() && pUnit->isHillsDoubleMove())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN14@GetCostsFo
	mov	ecx, ebx
	call	?isHillsDoubleMove@CvUnit@@QBE_NXZ	; CvUnit::isHillsDoubleMove
	test	al, al

; 75   : 		{
; 76   : 			iRegularCost /= 2;

	jne	SHORT $LN144@GetCostsFo
$LN14@GetCostsFo:

; 77   : 		}
; 78   : 
; 79   : 		else if((eFeature == NO_FEATURE) ? pUnit->isTerrainDoubleMove(eTerrain) : pUnit->isFeatureDoubleMove(eFeature))

	mov	eax, DWORD PTR _eFeature$[esp+44]
	mov	ecx, ebx
	cmp	eax, -1
	jne	SHORT $LN37@GetCostsFo
	mov	edx, DWORD PTR _eTerrain$[esp+44]
	push	edx
	call	?isTerrainDoubleMove@CvUnit@@QBE_NW4TerrainTypes@@@Z ; CvUnit::isTerrainDoubleMove
	jmp	SHORT $LN38@GetCostsFo
$LN37@GetCostsFo:
	push	eax
	call	?isFeatureDoubleMove@CvUnit@@QBE_NW4FeatureTypes@@@Z ; CvUnit::isFeatureDoubleMove
$LN38@GetCostsFo:
	test	al, al
	je	SHORT $LN139@GetCostsFo
$LN144@GetCostsFo:

; 80   : 		{
; 81   : 			iRegularCost /= 2;

	mov	eax, DWORD PTR [ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ebp], eax
$LN139@GetCostsFo:

; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : #ifndef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 86   : 	iRegularCost = std::min(iRegularCost, (iBaseMoves * iMoveDenominator));
; 87   : #endif
; 88   : 
; 89   : 	if(pFromPlot->isValidRoute(pUnit) && pToPlot->isValidRoute(pUnit) && ((kUnitTeam.isBridgeBuilding() || !(pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot))))))

	push	ebx
	mov	ecx, esi
	call	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isValidRoute
	test	al, al
	je	$LN11@GetCostsFo
	push	ebx
	mov	ecx, edi
	call	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isValidRoute
	test	al, al
	je	$LN11@GetCostsFo
	mov	ecx, DWORD PTR _kUnitTeam$[esp+44]
	call	?isBridgeBuilding@CvTeam@@QBE_NXZ	; CvTeam::isBridgeBuilding
	test	al, al
	jne	SHORT $LN10@GetCostsFo
	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	movsx	edx, WORD PTR [esi+2]
	push	eax
	movsx	eax, WORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, esi
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	test	al, al
	jne	$LN11@GetCostsFo
$LN10@GetCostsFo:

; 90   : 	{
; 91   : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 92   : 		RouteTypes eFromPlotRoute = pFromPlot->getRouteType();

	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	ebx, eax

; 93   : 		RouteTypes eToPlotRoute = pToPlot->getRouteType();

	mov	ecx, edi
	mov	DWORD PTR _eFromPlotRoute$217630[esp+40], ebx
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType

; 94   : 		if (pTraits->IsMoveFriendlyWoodsAsRoad())

	mov	ecx, DWORD PTR _pTraits$[esp+44]
	cmp	BYTE PTR [ecx+325], 0
	mov	esi, eax
	je	SHORT $LN142@GetCostsFo

; 95   : 		{
; 96   : 			if (eFromPlotRoute == NO_ROUTE)

	cmp	ebx, -1
	jne	SHORT $LN141@GetCostsFo

; 97   : 				eFromPlotRoute = ROUTE_ROAD;

	mov	DWORD PTR _eFromPlotRoute$217630[esp+40], 0
	mov	ebx, DWORD PTR _eFromPlotRoute$217630[esp+40]
$LN141@GetCostsFo:

; 98   : 			if (eToPlotRoute == NO_ROUTE)

	cmp	esi, -1
	jne	SHORT $LN142@GetCostsFo

; 99   : 				eToPlotRoute = ROUTE_ROAD;

	xor	esi, esi
$LN142@GetCostsFo:

; 100  : 		}
; 101  : 		CvRouteInfo* pFromRouteInfo = GC.getRouteInfo(eFromPlotRoute);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ebx, eax

; 102  : #else
; 103  : 		CvRouteInfo* pFromRouteInfo = GC.getRouteInfo(pFromPlot->getRouteType());
; 104  : #endif
; 105  : 		CvAssert(pFromRouteInfo != NULL);
; 106  : 
; 107  : 		int iFromMovementCost = (pFromRouteInfo != NULL)? pFromRouteInfo->getMovementCost() : 0;

	test	ebx, ebx
	je	SHORT $LN39@GetCostsFo
	mov	ecx, ebx
	call	?getMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getMovementCost

; 108  : 		int iFromFlatMovementCost = (pFromRouteInfo != NULL)? pFromRouteInfo->getFlatMovementCost() : 0;

	mov	ecx, ebx
	mov	DWORD PTR _iFromMovementCost$217636[esp+44], eax
	call	?getFlatMovementCost@CvRouteInfo@@QBEHXZ ; CvRouteInfo::getFlatMovementCost
	mov	ebx, eax
	jmp	SHORT $LN42@GetCostsFo
$LN39@GetCostsFo:

; 102  : #else
; 103  : 		CvRouteInfo* pFromRouteInfo = GC.getRouteInfo(pFromPlot->getRouteType());
; 104  : #endif
; 105  : 		CvAssert(pFromRouteInfo != NULL);
; 106  : 
; 107  : 		int iFromMovementCost = (pFromRouteInfo != NULL)? pFromRouteInfo->getMovementCost() : 0;

	mov	DWORD PTR _iFromMovementCost$217636[esp+44], 0

; 108  : 		int iFromFlatMovementCost = (pFromRouteInfo != NULL)? pFromRouteInfo->getFlatMovementCost() : 0;

	xor	ebx, ebx
$LN42@GetCostsFo:

; 109  : 
; 110  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 111  : 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(eToPlotRoute);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ebp, eax

; 112  : #else
; 113  : 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(pToPlot->getRouteType());
; 114  : #endif
; 115  : 		CvAssert(pRouteInfo != NULL);
; 116  : 
; 117  : 		int iMovementCost = (pRouteInfo != NULL)? pRouteInfo->getMovementCost() : 0;

	test	ebp, ebp
	je	SHORT $LN43@GetCostsFo
	mov	ecx, ebp
	call	?getMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getMovementCost

; 118  : 		int iFlatMovementCost = (pRouteInfo != NULL)? pRouteInfo->getFlatMovementCost() : 0;

	mov	ecx, ebp
	mov	DWORD PTR _iMovementCost$217639[esp+40], eax
	call	?getFlatMovementCost@CvRouteInfo@@QBEHXZ ; CvRouteInfo::getFlatMovementCost
	mov	ebp, eax
	jmp	SHORT $LN46@GetCostsFo
$LN43@GetCostsFo:

; 112  : #else
; 113  : 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(pToPlot->getRouteType());
; 114  : #endif
; 115  : 		CvAssert(pRouteInfo != NULL);
; 116  : 
; 117  : 		int iMovementCost = (pRouteInfo != NULL)? pRouteInfo->getMovementCost() : 0;

	mov	DWORD PTR _iMovementCost$217639[esp+40], 0

; 118  : 		int iFlatMovementCost = (pRouteInfo != NULL)? pRouteInfo->getFlatMovementCost() : 0;

	xor	ebp, ebp
$LN46@GetCostsFo:

; 119  : 
; 120  : #ifdef NQM_FAST_COMP
; 121  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 122  : 		iRouteCost = MAX(iFromMovementCost + kUnitTeam.getRouteChange(eFromPlotRoute), iMovementCost + kUnitTeam.getRouteChange(eToPlotRoute));
; 123  : #else
; 124  : 		iRouteCost = MAX(iFromMovementCost + kUnitTeam.getRouteChange(pFromPlot->getRouteType()), iMovementCost + kUnitTeam.getRouteChange(pToPlot->getRouteType()));
; 125  : #endif
; 126  : 		iRouteFlatCost = MAX(iFromFlatMovementCost * iBaseMoves, iFlatMovementCost * iBaseMoves);
; 127  : #else
; 128  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 129  : 		iRouteCost = std::max(iFromMovementCost + kUnitTeam.getRouteChange(eFromPlotRoute), iMovementCost + kUnitTeam.getRouteChange(eToPlotRoute));

	mov	ecx, DWORD PTR _kUnitTeam$[esp+44]
	push	esi
	call	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ; CvTeam::getRouteChange
	mov	edx, DWORD PTR _eFromPlotRoute$217630[esp+40]
	mov	ecx, DWORD PTR _kUnitTeam$[esp+44]
	mov	esi, eax
	add	esi, DWORD PTR _iMovementCost$217639[esp+40]
	push	edx
	mov	DWORD PTR $T218646[esp+44], esi
	call	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ; CvTeam::getRouteChange
	add	eax, DWORD PTR _iFromMovementCost$217636[esp+44]
	mov	DWORD PTR $T218647[esp+40], eax
	cmp	eax, esi
	lea	eax, DWORD PTR $T218646[esp+40]
	jl	SHORT $LN121@GetCostsFo
	lea	eax, DWORD PTR $T218647[esp+40]
$LN121@GetCostsFo:
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _iRouteCost$[esp+40]
	mov	DWORD PTR [esi], eax

; 130  : #else
; 131  : 		iRouteCost = std::max(iFromMovementCost + kUnitTeam.getRouteChange(pFromPlot->getRouteType()), iMovementCost + kUnitTeam.getRouteChange(pToPlot->getRouteType()));
; 132  : #endif
; 133  : 		iRouteFlatCost = std::max(iFromFlatMovementCost * iBaseMoves, iFlatMovementCost * iBaseMoves);

	mov	eax, DWORD PTR _iBaseMoves$[esp+40]
	imul	ebp, eax
	imul	ebx, eax
	cmp	ebx, ebp
	mov	DWORD PTR $T218648[esp+40], ebp
	mov	DWORD PTR $T218649[esp+40], ebx
	lea	eax, DWORD PTR $T218648[esp+40]
	jl	SHORT $LN125@GetCostsFo
	lea	eax, DWORD PTR $T218649[esp+40]
$LN125@GetCostsFo:
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR _iRouteFlatCost$[esp+40]
	mov	ebx, DWORD PTR _pUnit$[esp+40]
	mov	DWORD PTR [ebp], ecx
	jmp	SHORT $LN3@GetCostsFo
$LN11@GetCostsFo:

; 134  : #endif
; 135  : 	}
; 136  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 137  : 	else if (pTraits->IsMoveFriendlyWoodsAsRoad() && pUnit->getOwner() == pToPlot->getOwner() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE))

	mov	edx, DWORD PTR _pTraits$[esp+44]
	cmp	BYTE PTR [edx+325], 0
	je	SHORT $LN5@GetCostsFo
	movsx	eax, BYTE PTR [edi+4]
	cmp	DWORD PTR [ebx+40], eax
	jne	SHORT $LN5@GetCostsFo
	mov	eax, DWORD PTR _eFeature$[esp+44]
	cmp	eax, 5
	je	SHORT $LN4@GetCostsFo
	cmp	eax, 1
	jne	SHORT $LN5@GetCostsFo
$LN4@GetCostsFo:

; 138  : 	{
; 139  : 		CvRouteInfo* pRoadInfo = GC.getRouteInfo(ROUTE_ROAD);

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 140  : 		iRouteCost = pRoadInfo->getMovementCost() + kUnitTeam.getRouteChange(ROUTE_ROAD);

	mov	ecx, DWORD PTR _kUnitTeam$[esp+44]
	push	0
	mov	ebp, eax
	call	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ; CvTeam::getRouteChange
	mov	ecx, ebp
	mov	DWORD PTR tv671[esp+40], eax
	call	?getMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getMovementCost
	mov	ecx, DWORD PTR tv671[esp+40]
	mov	esi, DWORD PTR _iRouteCost$[esp+40]
	add	ecx, eax
	mov	DWORD PTR [esi], ecx

; 141  : #else
; 142  : 	else if(pUnit->getOwner() == pToPlot->getOwner() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE) && pTraits->IsMoveFriendlyWoodsAsRoad())
; 143  : 	{
; 144  : 		CvRouteInfo* pRoadInfo = GC.getRouteInfo(ROUTE_ROAD);
; 145  : 		iRouteCost = pRoadInfo->getMovementCost();
; 146  : #endif
; 147  : 		iRouteFlatCost = pRoadInfo->getFlatMovementCost() * iBaseMoves;

	mov	ecx, ebp
	call	?getFlatMovementCost@CvRouteInfo@@QBEHXZ ; CvRouteInfo::getFlatMovementCost
	imul	eax, DWORD PTR _iBaseMoves$[esp+40]
	mov	ebp, DWORD PTR _iRouteFlatCost$[esp+40]
	mov	DWORD PTR [ebp], eax

; 148  : 	}
; 149  : 	else

	jmp	SHORT $LN3@GetCostsFo
$LN5@GetCostsFo:

; 150  : 	{
; 151  : 		iRouteCost = INT_MAX;

	mov	esi, DWORD PTR _iRouteCost$[esp+40]

; 152  : 		iRouteFlatCost = INT_MAX;

	mov	ebp, DWORD PTR _iRouteFlatCost$[esp+40]
	mov	DWORD PTR [esi], 2147483647		; 7fffffffH
	mov	DWORD PTR [ebp], 2147483647		; 7fffffffH
$LN3@GetCostsFo:

; 153  : 	}
; 154  : 
; 155  : 	if(pUnit->getDomainType() == DOMAIN_SEA && pToPlot->IsAllowsSailLand()){ // from Izy

	mov	ecx, ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN2@GetCostsFo
	mov	ecx, edi
	call	?IsAllowsSailLand@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsSailLand
	test	al, al
	je	SHORT $LN2@GetCostsFo

; 156  : 			iRegularCost = iMoveDenominator*3;

	mov	eax, DWORD PTR _iMoveDenominator$[esp+44]
	mov	ecx, DWORD PTR _iRegularCost$[esp+40]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [ecx], eax

; 157  : 			iRouteCost = iRegularCost;

	mov	DWORD PTR [esi], eax

; 158  : 			iRouteFlatCost = iRegularCost;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [ebp], ecx
$LN2@GetCostsFo:

; 159  : 		}
; 160  : 	if(pUnit->getDomainType() == DOMAIN_LAND && pToPlot->IsAllowsSailLand() && (!bIgnoreTerrainCost)) { 

	mov	ecx, ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN1@GetCostsFo
	mov	ecx, edi
	call	?IsAllowsSailLand@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsSailLand
	test	al, al
	je	SHORT $LN1@GetCostsFo
	cmp	BYTE PTR _bIgnoreTerrainCost$[esp+44], 0
	jne	SHORT $LN1@GetCostsFo

; 161  : 			iRegularCost = iMoveDenominator;

	mov	ecx, DWORD PTR _iMoveDenominator$[esp+44]
	mov	eax, DWORD PTR _iRegularCost$[esp+40]
	mov	DWORD PTR [eax], ecx

; 162  : 			iRouteCost = iRegularCost;

	mov	DWORD PTR [esi], ecx

; 163  : 			iRouteFlatCost = iRegularCost;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ebp], edx
$LN1@GetCostsFo:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 164  : 		}
; 165  : 
; 166  : 	// NQMP GJS - Great Wall fix
; 167  : 	/*
; 168  : 	TeamTypes eTeam = pToPlot->getTeam();
; 169  : 	if(eTeam != NO_TEAM)
; 170  : 	{
; 171  : 		CvTeam* pPlotTeam = &GET_TEAM(eTeam);
; 172  : 		CvPlayer* pPlotPlayer = &GET_PLAYER(pToPlot->getOwner());
; 173  : 
; 174  : 		// Great Wall increases movement cost by 1
; 175  : 		if(pPlotTeam->isBorderObstacle() || pPlotPlayer->isBorderObstacle())
; 176  : 		{
; 177  : 			if(!pToPlot->isWater() && pUnit->getDomainType() == DOMAIN_LAND)
; 178  : 			{
; 179  : 				// Don't apply penalty to OUR team or teams we've given open borders to
; 180  : 				if(eUnitTeam != eTeam && !pPlotTeam->IsAllowsOpenBordersToTeam(eUnitTeam))
; 181  : 				{
; 182  : 					iRegularCost += iMoveDenominator;
; 183  : 				}
; 184  : 			}
; 185  : 		}
; 186  : 	}
; 187  : 	*/
; 188  : }

	add	esp, 28					; 0000001cH
	ret	0
?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ENDP ; CvUnitMovement::GetCostsForMove
_TEXT	ENDS
PUBLIC	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?canMoveAllTerrain@CvUnit@@QBE_NXZ:PROC		; CvUnit::canMoveAllTerrain
EXTRN	?IsHoveringUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsHoveringUnit
EXTRN	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForLocation
EXTRN	?IsAllowsWalkWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsAllowsWalkWater
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z PROC ; CvUnitMovement::ConsumesAllMoves, COMDAT

; 251  : {

	push	esi

; 252  : 	if(!pToPlot->isRevealed(pUnit->getTeam()) && pUnit->isHuman())

	mov	esi, DWORD PTR _pUnit$[esp]
	push	edi
	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	edi, ecx
	mov	ecx, eax
	sub	ecx, edi
	mov	edi, DWORD PTR _pToPlot$[esp+4]
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [edi+edx*4+8]
	jne	SHORT $LN9@ConsumesAl
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN9@ConsumesAl
	pop	edi

; 253  : 	{
; 254  : 		return true;

	mov	al, 1
	pop	esi

; 316  : }

	ret	0
$LN9@ConsumesAl:

; 255  : 	}
; 256  : 
; 257  : #ifndef AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK
; 258  : 	if (!pUnit->isEmbarked() && (pToPlot->IsAllowsWalkWater() || pFromPlot->IsAllowsWalkWater()))

	cmp	BYTE PTR [esi+1652], 0
	push	ebp
	mov	ebp, DWORD PTR _pFromPlot$[esp+8]
	jne	SHORT $LN8@ConsumesAl
	mov	ecx, edi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN7@ConsumesAl
	mov	ecx, ebp
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	je	SHORT $LN8@ConsumesAl
$LN7@ConsumesAl:
	pop	ebp
	pop	edi

; 259  : 	{
; 260  : 		return false;

	xor	al, al
	pop	esi

; 316  : }

	ret	0
$LN8@ConsumesAl:

; 261  : 	}
; 262  : #endif
; 263  : 
; 264  : 	if(!pFromPlot->isValidDomainForLocation(*pUnit))

	push	esi
	mov	ecx, ebp
	call	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
	test	al, al
	jne	SHORT $LN5@ConsumesAl

; 265  : 	{
; 266  : 		// If we are a land unit that can embark, then do further tests.
; 267  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 268  : 		if (pUnit->getDomainType() != DOMAIN_LAND || pUnit->canMoveAllTerrain() || !pUnit->CanEverEmbark())
; 269  : #else
; 270  : 		if(pUnit->getDomainType() != DOMAIN_LAND || pUnit->IsHoveringUnit() || pUnit->canMoveAllTerrain() || !pUnit->CanEverEmbark())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@ConsumesAl
	mov	ecx, esi
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	test	al, al
	jne	SHORT $LN4@ConsumesAl
	mov	ecx, esi
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN4@ConsumesAl
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	jne	SHORT $LN5@ConsumesAl
$LN4@ConsumesAl:
	pop	ebp
	pop	edi

; 271  : #endif
; 272  : 			return true;

	mov	al, 1
	pop	esi

; 316  : }

	ret	0
$LN5@ConsumesAl:
	push	ebx

; 273  : 	}
; 274  : 
; 275  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 276  : 	bool bToPlotNeedEmbark = !pToPlot->IsAllowsWalkWater();
; 277  : 	bool bFromPlotNeedEmbark = !pFromPlot->IsAllowsWalkWater();
; 278  : 	if (pUnit->IsHoveringUnit())
; 279  : 	{
; 280  : 		bToPlotNeedEmbark = bToPlotNeedEmbark && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 281  : 		bFromPlotNeedEmbark = bFromPlotNeedEmbark && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 282  : 	}
; 283  : 	else
; 284  : 	{
; 285  : 		bToPlotNeedEmbark = bToPlotNeedEmbark && pToPlot->isWater();
; 286  : 		bFromPlotNeedEmbark = bFromPlotNeedEmbark && pFromPlot->isWater();
; 287  : 	}
; 288  : 
; 289  : 	if (pUnit->CanEverEmbark() && bToPlotNeedEmbark != bFromPlotNeedEmbark)
; 290  : #elif defined(AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK)
; 291  : 	// if the unit can embark and we are transitioning from land to water or vice versa
; 292  : 	if ((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) != (pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater()) && pUnit->CanEverEmbark())
; 293  : #else
; 294  : 	if(pToPlot->isWater() != pFromPlot->isWater() && pUnit->CanEverEmbark())

	mov	bl, 3
	cmp	BYTE PTR [edi+5], bl
	sete	cl
	cmp	BYTE PTR [ebp+5], bl
	sete	dl
	cmp	cl, dl
	je	SHORT $LN1@ConsumesAl
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	SHORT $LN1@ConsumesAl

; 295  : #endif
; 296  : 	{
; 297  : 		// Is the unit from a civ that can disembark for just 1 MP?
; 298  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 299  : 		if (bFromPlotNeedEmbark && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 300  : #elif defined(AUI_UNIT_MOVEMENT_FIX_BAD_VIKING_DISEMBARK_PREVIEW)
; 301  : 		if (!pToPlot->isWater() && pFromPlot->isWater() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())

	cmp	BYTE PTR [edi+5], bl
	je	SHORT $LN2@ConsumesAl
	cmp	BYTE PTR [ebp+5], bl
	jne	SHORT $LN2@ConsumesAl
	mov	ecx, DWORD PTR [esi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+329], 0

; 302  : #else
; 303  : 		if(!pToPlot->isWater() && pFromPlot->isWater() && pUnit->isEmbarked() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 304  : #endif
; 305  : 		{
; 306  : 			return false;	// Then no, it does not.

	jne	SHORT $LN1@ConsumesAl
$LN2@ConsumesAl:

; 307  : 		}
; 308  : 
; 309  : 		if(!pUnit->canMoveAllTerrain())

	mov	ecx, esi
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN1@ConsumesAl
	pop	ebx
	pop	ebp
	pop	edi

; 310  : 		{
; 311  : 			return true;

	mov	al, 1
	pop	esi

; 316  : }

	ret	0
$LN1@ConsumesAl:
	pop	ebx
	pop	ebp
	pop	edi

; 312  : 		}
; 313  : 	}
; 314  : 
; 315  : 	return false;

	xor	al, al
	pop	esi

; 316  : }

	ret	0
?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ENDP ; CvUnitMovement::ConsumesAllMoves
_TEXT	ENDS
PUBLIC	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
EXTRN	?flatMovementCost@CvUnit@@QBE_NXZ:PROC		; CvUnit::flatMovementCost
EXTRN	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForAction
; Function compile flags: /Ogtpy
;	COMDAT ?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z PROC ; CvUnitMovement::CostsOnlyOne, COMDAT

; 320  : {

	push	esi

; 321  : 	if(!pToPlot->isValidDomainForAction(*pUnit))

	mov	esi, DWORD PTR _pUnit$[esp]
	push	edi
	mov	edi, DWORD PTR _pToPlot$[esp+4]
	push	esi
	mov	ecx, edi
	call	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
	test	al, al
	jne	SHORT $LN5@CostsOnlyO

; 322  : 	{
; 323  : 		// If we are a land unit that can embark, then do further tests.
; 324  : 		if(pUnit->getDomainType() != DOMAIN_LAND || pUnit->IsHoveringUnit() || pUnit->canMoveAllTerrain() || !pUnit->CanEverEmbark())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN2@CostsOnlyO
	mov	ecx, esi
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	test	al, al
	jne	SHORT $LN2@CostsOnlyO
	mov	ecx, esi
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN2@CostsOnlyO
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al

; 325  : 			return true;

	je	SHORT $LN2@CostsOnlyO
$LN5@CostsOnlyO:

; 326  : 	}
; 327  : 
; 328  : 	CvAssert(!pUnit->IsImmobile());
; 329  : 
; 330  : 	if(pUnit->flatMovementCost() || pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, esi
	call	?flatMovementCost@CvUnit@@QBE_NXZ	; CvUnit::flatMovementCost
	test	al, al
	jne	SHORT $LN2@CostsOnlyO
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN2@CostsOnlyO

; 333  : 	}
; 334  : 
; 335  : 	// Is the unit from a civ that can disembark for just 1 MP?
; 336  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 337  : 	bool bToPlotNeedEmbark = !pToPlot->IsAllowsWalkWater();
; 338  : 	bool bFromPlotNeedEmbark = !pFromPlot->IsAllowsWalkWater();
; 339  : 	if (pUnit->IsHoveringUnit())
; 340  : 	{
; 341  : 		bToPlotNeedEmbark = bToPlotNeedEmbark && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 342  : 		bFromPlotNeedEmbark = bFromPlotNeedEmbark && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 343  : 	}
; 344  : 	else
; 345  : 	{
; 346  : 		bToPlotNeedEmbark = bToPlotNeedEmbark && pToPlot->isWater();
; 347  : 		bFromPlotNeedEmbark = bFromPlotNeedEmbark && pFromPlot->isWater();
; 348  : 	}
; 349  : 
; 350  : 	if (pUnit->CanEverEmbark() && bFromPlotNeedEmbark && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 351  : #elif defined(AUI_UNIT_MOVEMENT_FIX_BAD_VIKING_DISEMBARK_PREVIEW)
; 352  : 	if (!pToPlot->isWater() && pFromPlot->isWater() && pUnit->CanEverEmbark() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())

	mov	al, 3
	cmp	BYTE PTR [edi+5], al
	je	SHORT $LN1@CostsOnlyO
	mov	ecx, DWORD PTR _pFromPlot$[esp+4]
	cmp	BYTE PTR [ecx+5], al
	jne	SHORT $LN1@CostsOnlyO
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	SHORT $LN1@CostsOnlyO
	mov	ecx, DWORD PTR [esi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+329], 0

; 353  : #else
; 354  : 	if(!pToPlot->isWater() && pFromPlot->isWater() && pUnit->isEmbarked() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 355  : #endif
; 356  : 	{
; 357  : 		return true;

	jne	SHORT $LN2@CostsOnlyO
$LN1@CostsOnlyO:
	pop	edi

; 358  : 	}
; 359  : 
; 360  : 	return false;

	xor	al, al
	pop	esi

; 361  : }

	ret	0
$LN2@CostsOnlyO:
	pop	edi

; 331  : 	{
; 332  : 		return true;

	mov	al, 1
	pop	esi

; 361  : }

	ret	0
?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ENDP ; CvUnitMovement::CostsOnlyOne
_TEXT	ENDS
PUBLIC	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?IsIgnoreZOC@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsIgnoreZOC
; Function compile flags: /Ogtpy
;	COMDAT ?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z
_TEXT	SEGMENT
_bIsVisibleEnemyUnit$217736 = -37			; size = 1
_iToPlotX$217732 = -36					; size = 4
_iToPlotY$217733 = -32					; size = 4
_pAdjUnitNode$217728 = -28				; size = 4
_iDirection0$217738 = -24				; size = 4
_iFromPlotY$217731 = -20				; size = 4
_iFromPlotX$217730 = -16				; size = 4
_unit_team_type$217734 = -12				; size = 4
_kUnitTeam$217737 = -8					; size = 4
_unit_domain_type$217735 = -4				; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z PROC ; CvUnitMovement::IsSlowedByZOC, COMDAT

; 365  : {

	sub	esp, 40					; 00000028H
	push	ebp

; 366  : 	if (pUnit->IsIgnoreZOC() || CostsOnlyOne(pUnit, pFromPlot, pToPlot))

	mov	ebp, DWORD PTR _pUnit$[esp+40]
	push	esi
	push	edi
	mov	ecx, ebp
	call	?IsIgnoreZOC@CvUnit@@QBE_NXZ		; CvUnit::IsIgnoreZOC
	test	al, al
	jne	$LN33@IsSlowedBy
	mov	esi, DWORD PTR _pToPlot$[esp+48]
	mov	edi, DWORD PTR _pFromPlot$[esp+48]
	push	esi
	push	edi
	push	ebp
	call	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
	add	esp, 12					; 0000000cH
	test	al, al
	jne	$LN33@IsSlowedBy

; 369  : 	}
; 370  : 
; 371  : 	// Zone of Control
; 372  : 	if(GC.getZONE_OF_CONTROL_ENABLED() > 0)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7360, 0
	push	ebx
	jle	$LN29@IsSlowedBy

; 373  : 	{
; 374  : 		IDInfo* pAdjUnitNode;
; 375  : 		CvUnit* pLoopUnit;
; 376  : 
; 377  : 		int iFromPlotX = pFromPlot->getX();

	movsx	eax, WORD PTR [edi]

; 378  : 		int iFromPlotY = pFromPlot->getY();

	movsx	ecx, WORD PTR [edi+2]

; 379  : 		int iToPlotX = pToPlot->getX();

	movsx	edx, WORD PTR [esi]
	mov	DWORD PTR _iFromPlotX$217730[esp+56], eax

; 380  : 		int iToPlotY = pToPlot->getY();

	movsx	eax, WORD PTR [esi+2]
	mov	DWORD PTR _iFromPlotY$217731[esp+56], ecx

; 381  : 		TeamTypes unit_team_type     = pUnit->getTeam();

	mov	ecx, ebp
	mov	DWORD PTR _iToPlotX$217732[esp+56], edx
	mov	DWORD PTR _iToPlotY$217733[esp+56], eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edi, eax

; 382  : 		DomainTypes unit_domain_type = pUnit->getDomainType();

	mov	ecx, ebp
	mov	DWORD PTR _unit_team_type$217734[esp+56], edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 383  : 		bool bIsVisibleEnemyUnit     = pToPlot->isVisibleEnemyUnit(pUnit);

	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _unit_domain_type$217735[esp+60], eax
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	mov	BYTE PTR _bIsVisibleEnemyUnit$217736[esp+56], al

; 384  : 		CvTeam& kUnitTeam = GET_TEAM(unit_team_type);

	mov	eax, edi
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$217737[esp+56], eax

; 385  : 
; 386  : 		for(int iDirection0 = 0; iDirection0 < NUM_DIRECTION_TYPES; iDirection0++)

	xor	eax, eax
	mov	DWORD PTR _iDirection0$217738[esp+56], eax
	npad	4
$LL106@IsSlowedBy:

; 387  : 		{
; 388  : 			CvPlot* pAdjPlot = plotDirection(iFromPlotX, iFromPlotY, ((DirectionTypes)iDirection0));

	mov	ecx, DWORD PTR _iFromPlotY$217731[esp+56]
	mov	edx, DWORD PTR _iFromPlotX$217730[esp+56]
	push	eax
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 389  : 			if(NULL != pAdjPlot)

	test	ebx, ebx
	je	$LN30@IsSlowedBy

; 390  : 			{
; 391  : 				// check city zone of control
; 392  : #ifdef AUI_UNIT_MOVEMENT_FIX_RADAR_ZOC
; 393  : 				if (pAdjPlot->isEnemyCity(*pUnit) && (pAdjPlot->isRevealed(pUnit->getTeam()) || pUnit->plot() == pFromPlot))

	push	ebp
	mov	ecx, ebx
	call	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z	; CvPlot::isEnemyCity
	test	al, al
	je	SHORT $LN23@IsSlowedBy
	mov	ecx, ebp
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	esi, ecx
	mov	ecx, eax
	sub	ecx, esi
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [ebx+edx*4+8]
	jne	SHORT $LN26@IsSlowedBy
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pFromPlot$[esp+52]
	jne	SHORT $LN23@IsSlowedBy
$LN26@IsSlowedBy:

; 394  : #else
; 395  : 				if(pAdjPlot->isEnemyCity(*pUnit))
; 396  : #endif
; 397  : 				{
; 398  : 					// Loop through plots adjacent to the enemy city and see if it's the same as our unit's Destination Plot
; 399  : 					for(int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)

	movsx	edi, WORD PTR [ebx+2]
	movsx	ebp, WORD PTR [ebx]
	xor	esi, esi
$LL25@IsSlowedBy:

; 400  : 					{
; 401  : 						CvPlot* pEnemyAdjPlot = plotDirection(pAdjPlot->getX(), pAdjPlot->getY(), ((DirectionTypes)iDirection));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 402  : 						if(NULL != pEnemyAdjPlot)

	test	eax, eax
	je	SHORT $LN24@IsSlowedBy

; 403  : 						{
; 404  : 							// Destination adjacent to enemy city?
; 405  : 							if(pEnemyAdjPlot->getX() == iToPlotX && pEnemyAdjPlot->getY() == iToPlotY)

	movsx	ecx, WORD PTR [eax]
	cmp	ecx, DWORD PTR _iToPlotX$217732[esp+56]
	jne	SHORT $LN24@IsSlowedBy
	movsx	edx, WORD PTR [eax+2]
	cmp	edx, DWORD PTR _iToPlotY$217733[esp+56]
	je	$LN94@IsSlowedBy
$LN24@IsSlowedBy:

; 394  : #else
; 395  : 				if(pAdjPlot->isEnemyCity(*pUnit))
; 396  : #endif
; 397  : 				{
; 398  : 					// Loop through plots adjacent to the enemy city and see if it's the same as our unit's Destination Plot
; 399  : 					for(int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL25@IsSlowedBy
	mov	ebp, DWORD PTR _pUnit$[esp+52]
$LN23@IsSlowedBy:

; 406  : 							{
; 407  : 								return true;
; 408  : 							}
; 409  : 						}
; 410  : 					}
; 411  : 				}
; 412  : 
; 413  : #ifdef AUI_UNIT_MOVEMENT_FIX_RADAR_ZOC
; 414  : 				if (!pAdjPlot->isVisible(pUnit->getTeam()) && pUnit->plot() != pFromPlot)

	mov	ecx, ebp
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, -1
	je	SHORT $LN98@IsSlowedBy
	mov	ecx, DWORD PTR [ebx+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN20@IsSlowedBy
$LN98@IsSlowedBy:
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pFromPlot$[esp+52]
	jne	$LN30@IsSlowedBy
$LN20@IsSlowedBy:

; 415  : 					continue;
; 416  : #endif
; 417  : 				pAdjUnitNode = pAdjPlot->headUnitNode();

	mov	ecx, ebx
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	edi, eax

; 418  : 				// Loop through all units to see if there's an enemy unit here
; 419  : 				while(pAdjUnitNode != NULL)

	test	edi, edi
	je	$LN30@IsSlowedBy
	jmp	SHORT $LN19@IsSlowedBy
$LL101@IsSlowedBy:
	mov	edi, DWORD PTR _pAdjUnitNode$217728[esp+56]
$LN19@IsSlowedBy:

; 420  : 				{
; 421  : 					if((pAdjUnitNode->eOwner >= 0) && pAdjUnitNode->eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jl	SHORT $LN17@IsSlowedBy
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN17@IsSlowedBy

; 422  : 					{
; 423  : 						pLoopUnit = (GET_PLAYER(pAdjUnitNode->eOwner).getUnit(pAdjUnitNode->iID));

	mov	edx, DWORD PTR [edi+4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax

; 424  : 					}
; 425  : 					else

	jmp	SHORT $LN16@IsSlowedBy
$LN17@IsSlowedBy:

; 426  : 					{
; 427  : 						pLoopUnit = NULL;

	xor	esi, esi
$LN16@IsSlowedBy:

; 428  : 					}
; 429  : 
; 430  : 					pAdjUnitNode = pAdjPlot->nextUnitNode(pAdjUnitNode);

	push	edi
	mov	ecx, ebx
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pAdjUnitNode$217728[esp+56], eax

; 431  : 
; 432  : 					if(!pLoopUnit) continue;

	test	esi, esi
	je	$LN103@IsSlowedBy

; 433  : 
; 434  : #ifdef AUI_UNIT_MOVEMENT_FIX_DELAYED_DEATH_UNITS_GENERATE_ZOC
; 435  : 					if (pLoopUnit->isDelayedDeath())
; 436  : 						continue;
; 437  : #endif
; 438  : 
; 439  : 					TeamTypes unit_loop_team_type = pLoopUnit->getTeam();

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam

; 440  : 
; 441  : 					if(pLoopUnit->isInvisible(unit_team_type,false)) continue;

	push	1
	mov	edi, eax
	mov	eax, DWORD PTR _unit_team_type$217734[esp+60]
	push	0
	push	eax
	mov	ecx, esi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	$LN103@IsSlowedBy

; 442  : 
; 443  : 					// Combat unit?
; 444  : 					if(!pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [esi+1044], 0
	jle	SHORT $LN103@IsSlowedBy

; 445  : 					{
; 446  : 						continue;
; 447  : 					}
; 448  : 
; 449  : 					// At war with this unit's team?
; 450  : 					if(unit_loop_team_type == BARBARIAN_TEAM || kUnitTeam.isAtWar(unit_loop_team_type))

	cmp	edi, 63					; 0000003fH
	je	SHORT $LN11@IsSlowedBy
	mov	ecx, DWORD PTR _kUnitTeam$217737[esp+56]
	push	edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN103@IsSlowedBy
$LN11@IsSlowedBy:

; 451  : 					{
; 452  : 
; 453  : 						// Same Domain?
; 454  : 
; 455  : 						DomainTypes loop_unit_domain_type = pLoopUnit->getDomainType();

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 456  : 						if(loop_unit_domain_type != unit_domain_type)

	mov	ecx, DWORD PTR _unit_domain_type$217735[esp+56]
	cmp	eax, ecx
	je	SHORT $LN8@IsSlowedBy

; 457  : 						{
; 458  : 							// this is valid
; 459  : 							if(loop_unit_domain_type == DOMAIN_SEA && unit_domain_type)

	test	eax, eax
	jne	SHORT $LN103@IsSlowedBy
	test	ecx, ecx

; 460  : 							{
; 461  : 								// continue on
; 462  : 							}
; 463  : 							else
; 464  : 							{
; 465  : 								continue;

	je	SHORT $LN103@IsSlowedBy
$LN8@IsSlowedBy:

; 466  : 							}
; 467  : 						}
; 468  : 
; 469  : 						// Embarked?
; 470  : 						if(unit_domain_type == DOMAIN_LAND && pLoopUnit->isEmbarked())

	cmp	ecx, 2
	jne	SHORT $LN7@IsSlowedBy
	cmp	BYTE PTR [esi+1652], 0
	jne	SHORT $LN103@IsSlowedBy
$LN7@IsSlowedBy:

; 471  : 						{
; 472  : 							continue;
; 473  : 						}
; 474  : 
; 475  : 						// Loop through plots adjacent to the enemy unit and see if it's the same as our unit's Destination Plot
; 476  : 						for(int iDirection2 = 0; iDirection2 < NUM_DIRECTION_TYPES; iDirection2++)

	movsx	edi, WORD PTR [ebx+2]
	movsx	ebp, WORD PTR [ebx]
	xor	esi, esi
$LL6@IsSlowedBy:

; 477  : 						{
; 478  : 							CvPlot* pEnemyAdjPlot = plotDirection(pAdjPlot->getX(), pAdjPlot->getY(), ((DirectionTypes)iDirection2));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 479  : 							if(!pEnemyAdjPlot)

	test	eax, eax
	je	SHORT $LN5@IsSlowedBy

; 480  : 							{
; 481  : 								continue;
; 482  : 							}
; 483  : 
; 484  : 							// Don't check Enemy Unit's plot
; 485  : 							if(!bIsVisibleEnemyUnit)

	cmp	BYTE PTR _bIsVisibleEnemyUnit$217736[esp+56], 0
	jne	SHORT $LN5@IsSlowedBy

; 486  : 							{
; 487  : 								// Destination adjacent to enemy unit?
; 488  : 								if(pEnemyAdjPlot->getX() == iToPlotX && pEnemyAdjPlot->getY() == iToPlotY)

	movsx	ecx, WORD PTR [eax]
	cmp	ecx, DWORD PTR _iToPlotX$217732[esp+56]
	jne	SHORT $LN5@IsSlowedBy
	movsx	edx, WORD PTR [eax+2]
	cmp	edx, DWORD PTR _iToPlotY$217733[esp+56]
	je	SHORT $LN94@IsSlowedBy
$LN5@IsSlowedBy:

; 471  : 						{
; 472  : 							continue;
; 473  : 						}
; 474  : 
; 475  : 						// Loop through plots adjacent to the enemy unit and see if it's the same as our unit's Destination Plot
; 476  : 						for(int iDirection2 = 0; iDirection2 < NUM_DIRECTION_TYPES; iDirection2++)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL6@IsSlowedBy
	mov	ebp, DWORD PTR _pUnit$[esp+52]
$LN103@IsSlowedBy:

; 418  : 				// Loop through all units to see if there's an enemy unit here
; 419  : 				while(pAdjUnitNode != NULL)

	cmp	DWORD PTR _pAdjUnitNode$217728[esp+56], 0
	jne	$LL101@IsSlowedBy
$LN30@IsSlowedBy:

; 385  : 
; 386  : 		for(int iDirection0 = 0; iDirection0 < NUM_DIRECTION_TYPES; iDirection0++)

	mov	eax, DWORD PTR _iDirection0$217738[esp+56]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iDirection0$217738[esp+56], eax
	jl	$LL106@IsSlowedBy
$LN29@IsSlowedBy:
	pop	ebx
	pop	edi
	pop	esi

; 491  : 								}
; 492  : 							}
; 493  : 						}
; 494  : 					}
; 495  : 				}
; 496  : 			}
; 497  : 		}
; 498  : 	}
; 499  : 	return false;

	xor	al, al
	pop	ebp

; 500  : }

	add	esp, 40					; 00000028H
	ret	0
$LN94@IsSlowedBy:
	pop	ebx
	pop	edi
	pop	esi

; 489  : 								{
; 490  : 									return true;

	mov	al, 1
	pop	ebp

; 500  : }

	add	esp, 40					; 00000028H
	ret	0
$LN33@IsSlowedBy:
	pop	edi
	pop	esi

; 367  : 	{
; 368  : 		return false;

	xor	al, al
	pop	ebp

; 500  : }

	add	esp, 40					; 00000028H
	ret	0
?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ENDP ; CvUnitMovement::IsSlowedByZOC
_TEXT	ENDS
PUBLIC	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z
_TEXT	SEGMENT
_iRouteFlatCost$ = -16					; size = 4
_iRouteCost$ = -12					; size = 4
_iRegularCost$ = -8					; size = 4
$T219036 = -4						; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
_iBaseMoves$ = 20					; size = 4
_iMaxMoves$ = 24					; size = 4
_iMovesRemaining$ = 28					; size = 4
?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z PROC ; CvUnitMovement::MovementCost, COMDAT

; 192  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 193  : 	int iRegularCost;
; 194  : 	int iRouteCost;
; 195  : 	int iRouteFlatCost;
; 196  : 
; 197  : 	CvAssertMsg(pToPlot->getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 198  : 
; 199  : 	if(ConsumesAllMoves(pUnit, pFromPlot, pToPlot))

	mov	ebx, DWORD PTR _pUnit$[esp+16]
	push	esi
	mov	esi, DWORD PTR _pToPlot$[esp+20]
	push	edi
	mov	edi, DWORD PTR _pFromPlot$[esp+24]
	push	esi
	push	edi
	push	ebx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN9@MovementCo
$LN26@MovementCo:

; 200  : 	{
; 201  : 		if (iMovesRemaining > 0)

	mov	eax, DWORD PTR _iMovesRemaining$[esp+24]
	test	eax, eax

; 202  : 			return iMovesRemaining;

	jg	$LN10@MovementCo

; 203  : 		else
; 204  : 			return iMaxMoves;

	mov	eax, DWORD PTR _iMaxMoves$[esp+24]
	pop	edi
	pop	esi
	pop	ebx

; 221  : }

	add	esp, 16					; 00000010H
	ret	0
$LN9@MovementCo:

; 205  : 	}
; 206  : 	else if(CostsOnlyOne(pUnit, pFromPlot, pToPlot))

	push	esi
	push	edi
	push	ebx
	call	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN5@MovementCo

; 207  : 	{
; 208  : 		return GC.getMOVE_DENOMINATOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	pop	edi
	pop	esi
	pop	ebx

; 221  : }

	add	esp, 16					; 00000010H
	ret	0
$LN5@MovementCo:

; 209  : 	}
; 210  : 	else if(IsSlowedByZOC(pUnit, pFromPlot, pToPlot))

	push	esi
	push	edi
	push	ebx
	call	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
	add	esp, 12					; 0000000cH
	test	al, al

; 211  : 	{
; 212  : 		if (iMovesRemaining > 0)
; 213  : 			return iMovesRemaining;
; 214  : 		else
; 215  : 			return iMaxMoves;

	jne	SHORT $LN26@MovementCo

; 216  : 	}
; 217  : 
; 218  : 	GetCostsForMove(pUnit, pFromPlot, pToPlot, iBaseMoves, iRegularCost, iRouteCost, iRouteFlatCost);

	lea	eax, DWORD PTR _iRouteFlatCost$[esp+28]
	push	eax
	mov	eax, DWORD PTR _iBaseMoves$[esp+28]
	lea	ecx, DWORD PTR _iRouteCost$[esp+32]
	push	ecx
	lea	edx, DWORD PTR _iRegularCost$[esp+36]
	push	edx
	push	eax
	push	esi
	push	edi
	push	ebx
	call	?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ; CvUnitMovement::GetCostsForMove

; 219  : 
; 220  : 	return std::max(1, std::min(iRegularCost, std::min(iRouteCost, iRouteFlatCost)));

	mov	ecx, DWORD PTR _iRouteFlatCost$[esp+56]
	add	esp, 28					; 0000001cH
	cmp	ecx, DWORD PTR _iRouteCost$[esp+28]
	mov	DWORD PTR $T219036[esp+28], 1
	lea	eax, DWORD PTR _iRouteFlatCost$[esp+28]
	jl	SHORT $LN17@MovementCo
	lea	eax, DWORD PTR _iRouteCost$[esp+28]
$LN17@MovementCo:
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _iRegularCost$[esp+28]
	jl	SHORT $LN21@MovementCo
	lea	eax, DWORD PTR _iRegularCost$[esp+28]
$LN21@MovementCo:
	cmp	DWORD PTR [eax], 1
	jg	SHORT $LN25@MovementCo
	lea	eax, DWORD PTR $T219036[esp+28]
$LN25@MovementCo:
	mov	eax, DWORD PTR [eax]
$LN10@MovementCo:
	pop	edi
	pop	esi
	pop	ebx

; 221  : }

	add	esp, 16					; 00000010H
	ret	0
?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ENDP ; CvUnitMovement::MovementCost
_TEXT	ENDS
PUBLIC	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
; Function compile flags: /Ogtpy
;	COMDAT ?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z
_TEXT	SEGMENT
_iRouteFlatCost$ = -16					; size = 4
_iRouteCost$ = -12					; size = 4
_iRegularCost$ = -8					; size = 4
$T219072 = -4						; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
_iBaseMoves$ = 20					; size = 4
_iMaxMoves$ = 24					; size = 4
_iMovesRemaining$ = 28					; size = 4
?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z PROC ; CvUnitMovement::MovementCostNoZOC, COMDAT

; 225  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 226  : 	int iRegularCost;
; 227  : 	int iRouteCost;
; 228  : 	int iRouteFlatCost;
; 229  : 
; 230  : 	CvAssertMsg(pToPlot->getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 231  : 
; 232  : 	if(ConsumesAllMoves(pUnit, pFromPlot, pToPlot))

	mov	ebx, DWORD PTR _pUnit$[esp+16]
	push	esi
	mov	esi, DWORD PTR _pToPlot$[esp+20]
	push	edi
	mov	edi, DWORD PTR _pFromPlot$[esp+24]
	push	esi
	push	edi
	push	ebx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN5@MovementCo@2

; 233  : 	{
; 234  : 		if (iMovesRemaining > 0)

	mov	eax, DWORD PTR _iMovesRemaining$[esp+24]
	test	eax, eax

; 235  : 			return iMovesRemaining;

	jg	SHORT $LN6@MovementCo@2

; 236  : 		else
; 237  : 			return iMaxMoves;

	mov	eax, DWORD PTR _iMaxMoves$[esp+24]
	pop	edi
	pop	esi
	pop	ebx

; 247  : }

	add	esp, 16					; 00000010H
	ret	0
$LN5@MovementCo@2:

; 238  : 	}
; 239  : 	else if(CostsOnlyOne(pUnit, pFromPlot, pToPlot))

	push	esi
	push	edi
	push	ebx
	call	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN1@MovementCo@2

; 240  : 	{
; 241  : 		return GC.getMOVE_DENOMINATOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	pop	edi
	pop	esi
	pop	ebx

; 247  : }

	add	esp, 16					; 00000010H
	ret	0
$LN1@MovementCo@2:

; 242  : 	}
; 243  : 
; 244  : 	GetCostsForMove(pUnit, pFromPlot, pToPlot, iBaseMoves, iRegularCost, iRouteCost, iRouteFlatCost);

	lea	eax, DWORD PTR _iRouteFlatCost$[esp+28]
	push	eax
	mov	eax, DWORD PTR _iBaseMoves$[esp+28]
	lea	ecx, DWORD PTR _iRouteCost$[esp+32]
	push	ecx
	lea	edx, DWORD PTR _iRegularCost$[esp+36]
	push	edx
	push	eax
	push	esi
	push	edi
	push	ebx
	call	?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ; CvUnitMovement::GetCostsForMove

; 245  : 
; 246  : 	return std::max(1, std::min(iRegularCost, std::min(iRouteCost, iRouteFlatCost)));

	mov	ecx, DWORD PTR _iRouteFlatCost$[esp+56]
	add	esp, 28					; 0000001cH
	cmp	ecx, DWORD PTR _iRouteCost$[esp+28]
	mov	DWORD PTR $T219072[esp+28], 1
	lea	eax, DWORD PTR _iRouteFlatCost$[esp+28]
	jl	SHORT $LN13@MovementCo@2
	lea	eax, DWORD PTR _iRouteCost$[esp+28]
$LN13@MovementCo@2:
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _iRegularCost$[esp+28]
	jl	SHORT $LN17@MovementCo@2
	lea	eax, DWORD PTR _iRegularCost$[esp+28]
$LN17@MovementCo@2:
	cmp	DWORD PTR [eax], 1
	jg	SHORT $LN21@MovementCo@2
	lea	eax, DWORD PTR $T219072[esp+28]
$LN21@MovementCo@2:
	mov	eax, DWORD PTR [eax]
$LN6@MovementCo@2:
	pop	edi
	pop	esi
	pop	ebx

; 247  : }

	add	esp, 16					; 00000010H
	ret	0
?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ENDP ; CvUnitMovement::MovementCostNoZOC
_TEXT	ENDS
END
