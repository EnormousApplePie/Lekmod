; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMinorCivAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG221773 DB	'TXT_KEY_NOTIFICATION_QUEST_START_ROUTE', 00H
$SG226384 DB	00H
$SG221775 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_START_ROUTE', 00H
$SG227421 DB	00H
$SG221780 DB	'TXT_KEY_NOTIFICATION_QUEST_KILL_CAMP', 00H
$SG227993 DB	00H
$SG227995 DB	00H
$SG228031 DB	00H
$SG221782 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_KILL_CAMP', 00H
$SG228033 DB	00H
$SG228041 DB	00H
$SG229390 DB	00H
$SG221788 DB	'TXT_KEY_NOTIFICATION_QUEST_CONNECT_RESOURCE', 00H
$SG221795 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONNECT_RESOURCE', 00H
$SG221801 DB	'TXT_KEY_NOTIFICATION_QUEST_CONSTRUCT_WONDER', 00H
$SG221803 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONSTRUCT_WONDER', 00H
$SG221809 DB	'TXT_KEY_NOTIFICATION_QUEST_GREAT_PERSON', 00H
$SG221811 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_GREAT_PERSON', 00H
$SG221817 DB	'TXT_KEY_NOTIFICATION_QUEST_KILL_CITY_STATE', 00H
	ORG $+1
$SG221819 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_KILL_CITY_STATE', 00H
	ORG $+1
$SG221825 DB	'TXT_KEY_NOTIFICATION_QUEST_FIND_PLAYER', 00H
	ORG $+1
$SG221827 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_FIND_PLAYER', 00H
	ORG $+1
$SG221832 DB	'TXT_KEY_NOTIFICATION_QUEST_FIND_NATURAL_WONDER', 00H
	ORG $+1
$SG221834 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_FIND_NATURAL_WONDER', 00H
	ORG $+1
$SG221840 DB	'TXT_KEY_NOTIFICATION_QUEST_GIVE_GOLD', 00H
	ORG $+3
$SG221842 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_GIVE_GOLD', 00H
	ORG $+3
$SG221847 DB	'Nobody', 00H
	ORG $+1
$SG221852 DB	'TXT_KEY_NOTIFICATION_QUEST_PLEDGE_TO_PROTECT', 00H
	ORG $+3
$SG221854 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_PLEDGE_TO_PROTECT', 00H
	ORG $+3
$SG221859 DB	'Nobody', 00H
	ORG $+1
$SG221866 DB	'TXT_KEY_NOTIFICATION_QUEST_CONTEST_CULTURE', 00H
	ORG $+1
$SG221868 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONTEST_CULTURE', 00H
	ORG $+1
$SG221875 DB	'TXT_KEY_NOTIFICATION_QUEST_CONTEST_FAITH', 00H
	ORG $+3
$SG221877 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONTEST_FAITH', 00H
	ORG $+3
$SG221884 DB	'TXT_KEY_NOTIFICATION_QUEST_CONTEST_TECHS', 00H
	ORG $+3
$SG221886 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONTEST_TECHS', 00H
	ORG $+3
$SG221893 DB	'TXT_KEY_NOTIFICATION_QUEST_INVEST', 00H
	ORG $+2
$SG221895 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_INVEST', 00H
	ORG $+2
$SG221901 DB	'TXT_KEY_NOTIFICATION_QUEST_BULLY_CITY_STATE', 00H
$SG221903 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_BULLY_CITY_STATE', 00H
$SG221908 DB	'Nobody', 00H
	ORG $+1
$SG221913 DB	'TXT_KEY_NOTIFICATION_QUEST_DENOUNCE_MAJOR', 00H
	ORG $+2
$SG221915 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_DENOUNCE_MAJOR', 00H
	ORG $+2
$SG221920 DB	'Nobody', 00H
	ORG $+1
$SG221925 DB	'TXT_KEY_NOTIFICATION_QUEST_SPREAD_RELIGION', 00H
	ORG $+1
$SG221927 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_SPREAD_RELIGION', 00H
	ORG $+1
$SG221934 DB	'No Religion', 00H
$SG221938 DB	'TXT_KEY_NOTIFICATION_QUEST_START_TRADE_ROUTE', 00H
	ORG $+3
$SG221940 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_START_TRADE_ROUTE', 00H
	ORG $+3
$SG221964 DB	'TXT_KEY_NOTIFICATION_QUEST_KILL_CAMP', 00H
	ORG $+3
$SG221966 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_KILL_CAMP', 00H
	ORG $+3
$SG221994 DB	'TXT_KEY_NOTIFICATION_MINOR_ROUTE_CONNECTION', 00H
$SG221996 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ROUTE_CONNECTION', 00H
$SG222000 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_KILL_CAMP', 00H
	ORG $+2
$SG222002 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_KILL_CAMP', 00H
	ORG $+2
$SG222009 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONNECT_RESOURCE', 00H
	ORG $+3
$SG222011 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONNECT_RESO'
	DB	'URCE', 00H
	ORG $+3
$SG222018 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONSTRUCT_WONDER', 00H
	ORG $+3
$SG222020 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONSTRUCT_WO'
	DB	'NDER', 00H
	ORG $+3
$SG222027 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_GREAT_PERSON', 00H
	ORG $+3
$SG222029 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_GREAT_PERSON'
	DB	00H
	ORG $+3
$SG222036 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_KILL_CITY_STATE', 00H
$SG222038 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_KILL_CITY_ST'
	DB	'ATE', 00H
$SG222045 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_FIND_PLAYER', 00H
$SG222047 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_FIND_PLAYER', 00H
$SG222051 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_FIND_NATURAL_WONDER', 00H
$SG222079 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONTEST_CULTURE', 00H
$SG222053 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_FIND_NATURAL'
	DB	'_WONDER', 00H
$SG222059 DB	'Nobody', 00H
	ORG $+1
$SG222062 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_GIVE_GOLD', 00H
	ORG $+2
$SG222064 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_GIVE_GOLD', 00H
	ORG $+2
$SG222070 DB	'Nobody', 00H
	ORG $+1
$SG222073 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_PLEDGE_TO_PROTECT', 00H
	ORG $+2
$SG222075 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_PLEDGE_TO_PR'
	DB	'OTECT', 00H
	ORG $+2
$SG222081 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONTEST_CULT'
	DB	'URE', 00H
$SG222086 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONTEST_FAITH', 00H
	ORG $+2
$SG222088 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONTEST_FAIT'
	DB	'H', 00H
	ORG $+2
$SG222093 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONTEST_TECHS', 00H
	ORG $+2
$SG222095 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONTEST_TECH'
	DB	'S', 00H
	ORG $+2
$SG222100 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_INVEST', 00H
	ORG $+1
$SG222102 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_INVEST', 00H
	ORG $+1
$SG222108 DB	'Nobody', 00H
	ORG $+1
$SG222111 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_BULLY_CITY_STATE', 00H
	ORG $+3
$SG222113 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_BULLY_CITY_S'
	DB	'TATE', 00H
	ORG $+3
$SG222119 DB	'Nobody', 00H
	ORG $+1
$SG222122 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_DENOUNCE_MAJOR', 00H
	ORG $+1
$SG222124 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_DENOUNCE_MAJ'
	DB	'OR', 00H
	ORG $+1
$SG222130 DB	'Atheism', 00H
$SG222136 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_SPREAD_RELIGION', 00H
$SG222139 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_SPREAD_RELIG'
	DB	'ION', 00H
$SG222143 DB	'TXT_KEY_NOTIFICATION_QUEST_COMPLETE_TRADE_ROUTE', 00H
$SG222145 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_TRADE_ROUTE', 00H
$SG222202 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG222223 DB	'TXT_KEY_NTFN_QUEST_ENDED_KILL_CAMP', 00H
	ORG $+1
$SG222225 DB	'TXT_KEY_NTFN_QUEST_ENDED_KILL_CAMP_S', 00H
	ORG $+3
$SG222235 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_CONSTRUCT_WONDER', 00H
	ORG $+2
$SG222237 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONSTRUCT_WONDE'
	DB	'R', 00H
	ORG $+2
$SG222244 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_KILL_CITY_STATE', 00H
	ORG $+3
$SG222246 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_KILL_CITY_STATE'
	DB	00H
	ORG $+3
$SG222250 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_CONTEST_CULTURE', 00H
	ORG $+3
$SG222252 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONTEST_CULTURE'
	DB	00H
	ORG $+3
$SG222257 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_CONTEST_FAITH', 00H
	ORG $+1
$SG222259 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONTEST_FAITH', 00H
	ORG $+1
$SG222264 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_CONTEST_TECHS', 00H
	ORG $+1
$SG222266 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONTEST_TECHS', 00H
	ORG $+1
$SG222270 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_OTHER', 00H
	ORG $+1
$SG222272 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_OTHER', 00H
	ORG $+1
$SG222538 DB	'FLAVOR_CITY_DEFENSE', 00H
$SG222542 DB	'FLAVOR_DEFENSE', 00H
	ORG $+1
$SG222546 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG222552 DB	'Minor Civ AI: Picking Personality for this Game (should '
	DB	'happen only once per player)', 00H
	ORG $+3
$SG222979 DB	'Rolling for Mercantile city-state special luxury', 00H
	ORG $+3
$SG223020 DB	'[NEWLINE][NEWLINE]', 00H
	ORG $+1
$SG223022 DB	'TXT_KEY_MINOR_QUEST_BLOCKING_TT', 00H
$SG223095 DB	'TXT_KEY_NOTIFICATION_MINOR_BARBS_QUEST', 00H
	ORG $+1
$SG223099 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BARBS_QUEST', 00H
	ORG $+1
$SG223126 DB	'TXT_KEY_NOTIFICATION_MINOR_BARB_KILLED', 00H
	ORG $+1
$SG223130 DB	'TXT_KEY_NOTIFICATION_SM_MINOR_BARB_KILLED', 00H
	ORG $+2
$SG223161 DB	'TXT_KEY_NOTIFICATION_MINOR_WAR_UNIT_HELP', 00H
	ORG $+3
$SG223166 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_WAR_UNIT_HELP', 00H
	ORG $+3
$SG223189 DB	'TXT_KEY_NOTIFICATION_MINOR_WAR_UNIT_HELP', 00H
	ORG $+3
$SG223194 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_WAR_UNIT_HELP', 00H
	ORG $+3
$SG223432 DB	'Picking random global quest for Minor to give to players'
	DB	'.', 00H
	ORG $+2
$SG223461 DB	'Picking random quest for Minor to give to a player.', 00H
$SG224546 DB	'TXT_KEY_NOTIFICATION_QUEST_ENDED_REVOKED', 00H
	ORG $+3
$SG224549 DB	'TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_REVOKED', 00H
	ORG $+7
$SG225006 DB	'Random # of turns for Minor Civ global quest counter - f'
	DB	'irst time.', 00H
	ORG $+1
$SG225010 DB	'Random # of turns for Minor Civ global quest counter.', 00H
	ORG $+6
$SG225033 DB	'Random # of turns for Minor Civ personal quest counter -'
	DB	' first time.', 00H
	ORG $+3
$SG225037 DB	'Random # of turns for Minor Civ personal quest counter.', 00H
$SG225458 DB	'Finding random Resource for Minor to give out a quest to'
	DB	' connect.', 00H
	ORG $+6
$SG225565 DB	'Finding random Wonder for Minor to give out a quest to c'
	DB	'onstruct.', 00H
	ORG $+2
$SG225574 DB	'SPECIALUNIT_PEOPLE', 00H
	ORG $+1
$SG225749 DB	'Finding random Great Person for Minor to give out a ques'
	DB	't to spawn.', 00H
$SG225952 DB	'TXT_KEY_NTFN_CITY_STATE_ALMOST_NOT_ALLIES', 00H
	ORG $+2
$SG225848 DB	'Finding random City State Target for Minor to give out a'
	DB	' quest to kill.', 00H
$SG225899 DB	'Finding random Major player Target for Minor to give out'
	DB	' a quest to find.', 00H
	ORG $+2
$SG225954 DB	'TXT_KEY_NTFN_CITY_STATE_ALMOST_SM', 00H
	ORG $+2
$SG225962 DB	'TXT_KEY_NTFN_CITY_STATE_ALMOST_NOT_FRIENDS', 00H
	ORG $+1
$SG225964 DB	'TXT_KEY_NTFN_CITY_STATE_ALMOST_SM', 00H
	ORG $+2
$SG226187 DB	'SetAlly', 00H
$SG226262 DB	'MinorFriendsChanged', 00H
$SG226274 DB	'MinorFriendsChanged', 00H
$SG226280 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG226288 DB	'MinorAlliesChanged', 00H
	ORG $+1
$SG226295 DB	'MinorAlliesChanged', 00H
	ORG $+1
$SG226302 DB	'MinorAlliesChanged', 00H
	ORG $+1
$SG226382 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG226388 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG226397 DB	'TXT_KEY_NTFN_MINOR_NEW_BEST_RELATIONS_ALL', 00H
	ORG $+2
$SG226399 DB	'TXT_KEY_NTFN_SMMRY_MINOR_BEST_RELATIONS_ALL', 00H
$SG226402 DB	'TXT_KEY_NTFN_MINOR_NOW_BEST_RELATIONS_ALL', 00H
	ORG $+2
$SG226404 DB	'TXT_KEY_NTFN_SMMRY_MINOR_NOW_ALLIES_ALL', 00H
$SG226416 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG226418 DB	'TXT_KEY_NTFN_MINOR_BEST_RELATIONS_LOST_ALL', 00H
	ORG $+1
$SG226420 DB	'TXT_KEY_NTFN_SMMRY_MINOR_BEST_RELATIONS_LOST_ALL', 00H
	ORG $+3
$SG226463 DB	'TXT_KEY_NOTIFICATION_MINOR_INTRUSION', 00H
	ORG $+3
$SG226466 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_INTRUSION', 00H
	ORG $+3
$SG226501 DB	'TXT_KEY_NOTIFICATION_MINOR_LIBERATION', 00H
	ORG $+2
$SG226506 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_LIBERATION', 00H
	ORG $+2
$SG226528 DB	'TXT_KEY_NOTIFICATION_MINOR_LIBERATION_YOU', 00H
	ORG $+2
$SG226531 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_LIBERATION', 00H
	ORG $+2
$SG226689 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226692 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226707 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226710 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226767 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226770 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226784 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226787 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226822 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226825 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226849 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226852 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226883 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226886 DB	'ERA_RENAISSANCE', 00H
$SG226889 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226892 DB	'ERA_CLASSICAL', 00H
	ORG $+2
$SG226911 DB	'ERA_INDUSTRIAL', 00H
	ORG $+1
$SG226914 DB	'ERA_RENAISSANCE', 00H
$SG226917 DB	'ERA_MEDIEVAL', 00H
	ORG $+3
$SG226920 DB	'ERA_CLASSICAL', 00H
	ORG $+2
$SG226957 DB	'ERA_RENAISSANCE', 00H
$SG226972 DB	'ERA_RENAISSANCE', 00H
$SG227014 DB	'Rand turns for Friendly Minor unit spawn', 00H
	ORG $+3
$SG227102 DB	'TXT_KEY_NOTIFICATION_CITY_STATE_UNIT_SPAWN', 00H
	ORG $+1
$SG227106 DB	'TXT_KEY_NOTIFICATION_SUMMARY_CITY_STATE_UNIT_SPAWN', 00H
	ORG $+1
$SG227191 DB	'MINOR_CIV_BORNU', 00H
$SG227194 DB	'MINOR_CIV_SOKOTO', 00H
	ORG $+7
$SG227206 DB	'Coin toss roll to determine flavor message for minor civ'
	DB	' buyout notification.', 00H
	ORG $+2
$SG227209 DB	'TXT_KEY_NOTIFICATION_MINOR_BUYOUT_TT_1', 00H
	ORG $+1
$SG227212 DB	'TXT_KEY_NOTIFICATION_MINOR_BUYOUT_TT_2', 00H
	ORG $+1
$SG227217 DB	'TXT_KEY_NOTIFICATION_MINOR_BUYOUT', 00H
	ORG $+2
$SG227667 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_POSITIVE', 00H
	ORG $+3
$SG227684 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_GLOBAL_MILITARY', 00H
$SG227734 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_POSITIVE', 00H
	ORG $+3
$SG227751 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_MILITARY_PRESENCE', 00H
	ORG $+2
$SG227758 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_POSITIVE', 00H
	ORG $+3
$SG227759 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_GUNBOAT_DIPLOMACY', 00H
	ORG $+2
$SG227764 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227766 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_BASE_RELUCTANCE', 00H
$SG227772 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227789 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_LOW_INFLUENCE', 00H
	ORG $+2
$SG227797 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227814 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_BULLIED_VERY_RECENTLY', 00H
	ORG $+2
$SG227821 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227838 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_BULLIED_RECENTLY', 00H
	ORG $+3
$SG227844 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227845 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_UNIT_RELUCTANCE', 00H
$SG227853 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227870 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_LOW_POPULATION', 00H
	ORG $+1
$SG227876 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227893 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_ALLIES', 00H
	ORG $+1
$SG227904 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227921 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_PLEDGES_TO_PROTECT', 00H
	ORG $+1
$SG227927 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227944 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_HOSTILE', 00H
$SG227950 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE', 00H
	ORG $+3
$SG227967 DB	'TXT_KEY_POP_CSTATE_BULLY_FACTOR_MILITARISTIC', 00H
	ORG $+3
$SG228000 DB	'TXT_KEY_POP_CSTATE_BULLY_AFRAID', 00H
$SG228003 DB	'TXT_KEY_POP_CSTATE_BULLY_RESILIENT', 00H
	ORG $+1
$SG228006 DB	'TXT_KEY_POP_CSTATE_BULLY_GOLD_TT', 00H
	ORG $+3
$SG228038 DB	'UNIT_WORKER', 00H
$SG228044 DB	'TXT_KEY_POP_CSTATE_BULLY_AFRAID', 00H
$SG228047 DB	'TXT_KEY_POP_CSTATE_BULLY_RESILIENT', 00H
	ORG $+1
$SG228050 DB	'TXT_KEY_POP_CSTATE_BULLY_UNIT_TT', 00H
	ORG $+3
$SG228377 DB	'Choosing CS election winner by weight', 00H
	ORG $+2
$SG228389 DB	'TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_SUCCESS_S', 00H
$SG228393 DB	'TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_SUCCESS', 00H
	ORG $+2
$SG228409 DB	'TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_FAILURE_S', 00H
$SG228413 DB	'TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_FAILURE', 00H
	ORG $+2
$SG228425 DB	'TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_ALERT_S', 00H
	ORG $+2
$SG228429 DB	'TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_ALERT', 00H
$SG228759 DB	'MINOR CIV AI: Become Wary Of aggressor roll.', 00H
	ORG $+3
$SG228805 DB	'MINOR CIV AI: Third party minor to become Wary Of aggres'
	DB	'sor roll.', 00H
	ORG $+2
$SG228813 DB	'TXT_KEY_NOTIFICATION_MINORS_NOW_WARY', 00H
	ORG $+3
$SG228816 DB	'TXT_KEY_NOTIFICATION_MINORS_NOW_WARY_TT', 00H
$SG229208 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_MILITARISTIC', 00H
	ORG $+1
$SG229119 DB	'Minor Civ Quest Reward: Tech - Adding random weight to T'
	DB	'ech Reward', 00H
	ORG $+1
$SG229195 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_CULTURE', 00H
	ORG $+2
$SG229199 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_CULTURE', 00H
	ORG $+1
$SG229203 DB	'TXT_KEY_NOTIFICATION_MINOR_LOST_CULTURE', 00H
$SG229212 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_MILITARISTIC', 00H
$SG229216 DB	'TXT_KEY_NOTIFICATION_MINOR_LOST_FRIENDS_MILITARISTIC', 00H
	ORG $+3
$SG229220 DB	'TXT_KEY_NOTIFICATION_MINOR_LOST_ALLIES_MILITARISTIC', 00H
$SG229232 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_MARITIME', 00H
	ORG $+1
$SG229241 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_MARITIME', 00H
$SG229245 DB	'TXT_KEY_NOTIFICATION_MINOR_LOST_MARITIME', 00H
	ORG $+3
$SG229254 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_MERCANTILE', 00H
	ORG $+3
$SG229258 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_MERCANTILE', 00H
	ORG $+2
$SG229262 DB	'TXT_KEY_NOTIFICATION_MINOR_LOST_MERCANTILE', 00H
	ORG $+1
$SG229270 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_RELIGIOUS', 00H
$SG229274 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_RELIGIOUS', 00H
	ORG $+3
$SG229278 DB	'TXT_KEY_NOTIFICATION_MINOR_LOST_RELIGIOUS', 00H
	ORG $+2
$SG229300 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_BASE', 00H
	ORG $+1
$SG229303 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG229307 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_BASE_PASSED', 00H
	ORG $+2
$SG229309 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ALLIES_STATUS', 00H
	ORG $+3
$SG229329 DB	'TXT_KEY_NOTIFICATION_MINOR_GAINED_BEST_RELATIONS_BONUS_N'
	DB	'ONE', 00H
$SG229336 DB	', ', 00H
	ORG $+1
$SG229338 DB	'TXT_KEY_NOTIFICATION_MINOR_GAINED_BEST_RELATIONS_BONUS_S'
	DB	'OME', 00H
$SG229344 DB	'TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_BASE', 00H
$SG229346 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDS_STATUS', 00H
	ORG $+2
$SG229351 DB	'TXT_KEY_NOTIFICATION_MINOR_ALLIES_LOST', 00H
	ORG $+1
$SG229353 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ALLIES_STATUS_LOST', 00H
	ORG $+2
$SG229356 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG229360 DB	'TXT_KEY_NOTIFICATION_MINOR_ALLIES_PASSED', 00H
	ORG $+3
$SG229362 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ALLIES_STATUS_PASSED', 00H
$SG229366 DB	'TXT_KEY_NOTIFICATION_MINOR_FRIENDS_LOST_BASE', 00H
	ORG $+3
$SG229368 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDS_STATUS_LOST', 00H
	ORG $+1
$SG229403 DB	'[NEWLINE]', 00H
	ORG $+2
$SG229520 DB	'ShortDescription', 00H
	ORG $+3
$SG229521 DB	'Adjective', 00H
	ORG $+2
$SG229522 DB	'ArtDefineTag', 00H
	ORG $+3
$SG229523 DB	'DefaultPlayerColor', 00H
	ORG $+1
$SG229524 DB	'ArtStyleType', 00H
	ORG $+3
$SG229525 DB	'ArtStylePrefix', 00H
	ORG $+1
$SG229526 DB	'ArtStyleSuffix', 00H
	ORG $+1
$SG229527 DB	'MinorCivTrait', 00H
	ORG $+2
$SG229529 DB	'MinorCivType', 00H
	ORG $+3
$SG229530 DB	'MinorCivilization_Flavors', 00H
	ORG $+2
$SG229532 DB	'MinorCiv - CityName', 00H
$SG229535 DB	'select CityName from MinorCivilization_CityNames where M'
	DB	'inorCivType = ?', 00H
$SG92498 DB	'f2eb1642-3334-4d2c-8db1-08e6aede3532', 00H
	ORG $+3
_CIV5_XP2_SCENARIO2_MODID DD FLAT:$SG92498
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??0CvMinorCivQuest@@QAE@XZ			; CvMinorCivQuest::CvMinorCivQuest
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ??0CvMinorCivQuest@@QAE@XZ
_TEXT	SEGMENT
??0CvMinorCivQuest@@QAE@XZ PROC				; CvMinorCivQuest::CvMinorCivQuest, COMDAT
; _this$ = ecx

; 29   : {

	mov	eax, ecx

; 30   : 	m_eMinor = NO_PLAYER;

	or	ecx, -1
	mov	DWORD PTR [eax], ecx

; 31   : 	m_eAssignedPlayer = NO_PLAYER;

	mov	DWORD PTR [eax+4], ecx

; 32   : 	m_eType = NO_MINOR_CIV_QUEST_TYPE;

	mov	DWORD PTR [eax+8], ecx

; 33   : 	m_iStartTurn = NO_TURN; /* -1 */

	mov	DWORD PTR [eax+12], ecx

; 34   : 	m_iData1 = NO_QUEST_DATA; /* -1 */

	mov	DWORD PTR [eax+16], ecx

; 35   : 	m_iData2 = NO_QUEST_DATA; /* -1 */

	mov	DWORD PTR [eax+20], ecx

; 36   : 	m_bHandled = false;

	mov	BYTE PTR [eax+24], 0

; 37   : }

	ret	0
??0CvMinorCivQuest@@QAE@XZ ENDP				; CvMinorCivQuest::CvMinorCivQuest
_TEXT	ENDS
PUBLIC	??0CvMinorCivQuest@@QAE@W4PlayerTypes@@0W4MinorCivQuestTypes@@@Z ; CvMinorCivQuest::CvMinorCivQuest
; Function compile flags: /Ogtpy
;	COMDAT ??0CvMinorCivQuest@@QAE@W4PlayerTypes@@0W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eMinor$ = 8						; size = 4
_eAssignedPlayer$ = 12					; size = 4
_eType$ = 16						; size = 4
??0CvMinorCivQuest@@QAE@W4PlayerTypes@@0W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivQuest::CvMinorCivQuest, COMDAT
; _this$ = ecx

; 42   : 	m_eMinor = eMinor;
; 43   : 	m_eAssignedPlayer = eAssignedPlayer;

	mov	edx, DWORD PTR _eAssignedPlayer$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _eMinor$[esp-4]
	mov	DWORD PTR [eax], ecx

; 44   : 	m_eType = eType;

	mov	ecx, DWORD PTR _eType$[esp-4]
	mov	DWORD PTR [eax+8], ecx

; 45   : 	m_iStartTurn = NO_TURN; /* -1 */

	or	ecx, -1
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+12], ecx

; 46   : 	m_iData1 = NO_QUEST_DATA; /* -1 */

	mov	DWORD PTR [eax+16], ecx

; 47   : 	m_iData2 = NO_QUEST_DATA; /* -1 */

	mov	DWORD PTR [eax+20], ecx

; 48   : 	m_bHandled = false;

	mov	BYTE PTR [eax+24], 0

; 49   : }

	ret	12					; 0000000cH
??0CvMinorCivQuest@@QAE@W4PlayerTypes@@0W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivQuest::CvMinorCivQuest
_TEXT	ENDS
PUBLIC	??1CvMinorCivQuest@@QAE@XZ			; CvMinorCivQuest::~CvMinorCivQuest
; Function compile flags: /Ogtpy
;	COMDAT ??1CvMinorCivQuest@@QAE@XZ
_TEXT	SEGMENT
??1CvMinorCivQuest@@QAE@XZ PROC				; CvMinorCivQuest::~CvMinorCivQuest, COMDAT
; _this$ = ecx

; 53   : }

	ret	0
??1CvMinorCivQuest@@QAE@XZ ENDP				; CvMinorCivQuest::~CvMinorCivQuest
_TEXT	ENDS
PUBLIC	?GetMinor@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivQuest::GetMinor
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinor@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetMinor@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ PROC	; CvMinorCivQuest::GetMinor, COMDAT
; _this$ = ecx

; 58   : 	return m_eMinor;

	mov	eax, DWORD PTR [ecx]

; 59   : }

	ret	0
?GetMinor@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ ENDP	; CvMinorCivQuest::GetMinor
_TEXT	ENDS
PUBLIC	?GetPlayerAssignedTo@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivQuest::GetPlayerAssignedTo
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerAssignedTo@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayerAssignedTo@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ PROC ; CvMinorCivQuest::GetPlayerAssignedTo, COMDAT
; _this$ = ecx

; 64   : 	return m_eAssignedPlayer;

	mov	eax, DWORD PTR [ecx+4]

; 65   : }

	ret	0
?GetPlayerAssignedTo@CvMinorCivQuest@@QBE?AW4PlayerTypes@@XZ ENDP ; CvMinorCivQuest::GetPlayerAssignedTo
_TEXT	ENDS
PUBLIC	?GetType@CvMinorCivQuest@@QBE?AW4MinorCivQuestTypes@@XZ ; CvMinorCivQuest::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvMinorCivQuest@@QBE?AW4MinorCivQuestTypes@@XZ
_TEXT	SEGMENT
?GetType@CvMinorCivQuest@@QBE?AW4MinorCivQuestTypes@@XZ PROC ; CvMinorCivQuest::GetType, COMDAT
; _this$ = ecx

; 70   : 	return m_eType;

	mov	eax, DWORD PTR [ecx+8]

; 71   : }

	ret	0
?GetType@CvMinorCivQuest@@QBE?AW4MinorCivQuestTypes@@XZ ENDP ; CvMinorCivQuest::GetType
_TEXT	ENDS
PUBLIC	?GetStartTurn@CvMinorCivQuest@@QBEHXZ		; CvMinorCivQuest::GetStartTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetStartTurn@CvMinorCivQuest@@QBEHXZ
_TEXT	SEGMENT
?GetStartTurn@CvMinorCivQuest@@QBEHXZ PROC		; CvMinorCivQuest::GetStartTurn, COMDAT
; _this$ = ecx

; 76   : 	return m_iStartTurn;

	mov	eax, DWORD PTR [ecx+12]

; 77   : }

	ret	0
?GetStartTurn@CvMinorCivQuest@@QBEHXZ ENDP		; CvMinorCivQuest::GetStartTurn
_TEXT	ENDS
PUBLIC	?GetPrimaryData@CvMinorCivQuest@@QBEHXZ		; CvMinorCivQuest::GetPrimaryData
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrimaryData@CvMinorCivQuest@@QBEHXZ
_TEXT	SEGMENT
?GetPrimaryData@CvMinorCivQuest@@QBEHXZ PROC		; CvMinorCivQuest::GetPrimaryData, COMDAT
; _this$ = ecx

; 157  : 	return m_iData1;

	mov	eax, DWORD PTR [ecx+16]

; 158  : }

	ret	0
?GetPrimaryData@CvMinorCivQuest@@QBEHXZ ENDP		; CvMinorCivQuest::GetPrimaryData
_TEXT	ENDS
PUBLIC	?GetSecondaryData@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetSecondaryData
; Function compile flags: /Ogtpy
;	COMDAT ?GetSecondaryData@CvMinorCivQuest@@QBEHXZ
_TEXT	SEGMENT
?GetSecondaryData@CvMinorCivQuest@@QBEHXZ PROC		; CvMinorCivQuest::GetSecondaryData, COMDAT
; _this$ = ecx

; 163  : 	return m_iData2;

	mov	eax, DWORD PTR [ecx+20]

; 164  : }

	ret	0
?GetSecondaryData@CvMinorCivQuest@@QBEHXZ ENDP		; CvMinorCivQuest::GetSecondaryData
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?IsHandled@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::IsHandled
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?IsHandled@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
?IsHandled@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::IsHandled, COMDAT
; _this$ = ecx

; 789  : 	return m_bHandled;

	mov	al, BYTE PTR [ecx+24]

; 790  : }

	ret	0
?IsHandled@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::IsHandled
_TEXT	ENDS
PUBLIC	?SetHandled@CvMinorCivQuest@@QAEX_N@Z		; CvMinorCivQuest::SetHandled
; Function compile flags: /Ogtpy
;	COMDAT ?SetHandled@CvMinorCivQuest@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetHandled@CvMinorCivQuest@@QAEX_N@Z PROC		; CvMinorCivQuest::SetHandled, COMDAT
; _this$ = ecx

; 794  : 	m_bHandled = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [ecx+24], al

; 795  : }

	ret	4
?SetHandled@CvMinorCivQuest@@QAEX_N@Z ENDP		; CvMinorCivQuest::SetHandled
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Uninit@CvMinorCivAI@@QAEXXZ			; CvMinorCivAI::Uninit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?Uninit@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::Uninit, COMDAT
; _this$ = ecx

; 1635 : }

	ret	0
?Uninit@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::Uninit
_TEXT	ENDS
PUBLIC	?GetPlayer@CvMinorCivAI@@QAEPAVCvPlayer@@XZ	; CvMinorCivAI::GetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvMinorCivAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvMinorCivAI@@QAEPAVCvPlayer@@XZ PROC	; CvMinorCivAI::GetPlayer, COMDAT
; _this$ = ecx

; 1884 : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx]

; 1885 : }

	ret	0
?GetPlayer@CvMinorCivAI@@QAEPAVCvPlayer@@XZ ENDP	; CvMinorCivAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetPersonality@CvMinorCivAI@@QBE?AW4MinorCivPersonalityTypes@@XZ ; CvMinorCivAI::GetPersonality
; Function compile flags: /Ogtpy
;	COMDAT ?GetPersonality@CvMinorCivAI@@QBE?AW4MinorCivPersonalityTypes@@XZ
_TEXT	SEGMENT
?GetPersonality@CvMinorCivAI@@QBE?AW4MinorCivPersonalityTypes@@XZ PROC ; CvMinorCivAI::GetPersonality, COMDAT
; _this$ = ecx

; 1897 : 	return m_ePersonality;

	mov	eax, DWORD PTR [ecx+8]

; 1898 : }

	ret	0
?GetPersonality@CvMinorCivAI@@QBE?AW4MinorCivPersonalityTypes@@XZ ENDP ; CvMinorCivAI::GetPersonality
_TEXT	ENDS
PUBLIC	?IsHasUniqueUnit@CvMinorCivAI@@QBE_NXZ		; CvMinorCivAI::IsHasUniqueUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasUniqueUnit@CvMinorCivAI@@QBE_NXZ
_TEXT	SEGMENT
?IsHasUniqueUnit@CvMinorCivAI@@QBE_NXZ PROC		; CvMinorCivAI::IsHasUniqueUnit, COMDAT
; _this$ = ecx

; 1961 : 	return (m_eUniqueUnit != NO_UNIT);

	xor	eax, eax
	cmp	DWORD PTR [ecx+16], -1
	setne	al

; 1962 : }

	ret	0
?IsHasUniqueUnit@CvMinorCivAI@@QBE_NXZ ENDP		; CvMinorCivAI::IsHasUniqueUnit
_TEXT	ENDS
PUBLIC	?GetUniqueUnit@CvMinorCivAI@@QBE?AW4UnitTypes@@XZ ; CvMinorCivAI::GetUniqueUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetUniqueUnit@CvMinorCivAI@@QBE?AW4UnitTypes@@XZ
_TEXT	SEGMENT
?GetUniqueUnit@CvMinorCivAI@@QBE?AW4UnitTypes@@XZ PROC	; CvMinorCivAI::GetUniqueUnit, COMDAT
; _this$ = ecx

; 1967 : 	return m_eUniqueUnit;

	mov	eax, DWORD PTR [ecx+16]

; 1968 : }

	ret	0
?GetUniqueUnit@CvMinorCivAI@@QBE?AW4UnitTypes@@XZ ENDP	; CvMinorCivAI::GetUniqueUnit
_TEXT	ENDS
PUBLIC	?SetUniqueUnit@CvMinorCivAI@@QAEXW4UnitTypes@@@Z ; CvMinorCivAI::SetUniqueUnit
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?SetUniqueUnit@CvMinorCivAI@@QAEXW4UnitTypes@@@Z
_TEXT	SEGMENT
_eUnit$ = 8						; size = 4
?SetUniqueUnit@CvMinorCivAI@@QAEXW4UnitTypes@@@Z PROC	; CvMinorCivAI::SetUniqueUnit, COMDAT
; _this$ = ecx

; 1972 : {

	push	esi
	push	edi

; 1973 : 	CvAssertMsg(GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC, "Setting a unique unit for a non-Militaristic City-State.  It will never be spawned without additional scripting.");
; 1974 : 	CvUnitEntry* pInfo = GC.getUnitInfo(eUnit);

	mov	edi, DWORD PTR _eUnit$[esp+4]
	mov	esi, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 1975 : 	CvAssertMsg(pInfo, "Setting a unique unit for a City-State that the game core could not identify. Please send Anton your save file and version.");
; 1976 : 	if (pInfo)

	test	eax, eax
	je	SHORT $LN1@SetUniqueU

; 1977 : 	{
; 1978 : 		m_eUniqueUnit = eUnit;

	mov	DWORD PTR [esi+16], edi
$LN1@SetUniqueU:
	pop	edi
	pop	esi

; 1979 : 	}
; 1980 : }

	ret	4
?SetUniqueUnit@CvMinorCivAI@@QAEXW4UnitTypes@@@Z ENDP	; CvMinorCivAI::SetUniqueUnit
_TEXT	ENDS
PUBLIC	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ ; CvMinorCivAI::GetStatus
; Function compile flags: /Ogtpy
;	COMDAT ?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ
_TEXT	SEGMENT
?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ PROC ; CvMinorCivAI::GetStatus, COMDAT
; _this$ = ecx

; 2384 : 	return m_eStatus;

	mov	eax, DWORD PTR [ecx+12]

; 2385 : }

	ret	0
?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ ENDP ; CvMinorCivAI::GetStatus
_TEXT	ENDS
PUBLIC	?GetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetTurnsSinceThreatenedAnnouncement
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QBEHXZ PROC ; CvMinorCivAI::GetTurnsSinceThreatenedAnnouncement, COMDAT
; _this$ = ecx

; 2609 : 	return m_iTurnsSinceThreatenedByBarbarians;

	mov	eax, DWORD PTR [ecx+20]

; 2610 : }

	ret	0
?GetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QBEHXZ ENDP ; CvMinorCivAI::GetTurnsSinceThreatenedAnnouncement
_TEXT	ENDS
PUBLIC	?SetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z ; CvMinorCivAI::SetTurnsSinceThreatenedAnnouncement
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z PROC ; CvMinorCivAI::SetTurnsSinceThreatenedAnnouncement, COMDAT
; _this$ = ecx

; 2615 : 	if(GetTurnsSinceThreatenedAnnouncement() != iValue)

	mov	eax, DWORD PTR _iValue$[esp-4]
	cmp	DWORD PTR [ecx+20], eax
	je	SHORT $LN1@SetTurnsSi

; 2616 : 		m_iTurnsSinceThreatenedByBarbarians = iValue;

	mov	DWORD PTR [ecx+20], eax
$LN1@SetTurnsSi:

; 2617 : }

	ret	4
?SetTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z ENDP ; CvMinorCivAI::SetTurnsSinceThreatenedAnnouncement
_TEXT	ENDS
PUBLIC	?ChangeTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z ; CvMinorCivAI::ChangeTurnsSinceThreatenedAnnouncement
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z PROC ; CvMinorCivAI::ChangeTurnsSinceThreatenedAnnouncement, COMDAT
; _this$ = ecx

; 2622 : 	SetTurnsSinceThreatenedAnnouncement(GetTurnsSinceThreatenedAnnouncement() + iChange);

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	edx, eax
	cmp	eax, edx
	je	SHORT $LN5@ChangeTurn
	mov	DWORD PTR [ecx+20], edx
$LN5@ChangeTurn:

; 2623 : }

	ret	4
?ChangeTurnsSinceThreatenedAnnouncement@CvMinorCivAI@@QAEXH@Z ENDP ; CvMinorCivAI::ChangeTurnsSinceThreatenedAnnouncement
_TEXT	ENDS
PUBLIC	?GetMaxActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetMaxActivePersonalQuestsForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetMaxActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHXZ PROC ; CvMinorCivAI::GetMaxActivePersonalQuestsForPlayer, COMDAT
; _this$ = ecx

; 2924 : 	return 2; //antonjs: todo: constant/XML, link with size of typedef vectors in header file

	mov	eax, 2

; 2925 : }

	ret	0
?GetMaxActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHXZ ENDP ; CvMinorCivAI::GetMaxActivePersonalQuestsForPlayer
_TEXT	ENDS
PUBLIC	?GetMaxActiveGlobalQuests@CvMinorCivAI@@QBEHXZ	; CvMinorCivAI::GetMaxActiveGlobalQuests
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxActiveGlobalQuests@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetMaxActiveGlobalQuests@CvMinorCivAI@@QBEHXZ PROC	; CvMinorCivAI::GetMaxActiveGlobalQuests, COMDAT
; _this$ = ecx

; 2930 : 	return 1; //antonjs: todo: constant/XML, link with size of typedef vectors in header file

	mov	eax, 1

; 2931 : }

	ret	0
?GetMaxActiveGlobalQuests@CvMinorCivAI@@QBEHXZ ENDP	; CvMinorCivAI::GetMaxActiveGlobalQuests
_TEXT	ENDS
PUBLIC	?IsGlobalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsGlobalQuest
; Function compile flags: /Ogtpy
;	COMDAT ?IsGlobalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eQuest$ = 8						; size = 4
?IsGlobalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsGlobalQuest, COMDAT
; _this$ = ecx

; 3847 : 	if(eQuest == MINOR_CIV_QUEST_KILL_CAMP)

	mov	eax, DWORD PTR _eQuest$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN5@IsGlobalQu
$LN8@IsGlobalQu:

; 3848 : 		return true;

	mov	al, 1

; 3860 : 		return true;
; 3861 : 
; 3862 : 	return false;
; 3863 : }

	ret	4
$LN5@IsGlobalQu:

; 3849 : 
; 3850 : 	if(eQuest == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH

; 3851 : 		return true;

	je	SHORT $LN8@IsGlobalQu

; 3852 : 
; 3853 : 	if(eQuest == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH

; 3854 : 		return true;

	je	SHORT $LN8@IsGlobalQu

; 3855 : 
; 3856 : 	if(eQuest == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH

; 3857 : 		return true;

	je	SHORT $LN8@IsGlobalQu

; 3858 : 
; 3859 : 	if(eQuest == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	sete	al

; 3860 : 		return true;
; 3861 : 
; 3862 : 	return false;
; 3863 : }

	ret	4
?IsGlobalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsGlobalQuest
_TEXT	ENDS
PUBLIC	?IsPersonalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsPersonalQuest
; Function compile flags: /Ogtpy
;	COMDAT ?IsPersonalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eQuest$ = 8						; size = 4
?IsPersonalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsPersonalQuest, COMDAT
; _this$ = ecx

; 3867 : 	return (!IsGlobalQuest(eQuest));

	mov	eax, DWORD PTR _eQuest$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN7@IsPersonal
$LN10@IsPersonal:
	mov	al, 1
	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl

; 3868 : }

	ret	4

; 3867 : 	return (!IsGlobalQuest(eQuest));

$LN7@IsPersonal:
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN10@IsPersonal
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN10@IsPersonal
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN10@IsPersonal
	cmp	eax, 13					; 0000000dH
	sete	al
	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl

; 3868 : }

	ret	4
?IsPersonalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsPersonalQuest
_TEXT	ENDS
PUBLIC	?GetGlobalQuestCountdown@CvMinorCivAI@@QAEHXZ	; CvMinorCivAI::GetGlobalQuestCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?GetGlobalQuestCountdown@CvMinorCivAI@@QAEHXZ
_TEXT	SEGMENT
?GetGlobalQuestCountdown@CvMinorCivAI@@QAEHXZ PROC	; CvMinorCivAI::GetGlobalQuestCountdown, COMDAT
; _this$ = ecx

; 4364 : 	return m_iGlobalQuestCountdown;

	mov	eax, DWORD PTR [ecx+24]

; 4365 : }

	ret	0
?GetGlobalQuestCountdown@CvMinorCivAI@@QAEHXZ ENDP	; CvMinorCivAI::GetGlobalQuestCountdown
_TEXT	ENDS
PUBLIC	?SetGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z	; CvMinorCivAI::SetGlobalQuestCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?SetGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z PROC	; CvMinorCivAI::SetGlobalQuestCountdown, COMDAT
; _this$ = ecx

; 4369 : 	m_iGlobalQuestCountdown = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 4370 : }

	ret	4
?SetGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z ENDP	; CvMinorCivAI::SetGlobalQuestCountdown
_TEXT	ENDS
PUBLIC	?ChangeGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z ; CvMinorCivAI::ChangeGlobalQuestCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z PROC	; CvMinorCivAI::ChangeGlobalQuestCountdown, COMDAT
; _this$ = ecx

; 4374 : 	SetGlobalQuestCountdown(GetGlobalQuestCountdown() + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+24], eax

; 4375 : }

	ret	4
?ChangeGlobalQuestCountdown@CvMinorCivAI@@QAEXH@Z ENDP	; CvMinorCivAI::ChangeGlobalQuestCountdown
_TEXT	ENDS
PUBLIC	?GetQuestCountdownForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetQuestCountdownForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetQuestCountdownForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetQuestCountdownForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetQuestCountdownForPlayer, COMDAT
; _this$ = ecx

; 4426 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4427 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4428 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // as set during Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetQuestCo

; 4429 : 
; 4430 : 	return m_aiQuestCountdown[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2464]

; 4431 : }

	ret	4
$LN1@GetQuestCo:

; 4426 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4427 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4428 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // as set during Reset()

	or	eax, -1

; 4431 : }

	ret	4
?GetQuestCountdownForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetQuestCountdownForPlayer
_TEXT	ENDS
PUBLIC	?SetQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetQuestCountdownForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetQuestCountdownForPlayer, COMDAT
; _this$ = ecx

; 4436 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4437 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4438 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetQuestCo

; 4439 : 
; 4440 : 	m_aiQuestCountdown[ePlayer] = iValue;

	mov	edx, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2464], edx
$LN1@SetQuestCo:

; 4441 : }

	ret	8
?SetQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetQuestCountdownForPlayer
_TEXT	ENDS
PUBLIC	?ChangeQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::ChangeQuestCountdownForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::ChangeQuestCountdownForPlayer, COMDAT
; _this$ = ecx

; 4446 : 	SetQuestCountdownForPlayer(ePlayer, GetQuestCountdownForPlayer(ePlayer) + iChange);

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN3@ChangeQues
	mov	edx, DWORD PTR [ecx+eax*4+2464]
	jmp	SHORT $LN5@ChangeQues
$LN3@ChangeQues:
	or	edx, -1
$LN5@ChangeQues:
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN7@ChangeQues
	push	esi
	mov	esi, DWORD PTR _iChange$[esp]
	add	edx, esi
	mov	DWORD PTR [ecx+eax*4+2464], edx
	pop	esi
$LN7@ChangeQues:

; 4447 : }

	ret	8
?ChangeQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::ChangeQuestCountdownForPlayer
_TEXT	ENDS
PUBLIC	?IsRouteConnectionEstablished@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRouteConnectionEstablished
; Function compile flags: /Ogtpy
;	COMDAT ?IsRouteConnectionEstablished@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsRouteConnectionEstablished@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsRouteConnectionEstablished, COMDAT
; _this$ = ecx

; 4624 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 4625 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 4626 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@IsRouteCon

; 4627 : 
; 4628 : 	return m_abRouteConnectionEstablished[eMajor];

	mov	al, BYTE PTR [eax+ecx+1988]

; 4629 : }

	ret	4
$LN1@IsRouteCon:

; 4624 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 4625 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 4626 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 4629 : }

	ret	4
?IsRouteConnectionEstablished@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsRouteConnectionEstablished
_TEXT	ENDS
PUBLIC	?SetRouteConnectionEstablished@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::SetRouteConnectionEstablished
; Function compile flags: /Ogtpy
;	COMDAT ?SetRouteConnectionEstablished@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetRouteConnectionEstablished@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z PROC ; CvMinorCivAI::SetRouteConnectionEstablished, COMDAT
; _this$ = ecx

; 4634 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 4635 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 4636 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN2@SetRouteCo

; 4637 : 
; 4638 : 	if(m_abRouteConnectionEstablished[eMajor] != bValue)

	mov	dl, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [eax+ecx+1988], dl
	je	SHORT $LN2@SetRouteCo

; 4639 : 	{
; 4640 : 		m_abRouteConnectionEstablished[eMajor] = bValue;

	mov	BYTE PTR [eax+ecx+1988], dl
$LN2@SetRouteCo:

; 4641 : 	}
; 4642 : }

	ret	8
?SetRouteConnectionEstablished@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ENDP ; CvMinorCivAI::SetRouteConnectionEstablished
_TEXT	ENDS
PUBLIC	?GetBaseFriendshipWithMajorTimes100@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBaseFriendshipWithMajorTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseFriendshipWithMajorTimes100@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetBaseFriendshipWithMajorTimes100@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetBaseFriendshipWithMajorTimes100, COMDAT
; _this$ = ecx

; 5420 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5421 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5422 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetBaseFri

; 5423 : 
; 5424 : 	return m_aiFriendshipWithMajorTimes100[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2024]

; 5425 : }

	ret	4
$LN1@GetBaseFri:

; 5420 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5421 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5422 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	xor	eax, eax

; 5425 : }

	ret	4
?GetBaseFriendshipWithMajorTimes100@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetBaseFriendshipWithMajorTimes100
_TEXT	ENDS
PUBLIC	?GetBaseFriendshipWithMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBaseFriendshipWithMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseFriendshipWithMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetBaseFriendshipWithMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetBaseFriendshipWithMajor, COMDAT
; _this$ = ecx

; 5491 : 	return GetBaseFriendshipWithMajorTimes100(ePlayer) / 100;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN3@GetBaseFri@2
	mov	ecx, DWORD PTR [ecx+eax*4+2024]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 5492 : }

	ret	4

; 5491 : 	return GetBaseFriendshipWithMajorTimes100(ePlayer) / 100;

$LN3@GetBaseFri@2:
	xor	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 5492 : }

	ret	4
?GetBaseFriendshipWithMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetBaseFriendshipWithMajor
_TEXT	ENDS
PUBLIC	?GetAngerFreeIntrusionCounter@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAngerFreeIntrusionCounter
; Function compile flags: /Ogtpy
;	COMDAT ?GetAngerFreeIntrusionCounter@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetAngerFreeIntrusionCounter@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetAngerFreeIntrusionCounter, COMDAT
; _this$ = ecx

; 5572 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5573 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5574 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetAngerFr

; 5575 : 
; 5576 : 	return m_aiAngerFreeIntrusionCounter[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2112]

; 5577 : }

	ret	4
$LN1@GetAngerFr:

; 5572 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5573 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5574 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	xor	eax, eax

; 5577 : }

	ret	4
?GetAngerFreeIntrusionCounter@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetAngerFreeIntrusionCounter
_TEXT	ENDS
PUBLIC	?SetAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetAngerFreeIntrusionCounter
; Function compile flags: /Ogtpy
;	COMDAT ?SetAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iNum$ = 12						; size = 4
?SetAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetAngerFreeIntrusionCounter, COMDAT
; _this$ = ecx

; 5582 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5583 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5584 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetAngerFr

; 5585 : 
; 5586 : 	m_aiAngerFreeIntrusionCounter[ePlayer] = iNum;

	mov	edx, DWORD PTR _iNum$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2112], edx
$LN1@SetAngerFr:

; 5587 : }

	ret	8
?SetAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetAngerFreeIntrusionCounter
_TEXT	ENDS
PUBLIC	?ChangeAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::ChangeAngerFreeIntrusionCounter
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::ChangeAngerFreeIntrusionCounter, COMDAT
; _this$ = ecx

; 5592 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5593 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5594 : 
; 5595 : 	SetAngerFreeIntrusionCounter(ePlayer, GetAngerFreeIntrusionCounter(ePlayer) + iChange);

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN3@ChangeAnge
	mov	edx, DWORD PTR [ecx+eax*4+2112]
	jmp	SHORT $LN5@ChangeAnge
$LN3@ChangeAnge:
	xor	edx, edx
$LN5@ChangeAnge:
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN7@ChangeAnge
	push	esi
	mov	esi, DWORD PTR _iChange$[esp]
	add	edx, esi
	mov	DWORD PTR [ecx+eax*4+2112], edx
	pop	esi
$LN7@ChangeAnge:

; 5596 : }

	ret	8
?ChangeAngerFreeIntrusionCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::ChangeAngerFreeIntrusionCounter
_TEXT	ENDS
PUBLIC	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ	; CvMinorCivAI::GetAlly
; Function compile flags: /Ogtpy
;	COMDAT ?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ PROC	; CvMinorCivAI::GetAlly, COMDAT
; _this$ = ecx

; 5680 : 	return m_eAlly;

	mov	eax, DWORD PTR [ecx+2012]

; 5681 : }

	ret	0
?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ENDP	; CvMinorCivAI::GetAlly
_TEXT	ENDS
PUBLIC	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z	; CvMinorCivAI::IsAllies
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC	; CvMinorCivAI::IsAllies, COMDAT
; _this$ = ecx

; 5824 : 	return m_eAlly == ePlayer;

	mov	ecx, DWORD PTR [ecx+2012]
	xor	eax, eax
	cmp	ecx, DWORD PTR _ePlayer$[esp-4]
	sete	al

; 5825 : }

	ret	4
?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP	; CvMinorCivAI::IsAllies
_TEXT	ENDS
PUBLIC	?IsEverFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsEverFriends
; Function compile flags: /Ogtpy
;	COMDAT ?IsEverFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsEverFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsEverFriends, COMDAT
; _this$ = ecx

; 5836 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5837 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5838 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@IsEverFrie

; 5839 : 
; 5840 : 	return m_abEverFriends[ePlayer];

	mov	al, BYTE PTR [eax+ecx+3124]

; 5841 : }

	ret	4
$LN1@IsEverFrie:

; 5836 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5837 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5838 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 5841 : }

	ret	4
?IsEverFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsEverFriends
_TEXT	ENDS
PUBLIC	?SetEverFriends@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::SetEverFriends
; Function compile flags: /Ogtpy
;	COMDAT ?SetEverFriends@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetEverFriends@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z PROC ; CvMinorCivAI::SetEverFriends, COMDAT
; _this$ = ecx

; 5846 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5847 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5848 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetEverFri

; 5849 : 
; 5850 : 	m_abEverFriends[ePlayer] = bValue;

	mov	dl, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [eax+ecx+3124], dl
$LN1@SetEverFri:

; 5851 : }

	ret	8
?SetEverFriends@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ENDP ; CvMinorCivAI::SetEverFriends
_TEXT	ENDS
PUBLIC	?IsMajorIntruding@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsMajorIntruding
; Function compile flags: /Ogtpy
;	COMDAT ?IsMajorIntruding@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsMajorIntruding@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsMajorIntruding, COMDAT
; _this$ = ecx

; 6443 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6444 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6445 : 	if(eMajor< 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@IsMajorInt

; 6446 : 
; 6447 : 	return m_abMajorIntruding[eMajor];

	mov	al, BYTE PTR [eax+ecx+3102]

; 6448 : }

	ret	4
$LN1@IsMajorInt:

; 6443 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6444 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6445 : 	if(eMajor< 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 6448 : }

	ret	4
?IsMajorIntruding@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsMajorIntruding
_TEXT	ENDS
PUBLIC	?SetMajorIntruding@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::SetMajorIntruding
; Function compile flags: /Ogtpy
;	COMDAT ?SetMajorIntruding@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetMajorIntruding@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z PROC ; CvMinorCivAI::SetMajorIntruding, COMDAT
; _this$ = ecx

; 6452 : {

	push	esi

; 6453 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6454 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6455 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	esi, DWORD PTR _eMajor$[esp]
	cmp	esi, 21					; 00000015H
	ja	SHORT $LN2@SetMajorIn

; 6456 : 
; 6457 : 	if(IsMajorIntruding(eMajor) != bValue)

	mov	al, BYTE PTR [esi+ecx+3102]
	mov	dl, BYTE PTR _bValue$[esp]
	cmp	al, dl
	je	SHORT $LN2@SetMajorIn

; 6458 : 	{
; 6459 : 		m_abMajorIntruding[eMajor] = bValue;

	mov	BYTE PTR [esi+ecx+3102], dl
$LN2@SetMajorIn:
	pop	esi

; 6460 : 	}
; 6461 : }

	ret	8
?SetMajorIntruding@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ENDP ; CvMinorCivAI::SetMajorIntruding
_TEXT	ENDS
PUBLIC	?IsProtectedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsProtectedByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsProtectedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsProtectedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsProtectedByMajor, COMDAT
; _this$ = ecx

; 6628 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6629 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6630 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@IsProtecte

; 6631 : 
; 6632 : 	return m_abPledgeToProtect[eMajor];

	mov	al, BYTE PTR [eax+ecx+3146]

; 6633 : }

	ret	4
$LN1@IsProtecte:

; 6628 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6629 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6630 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 6633 : }

	ret	4
?IsProtectedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsProtectedByMajor
_TEXT	ENDS
PUBLIC	?IsProtectedByAnyMajor@CvMinorCivAI@@QBE_NXZ	; CvMinorCivAI::IsProtectedByAnyMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsProtectedByAnyMajor@CvMinorCivAI@@QBE_NXZ
_TEXT	SEGMENT
?IsProtectedByAnyMajor@CvMinorCivAI@@QBE_NXZ PROC	; CvMinorCivAI::IsProtectedByAnyMajor, COMDAT
; _this$ = ecx

; 6637 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	eax, eax
$LL4@IsProtecte@2:

; 6638 : 		if(IsProtectedByMajor((PlayerTypes)iPlayerLoop))

	cmp	eax, 21					; 00000015H
	ja	SHORT $LN14@IsProtecte@2
	cmp	BYTE PTR [eax+ecx+3146], 0
	jne	SHORT $LN12@IsProtecte@2
$LN14@IsProtecte@2:

; 6637 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	eax
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL4@IsProtecte@2

; 6640 : 	return false;

	xor	al, al

; 6641 : }

	ret	0
$LN12@IsProtecte@2:

; 6639 : 			return true;

	mov	al, 1

; 6641 : }

	ret	0
?IsProtectedByAnyMajor@CvMinorCivAI@@QBE_NXZ ENDP	; CvMinorCivAI::IsProtectedByAnyMajor
_TEXT	ENDS
PUBLIC	?GetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetTurnLastPledgedProtectionByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?GetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetTurnLastPledgedProtectionByMajor, COMDAT
; _this$ = ecx

; 6645 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6646 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6647 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetTurnLas

; 6648 : 
; 6649 : 	return m_aiTurnLastPledged[eMajor];

	mov	eax, DWORD PTR [ecx+eax*4+2904]

; 6650 : }

	ret	4
$LN1@GetTurnLas:

; 6645 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6646 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6647 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	or	eax, -1

; 6650 : }

	ret	4
?GetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetTurnLastPledgedProtectionByMajor
_TEXT	ENDS
PUBLIC	?SetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetTurnLastPledgedProtectionByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_iTurn$ = 12						; size = 4
?SetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetTurnLastPledgedProtectionByMajor, COMDAT
; _this$ = ecx

; 6654 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6655 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6656 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetTurnLas

; 6657 : 
; 6658 : 	m_aiTurnLastPledged[eMajor] = iTurn;

	mov	edx, DWORD PTR _iTurn$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2904], edx
$LN1@SetTurnLas:

; 6659 : }

	ret	8
?SetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetTurnLastPledgedProtectionByMajor
_TEXT	ENDS
PUBLIC	?GetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetTurnLastPledgeBrokenByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?GetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetTurnLastPledgeBrokenByMajor, COMDAT
; _this$ = ecx

; 6663 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6664 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6665 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetTurnLas@2

; 6666 : 
; 6667 : 	return m_aiTurnLastBrokePledge[eMajor];

	mov	eax, DWORD PTR [ecx+eax*4+2992]

; 6668 : }

	ret	4
$LN1@GetTurnLas@2:

; 6663 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6664 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6665 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	or	eax, -1

; 6668 : }

	ret	4
?GetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetTurnLastPledgeBrokenByMajor
_TEXT	ENDS
PUBLIC	?SetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetTurnLastPledgeBrokenByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_iTurn$ = 12						; size = 4
?SetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetTurnLastPledgeBrokenByMajor, COMDAT
; _this$ = ecx

; 6672 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6673 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6674 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetTurnLas@2

; 6675 : 
; 6676 : 	m_aiTurnLastBrokePledge[eMajor] = iTurn;

	mov	edx, DWORD PTR _iTurn$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2992], edx
$LN1@SetTurnLas@2:

; 6677 : }

	ret	8
?SetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetTurnLastPledgeBrokenByMajor
_TEXT	ENDS
PUBLIC	?GetCulturePerBuildingFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCulturePerBuildingFriendshipBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePerBuildingFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetCulturePerBuildingFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetCulturePerBuildingFriendshipBonus, COMDAT
; _this$ = ecx

; 6984 : 	return 0;

	xor	eax, eax

; 6985 : }

	ret	8
?GetCulturePerBuildingFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetCulturePerBuildingFriendshipBonus
_TEXT	ENDS
PUBLIC	?GetCulturePerBuildingAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCulturePerBuildingAlliesBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePerBuildingAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetCulturePerBuildingAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetCulturePerBuildingAlliesBonus, COMDAT
; _this$ = ecx

; 6991 : 	return 0;

	xor	eax, eax

; 6992 : }

	ret	8
?GetCulturePerBuildingAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetCulturePerBuildingAlliesBonus
_TEXT	ENDS
PUBLIC	?GetUnitSpawnCounter@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetUnitSpawnCounter
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitSpawnCounter@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetUnitSpawnCounter@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetUnitSpawnCounter, COMDAT
; _this$ = ecx

; 7545 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7546 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7547 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // as defined during Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetUnitSpa

; 7548 : 
; 7549 : 	return m_aiUnitSpawnCounter[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2552]

; 7550 : }

	ret	4
$LN1@GetUnitSpa:

; 7545 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7546 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7547 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // as defined during Reset()

	or	eax, -1

; 7550 : }

	ret	4
?GetUnitSpawnCounter@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetUnitSpawnCounter
_TEXT	ENDS
PUBLIC	?SetUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetUnitSpawnCounter
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetUnitSpawnCounter, COMDAT
; _this$ = ecx

; 7555 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7556 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7557 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetUnitSpa

; 7558 : 
; 7559 : 	m_aiUnitSpawnCounter[ePlayer] = iValue;

	mov	edx, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2552], edx
$LN1@SetUnitSpa:

; 7560 : }

	ret	8
?SetUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetUnitSpawnCounter
_TEXT	ENDS
PUBLIC	?ChangeUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::ChangeUnitSpawnCounter
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::ChangeUnitSpawnCounter, COMDAT
; _this$ = ecx

; 7565 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7566 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7567 : 
; 7568 : 	SetUnitSpawnCounter(ePlayer, GetUnitSpawnCounter(ePlayer) + iChange);

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN3@ChangeUnit
	mov	edx, DWORD PTR [ecx+eax*4+2552]
	jmp	SHORT $LN5@ChangeUnit
$LN3@ChangeUnit:
	or	edx, -1
$LN5@ChangeUnit:
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN7@ChangeUnit
	push	esi
	mov	esi, DWORD PTR _iChange$[esp]
	add	edx, esi
	mov	DWORD PTR [ecx+eax*4+2552], edx
	pop	esi
$LN7@ChangeUnit:

; 7569 : }

	ret	8
?ChangeUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::ChangeUnitSpawnCounter
_TEXT	ENDS
PUBLIC	?IsUnitSpawningDisabled@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsUnitSpawningDisabled
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnitSpawningDisabled@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsUnitSpawningDisabled@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsUnitSpawningDisabled, COMDAT
; _this$ = ecx

; 7604 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7605 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7606 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@IsUnitSpaw

; 7607 : 
; 7608 : 	return m_abUnitSpawningDisabled[ePlayer];

	mov	al, BYTE PTR [eax+ecx+3080]

; 7609 : }

	ret	4
$LN1@IsUnitSpaw:

; 7604 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7605 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7606 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 7609 : }

	ret	4
?IsUnitSpawningDisabled@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsUnitSpawningDisabled
_TEXT	ENDS
PUBLIC	?SetUnitSpawningDisabled@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::SetUnitSpawningDisabled
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnitSpawningDisabled@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUnitSpawningDisabled@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z PROC ; CvMinorCivAI::SetUnitSpawningDisabled, COMDAT
; _this$ = ecx

; 7614 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7615 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7616 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetUnitSpa@2

; 7617 : 
; 7618 : 	m_abUnitSpawningDisabled[ePlayer] = bValue;

	mov	dl, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [eax+ecx+3080], dl
$LN1@SetUnitSpa@2:

; 7619 : }

	ret	8
?SetUnitSpawningDisabled@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ENDP ; CvMinorCivAI::SetUnitSpawningDisabled
_TEXT	ENDS
PUBLIC	?GetMajorBoughtOutBy@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMajorBoughtOutBy
; Function compile flags: /Ogtpy
;	COMDAT ?GetMajorBoughtOutBy@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetMajorBoughtOutBy@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ PROC ; CvMinorCivAI::GetMajorBoughtOutBy, COMDAT
; _this$ = ecx

; 7825 : 	return m_eMajorBoughtOutBy;

	mov	eax, DWORD PTR [ecx+2020]

; 7826 : }

	ret	0
?GetMajorBoughtOutBy@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ENDP ; CvMinorCivAI::GetMajorBoughtOutBy
_TEXT	ENDS
PUBLIC	?SetMajorBoughtOutBy@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::SetMajorBoughtOutBy
; Function compile flags: /Ogtpy
;	COMDAT ?SetMajorBoughtOutBy@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?SetMajorBoughtOutBy@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::SetMajorBoughtOutBy, COMDAT
; _this$ = ecx

; 7831 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 7832 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 7833 : 
; 7834 : 	m_eMajorBoughtOutBy = eMajor;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	mov	DWORD PTR [ecx+2020], eax

; 7835 : }

	ret	4
?SetMajorBoughtOutBy@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::SetMajorBoughtOutBy
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?IsEverBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsEverBulliedByMajor
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?IsEverBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsEverBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsEverBulliedByMajor, COMDAT
; _this$ = ecx

; 8719 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8720 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8721 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@IsEverBull

; 8722 : 
; 8723 : 	return (m_aiTurnLastBullied[ePlayer] >= 0); // -1 means never bullied

	xor	edx, edx
	cmp	DWORD PTR [ecx+eax*4+2816], edx
	setge	dl
	mov	al, dl

; 8724 : }

	ret	4
$LN1@IsEverBull:

; 8719 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8720 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8721 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 8724 : }

	ret	4
?IsEverBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsEverBulliedByMajor
_TEXT	ENDS
PUBLIC	?GetTurnLastBulliedByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetTurnLastBulliedByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnLastBulliedByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetTurnLastBulliedByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetTurnLastBulliedByMajor, COMDAT
; _this$ = ecx

; 8756 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8757 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8758 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetTurnLas@3

; 8759 : 
; 8760 : 	return m_aiTurnLastBullied[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2816]

; 8761 : }

	ret	4
$LN1@GetTurnLas@3:

; 8756 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8757 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8758 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;

	or	eax, -1

; 8761 : }

	ret	4
?GetTurnLastBulliedByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetTurnLastBulliedByMajor
_TEXT	ENDS
PUBLIC	?SetTurnLastBulliedByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetTurnLastBulliedByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnLastBulliedByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iTurn$ = 12						; size = 4
?SetTurnLastBulliedByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetTurnLastBulliedByMajor, COMDAT
; _this$ = ecx

; 8765 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8766 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8767 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetTurnLas@3

; 8768 : 
; 8769 : 	m_aiTurnLastBullied[ePlayer] = iTurn;

	mov	edx, DWORD PTR _iTurn$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2816], edx
$LN1@SetTurnLas@3:

; 8770 : }

	ret	8
?SetTurnLastBulliedByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetTurnLastBulliedByMajor
_TEXT	ENDS
PUBLIC	??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ; CvPopupInfo::CvPopupInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z
_TEXT	SEGMENT
_buttonPopupType$ = 8					; size = 4
_data1$ = 12						; size = 4
_data2$ = 16						; size = 4
_data3$ = 20						; size = 4
_flags$ = 24						; size = 4
_option1$ = 28						; size = 1
_option2$ = 32						; size = 1
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z PROC	; CvPopupInfo::CvPopupInfo, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	edx, DWORD PTR _data2$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _data1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _data3$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _flags$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _option1$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _option2$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _buttonPopupType$[esp-4]
	mov	BYTE PTR [eax+17], dl
	mov	DWORD PTR [eax+20], ecx

; 120  : 		//Nothing
; 121  : 		szText[0] = 0;

	mov	BYTE PTR [eax+24], 0

; 122  : 	}

	ret	28					; 0000001cH
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ENDP	; CvPopupInfo::CvPopupInfo
_TEXT	ENDS
PUBLIC	?GetNumUnitsGifted@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumUnitsGifted
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?GetNumUnitsGifted@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumUnitsGifted@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNumUnitsGifted, COMDAT
; _this$ = ecx

; 8935 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8936 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8937 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // as defined during Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetNumUnit

; 8938 : 
; 8939 : 	return m_aiNumUnitsGifted[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2640]

; 8940 : }

	ret	4
$LN1@GetNumUnit:

; 8935 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8936 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8937 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1; // as defined during Reset()

	or	eax, -1

; 8940 : }

	ret	4
?GetNumUnitsGifted@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNumUnitsGifted
_TEXT	ENDS
PUBLIC	?SetNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetNumUnitsGifted
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetNumUnitsGifted, COMDAT
; _this$ = ecx

; 8945 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8946 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8947 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetNumUnit

; 8948 : 
; 8949 : 	m_aiNumUnitsGifted[ePlayer] = iValue;

	mov	edx, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2640], edx
$LN1@SetNumUnit:

; 8950 : }

	ret	8
?SetNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetNumUnitsGifted
_TEXT	ENDS
PUBLIC	?ChangeNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::ChangeNumUnitsGifted
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::ChangeNumUnitsGifted, COMDAT
; _this$ = ecx

; 8955 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8956 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8957 : 
; 8958 : 	SetNumUnitsGifted(ePlayer, GetNumUnitsGifted(ePlayer) + iChange);

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN3@ChangeNumU
	mov	edx, DWORD PTR [ecx+eax*4+2640]
	jmp	SHORT $LN5@ChangeNumU
$LN3@ChangeNumU:
	or	edx, -1
$LN5@ChangeNumU:
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN7@ChangeNumU
	push	esi
	mov	esi, DWORD PTR _iChange$[esp]
	add	edx, esi
	mov	DWORD PTR [ecx+eax*4+2640], edx
	pop	esi
$LN7@ChangeNumU:

; 8959 : }

	ret	8
?ChangeNumUnitsGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::ChangeNumUnitsGifted
_TEXT	ENDS
PUBLIC	?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumGoldGifted
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNumGoldGifted, COMDAT
; _this$ = ecx

; 9025 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9026 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9027 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;  // as defined in Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetNumGold

; 9028 : 	return m_aiNumGoldGifted[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+2728]

; 9029 : }

	ret	4
$LN1@GetNumGold:

; 9025 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9026 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9027 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;  // as defined in Reset()

	xor	eax, eax

; 9029 : }

	ret	4
?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNumGoldGifted
_TEXT	ENDS
PUBLIC	?SetNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetNumGoldGifted
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetNumGoldGifted, COMDAT
; _this$ = ecx

; 9033 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9034 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9035 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetNumGold

; 9036 : 	m_aiNumGoldGifted[ePlayer] = iValue;

	mov	edx, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+eax*4+2728], edx
$LN1@SetNumGold:

; 9037 : }

	ret	8
?SetNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetNumGoldGifted
_TEXT	ENDS
PUBLIC	?ChangeNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::ChangeNumGoldGifted
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::ChangeNumGoldGifted, COMDAT
; _this$ = ecx

; 9041 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9042 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9043 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN9@ChangeNumG

; 9044 : 	SetNumGoldGifted(ePlayer, GetNumGoldGifted(ePlayer) + iChange);

	mov	edx, DWORD PTR [ecx+eax*4+2728]
	push	esi
	mov	esi, DWORD PTR _iChange$[esp]
	add	edx, esi
	mov	DWORD PTR [ecx+eax*4+2728], edx
	pop	esi
$LN9@ChangeNumG:

; 9045 : }

	ret	8
?ChangeNumGoldGifted@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::ChangeNumGoldGifted
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator@2

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator@2:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	?IsInfluenceTooLowForPeace@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsInfluenceTooLowForPeace
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?IsInfluenceTooLowForPeace@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsInfluenceTooLowForPeace@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsInfluenceTooLowForPeace, COMDAT
; _this$ = ecx

; 9437 : 	return GetBaseFriendshipWithMajor(ePlayer) < -50;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN5@IsInfluenc
	mov	ecx, DWORD PTR [ecx+eax*4+2024]
	jmp	SHORT $LN7@IsInfluenc
$LN5@IsInfluenc:
	xor	ecx, ecx
$LN7@IsInfluenc:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	cmp	eax, -50				; ffffffceH
	setl	cl
	mov	al, cl

; 9438 : }

	ret	4
?IsInfluenceTooLowForPeace@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsInfluenceTooLowForPeace
_TEXT	ENDS
PUBLIC	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
; Function compile flags: /Ogtpy
;	COMDAT ?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z PROC	; CvMinorCivAI::IsPermanentWar, COMDAT
; _this$ = ecx

; 9624 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9625 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9626 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return false;

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@IsPermanen

; 9627 : 
; 9628 : 	return m_abPermanentWar[eTeam];

	mov	al, BYTE PTR [eax+ecx+3168]

; 9629 : }

	ret	4
$LN1@IsPermanen:

; 9624 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9625 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9626 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return false;

	xor	al, al

; 9629 : }

	ret	4
?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ENDP	; CvMinorCivAI::IsPermanentWar
_TEXT	ENDS
PUBLIC	?SetPermanentWar@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ; CvMinorCivAI::SetPermanentWar
; Function compile flags: /Ogtpy
;	COMDAT ?SetPermanentWar@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetPermanentWar@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z PROC ; CvMinorCivAI::SetPermanentWar, COMDAT
; _this$ = ecx

; 9634 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9635 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9636 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return;
; 9637 : 
; 9638 : 	if(ENABLE_PERMANENT_WAR)
; 9639 : 		m_abPermanentWar[eTeam] = bValue;
; 9640 : }

	ret	8
?SetPermanentWar@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ENDP ; CvMinorCivAI::SetPermanentWar
_TEXT	ENDS
PUBLIC	?IsWaryOfTeam@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsWaryOfTeam
; Function compile flags: /Ogtpy
;	COMDAT ?IsWaryOfTeam@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsWaryOfTeam@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z PROC	; CvMinorCivAI::IsWaryOfTeam, COMDAT
; _this$ = ecx

; 9645 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9646 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9647 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return false;

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@IsWaryOfTe

; 9648 : 
; 9649 : 	return m_abWaryOfTeam[eTeam];

	mov	al, BYTE PTR [eax+ecx+3248]

; 9650 : }

	ret	4
$LN1@IsWaryOfTe:

; 9645 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9646 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9647 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return false;

	xor	al, al

; 9650 : }

	ret	4
?IsWaryOfTeam@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ENDP	; CvMinorCivAI::IsWaryOfTeam
_TEXT	ENDS
PUBLIC	?SetWaryOfTeam@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ; CvMinorCivAI::SetWaryOfTeam
; Function compile flags: /Ogtpy
;	COMDAT ?SetWaryOfTeam@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetWaryOfTeam@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z PROC	; CvMinorCivAI::SetWaryOfTeam, COMDAT
; _this$ = ecx

; 9654 : {

	push	esi

; 9655 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9656 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9657 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return;

	mov	esi, DWORD PTR _eTeam$[esp]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN2@SetWaryOfT

; 9658 : 
; 9659 : 	if(IsWaryOfTeam(eTeam) == bValue)

	mov	al, BYTE PTR [esi+ecx+3248]
	mov	dl, BYTE PTR _bValue$[esp]
	cmp	al, dl
	je	SHORT $LN2@SetWaryOfT

; 9660 : 		return;
; 9661 : 
; 9662 : 	m_abWaryOfTeam[eTeam] = bValue;

	mov	BYTE PTR [esi+ecx+3248], dl
$LN2@SetWaryOfT:
	pop	esi

; 9663 : }

	ret	8
?SetWaryOfTeam@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ENDP	; CvMinorCivAI::SetWaryOfTeam
_TEXT	ENDS
PUBLIC	?GetMajorScratchPad@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetMajorScratchPad
; Function compile flags: /Ogtpy
;	COMDAT ?GetMajorScratchPad@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetMajorScratchPad@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetMajorScratchPad, COMDAT
; _this$ = ecx

; 10142: 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 10143: 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 10144: 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetMajorSc

; 10145: 	return m_aiMajorScratchPad[ePlayer];

	mov	eax, DWORD PTR [ecx+eax*4+6776]

; 10146: }

	ret	4
$LN1@GetMajorSc:

; 10142: 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 10143: 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 10144: 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	xor	eax, eax

; 10146: }

	ret	4
?GetMajorScratchPad@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetMajorScratchPad
_TEXT	ENDS
PUBLIC	?SetMajorScratchPad@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetMajorScratchPad
; Function compile flags: /Ogtpy
;	COMDAT ?SetMajorScratchPad@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iNum$ = 12						; size = 4
?SetMajorScratchPad@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::SetMajorScratchPad, COMDAT
; _this$ = ecx

; 10151: 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 10152: 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 10153: 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@SetMajorSc

; 10154: 
; 10155: 	m_aiMajorScratchPad[ePlayer] = iNum;

	mov	edx, DWORD PTR _iNum$[esp-4]
	mov	DWORD PTR [ecx+eax*4+6776], edx
$LN1@SetMajorSc:

; 10156: }

	ret	8
?SetMajorScratchPad@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::SetMajorScratchPad
_TEXT	ENDS
PUBLIC	?IsDisableNotifications@CvMinorCivAI@@QBE_NXZ	; CvMinorCivAI::IsDisableNotifications
; Function compile flags: /Ogtpy
;	COMDAT ?IsDisableNotifications@CvMinorCivAI@@QBE_NXZ
_TEXT	SEGMENT
?IsDisableNotifications@CvMinorCivAI@@QBE_NXZ PROC	; CvMinorCivAI::IsDisableNotifications, COMDAT
; _this$ = ecx

; 10161: 	return m_bDisableNotifications;

	mov	al, BYTE PTR [ecx+6864]

; 10162: }

	ret	0
?IsDisableNotifications@CvMinorCivAI@@QBE_NXZ ENDP	; CvMinorCivAI::IsDisableNotifications
_TEXT	ENDS
PUBLIC	?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z	; CvMinorCivAI::SetDisableNotifications
; Function compile flags: /Ogtpy
;	COMDAT ?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z
_TEXT	SEGMENT
_bDisableNotifications$ = 8				; size = 1
?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z PROC	; CvMinorCivAI::SetDisableNotifications, COMDAT
; _this$ = ecx

; 10167: 	if (m_bDisableNotifications != bDisableNotifications)

	mov	al, BYTE PTR _bDisableNotifications$[esp-4]
	cmp	BYTE PTR [ecx+6864], al
	je	SHORT $LN1@SetDisable

; 10168: 	{
; 10169: 		m_bDisableNotifications = bDisableNotifications;

	mov	BYTE PTR [ecx+6864], al
$LN1@SetDisable:

; 10170: 	}
; 10171: }

	ret	4
?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z ENDP	; CvMinorCivAI::SetDisableNotifications
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?getDefaultPlayerColor@CvMinorCivInfo@@QBEHXZ	; CvMinorCivInfo::getDefaultPlayerColor
; Function compile flags: /Ogtpy
;	COMDAT ?getDefaultPlayerColor@CvMinorCivInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefaultPlayerColor@CvMinorCivInfo@@QBEHXZ PROC	; CvMinorCivInfo::getDefaultPlayerColor, COMDAT
; _this$ = ecx

; 10196: 	return m_iDefaultPlayerColor;

	mov	eax, DWORD PTR [ecx+260]

; 10197: }

	ret	0
?getDefaultPlayerColor@CvMinorCivInfo@@QBEHXZ ENDP	; CvMinorCivInfo::getDefaultPlayerColor
_TEXT	ENDS
PUBLIC	?getArtStyleType@CvMinorCivInfo@@QBEHXZ		; CvMinorCivInfo::getArtStyleType
; Function compile flags: /Ogtpy
;	COMDAT ?getArtStyleType@CvMinorCivInfo@@QBEHXZ
_TEXT	SEGMENT
?getArtStyleType@CvMinorCivInfo@@QBEHXZ PROC		; CvMinorCivInfo::getArtStyleType, COMDAT
; _this$ = ecx

; 10201: 	return m_iArtStyleType;

	mov	eax, DWORD PTR [ecx+264]

; 10202: }

	ret	0
?getArtStyleType@CvMinorCivInfo@@QBEHXZ ENDP		; CvMinorCivInfo::getArtStyleType
_TEXT	ENDS
PUBLIC	?getArtStylePrefix@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getArtStylePrefix
; Function compile flags: /Ogtpy
;	COMDAT ?getArtStylePrefix@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtStylePrefix@CvMinorCivInfo@@QBEPBDXZ PROC	; CvMinorCivInfo::getArtStylePrefix, COMDAT
; _this$ = ecx

; 10206: 	return m_strArtStylePrefix.c_str();

	add	ecx, 308				; 00000134H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtStylePrefix@CvMinorCivInfo@@QBEPBDXZ ENDP	; CvMinorCivInfo::getArtStylePrefix
_TEXT	ENDS
PUBLIC	?getArtStyleSuffix@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getArtStyleSuffix
; Function compile flags: /Ogtpy
;	COMDAT ?getArtStyleSuffix@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtStyleSuffix@CvMinorCivInfo@@QBEPBDXZ PROC	; CvMinorCivInfo::getArtStyleSuffix, COMDAT
; _this$ = ecx

; 10211: 	return m_strArtStyleSuffix.c_str();

	add	ecx, 336				; 00000150H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtStyleSuffix@CvMinorCivInfo@@QBEPBDXZ ENDP	; CvMinorCivInfo::getArtStyleSuffix
_TEXT	ENDS
PUBLIC	?getShortDescription@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getShortDescription
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDescription@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescription@CvMinorCivInfo@@QBEPBDXZ PROC	; CvMinorCivInfo::getShortDescription, COMDAT
; _this$ = ecx

; 10221: 	return m_wstrShortDescription.c_str();

	add	ecx, 392				; 00000188H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescription@CvMinorCivInfo@@QBEPBDXZ ENDP	; CvMinorCivInfo::getShortDescription
_TEXT	ENDS
PUBLIC	?getShortDescriptionKey@CvMinorCivInfo@@QBEPBDXZ ; CvMinorCivInfo::getShortDescriptionKey
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDescriptionKey@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescriptionKey@CvMinorCivInfo@@QBEPBDXZ PROC	; CvMinorCivInfo::getShortDescriptionKey, COMDAT
; _this$ = ecx

; 10226: 	return m_strShortDescriptionKey.c_str();

	add	ecx, 364				; 0000016cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescriptionKey@CvMinorCivInfo@@QBEPBDXZ ENDP	; CvMinorCivInfo::getShortDescriptionKey
_TEXT	ENDS
PUBLIC	?getShortDescriptionKeyWide@CvMinorCivInfo@@QBEPBDXZ ; CvMinorCivInfo::getShortDescriptionKeyWide
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDescriptionKeyWide@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescriptionKeyWide@CvMinorCivInfo@@QBEPBDXZ PROC ; CvMinorCivInfo::getShortDescriptionKeyWide, COMDAT
; _this$ = ecx

; 10231: 	return m_wstrShortDescriptionKey.c_str();

	add	ecx, 504				; 000001f8H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescriptionKeyWide@CvMinorCivInfo@@QBEPBDXZ ENDP ; CvMinorCivInfo::getShortDescriptionKeyWide
_TEXT	ENDS
PUBLIC	?getAdjective@CvMinorCivInfo@@QBEPBDXZ		; CvMinorCivInfo::getAdjective
; Function compile flags: /Ogtpy
;	COMDAT ?getAdjective@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAdjective@CvMinorCivInfo@@QBEPBDXZ PROC		; CvMinorCivInfo::getAdjective, COMDAT
; _this$ = ecx

; 10243: 	return m_wstrAdjective.c_str();

	add	ecx, 448				; 000001c0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAdjective@CvMinorCivInfo@@QBEPBDXZ ENDP		; CvMinorCivInfo::getAdjective
_TEXT	ENDS
PUBLIC	?getAdjectiveKey@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getAdjectiveKey
; Function compile flags: /Ogtpy
;	COMDAT ?getAdjectiveKey@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAdjectiveKey@CvMinorCivInfo@@QBEPBDXZ PROC		; CvMinorCivInfo::getAdjectiveKey, COMDAT
; _this$ = ecx

; 10248: 	return m_strAdjectiveKey.c_str();

	add	ecx, 420				; 000001a4H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAdjectiveKey@CvMinorCivInfo@@QBEPBDXZ ENDP		; CvMinorCivInfo::getAdjectiveKey
_TEXT	ENDS
PUBLIC	?getAdjectiveKeyWide@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getAdjectiveKeyWide
; Function compile flags: /Ogtpy
;	COMDAT ?getAdjectiveKeyWide@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAdjectiveKeyWide@CvMinorCivInfo@@QBEPBDXZ PROC	; CvMinorCivInfo::getAdjectiveKeyWide, COMDAT
; _this$ = ecx

; 10253: 	return m_wstrAdjectiveKey.c_str();

	add	ecx, 476				; 000001dcH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAdjectiveKeyWide@CvMinorCivInfo@@QBEPBDXZ ENDP	; CvMinorCivInfo::getAdjectiveKeyWide
_TEXT	ENDS
PUBLIC	?getFlagTexture@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getFlagTexture
; Function compile flags: /Ogtpy
;	COMDAT ?getFlagTexture@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getFlagTexture@CvMinorCivInfo@@QBEPBDXZ PROC		; CvMinorCivInfo::getFlagTexture, COMDAT
; _this$ = ecx

; 10265: 	return NULL;

	xor	eax, eax

; 10266: }

	ret	0
?getFlagTexture@CvMinorCivInfo@@QBEPBDXZ ENDP		; CvMinorCivInfo::getFlagTexture
_TEXT	ENDS
PUBLIC	?getArtDefineTag@CvMinorCivInfo@@QBEPBDXZ	; CvMinorCivInfo::getArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTag@CvMinorCivInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTag@CvMinorCivInfo@@QBEPBDXZ PROC		; CvMinorCivInfo::getArtDefineTag, COMDAT
; _this$ = ecx

; 10270: 	return m_strArtDefineTag;

	add	ecx, 280				; 00000118H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTag@CvMinorCivInfo@@QBEPBDXZ ENDP		; CvMinorCivInfo::getArtDefineTag
_TEXT	ENDS
PUBLIC	?setArtDefineTag@CvMinorCivInfo@@QAEXPBD@Z	; CvMinorCivInfo::setArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTag@CvMinorCivInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtDefineTag@CvMinorCivInfo@@QAEXPBD@Z PROC		; CvMinorCivInfo::setArtDefineTag, COMDAT
; _this$ = ecx

; 10275: 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 280				; 00000118H
	test	eax, eax
	je	SHORT $LN4@setArtDefi
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 10276: }

	ret	4
?setArtDefineTag@CvMinorCivInfo@@QAEXPBD@Z ENDP		; CvMinorCivInfo::setArtDefineTag
_TEXT	ENDS
PUBLIC	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ	; CvMinorCivInfo::GetMinorCivTrait
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ
_TEXT	SEGMENT
?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ PROC		; CvMinorCivInfo::GetMinorCivTrait, COMDAT
; _this$ = ecx

; 10280: 	return m_iMinorCivTrait;

	mov	eax, DWORD PTR [ecx+272]

; 10281: }

	ret	0
?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ ENDP		; CvMinorCivInfo::GetMinorCivTrait
_TEXT	ENDS
PUBLIC	?getFlavorValue@CvMinorCivInfo@@QBEHH@Z		; CvMinorCivInfo::getFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorValue@CvMinorCivInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFlavorValue@CvMinorCivInfo@@QBEHH@Z PROC		; CvMinorCivInfo::getFlavorValue, COMDAT
; _this$ = ecx

; 10285: 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 10286: 	CvAssertMsg(i > -1, "Index out of bounds");
; 10287: 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR [ecx+532]
	test	eax, eax
	je	SHORT $LN3@getFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 10288: }

	ret	4
$LN3@getFlavorV:

; 10285: 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 10286: 	CvAssertMsg(i > -1, "Index out of bounds");
; 10287: 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	xor	eax, eax

; 10288: }

	ret	4
?getFlavorValue@CvMinorCivInfo@@QBEHH@Z ENDP		; CvMinorCivInfo::getFlavorValue
_TEXT	ENDS
PUBLIC	?setArtStylePrefix@CvMinorCivInfo@@QAEXPBD@Z	; CvMinorCivInfo::setArtStylePrefix
; Function compile flags: /Ogtpy
;	COMDAT ?setArtStylePrefix@CvMinorCivInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtStylePrefix@CvMinorCivInfo@@QAEXPBD@Z PROC	; CvMinorCivInfo::setArtStylePrefix, COMDAT
; _this$ = ecx

; 10297: 	m_strArtStylePrefix = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 308				; 00000134H
	test	eax, eax
	je	SHORT $LN4@setArtStyl
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtStyl:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 10298: }

	ret	4
?setArtStylePrefix@CvMinorCivInfo@@QAEXPBD@Z ENDP	; CvMinorCivInfo::setArtStylePrefix
_TEXT	ENDS
PUBLIC	?setArtStyleSuffix@CvMinorCivInfo@@QAEXPBD@Z	; CvMinorCivInfo::setArtStyleSuffix
; Function compile flags: /Ogtpy
;	COMDAT ?setArtStyleSuffix@CvMinorCivInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtStyleSuffix@CvMinorCivInfo@@QAEXPBD@Z PROC	; CvMinorCivInfo::setArtStyleSuffix, COMDAT
; _this$ = ecx

; 10302: 	m_strArtStyleSuffix = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 336				; 00000150H
	test	eax, eax
	je	SHORT $LN4@setArtStyl@2
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtStyl@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 10303: }

	ret	4
?setArtStyleSuffix@CvMinorCivInfo@@QAEXPBD@Z ENDP	; CvMinorCivInfo::setArtStyleSuffix
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescriptionKey
; Function compile flags: /Ogtpy
;	COMDAT ?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescriptionKey, COMDAT
; _this$ = ecx

; 69   : 		return m_strDescriptionKey.c_str();

	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescriptionKey
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z ; std::vector<CvString,std::allocator<CvString> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z PROC ; std::vector<CvString,std::allocator<CvString> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 771  : 		}

	ret	4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z ; BaseVector<CvEspionageSpy,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z PROC ; BaseVector<CvEspionageSpy,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z ENDP ; BaseVector<CvEspionageSpy,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z		; Firaxis::Array<int,22>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z PROC		; Firaxis::Array<int,22>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z ENDP		; Firaxis::Array<int,22>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4BuildingTypes@@$00@@QAEAAW4BuildingTypes@@I@Z ; BaseVector<enum BuildingTypes,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@W4BuildingTypes@@$00@@QAEAAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4BuildingTypes@@$00@@QAEAAW4BuildingTypes@@I@Z PROC ; BaseVector<enum BuildingTypes,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4BuildingTypes@@$00@@QAEAAW4BuildingTypes@@I@Z ENDP ; BaseVector<enum BuildingTypes,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4BuildingTypes@@$00@@QBEIXZ	; BaseVector<enum BuildingTypes,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4BuildingTypes@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4BuildingTypes@@$00@@QBEIXZ PROC	; BaseVector<enum BuildingTypes,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4BuildingTypes@@$00@@QBEIXZ ENDP	; BaseVector<enum BuildingTypes,1>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 156				; 0000009cH
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 156				; 0000009cH
	add	eax, DWORD PTR [ecx]

; 137  : 	};

	ret	4
??A?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::begin, COMDAT
; _this$ = ecx

; 201  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 202  :     };

	ret	0
?begin@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::end, COMDAT
; _this$ = ecx

; 204  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	imul	eax, 156				; 0000009cH
	add	eax, DWORD PTR [ecx]

; 205  :     };

	ret	0
?end@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QBEPBV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@XZ ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::end
_TEXT	ENDS
PUBLIC	?erase@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEXPAVCvMinorCivQuest@@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEXPAVCvMinorCivQuest@@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 4
?erase@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEXPAVCvMinorCivQuest@@@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::erase, COMDAT
; _this$ = ecx

; 702  : 	{

	push	ebx
	mov	ebx, ecx

; 703  : 		m_bIsResized = false;
; 704  : 
; 705  : 		unsigned int uIndex = it - m_pData;

	mov	ecx, DWORD PTR _it$[esp]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 706  : 
; 707  :         for(unsigned int i = uIndex; i + 1< m_uiCurrSize; ++i)

	lea	edx, DWORD PTR [ecx+1]
	mov	BYTE PTR [ebx+152], 0
	cmp	edx, DWORD PTR [ebx+4]
	jae	SHORT $LN8@erase
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	add	eax, eax
	push	esi
	add	eax, eax
	push	edi
	npad	6
$LL3@erase:

; 708  :         {
; 709  :             m_pData[i] = m_pData[i+1];

	mov	ecx, DWORD PTR [ebx]
	lea	edi, DWORD PTR [eax+ecx]
	lea	esi, DWORD PTR [edi+28]
	mov	ecx, 7
	inc	edx
	rep movsd
	add	eax, 28					; 0000001cH
	cmp	edx, DWORD PTR [ebx+4]
	jb	SHORT $LL3@erase
	pop	edi
	pop	esi
$LN8@erase:

; 710  :         }
; 711  : 		
; 712  : 		--m_uiCurrSize;

	dec	DWORD PTR [ebx+4]
	pop	ebx

; 713  : 	}

	ret	4
?erase@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEXPAVCvMinorCivQuest@@@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::erase
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEAAVCvMinorCivQuest@@I@Z ; BaseVector<CvMinorCivQuest,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEAAVCvMinorCivQuest@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEAAVCvMinorCivQuest@@I@Z PROC ; BaseVector<CvMinorCivQuest,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEAAVCvMinorCivQuest@@I@Z ENDP ; BaseVector<CvMinorCivQuest,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEABVCvMinorCivQuest@@I@Z ; BaseVector<CvMinorCivQuest,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEABVCvMinorCivQuest@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEABVCvMinorCivQuest@@I@Z PROC ; BaseVector<CvMinorCivQuest,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEABVCvMinorCivQuest@@I@Z ENDP ; BaseVector<CvMinorCivQuest,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEIXZ ; BaseVector<CvMinorCivQuest,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEIXZ PROC	; BaseVector<CvMinorCivQuest,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvMinorCivQuest@@$0A@@@QBEIXZ ENDP	; BaseVector<CvMinorCivQuest,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ ; BaseVector<CvMinorCivQuest,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ PROC ; BaseVector<CvMinorCivQuest,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ ENDP ; BaseVector<CvMinorCivQuest,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ ; BaseVector<CvMinorCivQuest,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ PROC ; BaseVector<CvMinorCivQuest,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEPAVCvMinorCivQuest@@XZ ENDP ; BaseVector<CvMinorCivQuest,0>::end
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z ; BaseVector<enum PlayerTypes,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z PROC ; BaseVector<enum PlayerTypes,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z ENDP ; BaseVector<enum PlayerTypes,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ	; BaseVector<enum PlayerTypes,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ PROC	; BaseVector<enum PlayerTypes,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ ENDP	; BaseVector<enum PlayerTypes,1>::size
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z PROC ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ENDP ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ; std::auto_ptr<ICvCity1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ PROC ; std::auto_ptr<ICvCity1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ENDP ; std::auto_ptr<ICvCity1>::get
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4ResourceTypes@@$00@@QAEAAW4ResourceTypes@@I@Z ; BaseVector<enum ResourceTypes,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@W4ResourceTypes@@$00@@QAEAAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4ResourceTypes@@$00@@QAEAAW4ResourceTypes@@I@Z PROC ; BaseVector<enum ResourceTypes,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4ResourceTypes@@$00@@QAEAAW4ResourceTypes@@I@Z ENDP ; BaseVector<enum ResourceTypes,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4ResourceTypes@@$00@@QBEIXZ	; BaseVector<enum ResourceTypes,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4ResourceTypes@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4ResourceTypes@@$00@@QBEIXZ PROC	; BaseVector<enum ResourceTypes,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4ResourceTypes@@$00@@QBEIXZ ENDP	; BaseVector<enum ResourceTypes,1>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4MinorCivQuestTypes@@$00@@QAEAAW4MinorCivQuestTypes@@I@Z ; BaseVector<enum MinorCivQuestTypes,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@W4MinorCivQuestTypes@@$00@@QAEAAW4MinorCivQuestTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4MinorCivQuestTypes@@$00@@QAEAAW4MinorCivQuestTypes@@I@Z PROC ; BaseVector<enum MinorCivQuestTypes,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4MinorCivQuestTypes@@$00@@QAEAAW4MinorCivQuestTypes@@I@Z ENDP ; BaseVector<enum MinorCivQuestTypes,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4MinorCivQuestTypes@@$00@@QBEIXZ ; BaseVector<enum MinorCivQuestTypes,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4MinorCivQuestTypes@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4MinorCivQuestTypes@@$00@@QBEIXZ PROC ; BaseVector<enum MinorCivQuestTypes,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4MinorCivQuestTypes@@$00@@QBEIXZ ENDP ; BaseVector<enum MinorCivQuestTypes,1>::size
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::size
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4UnitTypes@@$00@@QAEAAW4UnitTypes@@I@Z ; BaseVector<enum UnitTypes,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@W4UnitTypes@@$00@@QAEAAW4UnitTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4UnitTypes@@$00@@QAEAAW4UnitTypes@@I@Z PROC ; BaseVector<enum UnitTypes,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4UnitTypes@@$00@@QAEAAW4UnitTypes@@I@Z ENDP ; BaseVector<enum UnitTypes,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4UnitTypes@@$00@@QBEIXZ	; BaseVector<enum UnitTypes,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4UnitTypes@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4UnitTypes@@$00@@QBEIXZ PROC	; BaseVector<enum UnitTypes,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4UnitTypes@@$00@@QBEIXZ ENDP	; BaseVector<enum UnitTypes,1>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z ; BaseVector<CvCity *,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z PROC ; BaseVector<CvCity *,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z ENDP ; BaseVector<CvCity *,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ	; BaseVector<CvCity *,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ PROC		; BaseVector<CvCity *,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ ENDP		; BaseVector<CvCity *,0>::size
_TEXT	ENDS
PUBLIC	??A?$Array@PAVCvEspionageSpy@@$0BG@@Firaxis@@QAEAAPAVCvEspionageSpy@@I@Z ; Firaxis::Array<CvEspionageSpy *,22>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??A?$Array@PAVCvEspionageSpy@@$0BG@@Firaxis@@QAEAAPAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@PAVCvEspionageSpy@@$0BG@@Firaxis@@QAEAAPAVCvEspionageSpy@@I@Z PROC ; Firaxis::Array<CvEspionageSpy *,22>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@PAVCvEspionageSpy@@$0BG@@Firaxis@@QAEAAPAVCvEspionageSpy@@I@Z ENDP ; Firaxis::Array<CvEspionageSpy *,22>::operator[]
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ; std::auto_ptr<ICvPlot1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ PROC ; std::auto_ptr<ICvPlot1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ENDP ; std::auto_ptr<ICvPlot1>::get
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
PUBLIC	?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xran
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T236193 = -80						; size = 28
$T236192 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xran, COMDAT

; 1264 : 		{	// report an out_of_range error

	push	-1
	push	__ehhandler$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1265 : 		_THROW(out_of_range, "invalid vector<T> subscript");

	push	OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
	lea	ecx, DWORD PTR $T236193[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T236192[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T236193[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T236192[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T236192[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T236192[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T236192[esp+88], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN13@Xran:
$LN12@Xran:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T236193[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T236192[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xran
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::capacity
_TEXT	ENDS
PUBLIC	?getMINOR_BULLY_GOLD@CvGlobals@@QAEHXZ		; CvGlobals::getMINOR_BULLY_GOLD
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_BULLY_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_BULLY_GOLD@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMINOR_BULLY_GOLD, COMDAT
; _this$ = ecx

; 1785 : 		return m_iMINOR_BULLY_GOLD;

	mov	eax, DWORD PTR [ecx+2720]

; 1786 : 	}

	ret	0
?getMINOR_BULLY_GOLD@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMINOR_BULLY_GOLD
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION, COMDAT
; _this$ = ecx

; 1793 : 		return m_iMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION;

	mov	eax, DWORD PTR [ecx+2728]

; 1794 : 	}

	ret	0
?getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_DROP_PER_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_DROP_PER_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_DROP_PER_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN, COMDAT
; _this$ = ecx

; 1797 : 		return m_iMINOR_FRIENDSHIP_DROP_PER_TURN;

	mov	eax, DWORD PTR [ecx+2732]

; 1798 : 	}

	ret	0
?getMINOR_FRIENDSHIP_DROP_PER_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE, COMDAT
; _this$ = ecx

; 1801 : 		return m_iMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE;

	mov	eax, DWORD PTR [ecx+2736]

; 1802 : 	}

	ret	0
?getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR, COMDAT
; _this$ = ecx

; 1805 : 		return m_iMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR;

	mov	eax, DWORD PTR [ecx+2740]

; 1806 : 	}

	ret	0
?getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 1809 : 		return m_iMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+2744]

; 1810 : 	}

	ret	0
?getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS, COMDAT
; _this$ = ecx

; 1813 : 		return m_iMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS;

	mov	eax, DWORD PTR [ecx+2748]

; 1814 : 	}

	ret	0
?getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@XZ		; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvString@@@std@@QAE@XZ PROC		; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvString@@@std@@QAE@XZ ENDP		; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS, COMDAT
; _this$ = ecx

; 1821 : 		return m_iMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS;

	mov	eax, DWORD PTR [ecx+2756]

; 1822 : 	}

	ret	0
?getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN, COMDAT
; _this$ = ecx

; 1829 : 		return m_iMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN;

	mov	eax, DWORD PTR [ecx+2764]

; 1830 : 	}

	ret	0
?getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN
_TEXT	ENDS
PUBLIC	?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::size
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_AT_WAR@CvGlobals@@QAEHXZ	; CvGlobals::getMINOR_FRIENDSHIP_AT_WAR
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_FRIENDSHIP_AT_WAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_AT_WAR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_FRIENDSHIP_AT_WAR, COMDAT
; _this$ = ecx

; 1833 : 		return m_iMINOR_FRIENDSHIP_AT_WAR;

	mov	eax, DWORD PTR [ecx+2768]

; 1834 : 	}

	ret	0
?getMINOR_FRIENDSHIP_AT_WAR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_FRIENDSHIP_AT_WAR
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_AGGRESSOR_CHANCE@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_AGGRESSOR_CHANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_AGGRESSOR_CHANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_AGGRESSOR_CHANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_AGGRESSOR_CHANCE, COMDAT
; _this$ = ecx

; 1845 : 		return m_iPERMANENT_WAR_AGGRESSOR_CHANCE;

	mov	eax, DWORD PTR [ecx+2780]

; 1846 : 	}

	ret	0
?getPERMANENT_WAR_AGGRESSOR_CHANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_AGGRESSOR_CHANCE
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT, COMDAT
; _this$ = ecx

; 1849 : 		return m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT;

	mov	eax, DWORD PTR [ecx+2784]

; 1850 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR, COMDAT
; _this$ = ecx

; 1853 : 		return m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR;

	mov	eax, DWORD PTR [ecx+2788]

; 1854 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE, COMDAT
; _this$ = ecx

; 1857 : 		return m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE;

	mov	eax, DWORD PTR [ecx+2792]

; 1858 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS, COMDAT
; _this$ = ecx

; 1861 : 		return m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS;

	mov	eax, DWORD PTR [ecx+2796]

; 1862 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_CHANCE_DISTANT@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_DISTANT
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_CHANCE_DISTANT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_CHANCE_DISTANT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_DISTANT, COMDAT
; _this$ = ecx

; 1865 : 		return m_iPERMANENT_WAR_OTHER_CHANCE_DISTANT;

	mov	eax, DWORD PTR [ecx+2800]

; 1866 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_CHANCE_DISTANT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_DISTANT
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_CHANCE_FAR@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_FAR
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_CHANCE_FAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_CHANCE_FAR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_FAR, COMDAT
; _this$ = ecx

; 1869 : 		return m_iPERMANENT_WAR_OTHER_CHANCE_FAR;

	mov	eax, DWORD PTR [ecx+2804]

; 1870 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_CHANCE_FAR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_FAR
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_CHANCE_CLOSE@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_CLOSE
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_CHANCE_CLOSE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_CHANCE_CLOSE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_CLOSE, COMDAT
; _this$ = ecx

; 1873 : 		return m_iPERMANENT_WAR_OTHER_CHANCE_CLOSE;

	mov	eax, DWORD PTR [ecx+2808]

; 1874 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_CHANCE_CLOSE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_CLOSE
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS, COMDAT
; _this$ = ecx

; 1877 : 		return m_iPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS;

	mov	eax, DWORD PTR [ecx+2812]

; 1878 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS
_TEXT	ENDS
PUBLIC	?getPERMANENT_WAR_OTHER_AT_WAR@CvGlobals@@QAEHXZ ; CvGlobals::getPERMANENT_WAR_OTHER_AT_WAR
; Function compile flags: /Ogtpy
;	COMDAT ?getPERMANENT_WAR_OTHER_AT_WAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPERMANENT_WAR_OTHER_AT_WAR@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPERMANENT_WAR_OTHER_AT_WAR, COMDAT
; _this$ = ecx

; 1881 : 		return m_iPERMANENT_WAR_OTHER_AT_WAR;

	mov	eax, DWORD PTR [ecx+2816]

; 1882 : 	}

	ret	0
?getPERMANENT_WAR_OTHER_AT_WAR@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPERMANENT_WAR_OTHER_AT_WAR
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_NEUTRAL_ON_DEATH@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_NEUTRAL_ON_DEATH
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getFRIENDSHIP_NEUTRAL_ON_DEATH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_NEUTRAL_ON_DEATH@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_NEUTRAL_ON_DEATH, COMDAT
; _this$ = ecx

; 1885 : 		return m_iFRIENDSHIP_NEUTRAL_ON_DEATH;

	mov	eax, DWORD PTR [ecx+2820]

; 1886 : 	}

	ret	0
?getFRIENDSHIP_NEUTRAL_ON_DEATH@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_NEUTRAL_ON_DEATH
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ	; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ PROC	; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ ENDP	; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_THRESHOLD_NEUTRAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_THRESHOLD_NEUTRAL
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getFRIENDSHIP_THRESHOLD_NEUTRAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_THRESHOLD_NEUTRAL@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_THRESHOLD_NEUTRAL, COMDAT
; _this$ = ecx

; 1889 : 		return m_iFRIENDSHIP_THRESHOLD_NEUTRAL;

	mov	eax, DWORD PTR [ecx+2824]

; 1890 : 	}

	ret	0
?getFRIENDSHIP_THRESHOLD_NEUTRAL@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_THRESHOLD_NEUTRAL
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4BuildingTypes@@$00@@IAE@XZ	; BaseVector<enum BuildingTypes,1>::BaseVector<enum BuildingTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@W4BuildingTypes@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4BuildingTypes@@$00@@IAE@XZ PROC	; BaseVector<enum BuildingTypes,1>::BaseVector<enum BuildingTypes,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4BuildingTypes@@$00@@IAE@XZ ENDP	; BaseVector<enum BuildingTypes,1>::BaseVector<enum BuildingTypes,1>
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_FRIENDS_ON_DEATH@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_FRIENDS_ON_DEATH
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getFRIENDSHIP_FRIENDS_ON_DEATH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_FRIENDS_ON_DEATH@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_FRIENDS_ON_DEATH, COMDAT
; _this$ = ecx

; 1893 : 		return m_iFRIENDSHIP_FRIENDS_ON_DEATH;

	mov	eax, DWORD PTR [ecx+2828]

; 1894 : 	}

	ret	0
?getFRIENDSHIP_FRIENDS_ON_DEATH@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_FRIENDS_ON_DEATH
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_THRESHOLD_FRIENDS@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_THRESHOLD_FRIENDS
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_THRESHOLD_FRIENDS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_THRESHOLD_FRIENDS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_THRESHOLD_FRIENDS, COMDAT
; _this$ = ecx

; 1897 : 		return m_iFRIENDSHIP_THRESHOLD_FRIENDS;

	mov	eax, DWORD PTR [ecx+2832]

; 1898 : 	}

	ret	0
?getFRIENDSHIP_THRESHOLD_FRIENDS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_THRESHOLD_FRIENDS
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_ALLIES_ON_DEATH@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_ALLIES_ON_DEATH
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_ALLIES_ON_DEATH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_ALLIES_ON_DEATH@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_ALLIES_ON_DEATH, COMDAT
; _this$ = ecx

; 1901 : 		return m_iFRIENDSHIP_ALLIES_ON_DEATH;

	mov	eax, DWORD PTR [ecx+2836]

; 1902 : 	}

	ret	0
?getFRIENDSHIP_ALLIES_ON_DEATH@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_ALLIES_ON_DEATH
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_THRESHOLD_ALLIES@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_THRESHOLD_ALLIES
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_THRESHOLD_ALLIES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_THRESHOLD_ALLIES@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_THRESHOLD_ALLIES, COMDAT
; _this$ = ecx

; 1905 : 		return m_iFRIENDSHIP_THRESHOLD_ALLIES;

	mov	eax, DWORD PTR [ecx+2840]

; 1906 : 	}

	ret	0
?getFRIENDSHIP_THRESHOLD_ALLIES@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_THRESHOLD_ALLIES
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_THRESHOLD_CAN_BULLY@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_THRESHOLD_CAN_BULLY
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_THRESHOLD_CAN_BULLY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_THRESHOLD_CAN_BULLY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDSHIP_THRESHOLD_CAN_BULLY, COMDAT
; _this$ = ecx

; 1913 : 		return m_iFRIENDSHIP_THRESHOLD_CAN_BULLY;

	mov	eax, DWORD PTR [ecx+2848]

; 1914 : 	}

	ret	0
?getFRIENDSHIP_THRESHOLD_CAN_BULLY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDSHIP_THRESHOLD_CAN_BULLY
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 1917 : 		return m_iFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+2852]

; 1918 : 	}

	ret	0
?getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_CLOSE_AMOUNT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_CLOSE_AMOUNT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_CLOSE_AMOUNT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_CLOSE_AMOUNT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_CLOSE_AMOUNT, COMDAT
; _this$ = ecx

; 1921 : 		return m_iMINOR_FRIENDSHIP_CLOSE_AMOUNT;

	mov	eax, DWORD PTR [ecx+2856]

; 1922 : 	}

	ret	0
?getMINOR_FRIENDSHIP_CLOSE_AMOUNT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_CLOSE_AMOUNT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER, COMDAT
; _this$ = ecx

; 1925 : 		return m_iMINOR_CIV_SCIENCE_BONUS_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+2860]

; 1926 : 	}

	ret	0
?getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 1929 : 		return m_iFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2864]

; 1930 : 	}

	ret	0
?getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 1933 : 		return m_iFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2868]

; 1934 : 	}

	ret	0
?getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 1937 : 		return m_iFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2872]

; 1938 : 	}

	ret	0
?getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 1941 : 		return m_iALLIES_CULTURE_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2876]

; 1942 : 	}

	ret	0
?getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 1945 : 		return m_iALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2880]

; 1946 : 	}

	ret	0
?getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 1949 : 		return m_iALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2884]

; 1950 : 	}

	ret	0
?getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE, COMDAT
; _this$ = ecx

; 1953 : 		return m_iFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE;

	mov	eax, DWORD PTR [ecx+2888]

; 1954 : 	}

	ret	0
?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z PROC ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, edi
	imul	eax, 156				; 0000009cH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 22			; 00000016H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ENDP ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE, COMDAT
; _this$ = ecx

; 1957 : 		return m_iFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE;

	mov	eax, DWORD PTR [ecx+2892]

; 1958 : 	}

	ret	0
?getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE
_TEXT	ENDS
PUBLIC	?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE, COMDAT
; _this$ = ecx

; 1961 : 		return m_iFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE;

	mov	eax, DWORD PTR [ecx+2896]

; 1962 : 	}

	ret	0
?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE
_TEXT	ENDS
PUBLIC	?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE, COMDAT
; _this$ = ecx

; 1965 : 		return m_iFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE;

	mov	eax, DWORD PTR [ecx+2900]

; 1966 : 	}

	ret	0
?getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE
_TEXT	ENDS
PUBLIC	?getALLIES_CAPITAL_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_CAPITAL_FOOD_BONUS_AMOUNT
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_CAPITAL_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_CAPITAL_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_CAPITAL_FOOD_BONUS_AMOUNT, COMDAT
; _this$ = ecx

; 1969 : 		return m_iALLIES_CAPITAL_FOOD_BONUS_AMOUNT;

	mov	eax, DWORD PTR [ecx+2904]

; 1970 : 	}

	ret	0
?getALLIES_CAPITAL_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_CAPITAL_FOOD_BONUS_AMOUNT
_TEXT	ENDS
PUBLIC	?getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT, COMDAT
; _this$ = ecx

; 1973 : 		return m_iALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT;

	mov	eax, DWORD PTR [ecx+2908]

; 1974 : 	}

	ret	0
?getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT
_TEXT	ENDS
PUBLIC	?getFRIENDS_BASE_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_BASE_TURNS_UNIT_SPAWN
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_BASE_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_BASE_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_BASE_TURNS_UNIT_SPAWN, COMDAT
; _this$ = ecx

; 1977 : 		return m_iFRIENDS_BASE_TURNS_UNIT_SPAWN;

	mov	eax, DWORD PTR [ecx+2912]

; 1978 : 	}

	ret	0
?getFRIENDS_BASE_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_BASE_TURNS_UNIT_SPAWN
_TEXT	ENDS
PUBLIC	??1?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::~BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::~BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::~BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>
_TEXT	ENDS
PUBLIC	?getFRIENDS_RAND_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_RAND_TURNS_UNIT_SPAWN
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getFRIENDS_RAND_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_RAND_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_RAND_TURNS_UNIT_SPAWN, COMDAT
; _this$ = ecx

; 1981 : 		return m_iFRIENDS_RAND_TURNS_UNIT_SPAWN;

	mov	eax, DWORD PTR [ecx+2916]

; 1982 : 	}

	ret	0
?getFRIENDS_RAND_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_RAND_TURNS_UNIT_SPAWN
_TEXT	ENDS
PUBLIC	??0?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>
_TEXT	ENDS
PUBLIC	?getALLIES_EXTRA_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_EXTRA_TURNS_UNIT_SPAWN
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getALLIES_EXTRA_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_EXTRA_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_EXTRA_TURNS_UNIT_SPAWN, COMDAT
; _this$ = ecx

; 1985 : 		return m_iALLIES_EXTRA_TURNS_UNIT_SPAWN;

	mov	eax, DWORD PTR [ecx+2920]

; 1986 : 	}

	ret	0
?getALLIES_EXTRA_TURNS_UNIT_SPAWN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_EXTRA_TURNS_UNIT_SPAWN
_TEXT	ENDS
PUBLIC	?getUNIT_SPAWN_BIAS_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getUNIT_SPAWN_BIAS_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getUNIT_SPAWN_BIAS_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getUNIT_SPAWN_BIAS_MULTIPLIER@CvGlobals@@QAEHXZ PROC	; CvGlobals::getUNIT_SPAWN_BIAS_MULTIPLIER, COMDAT
; _this$ = ecx

; 1989 : 		return m_iUNIT_SPAWN_BIAS_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+2924]

; 1990 : 	}

	ret	0
?getUNIT_SPAWN_BIAS_MULTIPLIER@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getUNIT_SPAWN_BIAS_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 1997 : 		return m_iFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2932]

; 1998 : 	}

	ret	0
?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 2001 : 		return m_iFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2936]

; 2002 : 	}

	ret	0
?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 2005 : 		return m_iFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2940]

; 2006 : 	}

	ret	0
?getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 2009 : 		return m_iALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2944]

; 2010 : 	}

	ret	0
?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 2013 : 		return m_iALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2948]

; 2014 : 	}

	ret	0
?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 2017 : 		return m_iALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2952]

; 2018 : 	}

	ret	0
?getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 2021 : 		return m_iFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2956]

; 2022 : 	}

	ret	0
?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 2025 : 		return m_iFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2960]

; 2026 : 	}

	ret	0
?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 2029 : 		return m_iFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2964]

; 2030 : 	}

	ret	0
?getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 2033 : 		return m_iALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2968]

; 2034 : 	}

	ret	0
?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 2037 : 		return m_iALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2972]

; 2038 : 	}

	ret	0
?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 2041 : 		return m_iALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2976]

; 2042 : 	}

	ret	0
?getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 2045 : 		return m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+2980]

; 2046 : 	}

	ret	0
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE, COMDAT
; _this$ = ecx

; 2049 : 		return m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE;

	mov	eax, DWORD PTR [ecx+2984]

; 2050 : 	}

	ret	0
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE
_TEXT	ENDS
PUBLIC	?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 2053 : 		return m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+2988]

; 2054 : 	}

	ret	0
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL, COMDAT
; _this$ = ecx

; 2057 : 		return m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL;

	mov	eax, DWORD PTR [ecx+2992]

; 2058 : 	}

	ret	0
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL
_TEXT	ENDS
PUBLIC	?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 2061 : 		return m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+2996]

; 2062 : 	}

	ret	0
?getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	?getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL, COMDAT
; _this$ = ecx

; 2065 : 		return m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL;

	mov	eax, DWORD PTR [ecx+3000]

; 2066 : 	}

	ret	0
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL
_TEXT	ENDS
PUBLIC	?getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE, COMDAT
; _this$ = ecx

; 2069 : 		return m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE;

	mov	eax, DWORD PTR [ecx+3004]

; 2070 : 	}

	ret	0
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEPAVCvMinorCivQuest@@I@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEPAVCvMinorCivQuest@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEPAVCvMinorCivQuest@@I@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 5
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 5
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEPAVCvMinorCivQuest@@I@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL, COMDAT
; _this$ = ecx

; 2073 : 		return m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL;

	mov	eax, DWORD PTR [ecx+3008]

; 2074 : 	}

	ret	0
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL
_TEXT	ENDS
PUBLIC	?getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL, COMDAT
; _this$ = ecx

; 2077 : 		return m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL;

	mov	eax, DWORD PTR [ecx+3012]

; 2078 : 	}

	ret	0
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL
_TEXT	ENDS
PUBLIC	?getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT
; Function compile flags: /Ogtpy
;	COMDAT ?getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT, COMDAT
; _this$ = ecx

; 2081 : 		return m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT;

	mov	eax, DWORD PTR [ecx+3016]

; 2082 : 	}

	ret	0
?getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvMinorCivQuest@@$0A@@@QAE@XZ	; BaseVector<CvMinorCivQuest,0>::~BaseVector<CvMinorCivQuest,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@VCvMinorCivQuest@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvMinorCivQuest@@$0A@@@QAE@XZ PROC	; BaseVector<CvMinorCivQuest,0>::~BaseVector<CvMinorCivQuest,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvMinorCivQuest@@$0A@@@QAE@XZ ENDP	; BaseVector<CvMinorCivQuest,0>::~BaseVector<CvMinorCivQuest,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvMinorCivQuest@@$0A@@@IAE@XZ	; BaseVector<CvMinorCivQuest,0>::BaseVector<CvMinorCivQuest,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvMinorCivQuest@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvMinorCivQuest@@$0A@@@IAE@XZ PROC	; BaseVector<CvMinorCivQuest,0>::BaseVector<CvMinorCivQuest,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvMinorCivQuest@@$0A@@@IAE@XZ ENDP	; BaseVector<CvMinorCivQuest,0>::BaseVector<CvMinorCivQuest,0>
_TEXT	ENDS
PUBLIC	?getMAX_DISTANCE_MINORS_BARB_QUEST@CvGlobals@@QAEHXZ ; CvGlobals::getMAX_DISTANCE_MINORS_BARB_QUEST
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMAX_DISTANCE_MINORS_BARB_QUEST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_DISTANCE_MINORS_BARB_QUEST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMAX_DISTANCE_MINORS_BARB_QUEST, COMDAT
; _this$ = ecx

; 2105 : 		return m_iMAX_DISTANCE_MINORS_BARB_QUEST;

	mov	eax, DWORD PTR [ecx+3040]

; 2106 : 	}

	ret	0
?getMAX_DISTANCE_MINORS_BARB_QUEST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMAX_DISTANCE_MINORS_BARB_QUEST
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_ROUTE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_ROUTE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_QUEST_FRIENDSHIP_ROUTE, COMDAT
; _this$ = ecx

; 2125 : 		return m_iMINOR_QUEST_FRIENDSHIP_ROUTE;

	mov	eax, DWORD PTR [ecx+3060]

; 2126 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_ROUTE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_QUEST_FRIENDSHIP_ROUTE
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_KILL_CAMP@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_KILL_CAMP
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_KILL_CAMP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_KILL_CAMP@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_KILL_CAMP, COMDAT
; _this$ = ecx

; 2129 : 		return m_iMINOR_QUEST_FRIENDSHIP_KILL_CAMP;

	mov	eax, DWORD PTR [ecx+3064]

; 2130 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_KILL_CAMP@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_KILL_CAMP
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE, COMDAT
; _this$ = ecx

; 2133 : 		return m_iMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE;

	mov	eax, DWORD PTR [ecx+3068]

; 2134 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER, COMDAT
; _this$ = ecx

; 2137 : 		return m_iMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER;

	mov	eax, DWORD PTR [ecx+3072]

; 2138 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON, COMDAT
; _this$ = ecx

; 2141 : 		return m_iMINOR_QUEST_FRIENDSHIP_GREAT_PERSON;

	mov	eax, DWORD PTR [ecx+3076]

; 2142 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE, COMDAT
; _this$ = ecx

; 2145 : 		return m_iMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3080]

; 2146 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER, COMDAT
; _this$ = ecx

; 2149 : 		return m_iMINOR_QUEST_FRIENDSHIP_FIND_PLAYER;

	mov	eax, DWORD PTR [ecx+3084]

; 2150 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER, COMDAT
; _this$ = ecx

; 2153 : 		return m_iMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER;

	mov	eax, DWORD PTR [ecx+3088]

; 2154 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD, COMDAT
; _this$ = ecx

; 2157 : 		return m_iMINOR_QUEST_FRIENDSHIP_GIVE_GOLD;

	mov	eax, DWORD PTR [ecx+3092]

; 2158 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 2161 : 		return m_iMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+3096]

; 2162 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE, COMDAT
; _this$ = ecx

; 2165 : 		return m_iMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE;

	mov	eax, DWORD PTR [ecx+3100]

; 2166 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH, COMDAT
; _this$ = ecx

; 2169 : 		return m_iMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH;

	mov	eax, DWORD PTR [ecx+3104]

; 2170 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS, COMDAT
; _this$ = ecx

; 2173 : 		return m_iMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS;

	mov	eax, DWORD PTR [ecx+3108]

; 2174 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_INVEST@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_INVEST
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_INVEST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_INVEST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_INVEST, COMDAT
; _this$ = ecx

; 2177 : 		return m_iMINOR_QUEST_FRIENDSHIP_INVEST;

	mov	eax, DWORD PTR [ecx+3112]

; 2178 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_INVEST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_INVEST
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE, COMDAT
; _this$ = ecx

; 2181 : 		return m_iMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3116]

; 2182 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ	; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ PROC		; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ ENDP		; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR, COMDAT
; _this$ = ecx

; 2185 : 		return m_iMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR;

	mov	eax, DWORD PTR [ecx+3120]

; 2186 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ	; BaseVector<enum PlayerTypes,1>::BaseVector<enum PlayerTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ PROC		; BaseVector<enum PlayerTypes,1>::BaseVector<enum PlayerTypes,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ ENDP		; BaseVector<enum PlayerTypes,1>::BaseVector<enum PlayerTypes,1>
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION, COMDAT
; _this$ = ecx

; 2189 : 		return m_iMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION;

	mov	eax, DWORD PTR [ecx+3124]

; 2190 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z ; BaseVector<enum PlayerTypes,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z PROC ; BaseVector<enum PlayerTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z ENDP ; BaseVector<enum PlayerTypes,1>::Destroy
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE, COMDAT
; _this$ = ecx

; 2193 : 		return m_iMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE;

	mov	eax, DWORD PTR [ecx+3128]

; 2194 : 	}

	ret	0
?getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE
_TEXT	ENDS
PUBLIC	?getMINOR_QUEST_STANDARD_CONTEST_LENGTH@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_QUEST_STANDARD_CONTEST_LENGTH
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_QUEST_STANDARD_CONTEST_LENGTH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_QUEST_STANDARD_CONTEST_LENGTH@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_QUEST_STANDARD_CONTEST_LENGTH, COMDAT
; _this$ = ecx

; 2197 : 		return m_iMINOR_QUEST_STANDARD_CONTEST_LENGTH;

	mov	eax, DWORD PTR [ecx+3132]

; 2198 : 	}

	ret	0
?getMINOR_QUEST_STANDARD_CONTEST_LENGTH@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_QUEST_STANDARD_CONTEST_LENGTH
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@W4PlayerTypes@@$00@@IAEXABV1@@Z ; BaseVector<enum PlayerTypes,1>::Copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Copy@?$BaseVector@W4PlayerTypes@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@W4PlayerTypes@@$00@@IAEXABV1@@Z PROC	; BaseVector<enum PlayerTypes,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@W4PlayerTypes@@$00@@IAEXABV1@@Z ENDP	; BaseVector<enum PlayerTypes,1>::Copy
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER, COMDAT
; _this$ = ecx

; 2201 : 		return m_iMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+3136]

; 2202 : 	}

	ret	0
?getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR, COMDAT
; _this$ = ecx

; 2205 : 		return m_iMINOR_CIV_GOLD_GIFT_GAME_DIVISOR;

	mov	eax, DWORD PTR [ecx+3140]

; 2206 : 	}

	ret	0
?getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR, COMDAT
; _this$ = ecx

; 2209 : 		return m_iMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR;

	mov	eax, DWORD PTR [ecx+3144]

; 2210 : 	}

	ret	0
?getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD, COMDAT
; _this$ = ecx

; 2213 : 		return m_iMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD;

	mov	eax, DWORD PTR [ecx+3148]

; 2214 : 	}

	ret	0
?getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_PER_UNIT_INTRUDING@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_PER_UNIT_INTRUDING
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_PER_UNIT_INTRUDING@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_PER_UNIT_INTRUDING@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFRIENDSHIP_PER_UNIT_INTRUDING, COMDAT
; _this$ = ecx

; 2225 : 		return m_iFRIENDSHIP_PER_UNIT_INTRUDING;

	mov	eax, DWORD PTR [ecx+3160]

; 2226 : 	}

	ret	0
?getFRIENDSHIP_PER_UNIT_INTRUDING@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFRIENDSHIP_PER_UNIT_INTRUDING
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_PER_BARB_KILLED@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_PER_BARB_KILLED
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_PER_BARB_KILLED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_PER_BARB_KILLED@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_PER_BARB_KILLED, COMDAT
; _this$ = ecx

; 2229 : 		return m_iFRIENDSHIP_PER_BARB_KILLED;

	mov	eax, DWORD PTR [ecx+3164]

; 2230 : 	}

	ret	0
?getFRIENDSHIP_PER_BARB_KILLED@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_PER_BARB_KILLED
_TEXT	ENDS
PUBLIC	?getFRIENDSHIP_PER_UNIT_GIFTED@CvGlobals@@QAEHXZ ; CvGlobals::getFRIENDSHIP_PER_UNIT_GIFTED
; Function compile flags: /Ogtpy
;	COMDAT ?getFRIENDSHIP_PER_UNIT_GIFTED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFRIENDSHIP_PER_UNIT_GIFTED@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFRIENDSHIP_PER_UNIT_GIFTED, COMDAT
; _this$ = ecx

; 2233 : 		return m_iFRIENDSHIP_PER_UNIT_GIFTED;

	mov	eax, DWORD PTR [ecx+3168]

; 2234 : 	}

	ret	0
?getFRIENDSHIP_PER_UNIT_GIFTED@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFRIENDSHIP_PER_UNIT_GIFTED
_TEXT	ENDS
PUBLIC	?getMINOR_LIBERATION_FRIENDSHIP@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_LIBERATION_FRIENDSHIP
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_LIBERATION_FRIENDSHIP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_LIBERATION_FRIENDSHIP@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_LIBERATION_FRIENDSHIP, COMDAT
; _this$ = ecx

; 2241 : 		return m_iMINOR_LIBERATION_FRIENDSHIP;

	mov	eax, DWORD PTR [ecx+3176]

; 2242 : 	}

	ret	0
?getMINOR_LIBERATION_FRIENDSHIP@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_LIBERATION_FRIENDSHIP
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN, COMDAT
; _this$ = ecx

; 2257 : 		return m_iMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN;

	mov	eax, DWORD PTR [ecx+3192]

; 2258 : 	}

	ret	0
?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND, COMDAT
; _this$ = ecx

; 2261 : 		return m_iMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND;

	mov	eax, DWORD PTR [ecx+3196]

; 2262 : 	}

	ret	0
?getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN, COMDAT
; _this$ = ecx

; 2265 : 		return m_iMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN;

	mov	eax, DWORD PTR [ecx+3200]

; 2266 : 	}

	ret	0
?getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4ResourceTypes@@I@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4ResourceTypes@@I@Z PROC ; FStaticVector<enum ResourceTypes,64,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@4

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@4:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEPAW4ResourceTypes@@I@Z ENDP ; FStaticVector<enum ResourceTypes,64,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN, COMDAT
; _this$ = ecx

; 2269 : 		return m_iMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN;

	mov	eax, DWORD PTR [ecx+3204]

; 2270 : 	}

	ret	0
?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER, COMDAT
; _this$ = ecx

; 2273 : 		return m_iMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+3208]

; 2274 : 	}

	ret	0
?getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN, COMDAT
; _this$ = ecx

; 2277 : 		return m_iMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN;

	mov	eax, DWORD PTR [ecx+3212]

; 2278 : 	}

	ret	0
?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND, COMDAT
; _this$ = ecx

; 2281 : 		return m_iMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND;

	mov	eax, DWORD PTR [ecx+3216]

; 2282 : 	}

	ret	0
?getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN, COMDAT
; _this$ = ecx

; 2285 : 		return m_iMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN;

	mov	eax, DWORD PTR [ecx+3220]

; 2286 : 	}

	ret	0
?getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN, COMDAT
; _this$ = ecx

; 2289 : 		return m_iMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN;

	mov	eax, DWORD PTR [ecx+3224]

; 2290 : 	}

	ret	0
?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4ResourceTypes@@$00@@QAE@XZ	; BaseVector<enum ResourceTypes,1>::~BaseVector<enum ResourceTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@W4ResourceTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4ResourceTypes@@$00@@QAE@XZ PROC	; BaseVector<enum ResourceTypes,1>::~BaseVector<enum ResourceTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4ResourceTypes@@$00@@QAE@XZ ENDP	; BaseVector<enum ResourceTypes,1>::~BaseVector<enum ResourceTypes,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4ResourceTypes@@$00@@IAE@XZ	; BaseVector<enum ResourceTypes,1>::BaseVector<enum ResourceTypes,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@W4ResourceTypes@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4ResourceTypes@@$00@@IAE@XZ PROC	; BaseVector<enum ResourceTypes,1>::BaseVector<enum ResourceTypes,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4ResourceTypes@@$00@@IAE@XZ ENDP	; BaseVector<enum ResourceTypes,1>::BaseVector<enum ResourceTypes,1>
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER, COMDAT
; _this$ = ecx

; 2293 : 		return m_iMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+3228]

; 2294 : 	}

	ret	0
?getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_KILL_CAMP_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_KILL_CAMP_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_KILL_CAMP_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_KILL_CAMP_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_KILL_CAMP_RANGE, COMDAT
; _this$ = ecx

; 2297 : 		return m_iMINOR_CIV_QUEST_KILL_CAMP_RANGE;

	mov	eax, DWORD PTR [ecx+3232]

; 2298 : 	}

	ret	0
?getMINOR_CIV_QUEST_KILL_CAMP_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_KILL_CAMP_RANGE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD, COMDAT
; _this$ = ecx

; 2301 : 		return m_iMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD;

	mov	eax, DWORD PTR [ecx+3236]

; 2302 : 	}

	ret	0
?getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD, COMDAT
; _this$ = ecx

; 2305 : 		return m_iMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD;

	mov	eax, DWORD PTR [ecx+3240]

; 2306 : 	}

	ret	0
?getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY, COMDAT
; _this$ = ecx

; 2309 : 		return m_iMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY;

	mov	eax, DWORD PTR [ecx+3244]

; 2310 : 	}

	ret	0
?getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED, COMDAT
; _this$ = ecx

; 2313 : 		return m_iMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED;

	mov	eax, DWORD PTR [ecx+3248]

; 2314 : 	}

	ret	0
?getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_ROUTE@CvGlobals@@QAEHXZ	; CvGlobals::getQUEST_DISABLED_ROUTE
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_ROUTE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getQUEST_DISABLED_ROUTE, COMDAT
; _this$ = ecx

; 2317 : 		return m_iQUEST_DISABLED_ROUTE;

	mov	eax, DWORD PTR [ecx+3252]

; 2318 : 	}

	ret	0
?getQUEST_DISABLED_ROUTE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getQUEST_DISABLED_ROUTE
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_KILL_CAMP@CvGlobals@@QAEHXZ	; CvGlobals::getQUEST_DISABLED_KILL_CAMP
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_KILL_CAMP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_KILL_CAMP@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_KILL_CAMP, COMDAT
; _this$ = ecx

; 2321 : 		return m_iQUEST_DISABLED_KILL_CAMP;

	mov	eax, DWORD PTR [ecx+3256]

; 2322 : 	}

	ret	0
?getQUEST_DISABLED_KILL_CAMP@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_KILL_CAMP
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_CONNECT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_CONNECT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_CONNECT_RESOURCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_CONNECT_RESOURCE, COMDAT
; _this$ = ecx

; 2325 : 		return m_iQUEST_DISABLED_CONNECT_RESOURCE;

	mov	eax, DWORD PTR [ecx+3260]

; 2326 : 	}

	ret	0
?getQUEST_DISABLED_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_CONNECT_RESOURCE
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_CONSTRUCT_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_CONSTRUCT_WONDER, COMDAT
; _this$ = ecx

; 2329 : 		return m_iQUEST_DISABLED_CONSTRUCT_WONDER;

	mov	eax, DWORD PTR [ecx+3264]

; 2330 : 	}

	ret	0
?getQUEST_DISABLED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_CONSTRUCT_WONDER
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_GREAT_PERSON@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_GREAT_PERSON
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_GREAT_PERSON@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_GREAT_PERSON@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_GREAT_PERSON, COMDAT
; _this$ = ecx

; 2333 : 		return m_iQUEST_DISABLED_GREAT_PERSON;

	mov	eax, DWORD PTR [ecx+3268]

; 2334 : 	}

	ret	0
?getQUEST_DISABLED_GREAT_PERSON@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_GREAT_PERSON
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_KILL_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_KILL_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_KILL_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_KILL_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_KILL_CITY_STATE, COMDAT
; _this$ = ecx

; 2337 : 		return m_iQUEST_DISABLED_KILL_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3272]

; 2338 : 	}

	ret	0
?getQUEST_DISABLED_KILL_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_KILL_CITY_STATE
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_FIND_PLAYER@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_FIND_PLAYER
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_FIND_PLAYER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_FIND_PLAYER@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_FIND_PLAYER, COMDAT
; _this$ = ecx

; 2341 : 		return m_iQUEST_DISABLED_FIND_PLAYER;

	mov	eax, DWORD PTR [ecx+3276]

; 2342 : 	}

	ret	0
?getQUEST_DISABLED_FIND_PLAYER@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_FIND_PLAYER
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_NATURAL_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_NATURAL_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_NATURAL_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_NATURAL_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_NATURAL_WONDER, COMDAT
; _this$ = ecx

; 2345 : 		return m_iQUEST_DISABLED_NATURAL_WONDER;

	mov	eax, DWORD PTR [ecx+3280]

; 2346 : 	}

	ret	0
?getQUEST_DISABLED_NATURAL_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_NATURAL_WONDER
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEPAW4MinorCivQuestTypes@@I@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEPAW4MinorCivQuestTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEPAW4MinorCivQuestTypes@@I@Z PROC ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 18					; 00000012H
	jbe	SHORT $LN2@Alloc@5

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@5:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 18			; 00000012H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEPAW4MinorCivQuestTypes@@I@Z ENDP ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_GIVE_GOLD@CvGlobals@@QAEHXZ	; CvGlobals::getQUEST_DISABLED_GIVE_GOLD
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getQUEST_DISABLED_GIVE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_GIVE_GOLD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_GIVE_GOLD, COMDAT
; _this$ = ecx

; 2349 : 		return m_iQUEST_DISABLED_GIVE_GOLD;

	mov	eax, DWORD PTR [ecx+3284]

; 2350 : 	}

	ret	0
?getQUEST_DISABLED_GIVE_GOLD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_GIVE_GOLD
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 2353 : 		return m_iQUEST_DISABLED_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+3288]

; 2354 : 	}

	ret	0
?getQUEST_DISABLED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_CONTEST_CULTURE@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_CONTEST_CULTURE
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_CONTEST_CULTURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_CONTEST_CULTURE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_CONTEST_CULTURE, COMDAT
; _this$ = ecx

; 2357 : 		return m_iQUEST_DISABLED_CONTEST_CULTURE;

	mov	eax, DWORD PTR [ecx+3292]

; 2358 : 	}

	ret	0
?getQUEST_DISABLED_CONTEST_CULTURE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_CONTEST_CULTURE
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_CONTEST_FAITH@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_CONTEST_FAITH
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_CONTEST_FAITH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_CONTEST_FAITH@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_CONTEST_FAITH, COMDAT
; _this$ = ecx

; 2361 : 		return m_iQUEST_DISABLED_CONTEST_FAITH;

	mov	eax, DWORD PTR [ecx+3296]

; 2362 : 	}

	ret	0
?getQUEST_DISABLED_CONTEST_FAITH@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_CONTEST_FAITH
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_CONTEST_TECHS@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_CONTEST_TECHS
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_CONTEST_TECHS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_CONTEST_TECHS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_CONTEST_TECHS, COMDAT
; _this$ = ecx

; 2365 : 		return m_iQUEST_DISABLED_CONTEST_TECHS;

	mov	eax, DWORD PTR [ecx+3300]

; 2366 : 	}

	ret	0
?getQUEST_DISABLED_CONTEST_TECHS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_CONTEST_TECHS
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_INVEST@CvGlobals@@QAEHXZ	; CvGlobals::getQUEST_DISABLED_INVEST
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_INVEST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_INVEST@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_INVEST, COMDAT
; _this$ = ecx

; 2369 : 		return m_iQUEST_DISABLED_INVEST;

	mov	eax, DWORD PTR [ecx+3304]

; 2370 : 	}

	ret	0
?getQUEST_DISABLED_INVEST@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_INVEST
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4MinorCivQuestTypes@@$00@@QAE@XZ ; BaseVector<enum MinorCivQuestTypes,1>::~BaseVector<enum MinorCivQuestTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@W4MinorCivQuestTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4MinorCivQuestTypes@@$00@@QAE@XZ PROC	; BaseVector<enum MinorCivQuestTypes,1>::~BaseVector<enum MinorCivQuestTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4MinorCivQuestTypes@@$00@@QAE@XZ ENDP	; BaseVector<enum MinorCivQuestTypes,1>::~BaseVector<enum MinorCivQuestTypes,1>
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_BULLY_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_BULLY_CITY_STATE
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getQUEST_DISABLED_BULLY_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_BULLY_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_BULLY_CITY_STATE, COMDAT
; _this$ = ecx

; 2373 : 		return m_iQUEST_DISABLED_BULLY_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3308]

; 2374 : 	}

	ret	0
?getQUEST_DISABLED_BULLY_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_BULLY_CITY_STATE
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4MinorCivQuestTypes@@$00@@IAE@XZ ; BaseVector<enum MinorCivQuestTypes,1>::BaseVector<enum MinorCivQuestTypes,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@W4MinorCivQuestTypes@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4MinorCivQuestTypes@@$00@@IAE@XZ PROC	; BaseVector<enum MinorCivQuestTypes,1>::BaseVector<enum MinorCivQuestTypes,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4MinorCivQuestTypes@@$00@@IAE@XZ ENDP	; BaseVector<enum MinorCivQuestTypes,1>::BaseVector<enum MinorCivQuestTypes,1>
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_DENOUNCE_MAJOR
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getQUEST_DISABLED_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_DENOUNCE_MAJOR, COMDAT
; _this$ = ecx

; 2377 : 		return m_iQUEST_DISABLED_DENOUNCE_MAJOR;

	mov	eax, DWORD PTR [ecx+3312]

; 2378 : 	}

	ret	0
?getQUEST_DISABLED_DENOUNCE_MAJOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_DENOUNCE_MAJOR
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 17					; 00000011H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_SPREAD_RELIGION@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_SPREAD_RELIGION
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getQUEST_DISABLED_SPREAD_RELIGION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_SPREAD_RELIGION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getQUEST_DISABLED_SPREAD_RELIGION, COMDAT
; _this$ = ecx

; 2381 : 		return m_iQUEST_DISABLED_SPREAD_RELIGION;

	mov	eax, DWORD PTR [ecx+3316]

; 2382 : 	}

	ret	0
?getQUEST_DISABLED_SPREAD_RELIGION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getQUEST_DISABLED_SPREAD_RELIGION
_TEXT	ENDS
PUBLIC	?getQUEST_DISABLED_TRADE_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getQUEST_DISABLED_TRADE_ROUTE
; Function compile flags: /Ogtpy
;	COMDAT ?getQUEST_DISABLED_TRADE_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getQUEST_DISABLED_TRADE_ROUTE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getQUEST_DISABLED_TRADE_ROUTE, COMDAT
; _this$ = ecx

; 2385 : 		return m_iQUEST_DISABLED_TRADE_ROUTE;

	mov	eax, DWORD PTR [ecx+3320]

; 2386 : 	}

	ret	0
?getQUEST_DISABLED_TRADE_ROUTE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getQUEST_DISABLED_TRADE_ROUTE
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Left
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_DEFAULT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_DEFAULT
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_DEFAULT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_DEFAULT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_DEFAULT, COMDAT
; _this$ = ecx

; 2389 : 		return m_iMINOR_CIV_QUEST_WEIGHT_DEFAULT;

	mov	eax, DWORD PTR [ecx+3324]

; 2390 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_DEFAULT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_DEFAULT
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Right
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Right
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE, COMDAT
; _this$ = ecx

; 2393 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE;

	mov	eax, DWORD PTR [ecx+3328]

; 2394 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE, COMDAT
; _this$ = ecx

; 2397 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE;

	mov	eax, DWORD PTR [ecx+3332]

; 2398 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE, COMDAT
; _this$ = ecx

; 2401 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE;

	mov	eax, DWORD PTR [ecx+3336]

; 2402 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE, COMDAT
; _this$ = ecx

; 2405 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE;

	mov	eax, DWORD PTR [ecx+3340]

; 2406 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP, COMDAT
; _this$ = ecx

; 2409 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP;

	mov	eax, DWORD PTR [ecx+3344]

; 2410 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE, COMDAT
; _this$ = ecx

; 2413 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE;

	mov	eax, DWORD PTR [ecx+3348]

; 2414 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE, COMDAT
; _this$ = ecx

; 2417 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE;

	mov	eax, DWORD PTR [ecx+3352]

; 2418 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER, COMDAT
; _this$ = ecx

; 2421 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER;

	mov	eax, DWORD PTR [ecx+3356]

; 2422 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON, COMDAT
; _this$ = ecx

; 2425 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON;

	mov	eax, DWORD PTR [ecx+3360]

; 2426 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE, COMDAT
; _this$ = ecx

; 2429 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3364]

; 2430 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE, COMDAT
; _this$ = ecx

; 2433 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3368]

; 2434 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE, COMDAT
; _this$ = ecx

; 2437 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE;

	mov	eax, DWORD PTR [ecx+3372]

; 2438 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER, COMDAT
; _this$ = ecx

; 2441 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER;

	mov	eax, DWORD PTR [ecx+3376]

; 2442 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER, COMDAT
; _this$ = ecx

; 2445 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER;

	mov	eax, DWORD PTR [ecx+3380]

; 2446 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER, COMDAT
; _this$ = ecx

; 2449 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER;

	mov	eax, DWORD PTR [ecx+3384]

; 2450 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER, COMDAT
; _this$ = ecx

; 2453 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER;

	mov	eax, DWORD PTR [ecx+3388]

; 2454 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD, COMDAT
; _this$ = ecx

; 2457 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD;

	mov	eax, DWORD PTR [ecx+3392]

; 2458 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD, COMDAT
; _this$ = ecx

; 2461 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD;

	mov	eax, DWORD PTR [ecx+3396]

; 2462 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD, COMDAT
; _this$ = ecx

; 2465 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD;

	mov	eax, DWORD PTR [ecx+3400]

; 2466 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 2469 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+3404]

; 2470 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 2473 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+3408]

; 2474 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT, COMDAT
; _this$ = ecx

; 2477 : 		return m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT;

	mov	eax, DWORD PTR [ecx+3412]

; 2478 : 	}

	ret	0
?getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@SAABW4MinorCivQuestTypes@@ABW43@@Z ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@SAABW4MinorCivQuestTypes@@ABW43@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@SAABW4MinorCivQuestTypes@@ABW43@@Z PROC ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::_Kfn, COMDAT

; 45   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 46   : 		}

	ret	0
?_Kfn@?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@SAABW4MinorCivQuestTypes@@ABW43@@Z ENDP ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::_Kfn
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@XZ ; std::allocator<enum MinorCivQuestTypes>::allocator<enum MinorCivQuestTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@XZ PROC	; std::allocator<enum MinorCivQuestTypes>::allocator<enum MinorCivQuestTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum MinorCivQuestTypes>::allocator<enum MinorCivQuestTypes>
_TEXT	ENDS
PUBLIC	??R?$less@W4MinorCivQuestTypes@@@std@@QBE_NABW4MinorCivQuestTypes@@0@Z ; std::less<enum MinorCivQuestTypes>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@W4MinorCivQuestTypes@@@std@@QBE_NABW4MinorCivQuestTypes@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@W4MinorCivQuestTypes@@@std@@QBE_NABW4MinorCivQuestTypes@@0@Z PROC ; std::less<enum MinorCivQuestTypes>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 144  : 		}

	ret	8
??R?$less@W4MinorCivQuestTypes@@@std@@QBE_NABW4MinorCivQuestTypes@@0@Z ENDP ; std::less<enum MinorCivQuestTypes>::operator()
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@6

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@6:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ PROC ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEPAW4BuildingTypes@@I@Z ; FStaticVector<enum BuildingTypes,50,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEPAW4BuildingTypes@@I@Z PROC ; FStaticVector<enum BuildingTypes,50,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 50					; 00000032H
	jbe	SHORT $LN2@Alloc@7

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@7:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 50			; 00000032H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEPAW4BuildingTypes@@I@Z ENDP ; FStaticVector<enum BuildingTypes,50,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEPAW4UnitTypes@@I@Z ; FStaticVector<enum UnitTypes,8,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEPAW4UnitTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEPAW4UnitTypes@@I@Z PROC ; FStaticVector<enum UnitTypes,8,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 8
	jbe	SHORT $LN2@Alloc@8

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@8:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 8
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEPAW4UnitTypes@@I@Z ENDP ; FStaticVector<enum UnitTypes,8,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4UnitTypes@@$00@@QAE@XZ	; BaseVector<enum UnitTypes,1>::~BaseVector<enum UnitTypes,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@W4UnitTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4UnitTypes@@$00@@QAE@XZ PROC		; BaseVector<enum UnitTypes,1>::~BaseVector<enum UnitTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4UnitTypes@@$00@@QAE@XZ ENDP		; BaseVector<enum UnitTypes,1>::~BaseVector<enum UnitTypes,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4UnitTypes@@$00@@IAE@XZ	; BaseVector<enum UnitTypes,1>::BaseVector<enum UnitTypes,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@W4UnitTypes@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4UnitTypes@@$00@@IAE@XZ PROC		; BaseVector<enum UnitTypes,1>::BaseVector<enum UnitTypes,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4UnitTypes@@$00@@IAE@XZ ENDP		; BaseVector<enum UnitTypes,1>::BaseVector<enum UnitTypes,1>
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	jbe	SHORT $LN2@Alloc@9

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@9:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 63			; 0000003fH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEPAPAVCvCity@@I@Z ; FStaticVector<CvCity *,16,0,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEPAPAVCvCity@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEPAPAVCvCity@@I@Z PROC ; FStaticVector<CvCity *,16,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 16					; 00000010H
	jbe	SHORT $LN2@Alloc@10

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@10:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 16			; 00000010H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEPAPAVCvCity@@I@Z ENDP ; FStaticVector<CvCity *,16,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ PROC		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ ENDP		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ		; BaseVector<CvCity *,0>::BaseVector<CvCity *,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ PROC		; BaseVector<CvCity *,0>::BaseVector<CvCity *,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ ENDP		; BaseVector<CvCity *,0>::BaseVector<CvCity *,0>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ PROC ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@XZ ; CvWeightedVector<int,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@XZ PROC ; CvWeightedVector<int,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@XZ ENDP ; CvWeightedVector<int,100,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??_GCvMinorCivQuest@@QAEPAXI@Z			; CvMinorCivQuest::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvMinorCivQuest@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMinorCivQuest@@QAEPAXI@Z PROC			; CvMinorCivQuest::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMinorCivQuest@@QAEPAXI@Z ENDP			; CvMinorCivQuest::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T236911 = -80						; size = 28
$T236910 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T236911[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T236910[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T236911[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T236910[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T236910[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T236910[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T236910[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T236911[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T236910[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z	; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ; std::allocator<CvString>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z PROC ; std::allocator<CvString>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ENDP ; std::allocator<CvString>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T236945 = -80						; size = 28
$T236944 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T236945[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T236944[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T236945[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T236944[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T236944[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T236944[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T236944[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T236945[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T236944[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z ; std::allocator<enum ResourceTypes>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z PROC ; std::allocator<enum ResourceTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z ENDP ; std::allocator<enum ResourceTypes>::deallocate
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4BuildingTypes@@$00@@IAEXPAW4BuildingTypes@@I@Z ; BaseVector<enum BuildingTypes,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@W4BuildingTypes@@$00@@IAEXPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4BuildingTypes@@$00@@IAEXPAW4BuildingTypes@@I@Z PROC ; BaseVector<enum BuildingTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4BuildingTypes@@$00@@IAEXPAW4BuildingTypes@@I@Z ENDP ; BaseVector<enum BuildingTypes,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXABV1@@Z ; BaseVector<CvMinorCivQuest,0>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXABV1@@Z PROC ; BaseVector<CvMinorCivQuest,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebx
	push	ebp

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebp, DWORD PTR _RHS$[esp+4]
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, ecx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	ebx, ebx
	mov	DWORD PTR [edx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy
	push	esi
	xor	eax, eax
	push	edi
$LL3@Copy:

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	edi, DWORD PTR [edx]
	add	edi, eax
	je	SHORT $LN2@Copy
	mov	esi, DWORD PTR [ebp]
	add	esi, eax
	mov	ecx, 7
	rep movsd
$LN2@Copy:
	inc	ebx
	add	eax, 28					; 0000001cH
	cmp	ebx, DWORD PTR [edx+4]
	jb	SHORT $LL3@Copy
	pop	edi
	pop	esi
$LN1@Copy:
	pop	ebp
	pop	ebx

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXABV1@@Z ENDP ; BaseVector<CvMinorCivQuest,0>::Copy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4ResourceTypes@@$00@@IAEXPAW4ResourceTypes@@I@Z ; BaseVector<enum ResourceTypes,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@W4ResourceTypes@@$00@@IAEXPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4ResourceTypes@@$00@@IAEXPAW4ResourceTypes@@I@Z PROC ; BaseVector<enum ResourceTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4ResourceTypes@@$00@@IAEXPAW4ResourceTypes@@I@Z ENDP ; BaseVector<enum ResourceTypes,1>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4MinorCivQuestTypes@@$00@@IAEXPAW4MinorCivQuestTypes@@I@Z ; BaseVector<enum MinorCivQuestTypes,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@W4MinorCivQuestTypes@@$00@@IAEXPAW4MinorCivQuestTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4MinorCivQuestTypes@@$00@@IAEXPAW4MinorCivQuestTypes@@I@Z PROC ; BaseVector<enum MinorCivQuestTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4MinorCivQuestTypes@@$00@@IAEXPAW4MinorCivQuestTypes@@I@Z ENDP ; BaseVector<enum MinorCivQuestTypes,1>::Destroy
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAAAW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum MinorCivQuestTypes>::allocator<enum MinorCivQuestTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@ABV01@@Z PROC ; std::allocator<enum MinorCivQuestTypes>::allocator<enum MinorCivQuestTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4MinorCivQuestTypes@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<enum MinorCivQuestTypes>::allocator<enum MinorCivQuestTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABU01@@Z ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@11

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@11:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$0EA@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4UnitTypes@@$00@@IAEXPAW4UnitTypes@@I@Z ; BaseVector<enum UnitTypes,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@W4UnitTypes@@$00@@IAEXPAW4UnitTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4UnitTypes@@$00@@IAEXPAW4UnitTypes@@I@Z PROC ; BaseVector<enum UnitTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4UnitTypes@@$00@@IAEXPAW4UnitTypes@@I@Z ENDP ; BaseVector<enum UnitTypes,1>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z ; BaseVector<CvCity *,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z PROC ; BaseVector<CvCity *,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z ENDP ; BaseVector<CvCity *,0>::Destroy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN2@Alloc@12

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@12:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 22			; 00000016H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@ABU01@@Z ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis, COMDAT
; _this$ = ecx

; 701  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
_TEXT	ENDS
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr, COMDAT
; _this$ = ecx

; 702  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 100				; 00000064H
	jbe	SHORT $LN2@Alloc@13

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@13:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 100			; 00000064H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@ABU01@@Z ; CvWeightedVector<int,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$0GE@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,100,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvString@@@std@@QBEIXZ	; std::allocator<CvString>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvString@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvString@@@std@@QBEIXZ PROC	; std::allocator<CvString>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvString@@@std@@QBEIXZ ENDP	; std::allocator<CvString>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ ; std::allocator<enum ResourceTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ PROC ; std::allocator<enum ResourceTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum ResourceTypes>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4MinorCivQuestTypes@@@std@@QBEIXZ ; std::allocator<enum MinorCivQuestTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4MinorCivQuestTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4MinorCivQuestTypes@@@std@@QBEIXZ PROC ; std::allocator<enum MinorCivQuestTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4MinorCivQuestTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum MinorCivQuestTypes>::max_size
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,100,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU012@00ABW4MinorCivQuestTypes@@D@Z ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU012@00ABW4MinorCivQuestTypes@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU012@00ABW4MinorCivQuestTypes@@D@Z PROC ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU012@00ABW4MinorCivQuestTypes@@D@Z ENDP ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Min
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@V?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@V?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4MinorCivQuestTypes@@@std@@@std@@IAE@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum MinorCivQuestTypes> >
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z ; operator<<<CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z PROC ; operator<<<CvString>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	ecx, DWORD PTR _val$[esp-4]
	push	esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR _s$[esp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z ENDP ; operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$?6$0DA@@@YAAAVString@Localization@@AAV01@AAY0DA@$$CBD@Z ; operator<<<48>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBDI@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6$0DA@@@YAAAVString@Localization@@AAV01@AAY0DA@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0DA@@@YAAAVString@Localization@@AAV01@AAY0DA@$$CBD@Z PROC ; operator<<<48>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	47					; 0000002fH
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0DA@@@YAAAVString@Localization@@AAV01@AAY0DA@$$CBD@Z ENDP ; operator<<<48>
_TEXT	ENDS
PUBLIC	??$?6$0DC@@@YAAAVString@Localization@@AAV01@AAY0DC@$$CBD@Z ; operator<<<50>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0DC@@@YAAAVString@Localization@@AAV01@AAY0DC@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0DC@@@YAAAVString@Localization@@AAV01@AAY0DC@$$CBD@Z PROC ; operator<<<50>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	49					; 00000031H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0DC@@@YAAAVString@Localization@@AAV01@AAY0DC@$$CBD@Z ENDP ; operator<<<50>
_TEXT	ENDS
PUBLIC	??$?6$0CO@@@YAAAVString@Localization@@AAV01@AAY0CO@$$CBD@Z ; operator<<<46>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0CO@@@YAAAVString@Localization@@AAV01@AAY0CO@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0CO@@@YAAAVString@Localization@@AAV01@AAY0CO@$$CBD@Z PROC ; operator<<<46>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	45					; 0000002dH
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0CO@@@YAAAVString@Localization@@AAV01@AAY0CO@$$CBD@Z ENDP ; operator<<<46>
_TEXT	ENDS
PUBLIC	??$?6$0DG@@@YAAAVString@Localization@@AAV01@AAY0DG@$$CBD@Z ; operator<<<54>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0DG@@@YAAAVString@Localization@@AAV01@AAY0DG@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0DG@@@YAAAVString@Localization@@AAV01@AAY0DG@$$CBD@Z PROC ; operator<<<54>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	53					; 00000035H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0DG@@@YAAAVString@Localization@@AAV01@AAY0DG@$$CBD@Z ENDP ; operator<<<54>
_TEXT	ENDS
PUBLIC	??$?6$0DB@@@YAAAVString@Localization@@AAV01@AAY0DB@$$CBD@Z ; operator<<<49>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0DB@@@YAAAVString@Localization@@AAV01@AAY0DB@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0DB@@@YAAAVString@Localization@@AAV01@AAY0DB@$$CBD@Z PROC ; operator<<<49>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	48					; 00000030H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0DB@@@YAAAVString@Localization@@AAV01@AAY0DB@$$CBD@Z ENDP ; operator<<<49>
_TEXT	ENDS
PUBLIC	??$?6$0CP@@@YAAAVString@Localization@@AAV01@AAY0CP@$$CBD@Z ; operator<<<47>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0CP@@@YAAAVString@Localization@@AAV01@AAY0CP@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0CP@@@YAAAVString@Localization@@AAV01@AAY0CP@$$CBD@Z PROC ; operator<<<47>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	46					; 0000002eH
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0CP@@@YAAAVString@Localization@@AAV01@AAY0CP@$$CBD@Z ENDP ; operator<<<47>
_TEXT	ENDS
PUBLIC	??$?6$0CH@@@YAAAVString@Localization@@AAV01@AAY0CH@$$CBD@Z ; operator<<<39>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0CH@@@YAAAVString@Localization@@AAV01@AAY0CH@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0CH@@@YAAAVString@Localization@@AAV01@AAY0CH@$$CBD@Z PROC ; operator<<<39>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	38					; 00000026H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0CH@@@YAAAVString@Localization@@AAV01@AAY0CH@$$CBD@Z ENDP ; operator<<<39>
_TEXT	ENDS
PUBLIC	??$?6$0DD@@@YAAAVString@Localization@@AAV01@AAY0DD@$$CBD@Z ; operator<<<51>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0DD@@@YAAAVString@Localization@@AAV01@AAY0DD@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0DD@@@YAAAVString@Localization@@AAV01@AAY0DD@$$CBD@Z PROC ; operator<<<51>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	50					; 00000032H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0DD@@@YAAAVString@Localization@@AAV01@AAY0DD@$$CBD@Z ENDP ; operator<<<51>
_TEXT	ENDS
PUBLIC	??$?6$0CI@@@YAAAVString@Localization@@AAV01@AAY0CI@$$CBD@Z ; operator<<<40>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0CI@@@YAAAVString@Localization@@AAV01@AAY0CI@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0CI@@@YAAAVString@Localization@@AAV01@AAY0CI@$$CBD@Z PROC ; operator<<<40>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	39					; 00000027H
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0CI@@@YAAAVString@Localization@@AAV01@AAY0CI@$$CBD@Z ENDP ; operator<<<40>
_TEXT	ENDS
PUBLIC	??$?6$0CN@@@YAAAVString@Localization@@AAV01@AAY0CN@$$CBD@Z ; operator<<<45>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$0CN@@@YAAAVString@Localization@@AAV01@AAY0CN@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0CN@@@YAAAVString@Localization@@AAV01@AAY0CN@$$CBD@Z PROC ; operator<<<45>, COMDAT

; 498  : 	s.PushArgument(val, N - 1);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	44					; 0000002cH
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, esi
	pop	esi

; 500  : }

	ret	0
??$?6$0CN@@@YAAAVString@Localization@@AAV01@AAY0CN@$$CBD@Z ENDP ; operator<<<45>
_TEXT	ENDS
PUBLIC	??$min@N@std@@YAABNABN0@Z			; std::min<double>
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@N@std@@YAABNABN0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@N@std@@YAABNABN0@Z PROC				; std::min<double>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR __Right$[esp-4]
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	mov	eax, edx
	je	SHORT $LN4@min@2
	mov	eax, ecx
$LN4@min@2:

; 3400 : 	}

	ret	0
??$min@N@std@@YAABNABN0@Z ENDP				; std::min<double>
_TEXT	ENDS
PUBLIC	??$?6M@@YAAAVString@Localization@@AAV01@ABM@Z	; operator<<<float>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NM@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6M@@YAAAVString@Localization@@AAV01@ABM@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6M@@YAAAVString@Localization@@AAV01@ABM@Z PROC	; operator<<<float>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esp], ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NM@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6M@@YAAAVString@Localization@@AAV01@ABM@Z ENDP	; operator<<<float>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z
_TEXT	SEGMENT
$T237280 = -12						; size = 12
$T237284 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z PROC ; std::_Allocate<CvString>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T237284[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T237280[esp+16]
	mov	DWORD PTR $T237284[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237280[esp+16]
	push	ecx
	mov	DWORD PTR $T237280[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ENDP ; std::_Allocate<CvString>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T237290 = -12						; size = 12
$T237294 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z PROC ; std::_Allocate<enum ResourceTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T237294[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T237290[esp+16]
	mov	DWORD PTR $T237294[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237290[esp+16]
	push	ecx
	mov	DWORD PTR $T237290[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0W4MinorCivQuestTypes@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *><enum MinorCivQuestTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0W4MinorCivQuestTypes@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0W4MinorCivQuestTypes@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *><enum MinorCivQuestTypes>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0W4MinorCivQuestTypes@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *><enum MinorCivQuestTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T237306 = -12						; size = 12
$T237310 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T237310[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T237306[esp+16]
	mov	DWORD PTR $T237310[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237306[esp+16]
	push	ecx
	mov	DWORD PTR $T237306[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0W4MinorCivQuestTypes@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node><enum MinorCivQuestTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0W4MinorCivQuestTypes@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0W4MinorCivQuestTypes@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node><enum MinorCivQuestTypes>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0W4MinorCivQuestTypes@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node><enum MinorCivQuestTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *,std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *,std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *,std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ; std::_Iter_random<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z PROC ; std::_Iter_random<CvString *,CvString *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ENDP ; std::_Iter_random<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ; std::_Ptr_cat<CvString *,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z PROC ; std::_Ptr_cat<CvString *,CvString *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ENDP ; std::_Ptr_cat<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ; std::_Move_cat<CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z PROC ; std::_Move_cat<CvString *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ENDP ; std::_Move_cat<CvString *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z ; std::_Ptr_cat<enum ResourceTypes *,enum ResourceTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z PROC ; std::_Ptr_cat<enum ResourceTypes *,enum ResourceTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z ENDP ; std::_Ptr_cat<enum ResourceTypes *,enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z PROC ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>, COMDAT

; 153  : 	return input;

	mov	eax, DWORD PTR _input$[esp-4]

; 154  : }

	ret	0
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ENDP ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@AAPAW4ResourceTypes@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@AAPAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@AAPAW4ResourceTypes@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@AAPAW4ResourceTypes@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getPLOT_VISIBILITY_RANGE
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPLOT_VISIBILITY_RANGE, COMDAT
; _this$ = ecx

; 5272 : 		return m_iPLOT_VISIBILITY_RANGE;

	mov	eax, DWORD PTR [ecx+6196]

; 5273 : 	}

	ret	0
?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPLOT_VISIBILITY_RANGE
_TEXT	ENDS
PUBLIC	??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z ; std::_Destroy<enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z PROC ; std::_Destroy<enum ResourceTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z ENDP ; std::_Destroy<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??_GCvString@@QAEPAXI@Z				; CvString::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvString@@QAEPAXI@Z PROC				; CvString::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvString@@QAEPAXI@Z ENDP				; CvString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBE_NABU01@@Z ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z ; CvWeightedVector<int,64,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,64,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$0EA@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,64,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBE_NABU01@@Z ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$0GE@$00@@QBE_NABU01@@Z ; CvWeightedVector<int,100,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$0GE@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$0GE@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,100,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$0GE@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,100,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::pair<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>::pair<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::pair<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>::pair<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::pair<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>::pair<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>::pair<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::pair<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>::pair<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::pair<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>::pair<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::pair<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>::pair<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::pair<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>::pair<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::pair<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>::pair<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::pair<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>::pair<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator==
_TEXT	ENDS
PUBLIC	??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
_bound_func$ = 16					; size = 4
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z PROC ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>, COMDAT

; 306  : 			GenericMemFuncType &bound_func) {
; 307  : #if defined __DMC__  
; 308  : 		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
; 309  : 		// even though the standard says you can. The 32-bit compiler lets you
; 310  : 		// static_cast through an int, but the DOS compiler doesn't.
; 311  : 		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
; 312  : #else 
; 313  :         bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

	mov	eax, DWORD PTR _bound_func$[esp-4]
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax], ecx

; 314  : #endif
; 315  :         return reinterpret_cast<GenericClass *>(pthis);

	mov	eax, DWORD PTR _pthis$[esp-4]

; 316  : 	}

	ret	0
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ENDP ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z ; std::_Dist_type<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; std::_Dist_type<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z ; std::_Dist_type<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z ; std::_Dist_type<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z ; std::_Construct<enum ResourceTypes,enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z PROC ; std::_Construct<enum ResourceTypes,enum ResourceTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z ENDP ; std::_Construct<enum ResourceTypes,enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::swap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::swap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::swap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::swap<CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::swap<CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::swap<CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::swap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::swap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::swap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::swap<CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::swap<CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@4

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@4:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::swap<CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Iter_random<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap@2
	npad	1
$LL3@Push_heap@2:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap@2

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap@2
$LN1@Push_heap@2:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Iter_random<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap@3
	npad	1
$LL3@Push_heap@3:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap@3

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap@3
$LN1@Push_heap@3:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Iter_random<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@3
	push	esi
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@3
	pop	esi
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap@4
	npad	1
$LL3@Push_heap@4:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap@4

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap@4
$LN1@Push_heap@4:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Iter_random<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@4
	push	esi
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@4
	pop	esi
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_CONTACT_GOLD_FIRST@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_CONTACT_GOLD_FIRST
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMINOR_CIV_CONTACT_GOLD_FIRST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_CONTACT_GOLD_FIRST@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_CONTACT_GOLD_FIRST, COMDAT
; _this$ = ecx

; 6409 : 		return m_iMINOR_CIV_CONTACT_GOLD_FIRST;

	mov	eax, DWORD PTR [ecx+7280]

; 6410 : 	}

	ret	0
?getMINOR_CIV_CONTACT_GOLD_FIRST@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_CONTACT_GOLD_FIRST
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_CONTACT_GOLD_OTHER@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_CONTACT_GOLD_OTHER
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_CONTACT_GOLD_OTHER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_CONTACT_GOLD_OTHER@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_CONTACT_GOLD_OTHER, COMDAT
; _this$ = ecx

; 6413 : 		return m_iMINOR_CIV_CONTACT_GOLD_OTHER;

	mov	eax, DWORD PTR [ecx+7284]

; 6414 : 	}

	ret	0
?getMINOR_CIV_CONTACT_GOLD_OTHER@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_CONTACT_GOLD_OTHER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST, COMDAT
; _this$ = ecx

; 6453 : 		return m_iMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST;

	mov	eax, DWORD PTR [ecx+7324]

; 6454 : 	}

	ret	0
?getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_BUYOUT_COST@CvGlobals@@QAEHXZ	; CvGlobals::getMINOR_CIV_BUYOUT_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_BUYOUT_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_BUYOUT_COST@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_BUYOUT_COST, COMDAT
; _this$ = ecx

; 6457 : 		return m_iMINOR_CIV_BUYOUT_COST;

	mov	eax, DWORD PTR [ecx+7328]

; 6458 : 	}

	ret	0
?getMINOR_CIV_BUYOUT_COST@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_BUYOUT_COST
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_BUYOUT_TURNS@CvGlobals@@QAEHXZ	; CvGlobals::getMINOR_CIV_BUYOUT_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_BUYOUT_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_BUYOUT_TURNS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_BUYOUT_TURNS, COMDAT
; _this$ = ecx

; 6461 : 		return m_iMINOR_CIV_BUYOUT_TURNS;

	mov	eax, DWORD PTR [ecx+7332]

; 6462 : 	}

	ret	0
?getMINOR_CIV_BUYOUT_TURNS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_BUYOUT_TURNS
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_ANCHOR_DEFAULT@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_DEFAULT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_ANCHOR_DEFAULT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_ANCHOR_DEFAULT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_DEFAULT, COMDAT
; _this$ = ecx

; 6469 : 		return m_iMINOR_FRIENDSHIP_ANCHOR_DEFAULT;

	mov	eax, DWORD PTR [ecx+7340]

; 6470 : 	}

	ret	0
?getMINOR_FRIENDSHIP_ANCHOR_DEFAULT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_DEFAULT
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED, COMDAT
; _this$ = ecx

; 6473 : 		return m_iMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED;

	mov	eax, DWORD PTR [ecx+7344]

; 6474 : 	}

	ret	0
?getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED
_TEXT	ENDS
PUBLIC	?getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF, COMDAT
; _this$ = ecx

; 6477 : 		return m_iMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF;

	mov	eax, DWORD PTR [ecx+7348]

; 6478 : 	}

	ret	0
?getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF
_TEXT	ENDS
PUBLIC	?getMAX_EXPERIENCE_PER_COMBAT@CvGlobals@@QAEHXZ	; CvGlobals::getMAX_EXPERIENCE_PER_COMBAT
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_EXPERIENCE_PER_COMBAT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_EXPERIENCE_PER_COMBAT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMAX_EXPERIENCE_PER_COMBAT, COMDAT
; _this$ = ecx

; 6717 : 		return m_iMAX_EXPERIENCE_PER_COMBAT;

	mov	eax, DWORD PTR [ecx+7588]

; 6718 : 	}

	ret	0
?getMAX_EXPERIENCE_PER_COMBAT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMAX_EXPERIENCE_PER_COMBAT
_TEXT	ENDS
PUBLIC	?getGOLD_GIFT_FRIENDSHIP_EXPONENT@CvGlobals@@QAEMXZ ; CvGlobals::getGOLD_GIFT_FRIENDSHIP_EXPONENT
; Function compile flags: /Ogtpy
;	COMDAT ?getGOLD_GIFT_FRIENDSHIP_EXPONENT@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getGOLD_GIFT_FRIENDSHIP_EXPONENT@CvGlobals@@QAEMXZ PROC ; CvGlobals::getGOLD_GIFT_FRIENDSHIP_EXPONENT, COMDAT
; _this$ = ecx

; 7124 : 		return m_fGOLD_GIFT_FRIENDSHIP_EXPONENT;

	fld	DWORD PTR [ecx+8112]

; 7125 : 	}

	ret	0
?getGOLD_GIFT_FRIENDSHIP_EXPONENT@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getGOLD_GIFT_FRIENDSHIP_EXPONENT
_TEXT	ENDS
PUBLIC	?getGOLD_GIFT_FRIENDSHIP_DIVISOR@CvGlobals@@QAEMXZ ; CvGlobals::getGOLD_GIFT_FRIENDSHIP_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getGOLD_GIFT_FRIENDSHIP_DIVISOR@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getGOLD_GIFT_FRIENDSHIP_DIVISOR@CvGlobals@@QAEMXZ PROC	; CvGlobals::getGOLD_GIFT_FRIENDSHIP_DIVISOR, COMDAT
; _this$ = ecx

; 7128 : 		return m_fGOLD_GIFT_FRIENDSHIP_DIVISOR;

	fld	DWORD PTR [ecx+8116]

; 7129 : 	}

	ret	0
?getGOLD_GIFT_FRIENDSHIP_DIVISOR@CvGlobals@@QAEMXZ ENDP	; CvGlobals::getGOLD_GIFT_FRIENDSHIP_DIVISOR
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	?getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION, COMDAT
; _this$ = ecx

; 7439 : 		return m_iESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION;

	mov	eax, DWORD PTR [ecx+7940]

; 7440 : 	}

	ret	0
?getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION
_TEXT	ENDS
PUBLIC	?getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION, COMDAT
; _this$ = ecx

; 7443 : 		return m_iESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION;

	mov	eax, DWORD PTR [ecx+7944]

; 7444 : 	}

	ret	0
?getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ ; CvPlayer::GetPlayerAchievements
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ
_TEXT	SEGMENT
?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ PROC ; CvPlayer::GetPlayerAchievements, COMDAT
; _this$ = ecx

; 1717 : 	CvPlayerAchievements& GetPlayerAchievements(){return m_kPlayerAchievements;}

	lea	eax, DWORD PTR [ecx+63156]
	ret	0
?GetPlayerAchievements@CvPlayer@@QAEAAVCvPlayerAchievements@@XZ ENDP ; CvPlayer::GetPlayerAchievements
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?isAlive@CvTeam@@QBE_NXZ			; CvTeam::isAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isAlive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvTeam@@QBE_NXZ PROC				; CvTeam::isAlive, COMDAT
; _this$ = ecx

; 131  : 		return m_iAliveCount > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	setg	al

; 132  : 	}

	ret	0
?isAlive@CvTeam@@QBE_NXZ ENDP				; CvTeam::isAlive
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetGreatPersonGiftInfluence@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGreatPersonGiftInfluence
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetGreatPersonGiftInfluence@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPersonGiftInfluence@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGreatPersonGiftInfluence, COMDAT
; _this$ = ecx

; 463  : 		return m_iGreatPersonGiftInfluence;

	mov	eax, DWORD PTR [ecx+60]

; 464  : 	};

	ret	0
?GetGreatPersonGiftInfluence@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGreatPersonGiftInfluence
_TEXT	ENDS
PUBLIC	?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetCityStateBonusModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetCityStateBonusModifier, COMDAT
; _this$ = ecx

; 491  : 		return m_iCityStateBonusModifier;

	mov	eax, DWORD PTR [ecx+88]

; 492  : 	};

	ret	0
?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetCityStateBonusModifier
_TEXT	ENDS
PUBLIC	?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetCityStateFriendshipModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetCityStateFriendshipModifier, COMDAT
; _this$ = ecx

; 495  : 		return m_iCityStateFriendshipModifier;

	mov	eax, DWORD PTR [ecx+92]

; 496  : 	};

	ret	0
?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetCityStateFriendshipModifier
_TEXT	ENDS
PUBLIC	?GetAfraidMinorPerTurnInfluence@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetAfraidMinorPerTurnInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetAfraidMinorPerTurnInfluence@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetAfraidMinorPerTurnInfluence@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetAfraidMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 732  : 		return m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR [ecx+316]

; 733  : 	}

	ret	0
?GetAfraidMinorPerTurnInfluence@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetAfraidMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?IsAngerFreeIntrusionOfCityStates@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsAngerFreeIntrusionOfCityStates
; Function compile flags: /Ogtpy
;	COMDAT ?IsAngerFreeIntrusionOfCityStates@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsAngerFreeIntrusionOfCityStates@CvPlayerTraits@@QBE_NXZ PROC ; CvPlayerTraits::IsAngerFreeIntrusionOfCityStates, COMDAT
; _this$ = ecx

; 858  : 		return m_bAngerFreeIntrusionOfCityStates;

	mov	al, BYTE PTR [ecx+355]

; 859  : 	}

	ret	0
?IsAngerFreeIntrusionOfCityStates@CvPlayerTraits@@QBE_NXZ ENDP ; CvPlayerTraits::IsAngerFreeIntrusionOfCityStates
_TEXT	ENDS
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = ecx

; 579  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
_TEXT	ENDS
PUBLIC	?clear@DelegateMemento@fastdelegate@@QAEXXZ	; fastdelegate::DelegateMemento::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@DelegateMemento@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@DelegateMemento@fastdelegate@@QAEXXZ PROC	; fastdelegate::DelegateMemento::clear, COMDAT
; _this$ = ecx

; 580  : 	void clear() {	m_pthis=0; m_pFunction=0;	}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@DelegateMemento@fastdelegate@@QAEXXZ ENDP	; fastdelegate::DelegateMemento::clear
_TEXT	ENDS
PUBLIC	?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ; fastdelegate::DelegateMemento::SetMementoFrom
; Function compile flags: /Ogtpy
;	COMDAT ?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z
_TEXT	SEGMENT
_right$ = 8						; size = 4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z PROC ; fastdelegate::DelegateMemento::SetMementoFrom, COMDAT
; _this$ = ecx

; 637  : 		m_pFunction = right.m_pFunction;

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 638  : 		m_pthis = right.m_pthis;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 639  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 640  : 		m_pStaticFunction = right.m_pStaticFunction;
; 641  : #endif
; 642  : 	}

	ret	4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ENDP ; fastdelegate::DelegateMemento::SetMementoFrom
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ		; FAllocBase<0,0,0>::~FAllocBase<0,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ PROC		; FAllocBase<0,0,0>::~FAllocBase<0,0,0>, COMDAT
; _this$ = ecx

; 34   : 		FAssert( !m_pData );
; 35   : 	}

	ret	0
??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ ENDP		; FAllocBase<0,0,0>::~FAllocBase<0,0,0>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T237695 = -80						; size = 28
$T237694 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T237695[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T237694[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T237695[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T237694[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T237694[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T237694[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T237694[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T237695[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T237694[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@5

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@5:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T237760 = -12						; size = 12
$T237764 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T237764[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T237760[esp+16]
	mov	DWORD PTR $T237764[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T237760[esp+16]
	push	ecx
	mov	DWORD PTR $T237760[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@5

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@5:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T238019 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T238019[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T238019[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T238019[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T238019[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	?GetEndTurn@CvMinorCivQuest@@QBEHXZ		; CvMinorCivQuest::GetEndTurn
EXTRN	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getGreatPeoplePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?GetEndTurn@CvMinorCivQuest@@QBEHXZ
_TEXT	SEGMENT
?GetEndTurn@CvMinorCivQuest@@QBEHXZ PROC		; CvMinorCivQuest::GetEndTurn, COMDAT
; _this$ = ecx

; 81   : {

	push	esi
	push	edi
	mov	edi, ecx

; 82   : 	CvAssertMsg(m_iStartTurn != NO_TURN, "GetEndTurn called for a quest, but the start turn was not initialized!");
; 83   : 
; 84   : 	int iLength = 0;
; 85   : 
; 86   : 	if(m_eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, 10					; 0000000aH

; 87   : 	{
; 88   : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 89   : 	}
; 90   : 
; 91   : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH

; 92   : 	{
; 93   : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 94   : 	}
; 95   : 
; 96   : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH

; 97   : 	{
; 98   : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 99   : 	}
; 100  : 
; 101  : 	else if(m_eType == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH

; 102  : 	{
; 103  : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 104  : 	}
; 105  : 
; 106  : 	else if(m_eType == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8

; 107  : 	{
; 108  : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 109  : 	}
; 110  : 
; 111  : 	else if(m_eType == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9

; 112  : 	{
; 113  : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 114  : 	}
; 115  : 
; 116  : 	else if(m_eType == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH

; 117  : 	{
; 118  : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();

	je	SHORT $LN37@GetEndTurn

; 119  : 	}
; 120  : 
; 121  : 	else if(m_eType == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN2@GetEndTurn
$LN37@GetEndTurn:

; 130  : 	}
; 131  : 
; 132  : 	// Modify for Game Speed
; 133  : 	iLength *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3132
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getGreatPeoplePercent
	mov	ecx, eax
	imul	ecx, esi

; 134  : 	iLength /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 135  : 
; 136  : 	return m_iStartTurn + iLength;

	mov	eax, DWORD PTR [edi+12]
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	pop	edi
	add	eax, ecx
	pop	esi

; 137  : }

	ret	0
$LN2@GetEndTurn:
	pop	edi

; 122  : 	{
; 123  : 		iLength = GC.getMINOR_QUEST_STANDARD_CONTEST_LENGTH();
; 124  : 	}
; 125  : 
; 126  : 	// Other quests are not time-sensitive
; 127  : 	else
; 128  : 	{
; 129  : 		return NO_TURN;

	or	eax, -1
	pop	esi

; 137  : }

	ret	0
?GetEndTurn@CvMinorCivQuest@@QBEHXZ ENDP		; CvMinorCivQuest::GetEndTurn
_TEXT	ENDS
PUBLIC	?GetTurnsRemaining@CvMinorCivQuest@@QBEHH@Z	; CvMinorCivQuest::GetTurnsRemaining
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnsRemaining@CvMinorCivQuest@@QBEHH@Z
_TEXT	SEGMENT
_iCurrentTurn$ = 8					; size = 4
?GetTurnsRemaining@CvMinorCivQuest@@QBEHH@Z PROC	; CvMinorCivQuest::GetTurnsRemaining, COMDAT
; _this$ = ecx

; 141  : {

	push	esi

; 142  : 	int iStartTurn = GetStartTurn();

	mov	esi, DWORD PTR [ecx+12]

; 143  : 	int iEndTurn = GetEndTurn();

	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn

; 144  : 
; 145  : 	if (iStartTurn == NO_TURN)

	cmp	esi, -1
	pop	esi
	jne	SHORT $LN2@GetTurnsRe
$LN7@GetTurnsRe:

; 146  : 		return NO_TURN;

	or	eax, -1

; 152  : }

	ret	4
$LN2@GetTurnsRe:

; 147  : 
; 148  : 	if (iEndTurn == NO_TURN)

	cmp	eax, -1

; 149  : 		return NO_TURN;

	je	SHORT $LN7@GetTurnsRe

; 150  : 
; 151  : 	return (iEndTurn - iCurrentTurn);

	sub	eax, DWORD PTR _iCurrentTurn$[esp-4]

; 152  : }

	ret	4
?GetTurnsRemaining@CvMinorCivQuest@@QBEHH@Z ENDP	; CvMinorCivQuest::GetTurnsRemaining
_TEXT	ENDS
PUBLIC	?GetInfluenceReward@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetInfluenceReward
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceReward@CvMinorCivQuest@@QBEHXZ
_TEXT	SEGMENT
?GetInfluenceReward@CvMinorCivQuest@@QBEHXZ PROC	; CvMinorCivQuest::GetInfluenceReward, COMDAT
; _this$ = ecx

; 169  : 	int iReward = 0;
; 170  : 
; 171  : 	switch(m_eType)

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN1@GetInfluen
	jmp	DWORD PTR $LN60@GetInfluen[eax*4]
$LN19@GetInfluen:

; 172  : 	{
; 173  : 	case MINOR_CIV_QUEST_ROUTE:
; 174  : 		iReward = /*50*/ GC.getMINOR_QUEST_FRIENDSHIP_ROUTE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3060

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN18@GetInfluen:

; 175  : 		break;
; 176  : 	case MINOR_CIV_QUEST_KILL_CAMP:
; 177  : 		iReward = /*50*/ GC.getMINOR_QUEST_FRIENDSHIP_KILL_CAMP();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3064

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN17@GetInfluen:

; 178  : 		break;
; 179  : 	case MINOR_CIV_QUEST_CONNECT_RESOURCE:
; 180  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3068

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN16@GetInfluen:

; 181  : 		break;
; 182  : 	case MINOR_CIV_QUEST_CONSTRUCT_WONDER:
; 183  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3072

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN15@GetInfluen:

; 184  : 		break;
; 185  : 	case MINOR_CIV_QUEST_GREAT_PERSON:
; 186  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_GREAT_PERSON();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3076

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN14@GetInfluen:

; 187  : 		break;
; 188  : 	case MINOR_CIV_QUEST_KILL_CITY_STATE:
; 189  : 		iReward = /*80*/ GC.getMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3080

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN13@GetInfluen:

; 190  : 		break;
; 191  : 	case MINOR_CIV_QUEST_FIND_PLAYER:
; 192  : 		iReward = /*35*/ GC.getMINOR_QUEST_FRIENDSHIP_FIND_PLAYER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3084

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN12@GetInfluen:

; 193  : 		break;
; 194  : 	case MINOR_CIV_QUEST_FIND_NATURAL_WONDER:
; 195  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3088

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN11@GetInfluen:

; 196  : 		break;
; 197  : 	case MINOR_CIV_QUEST_GIVE_GOLD:
; 198  : 		iReward = /*20*/ GC.getMINOR_QUEST_FRIENDSHIP_GIVE_GOLD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3092

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN10@GetInfluen:

; 199  : 		break;
; 200  : 	case MINOR_CIV_QUEST_PLEDGE_TO_PROTECT:
; 201  : 		iReward = /*20*/ GC.getMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3096

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN9@GetInfluen:

; 202  : 		break;
; 203  : 	case MINOR_CIV_QUEST_CONTEST_CULTURE:
; 204  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3100

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN8@GetInfluen:

; 205  : 		break;
; 206  : 	case MINOR_CIV_QUEST_CONTEST_FAITH:
; 207  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3104

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN7@GetInfluen:

; 208  : 		break;
; 209  : 	case MINOR_CIV_QUEST_CONTEST_TECHS:
; 210  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3108

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN6@GetInfluen:

; 211  : 		break;
; 212  : 	case MINOR_CIV_QUEST_INVEST:
; 213  : 		// Reward is indirect; increased gains from gold gifts
; 214  : 		iReward = /*0*/ GC.getMINOR_QUEST_FRIENDSHIP_INVEST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3112

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN5@GetInfluen:

; 215  : 		break;
; 216  : 	case MINOR_CIV_QUEST_BULLY_CITY_STATE:
; 217  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3116

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN4@GetInfluen:

; 218  : 		break;
; 219  : 	case MINOR_CIV_QUEST_DENOUNCE_MAJOR:
; 220  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3120

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN3@GetInfluen:

; 221  : 		break;
; 222  : 	case MINOR_CIV_QUEST_SPREAD_RELIGION:
; 223  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3124

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN2@GetInfluen:

; 224  : 		break;
; 225  : 	case MINOR_CIV_QUEST_TRADE_ROUTE:
; 226  : 		iReward = /*40*/ GC.getMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3128

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
$LN1@GetInfluen:

; 227  : 		break;
; 228  : 	default:
; 229  : 		iReward = 0;

	xor	eax, eax

; 230  : 		break;
; 231  : 	}
; 232  : 
; 233  : 	return iReward;
; 234  : }

	ret	0
	npad	2
$LN60@GetInfluen:
	DD	$LN19@GetInfluen
	DD	$LN18@GetInfluen
	DD	$LN17@GetInfluen
	DD	$LN16@GetInfluen
	DD	$LN15@GetInfluen
	DD	$LN14@GetInfluen
	DD	$LN13@GetInfluen
	DD	$LN12@GetInfluen
	DD	$LN11@GetInfluen
	DD	$LN10@GetInfluen
	DD	$LN9@GetInfluen
	DD	$LN8@GetInfluen
	DD	$LN7@GetInfluen
	DD	$LN6@GetInfluen
	DD	$LN5@GetInfluen
	DD	$LN4@GetInfluen
	DD	$LN3@GetInfluen
	DD	$LN2@GetInfluen
?GetInfluenceReward@CvMinorCivQuest@@QBEHXZ ENDP	; CvMinorCivQuest::GetInfluenceReward
_TEXT	ENDS
PUBLIC	??1?$pair@VCvString@@V1@@std@@QAE@XZ		; std::pair<CvString,CvString>::~pair<CvString,CvString>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@VCvString@@V1@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@VCvString@@V1@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@VCvString@@V1@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@VCvString@@V1@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$pair@VCvString@@V1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@VCvString@@V1@@std@@QAE@XZ PROC		; std::pair<CvString,CvString>::~pair<CvString,CvString>, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1?$pair@VCvString@@V1@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@VCvString@@V1@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1?$pair@VCvString@@V1@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@VCvString@@V1@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@VCvString@@V1@@std@@QAE@XZ ENDP		; std::pair<CvString,CvString>::~pair<CvString,CvString>
PUBLIC	?DoPickPersonality@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoPickPersonality
EXTRN	?ResetToBasePersonality@CvFlavorManager@@QAEXXZ:PROC ; CvFlavorManager::ResetToBasePersonality
EXTRN	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z:PROC ; CvFlavorManager::GetAdjustedValue
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetAllPersonalityFlavors@CvFlavorManager@@QAEPAHXZ:PROC ; CvFlavorManager::GetAllPersonalityFlavors
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?DoPickPersonality@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
_eFlavorCityDefense$ = -12				; size = 4
_eFlavorDefense$ = -8					; size = 4
_this$ = -4						; size = 4
?DoPickPersonality@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoPickPersonality, COMDAT
; _this$ = ecx

; 1902 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 1903 : 
; 1904 : 	FlavorTypes eFlavorCityDefense = NO_FLAVOR;

	or	ebp, -1

; 1905 : 	FlavorTypes eFlavorDefense = NO_FLAVOR;
; 1906 : 	FlavorTypes eFlavorOffense = NO_FLAVOR;
; 1907 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	ebx, ebx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+28], ecx
	mov	DWORD PTR _eFlavorCityDefense$[esp+28], ebp
	mov	DWORD PTR _eFlavorDefense$[esp+28], ebp
	jle	SHORT $LN8@DoPickPers
	mov	edi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	xor	esi, esi
	npad	8
$LL10@DoPickPers:

; 1908 : 	{
; 1909 : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_CITY_DEFENSE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, esi
	push	OFFSET $SG222538
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN7@DoPickPers

; 1910 : 		{
; 1911 : 			eFlavorCityDefense = (FlavorTypes)iFlavorLoop;

	mov	DWORD PTR _eFlavorCityDefense$[esp+28], ebx
$LN7@DoPickPers:

; 1912 : 		}
; 1913 : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_DEFENSE")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+ecx]
	push	OFFSET $SG222542
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN6@DoPickPers

; 1914 : 		{
; 1915 : 			eFlavorDefense = (FlavorTypes)iFlavorLoop;

	mov	DWORD PTR _eFlavorDefense$[esp+28], ebx
$LN6@DoPickPers:

; 1916 : 		}
; 1917 : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_OFFENSE")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+edx]
	push	OFFSET $SG222546
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN9@DoPickPers

; 1918 : 		{
; 1919 : 			eFlavorOffense = (FlavorTypes)iFlavorLoop;

	mov	ebp, ebx
$LN9@DoPickPers:

; 1905 : 	FlavorTypes eFlavorDefense = NO_FLAVOR;
; 1906 : 	FlavorTypes eFlavorOffense = NO_FLAVOR;
; 1907 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	inc	ebx
	add	esi, 28					; 0000001cH
	cmp	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL10@DoPickPers
$LN8@DoPickPers:

; 1920 : 		}
; 1921 : 	}
; 1922 : 
; 1923 : 	CvFlavorManager* pFlavorManager = m_pPlayer->GetFlavorManager();

	mov	eax, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	edi, eax

; 1924 : 	int* pFlavors = pFlavorManager->GetAllPersonalityFlavors();

	mov	ecx, edi
	call	?GetAllPersonalityFlavors@CvFlavorManager@@QAEPAHXZ ; CvFlavorManager::GetAllPersonalityFlavors

; 1925 : 
; 1926 : 	MinorCivPersonalityTypes eRandPersonality = (MinorCivPersonalityTypes) GC.getGame().getJonRandNum(NUM_MINOR_CIV_PERSONALITY_TYPES, "Minor Civ AI: Picking Personality for this Game (should happen only once per player)");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222552
	push	4
	mov	esi, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 1927 : 	m_ePersonality = eRandPersonality;

	mov	ecx, DWORD PTR _this$[esp+28]
	mov	DWORD PTR [ecx+8], eax

; 1928 : 
; 1929 : 	switch(eRandPersonality)

	sub	eax, 0
	je	SHORT $LN2@DoPickPers
	sub	eax, 2
	jne	$LN3@DoPickPers

; 1936 : 		break;
; 1937 : 	case MINOR_CIV_PERSONALITY_HOSTILE:
; 1938 : 		pFlavors[eFlavorCityDefense] = pFlavorManager->GetAdjustedValue(pFlavors[eFlavorCityDefense], 2, 0, 10);

	mov	ebx, DWORD PTR _eFlavorCityDefense$[esp+28]
	mov	edx, DWORD PTR [esi+ebx*4]
	push	10					; 0000000aH
	push	eax
	push	2
	push	edx
	mov	ecx, edi
	call	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z ; CvFlavorManager::GetAdjustedValue

; 1939 : 		pFlavors[eFlavorDefense] = pFlavorManager->GetAdjustedValue(pFlavors[eFlavorDefense], 2, 0, 10);

	push	10					; 0000000aH
	mov	DWORD PTR [esi+ebx*4], eax
	mov	ebx, DWORD PTR _eFlavorDefense$[esp+32]
	mov	eax, DWORD PTR [esi+ebx*4]
	push	0
	push	2
	push	eax
	mov	ecx, edi
	call	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z ; CvFlavorManager::GetAdjustedValue

; 1940 : 		pFlavors[eFlavorOffense] = pFlavorManager->GetAdjustedValue(pFlavors[eFlavorOffense], 2, 0, 10);

	push	10					; 0000000aH
	push	0
	mov	DWORD PTR [esi+ebx*4], eax
	mov	ecx, DWORD PTR [esi+ebp*4]
	push	2
	push	ecx
	mov	ecx, edi
	call	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z ; CvFlavorManager::GetAdjustedValue

; 1941 : 		pFlavorManager->ResetToBasePersonality();

	mov	ecx, edi
	pop	edi
	mov	DWORD PTR [esi+ebp*4], eax
	pop	esi
	pop	ebp
	pop	ebx

; 1942 : 		break;
; 1943 : 	}
; 1944 : }

	add	esp, 12					; 0000000cH

; 1941 : 		pFlavorManager->ResetToBasePersonality();

	jmp	?ResetToBasePersonality@CvFlavorManager@@QAEXXZ ; CvFlavorManager::ResetToBasePersonality
$LN2@DoPickPers:

; 1930 : 	{
; 1931 : 	case MINOR_CIV_PERSONALITY_FRIENDLY:
; 1932 : 		pFlavors[eFlavorCityDefense] = pFlavorManager->GetAdjustedValue(pFlavors[eFlavorCityDefense], -2, 0, 10);

	mov	ebx, DWORD PTR _eFlavorCityDefense$[esp+28]
	mov	edx, DWORD PTR [esi+ebx*4]
	push	10					; 0000000aH
	push	0
	push	-2					; fffffffeH
	push	edx
	mov	ecx, edi
	call	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z ; CvFlavorManager::GetAdjustedValue

; 1933 : 		pFlavors[eFlavorDefense] = pFlavorManager->GetAdjustedValue(pFlavors[eFlavorDefense], -2, 0, 10);

	push	10					; 0000000aH
	mov	DWORD PTR [esi+ebx*4], eax
	mov	ebx, DWORD PTR _eFlavorDefense$[esp+32]
	mov	eax, DWORD PTR [esi+ebx*4]
	push	0
	push	-2					; fffffffeH
	push	eax
	mov	ecx, edi
	call	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z ; CvFlavorManager::GetAdjustedValue

; 1934 : 		pFlavors[eFlavorOffense] = pFlavorManager->GetAdjustedValue(pFlavors[eFlavorOffense], -2, 0, 10);

	push	10					; 0000000aH
	push	0
	mov	DWORD PTR [esi+ebx*4], eax
	mov	ecx, DWORD PTR [esi+ebp*4]
	push	-2					; fffffffeH
	push	ecx
	mov	ecx, edi
	call	?GetAdjustedValue@CvFlavorManager@@QAEHHHHH@Z ; CvFlavorManager::GetAdjustedValue

; 1935 : 		pFlavorManager->ResetToBasePersonality();

	mov	ecx, edi
	pop	edi
	mov	DWORD PTR [esi+ebp*4], eax
	pop	esi
	pop	ebp
	pop	ebx

; 1942 : 		break;
; 1943 : 	}
; 1944 : }

	add	esp, 12					; 0000000cH

; 1935 : 		pFlavorManager->ResetToBasePersonality();

	jmp	?ResetToBasePersonality@CvFlavorManager@@QAEXXZ ; CvFlavorManager::ResetToBasePersonality
$LN3@DoPickPers:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1942 : 		break;
; 1943 : 	}
; 1944 : }

	add	esp, 12					; 0000000cH
	ret	0
?DoPickPersonality@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoPickPersonality
_TEXT	ENDS
PUBLIC	?GetFirstPossibleTurnForPersonalQuests@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetFirstPossibleTurnForPersonalQuests
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstPossibleTurnForPersonalQuests@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetFirstPossibleTurnForPersonalQuests@CvMinorCivAI@@QBEHXZ PROC ; CvMinorCivAI::GetFirstPossibleTurnForPersonalQuests, COMDAT
; _this$ = ecx

; 2912 : 	return /*30*/ GC.getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3212

; 2913 : }

	ret	0
?GetFirstPossibleTurnForPersonalQuests@CvMinorCivAI@@QBEHXZ ENDP ; CvMinorCivAI::GetFirstPossibleTurnForPersonalQuests
_TEXT	ENDS
PUBLIC	?GetFirstPossibleTurnForGlobalQuests@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetFirstPossibleTurnForGlobalQuests
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstPossibleTurnForGlobalQuests@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetFirstPossibleTurnForGlobalQuests@CvMinorCivAI@@QBEHXZ PROC ; CvMinorCivAI::GetFirstPossibleTurnForGlobalQuests, COMDAT
; _this$ = ecx

; 2918 : 	return /*30*/ GC.getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3192

; 2919 : }

	ret	0
?GetFirstPossibleTurnForGlobalQuests@CvMinorCivAI@@QBEHXZ ENDP ; CvMinorCivAI::GetFirstPossibleTurnForGlobalQuests
_TEXT	ENDS
PUBLIC	?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsEnabledQuest
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eQuest$ = 8						; size = 4
?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsEnabledQuest, COMDAT
; _this$ = ecx

; 3344 : 	// BUILD A ROUTE
; 3345 : 	if(eQuest == MINOR_CIV_QUEST_ROUTE)

	mov	eax, DWORD PTR _eQuest$[esp-4]
	push	ebx

; 3346 : 	{
; 3347 : 		if(GC.getQUEST_DISABLED_ROUTE() == 1)

	mov	ebx, 1
	test	eax, eax
	jne	SHORT $LN57@IsEnabledQ
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3252, ebx
	jne	$LN1@IsEnabledQ
$LN104@IsEnabledQ:

; 3348 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN57@IsEnabledQ:

; 3349 : 	}
; 3350 : 	// KILL A CAMP
; 3351 : 	else if(eQuest == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	eax, ebx
	jne	SHORT $LN54@IsEnabledQ

; 3352 : 	{
; 3353 : 		if(GC.getQUEST_DISABLED_KILL_CAMP() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3256, ebx
	jne	$LN1@IsEnabledQ

; 3354 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN54@IsEnabledQ:

; 3355 : 	}
; 3356 : 	// CONNECT A RESOURCE
; 3357 : 	else if(eQuest == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	eax, 2
	jne	SHORT $LN51@IsEnabledQ

; 3358 : 	{
; 3359 : 		if(GC.getQUEST_DISABLED_CONNECT_RESOURCE() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3260, ebx
	jne	$LN1@IsEnabledQ

; 3360 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN51@IsEnabledQ:

; 3361 : 	}
; 3362 : 	// CONSTRUCT A WONDER
; 3363 : 	else if(eQuest == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	SHORT $LN48@IsEnabledQ

; 3364 : 	{
; 3365 : 		if(GC.getQUEST_DISABLED_CONSTRUCT_WONDER() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3264, ebx
	jne	$LN1@IsEnabledQ

; 3366 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN48@IsEnabledQ:

; 3367 : 	}
; 3368 : 	// GREAT PERSON
; 3369 : 	else if(eQuest == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4
	jne	SHORT $LN45@IsEnabledQ

; 3370 : 	{
; 3371 : 		if(GC.getQUEST_DISABLED_GREAT_PERSON() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3268, ebx
	jne	$LN1@IsEnabledQ

; 3372 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN45@IsEnabledQ:

; 3373 : 	}
; 3374 : 	// KILL ANOTHER CITY STATE
; 3375 : 	else if(eQuest == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	SHORT $LN42@IsEnabledQ

; 3376 : 	{
; 3377 : 		if(GC.getQUEST_DISABLED_KILL_CITY_STATE() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3272, ebx
	jne	$LN1@IsEnabledQ

; 3378 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN42@IsEnabledQ:

; 3379 : 	}
; 3380 : 	// FIND ANOTHER PLAYER
; 3381 : 	else if(eQuest == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6
	jne	SHORT $LN39@IsEnabledQ

; 3382 : 	{
; 3383 : 		if(GC.getQUEST_DISABLED_FIND_PLAYER() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3276, ebx
	jne	$LN1@IsEnabledQ

; 3384 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN39@IsEnabledQ:

; 3385 : 	}
; 3386 : 	// FIND NATURAL WONDER
; 3387 : 	else if(eQuest == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7
	jne	SHORT $LN36@IsEnabledQ

; 3388 : 	{
; 3389 : 		if(GC.getQUEST_DISABLED_NATURAL_WONDER() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3280, ebx
	jne	$LN1@IsEnabledQ

; 3390 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN36@IsEnabledQ:

; 3391 : 	}
; 3392 : 	// GOLD GIFT
; 3393 : 	else if(eQuest == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8
	jne	SHORT $LN33@IsEnabledQ

; 3394 : 	{
; 3395 : 		if(GC.getQUEST_DISABLED_GIVE_GOLD() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3284, ebx
	jne	$LN1@IsEnabledQ

; 3396 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN33@IsEnabledQ:

; 3397 : 	}
; 3398 : 	// PLEDGE TO PROTECT
; 3399 : 	else if(eQuest == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9
	jne	SHORT $LN30@IsEnabledQ

; 3400 : 	{
; 3401 : 		if(GC.getQUEST_DISABLED_PLEDGE_TO_PROTECT() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3288, ebx
	jne	$LN1@IsEnabledQ

; 3402 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN30@IsEnabledQ:

; 3403 : 	}
; 3404 : 	// CONTEST CULTURE
; 3405 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN27@IsEnabledQ

; 3406 : 	{
; 3407 : 		if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	18					; 00000012H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 3408 : 			return false;

	jne	$LN104@IsEnabledQ

; 3409 : 
; 3410 : 		if(GC.getQUEST_DISABLED_CONTEST_CULTURE() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3292, ebx
	jne	$LN1@IsEnabledQ
	pop	ebx

; 3466 : }

	ret	4
$LN27@IsEnabledQ:

; 3411 : 			return false;
; 3412 : 	}
; 3413 : 	// CONTEST FAITH
; 3414 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN23@IsEnabledQ

; 3415 : 	{
; 3416 : 		if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	21					; 00000015H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 3417 : 			return false;

	jne	$LN104@IsEnabledQ

; 3418 : 
; 3419 : 		if(GC.getQUEST_DISABLED_CONTEST_FAITH() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3296, ebx
	jne	$LN1@IsEnabledQ
	pop	ebx

; 3466 : }

	ret	4
$LN23@IsEnabledQ:

; 3420 : 			return false;
; 3421 : 	}
; 3422 : 	// CONTEST TECHS
; 3423 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN19@IsEnabledQ

; 3424 : 	{
; 3425 : 		if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	17					; 00000011H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 3426 : 			return false;

	jne	$LN104@IsEnabledQ

; 3427 : 
; 3428 : 		if(GC.getQUEST_DISABLED_CONTEST_TECHS() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3300, ebx
	jne	SHORT $LN1@IsEnabledQ
	pop	ebx

; 3466 : }

	ret	4
$LN19@IsEnabledQ:

; 3429 : 			return false;
; 3430 : 	}
; 3431 : 	// Invest
; 3432 : 	else if(eQuest == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN15@IsEnabledQ

; 3433 : 	{
; 3434 : 		if(GC.getQUEST_DISABLED_INVEST() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3304, ebx
	jne	SHORT $LN1@IsEnabledQ

; 3435 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN15@IsEnabledQ:

; 3436 : 	}
; 3437 : 	// Bully target City-State
; 3438 : 	else if(eQuest == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN12@IsEnabledQ

; 3439 : 	{
; 3440 : 		if(GC.getQUEST_DISABLED_BULLY_CITY_STATE() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3308, ebx
	jne	SHORT $LN1@IsEnabledQ

; 3441 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN12@IsEnabledQ:

; 3442 : 	}
; 3443 : 	// Denounce target Major
; 3444 : 	else if(eQuest == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN9@IsEnabledQ

; 3445 : 	{
; 3446 : 		if(GC.getQUEST_DISABLED_DENOUNCE_MAJOR() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3312, ebx
	jne	SHORT $LN1@IsEnabledQ

; 3447 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN9@IsEnabledQ:

; 3448 : 	}
; 3449 : 	// Spread your religion to us
; 3450 : 	else if(eQuest == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN6@IsEnabledQ

; 3451 : 	{
; 3452 : 		if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	21					; 00000015H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 3453 : 			return false;

	jne	$LN104@IsEnabledQ

; 3454 : 
; 3455 : 		if(GC.getQUEST_DISABLED_SPREAD_RELIGION() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3316, ebx
	jne	SHORT $LN1@IsEnabledQ
	pop	ebx

; 3466 : }

	ret	4
$LN6@IsEnabledQ:

; 3456 : 			return false;
; 3457 : 	}
; 3458 : 	// Trade Route
; 3459 : 	else if(eQuest == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN1@IsEnabledQ

; 3460 : 	{
; 3461 : 		if(GC.getQUEST_DISABLED_TRADE_ROUTE() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3320, ebx
	jne	SHORT $LN1@IsEnabledQ

; 3462 : 			return false;

	xor	al, al
	pop	ebx

; 3466 : }

	ret	4
$LN1@IsEnabledQ:

; 3463 : 	}
; 3464 : 
; 3465 : 	return true;

	mov	al, bl
	pop	ebx

; 3466 : }

	ret	4
?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsEnabledQuest
_TEXT	ENDS
PUBLIC	?GetMinPlayersNeededForQuest@CvMinorCivAI@@QBEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetMinPlayersNeededForQuest
EXTRN	?countMajorCivsEverAlive@CvGame@@QBEHXZ:PROC	; CvGame::countMajorCivsEverAlive
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinPlayersNeededForQuest@CvMinorCivAI@@QBEHW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_iPlayersNeeded$ = -4					; size = 4
_iMajorsEverAlive$ = 8					; size = 4
_eQuest$ = 8						; size = 4
?GetMinPlayersNeededForQuest@CvMinorCivAI@@QBEHW4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::GetMinPlayersNeededForQuest, COMDAT
; _this$ = ecx

; 3871 : {

	push	ecx

; 3872 : 	int iPlayersNeeded = 1;
; 3873 : 
; 3874 : 	if(eQuest == MINOR_CIV_QUEST_CONTEST_CULTURE)

	mov	eax, DWORD PTR _eQuest$[esp]
	push	esi
	mov	esi, 1
	mov	DWORD PTR _iPlayersNeeded$[esp+8], esi
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN7@GetMinPlay

; 3875 : 	{
; 3876 : 		iPlayersNeeded = 3; //antonjs: todo: XML

	lea	esi, DWORD PTR [eax-7]
	jmp	SHORT $LN16@GetMinPlay
$LN7@GetMinPlay:

; 3877 : 	}
; 3878 : 
; 3879 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN5@GetMinPlay

; 3880 : 	{
; 3881 : 		iPlayersNeeded = 3; //antonjs: todo: XML

	lea	esi, DWORD PTR [eax-8]
	jmp	SHORT $LN16@GetMinPlay
$LN5@GetMinPlay:

; 3882 : 	}
; 3883 : 
; 3884 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN3@GetMinPlay

; 3885 : 	{
; 3886 : 		iPlayersNeeded = 3; //antonjs: todo: XML

	lea	esi, DWORD PTR [eax-9]
	jmp	SHORT $LN16@GetMinPlay
$LN3@GetMinPlay:

; 3887 : 	}
; 3888 : 
; 3889 : 	else if(eQuest == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN1@GetMinPlay

; 3890 : 	{
; 3891 : 		iPlayersNeeded = 2; //antonjs: todo: XML

	mov	esi, 2
$LN16@GetMinPlay:
	mov	DWORD PTR _iPlayersNeeded$[esp+8], esi
$LN1@GetMinPlay:

; 3892 : 	}
; 3893 : 
; 3894 : 	int iMajorsEverAlive = GC.getGame().countMajorCivsEverAlive();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?countMajorCivsEverAlive@CvGame@@QBEHXZ	; CvGame::countMajorCivsEverAlive

; 3895 : 	iPlayersNeeded = min(iPlayersNeeded, iMajorsEverAlive);

	cmp	eax, esi
	mov	DWORD PTR _iMajorsEverAlive$[esp+4], eax
	pop	esi
	lea	eax, DWORD PTR _iMajorsEverAlive$[esp]
	jl	SHORT $LN17@GetMinPlay
	lea	eax, DWORD PTR _iPlayersNeeded$[esp+4]
$LN17@GetMinPlay:

; 3896 : 
; 3897 : 	return iPlayersNeeded;

	mov	eax, DWORD PTR [eax]

; 3898 : }

	pop	ecx
	ret	4
?GetMinPlayersNeededForQuest@CvMinorCivAI@@QBEHW4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::GetMinPlayersNeededForQuest
_TEXT	ENDS
PUBLIC	?GetNumActiveQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumActiveQuestsForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumActiveQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumActiveQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNumActiveQuestsForPlayer, COMDAT
; _this$ = ecx

; 4216 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4217 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4218 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN1@GetNumActi

; 4219 : 
; 4220 : 	return m_QuestsGiven[ePlayer].size();

	mov	ecx, DWORD PTR [ecx+3328]
	imul	eax, 156				; 0000009cH
	mov	eax, DWORD PTR [ecx+eax+4]

; 4221 : }

	ret	4
$LN1@GetNumActi:

; 4216 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4217 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4218 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	xor	eax, eax

; 4221 : }

	ret	4
?GetNumActiveQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNumActiveQuestsForPlayer
_TEXT	ENDS
PUBLIC	?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumActivePersonalQuestsForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNumActivePersonalQuestsForPlayer, COMDAT
; _this$ = ecx

; 4225 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4226 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4227 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	mov	edx, DWORD PTR _ePlayer$[esp-4]

; 4228 : 
; 4229 : 	int iCount = 0;

	xor	eax, eax
	cmp	edx, 21					; 00000015H
	ja	SHORT $LN7@GetNumActi@2

; 4230 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	edx, 156				; 0000009cH
	add	ecx, edx
	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jbe	SHORT $LN7@GetNumActi@2
	push	esi
	mov	esi, DWORD PTR [ecx]
	add	esi, 8
$LL4@GetNumActi@2:

; 4231 : 	{
; 4232 : 		if(IsPersonalQuest(m_QuestsGiven[ePlayer][iQuestLoop].GetType()))

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, 1
	je	SHORT $LN3@GetNumActi@2
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN3@GetNumActi@2
	cmp	ecx, 11					; 0000000bH
	je	SHORT $LN3@GetNumActi@2
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN3@GetNumActi@2
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN3@GetNumActi@2

; 4233 : 		{
; 4234 : 			iCount++;

	inc	eax
$LN3@GetNumActi@2:

; 4230 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	add	esi, 28					; 0000001cH
	sub	edx, 1
	jne	SHORT $LL4@GetNumActi@2
	pop	esi
$LN7@GetNumActi@2:

; 4235 : 		}
; 4236 : 	}
; 4237 : 
; 4238 : 	return iCount;
; 4239 : }

	ret	4
?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNumActivePersonalQuestsForPlayer
_TEXT	ENDS
PUBLIC	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsActiveQuestForPlayer, COMDAT
; _this$ = ecx

; 4243 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4244 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4245 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	edx, DWORD PTR _ePlayer$[esp-4]
	cmp	edx, 21					; 00000015H
	ja	SHORT $LN7@IsActiveQu
	push	esi

; 4246 : 
; 4247 : 	CvAssertMsg(eType >= NO_MINOR_CIV_QUEST_TYPE, "eType is expected to be non-negative (invalid Index)");
; 4248 : 	CvAssertMsg(eType < NUM_MINOR_CIV_QUEST_TYPES, "eType is expected to be within maximum bounds (invalid Index)");
; 4249 : 	if(eType < NO_MINOR_CIV_QUEST_TYPE || eType >= NUM_MINOR_CIV_QUEST_TYPES) return false;

	mov	esi, DWORD PTR _eType$[esp]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, 18					; 00000012H
	ja	SHORT $LN5@IsActiveQu

; 4250 : 
; 4251 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	edx, 156				; 0000009cH
	add	ecx, edx
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	test	edx, edx
	jbe	SHORT $LN5@IsActiveQu
	mov	ecx, DWORD PTR [ecx]
	add	ecx, 8
$LL4@IsActiveQu:

; 4252 : 	{
; 4253 : 		if(m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN22@IsActiveQu
	inc	eax
	add	ecx, 28					; 0000001cH
	cmp	eax, edx
	jb	SHORT $LL4@IsActiveQu
$LN5@IsActiveQu:

; 4246 : 
; 4247 : 	CvAssertMsg(eType >= NO_MINOR_CIV_QUEST_TYPE, "eType is expected to be non-negative (invalid Index)");
; 4248 : 	CvAssertMsg(eType < NUM_MINOR_CIV_QUEST_TYPES, "eType is expected to be within maximum bounds (invalid Index)");
; 4249 : 	if(eType < NO_MINOR_CIV_QUEST_TYPE || eType >= NUM_MINOR_CIV_QUEST_TYPES) return false;

	xor	al, al
	pop	esi

; 4256 : 		}
; 4257 : 	}
; 4258 : 
; 4259 : 	return false;
; 4260 : }

	ret	8
$LN22@IsActiveQu:

; 4254 : 		{
; 4255 : 			return true;

	mov	al, 1
	pop	esi

; 4256 : 		}
; 4257 : 	}
; 4258 : 
; 4259 : 	return false;
; 4260 : }

	ret	8
$LN7@IsActiveQu:

; 4243 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4244 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4245 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 4256 : 		}
; 4257 : 	}
; 4258 : 
; 4259 : 	return false;
; 4260 : }

	ret	8
?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsActiveQuestForPlayer
_TEXT	ENDS
PUBLIC	?GetNumDisplayedQuestsForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumDisplayedQuestsForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumDisplayedQuestsForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumDisplayedQuestsForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNumDisplayedQuestsForPlayer, COMDAT
; _this$ = ecx

; 4276 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4277 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4278 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0;

	mov	edx, DWORD PTR _ePlayer$[esp-4]

; 4279 : 
; 4280 : 	int iValue = 0;

	xor	eax, eax
	cmp	edx, 21					; 00000015H
	ja	SHORT $LN7@GetNumDisp

; 4281 : 	
; 4282 : 	for (uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	edx, 156				; 0000009cH
	add	ecx, edx
	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jbe	SHORT $LN7@GetNumDisp
	mov	ecx, DWORD PTR [ecx]
	add	ecx, 24					; 00000018H
$LL4@GetNumDisp:

; 4283 : 	{
; 4284 : 		if(!m_QuestsGiven[ePlayer][iQuestLoop].IsHandled())

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN3@GetNumDisp

; 4285 : 		{
; 4286 : 			iValue++;

	inc	eax
$LN3@GetNumDisp:

; 4281 : 	
; 4282 : 	for (uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	add	ecx, 28					; 0000001cH
	sub	edx, 1
	jne	SHORT $LL4@GetNumDisp
$LN7@GetNumDisp:

; 4287 : 		}
; 4288 : 	}
; 4289 : 
; 4290 : 	return iValue;
; 4291 : }

	ret	4
?GetNumDisplayedQuestsForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNumDisplayedQuestsForPlayer
_TEXT	ENDS
PUBLIC	?IsDisplayedQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsDisplayedQuestForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsDisplayedQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
?IsDisplayedQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsDisplayedQuestForPlayer, COMDAT
; _this$ = ecx

; 4295 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4296 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4297 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN8@IsDisplaye
	push	esi

; 4298 : 
; 4299 : 	CvAssertMsg(eType >= NO_MINOR_CIV_QUEST_TYPE, "eType is expected to be non-negative (invalid Index)");
; 4300 : 	CvAssertMsg(eType < NUM_MINOR_CIV_QUEST_TYPES, "eType is expected to be within maximum bounds (invalid Index)");
; 4301 : 	if(eType < NO_MINOR_CIV_QUEST_TYPE || eType >= NUM_MINOR_CIV_QUEST_TYPES) return false;

	mov	esi, DWORD PTR _eType$[esp]
	lea	edx, DWORD PTR [esi+1]
	cmp	edx, 18					; 00000012H
	ja	SHORT $LN6@IsDisplaye

; 4302 : 
; 4303 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	eax, 156				; 0000009cH
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	xor	edx, edx
	test	ecx, ecx
	jbe	SHORT $LN6@IsDisplaye
	mov	eax, DWORD PTR [eax]
	add	eax, 24					; 00000018H
$LL5@IsDisplaye:

; 4304 : 	{
; 4305 : 		if(m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [eax-16], esi
	jne	SHORT $LN4@IsDisplaye

; 4306 : 		{
; 4307 : 			if(!m_QuestsGiven[ePlayer][iQuestLoop].IsHandled())

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN29@IsDisplaye
$LN4@IsDisplaye:

; 4302 : 
; 4303 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	inc	edx
	add	eax, 28					; 0000001cH
	cmp	edx, ecx
	jb	SHORT $LL5@IsDisplaye
$LN6@IsDisplaye:

; 4298 : 
; 4299 : 	CvAssertMsg(eType >= NO_MINOR_CIV_QUEST_TYPE, "eType is expected to be non-negative (invalid Index)");
; 4300 : 	CvAssertMsg(eType < NUM_MINOR_CIV_QUEST_TYPES, "eType is expected to be within maximum bounds (invalid Index)");
; 4301 : 	if(eType < NO_MINOR_CIV_QUEST_TYPE || eType >= NUM_MINOR_CIV_QUEST_TYPES) return false;

	xor	al, al
	pop	esi

; 4310 : 			}
; 4311 : 		}
; 4312 : 	}
; 4313 : 
; 4314 : 	return false;
; 4315 : }

	ret	8
$LN29@IsDisplaye:

; 4308 : 			{
; 4309 : 				return true;

	mov	al, 1
	pop	esi

; 4310 : 			}
; 4311 : 		}
; 4312 : 	}
; 4313 : 
; 4314 : 	return false;
; 4315 : }

	ret	8
$LN8@IsDisplaye:

; 4295 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4296 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4297 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 4310 : 			}
; 4311 : 		}
; 4312 : 	}
; 4313 : 
; 4314 : 	return false;
; 4315 : }

	ret	8
?IsDisplayedQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsDisplayedQuestForPlayer
_TEXT	ENDS
PUBLIC	?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
; Function compile flags: /Ogtpy
;	COMDAT ?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bForceSeed$ = 12					; size = 1
?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z PROC ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer, COMDAT
; _this$ = ecx

; 4380 : 	if(!bForceSeed)

	cmp	BYTE PTR _bForceSeed$[esp-4], 0
	push	ebx
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	ebx, ecx
	jne	SHORT $LN4@DoTestSeed

; 4381 : 	{
; 4382 : 		// Only seed if there is a potential spot for a personal quest for this player
; 4383 : 		if(GetNumActivePersonalQuestsForPlayer(ePlayer) >= GetMaxActivePersonalQuestsForPlayer())

	push	edi
	call	?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumActivePersonalQuestsForPlayer
	cmp	eax, 2
	jge	$LN37@DoTestSeed

; 4384 : 		{
; 4385 : 			return;
; 4386 : 		}
; 4387 : 
; 4388 : 		// Only seed if the countdown for this player is not already active
; 4389 : 		if(GetQuestCountdownForPlayer(ePlayer) > 0)

	cmp	edi, 21					; 00000015H
	ja	SHORT $LN4@DoTestSeed
	cmp	DWORD PTR [ebx+edi*4+2464], 0
	jg	$LN37@DoTestSeed
$LN4@DoTestSeed:

; 4390 : 		{
; 4391 : 			return;
; 4392 : 		}
; 4393 : 	}
; 4394 : 
; 4395 : 	int iNumTurns = 0;
; 4396 : 
; 4397 : 	// Quests are now available for the first time?
; 4398 : 	if(GC.getGame().getElapsedGameTurns() == GetFirstPossibleTurnForPersonalQuests())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3212
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jne	SHORT $LN3@DoTestSeed

; 4399 : 	{
; 4400 : 		int iRand = /*20*/ GC.getMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3216

; 4401 : 		iNumTurns += GC.getGame().getJonRandNum(iRand, "Random # of turns for Minor Civ personal quest counter - first time.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225033
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	esi, eax

; 4402 : 	}
; 4403 : 	else

	jmp	SHORT $LN2@DoTestSeed
$LN3@DoTestSeed:

; 4404 : 	{
; 4405 : 		iNumTurns += /*20*/ GC.getMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN();
; 4406 : 
; 4407 : 		int iRand = /*25*/ GC.getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN();
; 4408 : 		if(GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)

	cmp	DWORD PTR [ebx+8], 2
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3220
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3224
	jne	SHORT $LN1@DoTestSeed

; 4409 : 		{
; 4410 : 			iRand *= /*200*/ GC.getMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3228
	imul	ecx, eax

; 4411 : 			iRand /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN1@DoTestSeed:

; 4412 : 		}
; 4413 : 		iNumTurns += GC.getGame().getJonRandNum(iRand, "Random # of turns for Minor Civ personal quest counter.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225037
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	esi, eax
$LN2@DoTestSeed:

; 4414 : 	}
; 4415 : 
; 4416 : 	// Modify for Game Speed
; 4417 : 	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getGreatPeoplePercent
	mov	ecx, eax
	imul	ecx, esi

; 4418 : 	iNumTurns /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 4419 : 
; 4420 : 	SetQuestCountdownForPlayer(ePlayer, iNumTurns);

	cmp	edi, 21					; 00000015H
	ja	SHORT $LN37@DoTestSeed
	mov	DWORD PTR [ebx+edi*4+2464], eax
$LN37@DoTestSeed:
	pop	edi
	pop	ebx

; 4421 : }

	ret	8
?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ENDP ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer
_TEXT	ENDS
PUBLIC	?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetQuestData1
; Function compile flags: /Ogtpy
;	COMDAT ?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::GetQuestData1, COMDAT
; _this$ = ecx

; 4515 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4516 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4517 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) CvMinorCivQuest::NO_QUEST_DATA;
; 4518 : 
; 4519 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	edx, DWORD PTR _ePlayer$[esp-4]
	mov	ecx, DWORD PTR [ecx+3328]
	imul	edx, 156				; 0000009cH
	add	ecx, edx
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	xor	eax, eax
	push	edi
	test	edx, edx
	jbe	SHORT $LN2@GetQuestDa
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR _eType$[esp+4]
	lea	ecx, DWORD PTR [esi+8]
$LL4@GetQuestDa:

; 4520 : 	{
; 4521 : 		if(m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN26@GetQuestDa
	inc	eax
	add	ecx, 28					; 0000001cH
	cmp	eax, edx
	jb	SHORT $LL4@GetQuestDa
$LN2@GetQuestDa:
	pop	edi

; 4524 : 		}
; 4525 : 	}
; 4526 : 
; 4527 : 	return CvMinorCivQuest::NO_QUEST_DATA;

	or	eax, -1
	pop	esi

; 4528 : }

	ret	8
$LN26@GetQuestDa:

; 4522 : 		{
; 4523 : 			return m_QuestsGiven[ePlayer][iQuestLoop].GetPrimaryData();

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [esi+edx*4+16]
	pop	edi
	pop	esi

; 4528 : }

	ret	8
?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::GetQuestData1
_TEXT	ENDS
PUBLIC	?GetQuestData2@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetQuestData2
; Function compile flags: /Ogtpy
;	COMDAT ?GetQuestData2@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
?GetQuestData2@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::GetQuestData2, COMDAT
; _this$ = ecx

; 4533 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4534 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4535 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return CvMinorCivQuest::NO_QUEST_DATA;

	mov	edx, DWORD PTR _ePlayer$[esp-4]
	cmp	edx, 21					; 00000015H
	ja	SHORT $LN5@GetQuestDa@2

; 4536 : 
; 4537 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	edx, 156				; 0000009cH
	add	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	esi
	xor	eax, eax
	push	edi
	test	ecx, ecx
	jbe	SHORT $LN2@GetQuestDa@2
	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR _eType$[esp+4]
	lea	edx, DWORD PTR [esi+8]
	npad	5
$LL4@GetQuestDa@2:

; 4538 : 	{
; 4539 : 		if(m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [edx], edi
	je	SHORT $LN26@GetQuestDa@2
	inc	eax
	add	edx, 28					; 0000001cH
	cmp	eax, ecx
	jb	SHORT $LL4@GetQuestDa@2
$LN2@GetQuestDa@2:
	pop	edi

; 4542 : 		}
; 4543 : 	}
; 4544 : 
; 4545 : 	return CvMinorCivQuest::NO_QUEST_DATA;

	or	eax, -1
	pop	esi

; 4546 : }

	ret	8
$LN26@GetQuestDa@2:

; 4540 : 		{
; 4541 : 			return m_QuestsGiven[ePlayer][iQuestLoop].GetSecondaryData();

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [esi+edx*4+20]
	pop	edi
	pop	esi

; 4546 : }

	ret	8
$LN5@GetQuestDa@2:

; 4533 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4534 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4535 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return CvMinorCivQuest::NO_QUEST_DATA;

	or	eax, -1

; 4546 : }

	ret	8
?GetQuestData2@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::GetQuestData2
_TEXT	ENDS
PUBLIC	?GetQuestTurnsRemaining@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ; CvMinorCivAI::GetQuestTurnsRemaining
; Function compile flags: /Ogtpy
;	COMDAT ?GetQuestTurnsRemaining@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
_iGameTurn$ = 16					; size = 4
?GetQuestTurnsRemaining@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z PROC ; CvMinorCivAI::GetQuestTurnsRemaining, COMDAT
; _this$ = ecx

; 4550 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4551 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4552 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return CvMinorCivQuest::NO_TURN;

	mov	edx, DWORD PTR _ePlayer$[esp-4]
	cmp	edx, 21					; 00000015H
	ja	SHORT $LN5@GetQuestTu

; 4553 : 
; 4554 : 	for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	edx, 156				; 0000009cH
	add	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	esi
	xor	eax, eax
	push	edi
	test	ecx, ecx
	jbe	SHORT $LN2@GetQuestTu
	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR _eType$[esp+4]
	lea	edx, DWORD PTR [esi+8]
	npad	5
$LL4@GetQuestTu:

; 4555 : 	{
; 4556 : 		if(m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [edx], edi
	je	SHORT $LN30@GetQuestTu
	inc	eax
	add	edx, 28					; 0000001cH
	cmp	eax, ecx
	jb	SHORT $LL4@GetQuestTu
$LN2@GetQuestTu:
	pop	edi

; 4559 : 		}
; 4560 : 	}
; 4561 : 
; 4562 : 	return CvMinorCivQuest::NO_TURN;

	or	eax, -1
	pop	esi

; 4563 : }

	ret	12					; 0000000cH
$LN30@GetQuestTu:

; 4557 : 		{
; 4558 : 			return m_QuestsGiven[ePlayer][iQuestLoop].GetTurnsRemaining(iGameTurn);

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	ecx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [ecx+12]
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	cmp	esi, -1
	je	SHORT $LN2@GetQuestTu
	cmp	eax, -1
	je	SHORT $LN2@GetQuestTu
	sub	eax, DWORD PTR _iGameTurn$[esp+4]
	pop	edi
	pop	esi

; 4563 : }

	ret	12					; 0000000cH
$LN5@GetQuestTu:

; 4550 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4551 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4552 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return CvMinorCivQuest::NO_TURN;

	or	eax, -1

; 4563 : }

	ret	12					; 0000000cH
?GetQuestTurnsRemaining@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ENDP ; CvMinorCivAI::GetQuestTurnsRemaining
_TEXT	ENDS
PUBLIC	?DoUpdateAlliesResourceBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z ; CvMinorCivAI::DoUpdateAlliesResourceBonus
EXTRN	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceTotal
EXTRN	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeResourceExport
EXTRN	?changeResourceFromMinors@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeResourceFromMinors
EXTRN	?getResourceExport@CvPlayer@@QBEHW4ResourceTypes@@@Z:PROC ; CvPlayer::getResourceExport
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
; Function compile flags: /Ogtpy
;	COMDAT ?DoUpdateAlliesResourceBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eNewAlly$ = 8						; size = 4
_eOldAlly$ = 12						; size = 4
?DoUpdateAlliesResourceBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z PROC ; CvMinorCivAI::DoUpdateAlliesResourceBonus, COMDAT
; _this$ = ecx

; 5600 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 5601 : 	FAssertMsg(eNewAlly != NO_PLAYER || eOldAlly != NO_PLAYER, "MINOR CIV AI: Updating Allied resource bonus and both players are not defined!");
; 5602 : 
; 5603 : 	// Change gifted Resources
; 5604 : 	ResourceTypes eResource;
; 5605 : 	ResourceUsageTypes eUsage;
; 5606 : 	int iResourceQuantity;
; 5607 : #ifdef AUI_WARNING_FIXES
; 5608 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 5609 : #else
; 5610 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN8@DoUpdateAl
	push	ebp
	mov	ebp, DWORD PTR _eOldAlly$[esp+8]
	push	edi
	npad	2
$LL29@DoUpdateAl:

; 5611 : #endif
; 5612 : 	{
; 5613 : 		eResource = (ResourceTypes) iResourceLoop;
; 5614 : 
; 5615 : 		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 5616 : 		if (pkResourceInfo == NULL)

	test	eax, eax
	je	SHORT $LN9@DoUpdateAl

; 5617 : 			continue;
; 5618 : 
; 5619 : 		eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 5620 : 
; 5621 : 		if(eUsage == RESOURCEUSAGE_STRATEGIC || eUsage == RESOURCEUSAGE_LUXURY)

	cmp	eax, 1
	je	SHORT $LN5@DoUpdateAl
	cmp	eax, 2
	jne	SHORT $LN9@DoUpdateAl
$LN5@DoUpdateAl:

; 5622 : 		{
; 5623 : 			// Someone is losing the bonus :(
; 5624 : 			if(eOldAlly != NO_PLAYER)

	cmp	ebp, -1
	je	SHORT $LN3@DoUpdateAl

; 5625 : 			{
; 5626 : 				iResourceQuantity = GetPlayer()->getResourceExport(eResource);

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?getResourceExport@CvPlayer@@QBEHW4ResourceTypes@@@Z ; CvPlayer::getResourceExport

; 5627 : 
; 5628 : 				if(iResourceQuantity > 0)

	test	eax, eax
	jle	SHORT $LN3@DoUpdateAl

; 5629 : 				{
; 5630 : 					GET_PLAYER(eOldAlly).changeResourceFromMinors(eResource, -iResourceQuantity);

	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, eax
	neg	edi
	push	edi
	push	esi
	call	?changeResourceFromMinors@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceFromMinors

; 5631 : 					GetPlayer()->changeResourceExport(eResource, -iResourceQuantity);

	mov	ecx, DWORD PTR [ebx]
	push	edi
	push	esi
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport
$LN3@DoUpdateAl:

; 5632 : 				}
; 5633 : 			}
; 5634 : 
; 5635 : 			// Someone new is getting the bonus :D
; 5636 : 			if(eNewAlly != NO_PLAYER)

	cmp	DWORD PTR _eNewAlly$[esp+12], -1
	je	SHORT $LN9@DoUpdateAl

; 5637 : 			{
; 5638 : 				iResourceQuantity = GetPlayer()->getNumResourceTotal(eResource);

	mov	ecx, DWORD PTR [ebx]
	push	1
	push	esi
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	mov	edi, eax

; 5639 : 
; 5640 : 				if(iResourceQuantity > 0)

	test	edi, edi
	jle	SHORT $LN9@DoUpdateAl

; 5641 : 				{
; 5642 : 					GET_PLAYER(eNewAlly).changeResourceFromMinors(eResource, iResourceQuantity);

	mov	ecx, DWORD PTR _eNewAlly$[esp+12]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	push	esi
	call	?changeResourceFromMinors@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceFromMinors

; 5643 : 					GetPlayer()->changeResourceExport(eResource, iResourceQuantity);

	mov	ecx, DWORD PTR [ebx]
	push	edi
	push	esi
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport
$LN9@DoUpdateAl:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	$LL29@DoUpdateAl
	pop	edi
	pop	ebp
$LN8@DoUpdateAl:
	pop	esi
	pop	ebx

; 5644 : 				}
; 5645 : 			}
; 5646 : 		}
; 5647 : 	}
; 5648 : }

	ret	8
?DoUpdateAlliesResourceBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z ENDP ; CvMinorCivAI::DoUpdateAlliesResourceBonus
_TEXT	ENDS
PUBLIC	?GetAlliedTurns@CvMinorCivAI@@QBEHXZ		; CvMinorCivAI::GetAlliedTurns
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetAlliedTurns@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetAlliedTurns@CvMinorCivAI@@QBEHXZ PROC		; CvMinorCivAI::GetAlliedTurns, COMDAT
; _this$ = ecx

; 5810 : {

	push	esi
	mov	esi, ecx

; 5811 : 	int iRtnValue = -1;

	or	eax, -1

; 5812 : 
; 5813 : 	if (m_eAlly != NO_PLAYER)

	cmp	DWORD PTR [esi+2012], eax
	je	SHORT $LN1@GetAlliedT

; 5814 : 	{
; 5815 : 		iRtnValue = GC.getGame().getGameTurn() - m_iTurnAllied;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR [esi+2016]
$LN1@GetAlliedT:
	pop	esi

; 5816 : 	}
; 5817 : 
; 5818 : 	return iRtnValue;
; 5819 : }

	ret	0
?GetAlliedTurns@CvMinorCivAI@@QBEHXZ ENDP		; CvMinorCivAI::GetAlliedTurns
_TEXT	ENDS
PUBLIC	?GetFriendsThreshold@CvMinorCivAI@@QBEHXZ	; CvMinorCivAI::GetFriendsThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendsThreshold@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetFriendsThreshold@CvMinorCivAI@@QBEHXZ PROC		; CvMinorCivAI::GetFriendsThreshold, COMDAT
; _this$ = ecx

; 6095 : 	return /*30*/ GC.getFRIENDSHIP_THRESHOLD_FRIENDS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832

; 6096 : }

	ret	0
?GetFriendsThreshold@CvMinorCivAI@@QBEHXZ ENDP		; CvMinorCivAI::GetFriendsThreshold
_TEXT	ENDS
PUBLIC	?GetAlliesThreshold@CvMinorCivAI@@QBEHXZ	; CvMinorCivAI::GetAlliesThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetAlliesThreshold@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
?GetAlliesThreshold@CvMinorCivAI@@QBEHXZ PROC		; CvMinorCivAI::GetAlliesThreshold, COMDAT
; _this$ = ecx

; 6114 : 	return /*60*/ GC.getFRIENDSHIP_THRESHOLD_ALLIES();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840

; 6115 : }

	ret	0
?GetAlliesThreshold@CvMinorCivAI@@QBEHXZ ENDP		; CvMinorCivAI::GetAlliesThreshold
_TEXT	ENDS
PUBLIC	?IsPlayerHasOpenBordersAutomatically@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsPlayerHasOpenBordersAutomatically
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Ogtpy
;	COMDAT ?IsPlayerHasOpenBordersAutomatically@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsPlayerHasOpenBordersAutomatically@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsPlayerHasOpenBordersAutomatically, COMDAT
; _this$ = ecx

; 6477 : 	// Special trait?
; 6478 : 	if(GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateFriendshipModifier() > 0)

	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+92], 0
	setg	al

; 6479 : 		return true;
; 6480 : 
; 6481 : 	return false;
; 6482 : }

	ret	4
?IsPlayerHasOpenBordersAutomatically@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsPlayerHasOpenBordersAutomatically
_TEXT	ENDS
PUBLIC	?CanMajorWithdrawProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorWithdrawProtection
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorWithdrawProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?CanMajorWithdrawProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorWithdrawProtection, COMDAT
; _this$ = ecx

; 6608 : {

	push	esi
	push	edi

; 6609 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6610 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6611 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	edi, DWORD PTR _eMajor$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN3@CanMajorWi

; 6612 : 
; 6613 : 	if (!IsProtectedByMajor(eMajor))

	mov	al, BYTE PTR [edi+esi+3146]
	test	al, al

; 6614 : 		return false;

	je	SHORT $LN3@CanMajorWi

; 6615 : 
; 6616 : 	// Pledge is locked in for a certain time
; 6617 : 	int iCurrentTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 6618 : 	int iLastPledgeTurn = GetTurnLastPledgedProtectionByMajor(eMajor);

	mov	ecx, DWORD PTR [esi+edi*4+2904]

; 6619 : 	const int iGracePeriod = 10; //antonjs: todo: xml
; 6620 : 	if (iLastPledgeTurn >= 0 && iLastPledgeTurn + iGracePeriod > iCurrentTurn)

	test	ecx, ecx
	jl	SHORT $LN1@CanMajorWi
	add	ecx, 10					; 0000000aH
	cmp	ecx, eax

; 6621 : 		return false;

	jg	SHORT $LN3@CanMajorWi
$LN1@CanMajorWi:
	pop	edi

; 6622 : 
; 6623 : 	return true;

	mov	al, 1
	pop	esi

; 6624 : }

	ret	4
$LN3@CanMajorWi:
	pop	edi

; 6609 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6610 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6611 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 6624 : }

	ret	4
?CanMajorWithdrawProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorWithdrawProtection
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesCapitalFoodBonus
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetAlliesCapitalFoodBonus, COMDAT
; _this$ = ecx

; 7441 : 	int iBonus = /*100*/ GC.getALLIES_CAPITAL_FOOD_BONUS_AMOUNT();
; 7442 : 
; 7443 : 	// Modify the bonus if called for by our trait
; 7444 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier(); 

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2904
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp+4]
	imul	esi, 63236				; 0000f704H
	push	edi
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 7445 : 	
; 7446 : 	//NQMP GJS - Patronage Finisher
; 7447 : 	iModifier += GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_BONUS_MODIFIER);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR [eax+88]
	add	ecx, esi
	push	60					; 0000003cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax

; 7448 : 
; 7449 : 	if(iModifier > 0)

	test	edi, edi
	jle	SHORT $LN12@GetAlliesC

; 7450 : 	{
; 7451 : 		iBonus *= (iModifier + 100);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, ebx

; 7452 : 		iBonus /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 7456 : }

	ret	4
$LN12@GetAlliesC:
	pop	edi
	pop	esi

; 7453 : 	}
; 7454 : 
; 7455 : 	return iBonus;

	mov	eax, ebx
	pop	ebx

; 7456 : }

	ret	4
?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetAlliesCapitalFoodBonus
_TEXT	ENDS
PUBLIC	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetAlliesOtherCityFoodBonus, COMDAT
; _this$ = ecx

; 7461 : 	int iBonus = /*100*/ GC.getALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT();
; 7462 : 
; 7463 : 	// Modify the bonus if called for by our trait
; 7464 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier(); 

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2908
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp+4]
	imul	esi, 63236				; 0000f704H
	push	edi
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 7465 : 	
; 7466 : 	//NQMP GJS - Patronage Finisher
; 7467 : 	iModifier += GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_BONUS_MODIFIER);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR [eax+88]
	add	ecx, esi
	push	60					; 0000003cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax

; 7468 : 
; 7469 : 	if(iModifier > 0)

	test	edi, edi
	jle	SHORT $LN12@GetAlliesO

; 7470 : 	{
; 7471 : 		iBonus *= (iModifier + 100);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, ebx

; 7472 : 		iBonus /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 7476 : }

	ret	4
$LN12@GetAlliesO:
	pop	edi
	pop	esi

; 7473 : 	}
; 7474 : 
; 7475 : 	return iBonus;

	mov	eax, ebx
	pop	ebx

; 7476 : }

	ret	4
?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetAlliesOtherCityFoodBonus
_TEXT	ENDS
PUBLIC	?IsBoughtOut@CvMinorCivAI@@QBE_NXZ		; CvMinorCivAI::IsBoughtOut
; Function compile flags: /Ogtpy
;	COMDAT ?IsBoughtOut@CvMinorCivAI@@QBE_NXZ
_TEXT	SEGMENT
?IsBoughtOut@CvMinorCivAI@@QBE_NXZ PROC			; CvMinorCivAI::IsBoughtOut, COMDAT
; _this$ = ecx

; 7818 : 	PlayerTypes eBuyoutPlayer = GetMajorBoughtOutBy();
; 7819 : 	return (eBuyoutPlayer != NO_PLAYER);

	xor	eax, eax
	cmp	DWORD PTR [ecx+2020], -1
	setne	al

; 7820 : }

	ret	0
?IsBoughtOut@CvMinorCivAI@@QBE_NXZ ENDP			; CvMinorCivAI::IsBoughtOut
_TEXT	ENDS
PUBLIC	?GetBuyoutCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBuyoutCost
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?GetScrapGold@CvUnit@@QBEHXZ:PROC		; CvUnit::GetScrapGold
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?getGoldPercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getGoldPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuyoutCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iUnitLoop$ = 8						; size = 4
_eMajor$ = 8						; size = 4
?GetBuyoutCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC	; CvMinorCivAI::GetBuyoutCost, COMDAT
; _this$ = ecx

; 7876 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 7877 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 7878 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	cmp	DWORD PTR _eMajor$[esp-4], 21		; 00000015H
	push	ebx
	mov	ebx, ecx
	ja	SHORT $LN4@GetBuyoutC

; 7879 : 
; 7880 : 	int iGold = GC.getMINOR_CIV_BUYOUT_COST();
; 7881 : 
; 7882 : 	// Game Speed Mod
; 7883 : 	iGold *= GC.getGame().getGameSpeedInfo().getGoldPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7328
	push	edi
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGoldPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGoldPercent
	mov	ecx, eax
	imul	ecx, esi

; 7884 : 	iGold /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 7885 : 
; 7886 : 	// Add in the scrap cost of all this minor's units
; 7887 : 	int iScrapCost = 0;
; 7888 : 	int iUnitLoop;
; 7889 : 	CvUnit *pLoopUnit;
; 7890 : 	for (pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [ebx]
	sar	edx, 5
	mov	esi, edx
	xor	edi, edi
	push	edi
	lea	eax, DWORD PTR _iUnitLoop$[esp+12]
	shr	esi, 31					; 0000001fH
	push	eax
	add	esi, edx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN1@GetBuyoutC
	npad	3
$LL3@GetBuyoutC:

; 7891 : 	{
; 7892 : 		iScrapCost += pLoopUnit->GetScrapGold();

	mov	ecx, eax
	call	?GetScrapGold@CvUnit@@QBEHXZ		; CvUnit::GetScrapGold
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	add	edi, eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL3@GetBuyoutC
$LN1@GetBuyoutC:

; 7893 : 	}
; 7894 : 	iGold += iScrapCost;
; 7895 : 
; 7896 : 	// Rounding
; 7897 : 	int iVisibleDivisor = /*5*/ GC.getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3144
	lea	eax, DWORD PTR [edi+esi]

; 7898 : 	iGold /= iVisibleDivisor;

	cdq
	idiv	ecx
	pop	edi
	pop	esi
	pop	ebx

; 7899 : 	iGold *= iVisibleDivisor;

	imul	eax, ecx

; 7900 : 
; 7901 : 	return iGold;
; 7902 : }

	ret	4
$LN4@GetBuyoutC:

; 7876 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 7877 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 7878 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	or	eax, -1
	pop	ebx

; 7900 : 
; 7901 : 	return iGold;
; 7902 : }

	ret	4
?GetBuyoutCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP	; CvMinorCivAI::GetBuyoutCost
_TEXT	ENDS
PUBLIC	__real@c3af0000
PUBLIC	__real@3f800000
PUBLIC	?GetBullyGoldAmount@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBullyGoldAmount
EXTRN	?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getGoldGiftMod
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@c3af0000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@c3af0000 DD 0c3af0000r			; -350
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
CONST	ENDS
;	COMDAT ?GetBullyGoldAmount@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv186 = -12						; size = 4
tv184 = -12						; size = 4
_fGameProgressFactor$ = -12				; size = 4
tv75 = -8						; size = 8
___formal$ = 8						; size = 4
?GetBullyGoldAmount@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetBullyGoldAmount, COMDAT
; _this$ = ecx

; 8013 : {

	sub	esp, 12					; 0000000cH

; 8014 : 	int iGold = GC.getMINOR_BULLY_GOLD();
; 8015 : 	int iGoldGrowthFactor = 350; //antonjs: todo: XML
; 8016 : 
; 8017 : 	// Add gold, more if later in game
; 8018 : 	float fGameProgressFactor = ((float) GC.getGame().getElapsedGameTurns() / (float) GC.getGame().getEstimateEndTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2720
	mov	esi, ecx
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	DWORD PTR tv186[esp+20], eax
	fild	DWORD PTR tv186[esp+20]
	mov	ecx, esi
	fstp	QWORD PTR tv75[esp+20]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	mov	DWORD PTR tv184[esp+20], eax
	fild	DWORD PTR tv184[esp+20]
	fdivr	QWORD PTR tv75[esp+20]
	fstp	DWORD PTR _fGameProgressFactor$[esp+20]

; 8019 : 	CvAssertMsg(fGameProgressFactor >= 0.0f, "fGameProgressFactor is not expected to be negative! Please send Anton your save file and version.");
; 8020 : 	if(fGameProgressFactor > 1.0f)

	fld	DWORD PTR _fGameProgressFactor$[esp+20]
	fld1
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@GetBullyGo

; 8021 : 		fGameProgressFactor = 1.0f;

	mov	DWORD PTR _fGameProgressFactor$[esp+20], 1065353216 ; 3f800000H
$LN1@GetBullyGo:

; 8022 : 
; 8023 : 	iGold += (int)(fGameProgressFactor * iGoldGrowthFactor);
; 8024 : 
; 8025 : 	// UA, SP Mods
; 8026 : 
; 8027 : 	// Game Speed Mod
; 8028 : 	iGold *= GC.getGame().getGameSpeedInfo().getGoldGiftMod(); //antonjs: consider: separate XML

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGoldGiftMod

; 8029 : 	iGold /= 100;

	fld	DWORD PTR _fGameProgressFactor$[esp+20]
	fmul	DWORD PTR __real@c3af0000
	mov	esi, eax
	call	__ftol2_sse_excpt
	sub	edi, eax
	imul	esi, edi

; 8030 : 
; 8031 : 	// Rounding
; 8032 : 	int iVisibleDivisor = /*5*/ GC.getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR(); //antonjs: consider: separate XML

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3144
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 8033 : 	iGold /= iVisibleDivisor;

	cdq
	idiv	ecx
	pop	edi
	pop	esi

; 8034 : 	iGold *= iVisibleDivisor;

	imul	eax, ecx

; 8035 : 
; 8036 : 	return iGold;
; 8037 : }

	add	esp, 12					; 0000000cH
	ret	4
?GetBullyGoldAmount@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetBullyGoldAmount
_TEXT	ENDS
PUBLIC	?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ	; CvMinorCivAI::IsEverBulliedByAnyMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ
_TEXT	SEGMENT
?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ PROC	; CvMinorCivAI::IsEverBulliedByAnyMajor, COMDAT
; _this$ = ecx

; 8711 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	eax, eax
	add	ecx, 2816				; 00000b00H
$LL4@IsEverBull@2:

; 8712 : 		if(IsEverBulliedByMajor((PlayerTypes)iPlayerLoop))

	cmp	eax, 21					; 00000015H
	ja	SHORT $LN14@IsEverBull@2
	cmp	DWORD PTR [ecx], 0
	setge	dl
	test	dl, dl
	jne	SHORT $LN12@IsEverBull@2
$LN14@IsEverBull@2:

; 8711 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	eax
	add	ecx, 4
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL4@IsEverBull@2

; 8714 : 	return false;

	xor	al, al

; 8715 : }

	ret	0
$LN12@IsEverBull@2:

; 8713 : 			return true;

	mov	al, 1

; 8715 : }

	ret	0
?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ENDP	; CvMinorCivAI::IsEverBulliedByAnyMajor
_TEXT	ENDS
PUBLIC	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsRecentlyBulliedByMajor, COMDAT
; _this$ = ecx

; 8745 : {

	push	esi
	push	edi

; 8746 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8747 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8748 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN1@IsRecently

; 8749 : 
; 8750 : 	const int iRecentlyBulliedTurnInterval = 20; //antonjs: todo: constant/XML
; 8751 : 	return (m_aiTurnLastBullied[ePlayer] >= 0 && m_aiTurnLastBullied[ePlayer] >= (GC.getGame().getGameTurn() - iRecentlyBulliedTurnInterval)); // -1 means never bullied

	cmp	DWORD PTR [esi+edi*4+2816], 0
	jl	SHORT $LN5@IsRecently
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, 20					; 00000014H
	cmp	DWORD PTR [esi+edi*4+2816], eax
	jl	SHORT $LN5@IsRecently
	pop	edi
	mov	eax, 1
	pop	esi

; 8752 : }

	ret	4
$LN5@IsRecently:
	pop	edi

; 8749 : 
; 8750 : 	const int iRecentlyBulliedTurnInterval = 20; //antonjs: todo: constant/XML
; 8751 : 	return (m_aiTurnLastBullied[ePlayer] >= 0 && m_aiTurnLastBullied[ePlayer] >= (GC.getGame().getGameTurn() - iRecentlyBulliedTurnInterval)); // -1 means never bullied

	xor	eax, eax
	pop	esi

; 8752 : }

	ret	4
$LN1@IsRecently:
	pop	edi

; 8746 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8747 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8748 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 8752 : }

	ret	4
?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsRecentlyBulliedByMajor
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?GetFriendshipFromGoldGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z ; CvMinorCivAI::GetFriendshipFromGoldGift
EXTRN	?GetCityStateInfluenceModifier@CvPlayerReligions@@QBEHXZ:PROC ; CvPlayerReligions::GetCityStateInfluenceModifier
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
EXTRN	?getMinorGoldFriendshipMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getMinorGoldFriendshipMod
EXTRN	_pow:PROC
;	COMDAT __real@3ff0000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
CONST	ENDS
;	COMDAT ?GetFriendshipFromGoldGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iFriendship$ = -28					; size = 4
tv270 = -24						; size = 4
tv268 = -24						; size = 4
_fGameProgressFactor$ = -24				; size = 8
$T238809 = -12						; size = 4
_this$ = -12						; size = 4
tv90 = -8						; size = 8
$T238808 = -8						; size = 8
_eMajor$ = 8						; size = 4
_iGold$ = 12						; size = 4
?GetFriendshipFromGoldGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::GetFriendshipFromGoldGift, COMDAT
; _this$ = ecx

; 9084 : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H

; 9085 : 	// The more Gold you spend the more Friendship you get!
; 9086 : 	iGold = (int) pow((double) iGold, (double) /*1.01*/ GC.getGOLD_GIFT_FRIENDSHIP_EXPONENT());

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8112
	push	ebx
	push	esi
	push	edi
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	mov	DWORD PTR _this$[esp+80], ecx
	fild	DWORD PTR _iGold$[ebp]
	fstp	QWORD PTR [esp]
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iGold$[ebp], eax

; 9087 : 	// The higher this divisor the less Friendship is gained
; 9088 : 	int iFriendship = int(iGold / /*9.8*/ GC.getGOLD_GIFT_FRIENDSHIP_DIVISOR());

	fild	DWORD PTR _iGold$[ebp]
	fdiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8116
	call	__ftol2_sse_excpt

; 9089 : 
; 9090 : 	// Game progress factor based on how far into the game we are
; 9091 : 	double fGameProgressFactor = float(GC.getGame().getElapsedGameTurns()) / GC.getGame().getEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _iFriendship$[esp+64], eax
	mov	esi, ecx
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	DWORD PTR tv270[esp+64], eax
	fild	DWORD PTR tv270[esp+64]
	mov	ecx, esi
	fstp	QWORD PTR tv90[esp+64]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	mov	DWORD PTR tv268[esp+64], eax
	fild	DWORD PTR tv268[esp+64]
	fdivr	QWORD PTR tv90[esp+64]

; 9092 : 	fGameProgressFactor = min(fGameProgressFactor, 1.0); // Don't count above 1.0, otherwise it will end up negative!

	mov	DWORD PTR $T238808[esp+64], 0
	mov	DWORD PTR $T238808[esp+68], 1072693248	; 3ff00000H
	fstp	QWORD PTR _fGameProgressFactor$[esp+64]
	fld	QWORD PTR _fGameProgressFactor$[esp+64]
	fld1
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	lea	eax, DWORD PTR $T238808[esp+64]
	jnp	SHORT $LN16@GetFriends
	lea	eax, DWORD PTR _fGameProgressFactor$[esp+64]
$LN16@GetFriends:
	mov	ecx, DWORD PTR [eax]

; 9093 : 	
; 9094 : 	// Tweak factor slightly, otherwise Gold will do literally NOTHING once we reach the end of the game!
; 9095 : 	fGameProgressFactor *= /*2*/ GC.getMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER();

	fild	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3136
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _fGameProgressFactor$[esp+64], ecx
	mov	DWORD PTR _fGameProgressFactor$[esp+68], edx
	fmul	QWORD PTR _fGameProgressFactor$[esp+64]
	fstp	QWORD PTR _fGameProgressFactor$[esp+64]

; 9096 : 	fGameProgressFactor /= /*3*/ GC.getMINOR_CIV_GOLD_GIFT_GAME_DIVISOR();

	fild	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3140
	fdivr	QWORD PTR _fGameProgressFactor$[esp+64]
	fstp	QWORD PTR _fGameProgressFactor$[esp+64]

; 9097 : 	fGameProgressFactor = 1 - fGameProgressFactor;

	fsub	QWORD PTR _fGameProgressFactor$[esp+64]
	fstp	QWORD PTR _fGameProgressFactor$[esp+64]

; 9098 : 
; 9099 : 	iFriendship = (int)(iFriendship * fGameProgressFactor);

	fild	DWORD PTR _iFriendship$[esp+64]
	fmul	QWORD PTR _fGameProgressFactor$[esp+64]
	call	__ftol2_sse_excpt

; 9100 : 
; 9101 : 
; 9102 : 	// Mod (Policies, etc.)
; 9103 : 	int iFriendshipMod = GET_PLAYER(eMajor).getMinorGoldFriendshipMod();

	mov	esi, DWORD PTR _eMajor$[ebp]
	imul	esi, 63236				; 0000f704H
	mov	edi, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?getMinorGoldFriendshipMod@CvPlayer@@QBEHXZ ; CvPlayer::getMinorGoldFriendshipMod

; 9104 : 	iFriendshipMod += GET_PLAYER(eMajor).GetReligions()->GetCityStateInfluenceModifier();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	mov	ebx, eax
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetCityStateInfluenceModifier@CvPlayerReligions@@QBEHXZ ; CvPlayerReligions::GetCityStateInfluenceModifier
	add	ebx, eax

; 9105 : 	if(iFriendshipMod != 0)

	je	SHORT $LN2@GetFriends

; 9106 : 	{
; 9107 : 		iFriendship *= (100 + iFriendshipMod);

	add	ebx, 100				; 00000064H
	imul	ebx, edi

; 9108 : 		iFriendship /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
$LN2@GetFriends:

; 9109 : 	}
; 9110 : 
; 9111 : 	// Game Speed Mod
; 9112 : 	iFriendship *= GC.getGame().getGameSpeedInfo().getGoldGiftMod();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGoldGiftMod
	mov	ecx, eax
	imul	ecx, edi

; 9113 : 	iFriendship /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 9114 : 
; 9115 : 	//antonjs: todo: refine
; 9116 : 	if(IsActiveQuestForPlayer(eMajor, MINOR_CIV_QUEST_INVEST))

	mov	ecx, DWORD PTR _eMajor$[ebp]
	sar	edx, 5
	mov	esi, edx
	push	13					; 0000000dH
	shr	esi, 31					; 0000001fH
	add	esi, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+72]
	mov	DWORD PTR _iFriendship$[esp+72], esi
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al
	je	SHORT $LN1@GetFriends

; 9117 : 	{
; 9118 : 		int iBoostPercentage = 50; //antonjs: todo: xml
; 9119 : 		iFriendship *= 100 + iBoostPercentage;

	imul	esi, 150				; 00000096H

; 9120 : 		iFriendship /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
	mov	DWORD PTR _iFriendship$[esp+64], esi
$LN1@GetFriends:

; 9121 : 	}
; 9122 : 
; 9123 : 	// Friendship gained should always be positive
; 9124 : 	iFriendship = max(iFriendship, /*5*/ GC.getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3148
	mov	DWORD PTR $T238809[esp+64], eax
	cmp	esi, eax
	lea	eax, DWORD PTR $T238809[esp+64]
	jl	SHORT $LN32@GetFriends
	lea	eax, DWORD PTR _iFriendship$[esp+64]
$LN32@GetFriends:

; 9125 : 
; 9126 : 	// Round the number so it's pretty
; 9127 : 	int iVisibleDivisor = /*5*/ GC.getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR();
; 9128 : 	iFriendship /= iVisibleDivisor;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3144
	cdq
	idiv	ecx

; 9129 : 	iFriendship *= iVisibleDivisor;
; 9130 : 
; 9131 : 	return iFriendship;
; 9132 : }

	pop	edi
	pop	esi
	pop	ebx
	imul	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetFriendshipFromGoldGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::GetFriendshipFromGoldGift
_TEXT	ENDS
PUBLIC	?GetGiftTileImprovementCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetGiftTileImprovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetGiftTileImprovementCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?GetGiftTileImprovementCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetGiftTileImprovementCost, COMDAT
; _this$ = ecx

; 9284 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9285 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9286 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	cmp	DWORD PTR _eMajor$[esp-4], 21		; 00000015H
	ja	SHORT $LN1@GetGiftTil

; 9287 : 
; 9288 : 	return GC.getMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7324

; 9289 : }

	ret	4
$LN1@GetGiftTil:

; 9284 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9285 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9286 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return -1;

	or	eax, -1

; 9289 : }

	ret	4
?GetGiftTileImprovementCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetGiftTileImprovementCost
_TEXT	ENDS
PUBLIC	?GetNumResourcesMajorLacks@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumResourcesMajorLacks
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumResourcesMajorLacks@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?GetNumResourcesMajorLacks@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNumResourcesMajorLacks, COMDAT
; _this$ = ecx

; 9685 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 9686 : 	CvAssertMsg(eMajor >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9687 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9688 : 
; 9689 : 	int iNumTheyLack = 0;
; 9690 : 
; 9691 : 	// Loop through all resources to see what this minor has
; 9692 : 	ResourceTypes eResource;
; 9693 : #ifdef AUI_WARNING_FIXES
; 9694 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 9695 : #else
; 9696 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN16@GetNumReso
	push	ebp
	mov	ebp, DWORD PTR _eMajor$[esp+12]
	npad	4
$LL7@GetNumReso:

; 9697 : #endif
; 9698 : 	{
; 9699 : 		eResource = (ResourceTypes) iResourceLoop;
; 9700 : 
; 9701 : 		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 9702 : 		// Must not be a Bonus resource
; 9703 : 		if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_BONUS)

	test	eax, eax
	je	SHORT $LN6@GetNumReso
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	test	eax, eax
	je	SHORT $LN6@GetNumReso

; 9704 : 			continue;
; 9705 : 
; 9706 : 		// We must have it
; 9707 : 		if(GetPlayer()->getNumResourceTotal(eResource, /*bIncludeImport*/ false) == 0)

	mov	ecx, DWORD PTR [edi]
	push	0
	push	esi
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	je	SHORT $LN6@GetNumReso

; 9708 : 			continue;
; 9709 : 
; 9710 : 		// They must not have it
; 9711 : 		if(GET_PLAYER(eMajor).getNumResourceTotal(eResource, /*bIncludeImport*/ false) > 0)

	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	esi
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jg	SHORT $LN6@GetNumReso

; 9712 : 			continue;
; 9713 : 
; 9714 : 		iNumTheyLack++;

	inc	ebx
$LN6@GetNumReso:

; 9686 : 	CvAssertMsg(eMajor >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9687 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9688 : 
; 9689 : 	int iNumTheyLack = 0;
; 9690 : 
; 9691 : 	// Loop through all resources to see what this minor has
; 9692 : 	ResourceTypes eResource;
; 9693 : #ifdef AUI_WARNING_FIXES
; 9694 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 9695 : #else
; 9696 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL7@GetNumReso
	pop	ebp
$LN16@GetNumReso:
	pop	edi
	pop	esi

; 9715 : 	}
; 9716 : 
; 9717 : 	return iNumTheyLack;

	mov	eax, ebx
	pop	ebx

; 9718 : }

	ret	4
?GetNumResourcesMajorLacks@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNumResourcesMajorLacks
_TEXT	ENDS
PUBLIC	??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocBase<0,0,0> >::~FAllocArray2DType<int,FAllocBase<0,0,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocBase<0,0,0> >::~FAllocArray2DType<int,FAllocBase<0,0,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocBase<0,0,0> >::~FAllocArray2DType<int,FAllocBase<0,0,0> >
_TEXT	ENDS
PUBLIC	?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsSameReligionAsMajor
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ:PROC ; CvCityReligions::GetReligiousMajority
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsSameReligionAsMajor, COMDAT
; _this$ = ecx

; 9794 : 	CvPlayer* pkPlayer = GetPlayer();

	mov	ecx, DWORD PTR [ecx]
	push	esi

; 9795 : 	if(pkPlayer)

	test	ecx, ecx
	je	SHORT $LN1@IsSameReli

; 9796 : 	{
; 9797 : 		CvCity* pkCity = pkPlayer->getCapitalCity();

	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 9798 : 		if(pkCity)

	test	eax, eax
	je	SHORT $LN1@IsSameReli

; 9799 : 		{
; 9800 : 			ReligionTypes eMinorReligion = pkCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, eax
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority

; 9801 : 			ReligionTypes eMajorReligion = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(eMajor);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	mov	eax, DWORD PTR _eMajor$[esp]
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer

; 9802 : 
; 9803 : 			if(eMinorReligion != NO_RELIGION &&
; 9804 : 			        eMajorReligion != NO_RELIGION &&
; 9805 : 			        eMinorReligion == eMajorReligion)

	cmp	esi, -1
	je	SHORT $LN1@IsSameReli
	cmp	eax, -1
	je	SHORT $LN1@IsSameReli
	cmp	esi, eax
	jne	SHORT $LN1@IsSameReli

; 9806 : 			{
; 9807 : 				return true;

	mov	al, 1
	pop	esi

; 9812 : }

	ret	4
$LN1@IsSameReli:

; 9808 : 			}
; 9809 : 		}
; 9810 : 	}
; 9811 : 	return false;

	xor	al, al
	pop	esi

; 9812 : }

	ret	4
?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsSameReligionAsMajor
_TEXT	ENDS
PUBLIC	??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z	; std::pair<CvString,CvString>::pair<CvString,CvString>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z$0
__ehfuncinfo$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z PROC		; std::pair<CvString,CvString>::pair<CvString,CvString>, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	add	edi, 28					; 0000001cH
	push	edi
	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@VCvString@@V1@@std@@QAE@ABU01@@Z ENDP		; std::pair<CvString,CvString>::pair<CvString,CvString>
PUBLIC	?getNumCityNames@CvMinorCivInfo@@QBEHXZ		; CvMinorCivInfo::getNumCityNames
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCityNames@CvMinorCivInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumCityNames@CvMinorCivInfo@@QBEHXZ PROC		; CvMinorCivInfo::getNumCityNames, COMDAT
; _this$ = ecx

; 10215: {

	push	esi

; 10216: 	return m_vCityNames.size();

	mov	esi, DWORD PTR [ecx+544]
	sub	esi, DWORD PTR [ecx+540]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 10217: }

	ret	0
?getNumCityNames@CvMinorCivInfo@@QBEHXZ ENDP		; CvMinorCivInfo::getNumCityNames
_TEXT	ENDS
PUBLIC	?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z ; CvMinorCivInfo::setShortDescriptionKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z$0
__ehfuncinfo$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z
_TEXT	SEGMENT
$T238945 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szVal$ = 8						; size = 4
?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z PROC	; CvMinorCivInfo::setShortDescriptionKey, COMDAT
; _this$ = ecx

; 10235: {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 10236: 	m_strShortDescriptionKey = szVal;

	mov	edi, DWORD PTR _szVal$[esp+48]
	lea	ebx, DWORD PTR [esi+364]
	mov	ecx, ebx
	test	edi, edi
	je	SHORT $LN5@setShortDe
	push	edi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@setShortDe
$LN5@setShortDe:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@setShortDe:

; 10237: 	m_wstrShortDescriptionKey = szVal;

	lea	ecx, DWORD PTR [esi+504]
	test	edi, edi
	je	SHORT $LN9@setShortDe
	push	edi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@setShortDe
$LN9@setShortDe:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@setShortDe:

; 10238: 	m_wstrShortDescription = GetLocalizedText(m_strShortDescriptionKey.c_str());

	mov	ecx, ebx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T238945[esp+56]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [esi+392]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238945[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10239: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T238945[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z ENDP	; CvMinorCivInfo::setShortDescriptionKey
PUBLIC	?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z	; CvMinorCivInfo::setAdjectiveKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z$0
__ehfuncinfo$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z
_TEXT	SEGMENT
$T238977 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szVal$ = 8						; size = 4
?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z PROC		; CvMinorCivInfo::setAdjectiveKey, COMDAT
; _this$ = ecx

; 10257: {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 10258: 	m_strAdjectiveKey = szVal;

	mov	edi, DWORD PTR _szVal$[esp+48]
	lea	ebx, DWORD PTR [esi+420]
	mov	ecx, ebx
	test	edi, edi
	je	SHORT $LN5@setAdjecti
	push	edi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@setAdjecti
$LN5@setAdjecti:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@setAdjecti:

; 10259: 	m_wstrAdjectiveKey = szVal;

	lea	ecx, DWORD PTR [esi+476]
	test	edi, edi
	je	SHORT $LN9@setAdjecti
	push	edi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@setAdjecti
$LN9@setAdjecti:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@setAdjecti:

; 10260: 	m_wstrAdjective = GetLocalizedText(m_strAdjectiveKey.c_str());

	mov	ecx, ebx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T238977[esp+56]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [esi+448]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238977[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10261: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T238977[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z ENDP		; CvMinorCivInfo::setAdjectiveKey
PUBLIC	?getCityNames@CvMinorCivInfo@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; CvMinorCivInfo::getCityNames
; Function compile flags: /Ogtpy
;	COMDAT ?getCityNames@CvMinorCivInfo@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getCityNames@CvMinorCivInfo@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; CvMinorCivInfo::getCityNames, COMDAT
; _this$ = ecx

; 10292: 	return m_vCityNames[i];

	mov	eax, DWORD PTR _i$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+540]
	lea	eax, DWORD PTR [eax+edx*4]

; 10293: }

	ret	4
?getCityNames@CvMinorCivInfo@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; CvMinorCivInfo::getCityNames
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4MinorCivStatusTypes@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4MinorCivStatusTypes@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T239015 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4MinorCivStatusTypes@@@Z PROC ; operator<<, COMDAT

; 10368: 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T239015[esp]
	mov	DWORD PTR $T239015[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10369: 	return saveTo;

	mov	eax, esi
	pop	esi

; 10370: }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4MinorCivStatusTypes@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4MinorCivStatusTypes@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4MinorCivStatusTypes@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4MinorCivStatusTypes@@@Z PROC ; operator>>, COMDAT

; 10372: {

	push	esi

; 10373: 	int v;
; 10374: 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10375: 	writeTo = static_cast<MinorCivStatusTypes>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 10376: 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 10377: }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4MinorCivStatusTypes@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4MinorCivPersonalityTypes@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4MinorCivPersonalityTypes@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T239028 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4MinorCivPersonalityTypes@@@Z PROC ; operator<<, COMDAT

; 10381: 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T239028[esp]
	mov	DWORD PTR $T239028[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10382: 	return saveTo;

	mov	eax, esi
	pop	esi

; 10383: }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4MinorCivPersonalityTypes@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4MinorCivPersonalityTypes@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4MinorCivPersonalityTypes@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4MinorCivPersonalityTypes@@@Z PROC ; operator>>, COMDAT

; 10385: {

	push	esi

; 10386: 	int v;
; 10387: 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10388: 	writeTo = static_cast<MinorCivPersonalityTypes>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 10389: 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 10390: }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4MinorCivPersonalityTypes@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4MinorCivQuestTypes@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T239041 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4MinorCivQuestTypes@@@Z PROC ; operator<<, COMDAT

; 10394: 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T239041[esp]
	mov	DWORD PTR $T239041[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10395: 	return saveTo;

	mov	eax, esi
	pop	esi

; 10396: }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4MinorCivQuestTypes@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4MinorCivQuestTypes@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4MinorCivQuestTypes@@@Z PROC ; operator>>, COMDAT

; 10398: {

	push	esi

; 10399: 	int v;
; 10400: 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10401: 	writeTo = static_cast<MinorCivQuestTypes>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 10402: 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 10403: }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4MinorCivQuestTypes@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 5
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>, COMDAT
; _this$ = ecx

; 591  : 	FStaticVector(const THIS_TYPE& RHS)

	push	ebx
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	push	edi

; 592  : 	{
; 593  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	edi, DWORD PTR _RHS$[esp+8]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 594  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], ecx

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ebx, DWORD PTR [edi+8]
	cmp	ebx, 64					; 00000040H
	jbe	SHORT $LN6@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	edx, DWORD PTR [ebx*4]
	push	4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], ebx
	jmp	SHORT $LN5@FStaticVec
$LN6@FStaticVec:
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN5@FStaticVec:
	mov	DWORD PTR [esi], eax

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	add	edx, edx
	add	edx, edx
	push	edx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@I@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@I@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>, COMDAT
; _this$ = ecx

; 609  : 	FStaticVector(unsigned int uiStartingMaxSize)

	push	esi
	push	edi

; 610  : 	{
; 611  : 		m_uiCurrMaxSize = uiStartingMaxSize;

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], edi

; 612  : 		m_pData = Alloc(m_uiCurrMaxSize);

	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN6@FStaticVec@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi], eax
	pop	edi

; 613  : #ifdef BREAK_ON_STATIC_RESIZE
; 614  : 		m_iNumResized = 0;
; 615  : #endif
; 616  : 	};

	mov	eax, esi
	pop	esi
	ret	4

; 612  : 		m_pData = Alloc(m_uiCurrMaxSize);

$LN6@FStaticVec@2:
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], eax
	pop	edi
	mov	DWORD PTR [esi+8], 64			; 00000040H

; 613  : #ifdef BREAK_ON_STATIC_RESIZE
; 614  : 		m_iNumResized = 0;
; 615  : #endif
; 616  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@I@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z ; std::pair<CvString,CvString>::pair<CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z$0
__ehfuncinfo$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	ENDS
;	COMDAT ??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z PROC	; std::pair<CvString,CvString>::pair<CvString,CvString>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	-1
	push	__ehhandler$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, DWORD PTR __Val1$[esp+12]
	push	esi
	mov	esi, ecx
	push	eax
	mov	DWORD PTR _this$[esp+24], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __Val2$[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 51   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@VCvString@@V1@@std@@QAE@ABVCvString@@0@Z ENDP	; std::pair<CvString,CvString>::pair<CvString,CvString>
PUBLIC	??0?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum ResourceTypes,64,1,297,0>::FStaticVector<enum ResourceTypes,64,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum ResourceTypes,64,1,297,0>::FStaticVector<enum ResourceTypes,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum ResourceTypes,64,1,297,0>::FStaticVector<enum ResourceTypes,64,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::FStaticVector<enum MinorCivQuestTypes,18,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::FStaticVector<enum MinorCivQuestTypes,18,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 18			; 00000012H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::FStaticVector<enum MinorCivQuestTypes,18,1,297,0>
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBEABW4PlayerTypes@@I@Z ; CvWeightedVector<enum PlayerTypes,64,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBEABW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBEABW4PlayerTypes@@I@Z PROC ; CvWeightedVector<enum PlayerTypes,64,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QBEABW4PlayerTypes@@I@Z ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEHXZ ; CvWeightedVector<enum PlayerTypes,64,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEHXZ PROC ; CvWeightedVector<enum PlayerTypes,64,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEHXZ ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::size
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z ; CvWeightedVector<int,64,1>::GetElement
; Function compile flags: /Ogtpy
;	COMDAT ?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z PROC ; CvWeightedVector<int,64,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$0EA@$00@@QBEABHI@Z ENDP ; CvWeightedVector<int,64,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ	; CvWeightedVector<int,64,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ PROC		; CvWeightedVector<int,64,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$0EA@$00@@QAEHXZ ENDP		; CvWeightedVector<int,64,1>::size
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,50,1,297,0>::FStaticVector<enum BuildingTypes,50,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum BuildingTypes,50,1,297,0>::FStaticVector<enum BuildingTypes,50,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 50			; 00000032H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum BuildingTypes,50,1,297,0>::FStaticVector<enum BuildingTypes,50,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum UnitTypes,8,1,297,0>::FStaticVector<enum UnitTypes,8,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum UnitTypes,8,1,297,0>::FStaticVector<enum UnitTypes,8,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum UnitTypes,8,1,297,0>::FStaticVector<enum UnitTypes,8,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 63			; 0000003fH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,16,0,297,0>::FStaticVector<CvCity *,16,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvCity *,16,0,297,0>::FStaticVector<CvCity *,16,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 16			; 00000010H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvCity *,16,0,297,0>::FStaticVector<CvCity *,16,0,297,0>
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBEABW4PlayerTypes@@I@Z ; CvWeightedVector<enum PlayerTypes,22,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBEABW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBEABW4PlayerTypes@@I@Z PROC ; CvWeightedVector<enum PlayerTypes,22,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QBEABW4PlayerTypes@@I@Z ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ ; CvWeightedVector<enum PlayerTypes,22,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ PROC ; CvWeightedVector<enum PlayerTypes,22,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::size
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@H$0GE@$00@@QBEABHI@Z ; CvWeightedVector<int,100,1>::GetElement
; Function compile flags: /Ogtpy
;	COMDAT ?GetElement@?$CvWeightedVector@H$0GE@$00@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$0GE@$00@@QBEABHI@Z PROC ; CvWeightedVector<int,100,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$0GE@$00@@QBEABHI@Z ENDP ; CvWeightedVector<int,100,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$0GE@$00@@QAEHXZ	; CvWeightedVector<int,100,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$0GE@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$0GE@$00@@QAEHXZ PROC		; CvWeightedVector<int,100,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$0GE@$00@@QAEHXZ ENDP		; CvWeightedVector<int,100,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??1?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@XZ ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::~_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@XZ PROC ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::~_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@XZ ENDP ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::~_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z PROC ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ENDP ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>, COMDAT
; _this$ = ecx

; 591  : 	FStaticVector(const THIS_TYPE& RHS)

	push	ebx

; 592  : 	{
; 593  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebx, DWORD PTR _RHS$[esp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax

; 594  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR [esi+8], ecx

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebx+8]
	cmp	edi, 5
	jbe	SHORT $LN6@FStaticVec@4
	push	798					; 0000031eH
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	edx, edx
	add	edx, edx
	push	4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXABV1@@Z ; BaseVector<CvMinorCivQuest,0>::Copy
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

$LN6@FStaticVec@4:
	lea	eax, DWORD PTR [esi+12]

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 5
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXABV1@@Z ; BaseVector<CvMinorCivQuest,0>::Copy
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z ; BaseVector<CvMinorCivQuest,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z PROC ; BaseVector<CvMinorCivQuest,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvMinorCivQuest@@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z ENDP ; BaseVector<CvMinorCivQuest,0>::Destroy
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4ResourceTypes@@I@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4ResourceTypes@@I@Z PROC ; FStaticVector<enum ResourceTypes,64,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXPAW4ResourceTypes@@I@Z ENDP ; FStaticVector<enum ResourceTypes,64,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXPAW4MinorCivQuestTypes@@I@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXPAW4MinorCivQuestTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXPAW4MinorCivQuestTypes@@I@Z PROC ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@4

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@4:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXPAW4MinorCivQuestTypes@@I@Z ENDP ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAABW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAABW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAABW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAABW4MinorCivQuestTypes@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@5

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@5:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXABV1@@Z ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,1>::Copy
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXPAW4BuildingTypes@@I@Z ; FStaticVector<enum BuildingTypes,50,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXPAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXPAW4BuildingTypes@@I@Z PROC ; FStaticVector<enum BuildingTypes,50,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@6

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@6:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXPAW4BuildingTypes@@I@Z ENDP ; FStaticVector<enum BuildingTypes,50,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXPAW4UnitTypes@@I@Z ; FStaticVector<enum UnitTypes,8,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXPAW4UnitTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXPAW4UnitTypes@@I@Z PROC ; FStaticVector<enum UnitTypes,8,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@7

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@7:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXPAW4UnitTypes@@I@Z ENDP ; FStaticVector<enum UnitTypes,8,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 63					; 0000003fH
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 63			; 0000003fH
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+264], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXPAPAVCvCity@@I@Z ; FStaticVector<CvCity *,16,0,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXPAPAVCvCity@@I@Z PROC ; FStaticVector<CvCity *,16,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@8

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@8:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXPAPAVCvCity@@I@Z ENDP ; FStaticVector<CvCity *,16,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?GetTotalWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ ; CvWeightedVector<enum PlayerTypes,22,1>::GetTotalWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ PROC ; CvWeightedVector<enum PlayerTypes,22,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR [ecx+4]
	push	ebp
	push	esi
	push	edi

; 90   : 		int rtnValue = 0;

	xor	edx, edx
	xor	esi, esi
	xor	edi, edi

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	xor	ebp, ebp
	cmp	ebx, 2
	mov	DWORD PTR _rtnValue$[esp+20], edx
	jl	SHORT $LC15@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ebx-2]
	shr	edx, 1
	add	eax, 12					; 0000000cH
	inc	edx
	lea	ebp, DWORD PTR [edx+edx]
$LL16@GetTotalWe:
	add	esi, DWORD PTR [eax-8]
	add	edi, DWORD PTR [eax]
	add	eax, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL16@GetTotalWe
	mov	edx, DWORD PTR _rtnValue$[esp+20]
$LC15@GetTotalWe:

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	ebp, ebx
	jae	SHORT $LN14@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+ebp*8+4]
$LN14@GetTotalWe:
	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebp

; 96   : 		}
; 97   : 
; 98   : 		return rtnValue;

	add	eax, edx
	pop	ebx

; 99   : 	};

	pop	ecx
	ret	0
?GetTotalWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::GetTotalWeight
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>
_TEXT	ENDS
PUBLIC	??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z PROC	; fastdelegate::FastDelegate2<int,char const *,int>::operator(), COMDAT
; _this$ = ecx

; 1080 : 	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	eax
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::operator()
_TEXT	ENDS
PUBLIC	?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ; fastdelegate::FastDelegate2<int,char const *,int>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::clear, COMDAT
; _this$ = ecx

; 1101 : 	void clear() { m_Closure.clear();}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 100			; 00000064H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ; std::allocator<CvString>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z PROC ; std::allocator<CvString>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ENDP ; std::allocator<CvString>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z ; std::allocator<enum ResourceTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z PROC ; std::allocator<enum ResourceTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z ENDP ; std::allocator<enum ResourceTypes>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN34@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@2
$LN16@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+524], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@9

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@9:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@10

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@10:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@11

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@11:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@U?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ??0?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@U?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@U?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

	mov	eax, ecx

; 39   : 		}

	ret	8
??0?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@QAE@U?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0>
_TEXT	ENDS
PUBLIC	??$?5_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@_N@Z ; operator>><bool,22>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@_N@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@_N@Z PROC	; operator>><bool,22>, COMDAT

; 234  : {

	push	ebx

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _writeTo$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	xor	esi, esi
	npad	3
$LL3@operator@3:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	esi
	cmp	esi, 22					; 00000016H
	jb	SHORT $LL3@operator@3

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@_N@Z ENDP	; operator>><bool,22>
_TEXT	ENDS
PUBLIC	??$?5H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@H@Z	; operator>><int,22>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@H@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@H@Z PROC	; operator>><int,22>, COMDAT

; 234  : {

	push	ebx
	push	esi

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	mov	ebx, 22					; 00000016H
$LL3@operator@4:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@4

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@H@Z ENDP	; operator>><int,22>
_TEXT	ENDS
PUBLIC	??$?5_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@_N@Z ; operator>><bool,80>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@_N@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@_N@Z PROC	; operator>><bool,80>, COMDAT

; 234  : {

	push	ebx

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _writeTo$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	xor	esi, esi
	npad	3
$LL3@operator@5:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	esi
	cmp	esi, 80					; 00000050H
	jb	SHORT $LL3@operator@5

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@_N@Z ENDP	; operator>><bool,80>
_TEXT	ENDS
PUBLIC	??$?6_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CB_N@Z ; operator<<<bool,22>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CB_N@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CB_N@Z PROC ; operator<<<bool,22>, COMDAT

; 223  : {

	push	ebx

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _readFrom$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	xor	esi, esi
	npad	3
$LL3@operator@6:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, 22					; 00000016H
	jb	SHORT $LL3@operator@6

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6_N$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CB_N@Z ENDP ; operator<<<bool,22>
_TEXT	ENDS
PUBLIC	??$?6H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CBH@Z ; operator<<<int,22>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CBH@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CBH@Z PROC	; operator<<<int,22>, COMDAT

; 223  : {

	push	ebx
	push	esi

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	mov	ebx, 22					; 00000016H
$LL3@operator@7:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@7

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6H$0BG@@@YAAAVFDataStream@@AAV0@AAY0BG@$$CBH@Z ENDP	; operator<<<int,22>
_TEXT	ENDS
PUBLIC	??$?6_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CB_N@Z ; operator<<<bool,80>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CB_N@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CB_N@Z PROC ; operator<<<bool,80>, COMDAT

; 223  : {

	push	ebx

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _readFrom$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	xor	esi, esi
	npad	3
$LL3@operator@8:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, 80					; 00000050H
	jb	SHORT $LL3@operator@8

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6_N$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CB_N@Z ENDP ; operator<<<bool,80>
_TEXT	ENDS
PUBLIC	??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ PROC ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ENDP ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
_right$ = 12						; size = 4
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >, COMDAT
; _this$ = ecx

; 763  : #endif
; 764  : 		SetMementoFrom(right);

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 765  : 	}

	ret	8
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN10@Copy_opt
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN10@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::_Fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::_Fill<CvString *,CvString>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill@2
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Fill@2
	pop	ebx
$LN1@Fill@2:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::_Fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z ; std::allocator<enum ResourceTypes>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z PROC ; std::allocator<enum ResourceTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z ENDP ; std::allocator<enum ResourceTypes>::destroy
_TEXT	ENDS
PUBLIC	??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>, COMDAT
; _this$ = ecx

; 673  : 		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
; 674  : 			::Convert(pthis, function_to_bind, m_pFunction);

	mov	eax, DWORD PTR _function_to_bind$[esp-4]
	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx

; 675  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 676  : 		m_pStaticFunction = 0;
; 677  : #endif
; 678  : 	}

	ret	8
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN9@Copy_backw@6
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@6

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN9@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ; std::_Construct<CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
_TEXT	SEGMENT
$T240235 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z PROC ; std::_Construct<CvString,CvString>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T240235[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@3
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN3@Construct@3:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T240235[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ENDP ; std::_Construct<CvString,CvString>
PUBLIC	??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z	; std::_Destroy<CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z PROC	; std::_Destroy<CvString>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z ENDP	; std::_Destroy<CvString>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z ; std::allocator<enum ResourceTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z PROC ; std::allocator<enum ResourceTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z ENDP ; std::allocator<enum ResourceTypes>::construct
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::iter_swap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::iter_swap<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@2
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@2:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::iter_swap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@3
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@3:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::iter_swap<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@4
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@4:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_
	push	esi
$LL8@unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_
	pop	esi
$LN7@unchecked_:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3@2

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3@2
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3@2:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3@2

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3@2
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3@2:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3@2

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3@2
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3@2:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea@2
	npad	7
$LL5@Adjust_hea@2:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea@2

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea@2:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea@2
$LN14@Adjust_hea@2:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea@2

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea@2:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL8@unchecked_@2:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3@3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3@3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3@3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3@3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3@3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3@3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3@3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3@3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3@3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea@3
	npad	7
$LL5@Adjust_hea@3:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea@3

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea@3:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea@3
$LN14@Adjust_hea@3:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea@3

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea@3:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL8@unchecked_@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3@4

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3@4
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3@4:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3@4

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3@4
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3@4:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3@4

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3@4
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3@4:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea@4
	npad	7
$LL5@Adjust_hea@4:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea@4

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea@4:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea@4
$LN14@Adjust_hea@4:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea@4

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea@4:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL8@unchecked_@4:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z ; CvMinorCivQuest::GetContestValueForPlayer
EXTRN	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ:PROC	; CvTeamTechs::GetNumTechsKnown
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetFaithEverGenerated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetFaithEverGenerated
EXTRN	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetJONSCultureEverGenerated
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivQuest::GetContestValueForPlayer, COMDAT
; _this$ = ecx

; 239  : {

	push	ebx

; 240  : 	MinorCivQuestTypes eType = GetType();
; 241  : 	int iValue = -1;
; 242  : 	CvPlayer* pMinor = &GET_PLAYER(GetMinor());

	mov	ebx, DWORD PTR [ecx]
	imul	ebx, 63236				; 0000f704H
	push	ebp
	mov	ebp, DWORD PTR [ecx+8]
	push	edi
	or	edi, -1
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 243  : 	if(!pMinor)

	jne	SHORT $LN7@GetContest

; 244  : 	{
; 245  : 		CvAssertMsg(false, "Error when calculating contest standings - could not find minor civ! Please send Anton your save file and version.");
; 246  : 		return iValue;

	or	eax, edi
	pop	edi
	pop	ebp
	pop	ebx

; 273  : }

	ret	4
$LN7@GetContest:
	push	esi

; 247  : 	}
; 248  : 
; 249  : 	// Player must actually be in the contest to have a score!
; 250  : 	if(!pMinor->GetMinorCivAI()->IsActiveQuestForPlayer(ePlayer, eType))

	mov	esi, DWORD PTR _ePlayer$[esp+12]
	push	ebp
	push	esi
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al
	jne	SHORT $LN6@GetContest
	pop	esi
	pop	edi
	pop	ebp

; 251  : 		return iValue;

	or	eax, -1
	pop	ebx

; 273  : }

	ret	4
$LN6@GetContest:

; 252  : 
; 253  : 	if(eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	ebp, 10					; 0000000aH
	jne	SHORT $LN5@GetContest

; 254  : 	{
; 255  : 		int iStartCulture = pMinor->GetMinorCivAI()->GetQuestData1(ePlayer, eType);

	push	ebp
	push	esi
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetQuestData1

; 256  : 		int iEndCulture = GET_PLAYER(ePlayer).GetJONSCultureEverGenerated();

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, eax
	mov	ecx, esi
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated

; 268  : 		int iEndTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	edi, eax

; 269  : 		iValue = iEndTechs - iStartTechs;

	sub	edi, ebx
	pop	esi

; 270  : 	}
; 271  : 
; 272  : 	return iValue;

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx

; 273  : }

	ret	4
$LN5@GetContest:

; 257  : 		iValue = iEndCulture - iStartCulture;
; 258  : 	}
; 259  : 	else if(eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	ebp, 11					; 0000000bH
	jne	SHORT $LN3@GetContest

; 260  : 	{
; 261  : 		int iStartFaith = pMinor->GetMinorCivAI()->GetQuestData1(ePlayer, eType);

	push	ebp
	push	esi
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetQuestData1

; 262  : 		int iEndFaith = GET_PLAYER(ePlayer).GetFaithEverGenerated();

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, eax
	mov	ecx, esi
	call	?GetFaithEverGenerated@CvPlayer@@QBEHXZ	; CvPlayer::GetFaithEverGenerated

; 268  : 		int iEndTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	edi, eax

; 269  : 		iValue = iEndTechs - iStartTechs;

	sub	edi, ebx
	pop	esi

; 270  : 	}
; 271  : 
; 272  : 	return iValue;

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx

; 273  : }

	ret	4
$LN3@GetContest:

; 263  : 		iValue = iEndFaith - iStartFaith;
; 264  : 	}
; 265  : 	else if(eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	ebp, 12					; 0000000cH
	jne	SHORT $LN1@GetContest

; 266  : 	{
; 267  : 		int iStartTechs = pMinor->GetMinorCivAI()->GetQuestData1(ePlayer, eType);

	push	ebp
	push	esi
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetQuestData1

; 268  : 		int iEndTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	mov	edi, eax

; 269  : 		iValue = iEndTechs - iStartTechs;

	sub	edi, ebx
$LN1@GetContest:
	pop	esi

; 270  : 	}
; 271  : 
; 272  : 	return iValue;

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx

; 273  : }

	ret	4
?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivQuest::GetContestValueForPlayer
_TEXT	ENDS
PUBLIC	?GetContestValueForLeader@CvMinorCivQuest@@QAEHXZ ; CvMinorCivQuest::GetContestValueForLeader
; Function compile flags: /Ogtpy
;	COMDAT ?GetContestValueForLeader@CvMinorCivQuest@@QAEHXZ
_TEXT	SEGMENT
?GetContestValueForLeader@CvMinorCivQuest@@QAEHXZ PROC	; CvMinorCivQuest::GetContestValueForLeader, COMDAT
; _this$ = ecx

; 276  : {

	push	ebx
	mov	ebx, ecx

; 277  : 	MinorCivQuestTypes eType = GetType();

	mov	eax, DWORD PTR [ebx+8]
	push	edi

; 278  : 	int iHighestValue = -1;

	or	edi, -1

; 279  : 
; 280  : 	if(eType == MINOR_CIV_QUEST_CONTEST_CULTURE ||
; 281  : 	        eType == MINOR_CIV_QUEST_CONTEST_FAITH ||
; 282  : 	        eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 10					; 0000000aH
	je	SHORT $LN5@GetContest@2
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN5@GetContest@2
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN13@GetContest@2
$LN5@GetContest@2:
	push	esi

; 283  : 	{
; 284  : 		// What is the largest value a participant has for this contest?
; 285  : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	npad	4
$LL4@GetContest@2:

; 286  : 		{
; 287  : 			PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
; 288  : 
; 289  : 			int iPlayerValue = GetContestValueForPlayer(ePlayerLoop);

	push	esi
	mov	ecx, ebx
	call	?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z ; CvMinorCivQuest::GetContestValueForPlayer

; 290  : 			if(iPlayerValue > iHighestValue)

	cmp	eax, edi
	jle	SHORT $LN3@GetContest@2

; 291  : 			{
; 292  : 				iHighestValue = iPlayerValue;

	mov	edi, eax
$LN3@GetContest@2:

; 283  : 	{
; 284  : 		// What is the largest value a participant has for this contest?
; 285  : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL4@GetContest@2
	pop	esi
$LN13@GetContest@2:

; 293  : 			}
; 294  : 		}
; 295  : 	}
; 296  : 
; 297  : 	return iHighestValue;

	mov	eax, edi
	pop	edi
	pop	ebx

; 298  : }

	ret	0
?GetContestValueForLeader@CvMinorCivQuest@@QAEHXZ ENDP	; CvMinorCivQuest::GetContestValueForLeader
_TEXT	ENDS
PUBLIC	?IsRevoked@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::IsRevoked
; Function compile flags: /Ogtpy
;	COMDAT ?IsRevoked@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
?IsRevoked@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::IsRevoked, COMDAT
; _this$ = ecx

; 561  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 562  : 	if(GET_PLAYER(m_eMinor).GetMinorCivAI()->IsRecentlyBulliedByMajor(m_eAssignedPlayer))

	mov	ecx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ebx, eax
	cmp	esi, 21					; 00000015H
	ja	SHORT $LN1@IsRevoked
	cmp	DWORD PTR [ebx+esi*4+2816], 0
	jl	SHORT $LN1@IsRevoked
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, 20					; 00000014H
	cmp	DWORD PTR [ebx+esi*4+2816], eax
	jl	SHORT $LN1@IsRevoked

; 563  : 	{
; 564  : 		if(m_eType == MINOR_CIV_QUEST_ROUTE)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN13@IsRevoked
$LN28@IsRevoked:
	pop	edi
	pop	esi

; 565  : 			return true;

	mov	al, 1
	pop	ebx

; 593  : }

	ret	0
$LN13@IsRevoked:

; 566  : 		if(m_eType == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	eax, 2

; 567  : 			return true;

	je	SHORT $LN28@IsRevoked

; 568  : 		if(m_eType == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3

; 569  : 			return true;

	je	SHORT $LN28@IsRevoked

; 570  : 		if(m_eType == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4

; 571  : 			return true;

	je	SHORT $LN28@IsRevoked

; 572  : 		if(m_eType == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6

; 573  : 			return true;

	je	SHORT $LN28@IsRevoked

; 574  : 		if(m_eType == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7

; 575  : 			return true;

	je	SHORT $LN28@IsRevoked

; 576  : 		if(m_eType == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8

; 577  : 			return true;

	je	SHORT $LN28@IsRevoked

; 578  : 		if(m_eType == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9

; 579  : 			return true;

	je	SHORT $LN28@IsRevoked

; 580  : 		if(m_eType == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH

; 581  : 			return true;

	je	SHORT $LN28@IsRevoked

; 582  : 		if(m_eType == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH

; 583  : 			return true;

	je	SHORT $LN28@IsRevoked

; 584  : 		if(m_eType == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH

; 585  : 			return true;

	je	SHORT $LN28@IsRevoked

; 586  : 		if(m_eType == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	eax, 16					; 00000010H

; 587  : 			return true;

	je	SHORT $LN28@IsRevoked

; 588  : 		if(m_eType == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	eax, 17					; 00000011H

; 589  : 			return true;

	je	SHORT $LN28@IsRevoked
$LN1@IsRevoked:
	pop	edi
	pop	esi

; 590  : 	}
; 591  : 
; 592  : 	return false;

	xor	al, al
	pop	ebx

; 593  : }

	ret	0
?IsRevoked@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::IsRevoked
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvMinorCivQuest@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvMinorCivQuest@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_v$241296 = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvMinorCivQuest@@@Z PROC	; operator>>, COMDAT

; 1575 : {

	push	ecx
	push	esi

; 1576 : 	uint uiVersion;
; 1577 : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1578 : 
; 1579 : 	loadFrom >> writeTo.m_eType;

	lea	ecx, DWORD PTR _v$241296[esp+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	edi, DWORD PTR _writeTo$[esp+8]
	mov	edx, DWORD PTR _v$241296[esp+8]

; 1580 : 	loadFrom >> writeTo.m_iStartTurn;

	lea	eax, DWORD PTR [edi+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+8], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1581 : 	loadFrom >> writeTo.m_iData1;

	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1582 : 	loadFrom >> writeTo.m_iData2;

	lea	edx, DWORD PTR [edi+20]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1583 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+12], 2
	jb	SHORT $LN2@operator@9

; 1584 : 	{
; 1585 : 		loadFrom >> writeTo.m_bHandled;

	add	edi, 24					; 00000018H
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	pop	edi

; 1590 : 	}
; 1591 : 
; 1592 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 1593 : }

	pop	ecx
	ret	0
$LN2@operator@9:

; 1586 : 	}
; 1587 : 	else
; 1588 : 	{
; 1589 : 		writeTo.m_bHandled = false;

	mov	BYTE PTR [edi+24], 0
	pop	edi

; 1590 : 	}
; 1591 : 
; 1592 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 1593 : }

	pop	ecx
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvMinorCivQuest@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvMinorCivQuest@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvMinorCivQuest@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T241326 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvMinorCivQuest@@@Z PROC	; operator<<, COMDAT

; 1597 : {

	push	ecx
	push	esi

; 1598 : 	uint uiVersion = 2;
; 1599 : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1600 : 
; 1601 : 	saveTo << readFrom.m_eType;

	mov	edi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR $T241326[esp+8]
	mov	DWORD PTR $T241326[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1602 : 	saveTo << readFrom.m_iStartTurn;

	lea	eax, DWORD PTR [edi+12]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1603 : 	saveTo << readFrom.m_iData1;

	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1604 : 	saveTo << readFrom.m_iData2;

	lea	edx, DWORD PTR [edi+20]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1605 : 	saveTo << readFrom.m_bHandled;

	add	edi, 24					; 00000018H
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi

; 1606 : 
; 1607 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 1608 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvMinorCivQuest@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ ; CvMinorCivAI::GetMinorCivType
EXTRN	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z:PROC ; CvPreGame::minorCivType
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ
_TEXT	SEGMENT
?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ PROC ; CvMinorCivAI::GetMinorCivType, COMDAT
; _this$ = ecx

; 1890 : 	//	return m_minorCivType;
; 1891 : 	return CvPreGame::minorCivType(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4

; 1892 : }

	ret	0
?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ ENDP ; CvMinorCivAI::GetMinorCivType
_TEXT	ENDS
PUBLIC	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
EXTRN	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z:PROC ; CvGlobals::getMinorCivInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ
_TEXT	SEGMENT
?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ PROC ; CvMinorCivAI::GetTrait, COMDAT
; _this$ = ecx

; 1949 : 	CvMinorCivInfo* pkMinorCivInfo = GC.getMinorCivInfo(GetMinorCivType());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo

; 1950 : 	if(pkMinorCivInfo)

	test	eax, eax
	je	SHORT $LN1@GetTrait

; 1951 : 	{
; 1952 : 		return (MinorCivTraitTypes) pkMinorCivInfo->GetMinorCivTrait();

	mov	eax, DWORD PTR [eax+272]

; 1956 : }

	ret	0
$LN1@GetTrait:

; 1953 : 	}
; 1954 : 
; 1955 : 	return NO_MINOR_CIV_TRAIT_TYPE;

	or	eax, -1

; 1956 : }

	ret	0
?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ENDP ; CvMinorCivAI::GetTrait
_TEXT	ENDS
PUBLIC	?DoPickUniqueUnit@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoPickUniqueUnit
EXTRN	?GetRandomUniqueUnitType@CvGame@@QAE?AW4UnitTypes@@_N000@Z:PROC ; CvGame::GetRandomUniqueUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?DoPickUniqueUnit@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoPickUniqueUnit@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoPickUniqueUnit, COMDAT
; _this$ = ecx

; 1984 : {

	push	esi
	mov	esi, ecx

; 1985 : 	m_eUniqueUnit = NO_UNIT;
; 1986 : 	if (GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+16], -1
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN1@DoPickUniq
	mov	eax, DWORD PTR [eax+272]
	cmp	eax, 1
	jne	SHORT $LN1@DoPickUniq

; 1987 : 	{
; 1988 : 		// Units from our starting era or before would be no fun because players won't get the chance to use them
; 1989 : 		m_eUniqueUnit = GC.getGame().GetRandomUniqueUnitType(/*bIncludeCivsInGame*/false, /*bIncludeStartEraUnits*/false, /*bIncludeOldEras*/false, /*bIncludeRanged*/true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	push	0
	push	0
	call	?GetRandomUniqueUnitType@CvGame@@QAE?AW4UnitTypes@@_N000@Z ; CvGame::GetRandomUniqueUnitType
	mov	DWORD PTR [esi+16], eax
$LN1@DoPickUniq:
	pop	esi

; 1990 : 	}
; 1991 : }

	ret	0
?DoPickUniqueUnit@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoPickUniqueUnit
_TEXT	ENDS
PUBLIC	?DoTestEndWarsVSMinors@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z ; CvMinorCivAI::DoTestEndWarsVSMinors
EXTRN	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z:PROC	; CvTeam::makePeace
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?isMinorCiv@CvTeam@@QBE_NXZ:PROC		; CvTeam::isMinorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?DoTestEndWarsVSMinors@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv648 = -4						; size = 4
_eOldAlly$ = 8						; size = 4
_eNewAlly$ = 12						; size = 4
?DoTestEndWarsVSMinors@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z PROC ; CvMinorCivAI::DoTestEndWarsVSMinors, COMDAT
; _this$ = ecx

; 2220 : {

	push	ecx

; 2221 : 	if(eOldAlly == NO_PLAYER)

	cmp	DWORD PTR _eOldAlly$[esp], -1
	push	ebx
	mov	ebx, ecx
	je	$LN16@DoTestEndW

; 2222 : 		return;
; 2223 : 
; 2224 : 	if(!GetPlayer()->isAlive())

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+2256], 0
	je	$LN16@DoTestEndW
	push	ebp
	push	esi
	push	edi

; 2225 : 		return;
; 2226 : 
; 2227 : 	PlayerTypes eOtherMinor;
; 2228 : 	int iOtherMinorLoop;
; 2229 : 	PlayerTypes eOtherAlly;
; 2230 : 	bool bForcedWar;
; 2231 : 
; 2232 : 	TeamTypes eLoopTeam;
; 2233 : 	for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR tv648[esp+20], esi
	npad	7
$LL141@DoTestEndW:

; 2234 : 	{
; 2235 : 		eLoopTeam = (TeamTypes) iTeamLoop;
; 2236 : 
; 2237 : 		// Another Minor
; 2238 : 		if(!GET_TEAM(eLoopTeam).isMinorCiv())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebp, DWORD PTR _eNewAlly$[esp+16]
	add	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	$LN17@DoTestEndW

; 2239 : 			continue;
; 2240 : 
; 2241 : 		// They not alive!
; 2242 : 		if(!GET_TEAM(eLoopTeam).isAlive())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+ecx+12], 0
	jle	$LN17@DoTestEndW

; 2243 : 			continue;
; 2244 : 
; 2245 : 		// At war with him
; 2246 : 		if(!GET_TEAM(GetPlayer()->getTeam()).isAtWar(eLoopTeam))

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN41@DoTestEndW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN42@DoTestEndW
$LN41@DoTestEndW:
	or	eax, -1
$LN42@DoTestEndW:
	imul	eax, 2984				; 00000ba8H
	add	eax, ecx
	push	edi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN17@DoTestEndW

; 2247 : 			continue;
; 2248 : 
; 2249 : 		if(eOldAlly != NO_PLAYER)
; 2250 : 		{
; 2251 : 			// Old ally wasn't at war
; 2252 : 			if(!GET_TEAM(GET_PLAYER(eOldAlly).getTeam()).isAtWar(eLoopTeam))

	mov	eax, DWORD PTR _eOldAlly$[esp+16]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@DoTestEndW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN55@DoTestEndW
$LN54@DoTestEndW:
	or	eax, -1
$LN55@DoTestEndW:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN17@DoTestEndW

; 2253 : 				continue;
; 2254 : 		}
; 2255 : 
; 2256 : 		if(eNewAlly != NO_PLAYER)

	cmp	ebp, -1
	je	SHORT $LN9@DoTestEndW

; 2257 : 		{
; 2258 : 			// New ally IS at war
; 2259 : 			if(GET_TEAM(GET_PLAYER(eNewAlly).getTeam()).isAtWar(eLoopTeam))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebp, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN67@DoTestEndW
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN68@DoTestEndW
$LN67@DoTestEndW:
	or	eax, -1
$LN68@DoTestEndW:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN17@DoTestEndW
$LN9@DoTestEndW:

; 2260 : 				continue;
; 2261 : 		}
; 2262 : 
; 2263 : 		// Make sure this guy isn't allied with someone at war with us
; 2264 : 		bForcedWar = false;
; 2265 : 
; 2266 : 		for(iOtherMinorLoop = 0; iOtherMinorLoop < MAX_CIV_TEAMS; iOtherMinorLoop++)

	xor	esi, esi
	npad	4
$LL8@DoTestEndW:

; 2267 : 		{
; 2268 : 			eOtherMinor = (PlayerTypes) iOtherMinorLoop;
; 2269 : 
; 2270 : 			// Other minor is on this team
; 2271 : 			if(GET_PLAYER(eOtherMinor).getTeam() == eLoopTeam)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN80@DoTestEndW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN81@DoTestEndW
$LN80@DoTestEndW:
	or	eax, -1
$LN81@DoTestEndW:
	cmp	eax, edi
	jne	SHORT $LN7@DoTestEndW

; 2272 : 			{
; 2273 : 				eOtherAlly = GET_PLAYER(eOtherMinor).GetMinorCivAI()->GetAlly();

	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	eax, DWORD PTR [eax+2012]

; 2274 : 				if(eOtherAlly != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN7@DoTestEndW

; 2275 : 				{
; 2276 : 					// This guy's ally at war with us?
; 2277 : 					if(GET_TEAM(GET_PLAYER(eOtherAlly).getTeam()).isAtWar(GetPlayer()->getTeam()))

	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN95@DoTestEndW
	mov	ebp, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ebp+ecx*4]
	jmp	SHORT $LN96@DoTestEndW
$LN95@DoTestEndW:
	or	ecx, -1
$LN96@DoTestEndW:
	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN106@DoTestEndW
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN107@DoTestEndW
$LN106@DoTestEndW:
	or	eax, -1
$LN107@DoTestEndW:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN17@DoTestEndW
$LN7@DoTestEndW:

; 2260 : 				continue;
; 2261 : 		}
; 2262 : 
; 2263 : 		// Make sure this guy isn't allied with someone at war with us
; 2264 : 		bForcedWar = false;
; 2265 : 
; 2266 : 		for(iOtherMinorLoop = 0; iOtherMinorLoop < MAX_CIV_TEAMS; iOtherMinorLoop++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 3983868				; 003cc9fcH
	jl	$LL8@DoTestEndW

; 2278 : 					{
; 2279 : 						bForcedWar = true;
; 2280 : 						break;
; 2281 : 					}
; 2282 : 				}
; 2283 : 			}
; 2284 : 
; 2285 : 		}
; 2286 : 
; 2287 : 		if(bForcedWar)
; 2288 : 			continue;
; 2289 : 
; 2290 : 		if(IsPermanentWar(eLoopTeam))

	test	edi, edi
	jl	SHORT $LN136@DoTestEndW
	cmp	edi, 64					; 00000040H
	jge	SHORT $LN136@DoTestEndW
	cmp	BYTE PTR [edi+ebx+3168], 0
	jne	SHORT $LN17@DoTestEndW
$LN136@DoTestEndW:

; 2291 : 			continue;
; 2292 : 
; 2293 : 		GET_TEAM(GetPlayer()->getTeam()).makePeace(eLoopTeam);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN123@DoTestEndW
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN124@DoTestEndW
$LN123@DoTestEndW:
	or	ecx, -1
$LN124@DoTestEndW:
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	1
	push	edi
	call	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ; CvTeam::makePeace
$LN17@DoTestEndW:
	mov	esi, DWORD PTR tv648[esp+20]
	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	mov	DWORD PTR tv648[esp+20], esi
	jl	$LL141@DoTestEndW
	pop	edi
	pop	esi
	pop	ebp
$LN16@DoTestEndW:
	pop	ebx

; 2294 : 	}
; 2295 : }

	pop	ecx
	ret	8
?DoTestEndWarsVSMinors@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z ENDP ; CvMinorCivAI::DoTestEndWarsVSMinors
_TEXT	ENDS
PUBLIC	?DoRemoveStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z ; CvMinorCivAI::DoRemoveStartingResources
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
EXTRN	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isOnlyMinorCivs
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pCityPlot$ = 8						; size = 4
?DoRemoveStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z PROC ; CvMinorCivAI::DoRemoveStartingResources, COMDAT
; _this$ = ecx

; 2453 : {

	push	esi

; 2454 : 	CvAssertMsg(pCityPlot != NULL, "City's plot should not be NULL. Please send Anton your save file and version.");
; 2455 : 	if (pCityPlot == NULL) return;

	mov	esi, DWORD PTR _pCityPlot$[esp]
	test	esi, esi
	je	SHORT $LN1@DoRemoveSt

; 2456 : 
; 2457 : 	MinorCivTraitTypes eTrait = GetTrait();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN1@DoRemoveSt

; 2458 : 
; 2459 : 	// Mercantile
; 2460 : 	if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	DWORD PTR [eax+272], 3
	jne	SHORT $LN1@DoRemoveSt

; 2461 : 	{
; 2462 : 		bool bRemoveUniqueLuxury = false;
; 2463 : 
; 2464 : 		if (GC.getMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED() == 1)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+3248, 1
	jne	SHORT $LN1@DoRemoveSt

; 2465 : 			bRemoveUniqueLuxury = true;
; 2466 : 
; 2467 : 		if (bRemoveUniqueLuxury)
; 2468 : 		{
; 2469 : 			ResourceTypes eOldResource = pCityPlot->getResourceType();

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 2470 : 			if (eOldResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN1@DoRemoveSt

; 2471 : 			{
; 2472 : 				CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eOldResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2473 : 				if (pkResourceInfo && pkResourceInfo->isOnlyMinorCivs())

	test	eax, eax
	je	SHORT $LN1@DoRemoveSt
	mov	ecx, eax
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	test	al, al
	je	SHORT $LN1@DoRemoveSt

; 2474 : 				{
; 2475 : 					pCityPlot->setResourceType(NO_RESOURCE, 0, true);

	push	1
	push	0
	push	-1
	mov	ecx, esi
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN1@DoRemoveSt:
	pop	esi

; 2476 : 				}
; 2477 : 			}
; 2478 : 		}
; 2479 : 	}
; 2480 : }

	ret	4
?DoRemoveStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z ENDP ; CvMinorCivAI::DoRemoveStartingResources
_TEXT	ENDS
PUBLIC	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$1
__ehfuncinfo$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_sString$ = 8						; size = 28
_sSummaryString$ = 36					; size = 28
_ePlayer$ = 64						; size = 4
_iX$ = 68						; size = 4
_iY$ = 72						; size = 4
?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z PROC ; CvMinorCivAI::AddNotification, COMDAT
; _this$ = ecx

; 2484 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 2485 : 	if(iX == -1 && iY == -1)

	mov	ebx, DWORD PTR _iX$[esp+24]
	mov	ebp, DWORD PTR _iY$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 1
	cmp	ebx, -1
	jne	SHORT $LN37@AddNotific
	cmp	ebp, ebx
	jne	SHORT $LN37@AddNotific

; 2486 : 	{
; 2487 : 		CvCity* capCity = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [esi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 2488 : 
; 2489 : 		if(capCity != NULL)

	test	eax, eax
	je	SHORT $LN37@AddNotific

; 2490 : 		{
; 2491 : 			iX = capCity->getX();

	mov	ebx, DWORD PTR [eax+96]

; 2492 : 			iY = capCity->getY();

	mov	ebp, DWORD PTR [eax+108]
$LN37@AddNotific:

; 2493 : 		}
; 2494 : 	}
; 2495 : 
; 2496 : 	CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	ecx, DWORD PTR _ePlayer$[esp+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 2497 : 	if(pNotifications)

	test	edi, edi
	je	SHORT $LN1@AddNotific

; 2498 : 	{
; 2499 : 		pNotifications->Add(NOTIFICATION_MINOR, sString, sSummaryString, iX, iY, GetPlayer()->GetID());

	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _sSummaryString$[esp+24]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	ebp
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _sString$[esp+44]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-967190754				; c659d71eH
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN1@AddNotific:

; 2500 : 	}
; 2501 : }

	lea	ecx, DWORD PTR _sString$[esp+24]
	mov	BYTE PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sSummaryString$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	68					; 00000044H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _sSummaryString$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$1:
	lea	ecx, DWORD PTR _sString$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ENDP ; CvMinorCivAI::AddNotification
PUBLIC	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z$2
__ehfuncinfo$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z
_TEXT	SEGMENT
$T241796 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_sString$ = 8						; size = 28
_sSummaryString$ = 36					; size = 28
_ePlayer$ = 64						; size = 4
_iX$ = 68						; size = 4
_iY$ = 72						; size = 4
_bNewQuest$ = 76					; size = 1
?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z PROC ; CvMinorCivAI::AddQuestNotification, COMDAT
; _this$ = ecx

; 2505 : {

	push	-1
	push	__ehhandler$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	mov	edi, ecx

; 2506 : 	CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	ecx, DWORD PTR _ePlayer$[esp+96]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+108], 1
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 2507 : 	if(pNotifications)

	test	esi, esi
	je	$LN1@AddQuestNo

; 2508 : 	{
; 2509 : 		sString += "[NEWLINE][NEWLINE]";

	push	OFFSET $SG223020
	lea	ecx, DWORD PTR _sString$[esp+100]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2510 : 		sString += Localization::Lookup("TXT_KEY_MINOR_QUEST_BLOCKING_TT").toUTF8();

	lea	eax, DWORD PTR $T241796[esp+100]
	push	OFFSET $SG223022
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+108], 2
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sString$[esp+100]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	lea	ecx, DWORD PTR $T241796[esp+100]
	mov	BYTE PTR __$EHRec$[esp+108], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2511 : 
; 2512 : 		if (bNewQuest)
; 2513 : 			pNotifications->Add(NOTIFICATION_MINOR_QUEST, sString, sSummaryString, iX, iY, GetPlayer()->GetID(), 1);

	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+44]
	lea	ecx, DWORD PTR _sSummaryString$[esp+96]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	cmp	BYTE PTR _bNewQuest$[esp+96], 0
	mov	ecx, DWORD PTR _iY$[esp+96]
	mov	edx, DWORD PTR _iX$[esp+96]
	je	SHORT $LN2@AddQuestNo
	push	1

; 2514 : 		else

	jmp	SHORT $LN38@AddQuestNo
$LN2@AddQuestNo:

; 2515 : 			pNotifications->Add(NOTIFICATION_MINOR_QUEST, sString, sSummaryString, iX, iY, GetPlayer()->GetID());

	push	-1
$LN38@AddQuestNo:
	push	edi
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _sString$[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1365828128				; ae971de0H
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN1@AddQuestNo:

; 2516 : 	}
; 2517 : }

	lea	ecx, DWORD PTR _sString$[esp+96]
	mov	BYTE PTR __$EHRec$[esp+108], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sSummaryString$[esp+96]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 92					; 0000005cH
	ret	72					; 00000048H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z$0:
	lea	ecx, DWORD PTR _sSummaryString$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z$1:
	lea	ecx, DWORD PTR _sString$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z$2:
	lea	ecx, DWORD PTR $T241796[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ENDP ; CvMinorCivAI::AddQuestNotification
PUBLIC	?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddBuyoutNotification
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$1
__ehfuncinfo$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_sString$ = 8						; size = 28
_sSummaryString$ = 36					; size = 28
_ePlayer$ = 64						; size = 4
_iX$ = 68						; size = 4
_iY$ = 72						; size = 4
?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z PROC ; CvMinorCivAI::AddBuyoutNotification, COMDAT
; _this$ = ecx

; 2521 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 2522 : 	if(iX == -1 && iY == -1)

	mov	ebx, DWORD PTR _iX$[esp+24]
	mov	ebp, DWORD PTR _iY$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 1
	cmp	ebx, -1
	jne	SHORT $LN37@AddBuyoutN
	cmp	ebp, ebx
	jne	SHORT $LN37@AddBuyoutN

; 2523 : 	{
; 2524 : 		CvCity* capCity = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [esi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 2525 : 
; 2526 : 		if(capCity != NULL)

	test	eax, eax
	je	SHORT $LN37@AddBuyoutN

; 2527 : 		{
; 2528 : 			iX = capCity->getX();

	mov	ebx, DWORD PTR [eax+96]

; 2529 : 			iY = capCity->getY();

	mov	ebp, DWORD PTR [eax+108]
$LN37@AddBuyoutN:

; 2530 : 		}
; 2531 : 	}
; 2532 : 
; 2533 : 	CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	ecx, DWORD PTR _ePlayer$[esp+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 2534 : 	if(pNotifications)

	test	edi, edi
	je	SHORT $LN1@AddBuyoutN

; 2535 : 	{
; 2536 : 		pNotifications->Add(NOTIFICATION_MINOR_BUYOUT, sString, sSummaryString, iX, iY, GetPlayer()->GetID());

	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [eax+44]
	lea	ecx, DWORD PTR _sSummaryString$[esp+24]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	esi
	push	ebp
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _sString$[esp+44]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1594364879				; 5f0813cfH
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN1@AddBuyoutN:

; 2537 : 	}
; 2538 : }

	lea	ecx, DWORD PTR _sString$[esp+24]
	mov	BYTE PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sSummaryString$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	68					; 00000044H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _sSummaryString$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z$1:
	lea	ecx, DWORD PTR _sString$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ENDP ; CvMinorCivAI::AddBuyoutNotification
PUBLIC	?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetNumThreateningBarbarians
EXTRN	?IsBarbarianUnitThreateningMinor@CvUnit@@QAE_NW4PlayerTypes@@@Z:PROC ; CvUnit::IsBarbarianUnitThreateningMinor
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ PROC	; CvMinorCivAI::GetNumThreateningBarbarians, COMDAT
; _this$ = ecx

; 2564 : {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 2565 : 	int iCount = 0;
; 2566 : 
; 2567 : 	int iLoop;
; 2568 : 	for(CvUnit* pLoopUnit = GET_PLAYER(BARBARIAN_PLAYER).firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = GET_PLAYER(BARBARIAN_PLAYER).nextUnit(&iLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	edi, edi
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	add	ecx, 3983868				; 003cc9fcH
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN19@GetNumThre
$LL4@GetNumThre:

; 2569 : 	{
; 2570 : 		if(pLoopUnit->IsBarbarianUnitThreateningMinor(GetPlayer()->GetID()))

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	mov	ecx, eax
	call	?IsBarbarianUnitThreateningMinor@CvUnit@@QAE_NW4PlayerTypes@@@Z ; CvUnit::IsBarbarianUnitThreateningMinor
	test	al, al
	je	SHORT $LN3@GetNumThre

; 2571 : 			iCount++;

	inc	edi
$LN3@GetNumThre:

; 2565 : 	int iCount = 0;
; 2566 : 
; 2567 : 	int iLoop;
; 2568 : 	for(CvUnit* pLoopUnit = GET_PLAYER(BARBARIAN_PLAYER).firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = GET_PLAYER(BARBARIAN_PLAYER).nextUnit(&iLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+16]
	add	ecx, 3983868				; 003cc9fcH
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL4@GetNumThre
$LN19@GetNumThre:

; 2572 : 	}
; 2573 : 
; 2574 : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi

; 2575 : }

	pop	ecx
	ret	0
?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ENDP	; CvMinorCivAI::GetNumThreateningBarbarians
_TEXT	ENDS
PUBLIC	?GetPersonalityQuestBias@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetPersonalityQuestBias
; Function compile flags: /Ogtpy
;	COMDAT ?GetPersonalityQuestBias@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eQuest$ = 8						; size = 4
?GetPersonalityQuestBias@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::GetPersonalityQuestBias, COMDAT
; _this$ = ecx

; 3903 : 	// Multiply by 10 to give us some more fidelity. We'll remove it at the bottom
; 3904 : 	int iCount = 10 * /*10*/ GC.getMINOR_CIV_QUEST_WEIGHT_DEFAULT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3324
	push	esi
	lea	esi, DWORD PTR [eax+eax*4]

; 3905 : 
; 3906 : 	MinorCivPersonalityTypes ePersonality = GetPersonality();
; 3907 : 	MinorCivTraitTypes eTrait = GetTrait();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	push	edi
	mov	edi, DWORD PTR [ecx+8]
	push	eax
	add	esi, esi
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN84@GetPersona
	mov	ecx, DWORD PTR [eax+272]
	jmp	SHORT $LN85@GetPersona
$LN84@GetPersona:
	or	ecx, -1
$LN85@GetPersona:

; 3908 : 
; 3909 : 	// ******************
; 3910 : 	// Personal Quests
; 3911 : 	// ******************
; 3912 : 
; 3913 : 	// ROUTE
; 3914 : 	if(eQuest == MINOR_CIV_QUEST_ROUTE)

	mov	eax, DWORD PTR _eQuest$[esp+4]
	test	eax, eax
	jne	SHORT $LN77@GetPersona

; 3915 : 	{
; 3916 : 		if(ePersonality == MINOR_CIV_PERSONALITY_FRIENDLY)		// Friendly

	test	edi, edi
	jne	SHORT $LN76@GetPersona

; 3917 : 		{
; 3918 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3328

; 3919 : 			iCount /= 100;
; 3920 : 		}
; 3921 : 		if(ePersonality == MINOR_CIV_PERSONALITY_HOSTILE)		// Hostile

	jmp	SHORT $LN139@GetPersona
$LN76@GetPersona:
	cmp	edi, 2
	jne	SHORT $LN75@GetPersona

; 3922 : 		{
; 3923 : 			iCount *= /*20*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3332
$LN139@GetPersona:
	imul	edx, esi

; 3924 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN75@GetPersona:

; 3925 : 		}
; 3926 : 		if(eTrait == MINOR_CIV_TRAIT_MARITIME)						// Maritime

	cmp	ecx, 2
	jne	SHORT $LN74@GetPersona

; 3927 : 		{
; 3928 : 			iCount *= /*120*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3336
	imul	ecx, esi

; 3929 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 3930 : 		}
; 3931 : 		if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	jmp	$LN1@GetPersona
$LN74@GetPersona:
	cmp	ecx, 3
	jne	$LN1@GetPersona

; 3932 : 		{
; 3933 : 			iCount *= /*150*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3340
	imul	ecx, esi

; 3934 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3935 : 		}
; 3936 : 	}

	jmp	$LN140@GetPersona
$LN77@GetPersona:

; 3937 : 
; 3938 : 	// CONNECT A RESOURCE
; 3939 : 	else if(eQuest == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	eax, 2
	jne	SHORT $LN71@GetPersona

; 3940 : 	{
; 3941 : 		if(eTrait == MINOR_CIV_TRAIT_MARITIME)						// Maritime

	cmp	ecx, eax
	jne	SHORT $LN70@GetPersona

; 3942 : 		{
; 3943 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3348
	imul	ecx, esi

; 3944 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 3945 : 		}
; 3946 : 		if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	jmp	$LN1@GetPersona
$LN70@GetPersona:
	cmp	ecx, 3
	jne	$LN1@GetPersona

; 3947 : 		{
; 3948 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3352
	imul	ecx, esi

; 3949 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3950 : 		}
; 3951 : 	}

	jmp	$LN140@GetPersona
$LN71@GetPersona:

; 3952 : 
; 3953 : 	// CONSTRUCT A WONDER
; 3954 : 	else if(eQuest == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	SHORT $LN67@GetPersona

; 3955 : 	{
; 3956 : 		if(eTrait == MINOR_CIV_TRAIT_CULTURED)						// Cultured

	test	ecx, ecx
	jne	$LN1@GetPersona

; 3957 : 		{
; 3958 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3356
	imul	ecx, esi

; 3959 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 3960 : 		}
; 3961 : 	}

	jmp	$LN1@GetPersona
$LN67@GetPersona:

; 3962 : 
; 3963 : 	// GREAT PERSON
; 3964 : 	else if(eQuest == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4
	jne	SHORT $LN64@GetPersona

; 3965 : 	{
; 3966 : 		if(eTrait == MINOR_CIV_TRAIT_CULTURED)						// Cultured

	test	ecx, ecx
	jne	$LN1@GetPersona

; 3967 : 		{
; 3968 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3360
	imul	ecx, esi

; 3969 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3970 : 		}
; 3971 : 	}

	jmp	$LN140@GetPersona
$LN64@GetPersona:

; 3972 : 
; 3973 : 	// KILL ANOTHER CITY STATE
; 3974 : 	else if(eQuest == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	SHORT $LN61@GetPersona

; 3975 : 	{
; 3976 : 		if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)					// Militaristic

	cmp	ecx, 1
	jne	SHORT $LN60@GetPersona

; 3977 : 		{
; 3978 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3364
	imul	ecx, esi

; 3979 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx
$LN60@GetPersona:

; 3980 : 		}
; 3981 : 		if(ePersonality == MINOR_CIV_PERSONALITY_HOSTILE)		// Hostile

	cmp	edi, 2
	jne	SHORT $LN59@GetPersona

; 3982 : 		{
; 3983 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3368
	imul	ecx, esi

; 3984 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3985 : 		}
; 3986 : 		if(ePersonality == MINOR_CIV_PERSONALITY_NEUTRAL)		// Neutral

	jmp	$LN140@GetPersona
$LN59@GetPersona:
	cmp	edi, 1
	jne	$LN1@GetPersona

; 3987 : 		{
; 3988 : 			iCount *= /*40*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3372
	imul	ecx, esi

; 3989 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 3990 : 		}
; 3991 : 	}

	jmp	$LN1@GetPersona
$LN61@GetPersona:

; 3992 : 
; 3993 : 	// FIND ANOTHER PLAYER
; 3994 : 	else if(eQuest == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6
	jne	SHORT $LN56@GetPersona

; 3995 : 	{
; 3996 : 		if(eTrait == MINOR_CIV_TRAIT_MARITIME)						// Maritime

	cmp	ecx, 2
	jne	SHORT $LN55@GetPersona

; 3997 : 		{
; 3998 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3376
	imul	ecx, esi

; 3999 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 4000 : 		}
; 4001 : 		if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	jmp	$LN140@GetPersona
$LN55@GetPersona:
	cmp	ecx, 3
	jne	$LN1@GetPersona

; 4002 : 		{
; 4003 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3380
	imul	ecx, esi

; 4004 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4005 : 		}
; 4006 : 	}

	jmp	$LN1@GetPersona
$LN56@GetPersona:

; 4007 : 
; 4008 : 	// FIND NATURAL WONDER
; 4009 : 	else if(eQuest == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7
	jne	SHORT $LN52@GetPersona

; 4010 : 	{
; 4011 : 		if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)					// Militaristic

	cmp	ecx, 1
	jne	SHORT $LN51@GetPersona

; 4012 : 		{
; 4013 : 			iCount *= /*50*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3384
	imul	ecx, esi

; 4014 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN51@GetPersona:

; 4015 : 		}
; 4016 : 		if(ePersonality == MINOR_CIV_PERSONALITY_HOSTILE)		// Hostile

	cmp	edi, 2
	jne	$LN1@GetPersona

; 4017 : 		{
; 4018 : 			iCount *= /*30*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3388
	imul	ecx, esi

; 4019 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4020 : 		}
; 4021 : 	}

	jmp	$LN1@GetPersona
$LN52@GetPersona:

; 4022 : 
; 4023 : 	// GOLD GIFT
; 4024 : 	else if(eQuest == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8
	jne	SHORT $LN48@GetPersona

; 4025 : 	{
; 4026 : 		//antonjs: consider: split quest bias into two categories, so that we can guarantee a support quest when a CS is bullied recently
; 4027 : 
; 4028 : 		if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)  // We are tough, we don't need your charity
; 4029 : 		{
; 4030 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD();
; 4031 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	cmp	ecx, 1
	jne	SHORT $LN47@GetPersona
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3392
	imul	ecx, esi
	imul	ecx
	jmp	$LN140@GetPersona
$LN47@GetPersona:

; 4032 : 		}
; 4033 : 		else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)  // Money is the answer to everything!

	cmp	ecx, 3
	jne	SHORT $LN45@GetPersona

; 4034 : 		{
; 4035 : 			iCount *= /*350*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3396

; 4036 : 			iCount /= 100;
; 4037 : 		}
; 4038 : 		else

	jmp	SHORT $LN147@GetPersona
$LN45@GetPersona:

; 4039 : 		{
; 4040 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3400
	imul	ecx, esi

; 4041 : 			iCount /= 100;

	imul	ecx

; 4042 : 		}

	jmp	$LN140@GetPersona
$LN48@GetPersona:

; 4043 : 	}
; 4044 : 
; 4045 : 	// PLEDGE TO PROTECT
; 4046 : 	else if(eQuest == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9
	jne	SHORT $LN42@GetPersona

; 4051 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	cmp	ecx, 1
	jne	SHORT $LN41@GetPersona

; 4047 : 	{
; 4048 : 		if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)  // We are tough, we don't need your charity
; 4049 : 		{
; 4050 : 			iCount *= /*200*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3404

; 4051 : 			iCount /= 100;

	jmp	SHORT $LN147@GetPersona
$LN41@GetPersona:

; 4052 : 		}
; 4053 : 		else if(eTrait == MINOR_CIV_TRAIT_CULTURED)  // Military?  We don't have one of those!

	test	ecx, ecx
	jne	SHORT $LN39@GetPersona

; 4054 : 		{
; 4055 : 			iCount *= /*350*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3408
	imul	ecx, esi

; 4056 : 			iCount /= 100;

	imul	ecx

; 4057 : 		}
; 4058 : 		else

	jmp	$LN140@GetPersona
$LN39@GetPersona:

; 4059 : 		{
; 4060 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3412
$LN147@GetPersona:
	imul	ecx, esi

; 4061 : 			iCount /= 100;

	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4062 : 		}

	jmp	$LN1@GetPersona
$LN42@GetPersona:

; 4063 : 	}
; 4064 : 
; 4065 : 	// Bully target City-State
; 4066 : 	else if(eQuest == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN36@GetPersona

; 4067 : 	{
; 4068 : 		if(ePersonality == MINOR_CIV_PERSONALITY_HOSTILE)

	cmp	edi, 2

; 4069 : 		{
; 4070 : 			iCount *= 200; //antonjs: todo: XML
; 4071 : 			iCount /= 100;

	je	$LN143@GetPersona

; 4072 : 		}
; 4073 : 		else if(ePersonality == MINOR_CIV_PERSONALITY_IRRATIONAL)

	cmp	edi, 3
	jne	SHORT $LN33@GetPersona

; 4074 : 		{
; 4075 : 			iCount *= 150; //antonjs: todo: xml

	imul	esi, 150				; 00000096H

; 4076 : 			iCount /= 100;

	jmp	$LN145@GetPersona
$LN33@GetPersona:

; 4077 : 		}
; 4078 : 		else if(ePersonality == MINOR_CIV_PERSONALITY_FRIENDLY)

	test	edi, edi
	jne	$LN1@GetPersona

; 4079 : 		{
; 4080 : 			iCount *= 30; //antonjs: todo: xml

	mov	ecx, esi
	shl	ecx, 4
	sub	ecx, esi
	add	ecx, ecx

; 4081 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 4082 : 		}
; 4083 : 	}

	jmp	$LN140@GetPersona
$LN36@GetPersona:

; 4084 : 
; 4085 : 	// Denounce target Major
; 4086 : 	else if(eQuest == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN29@GetPersona

; 4087 : 	{
; 4088 : 		if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)

	cmp	ecx, 4
	jne	SHORT $LN28@GetPersona

; 4089 : 		{
; 4090 : 			iCount *= 250; //antonjs: todo: xml

	imul	esi, 250				; 000000faH

; 4091 : 			iCount /= 100;

	jmp	SHORT $LN145@GetPersona
$LN28@GetPersona:

; 4096 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	cmp	ecx, 2
	jne	SHORT $LN26@GetPersona
$LN144@GetPersona:

; 4092 : 		}
; 4093 : 		else if(eTrait == MINOR_CIV_TRAIT_MARITIME)
; 4094 : 		{
; 4095 : 			iCount *= 200; //antonjs: todo: xml

	imul	esi, 200				; 000000c8H

; 4097 : 		}
; 4098 : 		else

	jmp	$LN142@GetPersona
$LN26@GetPersona:

; 4099 : 		{
; 4100 : 			iCount *= 150; //antonjs: todo: xml

	imul	esi, 150				; 00000096H

; 4101 : 			iCount /= 100;

	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4102 : 		}

	jmp	$LN1@GetPersona
$LN29@GetPersona:

; 4103 : 	}
; 4104 : 
; 4105 : 	// Spread your religion to us
; 4106 : 	else if(eQuest == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN23@GetPersona

; 4107 : 	{
; 4108 : 		if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)

	cmp	ecx, 4
	jne	$LN1@GetPersona

; 4109 : 		{
; 4110 : 			iCount *= 300; //antonjs: todo: xml

	imul	esi, 300				; 0000012cH

; 4111 : 			iCount /= 100;
; 4112 : 		}
; 4113 : 	}

	jmp	$LN141@GetPersona
$LN23@GetPersona:

; 4114 : 
; 4115 : 	// Trade Route
; 4116 : 	else if(eQuest == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN20@GetPersona

; 4117 : 	{
; 4118 : 		if(eTrait == MINOR_CIV_TRAIT_MARITIME)

	cmp	ecx, 2

; 4119 : 		{
; 4120 : 			iCount *= 200; //xml
; 4121 : 			iCount /= 100;

	je	SHORT $LN146@GetPersona

; 4122 : 		}
; 4123 : 		else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	ecx, 3
	jne	$LN1@GetPersona
$LN143@GetPersona:

; 4124 : 		{
; 4125 : 			iCount *= 200; //xml

	imul	esi, 200				; 000000c8H

; 4126 : 			iCount /= 100;
; 4127 : 		}
; 4128 : 	}

	jmp	$LN141@GetPersona
$LN20@GetPersona:

; 4129 : 
; 4130 : 	// ******************
; 4131 : 	// Global Quests
; 4132 : 	// ******************
; 4133 : 
; 4134 : 	// CONTEST CULTURE
; 4135 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN15@GetPersona

; 4136 : 	{
; 4137 : 		if(eTrait == MINOR_CIV_TRAIT_CULTURED)

	test	ecx, ecx
	jne	$LN1@GetPersona
$LN146@GetPersona:

; 4138 : 		{
; 4139 : 			iCount *= 200; //antonjs: todo: XML

	imul	esi, 200				; 000000c8H
$LN145@GetPersona:

; 4140 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4141 : 		}
; 4142 : 	}

	jmp	$LN1@GetPersona
$LN15@GetPersona:

; 4143 : 	// CONTEST FAITH
; 4144 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN12@GetPersona

; 4145 : 	{
; 4146 : 		if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)
; 4147 : 		{
; 4148 : 			iCount *= 200; //antonjs: todo: XML
; 4149 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	cmp	ecx, 4

; 4150 : 		}
; 4151 : 		else

	je	$LN144@GetPersona

; 4152 : 		{
; 4153 : 			iCount *= 50; //antonjs: todo: XML

	imul	esi, 50					; 00000032H

; 4154 : 			iCount /= 100;

	imul	esi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4155 : 		}

	jmp	SHORT $LN1@GetPersona
$LN12@GetPersona:

; 4156 : 	}
; 4157 : 	// CONTEST TECHS
; 4158 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN8@GetPersona

; 4159 : 	{
; 4160 : 		if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)

	cmp	ecx, 4
	jne	SHORT $LN1@GetPersona

; 4161 : 		{
; 4162 : 			iCount += 50; //antonjs: todo: XML

	lea	ecx, DWORD PTR [esi+50]

; 4163 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 4164 : 		}
; 4165 : 	}

	jmp	SHORT $LN140@GetPersona
$LN8@GetPersona:

; 4166 : 
; 4167 : 	// KILL A CAMP
; 4168 : 	else if(eQuest == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	eax, 1
	jne	SHORT $LN5@GetPersona

; 4169 : 	{
; 4170 : 		iCount *= 300;

	imul	esi, 300				; 0000012cH

; 4171 : 		iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax

; 4172 : 
; 4173 : 		if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)					// Militaristic

	cmp	ecx, 1
	jne	SHORT $LN1@GetPersona

; 4174 : 		{
; 4175 : 			iCount *= /*300*/ GC.getMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3344
	imul	ecx, esi

; 4176 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx

; 4177 : 		}
; 4178 : 	}

	jmp	SHORT $LN1@GetPersona
$LN5@GetPersona:

; 4179 : 
; 4180 : 	// Invest
; 4181 : 	else if(eQuest == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN1@GetPersona

; 4182 : 	{
; 4183 : 		if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	ecx, 3
	jne	SHORT $LN1@GetPersona

; 4184 : 		{
; 4185 : 			iCount *= 150; //antonjs: todo: XML

	imul	esi, 150				; 00000096H
$LN141@GetPersona:

; 4186 : 			iCount /= 100;

	mov	eax, 1374389535				; 51eb851fH
$LN142@GetPersona:
	imul	esi
$LN140@GetPersona:
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN1@GetPersona:

; 4187 : 		}
; 4188 : 	}
; 4189 : 
; 4190 : 	return iCount / 10;

	mov	eax, 1717986919				; 66666667H
	imul	esi
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	edi
	add	eax, edx
	pop	esi

; 4191 : }

	ret	4
?GetPersonalityQuestBias@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::GetPersonalityQuestBias
_TEXT	ENDS
PUBLIC	?GetContestValueForLeader@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetContestValueForLeader
; Function compile flags: /Ogtpy
;	COMDAT ?GetContestValueForLeader@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?GetContestValueForLeader@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::GetContestValueForLeader, COMDAT
; _this$ = ecx

; 4583 : {

	push	ebx
	mov	ebx, DWORD PTR [ecx+3328]
	push	ebp

; 4584 : 	PlayerTypes eParticipant;
; 4585 : 	for (int iMajor = 0; iMajor < MAX_MAJOR_CIVS; iMajor++)

	mov	ebp, DWORD PTR _eType$[esp+4]
	push	esi
	push	edi
	xor	esi, esi
	mov	edi, ebx
$LL41@GetContest@3:
	mov	edx, DWORD PTR [edi+4]

; 4586 : 	{
; 4587 : 		eParticipant = (PlayerTypes) iMajor;
; 4588 : 		for (uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[eParticipant].size(); iQuestLoop++)

	xor	eax, eax
	test	edx, edx
	jbe	SHORT $LN6@GetContest@3
	mov	ecx, DWORD PTR [edi]
	add	ecx, 8
$LL4@GetContest@3:

; 4589 : 		{
; 4590 : 			if (m_QuestsGiven[eParticipant][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [ecx], ebp
	je	SHORT $LN37@GetContest@3
	inc	eax
	add	ecx, 28					; 0000001cH
	cmp	eax, edx
	jb	SHORT $LL4@GetContest@3
$LN6@GetContest@3:

; 4584 : 	PlayerTypes eParticipant;
; 4585 : 	for (int iMajor = 0; iMajor < MAX_MAJOR_CIVS; iMajor++)

	inc	esi
	add	edi, 156				; 0000009cH
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL41@GetContest@3
	pop	edi
	pop	esi
	pop	ebp

; 4593 : 			}
; 4594 : 		}
; 4595 : 	}
; 4596 : 
; 4597 : 	return -1;

	or	eax, -1
	pop	ebx

; 4598 : }

	ret	4
$LN37@GetContest@3:

; 4591 : 			{
; 4592 : 				return m_QuestsGiven[eParticipant][iQuestLoop].GetContestValueForLeader();

	imul	esi, 156				; 0000009cH
	mov	edx, DWORD PTR [esi+ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx+ecx*4+8]
	lea	ebx, DWORD PTR [edx+ecx*4]
	or	edi, -1
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN28@GetContest@3
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN28@GetContest@3
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN25@GetContest@3
$LN28@GetContest@3:
	xor	esi, esi
	npad	1
$LL27@GetContest@3:
	push	esi
	mov	ecx, ebx
	call	?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z ; CvMinorCivQuest::GetContestValueForPlayer
	cmp	eax, edi
	jle	SHORT $LN26@GetContest@3
	mov	edi, eax
$LN26@GetContest@3:
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL27@GetContest@3
$LN25@GetContest@3:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4598 : }

	ret	4
?GetContestValueForLeader@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::GetContestValueForLeader
_TEXT	ENDS
PUBLIC	?GetContestValueForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetContestValueForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetContestValueForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
?GetContestValueForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::GetContestValueForPlayer, COMDAT
; _this$ = ecx

; 4601 : {

	push	esi

; 4602 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4603 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4604 : #ifdef AUI_WARNING_FIXES
; 4605 : 	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return -1;
; 4606 : #else
; 4607 : 	if (ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	esi, DWORD PTR _ePlayer$[esp]

; 4608 : #endif
; 4609 : 
; 4610 : 	for (uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	xor	eax, eax
	cmp	esi, 21					; 00000015H
	ja	SHORT $LN7@GetContest@4
	mov	ecx, DWORD PTR [ecx+3328]
	mov	edx, esi
	imul	edx, 156				; 0000009cH
	add	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	ebx
	push	edi
	test	ecx, ecx
	jbe	SHORT $LN2@GetContest@4
	mov	edi, DWORD PTR [edx]
	mov	ebx, DWORD PTR _eType$[esp+8]
	lea	edx, DWORD PTR [edi+8]
	npad	2
$LL4@GetContest@4:

; 4611 : 	{
; 4612 : 		if (m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN24@GetContest@4
	inc	eax
	add	edx, 28					; 0000001cH
	cmp	eax, ecx
	jb	SHORT $LL4@GetContest@4
$LN2@GetContest@4:
	pop	edi

; 4615 : 		}
; 4616 : 	}
; 4617 : 
; 4618 : 	return -1;

	or	eax, -1
	pop	ebx
$LN7@GetContest@4:
	pop	esi

; 4619 : }

	ret	8
$LN24@GetContest@4:

; 4613 : 		{
; 4614 : 			return m_QuestsGiven[ePlayer][iQuestLoop].GetContestValueForPlayer(ePlayer);

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	ecx, DWORD PTR [edi+edx*4]
	push	esi
	call	?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z ; CvMinorCivQuest::GetContestValueForPlayer
	pop	edi
	pop	ebx
	pop	esi

; 4619 : }

	ret	8
?GetContestValueForPlayer@CvMinorCivAI@@QAEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::GetContestValueForPlayer
_TEXT	ENDS
PUBLIC	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest
; Function compile flags: /Ogtpy
;	COMDAT ?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ PROC ; CvMinorCivAI::GetMostRecentBullyForQuest, COMDAT
; _this$ = ecx

; 5059 : {

	push	ebx

; 5060 : 	PlayerTypes eBully = NO_PLAYER;

	mov	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	or	eax, -1
	push	esi

; 5061 : 	int iTurn = -1;

	or	esi, eax

; 5062 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edx, edx
	add	ecx, 2820				; 00000b04H
	push	edi
	add	ebx, 65492				; 0000ffd4H
	npad	4
$LL5@GetMostRec:

; 5063 : 	{
; 5064 : 		// Bully must still be alive
; 5065 : 		if(!GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive())

	cmp	BYTE PTR [ebx-63236], 0
	je	SHORT $LN4@GetMostRec

; 5066 : 			continue;
; 5067 : 
; 5068 : 		if(m_aiTurnLastBullied[iPlayerLoop] > iTurn)

	mov	edi, DWORD PTR [ecx-4]
	cmp	edi, esi
	jle	SHORT $LN4@GetMostRec

; 5069 : 		{
; 5070 : 			iTurn = m_aiTurnLastBullied[iPlayerLoop];

	mov	esi, edi

; 5071 : 			eBully = (PlayerTypes)iPlayerLoop;

	mov	eax, edx
$LN4@GetMostRec:

; 5063 : 	{
; 5064 : 		// Bully must still be alive
; 5065 : 		if(!GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive())

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN17@GetMostRec

; 5066 : 			continue;
; 5067 : 
; 5068 : 		if(m_aiTurnLastBullied[iPlayerLoop] > iTurn)

	mov	edi, DWORD PTR [ecx]
	cmp	edi, esi
	jle	SHORT $LN17@GetMostRec

; 5069 : 		{
; 5070 : 			iTurn = m_aiTurnLastBullied[iPlayerLoop];

	mov	esi, edi

; 5071 : 			eBully = (PlayerTypes)iPlayerLoop;

	lea	eax, DWORD PTR [edx+1]
$LN17@GetMostRec:
	add	edx, 2
	add	ecx, 8
	add	ebx, 126472				; 0001ee08H
	cmp	edx, 22					; 00000016H
	jl	SHORT $LL5@GetMostRec
	pop	edi
	pop	esi
	pop	ebx

; 5072 : 		}
; 5073 : 	}
; 5074 : 
; 5075 : 	return eBully;
; 5076 : }

	ret	0
?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ENDP ; CvMinorCivAI::GetMostRecentBullyForQuest
_TEXT	ENDS
PUBLIC	?IsWantsMinorDead@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsWantsMinorDead
; Function compile flags: /Ogtpy
;	COMDAT ?IsWantsMinorDead@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMinor$ = 8						; size = 4
?IsWantsMinorDead@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsWantsMinorDead, COMDAT
; _this$ = ecx

; 5080 : {

	push	ebx
	push	ebp

; 5081 : 	PlayerTypes eMajor;
; 5082 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	mov	ebx, ecx
	add	ebp, 2256				; 000008d0H
$LL42@IsWantsMin:

; 5083 : 	{
; 5084 : 		eMajor = (PlayerTypes) iMajorLoop;
; 5085 : 
; 5086 : 		// Major must be alive
; 5087 : 		if(!GET_PLAYER(eMajor).isAlive())

	cmp	BYTE PTR [ebp], 0
	je	SHORT $LN5@IsWantsMin

; 5088 : 			continue;
; 5089 : 
; 5090 : 		// Has the quest?
; 5091 : 		if(!IsActiveQuestForPlayer(eMajor, MINOR_CIV_QUEST_KILL_CITY_STATE))

	test	edi, edi
	jl	SHORT $LN5@IsWantsMin
	cmp	edi, 22					; 00000016H
	jge	SHORT $LN5@IsWantsMin
	mov	eax, DWORD PTR [ebx+3328]
	mov	edx, DWORD PTR [eax+esi+4]
	add	eax, esi
	xor	ecx, ecx
	test	edx, edx
	jbe	SHORT $LN5@IsWantsMin
	mov	eax, DWORD PTR [eax]
	add	eax, 8
	npad	4
$LL18@IsWantsMin:
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN40@IsWantsMin
	inc	ecx
	add	eax, 28					; 0000001cH
	cmp	ecx, edx
	jb	SHORT $LL18@IsWantsMin
	jmp	SHORT $LN5@IsWantsMin
$LN40@IsWantsMin:

; 5092 : 			continue;
; 5093 : 
; 5094 : 		// Right minor?
; 5095 : 		if(GetQuestData1(eMajor, MINOR_CIV_QUEST_KILL_CITY_STATE) != eMinor)

	push	5
	push	edi
	mov	ecx, ebx
	call	?GetQuestData1@CvMinorCivAI@@QBEHW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetQuestData1
	cmp	eax, DWORD PTR _eMinor$[esp+12]
	je	SHORT $LN1@IsWantsMin
$LN5@IsWantsMin:

; 5081 : 	PlayerTypes eMajor;
; 5082 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	add	esi, 156				; 0000009cH
	inc	edi
	add	ebp, 63236				; 0000f704H
	cmp	esi, 3432				; 00000d68H
	jl	SHORT $LL42@IsWantsMin
	pop	edi
	pop	esi
	pop	ebp

; 5099 : 	}
; 5100 : 
; 5101 : 	return false;

	xor	al, al
	pop	ebx

; 5102 : }

	ret	4
$LN1@IsWantsMin:
	pop	edi
	pop	esi
	pop	ebp

; 5096 : 			continue;
; 5097 : 
; 5098 : 		return true;

	mov	al, 1
	pop	ebx

; 5102 : }

	ret	4
?IsWantsMinorDead@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsWantsMinorDead
_TEXT	ENDS
PUBLIC	?IsGoodTimeForNaturalWonderQuest@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsGoodTimeForNaturalWonderQuest
EXTRN	?GetNumNaturalWondersDiscoveredInArea@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetNumNaturalWondersDiscoveredInArea
EXTRN	?GetNumNaturalWonders@CvArea@@QBEHXZ:PROC	; CvArea::GetNumNaturalWonders
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ:PROC ; CvTeam::GetNumNaturalWondersDiscovered
EXTRN	?GetNumNaturalWonders@CvMap@@QBEHXZ:PROC	; CvMap::GetNumNaturalWonders
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoodTimeForNaturalWonderQuest@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsGoodTimeForNaturalWonderQuest@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsGoodTimeForNaturalWonderQuest, COMDAT
; _this$ = ecx

; 5163 : {

	push	esi

; 5164 : 	CvPlayer* pPlayer = &GET_PLAYER(ePlayer);

	mov	esi, DWORD PTR _ePlayer$[esp]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 5165 : 	CvTeam* pTeam = &GET_TEAM(pPlayer->getTeam());

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN12@IsGoodTime
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN13@IsGoodTime
$LN12@IsGoodTime:
	or	eax, -1
$LN13@IsGoodTime:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 5166 : 
; 5167 : 	// No starting plot?
; 5168 : 	if(pPlayer->getStartingPlot() == NULL)

	mov	ecx, esi
	mov	edi, eax
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	jne	SHORT $LN3@IsGoodTime
$LN25@IsGoodTime:
	pop	edi

; 5169 : 	{
; 5170 : 		return false;

	xor	al, al
	pop	esi

; 5182 : 	{
; 5183 : 		return false;
; 5184 : 	}
; 5185 : 
; 5186 : 	return true;
; 5187 : }

	ret	4
$LN3@IsGoodTime:

; 5171 : 	}
; 5172 : 
; 5173 : 	// Player's already found them all
; 5174 : 	if(pTeam->GetNumNaturalWondersDiscovered() == GC.getMap().GetNumNaturalWonders())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	call	?GetNumNaturalWonders@CvMap@@QBEHXZ	; CvMap::GetNumNaturalWonders
	mov	ecx, edi
	mov	ebx, eax
	call	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ; CvTeam::GetNumNaturalWondersDiscovered
	cmp	eax, ebx
	pop	ebx

; 5175 : 	{
; 5176 : 		return false;

	je	SHORT $LN25@IsGoodTime

; 5177 : 	}
; 5178 : 
; 5179 : 	// Player hasn't yet found all the NWs in his area
; 5180 : 	int iNumNaturalWondersInStartingArea = GC.getMap().getArea(pPlayer->getStartingPlot()->getArea())->GetNumNaturalWonders();

	mov	ecx, esi
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	eax, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?GetNumNaturalWonders@CvArea@@QBEHXZ	; CvArea::GetNumNaturalWonders

; 5181 : 	if(pPlayer->GetNumNaturalWondersDiscoveredInArea() < iNumNaturalWondersInStartingArea)

	mov	ecx, esi
	mov	edi, eax
	call	?GetNumNaturalWondersDiscoveredInArea@CvPlayer@@QBEHXZ ; CvPlayer::GetNumNaturalWondersDiscoveredInArea
	cmp	eax, edi
	pop	edi
	setge	al
	pop	esi

; 5182 : 	{
; 5183 : 		return false;
; 5184 : 	}
; 5185 : 
; 5186 : 	return true;
; 5187 : }

	ret	4
?IsGoodTimeForNaturalWonderQuest@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsGoodTimeForNaturalWonderQuest
_TEXT	ENDS
PUBLIC	?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipAnchorWithMajor
EXTRN	?GetCityStateMinimumInfluence@CvPlayerReligions@@QBEHW4ReligionTypes@@@Z:PROC ; CvPlayerReligions::GetCityStateMinimumInfluence
EXTRN	?GetMinorFriendshipAnchorMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetMinorFriendshipAnchorMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetFriendshipAnchorWithMajor, COMDAT
; _this$ = ecx

; 5509 : 	int iAnchor = GC.getMINOR_FRIENDSHIP_ANCHOR_DEFAULT();
; 5510 : 
; 5511 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 5512 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 5513 : 	if (eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return iAnchor;

	mov	eax, DWORD PTR _eMajor$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7340
	push	edi
	mov	edi, ecx
	cmp	eax, 21					; 00000015H
	ja	$LN7@GetFriends@2
	push	esi

; 5514 : 
; 5515 : 	CvPlayer* pMajor = &GET_PLAYER(eMajor);

	mov	esi, eax
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5516 : 	CvAssertMsg(pMajor, "MINOR CIV AI: pMajor not expected to be NULL.  Please send Anton your save file and version.");
; 5517 : 	if (!pMajor) return iAnchor;

	je	SHORT $LN39@GetFriends@2

; 5518 : 
; 5519 : 	// Pledge to Protect
; 5520 : 	if (IsProtectedByMajor(eMajor))

	mov	al, BYTE PTR [eax+edi+3146]
	test	al, al
	je	SHORT $LN5@GetFriends@2

; 5521 : 	{
; 5522 : 		iAnchor += GC.getMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7344
$LN5@GetFriends@2:

; 5523 : 	}
; 5524 : 
; 5525 : 	// Wary Of?
; 5526 : 	if (IsWaryOfTeam(pMajor->getTeam()))

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN4@GetFriends@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN4@GetFriends@2
	cmp	BYTE PTR [eax+edi+3248], 0
	je	SHORT $LN4@GetFriends@2

; 5527 : 	{
; 5528 : 		iAnchor += GC.getMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7348
$LN4@GetFriends@2:

; 5529 : 	}
; 5530 : 
; 5531 : 	// Social Policies
; 5532 : 	iAnchor += pMajor->GetMinorFriendshipAnchorMod();

	mov	ecx, esi
	call	?GetMinorFriendshipAnchorMod@CvPlayer@@QBEHXZ ; CvPlayer::GetMinorFriendshipAnchorMod

; 5533 : 
; 5534 : 	// Religion
; 5535 : 	CvPlayerReligions* pMajorReligions = pMajor->GetReligions();

	mov	ecx, esi
	add	ebx, eax
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	esi, eax

; 5536 : 	CvAssertMsg(pMajorReligions, "MINOR CIV AI: pMajorReligions not expected to be NULL.  Please send Anton your save file and version.");
; 5537 : 	if (!pMajorReligions) return iAnchor;

	test	esi, esi
	je	SHORT $LN39@GetFriends@2

; 5538 : 	CvCity* pMinorCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [edi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 5539 : 	if (!pMinorCapital) return iAnchor; // Happens when city was just captured, after buyout, etc., so just return the anchor value we have

	test	eax, eax
	je	SHORT $LN39@GetFriends@2

; 5540 : 	CvCityReligions* pMinorCapitalReligions = pMinorCapital->GetCityReligions();

	mov	ecx, eax
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions

; 5541 : 	CvAssertMsg(pMinorCapitalReligions, "MINOR CIV AI: pMinorCapitalReligions not expected to be NULL.  Please send Anton your save file and version.");
; 5542 : 	if (!pMinorCapitalReligions) return iAnchor;

	test	eax, eax
	jne	SHORT $LN1@GetFriends@2
$LN39@GetFriends@2:
	pop	esi
	pop	edi
	mov	eax, ebx
	pop	ebx

; 5544 : 
; 5545 : 	return iAnchor;
; 5546 : }

	ret	4
$LN1@GetFriends@2:

; 5543 : 	iAnchor += pMajorReligions->GetCityStateMinimumInfluence(pMinorCapitalReligions->GetReligiousMajority());

	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority
	push	eax
	mov	ecx, esi
	call	?GetCityStateMinimumInfluence@CvPlayerReligions@@QBEHW4ReligionTypes@@@Z ; CvPlayerReligions::GetCityStateMinimumInfluence
	pop	esi
	pop	edi
	add	eax, ebx
	pop	ebx

; 5544 : 
; 5545 : 	return iAnchor;
; 5546 : }

	ret	4
$LN7@GetFriends@2:
	pop	edi

; 5509 : 	int iAnchor = GC.getMINOR_FRIENDSHIP_ANCHOR_DEFAULT();
; 5510 : 
; 5511 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 5512 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 5513 : 	if (eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return iAnchor;

	mov	eax, ebx
	pop	ebx

; 5544 : 
; 5545 : 	return iAnchor;
; 5546 : }

	ret	4
?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetFriendshipAnchorWithMajor
_TEXT	ENDS
PUBLIC	?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z	; CvMinorCivAI::SetAlly
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::declareWar
EXTRN	?AlliedWithCityState@CvPlayerAchievements@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlayerAchievements::AlliedWithCityState
EXTRN	?DoApplyNewAllyGPBonus@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoApplyNewAllyGPBonus
EXTRN	?DoSeedGreatPeopleSpawnCounter@CvPlayer@@QAEXXZ:PROC ; CvPlayer::DoSeedGreatPeopleSpawnCounter
EXTRN	?GetGreatPeopleSpawnCounter@CvPlayer@@QAEHXZ:PROC ; CvPlayer::GetGreatPeopleSpawnCounter
EXTRN	?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ:PROC ; CvPolicyEntry::IsMinorGreatPeopleAllies
EXTRN	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBlocked
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
EXTRN	?updateDeferredFog@CvMap@@QAEXXZ:PROC		; CvMap::updateDeferredFog
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z:PROC ; CvPlot::changeAdjacentSight
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
__ehfuncinfo$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv337 = -32						; size = 4
_args$226185 = -32					; size = 4
tv154 = -28						; size = 4
_iNumPlots$ = -28					; size = 4
_iPlotVisRange$ = -24					; size = 4
_eOldAlly$ = -20					; size = 4
_kNewAllyTeam$226173 = -16				; size = 4
_theMap$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_bResult$226186 = 8					; size = 1
_eNewAlly$ = 8						; size = 4
?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC	; CvMinorCivAI::SetAlly, COMDAT
; _this$ = ecx

; 5685 : {

	push	-1
	push	__ehhandler$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H

; 5686 : 	CvAssertMsg(eNewAlly >= NO_PLAYER, "ePlayer is expected to be non-negative (invalid Index)");
; 5687 : 	CvAssertMsg(eNewAlly < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5688 : 
; 5689 : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 5690 : #ifdef AUI_WARNING_FIXES
; 5691 : 	uint iNumPlots = GC.getMap().numPlots();
; 5692 : #else
; 5693 : 	int iNumPlots = GC.getMap().numPlots();
; 5694 : #endif
; 5695 : 
; 5696 : 	PlayerTypes eOldAlly = GetAlly();
; 5697 : 
; 5698 : 	int iPlotVisRange = GC.getPLOT_VISIBILITY_RANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	push	edi
	mov	edi, DWORD PTR [ebp+2012]
	mov	ebx, eax
	mov	eax, DWORD PTR [eax+4028]
	mov	DWORD PTR _theMap$[esp+48], ebx
	mov	DWORD PTR _iNumPlots$[esp+48], eax
	mov	DWORD PTR _eOldAlly$[esp+48], edi
	mov	DWORD PTR _iPlotVisRange$[esp+48], ecx

; 5699 : 
; 5700 : 	if(eOldAlly != NO_PLAYER)

	cmp	edi, -1
	je	$LN134@SetAlly

; 5701 : 	{
; 5702 : #ifdef AUI_WARNING_FIXES
; 5703 : 		for (uint iI = 0; iI < iNumPlots; iI++)
; 5704 : #else
; 5705 : 		for(int iI = 0; iI < iNumPlots; iI++)

	test	eax, eax
	jle	SHORT $LN23@SetAlly
	xor	esi, esi
	mov	DWORD PTR tv337[esp+48], eax
	npad	6
$LL25@SetAlly:

; 5706 : #endif
; 5707 : 		{
; 5708 : 			CvPlot* pPlot = theMap.plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR [ebx+4068]

; 5709 : 			if(pPlot->getOwner() == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	movsx	edx, BYTE PTR [ecx+esi+4]
	add	ecx, esi
	cmp	edx, eax
	jne	SHORT $LN24@SetAlly

; 5710 : 			{
; 5711 : 				pPlot->changeAdjacentSight(GET_PLAYER(eOldAlly).getTeam(), iPlotVisRange, false, NO_INVISIBLE, NO_DIRECTION, false);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, edi
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@SetAlly
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN55@SetAlly
$LN54@SetAlly:
	or	eax, -1
$LN55@SetAlly:
	mov	edx, DWORD PTR _iPlotVisRange$[esp+48]
	push	0
	push	-1
	push	-1
	push	0
	push	edx
	push	eax
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN24@SetAlly:
	add	esi, 484				; 000001e4H
	sub	DWORD PTR tv337[esp+48], 1
	jne	SHORT $LL25@SetAlly
$LN23@SetAlly:

; 5712 : 			}
; 5713 : 		}
; 5714 : 		if(eOldAlly == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	SHORT $LN134@SetAlly

; 5715 : 		{
; 5716 : 			theMap.updateDeferredFog();

	mov	ecx, ebx
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN134@SetAlly:

; 5717 : 		}
; 5718 : 	}
; 5719 : 
; 5720 : 	m_eAlly = eNewAlly;

	mov	ebx, DWORD PTR _eNewAlly$[esp+44]
	mov	DWORD PTR [ebp+2012], ebx

; 5721 : 	m_iTurnAllied = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [ebp+2016], eax

; 5722 : 
; 5723 : 	// Seed the GP counter?
; 5724 : 	if(eNewAlly != NO_PLAYER)

	cmp	ebx, -1
	je	$LN20@SetAlly

; 5725 : 	{
; 5726 : 		CvPlayerAI& kNewAlly = GET_PLAYER(eNewAlly);

	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5727 : 
; 5728 : 		// share the visibility with my ally (and his team-mates)
; 5729 : #ifdef AUI_WARNING_FIXES
; 5730 : 		for (uint iI = 0; iI < iNumPlots; iI++)
; 5731 : #else
; 5732 : 		for(int iI = 0; iI < iNumPlots; iI++)

	cmp	DWORD PTR _iNumPlots$[esp+48], 0
	jle	SHORT $LN17@SetAlly
	mov	eax, DWORD PTR _iNumPlots$[esp+48]
	xor	ebx, ebx
	mov	DWORD PTR tv154[esp+48], eax
	npad	8
$LL19@SetAlly:

; 5733 : #endif
; 5734 : 		{
; 5735 : 			CvPlot* pPlot = theMap.plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR _theMap$[esp+48]
	mov	esi, DWORD PTR [ecx+4068]

; 5736 : 			if(pPlot->getOwner() == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp]
	movsx	ecx, BYTE PTR [esi+ebx+4]
	mov	eax, DWORD PTR [edx+44]
	add	esi, ebx
	cmp	ecx, eax
	jne	SHORT $LN18@SetAlly

; 5737 : 			{
; 5738 : 				pPlot->changeAdjacentSight(kNewAlly.getTeam(), iPlotVisRange, true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	edx, DWORD PTR _iPlotVisRange$[esp+48]
	push	0
	push	-1
	push	-1
	push	1
	push	edx
	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN18@SetAlly:
	add	ebx, 484				; 000001e4H
	sub	DWORD PTR tv154[esp+48], 1
	jne	SHORT $LL19@SetAlly

; 5727 : 
; 5728 : 		// share the visibility with my ally (and his team-mates)
; 5729 : #ifdef AUI_WARNING_FIXES
; 5730 : 		for (uint iI = 0; iI < iNumPlots; iI++)
; 5731 : #else
; 5732 : 		for(int iI = 0; iI < iNumPlots; iI++)

	mov	ebx, DWORD PTR _eNewAlly$[esp+44]
$LN17@SetAlly:

; 5739 : 			}
; 5740 : 		}
; 5741 : 
; 5742 : #ifdef AUI_WARNING_FIXES
; 5743 : 		for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 5744 : #else
; 5745 : 		for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	test	eax, eax
	jle	SHORT $LN13@SetAlly
	npad	8
$LL135@SetAlly:

; 5746 : #endif
; 5747 : 		{
; 5748 : 			const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
; 5749 : 			CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	ebx, eax

; 5750 : 			if(pkPolicyInfo)

	test	ebx, ebx
	je	SHORT $LN14@SetAlly

; 5751 : 			{
; 5752 : 				if(kNewAlly.GetPlayerPolicies()->HasPolicy(eLoopPolicy) && !kNewAlly.GetPlayerPolicies()->IsPolicyBlocked(eLoopPolicy))

	push	esi
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	SHORT $LN14@SetAlly
	push	esi
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	test	al, al
	jne	SHORT $LN14@SetAlly

; 5753 : 				{
; 5754 : 					// This is the policy we want!
; 5755 : 					if(pkPolicyInfo->IsMinorGreatPeopleAllies()) // NQMP GJS - Patronage Finisher reference

	mov	ecx, ebx
	call	?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsMinorGreatPeopleAllies
	test	al, al
	je	SHORT $LN14@SetAlly

; 5756 : 					{
; 5757 : 						if(kNewAlly.GetGreatPeopleSpawnCounter() <= 0)

	mov	ecx, edi
	call	?GetGreatPeopleSpawnCounter@CvPlayer@@QAEHXZ ; CvPlayer::GetGreatPeopleSpawnCounter

; 5758 : 							kNewAlly.DoSeedGreatPeopleSpawnCounter();

	mov	ecx, edi
	test	eax, eax
	jg	SHORT $LN9@SetAlly
	call	?DoSeedGreatPeopleSpawnCounter@CvPlayer@@QAEXXZ ; CvPlayer::DoSeedGreatPeopleSpawnCounter

; 5759 : 						else

	jmp	SHORT $LN14@SetAlly
$LN9@SetAlly:

; 5760 : 							kNewAlly.DoApplyNewAllyGPBonus();

	call	?DoApplyNewAllyGPBonus@CvPlayer@@QAEXXZ	; CvPlayer::DoApplyNewAllyGPBonus
$LN14@SetAlly:

; 5739 : 			}
; 5740 : 		}
; 5741 : 
; 5742 : #ifdef AUI_WARNING_FIXES
; 5743 : 		for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 5744 : #else
; 5745 : 		for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	esi, eax
	jl	SHORT $LL135@SetAlly
	mov	ebx, DWORD PTR _eNewAlly$[esp+44]
$LN13@SetAlly:

; 5761 : 					}
; 5762 : 				}
; 5763 : 			}
; 5764 : 		}
; 5765 : 
; 5766 : 		//Achievement Test
; 5767 : 		kNewAlly.GetPlayerAchievements().AlliedWithCityState(GetPlayer()->GetID());;

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	lea	ecx, DWORD PTR [edi+63156]
	call	?AlliedWithCityState@CvPlayerAchievements@@QAEXW4PlayerTypes@@@Z ; CvPlayerAchievements::AlliedWithCityState
	mov	edi, DWORD PTR _eOldAlly$[esp+48]
$LN20@SetAlly:

; 5768 : 	}
; 5769 : 
; 5770 : 	// Alter who gets this guy's resources
; 5771 : 	DoUpdateAlliesResourceBonus(eNewAlly, eOldAlly);

	push	edi
	push	ebx
	mov	ecx, ebp
	call	?DoUpdateAlliesResourceBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z ; CvMinorCivAI::DoUpdateAlliesResourceBonus

; 5772 : 
; 5773 : 	// Declare war on Ally's enemies
; 5774 : 	if(eNewAlly != NO_PLAYER)

	cmp	ebx, -1
	je	$LN4@SetAlly

; 5775 : 	{
; 5776 : 		CvPlayerAI& kNewAlly = GET_PLAYER(eNewAlly);
; 5777 : 		CvTeam& kNewAllyTeam = GET_TEAM(kNewAlly.getTeam());

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, ebx
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN87@SetAlly
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN88@SetAlly
$LN87@SetAlly:
	or	eax, -1
$LN88@SetAlly:
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	eax, 2984				; 00000ba8H
	add	eax, edx
	mov	DWORD PTR _kNewAllyTeam$226173[esp+48], eax

; 5778 : 		CvTeam& kOurTeam = GET_TEAM(GetPlayer()->getTeam());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN100@SetAlly
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	imul	eax, 2984				; 00000ba8H
	add	eax, edx

; 5779 : 
; 5780 : 		TeamTypes eLoopTeam;
; 5781 : 		for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edi, edi
	mov	ebx, eax
	xor	esi, esi
	jmp	SHORT $LN6@SetAlly

; 5778 : 		CvTeam& kOurTeam = GET_TEAM(GetPlayer()->getTeam());

$LN100@SetAlly:
	or	eax, -1
	imul	eax, 2984				; 00000ba8H
	add	eax, edx

; 5779 : 
; 5780 : 		TeamTypes eLoopTeam;
; 5781 : 		for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edi, edi
	mov	ebx, eax
	xor	esi, esi
	jmp	SHORT $LN6@SetAlly
$LL136@SetAlly:

; 5778 : 		CvTeam& kOurTeam = GET_TEAM(GetPlayer()->getTeam());

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
$LN6@SetAlly:

; 5782 : 		{
; 5783 : 			eLoopTeam = (TeamTypes) iTeamLoop;
; 5784 : 
; 5785 : 			if(!GET_TEAM(eLoopTeam).isAlive())

	cmp	DWORD PTR [esi+edx+12], 0
	jle	SHORT $LN5@SetAlly

; 5786 : 				continue;
; 5787 : 
; 5788 : 			if(kNewAllyTeam.isAtWar(eLoopTeam))

	mov	ecx, DWORD PTR _kNewAllyTeam$226173[esp+48]
	push	edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN5@SetAlly

; 5789 : 				kOurTeam.declareWar(eLoopTeam);

	push	0
	push	edi
	mov	ecx, ebx
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar
$LN5@SetAlly:
	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL136@SetAlly
	mov	ebx, DWORD PTR _eNewAlly$[esp+44]
	mov	edi, DWORD PTR _eOldAlly$[esp+48]
$LN4@SetAlly:

; 5790 : 		}
; 5791 : 	}
; 5792 : 
; 5793 : 	DoTestEndWarsVSMinors(eOldAlly, eNewAlly);

	push	ebx
	push	edi
	mov	ecx, ebp
	call	?DoTestEndWarsVSMinors@CvMinorCivAI@@QAEXW4PlayerTypes@@0@Z ; CvMinorCivAI::DoTestEndWarsVSMinors

; 5794 : 
; 5795 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	esi, eax

; 5796 : 	if(pkScriptSystem)

	test	esi, esi
	je	SHORT $LN1@SetAlly

; 5797 : 	{
; 5798 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226185[esp+48]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 5799 : 		args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$226185[esp+48]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	eax

; 5800 : 		args->Push(eOldAlly);

	mov	ecx, DWORD PTR _args$226185[esp+48]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 5801 : 		args->Push(eNewAlly);

	mov	ecx, DWORD PTR _args$226185[esp+48]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 5802 : 
; 5803 : 		bool bResult;
; 5804 : 		LuaSupport::CallHook(pkScriptSystem, "SetAlly", args.get(), bResult);

	mov	edx, DWORD PTR _args$226185[esp+48]
	lea	ecx, DWORD PTR _bResult$226186[esp+44]
	push	ecx
	push	edx
	push	OFFSET $SG226187
	push	esi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 5805 : 	}

	lea	ecx, DWORD PTR _args$226185[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN1@SetAlly:

; 5806 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$226185[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP	; CvMinorCivAI::SetAlly
PUBLIC	?IsFriendshipAboveFriendsThreshold@CvMinorCivAI@@QBE_NH@Z ; CvMinorCivAI::IsFriendshipAboveFriendsThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendshipAboveFriendsThreshold@CvMinorCivAI@@QBE_NH@Z
_TEXT	SEGMENT
_iFriendship$ = 8					; size = 4
?IsFriendshipAboveFriendsThreshold@CvMinorCivAI@@QBE_NH@Z PROC ; CvMinorCivAI::IsFriendshipAboveFriendsThreshold, COMDAT
; _this$ = ecx

; 6081 : 	int iFriendshipThresholdFriends = GetFriendsThreshold();
; 6082 : 
; 6083 : 	if(iFriendship >= iFriendshipThresholdFriends)

	mov	eax, DWORD PTR _iFriendship$[esp-4]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	setge	al

; 6084 : 	{
; 6085 : 		return true;
; 6086 : 	}
; 6087 : 
; 6088 : 	return false;
; 6089 : }

	ret	4
?IsFriendshipAboveFriendsThreshold@CvMinorCivAI@@QBE_NH@Z ENDP ; CvMinorCivAI::IsFriendshipAboveFriendsThreshold
_TEXT	ENDS
PUBLIC	?IsFriendshipAboveAlliesThreshold@CvMinorCivAI@@QBE_NH@Z ; CvMinorCivAI::IsFriendshipAboveAlliesThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendshipAboveAlliesThreshold@CvMinorCivAI@@QBE_NH@Z
_TEXT	SEGMENT
_iFriendship$ = 8					; size = 4
?IsFriendshipAboveAlliesThreshold@CvMinorCivAI@@QBE_NH@Z PROC ; CvMinorCivAI::IsFriendshipAboveAlliesThreshold, COMDAT
; _this$ = ecx

; 6101 : 	int iFriendshipThresholdAllies = GetAlliesThreshold();
; 6102 : 
; 6103 : 	if(iFriendship >= iFriendshipThresholdAllies)

	mov	eax, DWORD PTR _iFriendship$[esp-4]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840
	setge	al

; 6104 : 	{
; 6105 : 		return true;
; 6106 : 	}
; 6107 : 
; 6108 : 	return false;
; 6109 : }

	ret	4
?IsFriendshipAboveAlliesThreshold@CvMinorCivAI@@QBE_NH@Z ENDP ; CvMinorCivAI::IsFriendshipAboveAlliesThreshold
_TEXT	ENDS
PUBLIC	?GetScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetScienceFriendshipBonusTimes100
EXTRN	?GetScienceTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetScienceTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHXZ
_TEXT	SEGMENT
?GetScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHXZ PROC ; CvMinorCivAI::GetScienceFriendshipBonusTimes100, COMDAT
; _this$ = ecx

; 6859 : 	int iResult = GET_PLAYER(m_pPlayer->GetID()).GetScienceTimes100() * /*25*/ GC.getMINOR_CIV_SCIENCE_BONUS_MULTIPLIER();

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+44]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2860
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	mov	ecx, eax
	imul	ecx, esi

; 6860 : 	iResult /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 6861 : 
; 6862 : 	return iResult;
; 6863 : }

	ret	0
?GetScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHXZ ENDP ; CvMinorCivAI::GetScienceFriendshipBonusTimes100
_TEXT	ENDS
PUBLIC	?GetCurrentScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentScienceFriendshipBonusTimes100
EXTRN	?IsGetsScienceFromPlayer@CvPlayer@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlayer::IsGetsScienceFromPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentScienceFriendshipBonusTimes100, COMDAT
; _this$ = ecx

; 6867 : {

	push	esi
	mov	esi, ecx

; 6868 : 	if(GET_PLAYER(ePlayer).IsGetsScienceFromPlayer(GetPlayer()->GetID()))

	mov	ecx, DWORD PTR _ePlayer$[esp]
	mov	eax, DWORD PTR [esi]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+44]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?IsGetsScienceFromPlayer@CvPlayer@@QBE_NW4PlayerTypes@@@Z ; CvPlayer::IsGetsScienceFromPlayer
	test	al, al
	je	SHORT $LN1@GetCurrent

; 6869 : 		return GetScienceFriendshipBonusTimes100();

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+44]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2860
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 6872 : }

	ret	4
$LN1@GetCurrent:

; 6870 : 
; 6871 : 	return 0;

	xor	eax, eax
	pop	esi

; 6872 : }

	ret	4
?GetCurrentScienceFriendshipBonusTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentScienceFriendshipBonusTimes100
_TEXT	ENDS
PUBLIC	?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatFriendshipBonus
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ:PROC	; CvTeam::GetCurrentEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetCultureFlatFriendshipBonus, COMDAT
; _this$ = ecx

; 6876 : {

	push	esi

; 6877 : 	//antonjs: consider: here it was assumed that this CS is cultured type, which is nice for me prototyping, but later maybe add in a check for this
; 6878 : 	int iCultureBonus = 0;
; 6879 : 
; 6880 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp]

; 6881 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN5@GetCulture

; 6882 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR _ePlayer$[esp]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@GetCulture
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@GetCulture
$LN14@GetCulture:
	or	eax, -1
$LN15@GetCulture:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN5@GetCulture:
	push	edi

; 6883 : 
; 6884 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226689
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 6885 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226692
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 6886 : 
; 6887 : 	// Industrial era or Later
; 6888 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	pop	edi
	jl	SHORT $LN4@GetCulture

; 6895 : 	{
; 6896 : 		iCultureBonus += /*6*/ GC.getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL();
; 6897 : 	}
; 6898 : 
; 6899 : 	// Pre-Medieval
; 6900 : 	else
; 6901 : 	{
; 6902 : 		iCultureBonus += /*4*/ GC.getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT();
; 6903 : 	}
; 6904 : 
; 6905 : 	return iCultureBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2872
	pop	esi

; 6906 : }

	ret	8
$LN4@GetCulture:

; 6889 : 	{
; 6890 : 		iCultureBonus += /*10*/ GC.getFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL();
; 6891 : 	}
; 6892 : 
; 6893 : 	// Medieval era or later
; 6894 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, eax

; 6895 : 	{
; 6896 : 		iCultureBonus += /*6*/ GC.getFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL();
; 6897 : 	}
; 6898 : 
; 6899 : 	// Pre-Medieval
; 6900 : 	else
; 6901 : 	{
; 6902 : 		iCultureBonus += /*4*/ GC.getFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT();
; 6903 : 	}
; 6904 : 
; 6905 : 	return iCultureBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2868
	jge	SHORT $LN1@GetCulture
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2864
$LN1@GetCulture:
	pop	esi

; 6906 : }

	ret	8
?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetCultureFlatFriendshipBonus
_TEXT	ENDS
PUBLIC	?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatAlliesBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetCultureFlatAlliesBonus, COMDAT
; _this$ = ecx

; 6910 : {

	push	esi

; 6911 : 	//antonjs: consider: here it was assumed that this CS is cultured type, which is nice for me prototyping, but later maybe add in a check for this
; 6912 : 	int iCultureBonus = 0;
; 6913 : 
; 6914 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp]

; 6915 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN5@GetCulture@2

; 6916 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR _ePlayer$[esp]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@GetCulture@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@GetCulture@2
$LN14@GetCulture@2:
	or	eax, -1
$LN15@GetCulture@2:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN5@GetCulture@2:
	push	edi

; 6917 : 
; 6918 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226707
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 6919 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226710
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 6920 : 
; 6921 : 	// Industrial era or Later
; 6922 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	pop	edi
	jl	SHORT $LN4@GetCulture@2

; 6929 : 	{
; 6930 : 		iCultureBonus += /*6*/ GC.getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL();
; 6931 : 	}
; 6932 : 
; 6933 : 	// Pre-Medieval
; 6934 : 	else
; 6935 : 	{
; 6936 : 		iCultureBonus += /*4*/ GC.getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT();
; 6937 : 	}
; 6938 : 
; 6939 : 	return iCultureBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2884
	pop	esi

; 6940 : }

	ret	8
$LN4@GetCulture@2:

; 6923 : 	{
; 6924 : 		iCultureBonus += /*10*/ GC.getALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL();
; 6925 : 	}
; 6926 : 
; 6927 : 	// Medieval era or later
; 6928 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, eax

; 6929 : 	{
; 6930 : 		iCultureBonus += /*6*/ GC.getALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL();
; 6931 : 	}
; 6932 : 
; 6933 : 	// Pre-Medieval
; 6934 : 	else
; 6935 : 	{
; 6936 : 		iCultureBonus += /*4*/ GC.getALLIES_CULTURE_BONUS_AMOUNT_ANCIENT();
; 6937 : 	}
; 6938 : 
; 6939 : 	return iCultureBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2880
	jge	SHORT $LN1@GetCulture@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2876
$LN1@GetCulture@2:
	pop	esi

; 6940 : }

	ret	8
?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetCultureFlatAlliesBonus
_TEXT	ENDS
PUBLIC	?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatFriendshipBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetHappinessFlatFriendshipBonus, COMDAT
; _this$ = ecx

; 7044 : {

	push	esi

; 7045 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp]

; 7046 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN5@GetHappine

; 7047 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR _ePlayer$[esp]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@GetHappine
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@GetHappine
$LN14@GetHappine:
	or	eax, -1
$LN15@GetHappine:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN5@GetHappine:
	push	edi

; 7048 : 
; 7049 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226767
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7050 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226770
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7051 : 
; 7052 : 	// Industrial era or Later
; 7053 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	pop	edi
	jl	SHORT $LN4@GetHappine

; 7054 : 		return GC.getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2940
	pop	esi

; 7063 : }

	ret	8
$LN4@GetHappine:

; 7055 : 
; 7056 : 	// Medieval era or later
; 7057 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, eax

; 7058 : 		return GC.getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2936
	jge	SHORT $LN1@GetHappine

; 7059 : 
; 7060 : 	// Pre-Medieval
; 7061 : 	else
; 7062 : 		return GC.getFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2932
$LN1@GetHappine:
	pop	esi

; 7063 : }

	ret	8
?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetHappinessFlatFriendshipBonus
_TEXT	ENDS
PUBLIC	?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatAlliesBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetHappinessFlatAlliesBonus, COMDAT
; _this$ = ecx

; 7067 : {

	push	esi

; 7068 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp]

; 7069 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN5@GetHappine@2

; 7070 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR _ePlayer$[esp]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@GetHappine@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@GetHappine@2
$LN14@GetHappine@2:
	or	eax, -1
$LN15@GetHappine@2:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN5@GetHappine@2:
	push	edi

; 7071 : 
; 7072 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226784
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7073 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226787
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7074 : 
; 7075 : 	// Industrial era or Later
; 7076 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	pop	edi
	jl	SHORT $LN4@GetHappine@2

; 7077 : 		return GC.getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2952
	pop	esi

; 7086 : }

	ret	8
$LN4@GetHappine@2:

; 7078 : 
; 7079 : 	// Medieval era or later
; 7080 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, eax

; 7081 : 		return GC.getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2948
	jge	SHORT $LN1@GetHappine@2

; 7082 : 
; 7083 : 	// Pre-Medieval
; 7084 : 	else
; 7085 : 		return GC.getALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2944
$LN1@GetHappine@2:
	pop	esi

; 7086 : }

	ret	8
?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetHappinessFlatAlliesBonus
_TEXT	ENDS
PUBLIC	?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus, COMDAT
; _this$ = ecx

; 7113 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 7114 : 	//antonjs: consider: optimize
; 7115 : 	int iNumLuxuries = 0;
; 7116 : 	ResourceTypes eResource;
; 7117 : #ifdef AUI_WARNING_FIXES
; 7118 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 7119 : #else
; 7120 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebx, DWORD PTR _ePlayer$[esp+12]
	test	eax, eax
	jle	SHORT $LN8@GetHappine@3
	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
$LL10@GetHappine@3:

; 7121 : #endif
; 7122 : 	{
; 7123 : 		eResource = (ResourceTypes) iResourceLoop;
; 7124 : 
; 7125 : 		if(GET_PLAYER(ePlayer).getNumResourceAvailable(eResource) > 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	lea	ecx, DWORD PTR [edi+eax]
	push	esi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	test	eax, eax
	jle	SHORT $LN9@GetHappine@3

; 7126 : 		{
; 7127 : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 7128 : 			if(pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	test	eax, eax
	je	SHORT $LN9@GetHappine@3
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN9@GetHappine@3

; 7129 : 			{
; 7130 : 				iNumLuxuries++;

	inc	ebp
$LN9@GetHappine@3:

; 7114 : 	//antonjs: consider: optimize
; 7115 : 	int iNumLuxuries = 0;
; 7116 : 	ResourceTypes eResource;
; 7117 : #ifdef AUI_WARNING_FIXES
; 7118 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 7119 : #else
; 7120 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL10@GetHappine@3
$LN8@GetHappine@3:

; 7131 : 			}
; 7132 : 		}
; 7133 : 	}
; 7134 : 
; 7135 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp+12]

; 7136 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN5@GetHappine@3

; 7137 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ebx+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@GetHappine@3
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN22@GetHappine@3
$LN21@GetHappine@3:
	or	eax, -1
$LN22@GetHappine@3:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN5@GetHappine@3:

; 7138 : 
; 7139 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226822
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7140 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226825
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7141 : 
; 7142 : 	// Industrial era or Later
; 7143 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	jl	SHORT $LN4@GetHappine@3

; 7144 : 		return (iNumLuxuries * GC.getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2964
	pop	edi

; 7149 : 
; 7150 : 	// Pre-Medieval
; 7151 : 	else
; 7152 : 		return (iNumLuxuries * GC.getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT());

	imul	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx

; 7153 : }

	ret	8
$LN4@GetHappine@3:

; 7145 : 
; 7146 : 	// Medieval era or later
; 7147 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, eax

; 7148 : 		return (iNumLuxuries * GC.getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2960
	jge	SHORT $LN37@GetHappine@3

; 7149 : 
; 7150 : 	// Pre-Medieval
; 7151 : 	else
; 7152 : 		return (iNumLuxuries * GC.getFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2956
$LN37@GetHappine@3:
	pop	edi
	imul	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx

; 7153 : }

	ret	8
?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus
_TEXT	ENDS
PUBLIC	?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus, COMDAT
; _this$ = ecx

; 7157 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 7158 : 	//antonjs: consider: optimize
; 7159 : 	int iNumLuxuries = 0;
; 7160 : 	ResourceTypes eResource;
; 7161 : #ifdef AUI_WARNING_FIXES
; 7162 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 7163 : #else
; 7164 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebx, DWORD PTR _ePlayer$[esp+12]
	test	eax, eax
	jle	SHORT $LN8@GetHappine@4
	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
$LL10@GetHappine@4:

; 7165 : #endif
; 7166 : 	{
; 7167 : 		eResource = (ResourceTypes) iResourceLoop;
; 7168 : 
; 7169 : 		if(GET_PLAYER(ePlayer).getNumResourceAvailable(eResource) > 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	lea	ecx, DWORD PTR [edi+eax]
	push	esi
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	test	eax, eax
	jle	SHORT $LN9@GetHappine@4

; 7170 : 		{
; 7171 : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 7172 : 			if(pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	test	eax, eax
	je	SHORT $LN9@GetHappine@4
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN9@GetHappine@4

; 7173 : 			{
; 7174 : 				iNumLuxuries++;

	inc	ebp
$LN9@GetHappine@4:

; 7158 : 	//antonjs: consider: optimize
; 7159 : 	int iNumLuxuries = 0;
; 7160 : 	ResourceTypes eResource;
; 7161 : #ifdef AUI_WARNING_FIXES
; 7162 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 7163 : #else
; 7164 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL10@GetHappine@4
$LN8@GetHappine@4:

; 7175 : 			}
; 7176 : 		}
; 7177 : 	}
; 7178 : 
; 7179 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp+12]

; 7180 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN5@GetHappine@4

; 7181 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ebx+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@GetHappine@4
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN22@GetHappine@4
$LN21@GetHappine@4:
	or	eax, -1
$LN22@GetHappine@4:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN5@GetHappine@4:

; 7182 : 
; 7183 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226849
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7184 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226852
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7185 : 
; 7186 : 	// Industrial era or Later
; 7187 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	jl	SHORT $LN4@GetHappine@4

; 7188 : 		return (iNumLuxuries * GC.getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2976
	pop	edi

; 7193 : 
; 7194 : 	// Pre-Medieval
; 7195 : 	else
; 7196 : 		return (iNumLuxuries * GC.getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT());

	imul	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx

; 7197 : }

	ret	8
$LN4@GetHappine@4:

; 7189 : 
; 7190 : 	// Medieval era or later
; 7191 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, eax

; 7192 : 		return (iNumLuxuries * GC.getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2972
	jge	SHORT $LN37@GetHappine@4

; 7193 : 
; 7194 : 	// Pre-Medieval
; 7195 : 	else
; 7196 : 		return (iNumLuxuries * GC.getALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2968
$LN37@GetHappine@4:
	pop	edi
	imul	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx

; 7197 : }

	ret	8
?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus
_TEXT	ENDS
PUBLIC	?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatFriendshipBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetFaithFlatFriendshipBonus, COMDAT
; _this$ = ecx

; 7234 : {

	push	ebx
	push	ebp
	push	esi

; 7235 : 	int iFaithBonus = 0;
; 7236 : 
; 7237 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp+8]
	push	edi

; 7238 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN9@GetFaithFl

; 7239 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR _ePlayer$[esp+12]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@GetFaithFl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN19@GetFaithFl
$LN18@GetFaithFl:
	or	eax, -1
$LN19@GetFaithFl:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN9@GetFaithFl:

; 7240 : 
; 7241 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226883
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7242 : 	EraTypes eRenaissance = (EraTypes) GC.getInfoTypeForString("ERA_RENAISSANCE", true);

	push	1
	push	OFFSET $SG226886
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7243 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226889
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7244 : 	EraTypes eClassical = (EraTypes) GC.getInfoTypeForString("ERA_CLASSICAL", true);

	push	1
	push	OFFSET $SG226892
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7245 : 
; 7246 : 	// Industrial era or later
; 7247 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	jl	SHORT $LN8@GetFaithFl

; 7266 : 	{
; 7267 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7268 : 	}
; 7269 : 
; 7270 : 	// Ancient era
; 7271 : 	else
; 7272 : 	{
; 7273 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7274 : 	}
; 7275 : 
; 7276 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2980
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7277 : }

	ret	8
$LN8@GetFaithFl:

; 7248 : 	{
; 7249 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL();
; 7250 : 	}
; 7251 : 
; 7252 : 	// Renaissance era
; 7253 : 	else if(eCurrentEra >= eRenaissance)

	cmp	esi, ebx
	jl	SHORT $LN6@GetFaithFl

; 7266 : 	{
; 7267 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7268 : 	}
; 7269 : 
; 7270 : 	// Ancient era
; 7271 : 	else
; 7272 : 	{
; 7273 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7274 : 	}
; 7275 : 
; 7276 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2984
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7277 : }

	ret	8
$LN6@GetFaithFl:

; 7254 : 	{
; 7255 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE();
; 7256 : 	}
; 7257 : 
; 7258 : 	// Medieval era
; 7259 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, ebp
	jl	SHORT $LN4@GetFaithFl

; 7266 : 	{
; 7267 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7268 : 	}
; 7269 : 
; 7270 : 	// Ancient era
; 7271 : 	else
; 7272 : 	{
; 7273 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7274 : 	}
; 7275 : 
; 7276 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2988
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7277 : }

	ret	8
$LN4@GetFaithFl:

; 7260 : 	{
; 7261 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL();
; 7262 : 	}
; 7263 : 
; 7264 : 	// Classical era
; 7265 : 	else if(eCurrentEra >= eClassical)

	cmp	esi, eax

; 7266 : 	{
; 7267 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7268 : 	}
; 7269 : 
; 7270 : 	// Ancient era
; 7271 : 	else
; 7272 : 	{
; 7273 : 		iFaithBonus += GC.getFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7274 : 	}
; 7275 : 
; 7276 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2992
	jge	SHORT $LN1@GetFaithFl
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2996
$LN1@GetFaithFl:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7277 : }

	ret	8
?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetFaithFlatFriendshipBonus
_TEXT	ENDS
PUBLIC	?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatAlliesBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetFaithFlatAlliesBonus, COMDAT
; _this$ = ecx

; 7280 : {

	push	ebx
	push	ebp
	push	esi

; 7281 : 	int iFaithBonus = 0;
; 7282 : 
; 7283 : 	EraTypes eCurrentEra = eAssumeEra;

	mov	esi, DWORD PTR _eAssumeEra$[esp+8]
	push	edi

; 7284 : 	if(eCurrentEra == NO_ERA)

	cmp	esi, -1
	jne	SHORT $LN9@GetFaithFl@2

; 7285 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	eax, DWORD PTR _ePlayer$[esp+12]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@GetFaithFl@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN19@GetFaithFl@2
$LN18@GetFaithFl@2:
	or	eax, -1
$LN19@GetFaithFl@2:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	esi, eax
$LN9@GetFaithFl@2:

; 7286 : 
; 7287 : 	EraTypes eIndustrial = (EraTypes) GC.getInfoTypeForString("ERA_INDUSTRIAL", true);

	push	1
	push	OFFSET $SG226911
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7288 : 	EraTypes eRenaissance = (EraTypes) GC.getInfoTypeForString("ERA_RENAISSANCE", true);

	push	1
	push	OFFSET $SG226914
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7289 : 	EraTypes eMedieval = (EraTypes) GC.getInfoTypeForString("ERA_MEDIEVAL", true);

	push	1
	push	OFFSET $SG226917
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7290 : 	EraTypes eClassical = (EraTypes) GC.getInfoTypeForString("ERA_CLASSICAL", true);

	push	1
	push	OFFSET $SG226920
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7291 : 
; 7292 : 	// Industrial era or later
; 7293 : 	if(eCurrentEra >= eIndustrial)

	cmp	esi, edi
	jl	SHORT $LN8@GetFaithFl@2

; 7312 : 	{
; 7313 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7314 : 	}
; 7315 : 
; 7316 : 	// Ancient era
; 7317 : 	else
; 7318 : 	{
; 7319 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7320 : 	}
; 7321 : 
; 7322 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3000
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7323 : }

	ret	8
$LN8@GetFaithFl@2:

; 7294 : 	{
; 7295 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL();
; 7296 : 	}
; 7297 : 
; 7298 : 	// Renaissance era
; 7299 : 	else if(eCurrentEra >= eRenaissance)

	cmp	esi, ebx
	jl	SHORT $LN6@GetFaithFl@2

; 7312 : 	{
; 7313 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7314 : 	}
; 7315 : 
; 7316 : 	// Ancient era
; 7317 : 	else
; 7318 : 	{
; 7319 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7320 : 	}
; 7321 : 
; 7322 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3004
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7323 : }

	ret	8
$LN6@GetFaithFl@2:

; 7300 : 	{
; 7301 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE();
; 7302 : 	}
; 7303 : 
; 7304 : 	// Medieval era
; 7305 : 	else if(eCurrentEra >= eMedieval)

	cmp	esi, ebp
	jl	SHORT $LN4@GetFaithFl@2

; 7312 : 	{
; 7313 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7314 : 	}
; 7315 : 
; 7316 : 	// Ancient era
; 7317 : 	else
; 7318 : 	{
; 7319 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7320 : 	}
; 7321 : 
; 7322 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3008
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7323 : }

	ret	8
$LN4@GetFaithFl@2:

; 7306 : 	{
; 7307 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL();
; 7308 : 	}
; 7309 : 
; 7310 : 	// Classical era
; 7311 : 	else if(eCurrentEra >= eClassical)

	cmp	esi, eax

; 7312 : 	{
; 7313 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL();
; 7314 : 	}
; 7315 : 
; 7316 : 	// Ancient era
; 7317 : 	else
; 7318 : 	{
; 7319 : 		iFaithBonus += GC.getALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT();
; 7320 : 	}
; 7321 : 
; 7322 : 	return iFaithBonus;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3012
	jge	SHORT $LN1@GetFaithFl@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3016
$LN1@GetFaithFl@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7323 : }

	ret	8
?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetFaithFlatAlliesBonus
_TEXT	ENDS
PUBLIC	?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsCapitalFoodBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetFriendsCapitalFoodBonus, COMDAT
; _this$ = ecx

; 7372 : {

	push	ebx
	push	esi

; 7373 : 	int iBonus;
; 7374 : 
; 7375 : 	EraTypes eCurrentEra = eAssumeEra;
; 7376 : 	if(eCurrentEra == NO_ERA)

	mov	esi, DWORD PTR _ePlayer$[esp+4]
	push	edi
	mov	edi, DWORD PTR _eAssumeEra$[esp+8]
	cmp	edi, -1
	jne	SHORT $LN4@GetFriends@3

; 7377 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, esi
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@GetFriends@3
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN14@GetFriends@3
$LN13@GetFriends@3:
	or	eax, -1
$LN14@GetFriends@3:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	edi, eax
$LN4@GetFriends@3:

; 7378 : 
; 7379 : 	EraTypes eRenaissance = (EraTypes) GC.getInfoTypeForString("ERA_RENAISSANCE", true);

	push	1
	push	OFFSET $SG226957
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7380 : 
; 7381 : 	// Medieval era or sooner
; 7382 : 	if(eCurrentEra < eRenaissance)

	cmp	edi, eax

; 7383 : 		iBonus = /*200*/ GC.getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2888
	jl	SHORT $LN22@GetFriends@3

; 7384 : 
; 7385 : 	// Renaissance era or later
; 7386 : 	else
; 7387 : 		iBonus = /*200*/ GC.getFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2892
$LN22@GetFriends@3:

; 7388 : 
; 7389 : 	// Modify the bonus if called for by our trait
; 7390 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier(); 

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	edi, DWORD PTR [eax+88]

; 7391 : 	
; 7392 : 	//NQMP GJS - Patronage Finisher
; 7393 : 	iModifier += GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_BONUS_MODIFIER);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	push	60					; 0000003cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax

; 7394 : 
; 7395 : 	if(iModifier > 0)

	test	edi, edi
	jle	SHORT $LN30@GetFriends@3

; 7396 : 	{
; 7397 : 		iBonus *= (iModifier + 100);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, ebx

; 7398 : 		iBonus /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 7402 : }

	ret	8
$LN30@GetFriends@3:
	pop	edi
	pop	esi

; 7399 : 	}
; 7400 : 
; 7401 : 	return iBonus;

	mov	eax, ebx
	pop	ebx

; 7402 : }

	ret	8
?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetFriendsCapitalFoodBonus
_TEXT	ENDS
PUBLIC	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eAssumeEra$ = 12					; size = 4
?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::GetFriendsOtherCityFoodBonus, COMDAT
; _this$ = ecx

; 7406 : {

	push	ebx
	push	esi

; 7407 : 	int iBonus;
; 7408 : 
; 7409 : 	EraTypes eCurrentEra = eAssumeEra;
; 7410 : 	if(eCurrentEra == NO_ERA)

	mov	esi, DWORD PTR _ePlayer$[esp+4]
	push	edi
	mov	edi, DWORD PTR _eAssumeEra$[esp+8]
	cmp	edi, -1
	jne	SHORT $LN4@GetFriends@4

; 7411 : 		eCurrentEra = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, esi
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@GetFriends@4
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN14@GetFriends@4
$LN13@GetFriends@4:
	or	eax, -1
$LN14@GetFriends@4:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	edi, eax
$LN4@GetFriends@4:

; 7412 : 
; 7413 : 	EraTypes eRenaissance = (EraTypes) GC.getInfoTypeForString("ERA_RENAISSANCE", true);

	push	1
	push	OFFSET $SG226972
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7414 : 
; 7415 : 	// Medieval era or sooner
; 7416 : 	if(eCurrentEra < eRenaissance)

	cmp	edi, eax

; 7417 : 		iBonus = /*0*/ GC.getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2896
	jl	SHORT $LN22@GetFriends@4

; 7418 : 
; 7419 : 	// Renaissance era or later
; 7420 : 	else
; 7421 : 		iBonus = /*0*/ GC.getFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2900
$LN22@GetFriends@4:

; 7422 : 
; 7423 : 	// Modify the bonus if called for by our trait
; 7424 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier(); 

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	edi, DWORD PTR [eax+88]

; 7425 : 	
; 7426 : 	//NQMP GJS - Patronage Finisher
; 7427 : 	iModifier += GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_BONUS_MODIFIER);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	push	60					; 0000003cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax

; 7428 : 
; 7429 : 	if(iModifier > 0)

	test	edi, edi
	jle	SHORT $LN30@GetFriends@4

; 7430 : 	{
; 7431 : 		iBonus *= (iModifier + 100);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, ebx

; 7432 : 		iBonus /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 7436 : }

	ret	8
$LN30@GetFriends@4:
	pop	edi
	pop	esi

; 7433 : 	}
; 7434 : 
; 7435 : 	return iBonus;

	mov	eax, ebx
	pop	ebx

; 7436 : }

	ret	8
?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::GetFriendsOtherCityFoodBonus
_TEXT	ENDS
PUBLIC	?CanMajorBuyout@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorBuyout
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?IsAbleToAnnexCityStates@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::IsAbleToAnnexCityStates
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorBuyout@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?CanMajorBuyout@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorBuyout, COMDAT
; _this$ = ecx

; 7839 : {

	push	ebx
	push	edi

; 7840 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 7841 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 7842 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	edi, DWORD PTR _eMajor$[esp+4]
	mov	ebx, ecx
	cmp	edi, 21					; 00000015H
	ja	$LN6@CanMajorBu

; 7843 : 
; 7844 : 	// Is alive?
; 7845 : 	if (!GET_PLAYER(eMajor).isAlive() || !GetPlayer()->isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edi, 63236				; 0000f704H
	cmp	BYTE PTR [edi+eax+2256], 0
	lea	ecx, DWORD PTR [edi+eax]
	je	$LN6@CanMajorBu
	mov	edx, DWORD PTR [ebx]
	cmp	BYTE PTR [edx+2256], 0
	je	$LN6@CanMajorBu

; 7847 : 	
; 7848 : 	// Has the trait or the policy?
; 7849 : 	if(!GET_PLAYER(eMajor).IsAbleToAnnexCityStates())

	call	?IsAbleToAnnexCityStates@CvPlayer@@QBE_NXZ ; CvPlayer::IsAbleToAnnexCityStates
	test	al, al

; 7850 : 		return false;

	je	$LN6@CanMajorBu

; 7851 : 
; 7852 : 	// Not at war?
; 7853 : 	if(GET_TEAM(GetPlayer()->getTeam()).isAtWar(GET_PLAYER(eMajor).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	push	esi
	lea	ebp, DWORD PTR [edi+eax]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	esi, eax
	imul	esi, 2984				; 00000ba8H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, ebp
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 7854 : 		return false;

	jne	SHORT $LN40@CanMajorBu

; 7855 : 
; 7856 : 	// Allies?
; 7857 : 	if(!IsAllies(eMajor))

	mov	esi, DWORD PTR _eMajor$[esp+12]
	cmp	DWORD PTR [ebx+2012], esi

; 7858 : 		return false;

	jne	SHORT $LN40@CanMajorBu

; 7859 : 
; 7860 : 	// Allied long enough?
; 7861 : 	if (GetAlliedTurns() < GC.getMINOR_CIV_BUYOUT_TURNS())

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7332
	mov	ecx, ebx
	call	?GetAlliedTurns@CvMinorCivAI@@QBEHXZ	; CvMinorCivAI::GetAlliedTurns
	cmp	eax, ebp
	jge	SHORT $LN2@CanMajorBu
$LN40@CanMajorBu:
	pop	esi
	pop	ebp
	pop	edi

; 7862 : 	{
; 7863 : 		return false;

	xor	al, al
	pop	ebx

; 7869 : 		return false;
; 7870 : 
; 7871 : 	return true;
; 7872 : }

	ret	4
$LN2@CanMajorBu:

; 7864 : 	}
; 7865 : 
; 7866 : 	// Has enough gold?
; 7867 : 	const int iBuyoutCost = GetBuyoutCost(eMajor);

	push	esi
	mov	ecx, ebx
	call	?GetBuyoutCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBuyoutCost

; 7868 : 	if(GET_PLAYER(eMajor).GetTreasury()->GetGold() < iBuyoutCost)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	mov	esi, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	cmp	eax, esi
	pop	esi
	pop	ebp
	pop	edi
	setge	al
	pop	ebx

; 7869 : 		return false;
; 7870 : 
; 7871 : 	return true;
; 7872 : }

	ret	4
$LN6@CanMajorBu:
	pop	edi

; 7846 : 		return false;

	xor	al, al
	pop	ebx

; 7869 : 		return false;
; 7870 : 
; 7871 : 	return true;
; 7872 : }

	ret	4
?CanMajorBuyout@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorBuyout
_TEXT	ENDS
PUBLIC	?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z ; CvMinorCivAI::CanMajorBullyGold
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iSpecifiedBullyMetric$ = 12				; size = 4
?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::CanMajorBullyGold, COMDAT
; _this$ = ecx

; 8458 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8459 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8460 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	cmp	DWORD PTR _ePlayer$[esp-4], 21		; 00000015H
	ja	SHORT $LN2@CanMajorBu@2

; 8461 : 
; 8462 : 	// Can't bully us if we're dead!
; 8463 : 	if(!GetPlayer()->isAlive())

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+2256], 0

; 8464 : 		return false;

	je	SHORT $LN2@CanMajorBu@2

; 8465 : 
; 8466 : 	return (iSpecifiedBullyMetric >= 0);

	xor	eax, eax
	cmp	DWORD PTR _iSpecifiedBullyMetric$[esp-4], eax
	setge	al

; 8467 : }

	ret	8
$LN2@CanMajorBu@2:

; 8458 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8459 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8460 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 8467 : }

	ret	8
?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::CanMajorBullyGold
_TEXT	ENDS
PUBLIC	?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z ; CvMinorCivAI::CanMajorBullyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iSpecifiedBullyMetric$ = 12				; size = 4
?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::CanMajorBullyUnit, COMDAT
; _this$ = ecx

; 8509 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8510 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8511 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	cmp	DWORD PTR _ePlayer$[esp-4], 21		; 00000015H
	ja	SHORT $LN2@CanMajorBu@3

; 8512 : 
; 8513 : 	// Can't bully us if we're dead!
; 8514 : 	if(!GetPlayer()->isAlive())

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+2256], 0

; 8515 : 		return false;

	je	SHORT $LN2@CanMajorBu@3

; 8516 : 
; 8517 : 	return (iSpecifiedBullyMetric >= 0);

	xor	eax, eax
	cmp	DWORD PTR _iSpecifiedBullyMetric$[esp-4], eax
	setge	al

; 8518 : }

	ret	8
$LN2@CanMajorBu@3:

; 8509 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8510 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8511 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 8518 : }

	ret	8
?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::CanMajorBullyUnit
_TEXT	ENDS
PUBLIC	?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ
_TEXT	SEGMENT
?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ PROC	; CvMinorCivAI::IsRecentlyBulliedByAnyMajor, COMDAT
; _this$ = ecx

; 8727 : {

	push	esi
	push	edi

; 8728 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	lea	edi, DWORD PTR [ecx+2816]
	npad	6
$LL4@IsRecently@2:

; 8729 : 		if(IsRecentlyBulliedByMajor((PlayerTypes)iPlayerLoop))

	cmp	esi, 21					; 00000015H
	ja	SHORT $LN7@IsRecently@2
	cmp	DWORD PTR [edi], 0
	jl	SHORT $LN7@IsRecently@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, 20					; 00000014H
	cmp	DWORD PTR [edi], eax
	jge	SHORT $LN16@IsRecently@2
$LN7@IsRecently@2:
	inc	esi
	add	edi, 4
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL4@IsRecently@2
	pop	edi

; 8731 : 	return false;

	xor	al, al
	pop	esi

; 8732 : }

	ret	0
$LN16@IsRecently@2:
	pop	edi

; 8730 : 			return true;

	mov	al, 1
	pop	esi

; 8732 : }

	ret	0
?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ENDP	; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
_TEXT	ENDS
PUBLIC	?GetFriendshipFromFaithGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z ; CvMinorCivAI::GetFriendshipFromFaithGift
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendshipFromFaithGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iFriendship$ = -4					; size = 4
_eMajor$ = 8						; size = 4
$T243315 = 12						; size = 4
_iFaith$ = 12						; size = 4
?GetFriendshipFromFaithGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::GetFriendshipFromFaithGift, COMDAT
; _this$ = ecx

; 9163 : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 9164 : 	int iFriendship = iFaith * 8; // hard-coded to be 8% of faith spent, which becomes 10% on quick speed
; 9165 : 	iFriendship /= 100;
; 9166 : 
; 9167 : 	// Game Speed Mod
; 9168 : 	iFriendship *= GC.getGame().getGameSpeedInfo().getGoldGiftMod(); // on quick speed this multiplies it by 125%

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGoldGiftMod
	mov	edx, DWORD PTR _iFaith$[esp+8]
	mov	ecx, eax
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	ecx, eax

; 9169 : 	iFriendship /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 9170 : 
; 9171 : 	// Friendship gained should always be positive
; 9172 : 	iFriendship = max(iFriendship, /*5*/ GC.getMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3148
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iFriendship$[esp+12], eax
	cmp	eax, ecx
	mov	DWORD PTR $T243315[esp+8], ecx
	lea	eax, DWORD PTR $T243315[esp+8]
	jl	SHORT $LN11@GetFriends@5
	lea	eax, DWORD PTR _iFriendship$[esp+12]
$LN11@GetFriends@5:

; 9173 : 
; 9174 : 	// Round the number so it's pretty
; 9175 : 	int iVisibleDivisor = /*5*/ GC.getMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR();
; 9176 : 	iFriendship /= iVisibleDivisor;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3144
	cdq
	idiv	ecx
	mov	esi, eax

; 9177 : 	iFriendship *= iVisibleDivisor;

	imul	esi, ecx

; 9178 : 
; 9179 : 	// if the city state is the same religion as you, triple the effect
; 9180 : 	if (IsSameReligionAsMajor(eMajor))

	mov	ecx, DWORD PTR _eMajor$[esp+8]
	push	ecx
	mov	ecx, edi
	call	?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsSameReligionAsMajor
	test	al, al

; 9181 : 		iFriendship *= 3;

	lea	eax, DWORD PTR [esi+esi*2]
	jne	SHORT $LN1@GetFriends@5

; 9182 : 
; 9183 : 	return iFriendship;

	mov	eax, esi
$LN1@GetFriends@5:
	pop	edi
	pop	esi

; 9184 : }

	pop	ecx
	ret	8
?GetFriendshipFromFaithGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::GetFriendshipFromFaithGift
_TEXT	ENDS
PUBLIC	?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ; CvMinorCivAI::IsLackingGiftableTileImprovementAtPlot
EXTRN	?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z:PROC ; CvPlot::getImprovementTypeNeededToImproveResource
; Function compile flags: /Ogtpy
;	COMDAT ?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eMajor$ = 8						; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z PROC ; CvMinorCivAI::IsLackingGiftableTileImprovementAtPlot, COMDAT
; _this$ = ecx

; 9233 : {

	push	ecx

; 9234 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9235 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9236 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	cmp	DWORD PTR _eMajor$[esp], 21		; 00000015H
	mov	DWORD PTR _this$[esp+4], ecx
	ja	$LN7@IsLackingG

; 9237 : 	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);

	mov	eax, DWORD PTR _iPlotX$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN67@IsLackingG
	mov	ecx, DWORD PTR _iPlotY$[esp+16]
	cmp	ecx, -2147483647			; 80000001H
	je	$LN67@IsLackingG
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	esi, DWORD PTR [ebp+4020]
	je	SHORT $LN61@IsLackingG
	test	eax, eax
	jge	SHORT $LN25@IsLackingG
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN27@IsLackingG
$LN25@IsLackingG:
	cmp	eax, esi
	jl	SHORT $LN61@IsLackingG
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN27@IsLackingG
$LN61@IsLackingG:
	mov	edi, eax
$LN27@IsLackingG:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN62@IsLackingG
	test	ecx, ecx
	jge	SHORT $LN35@IsLackingG
	mov	eax, ecx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@IsLackingG
$LN35@IsLackingG:
	cmp	ecx, ebx
	jl	SHORT $LN62@IsLackingG
	mov	eax, ecx
	cdq
	idiv	ebx
	jmp	SHORT $LN37@IsLackingG
$LN62@IsLackingG:
	mov	edx, ecx
$LN37@IsLackingG:
	test	edi, edi
	jl	SHORT $LN67@IsLackingG
	cmp	edi, esi
	jge	SHORT $LN67@IsLackingG
	test	edx, edx
	jl	SHORT $LN67@IsLackingG
	cmp	edx, ebx
	jge	SHORT $LN67@IsLackingG
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ebp+4068]

; 9238 : 	if(pPlot == NULL)

	test	esi, esi

; 9239 : 	{
; 9240 : 		CvAssertMsg(false, "pPlot not expected to be NULL, invalid coordinates. Please send Anton your save file and version.");
; 9241 : 		return false;

	je	SHORT $LN67@IsLackingG

; 9242 : 	}
; 9243 : 
; 9244 : 	// Only allowed to improve plots that the minor actually owns
; 9245 : 	if(pPlot->getOwner() != GetPlayer()->GetID())

	movsx	eax, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR _this$[esp+20]
	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+44]

; 9246 : 		return false;

	jne	SHORT $LN67@IsLackingG

; 9247 : 
; 9248 : 	// Only allowed to improve Luxury and Strategic resources
; 9249 : 	ResourceTypes eResource = pPlot->getResourceType();

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 9250 : 	if(eResource == NO_RESOURCE)

	cmp	eax, -1

; 9251 : 	{
; 9252 : 		return false;

	je	SHORT $LN67@IsLackingG

; 9253 : 	}
; 9254 : 	else
; 9255 : 	{
; 9256 : 		ResourceUsageTypes eUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 9257 : 		if(eUsage != RESOURCEUSAGE_STRATEGIC && eUsage != RESOURCEUSAGE_LUXURY)

	cmp	eax, 1
	je	SHORT $LN2@IsLackingG
	cmp	eax, 2
	je	SHORT $LN2@IsLackingG
$LN67@IsLackingG:
	pop	edi
	pop	esi
	pop	ebp

; 9258 : 		{
; 9259 : 			return false;

	xor	al, al
	pop	ebx

; 9267 : 		return false;
; 9268 : 
; 9269 : 	return true;
; 9270 : }

	pop	ecx
	ret	12					; 0000000cH
$LN2@IsLackingG:

; 9260 : 		}
; 9261 : 	}
; 9262 : 
; 9263 : 	ImprovementTypes eImprovement = pPlot->getImprovementTypeNeededToImproveResource(eMajor, false /*bTestOwner*/);

	mov	eax, DWORD PTR _eMajor$[esp+16]
	push	0
	push	eax
	mov	ecx, esi
	call	?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z ; CvPlot::getImprovementTypeNeededToImproveResource
	pop	edi
	pop	esi

; 9264 : 
; 9265 : 	// There must be a valid improvement for the player to build
; 9266 : 	if(eImprovement == NO_IMPROVEMENT)

	cmp	eax, -1
	pop	ebp
	setne	al
	pop	ebx

; 9267 : 		return false;
; 9268 : 
; 9269 : 	return true;
; 9270 : }

	pop	ecx
	ret	12					; 0000000cH
$LN7@IsLackingG:

; 9234 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9235 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9236 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al

; 9267 : 		return false;
; 9268 : 
; 9269 : 	return true;
; 9270 : }

	pop	ecx
	ret	12					; 0000000cH
?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ENDP ; CvMinorCivAI::IsLackingGiftableTileImprovementAtPlot
_TEXT	ENDS
PUBLIC	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPeaceBlocked
; Function compile flags: /Ogtpy
;	COMDAT ?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z PROC	; CvMinorCivAI::IsPeaceBlocked, COMDAT
; _this$ = ecx

; 9405 : {

	push	ebx

; 9406 : 	// Permanent war?
; 9407 : 	if(IsPermanentWar(eTeam))

	mov	ebx, DWORD PTR _eTeam$[esp]
	push	ebp
	mov	ebp, ecx
	cmp	ebx, 63					; 0000003fH
	ja	SHORT $LN7@IsPeaceBlo
	cmp	BYTE PTR [ebx+ebp+3168], 0
	je	SHORT $LN7@IsPeaceBlo
	pop	ebp

; 9408 : 		return true;

	mov	al, 1
	pop	ebx

; 9432 : }

	ret	4
$LN7@IsPeaceBlo:

; 9409 : 
; 9410 : 	// Allies with someone at war with this guy?
; 9411 : 	PlayerTypes eMajor;
; 9412 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	npad	7
$LL37@IsPeaceBlo:

; 9413 : 	{
; 9414 : 		eMajor = (PlayerTypes) iMajorLoop;
; 9415 : 
; 9416 : 		// Major must be alive
; 9417 : 		if(!GET_PLAYER(eMajor).isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	je	SHORT $LN5@IsPeaceBlo

; 9418 : 			continue;
; 9419 : 
; 9420 : 		// Must be allies
; 9421 : 		if(!IsAllies(eMajor))

	cmp	DWORD PTR [ebp+2012], edi
	jne	SHORT $LN5@IsPeaceBlo

; 9422 : 			continue;
; 9423 : 
; 9424 : 		// Ally must be at war with this team
; 9425 : 		if(!GET_TEAM(GET_PLAYER(eMajor).getTeam()).isAtWar(eTeam))

	mov	eax, DWORD PTR [esi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN28@IsPeaceBlo
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@IsPeaceBlo
$LN28@IsPeaceBlo:
	or	eax, -1
$LN29@IsPeaceBlo:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN1@IsPeaceBlo
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN5@IsPeaceBlo:

; 9409 : 
; 9410 : 	// Allies with someone at war with this guy?
; 9411 : 	PlayerTypes eMajor;
; 9412 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL37@IsPeaceBlo
	pop	edi
	pop	esi
	pop	ebp

; 9429 : 	}
; 9430 : 
; 9431 : 	return false;

	xor	al, al
	pop	ebx

; 9432 : }

	ret	4
$LN1@IsPeaceBlo:
	pop	edi
	pop	esi
	pop	ebp

; 9426 : 			continue;
; 9427 : 
; 9428 : 		return true;

	mov	al, 1
	pop	ebx

; 9432 : }

	ret	4
?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ENDP	; CvMinorCivAI::IsPeaceBlocked
_TEXT	ENDS
PUBLIC	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsHasMetPlayer, COMDAT
; _this$ = ecx

; 9674 : 	return GET_TEAM(GetPlayer()->getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam());

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	push	esi
	mov	esi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN9@IsHasMetPl
	mov	edx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN10@IsHasMetPl
$LN9@IsHasMetPl:
	or	edx, -1
$LN10@IsHasMetPl:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@IsHasMetPl
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN21@IsHasMetPl
$LN20@IsHasMetPl:
	or	eax, -1
$LN21@IsHasMetPl:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	pop	esi
	mov	DWORD PTR _ePlayer$[esp-4], edx
	mov	ecx, eax
	jmp	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsHasMetPlayer
_TEXT	ENDS
PUBLIC	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
; Function compile flags: /Ogtpy
;	COMDAT ?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsAtWarWithPlayersTeam, COMDAT
; _this$ = ecx

; 9680 : 	return GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GetPlayer()->getTeam());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN9@IsAtWarWit
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN10@IsAtWarWit
$LN9@IsAtWarWit:
	or	ecx, -1
$LN10@IsAtWarWit:
	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	push	esi
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+esi+44]
	pop	esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@IsAtWarWit
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@IsAtWarWit
$LN20@IsAtWarWit:
	or	eax, -1
$LN21@IsAtWarWit:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _ePlayer$[esp-4], ecx
	mov	ecx, eax
	jmp	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsAtWarWithPlayersTeam
_TEXT	ENDS
PUBLIC	??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z ; CvMinorCivAI::GetStatusChangeDetails
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
;	COMDAT __real@42c80000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$14
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$16
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z
_TEXT	SEGMENT
_fOtherCitiesFood$229229 = -184				; size = 4
_iOtherCitiesFoodTimes100$229224 = -184			; size = 4
tv651 = -180						; size = 4
_fCapitalFood$229228 = -180				; size = 4
_iCapitalFoodTimes100$229223 = -180			; size = 4
$T243701 = -176						; size = 4
$T243682 = -172						; size = 80
$T243681 = -172						; size = 80
$T243680 = -172						; size = 80
$T243679 = -172						; size = 80
$T243678 = -172						; size = 80
$T243677 = -172						; size = 80
$T243676 = -172						; size = 80
$T243675 = -172						; size = 80
$T243674 = -172						; size = 80
$T243673 = -172						; size = 80
$T243672 = -172						; size = 80
$T243671 = -172						; size = 80
$T243670 = -172						; size = 80
$T243669 = -172						; size = 80
$T243668 = -172						; size = 80
$T243667 = -172						; size = 80
_strDetailedInfo$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
_bAdd$ = 16						; size = 1
_bFriends$ = 20						; size = 1
_bAllies$ = 24						; size = 1
?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z PROC ; CvMinorCivAI::GetStatusChangeDetails, COMDAT
; _this$ = ecx

; 9815 : {

	push	-1
	push	__ehhandler$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 172				; 000000acH
	push	esi
	push	edi
	mov	esi, ecx
	xor	edi, edi

; 9816 : 	Localization::String strDetailedInfo;

	lea	ecx, DWORD PTR _strDetailedInfo$[esp+192]
	mov	DWORD PTR $T243701[esp+192], edi
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 9817 : 
; 9818 : 	MinorCivTraitTypes eTrait = GetTrait();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+204], 1
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	cmp	eax, edi
	je	$LN118@GetStatusC
	mov	eax, DWORD PTR [eax+272]
	push	ebx
	push	ebp

; 9819 : 
; 9820 : 	if(eTrait == MINOR_CIV_TRAIT_CULTURED)

	cmp	eax, edi
	jne	$LN47@GetStatusC

; 9821 : 	{
; 9822 : 		int iCultureBonusAmount = 0;
; 9823 : 		if (bFriends)

	cmp	BYTE PTR _bFriends$[esp+196], 0
	mov	ebp, DWORD PTR _ePlayer$[esp+196]
	je	SHORT $LN115@GetStatusC

; 9824 : 		{
; 9825 : 			iCultureBonusAmount += GetCultureFlatFriendshipBonus(ePlayer) + GetCulturePerBuildingFriendshipBonus(ePlayer);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatFriendshipBonus
	mov	edi, eax
$LN115@GetStatusC:

; 9826 : 		}
; 9827 : 		if (bAllies)

	mov	bl, BYTE PTR _bAllies$[esp+196]
	test	bl, bl
	je	SHORT $LN45@GetStatusC

; 9828 : 		{
; 9829 : 			iCultureBonusAmount += GetCultureFlatAlliesBonus(ePlayer) + GetCulturePerBuildingAlliesBonus(ePlayer);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatAlliesBonus
	add	edi, eax
$LN45@GetStatusC:

; 9830 : 		}
; 9831 : 		if (!bAdd)

	mov	al, BYTE PTR _bAdd$[esp+196]
	test	al, al
	jne	SHORT $LN44@GetStatusC

; 9832 : 		{
; 9833 : 			iCultureBonusAmount = -iCultureBonusAmount;

	neg	edi
$LN44@GetStatusC:

; 9834 : 		}
; 9835 : 
; 9836 : 		if(bAllies && bAdd)		// Now Allies (includes jump from nothing through Friends to Allies)

	test	bl, bl
	je	SHORT $LN43@GetStatusC
	test	al, al
	je	SHORT $LN43@GetStatusC

; 9837 : 		{
; 9838 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_CULTURE");

	lea	ecx, DWORD PTR $T243667[esp+200]
	push	OFFSET $SG229195
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 2

; 9839 : 			strDetailedInfo << iCultureBonusAmount;

	jmp	$LN124@GetStatusC
$LN43@GetStatusC:

; 9840 : 		}
; 9841 : 		else if(bFriends && bAdd)		// Now Friends

	cmp	BYTE PTR _bFriends$[esp+196], 0
	je	SHORT $LN41@GetStatusC
	test	al, al
	je	SHORT $LN110@GetStatusC

; 9842 : 		{
; 9843 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_CULTURE");

	lea	edx, DWORD PTR $T243668[esp+200]
	push	OFFSET $SG229199
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 3

; 9844 : 			strDetailedInfo << iCultureBonusAmount;

	jmp	$LN124@GetStatusC
$LN41@GetStatusC:

; 9845 : 		}
; 9846 : 		else if(!bAdd)		// Bonus diminished (or removed)

	test	al, al
	jne	$LN122@GetStatusC
$LN110@GetStatusC:

; 9847 : 		{
; 9848 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LOST_CULTURE");

	lea	eax, DWORD PTR $T243669[esp+200]
	push	OFFSET $SG229203
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 4

; 9849 : 			strDetailedInfo << iCultureBonusAmount;
; 9850 : 		}
; 9851 : 	}

	jmp	$LN124@GetStatusC
$LN47@GetStatusC:

; 9852 : 	else if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)

	cmp	eax, 1
	jne	$LN37@GetStatusC

; 9853 : 	{
; 9854 : 		if(bAllies && bAdd)		// Now Allies (includes jump from nothing through Friends to Allies)

	mov	cl, BYTE PTR _bAllies$[esp+196]
	mov	al, BYTE PTR _bAdd$[esp+196]
	test	cl, cl
	je	SHORT $LN36@GetStatusC
	test	al, al
	je	SHORT $LN36@GetStatusC

; 9855 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_MILITARISTIC");

	lea	ecx, DWORD PTR $T243670[esp+200]
	push	OFFSET $SG229208
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 5
	jmp	SHORT $LN126@GetStatusC
$LN36@GetStatusC:

; 9856 : 		else if(bFriends && bAdd)		// Now Friends

	cmp	BYTE PTR _bFriends$[esp+196], 0
	je	SHORT $LN32@GetStatusC
	test	al, al
	je	SHORT $LN34@GetStatusC

; 9857 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_MILITARISTIC");

	lea	edx, DWORD PTR $T243671[esp+200]
	push	OFFSET $SG229212
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 6
	jmp	SHORT $LN126@GetStatusC
$LN34@GetStatusC:

; 9858 : 		else if(bFriends && !bAdd)		// No longer Friends (includes drop from Allies down to nothing) - this should be before the Allies check!
; 9859 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LOST_FRIENDS_MILITARISTIC");

	lea	eax, DWORD PTR $T243672[esp+200]
	push	OFFSET $SG229216
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 7
	jmp	SHORT $LN126@GetStatusC
$LN32@GetStatusC:

; 9860 : 		else if(bAllies && !bAdd)		// No longer Allies

	test	cl, cl
	je	$LN122@GetStatusC
	test	al, al
	jne	$LN122@GetStatusC

; 9861 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LOST_ALLIES_MILITARISTIC");

	lea	ecx, DWORD PTR $T243673[esp+200]
	push	OFFSET $SG229220
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 8
$LN126@GetStatusC:
	push	eax
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+204]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243673[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9862 : 	}

	jmp	$LN122@GetStatusC
$LN37@GetStatusC:

; 9863 : 	else if(eTrait == MINOR_CIV_TRAIT_MARITIME)

	cmp	eax, 2
	jne	$LN28@GetStatusC

; 9864 : 	{
; 9865 : 		int iCapitalFoodTimes100 = 0;
; 9866 : 		int iOtherCitiesFoodTimes100 = 0;
; 9867 : 
; 9868 : 		if(bFriends)	// Friends bonus

	mov	ebx, DWORD PTR _ePlayer$[esp+196]
	xor	ebp, ebp
	cmp	BYTE PTR _bFriends$[esp+196], 0
	mov	DWORD PTR _iOtherCitiesFoodTimes100$229224[esp+200], ebp
	je	SHORT $LN27@GetStatusC

; 9869 : 		{
; 9870 : 			iCapitalFoodTimes100 += GetFriendsCapitalFoodBonus(ePlayer);

	push	-1
	push	ebx
	mov	ecx, esi
	call	?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsCapitalFoodBonus

; 9871 : 			iOtherCitiesFoodTimes100 += GetFriendsOtherCityFoodBonus(ePlayer);

	push	-1
	push	ebx
	mov	ecx, esi
	mov	edi, eax
	call	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus
	mov	ebp, eax
	mov	DWORD PTR _iOtherCitiesFoodTimes100$229224[esp+200], eax
$LN27@GetStatusC:

; 9872 : 		}
; 9873 : 		if(bAllies)		// Allies bonus

	cmp	BYTE PTR _bAllies$[esp+196], 0
	je	SHORT $LN26@GetStatusC

; 9874 : 		{
; 9875 : 			iCapitalFoodTimes100 += GetAlliesCapitalFoodBonus(ePlayer);

	push	ebx
	mov	ecx, esi
	call	?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesCapitalFoodBonus

; 9876 : 			iOtherCitiesFoodTimes100 += GetAlliesOtherCityFoodBonus(ePlayer);

	push	ebx
	mov	ecx, esi
	add	edi, eax
	call	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus
	add	ebp, eax
	mov	DWORD PTR _iOtherCitiesFoodTimes100$229224[esp+200], ebp
$LN26@GetStatusC:

; 9877 : 		}
; 9878 : 
; 9879 : 		if(!bAdd)		// Flip amount of we're taking bonuses away

	mov	al, BYTE PTR _bAdd$[esp+196]
	test	al, al
	jne	SHORT $LN25@GetStatusC

; 9880 : 		{
; 9881 : 			iCapitalFoodTimes100 = -iCapitalFoodTimes100;

	neg	edi

; 9882 : 			iOtherCitiesFoodTimes100 = -iOtherCitiesFoodTimes100;

	neg	ebp
	mov	DWORD PTR _iOtherCitiesFoodTimes100$229224[esp+200], ebp
$LN25@GetStatusC:

; 9883 : 		}
; 9884 : 
; 9885 : 		// Now that we've changed the gameplay, add together the two so the DISPLAY looks right
; 9886 : 		iCapitalFoodTimes100 += iOtherCitiesFoodTimes100;

	add	edi, ebp

; 9887 : 		float fCapitalFood = float(iCapitalFoodTimes100) / 100;
; 9888 : 		float fOtherCitiesFood = float(iOtherCitiesFoodTimes100) / 100;
; 9889 : 		//iCapitalFood += iOtherCitiesFood;
; 9890 : 
; 9891 : 		if(bAllies && bAdd)		// Now Allies (includes jump from nothing through Friends to Allies)

	cmp	BYTE PTR _bAllies$[esp+196], 0
	mov	DWORD PTR _iCapitalFoodTimes100$229223[esp+200], edi
	fild	DWORD PTR _iCapitalFoodTimes100$229223[esp+200]
	fld	DWORD PTR __real@42c80000
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _fCapitalFood$229228[esp+200]
	fidivr	DWORD PTR _iOtherCitiesFoodTimes100$229224[esp+200]
	fstp	DWORD PTR _fOtherCitiesFood$229229[esp+200]
	je	SHORT $LN24@GetStatusC
	test	al, al
	je	SHORT $LN24@GetStatusC

; 9892 : 		{
; 9893 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_MARITIME");

	lea	edx, DWORD PTR $T243674[esp+200]
	push	OFFSET $SG229232
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243674[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9894 : 			strDetailedInfo << fCapitalFood << fOtherCitiesFood;

	lea	eax, DWORD PTR _fOtherCitiesFood$229229[esp+200]
	push	eax
	lea	ecx, DWORD PTR _fCapitalFood$229228[esp+204]
	push	ecx
	lea	edx, DWORD PTR _strDetailedInfo$[esp+208]
	push	edx
	jmp	$LN125@GetStatusC
$LN24@GetStatusC:

; 9895 : 		}
; 9896 : 		else if(bFriends && bAdd)		// Now Friends

	cmp	BYTE PTR _bFriends$[esp+196], 0
	je	SHORT $LN22@GetStatusC
	test	al, al
	je	SHORT $LN109@GetStatusC

; 9897 : 		{
; 9898 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_MARITIME");

	lea	eax, DWORD PTR $T243675[esp+200]
	push	OFFSET $SG229241
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 10		; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243675[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9899 : 			strDetailedInfo << fCapitalFood << fOtherCitiesFood;

	lea	ecx, DWORD PTR _fOtherCitiesFood$229229[esp+200]
	push	ecx
	lea	edx, DWORD PTR _fCapitalFood$229228[esp+204]
	push	edx
	lea	eax, DWORD PTR _strDetailedInfo$[esp+208]
	push	eax
	jmp	SHORT $LN125@GetStatusC
$LN22@GetStatusC:

; 9900 : 		}
; 9901 : 		else if(!bAdd)		// Bonus diminished (or removed)

	test	al, al
	jne	$LN122@GetStatusC
$LN109@GetStatusC:

; 9902 : 		{
; 9903 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LOST_MARITIME");

	lea	ecx, DWORD PTR $T243676[esp+200]
	push	OFFSET $SG229245
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 11		; 0000000bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243676[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9904 : 			strDetailedInfo << fCapitalFood << fOtherCitiesFood;

	lea	edx, DWORD PTR _fOtherCitiesFood$229229[esp+200]
	push	edx
	lea	eax, DWORD PTR _fCapitalFood$229228[esp+204]
	push	eax
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+208]
	push	ecx
$LN125@GetStatusC:
	call	??$?6M@@YAAAVString@Localization@@AAV01@ABM@Z ; operator<<<float>
	add	esp, 8
	push	eax
	call	??$?6M@@YAAAVString@Localization@@AAV01@ABM@Z ; operator<<<float>
	add	esp, 8

; 9905 : 		}
; 9906 : 	}

	jmp	$LN122@GetStatusC
$LN28@GetStatusC:

; 9907 : 	else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	eax, 3
	jne	$LN94@GetStatusC

; 9908 : 	{
; 9909 : 		int iHappinessBonus = 0;
; 9910 : 
; 9911 : 		if(bFriends)	// Friends bonus

	cmp	BYTE PTR _bFriends$[esp+196], 0
	mov	ebp, DWORD PTR _ePlayer$[esp+196]
	je	SHORT $LN116@GetStatusC

; 9912 : 		{
; 9913 : 			iHappinessBonus += GetHappinessFlatFriendshipBonus(ePlayer) + GetHappinessPerLuxuryFriendshipBonus(ePlayer);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus
	push	-1
	push	ebp
	mov	ecx, esi
	mov	edi, eax
	call	?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatFriendshipBonus
	add	edi, eax
$LN116@GetStatusC:

; 9914 : 		}
; 9915 : 		if(bAllies)		// Allies bonus

	mov	bl, BYTE PTR _bAllies$[esp+196]
	test	bl, bl
	je	SHORT $LN16@GetStatusC

; 9916 : 		{
; 9917 : 			iHappinessBonus += GetHappinessFlatAlliesBonus(ePlayer) + GetHappinessPerLuxuryAlliesBonus(ePlayer);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus
	push	-1
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR tv651[esp+208], eax
	call	?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatAlliesBonus
	mov	ecx, DWORD PTR tv651[esp+200]
	add	eax, edi
	lea	edi, DWORD PTR [eax+ecx]
$LN16@GetStatusC:

; 9918 : 		}
; 9919 : 		if(!bAdd)		// Flip amount of we're taking bonuses away

	mov	al, BYTE PTR _bAdd$[esp+196]
	test	al, al
	jne	SHORT $LN15@GetStatusC

; 9920 : 		{
; 9921 : 			iHappinessBonus = -iHappinessBonus;

	neg	edi
$LN15@GetStatusC:

; 9922 : 		}
; 9923 : 
; 9924 : 		if(bAllies && bAdd)		// Now Allies (includes jump from nothing through Friends to Allies)

	test	bl, bl
	je	SHORT $LN14@GetStatusC
	test	al, al
	je	SHORT $LN14@GetStatusC

; 9925 : 		{
; 9926 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_MERCANTILE");

	lea	edx, DWORD PTR $T243677[esp+200]
	push	OFFSET $SG229254
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 12		; 0000000cH

; 9927 : 			strDetailedInfo << iHappinessBonus;

	jmp	$LN124@GetStatusC
$LN14@GetStatusC:

; 9928 : 		}
; 9929 : 		else if(bFriends && bAdd)		// Now Friends

	cmp	BYTE PTR _bFriends$[esp+196], 0
	je	SHORT $LN12@GetStatusC
	test	al, al
	je	SHORT $LN108@GetStatusC

; 9930 : 		{
; 9931 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_MERCANTILE");

	lea	eax, DWORD PTR $T243678[esp+200]
	push	OFFSET $SG229258
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 13		; 0000000dH

; 9932 : 			strDetailedInfo << iHappinessBonus;

	jmp	$LN124@GetStatusC
$LN12@GetStatusC:

; 9933 : 		}
; 9934 : 		else if(!bAdd)		// Bonus diminished (or removed)

	test	al, al
	jne	$LN122@GetStatusC
$LN108@GetStatusC:

; 9935 : 		{
; 9936 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LOST_MERCANTILE");

	lea	ecx, DWORD PTR $T243679[esp+200]
	push	OFFSET $SG229262
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 14		; 0000000eH

; 9938 : 		}
; 9939 : 	}
; 9940 : 
; 9941 : 	// Religious
; 9942 : 	if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)

	jmp	$LN124@GetStatusC

; 9937 : 			strDetailedInfo << iHappinessBonus;

$LN94@GetStatusC:

; 9938 : 		}
; 9939 : 	}
; 9940 : 
; 9941 : 	// Religious
; 9942 : 	if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)

	cmp	eax, 4
	jne	$LN122@GetStatusC

; 9943 : 	{
; 9944 : 		int iFaithBonusAmount = 0;
; 9945 : 		if (bFriends)

	cmp	BYTE PTR _bFriends$[esp+196], 0
	mov	ebp, DWORD PTR _ePlayer$[esp+196]
	je	SHORT $LN117@GetStatusC

; 9946 : 		{
; 9947 : 			iFaithBonusAmount += GetFaithFlatFriendshipBonus(ePlayer);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatFriendshipBonus
	mov	edi, eax
$LN117@GetStatusC:

; 9948 : 		}
; 9949 : 		if (bAllies)

	mov	bl, BYTE PTR _bAllies$[esp+196]
	test	bl, bl
	je	SHORT $LN7@GetStatusC

; 9950 : 		{
; 9951 : 			iFaithBonusAmount += GetFaithFlatAlliesBonus(ePlayer);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatAlliesBonus
	add	edi, eax
$LN7@GetStatusC:

; 9952 : 		}
; 9953 : 		if (!bAdd)

	mov	al, BYTE PTR _bAdd$[esp+196]
	test	al, al
	jne	SHORT $LN6@GetStatusC

; 9954 : 		{
; 9955 : 			iFaithBonusAmount = -iFaithBonusAmount;

	neg	edi
$LN6@GetStatusC:

; 9956 : 		}
; 9957 : 
; 9958 : 		if(bAllies && bAdd)		// Now Allies (includes jump from nothing through Friends to Allies)

	test	bl, bl
	je	SHORT $LN5@GetStatusC
	test	al, al
	je	SHORT $LN5@GetStatusC

; 9959 : 		{
; 9960 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_RELIGIOUS");

	lea	edx, DWORD PTR $T243680[esp+200]
	push	OFFSET $SG229270
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 15		; 0000000fH

; 9961 : 			strDetailedInfo << iFaithBonusAmount;

	jmp	SHORT $LN124@GetStatusC
$LN5@GetStatusC:

; 9962 : 		}
; 9963 : 		else if(bFriends && bAdd)		// Now Friends

	cmp	BYTE PTR _bFriends$[esp+196], 0
	je	SHORT $LN3@GetStatusC
	test	al, al
	je	SHORT $LN107@GetStatusC

; 9964 : 		{
; 9965 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_RELIGIOUS");

	lea	eax, DWORD PTR $T243681[esp+200]
	push	OFFSET $SG229274
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 16		; 00000010H

; 9966 : 			strDetailedInfo << iFaithBonusAmount;

	jmp	SHORT $LN124@GetStatusC
$LN3@GetStatusC:

; 9967 : 		}
; 9968 : 		else if(!bAdd)		// Bonus diminished (or removed)

	test	al, al
	jne	SHORT $LN122@GetStatusC
$LN107@GetStatusC:

; 9969 : 		{
; 9970 : 			strDetailedInfo = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LOST_RELIGIOUS");

	lea	ecx, DWORD PTR $T243682[esp+200]
	push	OFFSET $SG229278
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+208], 17		; 00000011H
$LN124@GetStatusC:
	push	eax
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+204]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243682[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9971 : 			strDetailedInfo << iFaithBonusAmount;

	push	edi
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+204]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
$LN122@GetStatusC:
	pop	ebp
	pop	ebx
$LN118@GetStatusC:

; 9972 : 		}
; 9973 : 	}
; 9974 : 
; 9975 : 	return strDetailedInfo.toUTF8();

	lea	ecx, DWORD PTR _strDetailedInfo$[esp+192]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN105@GetStatusC
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN105@GetStatusC:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+188]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+192]
	mov	DWORD PTR $T243701[esp+192], 1
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9976 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+192]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 184				; 000000b8H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$0:
	lea	ecx, DWORD PTR _strDetailedInfo$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$1:
	lea	ecx, DWORD PTR $T243667[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$2:
	lea	ecx, DWORD PTR $T243668[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$3:
	lea	ecx, DWORD PTR $T243669[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$4:
	lea	ecx, DWORD PTR $T243670[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$5:
	lea	ecx, DWORD PTR $T243671[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$6:
	lea	ecx, DWORD PTR $T243672[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$7:
	lea	ecx, DWORD PTR $T243673[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$8:
	lea	ecx, DWORD PTR $T243674[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$9:
	lea	ecx, DWORD PTR $T243675[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$10:
	lea	ecx, DWORD PTR $T243676[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$11:
	lea	ecx, DWORD PTR $T243677[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$12:
	lea	ecx, DWORD PTR $T243678[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$13:
	lea	ecx, DWORD PTR $T243679[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$14:
	lea	ecx, DWORD PTR $T243680[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$15:
	lea	ecx, DWORD PTR $T243681[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$16:
	lea	ecx, DWORD PTR $T243682[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z$17:
	mov	eax, DWORD PTR $T243701[ebp]
	and	eax, 1
	je	$LN68@GetStatusC
	and	DWORD PTR $T243701[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN68@GetStatusC:
	ret	0
__ehhandler$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z ENDP ; CvMinorCivAI::GetStatusChangeDetails
PUBLIC	?clear@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEXXZ ; BaseVector<CvMinorCivQuest,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEXXZ PROC	; BaseVector<CvMinorCivQuest,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvMinorCivQuest@@$0A@@@QAEXXZ ENDP	; BaseVector<CvMinorCivQuest,0>::clear
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@5:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@10

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@10
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@10:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN16@operator@10
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	ecx, DWORD PTR [edi*4]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@10
$LN16@operator@10:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@operator@10:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@10:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum ResourceTypes,64,1,297,0>::~FStaticVector<enum ResourceTypes,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum ResourceTypes,64,1,297,0>::~FStaticVector<enum ResourceTypes,64,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@6
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@6:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum ResourceTypes,64,1,297,0>::~FStaticVector<enum ResourceTypes,64,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::~FStaticVector<enum MinorCivQuestTypes,18,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::~FStaticVector<enum MinorCivQuestTypes,18,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@7:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::~FStaticVector<enum MinorCivQuestTypes,18,1,297,0>
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::end
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@ABV0@@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@ABV0@@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 591  : 	FStaticVector(const THIS_TYPE& RHS)

	push	ebx
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	push	edi

; 592  : 	{
; 593  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	edi, DWORD PTR _RHS$[esp+8]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 594  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], ecx

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ebx, DWORD PTR [edi+8]
	cmp	ebx, 64					; 00000040H
	jbe	SHORT $LN6@FStaticVec@8
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	edx, DWORD PTR [ebx*8]
	push	4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], ebx
	jmp	SHORT $LN5@FStaticVec@8
$LN6@FStaticVec@8:
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN5@FStaticVec@8:
	mov	DWORD PTR [esi], eax

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@ABV0@@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@9
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@9:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,50,1,297,0>::~FStaticVector<enum BuildingTypes,50,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum BuildingTypes,50,1,297,0>::~FStaticVector<enum BuildingTypes,50,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@10
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@10:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum BuildingTypes,50,1,297,0>::~FStaticVector<enum BuildingTypes,50,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum UnitTypes,8,1,297,0>::~FStaticVector<enum UnitTypes,8,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum UnitTypes,8,1,297,0>::~FStaticVector<enum UnitTypes,8,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@11
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@11:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum UnitTypes,8,1,297,0>::~FStaticVector<enum UnitTypes,8,1,297,0>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+264], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,16,0,297,0>::~FStaticVector<CvCity *,16,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvCity *,16,0,297,0>::~FStaticVector<CvCity *,16,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@12
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@12:

; 619  : 	};

	ret	0
??1?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvCity *,16,0,297,0>::~FStaticVector<CvCity *,16,0,297,0>
_TEXT	ENDS
PUBLIC	?ChooseByWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE?AW4PlayerTypes@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<enum PlayerTypes,22,1>::ChooseByWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?ChooseByWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE?AW4PlayerTypes@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_rndFcn$ = 8						; size = 4
_szRollName$ = 12					; size = 4
?ChooseByWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE?AW4PlayerTypes@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<enum PlayerTypes,22,1>::ChooseByWeight, COMDAT
; _this$ = ecx

; 197  : 	{

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 198  : 		WeightedElement elem;

	xor	edi, edi

; 199  : 		int iChoice;
; 200  : 
; 201  : 		// Random roll up to total weight
; 202  : 		iChoice = (*rndFcn)(GetTotalWeight(), szRollName);

	call	?GetTotalWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ ; CvWeightedVector<enum PlayerTypes,22,1>::GetTotalWeight
	mov	ecx, DWORD PTR _rndFcn$[esp+8]
	mov	ebx, DWORD PTR _szRollName$[esp+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	push	eax
	call	edx
	mov	edx, DWORD PTR [esi+4]

; 203  : 
; 204  : 		// Loop through until we find the item that is in the range for this roll
; 205  : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	xor	ecx, ecx
	test	edx, edx
	jbe	SHORT $LN2@ChooseByWe

; 198  : 		WeightedElement elem;

	mov	esi, DWORD PTR [esi]
$LL4@ChooseByWe:

; 206  : 		{
; 207  : 			elem = m_pItems[i];
; 208  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]

; 209  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseByWe
	inc	ecx
	add	esi, 8
	cmp	ecx, edx
	jb	SHORT $LL4@ChooseByWe
$LN2@ChooseByWe:

; 210  : 			{
; 211  : 				return elem.m_Element;
; 212  : 			}
; 213  : 		}
; 214  : 
; 215  : 		// We should have found something, so reaching here is an error
; 216  : 		//    Just return last thing accessed
; 217  : 		FAssertMsg (true, "Internal error in CvWeightedVector.");
; 218  : 		return elem.m_Element;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 219  : 	};

	ret	8
?ChooseByWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE?AW4PlayerTypes@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::ChooseByWeight
_TEXT	ENDS
PUBLIC	??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>, COMDAT
; _this$ = ecx

; 1041 : 	FastDelegate2() { clear(); }

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
_TEXT	ENDS
PUBLIC	??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::operator=, COMDAT
; _this$ = ecx

; 1045 : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	eax, DWORD PTR _x$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	ret	4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 153391689				; 09249249H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@12

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@12:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXPAVCvMinorCivQuest@@I@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
	npad	6
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN31@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN15@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@3
$LN15@GrowSize@3:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN14@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+268], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum ResourceTypes,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@4
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@4
	npad	6
$LL8@GrowSize@4:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@4

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@4

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@4
$LN31@GrowSize@4:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@4:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN15@GrowSize@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@4
$LN15@GrowSize@4:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN14@GrowSize@4:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+268], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum ResourceTypes,64,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@5
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@5:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@5
	npad	6
$LL8@GrowSize@5:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@5

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@5

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@5
$LN31@GrowSize@5:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@5:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 18					; 00000012H
	jbe	SHORT $LN15@GrowSize@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@5
$LN15@GrowSize@5:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 18			; 00000012H
$LN14@GrowSize@5:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@5:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+84], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::begin
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@13
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@13:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum BuildingTypes,50,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum BuildingTypes,50,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@6
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@6:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@6
	npad	6
$LL8@GrowSize@6:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@6

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@6

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@6
$LN31@GrowSize@6:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@6:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 50					; 00000032H
	jbe	SHORT $LN15@GrowSize@6
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@6
$LN15@GrowSize@6:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 50			; 00000032H
$LN14@GrowSize@6:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@6
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@6:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+212], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum BuildingTypes,50,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum UnitTypes,8,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum UnitTypes,8,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@7
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@7:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@7
	npad	6
$LL8@GrowSize@7:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@7

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@7

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@7
$LN31@GrowSize@7:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@7:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 8
	jbe	SHORT $LN15@GrowSize@7
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@7
$LN15@GrowSize@7:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 8
$LN14@GrowSize@7:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@7:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+44], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum UnitTypes,8,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCity *,16,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvCity *,16,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@8
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@8:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@8
	npad	5
$LL8@GrowSize@8:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize@8

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@8

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@8
$LN33@GrowSize@8:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@8:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 16					; 00000010H
	jbe	SHORT $LN15@GrowSize@8
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN14@GrowSize@8
$LN15@GrowSize@8:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 16			; 00000010H
$LN14@GrowSize@8:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN1@GrowSize@8
	mov	ecx, ebp
$LL3@GrowSize@8:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN2@GrowSize@8
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN2@GrowSize@8:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@8
$LN1@GrowSize@8:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN37@GrowSize@8
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN37@GrowSize@8:
	pop	edi

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+76], 1
	pop	esi
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvCity *,16,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::~FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::~FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@14
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@14:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::~FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@15
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@15:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z ; std::vector<CvString,std::allocator<CvString> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@00ABW4MinorCivQuestTypes@@D@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@00ABW4MinorCivQuestTypes@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@00ABW4MinorCivQuestTypes@@D@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0
$LN4@Buynode:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@00ABW4MinorCivQuestTypes@@D@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@9
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@9:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@9
	npad	6
$LL8@GrowSize@9:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@9

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@9

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@9
$LN34@GrowSize@9:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@9:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN16@GrowSize@9
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@9
$LN16@GrowSize@9:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@GrowSize@9:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@9
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@9:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+524], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@10
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@10:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@10
	npad	6
$LL8@GrowSize@10:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@10

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@10

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@10
$LN34@GrowSize@10:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@10:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 22					; 00000016H
	jbe	SHORT $LN16@GrowSize@10
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@10
$LN16@GrowSize@10:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 22			; 00000016H
$LN15@GrowSize@10:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@10
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@10:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+188], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@11
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@11:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@11
	npad	6
$LL8@GrowSize@11:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@11

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@11

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@11
$LN34@GrowSize@11:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@11:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 100				; 00000064H
	jbe	SHORT $LN16@GrowSize@11
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@11
$LN16@GrowSize@11:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 100			; 00000064H
$LN15@GrowSize@11:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@11
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@11:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+812], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T244997 = -80						; size = 28
$T244996 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+17], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase@2

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T244997[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T244996[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T244997[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T244996[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T244996[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T244996[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T244996[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase@2:
$LN40@erase@2:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LN39@erase@2

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase@2
$LN39@erase@2:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+17], 0
	je	SHORT $LN37@erase@2

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase@2
$LN37@erase@2:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase@2
$LN288@erase@2:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+17], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase@2

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@2:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase@2

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@2
$LN33@erase@2:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase@2

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@2
$LN31@erase@2:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@2:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase@2

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+17], 0
	je	SHORT $LN43@erase@2
	mov	eax, esi
	jmp	SHORT $LN44@erase@2
$LN43@erase@2:
	push	edi
	call	?_Min@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Min
	add	esp, 4
$LN44@erase@2:
	mov	DWORD PTR [ebx], eax
$LN29@erase@2:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase@2

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+17], 0
	je	SHORT $LN45@erase@2
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@2
$LN45@erase@2:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@2
$LN35@erase@2:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase@2

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@2
$LN26@erase@2:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+17], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@2

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@2:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@2:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase@2

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@2
$LN23@erase@2:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase@2

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@2
$LN21@erase@2:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+16]
	add	eax, 16					; 00000010H
	cmp	eax, ecx
	je	SHORT $LN173@erase@2
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@2:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+16], bl
	jne	$LN19@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase@2
	npad	6
$LL18@erase@2:
	cmp	BYTE PTR [edi+16], bl
	jne	$LN16@erase@2

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@2

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+16], 0
	jne	SHORT $LN14@erase@2

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+16], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+16], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase@2:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase@2

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN11@erase@2
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+16], bl
	je	SHORT $LN292@erase@2
$LN11@erase@2:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN9@erase@2

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+16], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+16], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase@2:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+16]
	mov	BYTE PTR [eax+16], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+16], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+16], bl
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@2
$LN15@erase@2:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+16], 0
	jne	SHORT $LN7@erase@2

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+16], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+16], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase@2:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase@2

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN4@erase@2
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+16], bl
	jne	SHORT $LN4@erase@2
$LN292@erase@2:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+16], 0
$LN291@erase@2:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@2
$LN4@erase@2:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN2@erase@2

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+16], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+16], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase@2:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+16]
	mov	BYTE PTR [eax+16], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+16], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+16], bl
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate
$LN16@erase@2:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+16], bl
$LN19@erase@2:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase@2

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase@2:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T244997[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T244996[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@2
	mov	DWORD PTR [eax], 0
$LN27@Buynode@2:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@2
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@2:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@2
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@2:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+16], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+17], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+17], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+17], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_nod<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	??$?5$$BY0BG@H$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@H@Z ; operator>><int [22],22>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5$$BY0BG@H$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@H@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5$$BY0BG@H$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@H@Z PROC ; operator>><int [22],22>, COMDAT

; 234  : {

	push	ebx

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _loadFrom$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _writeTo$[esp+8]
	push	edi
	mov	ebp, 22					; 00000016H
$LL17@operator@11:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	mov	edi, 22					; 00000016H
$LL8@operator@11:
	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL8@operator@11

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	sub	ebp, 1
	jne	SHORT $LL17@operator@11
	pop	edi
	pop	esi
	pop	ebp

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx

; 241  : }

	ret	0
??$?5$$BY0BG@H$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@H@Z ENDP ; operator>><int [22],22>
_TEXT	ENDS
PUBLIC	??$?6$$BY0BG@$$CBH$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@$$CBH@Z ; operator<<<int const [22],22>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$$BY0BG@$$CBH$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@$$CBH@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6$$BY0BG@$$CBH$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@$$CBH@Z PROC ; operator<<<int const [22],22>, COMDAT

; 223  : {

	push	ebx

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+8]
	push	edi
	mov	ebp, 22					; 00000016H
$LL17@operator@12:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	mov	edi, 22					; 00000016H
$LL8@operator@12:
	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL8@operator@12

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	sub	ebp, 1
	jne	SHORT $LL17@operator@12
	pop	edi
	pop	esi
	pop	ebp

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 230  : }

	ret	0
??$?6$$BY0BG@$$CBH$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@$$CBH@Z ENDP ; operator<<<int const [22],22>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::unchecked_copy<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvString *,CvString *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	esi, ebx
	je	SHORT $LN16@unchecked_@6
$LL9@unchecked_@6:
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL9@unchecked_@6
$LN16@unchecked_@6:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::fill<CvString *,CvString>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill@2
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill@2:
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL5@fill@2
	pop	ebx
$LN3@fill@2:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>, COMDAT
; _this$ = ecx

; 1057 : 		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN13@Move_backw@2
$LL6@Move_backw@2:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL6@Move_backw@2
$LN13@Move_backw@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum ResourceTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ; std::allocator<CvString>::construct
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0
__ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
_TEXT	SEGMENT
$T245766 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$245763 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z PROC ; std::allocator<CvString>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$245763[esp+12], ecx
	mov	DWORD PTR $T245766[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@3
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN5@construct@3:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0:
	mov	eax, DWORD PTR __Vptr$245763[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T245766[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ENDP ; std::allocator<CvString>::construct
PUBLIC	?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ; std::allocator<CvString>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z PROC ; std::allocator<CvString>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ENDP ; std::allocator<CvString>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL14@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@2

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median@2:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap@2
	npad	3
$LL2@Make_heap@2:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap@2
$LN1@Make_heap@2:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@2
	push	ebx
	push	esi
$LL7@Insertion_@2:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_@2
	npad	7
$LL22@Insertion_@2:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_@2
$LN21@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@2

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@2:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@2
	pop	esi
	pop	ebx
$LN6@Insertion_@2:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Median<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z PROC ; std::_Median<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@3

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median@3:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Med3<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap@3
	npad	3
$LL2@Make_heap@3:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap@3
$LN1@Make_heap@3:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@3

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@3
	push	ebx
	push	esi
$LL7@Insertion_@3:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@3

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_@3
	npad	7
$LL22@Insertion_@3:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_@3
$LN21@Insertion_@3:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@3
$LN5@Insertion_@3:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@3
$LL3@Insertion_@3:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@3

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@3:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@3:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@3
	pop	esi
	pop	ebx
$LN6@Insertion_@3:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Median<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@4

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median@4:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<int,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap@4
	npad	3
$LL2@Make_heap@4:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap@4
$LN1@Make_heap@4:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@4

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@4
	push	ebx
	push	esi
$LL7@Insertion_@4:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@4

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_@4
	npad	7
$LL22@Insertion_@4:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_@4
$LN21@Insertion_@4:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@4
$LN5@Insertion_@4:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@4
$LL3@Insertion_@4:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@4

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@4:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@4:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@4
	pop	esi
	pop	ebx
$LN6@Insertion_@4:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T246169 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$246177 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@3:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$246177[ebp], esi
	mov	DWORD PTR $T246169[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@3
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_cop@3:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $LL6@Uninit_cop@3
__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@3
$LL3@Uninit_cop@3:

; 134  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_cop@3:
$LN4@Uninit_cop@3:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_cop@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$246177[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246169[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@7
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@7:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@7
	pop	esi
$LN7@unchecked_@7:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?Write@CvMinorCivAI@@QBEXAAVFDataStream@@@Z	; CvMinorCivAI::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?Write@CvMinorCivAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -12					; size = 4
_uiVersion$246829 = -8					; size = 4
$T246816 = -4						; size = 4
$T246514 = 8						; size = 4
$T246504 = 8						; size = 4
_iQuestEntriesToWrite$222501 = 8			; size = 4
_kStream$ = 8						; size = 4
?Write@CvMinorCivAI@@QBEXAAVFDataStream@@@Z PROC	; CvMinorCivAI::Write, COMDAT
; _this$ = ecx

; 1810 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 1811 : 	// Current version number
; 1812 : 	uint uiVersion = 1;
; 1813 : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+20]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	ebx, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+32], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1814 : 
; 1815 : 	kStream << m_ePersonality;

	mov	ecx, DWORD PTR [ebx+8]
	lea	edx, DWORD PTR $T246504[esp+24]
	mov	DWORD PTR $T246504[esp+24], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1816 : 	kStream << m_eStatus;

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR $T246514[esp+24]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T246514[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1817 : 	kStream << m_eUniqueUnit; // Version 14

	lea	edx, DWORD PTR [ebx+16]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8

; 1818 : 
; 1819 : 	kStream << m_iTurnsSinceThreatenedByBarbarians;

	lea	eax, DWORD PTR [ebx+20]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1820 : 
; 1821 : 	kStream << m_iGlobalQuestCountdown; // Version 11

	lea	ecx, DWORD PTR [ebx+24]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1822 : 
; 1823 : 	kStream << m_eAlly;

	lea	edx, DWORD PTR [ebx+2012]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 1824 : 	kStream << m_iTurnAllied;

	lea	eax, DWORD PTR [ebx+2016]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1825 : 
; 1826 : 	kStream << m_eMajorBoughtOutBy; // Version 16

	lea	ecx, DWORD PTR [ebx+2020]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 1827 : 
; 1828 : 	kStream << m_abWarQuestAgainstMajor;

	xor	edi, edi
	npad	6
$LL27@Write:
	lea	edx, DWORD PTR [ebx+edi+28]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL27@Write

; 1829 : 
; 1830 : 	kStream << m_aaiNumEnemyUnitsLeftToKillByMajor;

	lea	eax, DWORD PTR [ebx+52]
	push	eax
	push	esi
	call	??$?6$$BY0BG@$$CBH$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@$$CBH@Z ; operator<<<int const [22],22>
	add	esp, 8

; 1831 : 
; 1832 : 	kStream << m_abRouteConnectionEstablished;

	xor	edi, edi
$LL34@Write:
	lea	ecx, DWORD PTR [ebx+edi+1988]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL34@Write

; 1833 : 
; 1834 : 	kStream << m_aiFriendshipWithMajorTimes100;

	lea	edi, DWORD PTR [ebx+2024]
	mov	ebp, 22					; 00000016H
$LL41@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL41@Write

; 1835 : 	kStream << m_aiAngerFreeIntrusionCounter;

	lea	edi, DWORD PTR [ebx+2112]
	mov	ebp, 22					; 00000016H
	npad	4
$LL48@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL48@Write

; 1836 : 	kStream << m_aiPlayerQuests;

	lea	edi, DWORD PTR [ebx+2200]
	mov	ebp, 22					; 00000016H
	npad	5
$LL55@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL55@Write

; 1837 : 	kStream << m_aiQuestData1;

	lea	edi, DWORD PTR [ebx+2288]
	mov	ebp, 22					; 00000016H
	npad	5
$LL62@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL62@Write

; 1838 : 	kStream << m_aiQuestData2;

	lea	edi, DWORD PTR [ebx+2376]
	mov	ebp, 22					; 00000016H
	npad	5
$LL69@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL69@Write

; 1839 : 	kStream << m_aiQuestCountdown;

	lea	edi, DWORD PTR [ebx+2464]
	mov	ebp, 22					; 00000016H
	npad	5
$LL76@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL76@Write

; 1840 : 	kStream << m_aiUnitSpawnCounter;

	lea	edi, DWORD PTR [ebx+2552]
	mov	ebp, 22					; 00000016H
	npad	5
$LL83@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL83@Write

; 1841 : 	kStream << m_aiNumUnitsGifted;

	lea	edi, DWORD PTR [ebx+2640]
	mov	ebp, 22					; 00000016H
	npad	5
$LL90@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL90@Write

; 1842 : 	kStream << m_aiNumGoldGifted;

	lea	edi, DWORD PTR [ebx+2728]
	mov	ebp, 22					; 00000016H
	npad	5
$LL97@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL97@Write

; 1843 : 	kStream << m_aiTurnLastBullied;

	lea	edi, DWORD PTR [ebx+2816]
	mov	ebp, 22					; 00000016H
	npad	5
$LL104@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL104@Write

; 1844 : 	kStream << m_aiTurnLastPledged;

	lea	edi, DWORD PTR [ebx+2904]
	mov	ebp, 22					; 00000016H
	npad	5
$LL111@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL111@Write

; 1845 : 	kStream << m_aiTurnLastBrokePledge;

	lea	edi, DWORD PTR [ebx+2992]
	mov	ebp, 22					; 00000016H
	npad	5
$LL118@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL118@Write

; 1846 : 	kStream << m_abUnitSpawningDisabled;

	xor	edi, edi
$LL125@Write:
	lea	edx, DWORD PTR [ebx+edi+3080]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL125@Write

; 1847 : 	kStream << m_abMajorIntruding;

	xor	edi, edi
	npad	7
$LL132@Write:
	lea	eax, DWORD PTR [ebx+edi+3102]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL132@Write

; 1848 : 	kStream << m_abEverFriends;

	xor	edi, edi
	npad	9
$LL139@Write:
	lea	ecx, DWORD PTR [ebx+edi+3124]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL139@Write

; 1849 : 	kStream << m_abPledgeToProtect;

	xor	edi, edi
	npad	9
$LL146@Write:
	lea	edx, DWORD PTR [ebx+edi+3146]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL146@Write

; 1850 : 	kStream << m_abPermanentWar;

	xor	edi, edi
	npad	9
$LL153@Write:
	lea	eax, DWORD PTR [ebx+edi+3168]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 80					; 00000050H
	jb	SHORT $LL153@Write

; 1851 : 	kStream << m_abWaryOfTeam; // Version 12

	xor	edi, edi
	npad	9
$LL160@Write:
	lea	ecx, DWORD PTR [ebx+edi+3248]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, 80					; 00000050H
	jb	SHORT $LL160@Write

; 1852 : 
; 1853 : 	// List of quests given
; 1854 : 	CvAssertMsg(m_QuestsGiven.size() == MAX_MAJOR_CIVS, "Number of entries in minor's quest list does not match MAX_MAJOR_CIVS when writing to memory!");
; 1855 : 	QuestListForAllPlayers::const_iterator itr_player;
; 1856 : 	for(itr_player = m_QuestsGiven.begin(); itr_player != m_QuestsGiven.end(); itr_player++)

	mov	edx, DWORD PTR [ebx+3332]
	mov	ebp, DWORD PTR [ebx+3328]
	imul	edx, 156				; 0000009cH
	add	edx, ebp
	cmp	ebp, edx
	je	$LN4@Write
$LL6@Write:

; 1857 : 	{
; 1858 : 		QuestListForPlayer* pvQuestList = (QuestListForPlayer*)itr_player;
; 1859 : 		int iQuestEntriesToWrite = pvQuestList->size();

	mov	eax, DWORD PTR [ebp+4]

; 1860 : 		kStream << iQuestEntriesToWrite;

	lea	ecx, DWORD PTR _iQuestEntriesToWrite$222501[esp+24]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _iQuestEntriesToWrite$222501[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1861 : 		QuestListForPlayer::const_iterator itr_quest;
; 1862 : 		for(itr_quest = pvQuestList->begin(); itr_quest != pvQuestList->end(); itr_quest++)

	mov	eax, DWORD PTR [ebp+4]
	mov	edi, DWORD PTR [ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	eax, DWORD PTR [edi+edx*4]
	cmp	edi, eax
	je	SHORT $LN5@Write
	npad	6
$LL3@Write:

; 1863 : 		{
; 1864 : 			kStream << *itr_quest;

	lea	ecx, DWORD PTR _uiVersion$246829[esp+28]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$246829[esp+32], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR $T246816[esp+28]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T246816[esp+32], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edx, DWORD PTR [edi+16]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	eax, DWORD PTR [edi+20]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ecx, DWORD PTR [edi+24]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	mov	eax, DWORD PTR [ebp+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebp]
	add	edi, 28					; 0000001cH
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	edi, ecx
	jne	SHORT $LL3@Write
$LN5@Write:

; 1852 : 
; 1853 : 	// List of quests given
; 1854 : 	CvAssertMsg(m_QuestsGiven.size() == MAX_MAJOR_CIVS, "Number of entries in minor's quest list does not match MAX_MAJOR_CIVS when writing to memory!");
; 1855 : 	QuestListForAllPlayers::const_iterator itr_player;
; 1856 : 	for(itr_player = m_QuestsGiven.begin(); itr_player != m_QuestsGiven.end(); itr_player++)

	mov	edx, DWORD PTR [ebx+3332]
	imul	edx, 156				; 0000009cH
	add	edx, DWORD PTR [ebx+3328]
	add	ebp, 156				; 0000009cH
	cmp	ebp, edx
	jne	$LL6@Write
$LN4@Write:

; 1865 : 		}
; 1866 : 	}
; 1867 : 
; 1868 : 	kStream << m_bDisableNotifications;

	add	ebx, 6864				; 00001ad0H
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1869 : }

	add	esp, 12					; 0000000cH
	ret	4
?Write@CvMinorCivAI@@QBEXAAVFDataStream@@@Z ENDP	; CvMinorCivAI::Write
_TEXT	ENDS
PUBLIC	?DoPickInitialItems@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoPickInitialItems
; Function compile flags: /Ogtpy
;	COMDAT ?DoPickInitialItems@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoPickInitialItems@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoPickInitialItems, COMDAT
; _this$ = ecx

; 1873 : {

	push	esi
	mov	esi, ecx

; 1874 : 	// Personality
; 1875 : 	DoPickPersonality();

	call	?DoPickPersonality@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoPickPersonality

; 1876 : 
; 1877 : 	// Unique unit
; 1878 : 	DoPickUniqueUnit();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+16], -1
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN3@DoPickInit
	mov	eax, DWORD PTR [eax+272]
	cmp	eax, 1
	jne	SHORT $LN3@DoPickInit
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	push	0
	push	0
	call	?GetRandomUniqueUnitType@CvGame@@QAE?AW4UnitTypes@@_N000@Z ; CvGame::GetRandomUniqueUnitType
	mov	DWORD PTR [esi+16], eax
$LN3@DoPickInit:
	pop	esi

; 1879 : }

	ret	0
?DoPickInitialItems@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoPickInitialItems
_TEXT	ENDS
PUBLIC	?DoTurnStatus@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoTurnStatus
EXTRN	?IsMinorCivWarmonger@CvTeam@@QBE_NXZ:PROC	; CvTeam::IsMinorCivWarmonger
EXTRN	?IsMinorCivAggressor@CvTeam@@QBE_NXZ:PROC	; CvTeam::IsMinorCivAggressor
EXTRN	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z:PROC ; CvPlayer::GetProximityToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurnStatus@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurnStatus@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::DoTurnStatus, COMDAT
; _this$ = ecx

; 2299 : {

	push	ebx
	push	ebp
	push	edi

; 2300 : 	int iWeight = 0;

	xor	ebp, ebp
	mov	ebx, ecx
	xor	edi, edi
	push	esi
	npad	6
$LL18@DoTurnStat:

; 2308 : 	{
; 2309 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 2310 : 		pPlayer = &GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]

; 2311 : 		pTeam = &GET_TEAM(pPlayer->getTeam());

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@DoTurnStat
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@DoTurnStat
$LN27@DoTurnStat:
	or	eax, -1
$LN28@DoTurnStat:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, eax

; 2312 : 
; 2313 : 		eProximity = pPlayer->GetProximityToPlayer(GetPlayer()->GetID());

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer

; 2314 : 
; 2315 : 		// Check how close the player is
; 2316 : 		switch(eProximity)

	sub	eax, 2
	je	SHORT $LN11@DoTurnStat
	sub	eax, 1
	jne	SHORT $LN17@DoTurnStat

; 2347 : 			}
; 2348 : 			break;
; 2349 : 
; 2350 : 			// NEIGHBORS: Pretty much anything makes the situation critical
; 2351 : 		case PLAYER_PROXIMITY_NEIGHBORS:
; 2352 : 			if(pTeam->IsMinorCivAggressor())

	mov	ecx, esi
	call	?IsMinorCivAggressor@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivAggressor
	test	al, al
	je	SHORT $LN68@DoTurnStat

; 2353 : 			{
; 2354 : 				iWeight += 20;

	add	ebp, 20					; 00000014H
$LN68@DoTurnStat:

; 2355 : 			}
; 2356 : 			if(IsAtWarWithPlayersTeam(ePlayer))

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN48@DoTurnStat
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN49@DoTurnStat
$LN48@DoTurnStat:
	or	ecx, -1
$LN49@DoTurnStat:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN59@DoTurnStat
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN60@DoTurnStat
$LN59@DoTurnStat:
	or	eax, -1
$LN60@DoTurnStat:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar

; 2357 : 			{
; 2358 : 				iWeight += 20;
; 2359 : 			}
; 2360 : 			break;

	jmp	SHORT $LN70@DoTurnStat
$LN11@DoTurnStat:

; 2317 : 		{
; 2318 : 			// DISTANT: Elevated if we're at war
; 2319 : 		case PLAYER_PROXIMITY_DISTANT:
; 2320 : 			break;
; 2321 : // 			if (IsAtWarWithPlayersTeam(ePlayer))
; 2322 : // 			{
; 2323 : // 				iWeight += 10;
; 2324 : // 			}
; 2325 : 
; 2326 : 			// FAR: Elevated if they're an aggressor OR we're at war (note the ELSE IF)
; 2327 : 		case PLAYER_PROXIMITY_FAR:
; 2328 : 			break;
; 2329 : // 			if (pTeam->IsMinorCivAggressor())
; 2330 : // 			{
; 2331 : // 				iWeight += 10;
; 2332 : // 			}
; 2333 : // 			else if (IsAtWarWithPlayersTeam(ePlayer))
; 2334 : // 			{
; 2335 : // 				iWeight += 10;
; 2336 : // 			}
; 2337 : 
; 2338 : 			// CLOSE: Elevated if they're an aggressor, critical if we're at war
; 2339 : 		case PLAYER_PROXIMITY_CLOSE:
; 2340 : 			if(pTeam->IsMinorCivAggressor())

	mov	ecx, esi
	call	?IsMinorCivAggressor@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivAggressor
	test	al, al
	je	SHORT $LN10@DoTurnStat

; 2341 : 			{
; 2342 : 				iWeight += 10;

	add	ebp, 10					; 0000000aH
$LN10@DoTurnStat:

; 2343 : 			}
; 2344 : 			if(pTeam->IsMinorCivWarmonger())

	mov	ecx, esi
	call	?IsMinorCivWarmonger@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivWarmonger
$LN70@DoTurnStat:
	test	al, al
	je	SHORT $LN17@DoTurnStat

; 2345 : 			{
; 2346 : 				iWeight += 20;

	add	ebp, 20					; 00000014H
$LN17@DoTurnStat:

; 2301 : 
; 2302 : 	PlayerProximityTypes eProximity;
; 2303 : 
; 2304 : 	CvPlayer* pPlayer;
; 2305 : 	CvTeam* pTeam;
; 2306 : 	PlayerTypes ePlayer;
; 2307 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jl	$LL18@DoTurnStat

; 2361 : 		default:
; 2362 : 			break;
; 2363 : 		}
; 2364 : 	}
; 2365 : 
; 2366 : 	// Do the final math
; 2367 : 	if(iWeight >= 20)

	cmp	ebp, 20					; 00000014H
	pop	esi
	jl	SHORT $LN4@DoTurnStat
	pop	edi
	pop	ebp

; 2368 : 	{
; 2369 : 		m_eStatus = MINOR_CIV_STATUS_CRITICAL;

	mov	DWORD PTR [ebx+12], 2
	pop	ebx

; 2372 : 	{
; 2373 : 		m_eStatus = MINOR_CIV_STATUS_ELEVATED;
; 2374 : 	}
; 2375 : 	else
; 2376 : 	{
; 2377 : 		m_eStatus = MINOR_CIV_STATUS_NORMAL;
; 2378 : 	}
; 2379 : }

	ret	0
$LN4@DoTurnStat:

; 2370 : 	}
; 2371 : 	else if(iWeight >= 10)

	xor	eax, eax
	cmp	ebp, 10					; 0000000aH
	setge	al
	pop	edi
	pop	ebp
	mov	DWORD PTR [ebx+12], eax
	pop	ebx

; 2372 : 	{
; 2373 : 		m_eStatus = MINOR_CIV_STATUS_ELEVATED;
; 2374 : 	}
; 2375 : 	else
; 2376 : 	{
; 2377 : 		m_eStatus = MINOR_CIV_STATUS_NORMAL;
; 2378 : 	}
; 2379 : }

	ret	0
?DoTurnStatus@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::DoTurnStatus
_TEXT	ENDS
PUBLIC	?IsThreateningBarbariansEventActiveForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsThreateningBarbariansEventActiveForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsThreateningBarbariansEventActiveForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsThreateningBarbariansEventActiveForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsThreateningBarbariansEventActiveForPlayer, COMDAT
; _this$ = ecx

; 2547 : {

	push	esi
	mov	esi, ecx

; 2548 : 	if (GetPlayer()->isAlive())

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+2256], 0
	push	edi
	je	SHORT $LN1@IsThreaten

; 2549 : 	{
; 2550 : 		if (IsHasMetPlayer(ePlayer) && !IsAtWarWithPlayersTeam(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	push	edi
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	je	SHORT $LN1@IsThreaten
	push	edi
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	jne	SHORT $LN1@IsThreaten

; 2551 : 		{
; 2552 : 			if (GetNumThreateningBarbarians() > 0)

	mov	ecx, esi
	call	?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetNumThreateningBarbarians
	test	eax, eax
	jle	SHORT $LN1@IsThreaten
	pop	edi

; 2553 : 			{
; 2554 : 				return true;

	mov	al, 1
	pop	esi

; 2560 : }

	ret	4
$LN1@IsThreaten:
	pop	edi

; 2555 : 			}
; 2556 : 		}
; 2557 : 	}
; 2558 : 	
; 2559 : 	return false;

	xor	al, al
	pop	esi

; 2560 : }

	ret	4
?IsThreateningBarbariansEventActiveForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsThreateningBarbariansEventActiveForPlayer
_TEXT	ENDS
PUBLIC	?IsPlayerCloseEnoughForThreatenedAnnouncement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsPlayerCloseEnoughForThreatenedAnnouncement
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?IsPlayerCloseEnoughForThreatenedAnnouncement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsPlayerCloseEnoughForThreatenedAnnouncement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsPlayerCloseEnoughForThreatenedAnnouncement, COMDAT
; _this$ = ecx

; 2657 : {

	push	ebx
	mov	ebx, ecx

; 2658 : 	CvCity* pCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	edi, eax

; 2659 : 
; 2660 : 	// Minor must have Capital
; 2661 : 	if(pCapital == NULL)

	test	edi, edi
	jne	SHORT $LN6@IsPlayerCl
	pop	edi

; 2662 : 	{
; 2663 : 		return false;

	xor	al, al
	pop	ebx

; 2693 : }

	ret	4
$LN6@IsPlayerCl:
	push	esi

; 2664 : 	}
; 2665 : 
; 2666 : 	// Has Minor met this player yet?
; 2667 : 	if(IsHasMetPlayer(eMajor))

	mov	esi, DWORD PTR _eMajor$[esp+8]
	push	esi
	mov	ecx, ebx
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	je	SHORT $LN1@IsPlayerCl

; 2668 : 	{
; 2669 : 		bool bCloseEnoughForQuest = false;
; 2670 : 
; 2671 : 		CvCity* pMajorsCapital = GET_PLAYER(eMajor).getCapitalCity();

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	esi, eax

; 2672 : 
; 2673 : 		if(pMajorsCapital != NULL)

	test	esi, esi
	je	SHORT $LN1@IsPlayerCl

; 2674 : 		{
; 2675 : 			if(pCapital->getArea() == pMajorsCapital->getArea())

	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, edi
	mov	ebx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	eax, ebx

; 2676 : 			{
; 2677 : 				return true;

	je	SHORT $LN32@IsPlayerCl

; 2678 : 			}
; 2679 : 
; 2680 : 			if(!bCloseEnoughForQuest)
; 2681 : 			{
; 2682 : 				int iDistance = plotDistance(pCapital->getX(), pCapital->getY(), pMajorsCapital->getX(), pMajorsCapital->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [edi+108]
	push	eax
	mov	eax, DWORD PTR [edi+96]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2683 : 
; 2684 : 				if(iDistance <= /*50*/ GC.getMAX_DISTANCE_MINORS_BARB_QUEST())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3040
	jg	SHORT $LN1@IsPlayerCl
$LN32@IsPlayerCl:
	pop	esi
	pop	edi

; 2685 : 				{
; 2686 : 					return true;

	mov	al, 1
	pop	ebx

; 2693 : }

	ret	4
$LN1@IsPlayerCl:
	pop	esi
	pop	edi

; 2687 : 				}
; 2688 : 			}
; 2689 : 		}
; 2690 : 	}
; 2691 : 
; 2692 : 	return false;

	xor	al, al
	pop	ebx

; 2693 : }

	ret	4
?IsPlayerCloseEnoughForThreatenedAnnouncement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsPlayerCloseEnoughForThreatenedAnnouncement
_TEXT	ENDS
PUBLIC	?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z ; CvMinorCivAI::IsProxyWarActiveForMajor
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ:PROC ; CvTeam::getLeaderID
; Function compile flags: /Ogtpy
;	COMDAT ?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eMajor$ = 8						; size = 4
_eOtherMajor$ = 12					; size = 4
?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z PROC ; CvMinorCivAI::IsProxyWarActiveForMajor, COMDAT
; _this$ = ecx

; 2796 : {

	push	ecx
	push	ebx
	push	ebp

; 2797 : 	CvAssert(eMajor >= 0 && eMajor < MAX_MAJOR_CIVS);
; 2798 : 	CvAssert(eOtherMajor >= 0 && eOtherMajor < MAX_MAJOR_CIVS);
; 2799 : 	if (eMajor != eOtherMajor && eMajor >= 0 && eMajor < MAX_MAJOR_CIVS && eOtherMajor >= 0 && eOtherMajor < MAX_MAJOR_CIVS)

	mov	ebp, DWORD PTR _eOtherMajor$[esp+8]
	push	esi
	mov	esi, DWORD PTR _eMajor$[esp+12]
	push	edi
	mov	DWORD PTR _this$[esp+20], ecx
	cmp	esi, ebp
	je	$LN1@IsProxyWar
	cmp	esi, 21					; 00000015H
	ja	$LN1@IsProxyWar
	cmp	ebp, 21					; 00000015H
	ja	$LN1@IsProxyWar

; 2800 : 	{
; 2801 : 		TeamTypes eOtherTeam = GET_PLAYER(eOtherMajor).getTeam();

	mov	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebp, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+ebp]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ebx, eax

; 2802 : 		CvAssert(eOtherTeam != NO_TEAM);
; 2803 : 		if (eOtherTeam != NO_TEAM)

	cmp	ebx, -1
	je	$LN1@IsProxyWar

; 2804 : 		{
; 2805 : 			// eMajor is at peace with us and eOtherMajor
; 2806 : 			if (GET_PLAYER(eMajor).isAlive() && !IsAtWarWithPlayersTeam(eMajor) && !GET_TEAM(eOtherTeam).isAtWar(GET_PLAYER(eMajor).getTeam()))

	imul	esi, 63236				; 0000f704H
	cmp	BYTE PTR [esi+edi+2256], 0
	je	$LN1@IsProxyWar
	mov	eax, DWORD PTR _eMajor$[esp+16]
	mov	ecx, DWORD PTR _this$[esp+20]
	push	eax
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	jne	$LN1@IsProxyWar
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	mov	esi, ebx
	imul	esi, 2984				; 00000ba8H
	lea	edi, DWORD PTR [esi+edx]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN1@IsProxyWar

; 2807 : 			{
; 2808 : 				// eOtherMajor is at war with us
; 2809 : 				if (GET_PLAYER(eOtherMajor).isAlive() && IsAtWarWithPlayersTeam(eOtherMajor) && !IsPeaceBlocked(eOtherTeam))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [eax+ebp+2256], 0
	je	SHORT $LN1@IsProxyWar
	mov	ecx, DWORD PTR _eOtherMajor$[esp+16]
	mov	edi, DWORD PTR _this$[esp+20]
	push	ecx
	mov	ecx, edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN1@IsProxyWar
	push	ebx
	mov	ecx, edi
	call	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPeaceBlocked
	test	al, al
	jne	SHORT $LN1@IsProxyWar

; 2810 : 				{
; 2811 : 					// Do some additional checks to safeguard against weird scenario cases (ex. major and minor on same team, major is dead)
; 2812 : 					PlayerTypes eOtherTeamLeader = GET_TEAM(eOtherTeam).getLeaderID();

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+edx]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 2813 : 					CvPlayer* pOtherTeamLeader = &GET_PLAYER(eOtherTeamLeader);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax

; 2814 : 					if (pOtherTeamLeader && !pOtherTeamLeader->isMinorCiv() && pOtherTeamLeader->isAlive())

	je	SHORT $LN1@IsProxyWar
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN1@IsProxyWar
	cmp	BYTE PTR [esi+2256], al
	je	SHORT $LN1@IsProxyWar
	pop	edi
	pop	esi
	pop	ebp

; 2815 : 					{
; 2816 : 						return true;

	mov	al, 1
	pop	ebx

; 2823 : }

	pop	ecx
	ret	8
$LN1@IsProxyWar:
	pop	edi
	pop	esi
	pop	ebp

; 2817 : 					}
; 2818 : 				}
; 2819 : 			}
; 2820 : 		}
; 2821 : 	}
; 2822 : 	return false;

	xor	al, al
	pop	ebx

; 2823 : }

	pop	ecx
	ret	8
?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z ENDP ; CvMinorCivAI::IsProxyWarActiveForMajor
_TEXT	ENDS
PUBLIC	?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsProxyWarActiveForMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsProxyWarActiveForMajor, COMDAT
; _this$ = ecx

; 2826 : {

	push	ebx

; 2827 : 	CvAssert(eMajor >= 0 && eMajor < MAX_MAJOR_CIVS);
; 2828 : 	for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	mov	ebx, DWORD PTR _eMajor$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	xor	esi, esi
	npad	5
$LL4@IsProxyWar@2:

; 2829 : 	{
; 2830 : 		if (IsProxyWarActiveForMajor(eMajor, (PlayerTypes)i))

	push	esi
	push	ebx
	mov	ecx, edi
	call	?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z ; CvMinorCivAI::IsProxyWarActiveForMajor
	test	al, al
	jne	SHORT $LN8@IsProxyWar@2
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL4@IsProxyWar@2
	pop	edi
	pop	esi
	pop	ebx

; 2833 : 		}
; 2834 : 	}
; 2835 : 	return false;
; 2836 : }

	ret	4
$LN8@IsProxyWar@2:
	pop	edi
	pop	esi

; 2831 : 		{
; 2832 : 			return true;

	mov	al, 1
	pop	ebx

; 2833 : 		}
; 2834 : 	}
; 2835 : 	return false;
; 2836 : }

	ret	4
?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsProxyWarActiveForMajor
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABV0@@Z ; CvWeightedVector<enum PlayerTypes,64,1>::CvWeightedVector<enum PlayerTypes,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABV0@@Z PROC ; CvWeightedVector<enum PlayerTypes,64,1>::CvWeightedVector<enum PlayerTypes,64,1>, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@ABV0@@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>
	mov	eax, esi
	pop	esi
	ret	4
??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@ABV0@@Z ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::CvWeightedVector<enum PlayerTypes,64,1>
_TEXT	ENDS
PUBLIC	?EndAllActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::EndAllActiveQuestsForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?EndAllActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?EndAllActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::EndAllActiveQuestsForPlayer, COMDAT
; _this$ = ecx

; 4265 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4266 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4267 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN2@EndAllActi

; 4268 : 
; 4269 : 	//antonjs: todo: instead, call for cancel quest (with flag for no notif)
; 4270 : 	if(GetNumActiveQuestsForPlayer(ePlayer) > 0)

	mov	ecx, DWORD PTR [ecx+3328]
	imul	eax, 156				; 0000009cH
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jle	SHORT $LN2@EndAllActi

; 4271 : 		m_QuestsGiven[ePlayer].clear();

	mov	DWORD PTR [eax+4], 0
$LN2@EndAllActi:

; 4272 : }

	ret	4
?EndAllActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::EndAllActiveQuestsForPlayer
_TEXT	ENDS
PUBLIC	?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestCityStateTarget
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z$0
__ehfuncinfo$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
_TEXT	SEGMENT
_eClosestProximity$ = -288				; size = 4
_this$ = -284						; size = 4
_veValidTargets$ = -280					; size = 268
__$EHRec$ = -12						; size = 12
_eForPlayer$ = 8					; size = 4
?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z PROC ; CvMinorCivAI::GetBestCityStateTarget, COMDAT
; _this$ = ecx

; 4992 : {

	push	-1
	push	__ehhandler$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 276				; 00000114H
	push	ebx

; 4993 : 	CvAssertMsg(eForPlayer >= 0, "eForPlayer is expected to be non-negative (invalid Index)");
; 4994 : 	CvAssertMsg(eForPlayer < MAX_MAJOR_CIVS, "eForPlayer is expected to be within maximum bounds (invalid Index)");
; 4995 : 
; 4996 : 	PlayerTypes eBestCityStateTarget = NO_PLAYER;
; 4997 : 
; 4998 : 	PlayerProximityTypes eClosestProximity = PLAYER_PROXIMITY_DISTANT;

	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	ebp
	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+304], ecx
	mov	DWORD PTR _eClosestProximity$[esp+304], 0

; 4999 : 
; 5000 : 	// First, loop through the Minors in the game to what the closest proximity is to any of the players
; 5001 : 	int iTargetLoop;
; 5002 : 	PlayerTypes eTarget;
; 5003 : 	for(iTargetLoop = MAX_MAJOR_CIVS; iTargetLoop < MAX_CIV_PLAYERS; iTargetLoop++)

	mov	edi, 22					; 00000016H
	mov	esi, 1391192				; 00153a58H
$LL164@GetBestCit:

; 5004 : 	{
; 5005 : 		eTarget = (PlayerTypes) iTargetLoop;
; 5006 : 
; 5007 : 		if(!GET_PLAYER(eTarget).isAlive())

	cmp	BYTE PTR [esi+ebp+2256], 0
	je	SHORT $LN14@GetBestCit

; 5008 : 			continue;
; 5009 : 
; 5010 : 		if(GetPlayer()->getTeam() == GET_PLAYER(eTarget).getTeam())

	mov	eax, DWORD PTR _this$[esp+304]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN31@GetBestCit
	mov	edx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN32@GetBestCit
$LN31@GetBestCit:
	or	edx, -1
$LN32@GetBestCit:
	mov	eax, DWORD PTR [esi+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN42@GetBestCit
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	jmp	SHORT $LN43@GetBestCit
$LN42@GetBestCit:
	or	eax, -1
$LN43@GetBestCit:
	cmp	edx, eax
	je	SHORT $LN14@GetBestCit

; 5011 : 			continue;
; 5012 : 
; 5013 : 		if(GetPlayer()->GetProximityToPlayer(eTarget) > eClosestProximity)

	push	edi
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, DWORD PTR _eClosestProximity$[esp+304]
	jle	SHORT $LN160@GetBestCit

; 5014 : 		{
; 5015 : 			eClosestProximity = GetPlayer()->GetProximityToPlayer(eTarget);

	mov	eax, DWORD PTR _this$[esp+304]
	mov	ecx, DWORD PTR [eax]
	push	edi
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	mov	DWORD PTR _eClosestProximity$[esp+304], eax
$LN160@GetBestCit:
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN14@GetBestCit:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL164@GetBestCit

; 5016 : 		}
; 5017 : 	}
; 5018 : 
; 5019 : 	// Found nobody, or only people far away
; 5020 : 	if(eClosestProximity == PLAYER_PROXIMITY_DISTANT)

	xor	eax, eax
	cmp	DWORD PTR _eClosestProximity$[esp+304], eax

; 5021 : 	{
; 5022 : 		return NO_PLAYER;

	je	$LN124@GetBestCit

; 5023 : 	}
; 5024 : 
; 5025 : 	FStaticVector<PlayerTypes, MAX_CIV_PLAYERS, true, c_eCiv5GameplayDLL, 0> veValidTargets;

	lea	ecx, DWORD PTR _veValidTargets$[esp+316]
	mov	DWORD PTR _veValidTargets$[esp+308], eax
	mov	DWORD PTR _veValidTargets$[esp+312], 63	; 0000003fH
	mov	DWORD PTR _veValidTargets$[esp+304], ecx
	mov	DWORD PTR __$EHRec$[esp+312], eax

; 5026 : 
; 5027 : 	// Now loop through and come up with a list of valid players based on the proximity we found out earlier
; 5028 : 	for(iTargetLoop = MAX_MAJOR_CIVS; iTargetLoop < MAX_CIV_PLAYERS; iTargetLoop++)

	lea	edi, DWORD PTR [eax+22]
	mov	esi, 1391192				; 00153a58H
	npad	8
$LL165@GetBestCit:

; 5029 : 	{
; 5030 : 		eTarget = (PlayerTypes) iTargetLoop;
; 5031 : 
; 5032 : 		if(!GET_PLAYER(eTarget).isAlive())

	cmp	BYTE PTR [esi+ebp+2256], 0
	je	$LN7@GetBestCit

; 5033 : 			continue;
; 5034 : 
; 5035 : 		if(GetPlayer()->getTeam() == GET_PLAYER(eTarget).getTeam())

	mov	edx, DWORD PTR _this$[esp+304]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN71@GetBestCit
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN72@GetBestCit
$LN71@GetBestCit:
	or	ecx, -1
$LN72@GetBestCit:
	mov	eax, DWORD PTR [esi+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN82@GetBestCit
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN83@GetBestCit
$LN82@GetBestCit:
	or	eax, -1
$LN83@GetBestCit:
	cmp	ecx, eax
	je	$LN7@GetBestCit

; 5036 : 			continue;
; 5037 : 
; 5038 : 		if(!GET_TEAM(GET_PLAYER(eForPlayer).getTeam()).isHasMet(GET_PLAYER(eTarget).getTeam()))

	mov	eax, DWORD PTR [esi+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN93@GetBestCit
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN94@GetBestCit
$LN93@GetBestCit:
	or	ecx, -1
$LN94@GetBestCit:
	mov	eax, DWORD PTR _eForPlayer$[esp+300]
	imul	eax, 63236				; 0000f704H
	add	eax, ebp
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN104@GetBestCit
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN105@GetBestCit
$LN104@GetBestCit:
	or	eax, -1
$LN105@GetBestCit:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN161@GetBestCit

; 5039 : 			continue;
; 5040 : 
; 5041 : 		if(GetPlayer()->GetProximityToPlayer(eTarget) == eClosestProximity)

	mov	eax, DWORD PTR _this$[esp+304]
	mov	ecx, DWORD PTR [eax]
	push	edi
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, DWORD PTR _eClosestProximity$[esp+304]
	jne	SHORT $LN161@GetBestCit

; 5042 : 		{
; 5043 : 			veValidTargets.push_back(eTarget);

	mov	eax, DWORD PTR _veValidTargets$[esp+312]
	mov	BYTE PTR _veValidTargets$[esp+568], 0
	cmp	DWORD PTR _veValidTargets$[esp+308], eax
	jne	SHORT $LN113@GetBestCit
	push	eax
	lea	ecx, DWORD PTR _veValidTargets$[esp+308]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
$LN113@GetBestCit:
	mov	ecx, DWORD PTR _veValidTargets$[esp+308]
	mov	edx, DWORD PTR _veValidTargets$[esp+304]
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN116@GetBestCit
	mov	DWORD PTR [eax], edi
$LN116@GetBestCit:
	inc	DWORD PTR _veValidTargets$[esp+308]
$LN161@GetBestCit:
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN7@GetBestCit:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	jl	$LL165@GetBestCit

; 5044 : 		}
; 5045 : 	}
; 5046 : 
; 5047 : 	// Didn't find any valid Target players
; 5048 : 	if(veValidTargets.size() == 0)

	mov	eax, DWORD PTR _veValidTargets$[esp+308]
	test	eax, eax
	jne	SHORT $LN1@GetBestCit

; 5049 : 		return NO_PLAYER;

	mov	eax, DWORD PTR _veValidTargets$[esp+304]
	lea	ecx, DWORD PTR _veValidTargets$[esp+316]
	mov	DWORD PTR __$EHRec$[esp+312], -1
	cmp	eax, ecx
	je	SHORT $LN124@GetBestCit
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN124@GetBestCit:
	or	eax, -1
	jmp	SHORT $LN16@GetBestCit
$LN1@GetBestCit:

; 5050 : 
; 5051 : 	int iRandIndex = GC.getGame().getJonRandNum(veValidTargets.size(), "Finding random City State Target for Minor to give out a quest to kill.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225848
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 5052 : 	eBestCityStateTarget = veValidTargets[iRandIndex];
; 5053 : 
; 5054 : 	return eBestCityStateTarget;

	mov	ecx, DWORD PTR _veValidTargets$[esp+304]
	mov	esi, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR _veValidTargets$[esp+316]
	mov	DWORD PTR __$EHRec$[esp+312], -1
	cmp	ecx, edx
	je	SHORT $LN144@GetBestCit
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN144@GetBestCit:
	mov	eax, esi
$LN16@GetBestCit:

; 5055 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+304]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 288				; 00000120H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z$0:
	lea	ecx, DWORD PTR _veValidTargets$[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
__ehhandler$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ENDP ; CvMinorCivAI::GetBestCityStateTarget
PUBLIC	?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestPlayerToFind
EXTRN	?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z:PROC ; CvTeam::IsHasFoundPlayersTerritory
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z$0
__ehfuncinfo$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
_TEXT	SEGMENT
_veValidTargets$ = -280					; size = 268
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z PROC ; CvMinorCivAI::GetBestPlayerToFind, COMDAT
; _this$ = ecx

; 5106 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
	push	eax

; 5107 : 	PlayerTypes eBestTargetPlayer = NO_PLAYER;
; 5108 : 
; 5109 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp+8]
	mov	DWORD PTR fs:0, esp
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	sub	esp, 268				; 0000010cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@GetBestPla
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@GetBestPla
$LN18@GetBestPla:
	or	ebx, -1
$LN19@GetBestPla:

; 5110 : 	CvTeam* pTeam = &GET_TEAM(eTeam);

	mov	edi, ebx
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 5111 : 
; 5112 : 	FStaticVector<PlayerTypes, MAX_CIV_PLAYERS, true, c_eCiv5GameplayDLL, 0> veValidTargets;

	xor	esi, esi
	lea	eax, DWORD PTR _veValidTargets$[esp+308]
	mov	DWORD PTR _veValidTargets$[esp+300], esi
	mov	DWORD PTR _veValidTargets$[esp+304], 63	; 0000003fH
	mov	DWORD PTR _veValidTargets$[esp+296], eax
	mov	DWORD PTR __$EHRec$[esp+304], esi

; 5113 : 
; 5114 : 	// First, loop through majors and see if the player has met them
; 5115 : 	PlayerTypes eTargetMajor;
; 5116 : 	TeamTypes eTargetTeam;
; 5117 : 	for(int iTargetMajorLoop = 0; iTargetMajorLoop < MAX_MAJOR_CIVS; iTargetMajorLoop++)

	xor	ebp, ebp
	jmp	SHORT $LN8@GetBestPla
	npad	8
$LL97@GetBestPla:

; 5110 : 	CvTeam* pTeam = &GET_TEAM(eTeam);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN8@GetBestPla:

; 5118 : 	{
; 5119 : 		eTargetMajor = (PlayerTypes) iTargetMajorLoop;
; 5120 : 		eTargetTeam = GET_PLAYER(eTargetMajor).getTeam();

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@GetBestPla
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN40@GetBestPla
$LN39@GetBestPla:
	or	eax, -1
$LN40@GetBestPla:

; 5121 : 
; 5122 : 		// Target needs to be alive
; 5123 : 		if(!GET_PLAYER(eTargetMajor).isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN7@GetBestPla

; 5124 : 		{
; 5125 : 			continue;
; 5126 : 		}
; 5127 : 
; 5128 : 		// Don't have the player find anyone on his team...
; 5129 : 		if(eTargetTeam == eTeam)

	cmp	eax, ebx
	je	SHORT $LN7@GetBestPla

; 5130 : 		{
; 5131 : 			continue;
; 5132 : 		}
; 5133 : 
; 5134 : 		// Player must already know the target
; 5135 : 		if(!pTeam->isHasMet(eTargetTeam))

	push	eax
	mov	ecx, edi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN7@GetBestPla

; 5136 : 		{
; 5137 : 			continue;
; 5138 : 		}
; 5139 : 
; 5140 : 		// Player can't have seen this guy's territory before
; 5141 : 		if(pTeam->IsHasFoundPlayersTerritory(eTargetMajor))

	push	ebp
	mov	ecx, edi
	call	?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ; CvTeam::IsHasFoundPlayersTerritory
	test	al, al
	jne	SHORT $LN7@GetBestPla

; 5142 : 		{
; 5143 : 			continue;
; 5144 : 		}
; 5145 : 
; 5146 : 		veValidTargets.push_back(eTargetMajor);

	mov	BYTE PTR _veValidTargets$[esp+560], al
	mov	eax, DWORD PTR _veValidTargets$[esp+304]
	cmp	DWORD PTR _veValidTargets$[esp+300], eax
	jne	SHORT $LN50@GetBestPla
	push	eax
	lea	ecx, DWORD PTR _veValidTargets$[esp+300]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
$LN50@GetBestPla:
	mov	eax, DWORD PTR _veValidTargets$[esp+300]
	mov	ecx, DWORD PTR _veValidTargets$[esp+296]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN53@GetBestPla
	mov	DWORD PTR [eax], ebp
$LN53@GetBestPla:
	inc	DWORD PTR _veValidTargets$[esp+300]
$LN7@GetBestPla:

; 5113 : 
; 5114 : 	// First, loop through majors and see if the player has met them
; 5115 : 	PlayerTypes eTargetMajor;
; 5116 : 	TeamTypes eTargetTeam;
; 5117 : 	for(int iTargetMajorLoop = 0; iTargetMajorLoop < MAX_MAJOR_CIVS; iTargetMajorLoop++)

	add	esi, 63236				; 0000f704H
	inc	ebp
	cmp	esi, 1391192				; 00153a58H
	jl	$LL97@GetBestPla

; 5147 : 	}
; 5148 : 
; 5149 : 	// Didn't find any valid Target players
; 5150 : 	if(veValidTargets.size() == 0)

	mov	eax, DWORD PTR _veValidTargets$[esp+300]
	test	eax, eax
	jne	SHORT $LN1@GetBestPla

; 5151 : 	{
; 5152 : 		return NO_PLAYER;

	mov	eax, DWORD PTR _veValidTargets$[esp+296]
	lea	edx, DWORD PTR _veValidTargets$[esp+308]
	mov	DWORD PTR __$EHRec$[esp+304], -1
	cmp	eax, edx
	je	SHORT $LN61@GetBestPla
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN61@GetBestPla:
	or	eax, -1
	jmp	SHORT $LN9@GetBestPla
$LN1@GetBestPla:

; 5153 : 	}
; 5154 : 
; 5155 : 	int iRandIndex = GC.getGame().getJonRandNum(veValidTargets.size(), "Finding random Major player Target for Minor to give out a quest to find.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225899
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 5156 : 	eBestTargetPlayer = veValidTargets[iRandIndex];
; 5157 : 
; 5158 : 	return eBestTargetPlayer;

	mov	ecx, DWORD PTR _veValidTargets$[esp+296]
	mov	esi, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR _veValidTargets$[esp+308]
	mov	DWORD PTR __$EHRec$[esp+304], -1
	cmp	ecx, eax
	je	SHORT $LN81@GetBestPla
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN81@GetBestPla:
	mov	eax, esi
$LN9@GetBestPla:

; 5159 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 280				; 00000118H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z$0:
	lea	ecx, DWORD PTR _veValidTargets$[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
__ehhandler$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ENDP ; CvMinorCivAI::GetBestPlayerToFind
PUBLIC	?IsGoodTimeForGiveGoldQuest@CvMinorCivAI@@QAE_NXZ ; CvMinorCivAI::IsGoodTimeForGiveGoldQuest
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoodTimeForGiveGoldQuest@CvMinorCivAI@@QAE_NXZ
_TEXT	SEGMENT
?IsGoodTimeForGiveGoldQuest@CvMinorCivAI@@QAE_NXZ PROC	; CvMinorCivAI::IsGoodTimeForGiveGoldQuest, COMDAT
; _this$ = ecx

; 5192 : 	if(IsRecentlyBulliedByAnyMajor())

	call	?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
	test	al, al
	setne	al

; 5193 : 	{
; 5194 : 		return true;
; 5195 : 	}
; 5196 : 
; 5197 : 	return false;
; 5198 : }

	ret	0
?IsGoodTimeForGiveGoldQuest@CvMinorCivAI@@QAE_NXZ ENDP	; CvMinorCivAI::IsGoodTimeForGiveGoldQuest
_TEXT	ENDS
PUBLIC	?IsGoodTimeForPledgeToProtectQuest@CvMinorCivAI@@QAE_NXZ ; CvMinorCivAI::IsGoodTimeForPledgeToProtectQuest
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoodTimeForPledgeToProtectQuest@CvMinorCivAI@@QAE_NXZ
_TEXT	SEGMENT
?IsGoodTimeForPledgeToProtectQuest@CvMinorCivAI@@QAE_NXZ PROC ; CvMinorCivAI::IsGoodTimeForPledgeToProtectQuest, COMDAT
; _this$ = ecx

; 5203 : 	if(IsRecentlyBulliedByAnyMajor())

	call	?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
	test	al, al
	setne	al

; 5204 : 	{
; 5205 : 		return true;
; 5206 : 	}
; 5207 : 
; 5208 : 	return false;
; 5209 : }

	ret	0
?IsGoodTimeForPledgeToProtectQuest@CvMinorCivAI@@QAE_NXZ ENDP ; CvMinorCivAI::IsGoodTimeForPledgeToProtectQuest
_TEXT	ENDS
PUBLIC	?IsGoodTimeForDenounceMajorQuest@CvMinorCivAI@@QAE_NXZ ; CvMinorCivAI::IsGoodTimeForDenounceMajorQuest
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoodTimeForDenounceMajorQuest@CvMinorCivAI@@QAE_NXZ
_TEXT	SEGMENT
?IsGoodTimeForDenounceMajorQuest@CvMinorCivAI@@QAE_NXZ PROC ; CvMinorCivAI::IsGoodTimeForDenounceMajorQuest, COMDAT
; _this$ = ecx

; 5214 : 	if(IsRecentlyBulliedByAnyMajor())

	call	?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
	test	al, al
	setne	al

; 5215 : 	{
; 5216 : 		return true;
; 5217 : 	}
; 5218 : 
; 5219 : 	return false;
; 5220 : }

	ret	0
?IsGoodTimeForDenounceMajorQuest@CvMinorCivAI@@QAE_NXZ ENDP ; CvMinorCivAI::IsGoodTimeForDenounceMajorQuest
_TEXT	ENDS
PUBLIC	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100, COMDAT
; _this$ = ecx

; 5405 : {

	push	esi
	push	edi

; 5406 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5407 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5408 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN2@GetEffecti

; 5409 : 
; 5410 : 	// Are we at war?
; 5411 : 	if(IsAtWarWithPlayersTeam(ePlayer))

	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN1@GetEffecti

; 5412 : 		return (100 * /*-60*/GC.getMINOR_FRIENDSHIP_AT_WAR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	pop	edi
	imul	eax, 100				; 00000064H
	pop	esi

; 5415 : }

	ret	4
$LN1@GetEffecti:

; 5413 : 
; 5414 : 	return GetBaseFriendshipWithMajorTimes100(ePlayer);

	mov	eax, DWORD PTR [esi+edi*4+2024]
	pop	edi
	pop	esi

; 5415 : }

	ret	4
$LN2@GetEffecti:
	pop	edi

; 5406 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5407 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5408 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return 0; // as defined during Reset()

	xor	eax, eax
	pop	esi

; 5415 : }

	ret	4
?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
_TEXT	ENDS
PUBLIC	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetEffectiveFriendshipWithMajor, COMDAT
; _this$ = ecx

; 5484 : {

	push	esi
	push	edi

; 5485 : 	return GetEffectiveFriendshipWithMajorTimes100(ePlayer) / 100;

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN4@GetEffecti@2
	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN3@GetEffecti@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN6@GetEffecti@2
$LN3@GetEffecti@2:
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN6@GetEffecti@2
$LN4@GetEffecti@2:
	xor	ecx, ecx
$LN6@GetEffecti@2:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	edi
	add	eax, edx
	pop	esi

; 5486 : }

	ret	4
?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
_TEXT	ENDS
PUBLIC	?GetMostFriendshipWithAnyMajor@CvMinorCivAI@@QAEHAAW4PlayerTypes@@@Z ; CvMinorCivAI::GetMostFriendshipWithAnyMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetMostFriendshipWithAnyMajor@CvMinorCivAI@@QAEHAAW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBestPlayer$ = 8					; size = 4
?GetMostFriendshipWithAnyMajor@CvMinorCivAI@@QAEHAAW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetMostFriendshipWithAnyMajor, COMDAT
; _this$ = ecx

; 5652 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 5653 : 	int iMostFriendship = 0;

	xor	ebx, ebx

; 5654 : 	PlayerTypes eMajor;
; 5655 : 
; 5656 : 	int iFriendship;
; 5657 : 
; 5658 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
	mov	DWORD PTR _this$[esp+20], ecx
	xor	edi, edi
	lea	ebp, DWORD PTR [ecx+2024]
	npad	11
$LL5@GetMostFri:

; 5659 : 	{
; 5660 : 		eMajor = (PlayerTypes) iMajorLoop;
; 5661 : 
; 5662 : 		if(IsHasMetPlayer(eMajor))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@GetMostFri
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN17@GetMostFri
$LN16@GetMostFri:
	or	ecx, -1
$LN17@GetMostFri:
	mov	eax, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@GetMostFri
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@GetMostFri
$LN27@GetMostFri:
	or	eax, -1
$LN28@GetMostFri:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN4@GetMostFri

; 5663 : 		{
; 5664 : 			iFriendship = GetEffectiveFriendshipWithMajor(eMajor);

	test	esi, esi
	jl	SHORT $LN37@GetMostFri
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN37@GetMostFri
	mov	ecx, DWORD PTR _this$[esp+20]
	push	esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN36@GetMostFri
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN39@GetMostFri
$LN36@GetMostFri:
	mov	ecx, DWORD PTR [ebp]
	jmp	SHORT $LN39@GetMostFri
$LN37@GetMostFri:
	xor	ecx, ecx
$LN39@GetMostFri:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 5665 : 
; 5666 : 			if(iFriendship > iMostFriendship)

	cmp	eax, ebx
	jle	SHORT $LN4@GetMostFri

; 5667 : 			{
; 5668 : 				eBestPlayer = eMajor;

	mov	ecx, DWORD PTR _eBestPlayer$[esp+16]
	mov	DWORD PTR [ecx], esi

; 5669 : 				iMostFriendship = iFriendship;

	mov	ebx, eax
$LN4@GetMostFri:
	add	edi, 63236				; 0000f704H
	inc	esi
	add	ebp, 4
	cmp	edi, 1391192				; 00153a58H
	jl	$LL5@GetMostFri
	pop	edi
	pop	esi
	pop	ebp

; 5670 : 			}
; 5671 : 		}
; 5672 : 	}
; 5673 : 
; 5674 : 	return iMostFriendship;

	mov	eax, ebx
	pop	ebx

; 5675 : }

	pop	ecx
	ret	4
?GetMostFriendshipWithAnyMajor@CvMinorCivAI@@QAEHAAW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetMostFriendshipWithAnyMajor
_TEXT	ENDS
PUBLIC	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z	; CvMinorCivAI::IsFriends
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC	; CvMinorCivAI::IsFriends, COMDAT
; _this$ = ecx

; 5829 : {

	push	esi
	push	edi

; 5830 : 	return IsFriendshipAboveFriendsThreshold(GetEffectiveFriendshipWithMajor(ePlayer));

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN6@IsFriends
	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN5@IsFriends
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN8@IsFriends
$LN5@IsFriends:
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN8@IsFriends
$LN6@IsFriends:
	xor	ecx, ecx
$LN8@IsFriends:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	pop	edi
	setge	al
	pop	esi

; 5831 : }

	ret	4
?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP	; CvMinorCivAI::IsFriends
_TEXT	ENDS
PUBLIC	?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsCloseToNotBeingAllies
; Function compile flags: /Ogtpy
;	COMDAT ?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsCloseToNotBeingAllies, COMDAT
; _this$ = ecx

; 5856 : {

	push	esi
	push	edi

; 5857 : 	int iBuffer = GetEffectiveFriendshipWithMajor(ePlayer) - GetAlliesThreshold();

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN7@IsCloseToN
	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN6@IsCloseToN
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN9@IsCloseToN
$LN6@IsCloseToN:
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN9@IsCloseToN
$LN7@IsCloseToN:
	xor	ecx, ecx
$LN9@IsCloseToN:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840
	pop	edi
	pop	esi

; 5858 : 
; 5859 : 	if(iBuffer >= 0 && iBuffer < /*8*/ GC.getMINOR_FRIENDSHIP_CLOSE_AMOUNT())

	js	SHORT $LN1@IsCloseToN
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2856
	jge	SHORT $LN1@IsCloseToN

; 5860 : 		return true;

	mov	al, 1

; 5863 : }

	ret	4
$LN1@IsCloseToN:

; 5861 : 
; 5862 : 	return false;

	xor	al, al

; 5863 : }

	ret	4
?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsCloseToNotBeingAllies
_TEXT	ENDS
PUBLIC	?IsCloseToNotBeingFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsCloseToNotBeingFriends
; Function compile flags: /Ogtpy
;	COMDAT ?IsCloseToNotBeingFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsCloseToNotBeingFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsCloseToNotBeingFriends, COMDAT
; _this$ = ecx

; 5867 : {

	push	esi
	push	edi

; 5868 : 	int iBuffer = GetEffectiveFriendshipWithMajor(ePlayer) - GetFriendsThreshold();

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN7@IsCloseToN@2
	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN6@IsCloseToN@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN9@IsCloseToN@2
$LN6@IsCloseToN@2:
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN9@IsCloseToN@2
$LN7@IsCloseToN@2:
	xor	ecx, ecx
$LN9@IsCloseToN@2:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	pop	edi
	pop	esi

; 5869 : 
; 5870 : 	if(iBuffer >= 0 && iBuffer < /*8*/ GC.getMINOR_FRIENDSHIP_CLOSE_AMOUNT())

	js	SHORT $LN1@IsCloseToN@2
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2856
	jge	SHORT $LN1@IsCloseToN@2

; 5871 : 		return true;

	mov	al, 1

; 5874 : }

	ret	4
$LN1@IsCloseToN@2:

; 5872 : 
; 5873 : 	return false;

	xor	al, al

; 5874 : }

	ret	4
?IsCloseToNotBeingFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsCloseToNotBeingFriends
_TEXT	ENDS
PUBLIC	?GetFriendshipLevelWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipLevelWithMajor
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendshipLevelWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetFriendshipLevelWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetFriendshipLevelWithMajor, COMDAT
; _this$ = ecx

; 5879 : 	if(IsAllies(ePlayer))

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	DWORD PTR [ecx+2012], eax
	jne	SHORT $LN3@GetFriends@6

; 5880 : 	{
; 5881 : 		return 2;

	mov	eax, 2

; 5884 : 	{
; 5885 : 		return 1;
; 5886 : 	}
; 5887 : 
; 5888 : 	return 0;
; 5889 : }

	ret	4
$LN3@GetFriends@6:

; 5882 : 	}
; 5883 : 	else if(IsFriends(ePlayer))

	push	eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	xor	ecx, ecx
	test	al, al
	setne	cl
	mov	eax, ecx

; 5884 : 	{
; 5885 : 		return 1;
; 5886 : 	}
; 5887 : 
; 5888 : 	return 0;
; 5889 : }

	ret	4
?GetFriendshipLevelWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetFriendshipLevelWithMajor
_TEXT	ENDS
PUBLIC	?GetFriendshipNeededForNextLevel@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipNeededForNextLevel
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendshipNeededForNextLevel@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetFriendshipNeededForNextLevel@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetFriendshipNeededForNextLevel, COMDAT
; _this$ = ecx

; 5894 : {

	push	esi
	push	edi

; 5895 : 	if(!IsFriends(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN11@GetFriends@7
	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN10@GetFriends@7
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN13@GetFriends@7
$LN10@GetFriends@7:
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN13@GetFriends@7
$LN11@GetFriends@7:
	xor	ecx, ecx
$LN13@GetFriends@7:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, eax

; 5896 : 	{
; 5897 : 		return GetFriendsThreshold();

	jl	SHORT $LN1@GetFriends@7

; 5898 : 	}
; 5899 : 	else if(!IsAllies(ePlayer))

	mov	eax, DWORD PTR [esi+2012]
	sub	eax, edi
	neg	eax
	sbb	eax, eax
	and	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840
$LN1@GetFriends@7:
	pop	edi
	pop	esi

; 5900 : 	{
; 5901 : 		return GetAlliesThreshold();
; 5902 : 	}
; 5903 : 
; 5904 : 	return 0;
; 5905 : }

	ret	4
?GetFriendshipNeededForNextLevel@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetFriendshipNeededForNextLevel
_TEXT	ENDS
PUBLIC	?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsPlayerHasOpenBorders
; Function compile flags: /Ogtpy
;	COMDAT ?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsPlayerHasOpenBorders, COMDAT
; _this$ = ecx

; 6466 : {

	push	esi
	push	edi

; 6467 : 	// Special trait?
; 6468 : 	if(IsPlayerHasOpenBordersAutomatically(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+92], 0
	jle	SHORT $LN1@IsPlayerHa
	pop	edi

; 6469 : 		return true;

	mov	al, 1
	pop	esi

; 6472 : }

	ret	4
$LN1@IsPlayerHa:

; 6470 : 
; 6471 : 	return IsFriends(ePlayer);

	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	pop	edi
	pop	esi

; 6472 : }

	ret	4
?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsPlayerHasOpenBorders
_TEXT	ENDS
PUBLIC	?CanMajorProtect@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorProtect
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorProtect@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?CanMajorProtect@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorProtect, COMDAT
; _this$ = ecx

; 6575 : {

	push	ebx

; 6576 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6577 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6578 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	ebx, DWORD PTR _eMajor$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, 21					; 00000015H
	ja	$LN4@CanMajorPr

; 6579 : 
; 6580 : 	// If at war, may not protect
; 6581 : 	if(GET_TEAM(GET_PLAYER(eMajor).getTeam()).isAtWar(GetPlayer()->getTeam()))

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@CanMajorPr
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@CanMajorPr
$LN14@CanMajorPr:
	or	ecx, -1
$LN15@CanMajorPr:
	mov	eax, ebx
	imul	eax, 63236				; 0000f704H
	push	esi
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN25@CanMajorPr
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@CanMajorPr
$LN25@CanMajorPr:
	or	eax, -1
$LN26@CanMajorPr:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 6582 : 		return false;

	jne	SHORT $LN41@CanMajorPr

; 6583 : 
; 6584 : 	// Must have positive INF
; 6585 : 	if(GetEffectiveFriendshipWithMajor(eMajor) < /*0*/ GC.getFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2852
	push	ebx
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
	cmp	eax, esi

; 6586 : 		return false;

	jl	SHORT $LN41@CanMajorPr

; 6587 : 
; 6588 : 	// Must not be too soon after a previous pledge was broken
; 6589 : 	int iCurrentTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 6590 : 	int iLastPledgeBrokenTurn = GetTurnLastPledgeBrokenByMajor(eMajor);

	mov	ecx, DWORD PTR [edi+ebx*4+2992]

; 6591 : 	const int iGracePeriod = 20; //antonjs: todo: xml
; 6592 : 	if(iLastPledgeBrokenTurn >= 0 && iLastPledgeBrokenTurn + iGracePeriod > iCurrentTurn)

	test	ecx, ecx
	jl	SHORT $LN1@CanMajorPr
	add	ecx, 20					; 00000014H
	cmp	ecx, eax
	jle	SHORT $LN1@CanMajorPr
$LN41@CanMajorPr:
	pop	esi
	pop	edi

; 6593 : 		return false;

	xor	al, al
	pop	ebx

; 6596 : }

	ret	4
$LN1@CanMajorPr:
	pop	esi
	pop	edi

; 6594 : 
; 6595 : 	return true;

	mov	al, 1
	pop	ebx

; 6596 : }

	ret	4
$LN4@CanMajorPr:
	pop	edi

; 6576 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6577 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6578 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	ebx

; 6596 : }

	ret	4
?CanMajorProtect@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorProtect
_TEXT	ENDS
PUBLIC	?CanMajorStartProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorStartProtection
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorStartProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?CanMajorStartProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorStartProtection, COMDAT
; _this$ = ecx

; 6599 : {

	push	esi
	push	edi

; 6600 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6601 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6602 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	edi, DWORD PTR _eMajor$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN1@CanMajorSt

; 6603 : 
; 6604 : 	return (CanMajorProtect(eMajor) && !IsProtectedByMajor(eMajor));

	push	edi
	call	?CanMajorProtect@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorProtect
	test	al, al
	je	SHORT $LN5@CanMajorSt
	cmp	BYTE PTR [edi+esi+3146], 0
	jne	SHORT $LN5@CanMajorSt
	pop	edi
	mov	eax, 1
	pop	esi

; 6605 : }

	ret	4
$LN5@CanMajorSt:
	pop	edi

; 6603 : 
; 6604 : 	return (CanMajorProtect(eMajor) && !IsProtectedByMajor(eMajor));

	xor	eax, eax
	pop	esi

; 6605 : }

	ret	4
$LN1@CanMajorSt:
	pop	edi

; 6600 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6601 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6602 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 6605 : }

	ret	4
?CanMajorStartProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorStartProtection
_TEXT	ENDS
PUBLIC	?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::DoMajorCivEraChange
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?ChangeCityYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z:PROC ; CvPlayer::ChangeCityYieldChange
EXTRN	?ChangeCapitalYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z:PROC ; CvPlayer::ChangeCapitalYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_bSomethingChanged$ = -1				; size = 1
tv378 = 8						; size = 4
_ePlayer$ = 8						; size = 4
tv376 = 12						; size = 4
_eNewEra$ = 12						; size = 4
?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z PROC ; CvMinorCivAI::DoMajorCivEraChange, COMDAT
; _this$ = ecx

; 6689 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 6690 : 	bool bSomethingChanged = false;
; 6691 : 
; 6692 : 	MinorCivTraitTypes eTrait = GetTrait();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	BYTE PTR _bSomethingChanged$[esp+12], 0
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	$LN68@DoMajorCiv
	mov	eax, DWORD PTR [eax+272]
	push	ebx
	push	ebp
	push	edi

; 6693 : 
; 6694 : 	// MARITIME
; 6695 : 	if(eTrait == MINOR_CIV_TRAIT_MARITIME)

	cmp	eax, 2
	jne	$LN25@DoMajorCiv

; 6696 : 	{
; 6697 : 		// Friends
; 6698 : 		if(IsFriends(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+16]
	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN69@DoMajorCiv

; 6699 : 		{
; 6700 : 			int iOldFood, iNewFood;
; 6701 : 
; 6702 : 			// Capital
; 6703 : 			iOldFood = GetFriendsCapitalFoodBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsCapitalFoodBonus

; 6704 : 			iNewFood = GetFriendsCapitalFoodBonus(ePlayer, eNewEra);

	mov	ebx, DWORD PTR _eNewEra$[esp+16]
	push	ebx
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsCapitalFoodBonus

; 6705 : 
; 6706 : 			if(iOldFood != iNewFood)

	cmp	ebp, eax
	je	SHORT $LN23@DoMajorCiv

; 6707 : 			{
; 6708 : 				bSomethingChanged = true;
; 6709 : 				GET_PLAYER(ePlayer).ChangeCapitalYieldChange(YIELD_FOOD, iNewFood - iOldFood);

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	eax, ebp
	push	eax
	push	0
	mov	BYTE PTR _bSomethingChanged$[esp+28], 1
	call	?ChangeCapitalYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z ; CvPlayer::ChangeCapitalYieldChange
$LN23@DoMajorCiv:

; 6710 : 			}
; 6711 : 
; 6712 : 			// Other Cities
; 6713 : 			iOldFood = GetFriendsOtherCityFoodBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus

; 6714 : 			iNewFood = GetFriendsOtherCityFoodBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus

; 6715 : 
; 6716 : 			if(iOldFood != iNewFood)

	cmp	ebp, eax
	je	SHORT $LN69@DoMajorCiv

; 6717 : 			{
; 6718 : 				bSomethingChanged = true;
; 6719 : 				GET_PLAYER(ePlayer).ChangeCityYieldChange(YIELD_FOOD, iNewFood - iOldFood);

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	eax, ebp
	push	eax
	push	0
	mov	BYTE PTR _bSomethingChanged$[esp+28], 1
	call	?ChangeCityYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z ; CvPlayer::ChangeCityYieldChange
$LN69@DoMajorCiv:

; 6720 : 			}
; 6721 : 		}
; 6722 : 
; 6723 : 		// Allies
; 6724 : 		if(IsAllies(ePlayer))

	cmp	DWORD PTR [esi+2012], edi
	jne	$LN73@DoMajorCiv

; 6725 : 		{
; 6726 : 			int iOldFood, iNewFood;
; 6727 : 
; 6728 : 			// Capital
; 6729 : 			iOldFood = GetAlliesCapitalFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesCapitalFoodBonus

; 6730 : 			iNewFood = GetAlliesCapitalFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesCapitalFoodBonus

; 6731 : 
; 6732 : 			if(iOldFood != iNewFood)

	cmp	ebp, eax
	je	SHORT $LN72@DoMajorCiv

; 6733 : 			{
; 6734 : 				bSomethingChanged = true;
; 6735 : 				GET_PLAYER(ePlayer).ChangeCapitalYieldChange(YIELD_FOOD, iNewFood - iOldFood);

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	eax, ebp
	push	eax
	push	0
	mov	BYTE PTR _bSomethingChanged$[esp+28], 1
	call	?ChangeCapitalYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z ; CvPlayer::ChangeCapitalYieldChange
$LN72@DoMajorCiv:

; 6736 : 			}
; 6737 : 
; 6738 : 			// Other Cities
; 6739 : 			iOldFood = GetAlliesOtherCityFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus

; 6740 : 			iNewFood = GetAlliesOtherCityFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus

; 6741 : 
; 6742 : 			if(iOldFood != iNewFood)

	cmp	ebp, eax
	je	$LN73@DoMajorCiv

; 6743 : 			{
; 6744 : 				bSomethingChanged = true;
; 6745 : 				GET_PLAYER(ePlayer).ChangeCityYieldChange(YIELD_FOOD, iNewFood - iOldFood);

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	eax, ebp
	push	eax
	push	0
	mov	BYTE PTR _bSomethingChanged$[esp+28], 1
	call	?ChangeCityYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z ; CvPlayer::ChangeCityYieldChange

; 6836 : 			}
; 6837 : 		}
; 6838 : 	}
; 6839 : 
; 6840 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6841 : 	if(bSomethingChanged)
; 6842 : 		GET_PLAYER(ePlayer).doSelfConsistencyCheckAllCities();
; 6843 : #endif
; 6844 : 
; 6845 : 	return bSomethingChanged;

	mov	al, BYTE PTR _bSomethingChanged$[esp+20]
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 6846 : }

	pop	ecx
	ret	8
$LN25@DoMajorCiv:

; 6746 : 			}
; 6747 : 		}
; 6748 : 	}
; 6749 : 
; 6750 : 	// CULTURED
; 6751 : 	else if(eTrait == MINOR_CIV_TRAIT_CULTURED)

	test	eax, eax
	jne	SHORT $LN17@DoMajorCiv

; 6752 : 	{
; 6753 : 		// Friends
; 6754 : 		if(IsFriends(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+16]
	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	mov	ebx, DWORD PTR _eNewEra$[esp+16]
	test	al, al
	je	SHORT $LN15@DoMajorCiv

; 6755 : 		{
; 6756 : 			int iOldCulture = GetCultureFlatFriendshipBonus(ePlayer) + GetCulturePerBuildingFriendshipBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatFriendshipBonus

; 6757 : 			int iNewCulture = GetCultureFlatFriendshipBonus(ePlayer, eNewEra) + GetCulturePerBuildingFriendshipBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatFriendshipBonus

; 6758 : 
; 6759 : 			if(iOldCulture != iNewCulture)

	cmp	ebp, eax
	je	SHORT $LN15@DoMajorCiv

; 6760 : 			{
; 6761 : 				bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$[esp+20], 1
$LN15@DoMajorCiv:

; 6762 : 			}
; 6763 : 		}
; 6764 : 
; 6765 : 		// Allies
; 6766 : 		if(IsAllies(ePlayer))

	cmp	DWORD PTR [esi+2012], edi
	jne	$LN73@DoMajorCiv

; 6767 : 		{
; 6768 : 			int iOldCulture = GetCultureFlatAlliesBonus(ePlayer) + GetCulturePerBuildingAlliesBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatAlliesBonus

; 6769 : 			int iNewCulture = GetCultureFlatAlliesBonus(ePlayer, eNewEra) + GetCulturePerBuildingAlliesBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatAlliesBonus

; 6770 : 
; 6771 : 			if(iOldCulture != iNewCulture)
; 6772 : 			{
; 6773 : 				bSomethingChanged = true;
; 6774 : 			}
; 6775 : 		}
; 6776 : 	}

	jmp	$LN77@DoMajorCiv
$LN17@DoMajorCiv:

; 6777 : 
; 6778 : 	// MERCANTILE
; 6779 : 	else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	eax, 3
	jne	$LN11@DoMajorCiv

; 6780 : 	{
; 6781 : 		// Friends
; 6782 : 		if(IsFriends(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+16]
	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	mov	ebx, DWORD PTR _eNewEra$[esp+16]
	test	al, al
	je	SHORT $LN9@DoMajorCiv

; 6783 : 		{
; 6784 : 			int iOldHappiness, iNewHappiness;
; 6785 : 
; 6786 : 			iOldHappiness = GetHappinessFlatFriendshipBonus(ePlayer) + GetHappinessPerLuxuryFriendshipBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus
	push	-1
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatFriendshipBonus

; 6787 : 			iNewHappiness = GetHappinessFlatFriendshipBonus(ePlayer, eNewEra) + GetHappinessPerLuxuryFriendshipBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	add	ebp, eax
	call	?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR tv378[esp+24], eax
	call	?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatFriendshipBonus
	mov	ecx, DWORD PTR tv378[esp+16]
	add	ecx, eax

; 6788 : 
; 6789 : 			if(iOldHappiness != iNewHappiness)

	cmp	ebp, ecx
	je	SHORT $LN9@DoMajorCiv

; 6790 : 			{
; 6791 : 				bSomethingChanged = true;
; 6792 : 				GET_PLAYER(ePlayer).DoUpdateHappiness();

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR _bSomethingChanged$[esp+20], 1
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN9@DoMajorCiv:

; 6793 : 			}
; 6794 : 		}
; 6795 : 
; 6796 : 		// Allies
; 6797 : 		if(IsAllies(ePlayer))

	cmp	DWORD PTR [esi+2012], edi
	jne	$LN73@DoMajorCiv

; 6798 : 		{
; 6799 : 			int iOldHappiness, iNewHappiness;
; 6800 : 
; 6801 : 			iOldHappiness = GetHappinessFlatAlliesBonus(ePlayer) + GetHappinessPerLuxuryAlliesBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus
	push	-1
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatAlliesBonus

; 6802 : 			iNewHappiness = GetHappinessFlatAlliesBonus(ePlayer, eNewEra) + GetHappinessPerLuxuryAlliesBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	add	ebp, eax
	call	?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR tv376[esp+24], eax
	call	?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatAlliesBonus
	mov	ecx, DWORD PTR tv376[esp+16]
	add	ecx, eax

; 6803 : 
; 6804 : 			if(iOldHappiness != iNewHappiness)

	cmp	ebp, ecx
	je	$LN73@DoMajorCiv

; 6805 : 			{
; 6806 : 				bSomethingChanged = true;
; 6807 : 				GET_PLAYER(ePlayer).DoUpdateHappiness();

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR _bSomethingChanged$[esp+20], 1
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness

; 6836 : 			}
; 6837 : 		}
; 6838 : 	}
; 6839 : 
; 6840 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6841 : 	if(bSomethingChanged)
; 6842 : 		GET_PLAYER(ePlayer).doSelfConsistencyCheckAllCities();
; 6843 : #endif
; 6844 : 
; 6845 : 	return bSomethingChanged;

	mov	al, BYTE PTR _bSomethingChanged$[esp+20]
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 6846 : }

	pop	ecx
	ret	8
$LN11@DoMajorCiv:

; 6808 : 			}
; 6809 : 		}
; 6810 : 	}
; 6811 : 
; 6812 : 	// RELIGIOUS
; 6813 : 	else if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)

	cmp	eax, 4
	jne	SHORT $LN73@DoMajorCiv

; 6814 : 	{
; 6815 : 		// Friends
; 6816 : 		if(IsFriends(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+16]
	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	mov	ebx, DWORD PTR _eNewEra$[esp+16]
	test	al, al
	je	SHORT $LN3@DoMajorCiv

; 6817 : 		{
; 6818 : 			int iOldFaith = GetFaithFlatFriendshipBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatFriendshipBonus

; 6819 : 			int iNewFaith = GetFaithFlatFriendshipBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatFriendshipBonus

; 6820 : 
; 6821 : 			if(iOldFaith != iNewFaith)

	cmp	ebp, eax
	je	SHORT $LN3@DoMajorCiv

; 6822 : 			{
; 6823 : 				bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$[esp+20], 1
$LN3@DoMajorCiv:

; 6824 : 			}
; 6825 : 		}
; 6826 : 
; 6827 : 		// Allies
; 6828 : 		if(IsAllies(ePlayer))

	cmp	DWORD PTR [esi+2012], edi
	jne	SHORT $LN73@DoMajorCiv

; 6829 : 		{
; 6830 : 			int iOldFaith = GetFaithFlatAlliesBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatAlliesBonus

; 6831 : 			int iNewFaith = GetFaithFlatAlliesBonus(ePlayer, eNewEra);

	push	ebx
	push	edi
	mov	ecx, esi
	mov	ebp, eax
	call	?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatAlliesBonus
$LN77@DoMajorCiv:

; 6832 : 
; 6833 : 			if(iOldFaith != iNewFaith)

	cmp	ebp, eax
	je	SHORT $LN73@DoMajorCiv

; 6834 : 			{
; 6835 : 				bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$[esp+20], 1
$LN73@DoMajorCiv:
	pop	edi
	pop	ebp
	pop	ebx
$LN68@DoMajorCiv:

; 6836 : 			}
; 6837 : 		}
; 6838 : 	}
; 6839 : 
; 6840 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6841 : 	if(bSomethingChanged)
; 6842 : 		GET_PLAYER(ePlayer).doSelfConsistencyCheckAllCities();
; 6843 : #endif
; 6844 : 
; 6845 : 	return bSomethingChanged;

	mov	al, BYTE PTR _bSomethingChanged$[esp+8]
	pop	esi

; 6846 : }

	pop	ecx
	ret	8
?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z ENDP ; CvMinorCivAI::DoMajorCivEraChange
_TEXT	ENDS
PUBLIC	?GetScienceFriendshipBonus@CvMinorCivAI@@QAEHXZ	; CvMinorCivAI::GetScienceFriendshipBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetScienceFriendshipBonus@CvMinorCivAI@@QAEHXZ
_TEXT	SEGMENT
?GetScienceFriendshipBonus@CvMinorCivAI@@QAEHXZ PROC	; CvMinorCivAI::GetScienceFriendshipBonus, COMDAT
; _this$ = ecx

; 6851 : 	int iResult = GetScienceFriendshipBonusTimes100();

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+44]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2860
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 6852 : 	iResult /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 6853 : 
; 6854 : 	return iResult;
; 6855 : }

	ret	0
?GetScienceFriendshipBonus@CvMinorCivAI@@QAEHXZ ENDP	; CvMinorCivAI::GetScienceFriendshipBonus
_TEXT	ENDS
PUBLIC	?GetCurrentCultureFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentCultureFlatBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentCultureFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentCultureFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentCultureFlatBonus, COMDAT
; _this$ = ecx

; 6944 : {

	push	esi

; 6945 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 6946 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 6947 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	mov	esi, DWORD PTR _ePlayer$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, 63					; 0000003fH
	ja	$LN6@GetCurrent@2

; 6948 : 
; 6949 : 	// Don't give a bonus to a minor civ player
; 6950 : 	if(ePlayer >= MAX_MAJOR_CIVS)

	cmp	esi, 22					; 00000016H

; 6951 : 		return 0;

	jge	$LN6@GetCurrent@2

; 6952 : 
; 6953 : 	// Only give a bonus if we are Cultural trait
; 6954 : 	if(GetTrait() != MINOR_CIV_TRAIT_CULTURED)

	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	test	eax, eax

; 6955 : 		return 0;

	jne	$LN6@GetCurrent@2
	push	ebx

; 6956 : 
; 6957 : 	int iAmount = 0;

	xor	ebx, ebx

; 6958 : 
; 6959 : 	if(IsAllies(ePlayer))

	cmp	DWORD PTR [edi+2012], esi
	jne	SHORT $LN3@GetCurrent@2

; 6960 : 		iAmount += GetCultureFlatAlliesBonus(ePlayer);

	push	-1
	push	esi
	mov	ecx, edi
	call	?GetCultureFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatAlliesBonus
	mov	ebx, eax
$LN3@GetCurrent@2:

; 6961 : 
; 6962 : 	if(IsFriends(ePlayer))

	push	esi
	mov	ecx, edi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN2@GetCurrent@2

; 6963 : 		iAmount += GetCultureFlatFriendshipBonus(ePlayer);

	push	-1
	push	esi
	mov	ecx, edi
	call	?GetCultureFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetCultureFlatFriendshipBonus
	add	ebx, eax
$LN2@GetCurrent@2:

; 6964 : 
; 6965 : 	// Modify the bonus if called for by our trait
; 6966 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier(); 

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 6967 : 	
; 6968 : 	//NQMP GJS - Patronage Finisher
; 6969 : 	iModifier += GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_BONUS_MODIFIER);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR [eax+88]
	add	ecx, esi
	push	60					; 0000003cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax

; 6970 : 
; 6971 : 	if(iModifier > 0)

	test	edi, edi
	jle	SHORT $LN1@GetCurrent@2

; 6972 : 	{
; 6973 : 		iAmount *= (iModifier + 100);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, ebx

; 6974 : 		iAmount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
$LN1@GetCurrent@2:

; 6975 : 	}
; 6976 : 
; 6977 : 	return iAmount;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 6978 : }

	ret	4
$LN6@GetCurrent@2:
	pop	edi

; 6945 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 6946 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 6947 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	xor	eax, eax
	pop	esi

; 6978 : }

	ret	4
?GetCurrentCultureFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentCultureFlatBonus
_TEXT	ENDS
PUBLIC	?GetCurrentCulturePerBuildingBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentCulturePerBuildingBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentCulturePerBuildingBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentCulturePerBuildingBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentCulturePerBuildingBonus, COMDAT
; _this$ = ecx

; 6996 : {

	push	esi

; 6997 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 6998 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 6999 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	mov	esi, DWORD PTR _ePlayer$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN6@GetCurrent@3

; 7000 : 
; 7001 : 	// Don't give a bonus to a minor civ player
; 7002 : 	if(ePlayer >= MAX_MAJOR_CIVS)

	cmp	esi, 22					; 00000016H

; 7003 : 		return 0;

	jge	SHORT $LN6@GetCurrent@3

; 7004 : 
; 7005 : 	// Only give a bonus if we are Cultural trait
; 7006 : 	if(GetTrait() != MINOR_CIV_TRAIT_CULTURED)

	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	test	eax, eax

; 7007 : 		return 0;

	jne	SHORT $LN6@GetCurrent@3

; 7008 : 
; 7009 : 	int iAmount = 0;
; 7010 : 
; 7011 : 	if(IsAllies(ePlayer))
; 7012 : 		iAmount += GetCulturePerBuildingAlliesBonus(ePlayer);
; 7013 : 
; 7014 : 	if(IsFriends(ePlayer))

	push	esi
	mov	ecx, edi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends

; 7015 : 		iAmount += GetCulturePerBuildingFriendshipBonus(ePlayer);
; 7016 : 
; 7017 : 	// Modify the bonus if called for by our trait
; 7018 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier();

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
$LN6@GetCurrent@3:
	pop	edi
	xor	eax, eax
	pop	esi

; 7019 : 	if(iModifier > 0)
; 7020 : 	{
; 7021 : 		iAmount *= (iModifier + 100);
; 7022 : 		iAmount /= 100;
; 7023 : 	}
; 7024 : 
; 7025 : 	return iAmount;
; 7026 : }

	ret	4
?GetCurrentCulturePerBuildingBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentCulturePerBuildingBonus
_TEXT	ENDS
PUBLIC	?GetCurrentCultureBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentCultureBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentCultureBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentCultureBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentCultureBonus, COMDAT
; _this$ = ecx

; 7029 : {

	push	esi
	push	edi

; 7030 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7031 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7032 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN1@GetCurrent@4
	push	ebx

; 7033 : 
; 7034 : 	int iAmount = 0;
; 7035 : 
; 7036 : 	iAmount += GetCurrentCultureFlatBonus(ePlayer);

	push	edi
	call	?GetCurrentCultureFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentCultureFlatBonus

; 7037 : 	iAmount += GetCurrentCulturePerBuildingBonus(ePlayer); //antonjs: This feature was prototyped, but later removed. Its value is 0 (no bonus).

	push	edi
	mov	ecx, esi
	mov	ebx, eax
	call	?GetCurrentCulturePerBuildingBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentCulturePerBuildingBonus
	add	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 7038 : 
; 7039 : 	return iAmount;
; 7040 : }

	ret	4
$LN1@GetCurrent@4:
	pop	edi

; 7030 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7031 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7032 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	xor	eax, eax
	pop	esi

; 7038 : 
; 7039 : 	return iAmount;
; 7040 : }

	ret	4
?GetCurrentCultureBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentCultureBonus
_TEXT	ENDS
PUBLIC	?GetCurrentHappinessFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentHappinessFlatBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentHappinessFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentHappinessFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentHappinessFlatBonus, COMDAT
; _this$ = ecx

; 7090 : {

	push	esi
	push	edi

; 7091 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7092 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7093 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN5@GetCurrent@5

; 7094 : 
; 7095 : 	// Minor civ players do not get a bonus
; 7096 : 	if(ePlayer >= MAX_MAJOR_CIVS)

	cmp	edi, 22					; 00000016H

; 7097 : 		return 0;

	jge	SHORT $LN5@GetCurrent@5

; 7098 : 
; 7099 : 	// Only for Mercantile trait minors
; 7100 : 	if(GetTrait() != MINOR_CIV_TRAIT_MERCANTILE)

	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	cmp	eax, 3

; 7101 : 		return 0;

	jne	SHORT $LN5@GetCurrent@5
	push	ebx

; 7102 : 
; 7103 : 	int iAmount = 0;

	xor	ebx, ebx

; 7104 : 	if(IsAllies(ePlayer))

	cmp	DWORD PTR [esi+2012], edi
	jne	SHORT $LN2@GetCurrent@5

; 7105 : 		iAmount += GetHappinessFlatAlliesBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetHappinessFlatAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatAlliesBonus
	mov	ebx, eax
$LN2@GetCurrent@5:

; 7106 : 	if(IsFriends(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN1@GetCurrent@5

; 7107 : 		iAmount += GetHappinessFlatFriendshipBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetHappinessFlatFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessFlatFriendshipBonus
	add	ebx, eax
$LN1@GetCurrent@5:

; 7108 : 	return iAmount;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 7109 : }

	ret	4
$LN5@GetCurrent@5:
	pop	edi

; 7091 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7092 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7093 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	xor	eax, eax
	pop	esi

; 7109 : }

	ret	4
?GetCurrentHappinessFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentHappinessFlatBonus
_TEXT	ENDS
PUBLIC	?GetCurrentHappinessPerLuxuryBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentHappinessPerLuxuryBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentHappinessPerLuxuryBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentHappinessPerLuxuryBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentHappinessPerLuxuryBonus, COMDAT
; _this$ = ecx

; 7201 : {

	push	esi
	push	edi

; 7202 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7203 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7204 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN5@GetCurrent@6

; 7205 : 
; 7206 : 	// Minor civ players do not get a bonus
; 7207 : 	if(ePlayer >= MAX_MAJOR_CIVS)

	cmp	edi, 22					; 00000016H

; 7208 : 		return 0;

	jge	SHORT $LN5@GetCurrent@6

; 7209 : 
; 7210 : 	// Only for Mercantile trait minors
; 7211 : 	if(GetTrait() != MINOR_CIV_TRAIT_MERCANTILE)

	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	cmp	eax, 3

; 7212 : 		return 0;

	jne	SHORT $LN5@GetCurrent@6
	push	ebx

; 7213 : 
; 7214 : 	int iAmount = 0;

	xor	ebx, ebx

; 7215 : 	if(IsAllies(ePlayer))

	cmp	DWORD PTR [esi+2012], edi
	jne	SHORT $LN2@GetCurrent@6

; 7216 : 		iAmount += GetHappinessPerLuxuryAlliesBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetHappinessPerLuxuryAlliesBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryAlliesBonus
	mov	ebx, eax
$LN2@GetCurrent@6:

; 7217 : 	if(IsFriends(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN1@GetCurrent@6

; 7218 : 		iAmount += GetHappinessPerLuxuryFriendshipBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetHappinessPerLuxuryFriendshipBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetHappinessPerLuxuryFriendshipBonus
	add	ebx, eax
$LN1@GetCurrent@6:

; 7219 : 	return iAmount;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 7220 : }

	ret	4
$LN5@GetCurrent@6:
	pop	edi

; 7202 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7203 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7204 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	xor	eax, eax
	pop	esi

; 7220 : }

	ret	4
?GetCurrentHappinessPerLuxuryBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentHappinessPerLuxuryBonus
_TEXT	ENDS
PUBLIC	?GetCurrentHappinessBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentHappinessBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentHappinessBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentHappinessBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentHappinessBonus, COMDAT
; _this$ = ecx

; 7224 : {

	push	ebx
	push	esi
	push	edi

; 7225 : 	int iValue = 0;
; 7226 : 
; 7227 : 	iValue += GetCurrentHappinessFlatBonus(ePlayer);

	mov	edi, DWORD PTR _ePlayer$[esp+8]
	push	edi
	mov	esi, ecx
	call	?GetCurrentHappinessFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentHappinessFlatBonus

; 7228 : 	iValue += GetCurrentHappinessPerLuxuryBonus(ePlayer);

	push	edi
	mov	ecx, esi
	mov	ebx, eax
	call	?GetCurrentHappinessPerLuxuryBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentHappinessPerLuxuryBonus
	pop	edi
	pop	esi
	add	eax, ebx
	pop	ebx

; 7229 : 
; 7230 : 	return iValue;
; 7231 : }

	ret	4
?GetCurrentHappinessBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentHappinessBonus
_TEXT	ENDS
PUBLIC	?GetCurrentFaithFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentFaithFlatBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentFaithFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentFaithFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentFaithFlatBonus, COMDAT
; _this$ = ecx

; 7326 : {

	push	esi

; 7327 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7328 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7329 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	mov	esi, DWORD PTR _ePlayer$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, 63					; 0000003fH
	ja	$LN6@GetCurrent@7

; 7330 : 
; 7331 : 	// Minor civ players do not get a bonus
; 7332 : 	if(ePlayer >= MAX_MAJOR_CIVS)

	cmp	esi, 22					; 00000016H

; 7333 : 		return 0;

	jge	$LN6@GetCurrent@7

; 7334 : 
; 7335 : 	// Only for Religious trait minors
; 7336 : 	if(GetTrait() != MINOR_CIV_TRAIT_RELIGIOUS)

	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	cmp	eax, 4

; 7337 : 		return 0;

	jne	$LN6@GetCurrent@7
	push	ebx

; 7338 : 
; 7339 : 	int iAmount = 0;

	xor	ebx, ebx

; 7340 : 	if(IsAllies(ePlayer))

	cmp	DWORD PTR [edi+2012], esi
	jne	SHORT $LN3@GetCurrent@7

; 7341 : 		iAmount += GetFaithFlatAlliesBonus(ePlayer);

	push	-1
	push	esi
	mov	ecx, edi
	call	?GetFaithFlatAlliesBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatAlliesBonus
	mov	ebx, eax
$LN3@GetCurrent@7:

; 7342 : 	if(IsFriends(ePlayer))

	push	esi
	mov	ecx, edi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN2@GetCurrent@7

; 7343 : 		iAmount += GetFaithFlatFriendshipBonus(ePlayer);

	push	-1
	push	esi
	mov	ecx, edi
	call	?GetFaithFlatFriendshipBonus@CvMinorCivAI@@QBEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFaithFlatFriendshipBonus
	add	ebx, eax
$LN2@GetCurrent@7:

; 7344 : 
; 7345 : 	// Modify the bonus if called for by our trait
; 7346 : 	int iModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetCityStateBonusModifier(); 

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 7347 : 	
; 7348 : 	//NQMP GJS - Patronage Finisher
; 7349 : 	iModifier += GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_BONUS_MODIFIER);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR [eax+88]
	add	ecx, esi
	push	60					; 0000003cH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	edi, eax

; 7350 : 
; 7351 : 	if(iModifier > 0)

	test	edi, edi
	jle	SHORT $LN1@GetCurrent@7

; 7352 : 	{
; 7353 : 		iAmount *= (iModifier + 100);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, ebx

; 7354 : 		iAmount /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
$LN1@GetCurrent@7:

; 7355 : 	}
; 7356 : 
; 7357 : 	return iAmount;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 7358 : }

	ret	4
$LN6@GetCurrent@7:
	pop	edi

; 7327 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7328 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7329 : 	if(ePlayer < 0 || ePlayer >= MAX_PLAYERS) return 0;

	xor	eax, eax
	pop	esi

; 7358 : }

	ret	4
?GetCurrentFaithFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentFaithFlatBonus
_TEXT	ENDS
PUBLIC	?GetCurrentFaithBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentFaithBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentFaithBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentFaithBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentFaithBonus, COMDAT
; _this$ = ecx

; 7363 : 	int iValue = 0;
; 7364 : 
; 7365 : 	iValue += GetCurrentFaithFlatBonus(ePlayer);

	jmp	?GetCurrentFaithFlatBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentFaithFlatBonus
?GetCurrentFaithBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentFaithBonus
_TEXT	ENDS
PUBLIC	?GetCurrentCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentCapitalFoodBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentCapitalFoodBonus, COMDAT
; _this$ = ecx

; 7480 : {

	push	esi
	mov	esi, ecx

; 7481 : 	// This guy isn't Maritime
; 7482 : 	if(GetTrait() != MINOR_CIV_TRAIT_MARITIME)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN19@GetCurrent@8
	cmp	DWORD PTR [eax+272], 2
	je	SHORT $LN3@GetCurrent@8
$LN19@GetCurrent@8:

; 7483 : 		return 0;

	xor	eax, eax
	pop	esi

; 7500 : }

	ret	4
$LN3@GetCurrent@8:
	push	ebx
	push	edi

; 7484 : 
; 7485 : 	int iAmount = 0;
; 7486 : 
; 7487 : 	if(IsAllies(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+8]
	xor	ebx, ebx
	cmp	DWORD PTR [esi+2012], edi
	jne	SHORT $LN2@GetCurrent@8

; 7488 : 	{
; 7489 : 		iAmount += GetAlliesCapitalFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesCapitalFoodBonus

; 7490 : 		iAmount += GetAlliesOtherCityFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	mov	ebx, eax
	call	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus
	add	ebx, eax
$LN2@GetCurrent@8:

; 7491 : 	}
; 7492 : 
; 7493 : 	if(IsFriends(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN1@GetCurrent@8

; 7494 : 	{
; 7495 : 		iAmount += GetFriendsCapitalFoodBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsCapitalFoodBonus

; 7496 : 		iAmount += GetFriendsOtherCityFoodBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	add	ebx, eax
	call	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus
	add	ebx, eax
$LN1@GetCurrent@8:
	pop	edi

; 7497 : 	}
; 7498 : 
; 7499 : 	return iAmount;

	mov	eax, ebx
	pop	ebx
	pop	esi

; 7500 : }

	ret	4
?GetCurrentCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentCapitalFoodBonus
_TEXT	ENDS
PUBLIC	?GetCurrentOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentOtherCityFoodBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentOtherCityFoodBonus, COMDAT
; _this$ = ecx

; 7504 : {

	push	esi
	mov	esi, ecx

; 7505 : 	// This guy isn't Maritime
; 7506 : 	if(GetTrait() != MINOR_CIV_TRAIT_MARITIME)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN19@GetCurrent@9
	cmp	DWORD PTR [eax+272], 2
	je	SHORT $LN3@GetCurrent@9
$LN19@GetCurrent@9:

; 7507 : 		return 0;

	xor	eax, eax
	pop	esi

; 7518 : }

	ret	4
$LN3@GetCurrent@9:
	push	ebx
	push	edi

; 7508 : 
; 7509 : 	int iAmount = 0;
; 7510 : 
; 7511 : 	if(IsAllies(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+8]
	xor	ebx, ebx
	cmp	DWORD PTR [esi+2012], edi
	jne	SHORT $LN2@GetCurrent@9

; 7512 : 		iAmount += GetAlliesOtherCityFoodBonus(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus
	mov	ebx, eax
$LN2@GetCurrent@9:

; 7513 : 
; 7514 : 	if(IsFriends(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN1@GetCurrent@9

; 7515 : 		iAmount += GetFriendsOtherCityFoodBonus(ePlayer);

	push	-1
	push	edi
	mov	ecx, esi
	call	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus
	add	ebx, eax
$LN1@GetCurrent@9:
	pop	edi

; 7516 : 
; 7517 : 	return iAmount;

	mov	eax, ebx
	pop	ebx
	pop	esi

; 7518 : }

	ret	4
?GetCurrentOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentOtherCityFoodBonus
_TEXT	ENDS
PUBLIC	?IsUnitSpawningAllowed@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsUnitSpawningAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnitSpawningAllowed@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsUnitSpawningAllowed@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::IsUnitSpawningAllowed, COMDAT
; _this$ = ecx

; 7573 : {

	push	esi
	push	edi

; 7574 : 	// Must have met ePlayer
; 7575 : 	if(!IsHasMetPlayer(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	push	edi
	mov	esi, ecx
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	jne	SHORT $LN6@IsUnitSpaw@2
$LN32@IsUnitSpaw@2:
	pop	edi

; 7576 : 		return false;

	xor	al, al
	pop	esi

; 7596 : 		return false;
; 7597 : 
; 7598 : 	return true;
; 7599 : }

	ret	4
$LN6@IsUnitSpaw@2:

; 7577 : 
; 7578 : 	// Must be Militaristic
; 7579 : 	if(GetTrait() != MINOR_CIV_TRAIT_MILITARISTIC)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN32@IsUnitSpaw@2
	cmp	DWORD PTR [eax+272], 1

; 7580 : 		return false;

	jne	SHORT $LN32@IsUnitSpaw@2

; 7581 : 
; 7582 : 	// Can't be at war!
; 7583 : 	if(IsAtWarWithPlayersTeam(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al

; 7584 : 		return false;

	jne	SHORT $LN32@IsUnitSpaw@2

; 7585 : 
; 7586 : 	// Must be Friends
; 7587 : 	if(!IsFriends(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al

; 7588 : 		return false;

	je	SHORT $LN32@IsUnitSpaw@2

; 7589 : 
; 7590 : 	// We must be alive
; 7591 : 	if(!GetPlayer()->isAlive())

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+2256], 0

; 7592 : 		return false;

	je	SHORT $LN32@IsUnitSpaw@2

; 7593 : 
; 7594 : 	// They must be alive
; 7595 : 	if(!GET_PLAYER(ePlayer).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edi, 63236				; 0000f704H
	cmp	BYTE PTR [edi+edx+2256], 0
	pop	edi
	setne	al
	pop	esi

; 7596 : 		return false;
; 7597 : 
; 7598 : 	return true;
; 7599 : }

	ret	4
?IsUnitSpawningAllowed@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::IsUnitSpawningAllowed
_TEXT	ENDS
PUBLIC	?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetSpawnBaseTurns
EXTRN	?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::HasCommonEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetSpawnBaseTurns, COMDAT
; _this$ = ecx

; 7762 : {

	push	ebx
	push	esi

; 7763 : 	// Not friends
; 7764 : 	if(!IsFriends(ePlayer))

	mov	esi, DWORD PTR _ePlayer$[esp+4]
	mov	ebx, ecx
	cmp	esi, 21					; 00000015H
	ja	SHORT $LN13@GetSpawnBa
	push	esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN12@GetSpawnBa
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN15@GetSpawnBa
$LN12@GetSpawnBa:
	mov	ecx, DWORD PTR [ebx+esi*4+2024]
	jmp	SHORT $LN15@GetSpawnBa
$LN13@GetSpawnBa:
	xor	ecx, ecx
$LN15@GetSpawnBa:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	jge	SHORT $LN5@GetSpawnBa
$LN72@GetSpawnBa:
	pop	esi

; 7765 : 		return 0;

	xor	eax, eax
	pop	ebx

; 7794 : }

	ret	4
$LN5@GetSpawnBa:

; 7766 : 
; 7767 : 	// This guy isn't militaristic
; 7768 : 	if(GetTrait() != MINOR_CIV_TRAIT_MILITARISTIC)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN72@GetSpawnBa
	cmp	DWORD PTR [eax+272], 1

; 7769 : 		return 0;

	jne	SHORT $LN72@GetSpawnBa
	push	ebp
	push	edi

; 7770 : 
; 7771 : 	int iNumTurns = /*19*/ GC.getFRIENDS_BASE_TURNS_UNIT_SPAWN() * 100;

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2912
	imul	edi, 100				; 00000064H

; 7772 : 
; 7773 : 	// If relations are at allied level then reduce spawn counter
; 7774 : 	if(IsAllies(ePlayer))

	cmp	DWORD PTR [ebx+2012], esi
	jne	SHORT $LN3@GetSpawnBa

; 7775 : 		iNumTurns += /*-3*/ (GC.getALLIES_EXTRA_TURNS_UNIT_SPAWN() * 100);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2920
	imul	edx, 100				; 00000064H
	add	edi, edx
$LN3@GetSpawnBa:

; 7776 : 
; 7777 : 	// Modify for Game Speed
; 7778 : 	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getGreatPeoplePercent

; 7779 : 	iNumTurns /= 100;
; 7780 : 
; 7781 : 	// Modify for policies
; 7782 : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH

; 7783 : 	int iPolicyMod = kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_UNIT_FREQUENCY_MODIFIER);

	push	16					; 00000010H
	mov	ecx, esi
	add	edi, edx
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ebp, eax

; 7784 : 	if(iPolicyMod > 0)

	test	ebp, ebp
	jle	SHORT $LN1@GetSpawnBa

; 7785 : 	{
; 7786 : 		if(GET_TEAM(kPlayer.getTeam()).HasCommonEnemy(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN55@GetSpawnBa
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN56@GetSpawnBa
$LN55@GetSpawnBa:
	or	ecx, -1
$LN56@GetSpawnBa:
	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN64@GetSpawnBa
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN65@GetSpawnBa
$LN64@GetSpawnBa:
	or	eax, -1
$LN65@GetSpawnBa:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasCommonEnemy
	test	al, al
	je	SHORT $LN1@GetSpawnBa

; 7787 : 		{
; 7788 : 			iNumTurns *= 100;

	mov	eax, edi
	imul	eax, 100				; 00000064H

; 7789 : 			iNumTurns /= (100 + iPolicyMod);

	cdq
	add	ebp, 100				; 00000064H
	idiv	ebp
	mov	edi, eax
$LN1@GetSpawnBa:

; 7790 : 		}
; 7791 : 	}
; 7792 : 
; 7793 : 	return iNumTurns / 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	pop	edi
	sar	edx, 5
	pop	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 7794 : }

	ret	4
?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetSpawnBaseTurns
_TEXT	ENDS
PUBLIC	?GetCurrentSpawnEstimate@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetCurrentSpawnEstimate
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentSpawnEstimate@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetCurrentSpawnEstimate@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetCurrentSpawnEstimate, COMDAT
; _this$ = ecx

; 7798 : {

	push	esi
	push	edi

; 7799 : 	// Not friends
; 7800 : 	if(!IsFriends(ePlayer))

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN10@GetCurrent@10
	push	edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN9@GetCurrent@10
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN12@GetCurrent@10
$LN9@GetCurrent@10:
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN12@GetCurrent@10
$LN10@GetCurrent@10:
	xor	ecx, ecx
$LN12@GetCurrent@10:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	jge	SHORT $LN2@GetCurrent@10
$LN41@GetCurrent@10:
	pop	edi

; 7801 : 		return 0;

	xor	eax, eax
	pop	esi

; 7813 : }

	ret	4
$LN2@GetCurrent@10:

; 7802 : 
; 7803 : 	// This guy isn't militaristic
; 7804 : 	if(GetTrait() != MINOR_CIV_TRAIT_MILITARISTIC)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN41@GetCurrent@10
	cmp	DWORD PTR [eax+272], 1

; 7805 : 		return 0;

	jne	SHORT $LN41@GetCurrent@10

; 7806 : 
; 7807 : 	int iNumTurns = GetSpawnBaseTurns(ePlayer) * 100;

	push	edi
	mov	ecx, esi
	call	?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetSpawnBaseTurns
	mov	esi, eax

; 7808 : 
; 7809 : 	int iRand = /*3*/ GC.getFRIENDS_RAND_TURNS_UNIT_SPAWN() * 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2916
	imul	esi, 100				; 00000064H
	imul	eax, 100				; 00000064H

; 7810 : 	iNumTurns += (iRand / 2);

	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	add	ecx, esi

; 7811 : 
; 7812 : 	return iNumTurns / 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	edi
	add	eax, edx
	pop	esi

; 7813 : }

	ret	4
?GetCurrentSpawnEstimate@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetCurrentSpawnEstimate
_TEXT	ENDS
PUBLIC	?GetFriendshipFromUnitGift@CvMinorCivAI@@QAEHW4PlayerTypes@@_N1@Z ; CvMinorCivAI::GetFriendshipFromUnitGift
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendshipFromUnitGift@CvMinorCivAI@@QAEHW4PlayerTypes@@_N1@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
_bGreatPerson$ = 12					; size = 1
___formal$ = 16						; size = 1
?GetFriendshipFromUnitGift@CvMinorCivAI@@QAEHW4PlayerTypes@@_N1@Z PROC ; CvMinorCivAI::GetFriendshipFromUnitGift, COMDAT
; _this$ = ecx

; 8985 : 	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
; 8986 : 	CvAssertMsg(eFromPlayer < MAX_MAJOR_CIVS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
; 8987 : 	if (eFromPlayer < 0 || eFromPlayer >= MAX_MAJOR_CIVS) return 0;

	mov	eax, DWORD PTR _eFromPlayer$[esp-4]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN6@GetFriends@8
	push	esi

; 8988 : 
; 8989 : 	int iInfluence = 0;
; 8990 : 	CvPlayer& kFromPlayer = GET_PLAYER(eFromPlayer);

	mov	esi, eax
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	edi, edi

; 8991 : 
; 8992 : 	// Influence
; 8993 : 	if (bGreatPerson)

	cmp	BYTE PTR _bGreatPerson$[esp+4], 0
	je	SHORT $LN5@GetFriends@8

; 8994 : 	{
; 8995 : 		int iGPInfluence = kFromPlayer.GetPlayerTraits()->GetGreatPersonGiftInfluence();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+60]

; 8996 : 		if (iGPInfluence > 0)

	test	eax, eax
	jle	SHORT $LN1@GetFriends@8

; 8997 : 		{
; 8998 : 			iInfluence += iGPInfluence;

	mov	edi, eax
	pop	edi
	pop	esi

; 9020 : }

	ret	12					; 0000000cH
$LN5@GetFriends@8:

; 8999 : 		}
; 9000 : 	}
; 9001 : 	else
; 9002 : 	{
; 9003 : 		iInfluence += GC.getFRIENDSHIP_PER_UNIT_GIFTED();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3168

; 9004 : 
; 9005 : 		// War state
; 9006 : 		if (IsProxyWarActiveForMajor(eFromPlayer))

	push	eax
	call	?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsProxyWarActiveForMajor
	test	al, al
	je	SHORT $LN2@GetFriends@8

; 9007 : 		{
; 9008 : 			iInfluence += GC.getFRIENDSHIP_PER_UNIT_GIFTED();

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3168
$LN2@GetFriends@8:

; 9009 : 		}
; 9010 : 		
; 9011 : 		// Policies
; 9012 : 		int iMilitaryInfluence = kFromPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_MILITARY_UNIT_GIFT_INFLUENCE);

	push	36					; 00000024H
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 9013 : 		if (iMilitaryInfluence > 0)

	test	eax, eax
	jle	SHORT $LN1@GetFriends@8

; 9014 : 		{
; 9015 : 			iInfluence += iMilitaryInfluence;

	add	edi, eax
$LN1@GetFriends@8:

; 9016 : 		}
; 9017 : 	}
; 9018 : 
; 9019 : 	return iInfluence;

	mov	eax, edi
	pop	edi
	pop	esi

; 9020 : }

	ret	12					; 0000000cH
$LN6@GetFriends@8:

; 8985 : 	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
; 8986 : 	CvAssertMsg(eFromPlayer < MAX_MAJOR_CIVS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
; 8987 : 	if (eFromPlayer < 0 || eFromPlayer >= MAX_MAJOR_CIVS) return 0;

	xor	eax, eax

; 9020 : }

	ret	12					; 0000000cH
?GetFriendshipFromUnitGift@CvMinorCivAI@@QAEHW4PlayerTypes@@_N1@Z ENDP ; CvMinorCivAI::GetFriendshipFromUnitGift
_TEXT	ENDS
PUBLIC	?CanMajorGiftTileImprovement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorGiftTileImprovement
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorGiftTileImprovement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?CanMajorGiftTileImprovement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorGiftTileImprovement, COMDAT
; _this$ = ecx

; 9190 : {

	push	ebx
	push	ebp

; 9191 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9192 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9193 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	ebp, DWORD PTR _eMajor$[esp+4]
	mov	ebx, ecx
	cmp	ebp, 21					; 00000015H
	ja	SHORT $LN9@CanMajorGi

; 9194 : 	CvPlayer* pPlayer = &GET_PLAYER(eMajor);

	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 9195 : 	if(pPlayer == NULL)

	jne	SHORT $LN8@CanMajorGi
$LN9@CanMajorGi:
	pop	ebp

; 9196 : 	{
; 9197 : 		CvAssertMsg(false, "pPlayer not expected to be NULL. Please send Anton your save file and version.");
; 9198 : 		return false;

	xor	al, al
	pop	ebx

; 9229 : }

	ret	4
$LN8@CanMajorGi:
	push	esi

; 9199 : 	}
; 9200 : 
; 9201 : 	// Must have enough gold
; 9202 : 	const int iCost = GetGiftTileImprovementCost(eMajor);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7324

; 9203 : 	if(pPlayer->GetTreasury()->GetGold() < iCost)

	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	cmp	eax, esi
	jge	SHORT $LN7@CanMajorGi
	pop	esi
	pop	ebp

; 9204 : 		return false;

	xor	al, al
	pop	ebx

; 9229 : }

	ret	4
$LN7@CanMajorGi:

; 9205 : 
; 9206 : 	// Must own an improveable plot
; 9207 : 	bool bHasValidPlot = false;
; 9208 : 	CvPlotsVector& aiPlots = GetPlayer()->GetPlots();

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	edi, eax

; 9209 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	xor	esi, esi
	cmp	DWORD PTR [edi+4], esi
	jbe	SHORT $LN45@CanMajorGi
$LL46@CanMajorGi:

; 9210 : 	{
; 9211 : 		// at the end of the plot list
; 9212 : 		if(aiPlots[ui] == -1)

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+esi*4]
	cmp	eax, -1
	je	SHORT $LN45@CanMajorGi

; 9213 : 		{
; 9214 : 			break;
; 9215 : 		}
; 9216 : 
; 9217 : 		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	test	eax, eax
	jl	SHORT $LN33@CanMajorGi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN33@CanMajorGi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN34@CanMajorGi
$LN33@CanMajorGi:
	xor	eax, eax
$LN34@CanMajorGi:

; 9218 : 		if (IsLackingGiftableTileImprovementAtPlot(eMajor, pPlot->getX(), pPlot->getY()))

	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	ecx
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ; CvMinorCivAI::IsLackingGiftableTileImprovementAtPlot
	test	al, al
	jne	SHORT $LN1@CanMajorGi
	inc	esi
	cmp	esi, DWORD PTR [edi+4]
	jb	SHORT $LL46@CanMajorGi
$LN45@CanMajorGi:
	pop	edi
	pop	esi
	pop	ebp

; 9219 : 		{
; 9220 : 			bHasValidPlot = true;
; 9221 : 			break;
; 9222 : 		}
; 9223 : 	}
; 9224 : 
; 9225 : 	if (!bHasValidPlot)
; 9226 : 		return false;

	xor	al, al
	pop	ebx

; 9229 : }

	ret	4
$LN1@CanMajorGi:
	pop	edi
	pop	esi
	pop	ebp

; 9227 : 
; 9228 : 	return true;

	mov	al, 1
	pop	ebx

; 9229 : }

	ret	4
?CanMajorGiftTileImprovement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorGiftTileImprovement
_TEXT	ENDS
PUBLIC	?CanMajorGiftTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ; CvMinorCivAI::CanMajorGiftTileImprovementAtPlot
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorGiftTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?CanMajorGiftTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z PROC ; CvMinorCivAI::CanMajorGiftTileImprovementAtPlot, COMDAT
; _this$ = ecx

; 9274 : {

	push	esi
	push	edi

; 9275 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9276 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9277 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	edi, DWORD PTR _eMajor$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN1@CanMajorGi@2

; 9278 : 
; 9279 : 	return (CanMajorGiftTileImprovement(eMajor) && IsLackingGiftableTileImprovementAtPlot(eMajor, iPlotX, iPlotY));

	push	edi
	call	?CanMajorGiftTileImprovement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorGiftTileImprovement
	test	al, al
	je	SHORT $LN5@CanMajorGi@2
	mov	eax, DWORD PTR _iPlotY$[esp+4]
	mov	ecx, DWORD PTR _iPlotX$[esp+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ; CvMinorCivAI::IsLackingGiftableTileImprovementAtPlot
	test	al, al
	je	SHORT $LN5@CanMajorGi@2
	pop	edi
	mov	eax, 1
	pop	esi

; 9280 : }

	ret	12					; 0000000cH
$LN5@CanMajorGi@2:
	pop	edi

; 9278 : 
; 9279 : 	return (CanMajorGiftTileImprovement(eMajor) && IsLackingGiftableTileImprovementAtPlot(eMajor, iPlotX, iPlotY));

	xor	eax, eax
	pop	esi

; 9280 : }

	ret	12					; 0000000cH
$LN1@CanMajorGi@2:
	pop	edi

; 9275 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 9276 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 9277 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 9280 : }

	ret	12					; 0000000cH
?CanMajorGiftTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ENDP ; CvMinorCivAI::CanMajorGiftTileImprovementAtPlot
_TEXT	ENDS
PUBLIC	??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >
_TEXT	ENDS
PUBLIC	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_ui$229392 = -156					; size = 4
$T249177 = -152						; size = 4
$T249174 = -148						; size = 28
$T249173 = -120						; size = 28
_sName$229399 = -92					; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_veNames$ = 12						; size = 272
?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z PROC ; CvMinorCivAI::GetNamesListAsString, COMDAT
; _this$ = ecx

; 10121: {

	push	-1
	push	__ehhandler$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 144				; 00000090H
	push	ebp
	push	esi
	mov	DWORD PTR $T249177[esp+164], 0

; 10122: 	CvString s = "";

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+160]
	mov	esi, 1
	push	OFFSET $SG229390
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+176], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 10123: 	if (veNames.size() > 0)
; 10124: 	{
; 10125: 		for (uint ui = 0; ui < veNames.size(); ui++)
; 10126: 		{
; 10127: 			PlayerTypes ePlayerLoop = veNames[ui];
; 10128: 			CvPlayer* pPlayerLoop = &GET_PLAYER(ePlayerLoop);
; 10129: 			if (pPlayerLoop)
; 10130: 			{
; 10131: 				Localization::String sName = Localization::Lookup(pPlayerLoop->getCivilizationShortDescriptionKey());
; 10132: 				s = s + "[NEWLINE]" + sName.toUTF8();
; 10133: 			}
; 10134: 		}
; 10135: 	}
; 10136: 	return s;

	mov	edx, DWORD PTR _veNames$[esp+164]
	mov	DWORD PTR $T249177[esp+164], esi
	test	edx, edx
	jbe	$LN46@GetNamesLi
	xor	ecx, ecx
	mov	DWORD PTR _ui$229392[esp+164], ecx
	test	edx, edx
	jbe	$LN46@GetNamesLi
	push	ebx
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	push	edi
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	npad	12
$LL4@GetNamesLi:
	mov	eax, DWORD PTR _veNames$[esp+168]
	mov	eax, DWORD PTR [eax+ecx*4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	je	$LN3@GetNamesLi
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _sName$229399[esp+176]
	push	ecx
	call	ebx
	push	OFFSET $SG229403
	lea	edx, DWORD PTR $T249173[esp+184]
	push	ebp
	push	edx
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	edi
	add	esp, 20					; 00000014H
	mov	esi, eax
	lea	ecx, DWORD PTR _sName$229399[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 3
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T249174[esp+176]
	push	esi
	push	eax
	call	edi
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+180], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T249174[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T249173[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sName$229399[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	edx, DWORD PTR _veNames$[esp+172]
	mov	ecx, DWORD PTR _ui$229392[esp+172]
$LN3@GetNamesLi:
	inc	ecx
	mov	DWORD PTR _ui$229392[esp+172], ecx
	cmp	ecx, edx
	jb	$LL4@GetNamesLi
	pop	edi
	pop	ebx
$LN46@GetNamesLi:
	mov	eax, DWORD PTR _veNames$[esp+160]
	lea	ecx, DWORD PTR _veNames$[esp+172]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	cmp	eax, ecx
	je	SHORT $LN45@GetNamesLi
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN45@GetNamesLi:

; 10137: }

	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 156				; 0000009cH
	ret	276					; 00000114H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$0:
	lea	ecx, DWORD PTR _veNames$[ebp-4]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$1:
	mov	eax, DWORD PTR $T249177[ebp]
	and	eax, 1
	je	$LN10@GetNamesLi
	and	DWORD PTR $T249177[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN10@GetNamesLi:
	ret	0
__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$2:
	lea	ecx, DWORD PTR _sName$229399[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$3:
	lea	ecx, DWORD PTR $T249173[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z$4:
	lea	ecx, DWORD PTR $T249174[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ENDP ; CvMinorCivAI::GetNamesListAsString
PUBLIC	?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::at
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::at, COMDAT
; _this$ = ecx

; 753  : 		if (size() <= _Pos)

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	sub	edx, eax
	sar	edx, 2
	cmp	edx, ecx
	ja	SHORT $LN1@at

; 754  : 			_Xran();

	call	?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xran
$LN23@at:
$LN1@at:

; 755  : 		return (*(begin() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]

; 756  : 		}

	ret	4
$LN22@at:
?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::at
_TEXT	ENDS
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvMinorCivQuest,5,0,297,0>::~FStaticVector<CvMinorCivQuest,5,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::~FStaticVector<CvMinorCivQuest,5,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@16
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@16:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::~FStaticVector<CvMinorCivQuest,5,0,297,0>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z PROC ; FStaticVector<enum PlayerTypes,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+268], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ENDP ; FStaticVector<enum PlayerTypes,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4ResourceTypes@@@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4ResourceTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4ResourceTypes@@@Z PROC ; FStaticVector<enum ResourceTypes,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+268], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::GrowSize
$LN1@push_back@4:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@4
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4ResourceTypes@@@Z ENDP ; FStaticVector<enum ResourceTypes,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAEIABW4MinorCivQuestTypes@@@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAEIABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAEIABW4MinorCivQuestTypes@@@Z PROC ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+84], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@5

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::GrowSize
$LN1@push_back@5:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@5
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@5:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAEIABW4MinorCivQuestTypes@@@Z ENDP ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
$T249494 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+17], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jge	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jl	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 983  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	DWORD PTR $T249494[esp+8], eax
	lea	eax, DWORD PTR $T249494[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 983  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::find
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,64,1>::CvWeightedVector<enum PlayerTypes,64,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ PROC ; CvWeightedVector<enum PlayerTypes,64,1>::CvWeightedVector<enum PlayerTypes,64,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::CvWeightedVector<enum PlayerTypes,64,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,64,1>::~CvWeightedVector<enum PlayerTypes,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ PROC ; CvWeightedVector<enum PlayerTypes,64,1>::~CvWeightedVector<enum PlayerTypes,64,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::~CvWeightedVector<enum PlayerTypes,64,1>
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEIABW4PlayerTypes@@H@Z ; CvWeightedVector<enum PlayerTypes,64,1>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEIABW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEIABW4PlayerTypes@@H@Z PROC ; CvWeightedVector<enum PlayerTypes,64,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@6
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN5@push_back@6:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@6
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@6:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEIABW4PlayerTypes@@H@Z ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::push_back
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ		; CvWeightedVector<int,64,1>::CvWeightedVector<int,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC		; CvWeightedVector<int,64,1>::CvWeightedVector<int,64,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,64,1>::CvWeightedVector<int,64,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted@2:
	ret	0
??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z ; FStaticVector<enum BuildingTypes,50,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z PROC ; FStaticVector<enum BuildingTypes,50,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@7

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum BuildingTypes,50,1,297,0>::GrowSize
$LN1@push_back@7:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@7
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@7:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z ENDP ; FStaticVector<enum BuildingTypes,50,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAEIABW4UnitTypes@@@Z ; FStaticVector<enum UnitTypes,8,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAEIABW4UnitTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAEIABW4UnitTypes@@@Z PROC ; FStaticVector<enum UnitTypes,8,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+44], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@8

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum UnitTypes,8,1,297,0>::GrowSize
$LN1@push_back@8:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@8
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@8:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAEIABW4UnitTypes@@@Z ENDP ; FStaticVector<enum UnitTypes,8,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z ; FStaticVector<CvCity *,16,0,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z PROC ; FStaticVector<CvCity *,16,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+76], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@9

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCity *,16,0,297,0>::GrowSize
$LN1@push_back@9:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@9
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@9:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z ENDP ; FStaticVector<CvCity *,16,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,22,1>::CvWeightedVector<enum PlayerTypes,22,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ PROC ; CvWeightedVector<enum PlayerTypes,22,1>::CvWeightedVector<enum PlayerTypes,22,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::CvWeightedVector<enum PlayerTypes,22,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,22,1>::~CvWeightedVector<enum PlayerTypes,22,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ PROC ; CvWeightedVector<enum PlayerTypes,22,1>::~CvWeightedVector<enum PlayerTypes,22,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted@3:
	ret	0
??1?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::~CvWeightedVector<enum PlayerTypes,22,1>
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$0GE@$00@@QAE@XZ		; CvWeightedVector<int,100,1>::CvWeightedVector<int,100,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CvWeightedVector@H$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$0GE@$00@@QAE@XZ PROC		; CvWeightedVector<int,100,1>::CvWeightedVector<int,100,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 100			; 00000064H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$0GE@$00@@QAE@XZ ENDP		; CvWeightedVector<int,100,1>::CvWeightedVector<int,100,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$0GE@$00@@QAE@XZ		; CvWeightedVector<int,100,1>::~CvWeightedVector<int,100,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$0GE@$00@@QAE@XZ PROC		; CvWeightedVector<int,100,1>::~CvWeightedVector<int,100,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted@4:
	ret	0
??1?$CvWeightedVector@H$0GE@$00@@QAE@XZ ENDP		; CvWeightedVector<int,100,1>::~CvWeightedVector<int,100,1>
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pRet$249995 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [ebp+8], 0
	jne	SHORT $LN43@GrowSize@12
	mov	DWORD PTR [ebp+8], 1
$LN43@GrowSize@12:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp]
	cmp	edx, DWORD PTR [ebp+8]
	jb	SHORT $LN7@GrowSize@12
	npad	7
$LL8@GrowSize@12:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN38@GrowSize@12

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [ebp+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@12

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@12
$LN38@GrowSize@12:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [ebp+8], edx
$LN7@GrowSize@12:
	push	ebx
	push	esi

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	esi, DWORD PTR [ebp+8]
	cmp	esi, 5
	jbe	SHORT $LN15@GrowSize@12
	push	798					; 0000031eH
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$249995[esp+8], eax
	mov	DWORD PTR [ebp+8], esi
	jmp	SHORT $LN14@GrowSize@12
$LN15@GrowSize@12:
	lea	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR _pRet$249995[esp+8], ecx
	mov	DWORD PTR [ebp+8], 5
$LN14@GrowSize@12:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $LN1@GrowSize@12
	mov	eax, DWORD PTR _pRet$249995[esp+8]
	xor	edx, edx
	push	edi
$LL44@GrowSize@12:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN2@GrowSize@12
	mov	esi, DWORD PTR [ebp]
	add	esi, edx
	mov	ecx, 7
	mov	edi, eax
	rep movsd
$LN2@GrowSize@12:
	inc	ebx
	add	edx, 28					; 0000001cH
	add	eax, 28					; 0000001cH
	cmp	ebx, DWORD PTR [ebp+4]
	jb	SHORT $LL44@GrowSize@12
	pop	edi
$LN1@GrowSize@12:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebp]
	lea	edx, DWORD PTR [ebp+12]
	pop	esi
	pop	ebx
	cmp	eax, edx
	je	SHORT $LN42@GrowSize@12
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _pRet$249995[esp+4]
	add	esp, 4
	mov	DWORD PTR [ebp], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [ebp+152], 1
	pop	ebp

; 772  : 	};

	ret	4
$LN42@GrowSize@12:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _pRet$249995[esp]
	mov	DWORD PTR [ebp], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [ebp+152], 1
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
$T250060 = -80						; size = 28
$T250059 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 1073741822		; 3ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T250060[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T250059[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T250060[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T250059[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T250059[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T250059[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T250059[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@PAU342@00ABW4MinorCivQuestTypes@@D@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+16], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+16], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+16], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z$0:
	lea	ecx, DWORD PTR $T250060[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z$2:
	lea	ecx, DWORD PTR $T250059[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Insert
PUBLIC	??Fiterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@10

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN1@push_back@10:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@10
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@10:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z PROC ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+188], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@11

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::GrowSize
$LN1@push_back@11:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@11
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@11:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+812], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@12

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN1@push_back@12:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@12
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@12:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??_G?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEPAXI@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEPAXI@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN6@scalar@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN6@scalar@7:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN25@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEPAXI@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+17], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Init
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_ptr<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _func$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx

; 2032 : }

	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvString *,CvString *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN19@Unchecked_@2
$LL12@Unchecked_@2:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL12@Unchecked_@2
$LN19@Unchecked_@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum ResourceTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@stdext@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4ResourceTypes@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@stdext@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4ResourceTypes@@@3@@Z
_TEXT	SEGMENT
$T250797 = -4						; size = 1
__Cat$250801 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@stdext@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4ResourceTypes@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T250797[esp+4], 0
	mov	eax, DWORD PTR $T250797[esp+4]
	mov	ecx, DWORD PTR __Cat$250801[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@stdext@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@0PAW41@AAV?$allocator@W4ResourceTypes@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T250841 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$250838 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$250838[ebp], esi
	mov	DWORD PTR $T250841[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_fil:
	dec	edi
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil
$LL3@Uninit_fil:

; 407  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_fil:
$LN4@Uninit_fil:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_fil:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$250838[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250841[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:

; 234  : 		_Al.destroy(_First);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Tmp$251031 = -24					; size = 8
__Tmp$250960 = -16					; size = 8
__Tmp$250986 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$250960[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$250960[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$250986[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$250986[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$251031[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$251031[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$251031[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251031[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__Tmp$251239 = -24					; size = 8
__Tmp$251168 = -16					; size = 8
__Tmp$251194 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_@2
$LL27@Unguarded_@2:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_@2
	jg	SHORT $LN99@Unguarded_@2

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_@2
$LN99@Unguarded_@2:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_@2
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_@2:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_@2
	jg	SHORT $LN24@Unguarded_@2

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_@2
$LN24@Unguarded_@2:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_@2:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_@2
	npad	6
$LL21@Unguarded_@2:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_@2

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_@2

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_@2
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$251168[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$251168[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_@2:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_@2
$LN103@Unguarded_@2:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_@2
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_@2:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_@2

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_@2

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_@2
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$251194[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251194[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_@2:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_@2
$LN111@Unguarded_@2:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_@2:
	jne	SHORT $LN6@Unguarded_@2
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_@2

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_@2

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_@2
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_@2:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$251239[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$251239[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$251239[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251239[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_@2
$LN6@Unguarded_@2:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_@2
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_@2

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_@2:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_@2
$LN3@Unguarded_@2:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_@2
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_@2:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_@2
$LN105@Unguarded_@2:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::make_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap@2

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap@2:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__Tmp$251444 = -24					; size = 8
__Tmp$251373 = -16					; size = 8
__Tmp$251399 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Median<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_@3
$LL27@Unguarded_@3:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_@3
	jg	SHORT $LN99@Unguarded_@3

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_@3
$LN99@Unguarded_@3:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_@3
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_@3:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_@3
	jg	SHORT $LN24@Unguarded_@3

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_@3
$LN24@Unguarded_@3:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_@3:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_@3
	npad	6
$LL21@Unguarded_@3:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_@3

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_@3

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_@3
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$251373[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$251373[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_@3:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_@3
$LN103@Unguarded_@3:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_@3
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_@3:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_@3

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_@3

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_@3
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$251399[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251399[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_@3:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_@3
$LN111@Unguarded_@3:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_@3:
	jne	SHORT $LN6@Unguarded_@3
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_@3

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_@3

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_@3
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_@3:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_@3
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$251444[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$251444[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$251444[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251444[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_@3
$LN6@Unguarded_@3:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_@3
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_@3

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_@3:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_@3
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_@3
$LN3@Unguarded_@3:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_@3
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_@3:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_@3
$LN105@Unguarded_@3:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap@3

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap@3:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__Tmp$251652 = -24					; size = 8
__Tmp$251581 = -16					; size = 8
__Tmp$251607 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Median<CvWeightedVector<int,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_@4
$LL27@Unguarded_@4:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_@4
	jg	SHORT $LN99@Unguarded_@4

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_@4
$LN99@Unguarded_@4:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_@4
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_@4:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_@4
	jg	SHORT $LN24@Unguarded_@4

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_@4
$LN24@Unguarded_@4:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_@4:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_@4
	npad	6
$LL21@Unguarded_@4:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_@4

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_@4

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_@4
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$251581[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$251581[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_@4:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_@4
$LN103@Unguarded_@4:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_@4
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_@4:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_@4

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_@4

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_@4
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$251607[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251607[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_@4:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_@4
$LN111@Unguarded_@4:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_@4:
	jne	SHORT $LN6@Unguarded_@4
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_@4

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_@4

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_@4
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_@4:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_@4
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$251652[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$251652[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$251652[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$251652[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_@4
$LN6@Unguarded_@4:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_@4
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_@4

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_@4:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_@4
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_@4
$LN3@Unguarded_@4:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_@4
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_@4:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_@4
$LN105@Unguarded_@4:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::make_heap<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap@4

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap@4:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T251757 = -4						; size = 1
__Cat$251762 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T251757[esp+4], 0
	mov	eax, DWORD PTR $T251757[esp+4]
	mov	ecx, DWORD PTR __Cat$251762[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::pop_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::pop_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap@2

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap@2:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::pop_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap@3

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap@3:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::pop_heap<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap@4

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap@4:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ$0
__ehfuncinfo$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ
_TEXT	SEGMENT
$T252144 = -20						; size = 4
_iHighestValue$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ PROC ; CvMinorCivQuest::GetContestLeaders, COMDAT
; _this$ = ecx

; 302  : {

	push	-1
	push	__ehhandler$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	xor	ebx, ebx
	mov	DWORD PTR $T252144[esp+28], ebx
	push	esi

; 303  : 	MinorCivQuestTypes eType = GetType();
; 304  : 	CivsList veTiedForLead;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ebp, ecx
	push	edi
	mov	edi, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], 64			; 00000040H
	mov	DWORD PTR [esi], eax

; 318  : 		}
; 319  : 	}
; 320  : 
; 321  : 	return veTiedForLead;

	mov	DWORD PTR __$EHRec$[esp+44], ebx
	mov	DWORD PTR $T252144[esp+36], 1
	call	?GetContestValueForLeader@CvMinorCivQuest@@QAEHXZ ; CvMinorCivQuest::GetContestValueForLeader
	mov	DWORD PTR _iHighestValue$[esp+36], eax
	cmp	edi, 10					; 0000000aH
	je	SHORT $LN5@GetContest@5

; 305  : 	int iHighestValue = GetContestValueForLeader();
; 306  : 
; 307  : 	if(eType == MINOR_CIV_QUEST_CONTEST_CULTURE ||
; 308  : 	        eType == MINOR_CIV_QUEST_CONTEST_FAITH ||
; 309  : 	        eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	edi, 11					; 0000000bH
	je	SHORT $LN5@GetContest@5
	cmp	edi, 12					; 0000000cH
	jne	SHORT $LN30@GetContest@5
$LN5@GetContest@5:

; 310  : 	{
; 311  : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
$LL4@GetContest@5:

; 312  : 		{
; 313  : 			PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
; 314  : 			int iPlayerValue = GetContestValueForPlayer(ePlayerLoop);

	push	edi
	mov	ecx, ebp
	call	?GetContestValueForPlayer@CvMinorCivQuest@@QAEHW4PlayerTypes@@@Z ; CvMinorCivQuest::GetContestValueForPlayer

; 315  : 			CvAssertMsg(iPlayerValue <= iHighestValue, "Calculation error for calculating the leaders of a contest! Please send Anton your save file and version.");
; 316  : 			if(iPlayerValue == iHighestValue)

	cmp	eax, DWORD PTR _iHighestValue$[esp+36]
	jne	SHORT $LN3@GetContest@5

; 317  : 				veTiedForLead.push_back(ePlayerLoop);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+268], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN21@GetContest@5
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
$LN21@GetContest@5:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $LN24@GetContest@5
	mov	DWORD PTR [eax], edi
$LN24@GetContest@5:
	inc	DWORD PTR [esi+4]
$LN3@GetContest@5:

; 310  : 	{
; 311  : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	edi
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL4@GetContest@5
$LN30@GetContest@5:

; 322  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ$0:
	mov	eax, DWORD PTR $T252144[ebp]
	and	eax, 1
	je	$LN10@GetContest@5
	and	DWORD PTR $T252144[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
$LN10@GetContest@5:
	ret	0
__ehhandler$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ENDP ; CvMinorCivQuest::GetContestLeaders
PUBLIC	?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivQuest::IsContestLeader
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_veTiedForLead$221544 = -284				; size = 272
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivQuest::IsContestLeader, COMDAT
; _this$ = ecx

; 326  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 272				; 00000110H
	push	ebx

; 327  : 	if(ePlayer == NO_PLAYER)

	mov	ebx, DWORD PTR _ePlayer$[esp+284]
	push	esi
	push	edi
	mov	esi, ecx
	cmp	ebx, -1
	jne	SHORT $LN13@IsContestL

; 328  : 		ePlayer = GetPlayerAssignedTo();

	mov	ebx, DWORD PTR [esi+4]
$LN13@IsContestL:

; 329  : 
; 330  : 	MinorCivQuestTypes eType = GetType();
; 331  : 	CvPlayer* pMinor = &GET_PLAYER(GetMinor());

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [esi+8]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 332  : 	if(!pMinor)
; 333  : 	{
; 334  : 		CvAssertMsg(false, "Error when calculating contest standings - could not find minor civ! Please send Anton your save file and version.");
; 335  : 		return false;

	je	SHORT $LN41@IsContestL

; 336  : 	}
; 337  : 	// Player must actually be in the contest!
; 338  : 	if(!pMinor->GetMinorCivAI()->IsActiveQuestForPlayer(ePlayer, eType))

	push	edi
	push	ebx
	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al

; 339  : 		return false;

	je	SHORT $LN41@IsContestL

; 340  : 
; 341  : 	if(eType == MINOR_CIV_QUEST_CONTEST_CULTURE ||
; 342  : 	        eType == MINOR_CIV_QUEST_CONTEST_FAITH ||
; 343  : 	        eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	edi, 10					; 0000000aH
	je	SHORT $LN5@IsContestL
	cmp	edi, 11					; 0000000bH
	je	SHORT $LN5@IsContestL
	cmp	edi, 12					; 0000000cH
	jne	SHORT $LN41@IsContestL
$LN5@IsContestL:

; 344  : 	{
; 345  : 		CivsList veTiedForLead = GetContestLeaders();

	lea	eax, DWORD PTR _veTiedForLead$221544[esp+296]
	push	eax
	mov	ecx, esi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders

; 346  : 		for(uint ui = 0; ui < veTiedForLead.size(); ui++)

	mov	edx, DWORD PTR _veTiedForLead$221544[esp+300]
	mov	ecx, DWORD PTR _veTiedForLead$221544[esp+296]
	xor	eax, eax
	test	edx, edx
	jbe	SHORT $LN2@IsContestL
	npad	1
$LL4@IsContestL:

; 347  : 		{
; 348  : 			if(ePlayer == veTiedForLead[ui])

	cmp	ebx, DWORD PTR [ecx+eax*4]
	je	SHORT $LN54@IsContestL
	inc	eax
	cmp	eax, edx
	jb	SHORT $LL4@IsContestL
$LN2@IsContestL:

; 351  : 			}
; 352  : 		}
; 353  : 	}

	lea	eax, DWORD PTR _veTiedForLead$221544[esp+308]
	mov	DWORD PTR __$EHRec$[esp+304], -1
	cmp	ecx, eax
	je	SHORT $LN41@IsContestL
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN41@IsContestL:

; 354  : 
; 355  : 	return false;

	xor	al, al
$LN10@IsContestL:

; 356  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 284				; 0000011cH
	ret	4
$LN54@IsContestL:

; 349  : 			{
; 350  : 				return true;

	lea	edx, DWORD PTR _veTiedForLead$221544[esp+308]
	mov	DWORD PTR __$EHRec$[esp+304], -1
	cmp	ecx, edx
	je	SHORT $LN27@IsContestL
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@IsContestL:
	mov	al, 1
	jmp	SHORT $LN10@IsContestL
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _veTiedForLead$221544[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__ehhandler$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivQuest::IsContestLeader
PUBLIC	?IsComplete@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::IsComplete
EXTRN	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z:PROC ; CvGameTrade::IsPlayerConnectedToPlayer
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
EXTRN	?IsDenouncedPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDenouncedPlayer
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC ; CvTeam::GetKilledByTeam
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?countNumBuildings@CvPlayer@@QBEHW4BuildingTypes@@@Z:PROC ; CvPlayer::countNumBuildings
EXTRN	?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetPlayerThatClearedBarbCampHere
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?IsCapitalConnectedToPlayer@CvPlayer@@QAE_NW4PlayerTypes@@W4RouteTypes@@@Z:PROC ; CvPlayer::IsCapitalConnectedToPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?IsComplete@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
_iLoop$221583 = -4					; size = 4
?IsComplete@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::IsComplete, COMDAT
; _this$ = ecx

; 361  : {

	push	ecx
	push	ebx
	push	ebp

; 362  : 	CvPlayer* pMinor = &GET_PLAYER(m_eMinor);

	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]

; 363  : 	CvPlayer* pAssignedPlayer = &GET_PLAYER(m_eAssignedPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	ebx, ecx
	imul	ebx, 63236				; 0000f704H
	mov	edi, edx
	imul	edi, 63236				; 0000f704H
	add	ebx, ebp
	add	edi, ebp

; 364  : 
; 365  : 	if(!pMinor)

	test	ebx, ebx

; 366  : 	{
; 367  : 		CvAssertMsg(false, "Minor player not found! Please send Anton your save file and version.");
; 368  : 		return false;

	je	$LN1@IsComplete

; 369  : 	}
; 370  : 	if(!pAssignedPlayer)

	test	edi, edi

; 371  : 	{
; 372  : 		CvAssertMsg(false, "Assigned player not found! Please send Anton your save file and version.");
; 373  : 		return false;

	je	$LN1@IsComplete

; 374  : 	}
; 375  : 
; 376  : 	if(m_eType == MINOR_CIV_QUEST_ROUTE)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN66@IsComplete

; 377  : 	{
; 378  : 		if (pAssignedPlayer->IsCapitalConnectedToPlayer(m_eMinor))

	push	-1
	push	ecx
	mov	ecx, edi
	call	?IsCapitalConnectedToPlayer@CvPlayer@@QAE_NW4PlayerTypes@@W4RouteTypes@@@Z ; CvPlayer::IsCapitalConnectedToPlayer
	test	al, al
	je	$LN1@IsComplete
$LN146@IsComplete:
	pop	edi
	pop	esi
	pop	ebp

; 379  : 		{
; 380  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN66@IsComplete:

; 381  : 		}
; 382  : 	}
; 383  : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	eax, 1
	jne	$LN63@IsComplete

; 384  : 	{
; 385  : 		int iX = m_iData1;

	mov	eax, DWORD PTR [esi+16]

; 386  : 		int iY = m_iData2;

	mov	ebp, DWORD PTR [esi+20]

; 387  : 		CvPlot* pPlot = GC.getMap().plot(iX, iY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN1@IsComplete
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@IsComplete
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN149@IsComplete
	test	eax, eax
	jge	SHORT $LN89@IsComplete
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN91@IsComplete
$LN89@IsComplete:
	cmp	eax, ecx
	jl	SHORT $LN149@IsComplete
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN91@IsComplete
$LN149@IsComplete:
	mov	edi, eax
$LN91@IsComplete:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [eax+4057], 0
	mov	ebx, DWORD PTR [ebx+4024]
	je	SHORT $LN150@IsComplete
	test	ebp, ebp
	jge	SHORT $LN99@IsComplete
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN101@IsComplete
$LN99@IsComplete:
	cmp	ebp, ebx
	jl	SHORT $LN150@IsComplete
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN101@IsComplete
$LN150@IsComplete:
	mov	edx, ebp
$LN101@IsComplete:
	test	edi, edi
	jl	$LN1@IsComplete
	cmp	edi, ecx
	jge	$LN1@IsComplete
	test	edx, edx
	jl	$LN1@IsComplete
	cmp	edx, ebx
	jge	$LN1@IsComplete
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx

; 388  : 
; 389  : 		if(pPlot)

	je	$LN1@IsComplete

; 390  : 		{
; 391  : 			// No longer a camp here?
; 392  : 			if(pPlot->getImprovementType() != GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, ebx
	je	$LN1@IsComplete

; 393  : 			{
; 394  : 				// Did this guy clear it?
; 395  : 				if(pPlot->GetPlayerThatClearedBarbCampHere() == m_eAssignedPlayer)

	mov	ecx, edi
	call	?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatClearedBarbCampHere
	cmp	eax, DWORD PTR [esi+4]
	jne	$LN1@IsComplete
$LN151@IsComplete:
	pop	edi
	pop	esi
	pop	ebp

; 396  : 				{
; 397  : 					return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN63@IsComplete:

; 398  : 				}
; 399  : 			}
; 400  : 		}
; 401  : 	}
; 402  : 	else if(m_eType == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	eax, 2
	jne	SHORT $LN58@IsComplete

; 403  : 	{
; 404  : 		ResourceTypes eResource = (ResourceTypes) m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 405  : 
; 406  : 		// Player has the Resource?
; 407  : 		if(pAssignedPlayer->getNumResourceTotal(eResource, /*bIncludeImport*/ true) > 0)

	push	1
	push	esi
	mov	ecx, edi
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jle	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 408  : 		{
; 409  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN58@IsComplete:

; 410  : 		}
; 411  : 	}
; 412  : 	else if(m_eType == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	SHORT $LN55@IsComplete

; 413  : 	{
; 414  : 		BuildingTypes eWonder = (BuildingTypes) m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 415  : 
; 416  : 		// Player built the Wonder?
; 417  : 		if(pAssignedPlayer->countNumBuildings(eWonder) > 0)

	push	esi
	mov	ecx, edi
	call	?countNumBuildings@CvPlayer@@QBEHW4BuildingTypes@@@Z ; CvPlayer::countNumBuildings
	test	eax, eax
	jle	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 418  : 		{
; 419  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN55@IsComplete:

; 420  : 		}
; 421  : 	}
; 422  : 	else if(m_eType == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4
	jne	SHORT $LN52@IsComplete

; 423  : 	{
; 424  : 		UnitTypes eUnit = (UnitTypes) m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 425  : 
; 426  : 		// Player has the Great Person?
; 427  : 		int iLoop;
; 428  : 		for(CvUnit* pLoopUnit = pAssignedPlayer->firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = pAssignedPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$221583[esp+24]
	push	eax
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	$LN1@IsComplete
$LL51@IsComplete:

; 429  : 		{
; 430  : 			if(pLoopUnit->getUnitType() == eUnit)

	mov	ecx, eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	eax, esi
	je	$LN146@IsComplete
	push	0
	lea	ecx, DWORD PTR _iLoop$221583[esp+24]
	push	ecx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL51@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 554  : 	}
; 555  : 
; 556  : 	return false;

	xor	al, al
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN52@IsComplete:

; 431  : 			{
; 432  : 				return true;
; 433  : 			}
; 434  : 		}
; 435  : 	}
; 436  : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	SHORT $LN46@IsComplete

; 437  : 	{
; 438  : 		PlayerTypes eTargetCityState = (PlayerTypes) m_iData1;
; 439  : 		CvPlayer* pTargetCityState = &GET_PLAYER(eTargetCityState);

	mov	ecx, DWORD PTR [esi+16]
	imul	ecx, 63236				; 0000f704H
	add	ecx, ebp

; 440  : 		if(pTargetCityState)

	je	$LN1@IsComplete

; 441  : 		{
; 442  : 			CvTeam* pTargetCityStateTeam = &GET_TEAM(pTargetCityState->getTeam());

	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 443  : 			if(pTargetCityStateTeam)

	je	$LN1@IsComplete

; 444  : 			{
; 445  : 				// Player killed the City State?
; 446  : 				if(pTargetCityStateTeam->GetKilledByTeam() == pAssignedPlayer->getTeam())

	mov	ecx, eax
	call	?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetKilledByTeam
	mov	ecx, edi
	mov	esi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	esi, eax
	jne	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 447  : 				{
; 448  : 					return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN46@IsComplete:

; 449  : 				}
; 450  : 			}
; 451  : 		}
; 452  : 	}
; 453  : 	else if(m_eType == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6
	jne	SHORT $LN41@IsComplete

; 454  : 	{
; 455  : 		PlayerTypes ePlayerToFind = (PlayerTypes) m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 456  : 
; 457  : 		// Player found the target player?
; 458  : 		if(GET_TEAM(pAssignedPlayer->getTeam()).IsHasFoundPlayersTerritory(ePlayerToFind))

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ; CvTeam::IsHasFoundPlayersTerritory
	test	al, al
	je	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 459  : 		{
; 460  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN41@IsComplete:

; 461  : 		}
; 462  : 	}
; 463  : 	else if(m_eType == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7
	jne	SHORT $LN38@IsComplete

; 464  : 	{
; 465  : 		int iNumWondersFoundBefore = m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 466  : 
; 467  : 		// Player found a new NW?
; 468  : 		if(GET_TEAM(pAssignedPlayer->getTeam()).GetNumNaturalWondersDiscovered() > iNumWondersFoundBefore)

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ; CvTeam::GetNumNaturalWondersDiscovered
	cmp	eax, esi
	jle	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 469  : 		{
; 470  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN38@IsComplete:

; 471  : 		}
; 472  : 	}
; 473  : 	else if(m_eType == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8
	jne	SHORT $LN35@IsComplete

; 474  : 	{
; 475  : 		int iGoldGiftedBefore = m_iData2;

	mov	esi, DWORD PTR [esi+20]

; 476  : 
; 477  : 		// Has the player given gold since the quest began?
; 478  : 		if(pMinor->GetMinorCivAI()->GetNumGoldGifted(m_eAssignedPlayer) > iGoldGiftedBefore)

	push	edx
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumGoldGifted
	cmp	eax, esi
	jle	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 479  : 		{
; 480  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN35@IsComplete:

; 481  : 		}
; 482  : 	}
; 483  : 	else if(m_eType == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9
	jne	SHORT $LN32@IsComplete

; 484  : 	{
; 485  : 		// Has the player pledged?
; 486  : 		if(pMinor->GetMinorCivAI()->IsProtectedByMajor(m_eAssignedPlayer))

	push	edx
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsProtectedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsProtectedByMajor
	test	al, al
	je	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 487  : 		{
; 488  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN32@IsComplete:

; 489  : 		}
; 490  : 	}
; 491  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN29@IsComplete
$LN152@IsComplete:

; 492  : 	{
; 493  : 		// Is it time to compare the score?
; 494  : 		if(GetEndTurn() == GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	edi, eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	cmp	eax, edi
	jne	$LN1@IsComplete

; 495  : 			if(IsContestLeader(GetPlayerAssignedTo()))

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, esi
	call	?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivQuest::IsContestLeader
	test	al, al
	je	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 496  : 				return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN29@IsComplete:

; 497  : 	}
; 498  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH

; 499  : 	{
; 500  : 		// Is it time to compare the score?
; 501  : 		if(GetEndTurn() == GC.getGame().getGameTurn())
; 502  : 			if(IsContestLeader(GetPlayerAssignedTo()))
; 503  : 				return true;

	je	SHORT $LN152@IsComplete

; 504  : 	}
; 505  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH

; 506  : 	{
; 507  : 		// Is it time to compare the score?
; 508  : 		if(GetEndTurn() == GC.getGame().getGameTurn())
; 509  : 			if(IsContestLeader(GetPlayerAssignedTo()))
; 510  : 				return true;

	je	SHORT $LN152@IsComplete

; 511  : 	}
; 512  : 	else if(m_eType == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN17@IsComplete

; 513  : 	{
; 514  : 		if(GetEndTurn() == GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	edi, eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	cmp	eax, edi
	jne	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 515  : 			return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN17@IsComplete:

; 516  : 	}
; 517  : 	else if(m_eType == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN14@IsComplete

; 518  : 	{
; 519  : 		// Has the player bullied since the quest began?
; 520  : 		PlayerTypes eTargetMinor = (PlayerTypes) m_iData1;
; 521  : 		CvPlayer* pTargetMinor = &GET_PLAYER(eTargetMinor);

	mov	ecx, DWORD PTR [esi+16]
	imul	ecx, 63236				; 0000f704H
	add	ecx, ebp

; 522  : 		if(pTargetMinor)

	je	$LN1@IsComplete

; 523  : 		{
; 524  : 			int iMostRecentBullyTurn = pTargetMinor->GetMinorCivAI()->GetTurnLastBulliedByMajor(m_eAssignedPlayer);

	push	edx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetTurnLastBulliedByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetTurnLastBulliedByMajor

; 525  : 			if(iMostRecentBullyTurn > m_iData2)

	cmp	eax, DWORD PTR [esi+20]
	jle	$LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 526  : 				return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN14@IsComplete:

; 527  : 		}
; 528  : 	}
; 529  : 	else if(m_eType == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN10@IsComplete

; 530  : 	{
; 531  : 		// Has the player denounced that major yet?
; 532  : 		PlayerTypes eTargetMajor = (PlayerTypes) m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 533  : 		CvPlayer* pTargetMajor = &GET_PLAYER(eTargetMajor);

	mov	edx, esi
	imul	edx, 63236				; 0000f704H
	add	edx, ebp

; 534  : 		if(pTargetMajor)

	je	SHORT $LN1@IsComplete

; 535  : 		{
; 536  : 			if(pAssignedPlayer->GetDiplomacyAI()->IsDenouncedPlayer(eTargetMajor))

	push	esi
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDenouncedPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDenouncedPlayer
	test	al, al
	je	SHORT $LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 537  : 				return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN10@IsComplete:

; 538  : 		}
; 539  : 	}
; 540  : 	else if(m_eType == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN6@IsComplete

; 541  : 	{
; 542  : 		// Does the CS have the right majority religion?
; 543  : 		ReligionTypes eReligion = (ReligionTypes) m_iData1;

	mov	esi, DWORD PTR [esi+16]

; 544  : 		if(pMinor->getCapitalCity())

	mov	ecx, ebx
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN1@IsComplete

; 545  : 		{
; 546  : 			if(pMinor->getCapitalCity()->GetCityReligions()->GetReligiousMajority() == eReligion)

	mov	ecx, ebx
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority
	cmp	eax, esi
	jne	SHORT $LN1@IsComplete
	pop	edi
	pop	esi
	pop	ebp

; 547  : 				return true;

	mov	al, 1
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
$LN6@IsComplete:

; 548  : 		}
; 549  : 	}
; 550  : 	else if(m_eType == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN1@IsComplete

; 551  : 	{
; 552  : 		if(GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_eMinor,m_eAssignedPlayer))

	push	edx
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al

; 553  : 			return true;

	jne	$LN151@IsComplete
$LN1@IsComplete:
	pop	edi
	pop	esi
	pop	ebp

; 554  : 	}
; 555  : 
; 556  : 	return false;

	xor	al, al
	pop	ebx

; 557  : }

	pop	ecx
	ret	0
?IsComplete@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::IsComplete
_TEXT	ENDS
PUBLIC	?IsExpired@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::IsExpired
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
; Function compile flags: /Ogtpy
;	COMDAT ?IsExpired@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExpired@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::IsExpired, COMDAT
; _this$ = ecx

; 597  : {

	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+12], esi

; 598  : 	// If this quest type has an end turn, have we passed it?
; 599  : 	if(GetEndTurn() != NO_TURN && GC.getGame().getGameTurn() > GetEndTurn())

	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	cmp	eax, -1
	je	SHORT $LN55@IsExpired
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	edi, eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	cmp	edi, eax
	jle	SHORT $LN55@IsExpired
	pop	edi

; 600  : 	{
; 601  : 		return true;

	mov	al, 1
	pop	esi

; 779  : }

	pop	ecx
	ret	0
$LN55@IsExpired:

; 602  : 	}
; 603  : 
; 604  : 	// Build a Route
; 605  : 	if(m_eType == MINOR_CIV_QUEST_ROUTE)
; 606  : 	{
; 607  : 	}
; 608  : 
; 609  : 	// City-state wanted us to clear a camp
; 610  : 	if(m_eType == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	DWORD PTR [esi+8], 1
	push	ebx
	push	ebp
	jne	$LN50@IsExpired

; 611  : 	{
; 612  : 		int iX = GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 613  : 		int iY = GetSecondaryData();

	mov	ebx, DWORD PTR [esi+20]

; 614  : 		CvPlot* pPlot = GC.getMap().plot(iX, iY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN50@IsExpired
	cmp	ebx, -2147483647			; 80000001H
	je	$LN50@IsExpired
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN156@IsExpired
	test	eax, eax
	jge	SHORT $LN78@IsExpired
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN80@IsExpired
$LN78@IsExpired:
	cmp	eax, ecx
	jl	SHORT $LN156@IsExpired
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN80@IsExpired
$LN156@IsExpired:
	mov	esi, eax
$LN80@IsExpired:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN158@IsExpired
	test	ebx, ebx
	jge	SHORT $LN88@IsExpired
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN90@IsExpired
$LN88@IsExpired:
	cmp	ebx, edi
	jl	SHORT $LN158@IsExpired
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN90@IsExpired
$LN158@IsExpired:
	mov	edx, ebx
$LN90@IsExpired:
	test	esi, esi
	jl	SHORT $LN159@IsExpired
	cmp	esi, ecx
	jge	SHORT $LN159@IsExpired
	test	edx, edx
	jl	SHORT $LN159@IsExpired
	cmp	edx, edi
	jge	SHORT $LN159@IsExpired
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx

; 615  : 
; 616  : 		if(pPlot)

	je	SHORT $LN159@IsExpired

; 617  : 		{
; 618  : 			// Camp that was here is gone
; 619  : 			if(!pPlot->HasBarbarianCamp())

	call	?HasBarbarianCamp@CvPlot@@QAE_NXZ	; CvPlot::HasBarbarianCamp
	test	al, al
	jne	SHORT $LN159@IsExpired

; 620  : 			{
; 621  : 				// Someone cleared it, and it wasn't us
; 622  : 				if(pPlot->GetPlayerThatClearedBarbCampHere() != NO_PLAYER && pPlot->GetPlayerThatClearedBarbCampHere() != m_eAssignedPlayer)

	mov	ecx, esi
	call	?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatClearedBarbCampHere
	cmp	eax, -1
	je	SHORT $LN159@IsExpired
	mov	ecx, esi
	call	?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatClearedBarbCampHere
	mov	ecx, DWORD PTR _this$[esp+20]
	cmp	eax, DWORD PTR [ecx+4]

; 623  : 				{
; 624  : 					return true;

	jne	$LN153@IsExpired
$LN159@IsExpired:
	mov	esi, DWORD PTR _this$[esp+20]
$LN50@IsExpired:

; 625  : 				}
; 626  : 			}
; 627  : 		}
; 628  : 	}
; 629  : 
; 630  : 	// Connect a resource
; 631  : 	if(m_eType == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, 2
	je	$LN5@IsExpired

; 632  : 	{
; 633  : 	}
; 634  : 
; 635  : 	// CONSTRUCT A WONDER
; 636  : 	else if(m_eType == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	SHORT $LN47@IsExpired

; 637  : 	{
; 638  : 		BuildingTypes eWonder = (BuildingTypes) GetPrimaryData();

	mov	ebx, DWORD PTR [esi+16]

; 639  : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eWonder);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 640  : 		CvAssertMsg(pkBuildingInfo, "Building info not expected to be FALSE! Please send Anton your save file and version.");
; 641  : 		if(!pkBuildingInfo) return false;

	test	eax, eax
	je	$LN5@IsExpired

; 642  : 
; 643  : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	edi, edi
	xor	esi, esi
	npad	1
$LL45@IsExpired:

; 644  : 		{
; 645  : 			const PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 646  : 			CvPlayer* pLoopPlayer = &GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]

; 647  : 
; 648  : 			if(pLoopPlayer)

	test	ecx, ecx
	je	SHORT $LN44@IsExpired

; 649  : 			{
; 650  : 				// Someone built the wonder, and it wasn't us
; 651  : 				if(m_eAssignedPlayer != eLoopPlayer && pLoopPlayer->countNumBuildings(eWonder) > 0)

	mov	eax, DWORD PTR _this$[esp+20]
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN44@IsExpired
	push	ebx
	call	?countNumBuildings@CvPlayer@@QBEHW4BuildingTypes@@@Z ; CvPlayer::countNumBuildings
	test	eax, eax
	jg	$LN153@IsExpired
$LN44@IsExpired:

; 642  : 
; 643  : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL45@IsExpired
	pop	ebp
	pop	ebx
	pop	edi

; 764  : 		}
; 765  : 	}
; 766  : 
; 767  : 	// Spread your religion to us
; 768  : 	else if(m_eType == MINOR_CIV_QUEST_SPREAD_RELIGION)
; 769  : 	{
; 770  : 		//antonjs: consider: if holy city is lost
; 771  : 	}
; 772  : 	
; 773  : 	// Trade Route
; 774  : 	else if(m_eType == MINOR_CIV_QUEST_TRADE_ROUTE)
; 775  : 	{
; 776  : 	}
; 777  : 
; 778  : 	return false;

	xor	al, al
	pop	esi

; 779  : }

	pop	ecx
	ret	0
$LN47@IsExpired:

; 652  : 				{
; 653  : 					return true;
; 654  : 				}
; 655  : 			}
; 656  : 		}
; 657  : 	}
; 658  : 
; 659  : 	// Spawn a Great Person
; 660  : 	else if(m_eType == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4
	je	$LN5@IsExpired

; 661  : 	{
; 662  : 	}
; 663  : 
; 664  : 	// KILL ANOTHER CITY STATE
; 665  : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	SHORT $LN37@IsExpired

; 666  : 	{
; 667  : 		PlayerTypes eTargetCityState = (PlayerTypes) GetPrimaryData();
; 668  : 		CvPlayer* pTargetCityState = &GET_PLAYER(eTargetCityState);

	mov	esi, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	add	esi, ebx

; 669  : 
; 670  : 		if(pTargetCityState)

	je	$LN5@IsExpired

; 671  : 		{
; 672  : 			CvTeam* pTargetCityStateTeam = &GET_TEAM(pTargetCityState->getTeam());

	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edi, eax
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 673  : 			if(pTargetCityStateTeam)

	je	$LN5@IsExpired

; 674  : 			{
; 675  : 				// Someone killed the City State, and it wasn't us
; 676  : 				if(!pTargetCityState->isAlive() && pTargetCityStateTeam->GetKilledByTeam() != GET_PLAYER(m_eAssignedPlayer).getTeam())

	cmp	BYTE PTR [esi+2256], 0
	jne	$LN5@IsExpired
	mov	ecx, DWORD PTR _this$[esp+20]
	mov	ecx, DWORD PTR [ecx+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, edi
	mov	esi, eax
	call	?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetKilledByTeam
	cmp	eax, esi
	je	$LN5@IsExpired
$LN164@IsExpired:
	pop	ebp
	pop	ebx
	pop	edi

; 677  : 				{
; 678  : 					return true;

	mov	al, 1
	pop	esi

; 779  : }

	pop	ecx
	ret	0
$LN37@IsExpired:

; 679  : 				}
; 680  : 			}
; 681  : 		}
; 682  : 	}
; 683  : 
; 684  : 	// Find a Player
; 685  : 	else if(m_eType == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6
	jne	SHORT $LN32@IsExpired

; 686  : 	{
; 687  : 		PlayerTypes eTargetPlayer = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 688  : 		CvPlayer* pTargetPlayer = &GET_PLAYER(eTargetPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	add	eax, edx

; 689  : 
; 690  : 		if(pTargetPlayer)
; 691  : 		{
; 692  : 			// Someone killed the Player
; 693  : 			if(!GET_PLAYER(eTargetPlayer).isAlive())
; 694  : 				return true;

	jmp	SHORT $LN163@IsExpired
$LN32@IsExpired:

; 695  : 		}
; 696  : 	}
; 697  : 
; 698  : 	// Find a Natural Wonder
; 699  : 	else if(m_eType == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7
	je	SHORT $LN5@IsExpired

; 700  : 	{
; 701  : 	}
; 702  : 
; 703  : 	// Give Gold
; 704  : 	else if(m_eType == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8
	je	SHORT $LN5@IsExpired

; 705  : 	{
; 706  : 	}
; 707  : 
; 708  : 	// Pledge to Protect
; 709  : 	else if(m_eType == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9
	je	SHORT $LN5@IsExpired

; 710  : 	{
; 711  : 	}
; 712  : 
; 713  : 	// Contest Culture
; 714  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH

; 715  : 	{
; 716  : 		if(GC.getGame().getGameTurn() == GetEndTurn() && !IsComplete())
; 717  : 			return true;

	je	SHORT $LN165@IsExpired

; 718  : 	}
; 719  : 
; 720  : 	// Contest Faith
; 721  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH

; 722  : 	{
; 723  : 		if(GC.getGame().getGameTurn() == GetEndTurn() && !IsComplete())
; 724  : 			return true;

	je	SHORT $LN165@IsExpired

; 725  : 	}
; 726  : 
; 727  : 	// Contest Techs
; 728  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN16@IsExpired
$LN165@IsExpired:

; 729  : 	{
; 730  : 		if(GC.getGame().getGameTurn() == GetEndTurn() && !IsComplete())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	edi, eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	cmp	edi, eax
	jne	SHORT $LN5@IsExpired
	mov	ecx, esi
	call	?IsComplete@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsComplete
	test	al, al
	jne	SHORT $LN5@IsExpired
$LN153@IsExpired:
	pop	ebp
	pop	ebx
	pop	edi

; 731  : 			return true;

	mov	al, 1
	pop	esi

; 779  : }

	pop	ecx
	ret	0
$LN16@IsExpired:

; 732  : 	}
; 733  : 
; 734  : 	// Invest
; 735  : 	else if(m_eType == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	je	SHORT $LN5@IsExpired

; 736  : 	{
; 737  : 	}
; 738  : 
; 739  : 	// Bully target City-State
; 740  : 	else if(m_eType == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH

; 741  : 	{
; 742  : 		PlayerTypes eTargetCityState = (PlayerTypes) GetPrimaryData();
; 743  : 		CvPlayer* pTargetCityState = &GET_PLAYER(eTargetCityState);
; 744  : 
; 745  : 		if(pTargetCityState)
; 746  : 		{
; 747  : 			// Someone killed the City State...ouch
; 748  : 			if(!pTargetCityState->isAlive())
; 749  : 				return true;

	je	SHORT $LN162@IsExpired

; 750  : 		}
; 751  : 	}
; 752  : 
; 753  : 	// Denounce target Major
; 754  : 	else if(m_eType == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN5@IsExpired
$LN162@IsExpired:

; 755  : 	{
; 756  : 		PlayerTypes eTargetPlayer = (PlayerTypes) GetPrimaryData();
; 757  : 		CvPlayer* pTargetPlayer = &GET_PLAYER(eTargetPlayer);

	mov	eax, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN163@IsExpired:

; 758  : 
; 759  : 		if(pTargetPlayer)

	je	SHORT $LN5@IsExpired

; 760  : 		{
; 761  : 			// Someone killed the Major
; 762  : 			if(!pTargetPlayer->isAlive())

	cmp	BYTE PTR [eax+2256], 0

; 763  : 				return true;

	je	$LN164@IsExpired
$LN5@IsExpired:
	pop	ebp
	pop	ebx
	pop	edi

; 764  : 		}
; 765  : 	}
; 766  : 
; 767  : 	// Spread your religion to us
; 768  : 	else if(m_eType == MINOR_CIV_QUEST_SPREAD_RELIGION)
; 769  : 	{
; 770  : 		//antonjs: consider: if holy city is lost
; 771  : 	}
; 772  : 	
; 773  : 	// Trade Route
; 774  : 	else if(m_eType == MINOR_CIV_QUEST_TRADE_ROUTE)
; 775  : 	{
; 776  : 	}
; 777  : 
; 778  : 	return false;

	xor	al, al
	pop	esi

; 779  : }

	pop	ecx
	ret	0
?IsExpired@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::IsExpired
_TEXT	ENDS
PUBLIC	?IsObsolete@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::IsObsolete
; Function compile flags: /Ogtpy
;	COMDAT ?IsObsolete@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
?IsObsolete@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::IsObsolete, COMDAT
; _this$ = ecx

; 782  : {

	push	esi
	mov	esi, ecx

; 783  : 	return (IsRevoked() || IsExpired());

	call	?IsRevoked@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsRevoked
	test	al, al
	jne	SHORT $LN3@IsObsolete
	mov	ecx, esi
	call	?IsExpired@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsExpired
	test	al, al
	jne	SHORT $LN3@IsObsolete
	xor	eax, eax
	pop	esi

; 784  : }

	ret	0
$LN3@IsObsolete:

; 783  : 	return (IsRevoked() || IsExpired());

	mov	eax, 1
	pop	esi

; 784  : }

	ret	0
?IsObsolete@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::IsObsolete
_TEXT	ENDS
PUBLIC	?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::DoCancelQuest
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ DD 019930522H
	DD	01bH
	DD	FLAT:__unwindtable$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$7
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$8
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$9
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$10
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$11
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$12
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$13
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$14
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$15
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$16
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$17
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$18
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$19
	DD	02H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$22
	DD	015H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$24
	DD	015H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$26
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
$T252739 = -920						; size = 4
$T252736 = -920						; size = 4
_strTargetNameKey$222242 = -920				; size = 4
_strBuildingName$222233 = -920				; size = 4
_bRevoked$ = -914					; size = 1
_bExpired$ = -913					; size = 1
$T252733 = -912						; size = 80
$T252732 = -912						; size = 80
$T252730 = -912						; size = 80
$T252729 = -912						; size = 80
$T252727 = -912						; size = 80
$T252726 = -912						; size = 80
$T252724 = -912						; size = 80
$T252723 = -912						; size = 80
$T252722 = -912						; size = 80
$T252721 = -912						; size = 80
$T252720 = -912						; size = 80
$T252719 = -912						; size = 80
$T252717 = -912						; size = 80
$T252716 = -912						; size = 80
$T252740 = -832						; size = 4
_sMessage$222275 = -828					; size = 28
_strSummary$ = -800					; size = 80
_strMessage$ = -720					; size = 80
_sSummary$222276 = -640					; size = 28
$T252738 = -612						; size = 28
$T252737 = -584						; size = 28
_veNamesToShow$ = -556					; size = 272
$T252731 = -284						; size = 272
$T252728 = -284						; size = 272
$T252725 = -284						; size = 272
__$EHRec$ = -12						; size = 12
?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::DoCancelQuest, COMDAT
; _this$ = ecx

; 1465 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 908				; 0000038cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1466 : 	if (IsHandled())

	mov	al, BYTE PTR [edi+24]
	test	al, al

; 1467 : 		return false;

	jne	$LN183@DoCancelQu

; 1468 : 
; 1469 : 	SetHandled(true); // We are handling the end of the quest, and this should only happen once
; 1470 : 
; 1471 : 	CvPlayer* pMinor = &GET_PLAYER(m_eMinor);

	mov	ebp, DWORD PTR [edi]
	imul	ebp, 63236				; 0000f704H
	mov	BYTE PTR [edi+24], 1
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1472 : 
; 1473 : 	// Why is the quest cancelled?  Will affect which notification message we send
; 1474 : 	bool bRevoked = IsRevoked();

	call	?IsRevoked@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsRevoked

; 1475 : 	bool bExpired = IsExpired();

	mov	ecx, edi
	mov	BYTE PTR _bRevoked$[esp+936], al
	call	?IsExpired@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsExpired

; 1476 : 
; 1477 : 	Localization::String strMessage;

	mov	esi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$[esp+936]
	mov	BYTE PTR _bExpired$[esp+936], al
	call	esi
	xor	ebx, ebx

; 1478 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+936]
	mov	DWORD PTR __$EHRec$[esp+944], ebx
	call	esi

; 1479 : 	CivsList veNamesToShow;

	lea	eax, DWORD PTR _veNamesToShow$[esp+948]
	mov	DWORD PTR _veNamesToShow$[esp+940], ebx
	mov	DWORD PTR _veNamesToShow$[esp+944], 64	; 00000040H
	mov	DWORD PTR _veNamesToShow$[esp+936], eax

; 1480 : 
; 1481 : 	// If quest was revoked due to bullying, notification is handled elsewhere (to allow condensing)
; 1482 : 	if(bRevoked)

	cmp	BYTE PTR _bRevoked$[esp+936], 0
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	bl, 2
	mov	BYTE PTR __$EHRec$[esp+944], bl
	jne	$LN15@DoCancelQu

; 1483 : 	{
; 1484 : 	}
; 1485 : 	// If quest expired "naturally", send a notification particular to the expiration conditions of the quest
; 1486 : 	else if(bExpired)

	cmp	BYTE PTR _bExpired$[esp+936], 0
	je	$LN15@DoCancelQu

; 1487 : 	{
; 1488 : 		// City-state wanted us to clear a camp
; 1489 : 		if(m_eType == MINOR_CIV_QUEST_KILL_CAMP)

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, 1
	jne	SHORT $LN14@DoCancelQu

; 1490 : 		{
; 1491 : 			strMessage = Localization::Lookup("TXT_KEY_NTFN_QUEST_ENDED_KILL_CAMP");

	lea	eax, DWORD PTR $T252716[esp+936]
	push	OFFSET $SG222223
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252716[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1492 : 			strSummary = Localization::Lookup("TXT_KEY_NTFN_QUEST_ENDED_KILL_CAMP_S");

	lea	ecx, DWORD PTR $T252717[esp+936]
	push	OFFSET $SG222225
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+944], 4
	jmp	$LN182@DoCancelQu
$LN14@DoCancelQu:

; 1493 : 		}
; 1494 : 		// CONSTRUCT A WONDER
; 1495 : 		else if(m_eType == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	$LN12@DoCancelQu

; 1496 : 		{
; 1497 : 			BuildingTypes eWonder = (BuildingTypes) GetPrimaryData();

	mov	eax, DWORD PTR [edi+16]

; 1498 : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eWonder);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 1499 : 			CvAssertMsg(pkBuildingInfo, "Building info not expected to be FALSE! Please send Anton your save file and version.");
; 1500 : 			if(!pkBuildingInfo) 

	test	eax, eax
	jne	SHORT $LN11@DoCancelQu

; 1501 : 				return false;

	mov	eax, DWORD PTR _veNamesToShow$[esp+936]
	lea	edx, DWORD PTR _veNamesToShow$[esp+948]
	mov	BYTE PTR __$EHRec$[esp+944], 1
	cmp	eax, edx
	je	SHORT $LN66@DoCancelQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN66@DoCancelQu:
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+936]
	mov	DWORD PTR __$EHRec$[esp+944], -1
	call	esi
$LN183@DoCancelQu:
	xor	al, al
	jmp	$LN19@DoCancelQu
$LN11@DoCancelQu:

; 1502 : 
; 1503 : 			const char* strBuildingName = pkBuildingInfo->GetDescriptionKey();

	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _strBuildingName$222233[esp+936], eax

; 1504 : 
; 1505 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_CONSTRUCT_WONDER");

	lea	eax, DWORD PTR $T252719[esp+936]
	push	OFFSET $SG222235
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252719[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1506 : 			strMessage << strBuildingName;

	mov	ecx, DWORD PTR _strBuildingName$222233[esp+936]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1507 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONSTRUCT_WONDER");

	lea	edx, DWORD PTR $T252720[esp+936]
	push	OFFSET $SG222237
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252720[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1508 : 			strSummary << strBuildingName;

	mov	eax, DWORD PTR _strBuildingName$222233[esp+936]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN2@DoCancelQu
$LN12@DoCancelQu:

; 1509 : 		}
; 1510 : 
; 1511 : 		// KILL ANOTHER CITY STATE
; 1512 : 		else if(m_eType == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	$LN9@DoCancelQu

; 1513 : 		{
; 1514 : 			PlayerTypes eTargetCityState = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [edi+16]

; 1515 : 
; 1516 : 			const char* strTargetNameKey = GET_PLAYER(eTargetCityState).getNameKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 1517 : 
; 1518 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_KILL_CITY_STATE");

	lea	ecx, DWORD PTR $T252721[esp+936]
	push	OFFSET $SG222244
	push	ecx
	mov	DWORD PTR _strTargetNameKey$222242[esp+944], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252721[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1519 : 			strMessage << strTargetNameKey;

	mov	edx, DWORD PTR _strTargetNameKey$222242[esp+936]
	push	edx
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1520 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_KILL_CITY_STATE");

	lea	eax, DWORD PTR $T252722[esp+936]
	push	OFFSET $SG222246
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252722[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1521 : 			strSummary << strTargetNameKey;

	mov	ecx, DWORD PTR _strTargetNameKey$222242[esp+936]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN2@DoCancelQu
$LN9@DoCancelQu:

; 1522 : 		}
; 1523 : 
; 1524 : 		// Contest Culture
; 1525 : 		else if(m_eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH
	jne	$LN7@DoCancelQu

; 1526 : 		{
; 1527 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_CONTEST_CULTURE");

	lea	edx, DWORD PTR $T252723[esp+936]
	push	OFFSET $SG222250
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252723[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1528 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONTEST_CULTURE");

	lea	eax, DWORD PTR $T252724[esp+936]
	push	OFFSET $SG222252
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 10		; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252724[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1529 : 			veNamesToShow = GetContestLeaders();

	lea	ecx, DWORD PTR $T252725[esp+936]
	push	ecx
	mov	ecx, edi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
	push	eax
	lea	ecx, DWORD PTR _veNamesToShow$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 11		; 0000000bH
	call	??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
	mov	eax, DWORD PTR $T252725[esp+936]
	lea	edx, DWORD PTR $T252725[esp+948]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	cmp	eax, edx
	je	$LN2@DoCancelQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	jmp	$LN2@DoCancelQu
$LN7@DoCancelQu:

; 1530 : 		}
; 1531 : 
; 1532 : 		// Contest Faith
; 1533 : 		else if(m_eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH
	jne	$LN5@DoCancelQu

; 1534 : 		{
; 1535 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_CONTEST_FAITH");

	lea	eax, DWORD PTR $T252726[esp+936]
	push	OFFSET $SG222257
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 12		; 0000000cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252726[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1536 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONTEST_FAITH");

	lea	ecx, DWORD PTR $T252727[esp+936]
	push	OFFSET $SG222259
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 13		; 0000000dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252727[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1537 : 			veNamesToShow = GetContestLeaders();

	lea	edx, DWORD PTR $T252728[esp+936]
	push	edx
	mov	ecx, edi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
	push	eax
	lea	ecx, DWORD PTR _veNamesToShow$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 14		; 0000000eH
	call	??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
	mov	eax, DWORD PTR $T252728[esp+936]
	lea	ecx, DWORD PTR $T252728[esp+948]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	cmp	eax, ecx
	je	$LN2@DoCancelQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	jmp	$LN2@DoCancelQu
$LN5@DoCancelQu:

; 1538 : 		}
; 1539 : 
; 1540 : 		// Contest Techs
; 1541 : 		else if(m_eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	$LN3@DoCancelQu

; 1542 : 		{
; 1543 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_CONTEST_TECHS");

	lea	edx, DWORD PTR $T252729[esp+936]
	push	OFFSET $SG222264
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 15		; 0000000fH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252729[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1544 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_CONTEST_TECHS");

	lea	eax, DWORD PTR $T252730[esp+936]
	push	OFFSET $SG222266
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 16		; 00000010H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252730[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1545 : 			veNamesToShow = GetContestLeaders();

	lea	ecx, DWORD PTR $T252731[esp+936]
	push	ecx
	mov	ecx, edi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
	push	eax
	lea	ecx, DWORD PTR _veNamesToShow$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 17		; 00000011H
	call	??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
	mov	eax, DWORD PTR $T252731[esp+936]
	lea	edx, DWORD PTR $T252731[esp+948]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	cmp	eax, edx
	je	SHORT $LN2@DoCancelQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 1546 : 		}
; 1547 : 
; 1548 : 		// General "Quest Expired" catch statement
; 1549 : 		else

	jmp	SHORT $LN2@DoCancelQu
$LN3@DoCancelQu:

; 1550 : 		{
; 1551 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_OTHER");

	lea	eax, DWORD PTR $T252732[esp+936]
	push	OFFSET $SG222270
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 18		; 00000012H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252732[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi

; 1552 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_OTHER");

	lea	ecx, DWORD PTR $T252733[esp+936]
	push	OFFSET $SG222272
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+944], 19		; 00000013H
$LN182@DoCancelQu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252733[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	esi
$LN2@DoCancelQu:

; 1553 : 		}
; 1554 : 
; 1555 : 		strMessage << pMinor->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+940]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1556 : 		strSummary << pMinor->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+940]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1557 : 
; 1558 : 		CvString sMessage = strMessage.toUTF8();

	lea	ecx, DWORD PTR _strMessage$[esp+936]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN141@DoCancelQu
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN141@DoCancelQu:
	push	eax
	lea	ecx, DWORD PTR _sMessage$222275[esp+940]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1559 : 		CvString sSummary = strSummary.toUTF8();

	lea	ecx, DWORD PTR _strSummary$[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 20		; 00000014H
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN146@DoCancelQu
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN146@DoCancelQu:
	push	eax
	lea	ecx, DWORD PTR _sSummary$222276[esp+940]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1560 : 
; 1561 : 		// This quest involved multiple winners, so grab their names for the notification
; 1562 : 		if(veNamesToShow.size() > 0)

	cmp	DWORD PTR _veNamesToShow$[esp+940], 0
	mov	BYTE PTR __$EHRec$[esp+944], 21		; 00000015H
	jbe	$LN1@DoCancelQu

; 1563 : 		{
; 1564 : 			sMessage = sMessage + pMinor->GetMinorCivAI()->GetNamesListAsString(veNamesToShow);

	sub	esp, 272				; 00000110H
	lea	edx, DWORD PTR _veNamesToShow$[esp+1208]
	mov	ecx, esp
	mov	DWORD PTR $T252736[esp+1208], esp
	push	edx
	call	??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
	lea	eax, DWORD PTR $T252737[esp+1208]
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+1220], 22	; 00000016H
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+1220], 21	; 00000015H
	call	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
	push	eax
	lea	ecx, DWORD PTR _sMessage$222275[esp+940]
	push	ecx
	lea	edx, DWORD PTR $T252738[esp+944]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+956], 23		; 00000017H
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+944], 24		; 00000018H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sMessage$222275[esp+940]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T252738[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 23		; 00000017H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T252737[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 21		; 00000015H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@DoCancelQu:

; 1565 : 		}
; 1566 : 
; 1567 : 		pMinor->GetMinorCivAI()->AddQuestNotification(sMessage, sSummary, m_eAssignedPlayer);

	mov	eax, DWORD PTR [edi+4]
	push	0
	push	-1
	push	-1
	push	eax
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _sSummary$222276[esp+980]
	mov	DWORD PTR $T252739[esp+980], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _sMessage$222275[esp+1008]
	mov	DWORD PTR $T252740[esp+1008], esp
	mov	ecx, esp
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1020], 25	; 00000019H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+1016], 26	; 0000001aH
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+1016], 21	; 00000015H
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification

; 1568 : 	}

	lea	ecx, DWORD PTR _sSummary$222276[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 20		; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sMessage$222275[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _veNamesToShow$[esp+936]
$LN15@DoCancelQu:

; 1569 : 
; 1570 : 	return true;

	lea	ecx, DWORD PTR _veNamesToShow$[esp+948]
	mov	BYTE PTR __$EHRec$[esp+944], 1
	cmp	eax, ecx
	je	SHORT $LN169@DoCancelQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN169@DoCancelQu:
	lea	ecx, DWORD PTR _strSummary$[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+936]
	mov	DWORD PTR __$EHRec$[esp+944], -1
	call	esi
	mov	al, 1
$LN19@DoCancelQu:

; 1571 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+936]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 920				; 00000398H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$2:
	lea	ecx, DWORD PTR _veNamesToShow$[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$3:
	lea	ecx, DWORD PTR $T252716[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$4:
	lea	ecx, DWORD PTR $T252717[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$5:
	lea	ecx, DWORD PTR $T252719[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$6:
	lea	ecx, DWORD PTR $T252720[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$7:
	lea	ecx, DWORD PTR $T252721[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$8:
	lea	ecx, DWORD PTR $T252722[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$9:
	lea	ecx, DWORD PTR $T252723[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$10:
	lea	ecx, DWORD PTR $T252724[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$11:
	lea	ecx, DWORD PTR $T252725[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$12:
	lea	ecx, DWORD PTR $T252726[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$13:
	lea	ecx, DWORD PTR $T252727[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$14:
	lea	ecx, DWORD PTR $T252728[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$15:
	lea	ecx, DWORD PTR $T252729[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$16:
	lea	ecx, DWORD PTR $T252730[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$17:
	lea	ecx, DWORD PTR $T252731[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$18:
	lea	ecx, DWORD PTR $T252732[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$19:
	lea	ecx, DWORD PTR $T252733[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$20:
	lea	ecx, DWORD PTR _sMessage$222275[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$21:
	lea	ecx, DWORD PTR _sSummary$222276[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$22:
	mov	ecx, DWORD PTR $T252736[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$23:
	lea	ecx, DWORD PTR $T252737[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$24:
	lea	ecx, DWORD PTR $T252738[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$25:
	mov	ecx, DWORD PTR $T252739[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ$26:
	mov	ecx, DWORD PTR $T252740[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::DoCancelQuest
PUBLIC	?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z ; CvMinorCivAI::DoAddStartingResources
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_eResourceLoop$222972 = -288				; size = 4
_veUniqueLuxuries$222967 = -284				; size = 272
__$EHRec$ = -12						; size = 12
_pCityPlot$ = 8						; size = 4
?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z PROC ; CvMinorCivAI::DoAddStartingResources, COMDAT
; _this$ = ecx

; 2389 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 276				; 00000114H
	push	esi
	push	edi

; 2390 : 	CvAssertMsg(pCityPlot != NULL, "City's plot should not be NULL. Please send Anton your save file and version.");
; 2391 : 	if (pCityPlot == NULL) return;

	mov	edi, DWORD PTR _pCityPlot$[esp+292]
	mov	esi, ecx
	test	edi, edi
	je	$LN49@DoAddStart

; 2392 : 
; 2393 : 	MinorCivTraitTypes eTrait = GetTrait();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	$LN49@DoAddStart

; 2394 : 
; 2395 : 	// Mercantile
; 2396 : 	if (eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	DWORD PTR [eax+272], 3
	jne	$LN49@DoAddStart

; 2397 : 	{
; 2398 : 		bool bAddUniqueLuxury = true;
; 2399 : 		
; 2400 : 		// Only for our first city
; 2401 : 		if (GetPlayer()->getNumCities() > 1)

	mov	ecx, DWORD PTR [esi]
	push	ebx
	mov	bl, 1
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	SHORT $LN10@DoAddStart

; 2402 : 		{
; 2403 : 			bAddUniqueLuxury = false;

	xor	bl, bl
$LN10@DoAddStart:

; 2404 : 		}
; 2405 : 	
; 2406 : 		// Only if there isn't already a unique luxury on this plot
; 2407 : 		ResourceTypes ePlotResource = pCityPlot->getResourceType();

	push	-1
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 2408 : 		if (ePlotResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN8@DoAddStart

; 2409 : 		{
; 2410 : 			CvResourceInfo* pkPlotResourceInfo = GC.getResourceInfo(ePlotResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2411 : 			if (pkPlotResourceInfo && pkPlotResourceInfo->isOnlyMinorCivs())

	test	eax, eax
	je	SHORT $LN8@DoAddStart
	mov	ecx, eax
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	test	al, al

; 2412 : 			{
; 2413 : 				bAddUniqueLuxury = false;
; 2414 : 			}
; 2415 : 		}
; 2416 : 
; 2417 : 		// Pick and add a unique luxury
; 2418 : 		if (bAddUniqueLuxury)

	jne	$LN64@DoAddStart
$LN8@DoAddStart:
	test	bl, bl
	je	$LN64@DoAddStart

; 2419 : 		{
; 2420 : 			FStaticVector< ResourceTypes, 64, true, c_eCiv5GameplayDLL > veUniqueLuxuries;

	lea	ecx, DWORD PTR _veUniqueLuxuries$222967[esp+312]
	mov	DWORD PTR _veUniqueLuxuries$222967[esp+304], 0
	mov	DWORD PTR _veUniqueLuxuries$222967[esp+308], 64 ; 00000040H
	mov	DWORD PTR _veUniqueLuxuries$222967[esp+300], ecx

; 2421 : #ifdef AUI_WARNING_FIXES
; 2422 : 			for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2423 : #else
; 2424 : 			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+308], 0
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN4@DoAddStart
$LL6@DoAddStart:

; 2425 : #endif
; 2426 : 			{
; 2427 : 				const ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
; 2428 : 				CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResourceLoop);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eResourceLoop$222972[esp+304], esi
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2429 : 				if(pkResourceInfo)

	test	eax, eax
	je	SHORT $LN5@DoAddStart

; 2430 : 				{
; 2431 : 					if(pkResourceInfo->isOnlyMinorCivs())

	mov	ecx, eax
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	test	al, al
	je	SHORT $LN5@DoAddStart

; 2432 : 					{
; 2433 : 						veUniqueLuxuries.push_back(eResourceLoop);

	lea	edx, DWORD PTR _eResourceLoop$222972[esp+300]
	push	edx
	lea	ecx, DWORD PTR _veUniqueLuxuries$222967[esp+304]
	call	?push_back@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4ResourceTypes@@@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::push_back
$LN5@DoAddStart:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL6@DoAddStart
$LN4@DoAddStart:

; 2434 : 					}
; 2435 : 				}
; 2436 : 			}
; 2437 : 
; 2438 : 			pCityPlot->setResourceType(NO_RESOURCE, 0, true);

	push	1
	push	0
	push	-1
	mov	ecx, edi
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType

; 2439 : 			if (veUniqueLuxuries.size() > 0)

	mov	eax, DWORD PTR _veUniqueLuxuries$222967[esp+304]
	test	eax, eax
	jbe	SHORT $LN1@DoAddStart

; 2440 : 			{
; 2441 : 				int iRoll = GC.getGame().getJonRandNum(veUniqueLuxuries.size(), "Rolling for Mercantile city-state special luxury"); // range = [0, size - 1]

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222979
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2442 : 				int iQuantity = GC.getMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY();
; 2443 : 				ResourceTypes eSpecialLuxury = veUniqueLuxuries[iRoll];

	mov	ecx, DWORD PTR _veUniqueLuxuries$222967[esp+300]

; 2444 : 
; 2445 : 				pCityPlot->setResourceType(eSpecialLuxury, iQuantity, true);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3244
	mov	eax, DWORD PTR [ecx+eax*4]
	push	1
	push	edx
	push	eax
	mov	ecx, edi
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN1@DoAddStart:

; 2446 : 			}
; 2447 : 		}

	mov	eax, DWORD PTR _veUniqueLuxuries$222967[esp+300]
	lea	ecx, DWORD PTR _veUniqueLuxuries$222967[esp+312]
	mov	DWORD PTR __$EHRec$[esp+308], -1
	cmp	eax, ecx
	je	SHORT $LN64@DoAddStart
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN64@DoAddStart:
	pop	ebx
$LN49@DoAddStart:

; 2448 : 	}
; 2449 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 288				; 00000120H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _veUniqueLuxuries$222967[ebp]
	jmp	??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum ResourceTypes,64,1,297,0>::~FStaticVector<enum ResourceTypes,64,1,297,0>
__ehhandler$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddStartingResources@CvMinorCivAI@@QAEXPAVCvPlot@@@Z ENDP ; CvMinorCivAI::DoAddStartingResources
PUBLIC	?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestThreatenedAnnouncementForPlayer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
xdata$x	SEGMENT
__unwindtable$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2
__ehfuncinfo$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T253226 = -180						; size = 4
_iX$223088 = -180					; size = 4
$T253227 = -176						; size = 4
_iY$223089 = -176					; size = 4
_strSummary$223097 = -172				; size = 80
_strMessage$223093 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::DoTestThreatenedAnnouncementForPlayer, COMDAT
; _this$ = ecx

; 2627 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2628 : 	if (GetPlayer()->isAlive())

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ecx+2256]
	push	edi
	test	al, al
	je	$LN1@DoTestThre

; 2629 : 	{
; 2630 : 		CvCity* pCapital = GetPlayer()->getCapitalCity();

	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 2631 : 		if (pCapital)

	test	eax, eax
	je	$LN1@DoTestThre

; 2632 : 		{
; 2633 : 			int iX = pCapital->getX();

	mov	ecx, DWORD PTR [eax+96]

; 2634 : 			int iY = pCapital->getY();

	mov	edx, DWORD PTR [eax+108]

; 2635 : 			if (IsThreateningBarbariansEventActiveForPlayer(ePlayer))

	mov	ebx, DWORD PTR _ePlayer$[esp+192]
	mov	DWORD PTR _iX$223088[esp+196], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _iY$223089[esp+200], edx
	call	?IsThreateningBarbariansEventActiveForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsThreateningBarbariansEventActiveForPlayer
	test	al, al
	je	$LN1@DoTestThre

; 2636 : 			{
; 2637 : 				// Is ePlayer is close to us?
; 2638 : 				if (IsPlayerCloseEnoughForThreatenedAnnouncement(ePlayer))

	push	ebx
	mov	ecx, esi
	call	?IsPlayerCloseEnoughForThreatenedAnnouncement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsPlayerCloseEnoughForThreatenedAnnouncement
	test	al, al
	je	$LN1@DoTestThre

; 2639 : 				{
; 2640 : 					// Are there enough barbs to warrant sending a message about it?
; 2641 : 					if (GetNumThreateningBarbarians() >= GC.getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD())

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3240
	mov	ecx, esi
	call	?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetNumThreateningBarbarians
	cmp	eax, edi
	jl	$LN1@DoTestThre

; 2642 : 					{
; 2643 : 						Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BARBS_QUEST");

	mov	edi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR _strMessage$223093[esp+196]
	push	OFFSET $SG223095
	push	eax
	call	edi
	add	esp, 8

; 2644 : 						strMessage << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+204], 0
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$223093[esp+200]
	call	ebp

; 2645 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BARBS_QUEST");

	lea	ecx, DWORD PTR _strSummary$223097[esp+196]
	push	OFFSET $SG223099
	push	ecx
	call	edi
	add	esp, 8

; 2646 : 						strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223097[esp+200]
	call	ebp

; 2647 : 						AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), ePlayer, iX, iY);

	mov	edx, DWORD PTR _iY$223089[esp+196]
	mov	eax, DWORD PTR _iX$223088[esp+196]
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	edx
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _strSummary$223097[esp+208]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T253226[esp+236], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	ecx, DWORD PTR _strMessage$223093[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 2
	call	edi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T253227[esp+264], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+272], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification

; 2648 : 					}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$223097[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$223093[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	call	esi
$LN1@DoTestThre:

; 2649 : 				}
; 2650 : 			}
; 2651 : 		}
; 2652 : 	}
; 2653 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 180				; 000000b4H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$223093[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$223097[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2:
	mov	ecx, DWORD PTR $T253226[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::DoTestThreatenedAnnouncementForPlayer
PUBLIC	?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ ; CvMinorCivAI::DoTestProxyWarAnnouncement
EXTRN	?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z:PROC ; CvTeam::GetNumTurnsAtWar
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ$2
__ehfuncinfo$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
_iNotifyLoop$223137 = -188				; size = 4
$T253295 = -184						; size = 4
_i$223146 = -184					; size = 4
tv520 = -180						; size = 4
$T253296 = -176						; size = 4
_strMessage$223159 = -172				; size = 80
_strSummary$223164 = -92				; size = 80
__$EHRec$ = -12						; size = 12
?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ PROC	; CvMinorCivAI::DoTestProxyWarAnnouncement, COMDAT
; _this$ = ecx

; 2724 : {

	push	-1
	push	__ehhandler$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	ebp

; 2725 : 	for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	xor	eax, eax
	push	esi
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _iNotifyLoop$223137[esp+204], eax
	mov	DWORD PTR tv520[esp+204], eax
$LN10@DoTestProx:

; 2726 : 		PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;
; 2727 : 		CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
; 2728 : 		CvTeam* pNotifyTeam = &GET_TEAM(kCurNotifyPlayer.getTeam());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@DoTestProx
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@DoTestProx
$LN23@DoTestProx:
	or	eax, -1
$LN24@DoTestProx:

; 2729 : 		if (!pNotifyTeam->isHasMet(GetPlayer()->getTeam()))

	mov	edx, DWORD PTR [ebp]
	imul	eax, 2984				; 00000ba8H
	mov	edx, DWORD PTR [edx+44]
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN36@DoTestProx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN37@DoTestProx
$LN36@DoTestProx:
	or	edx, -1
$LN37@DoTestProx:
	push	edx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN9@DoTestProx

; 2730 : 		{
; 2731 : 			continue;
; 2732 : 		}
; 2733 : 
; 2734 : 		for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	xor	ebx, ebx
	mov	DWORD PTR _i$223146[esp+204], ebx
$LN6@DoTestProx:

; 2735 : 		{
; 2736 : 			PlayerTypes eOtherMajor = (PlayerTypes) i;
; 2737 : 			if (IsProxyWarActiveForMajor(eNotifyPlayer, eOtherMajor))

	mov	edx, DWORD PTR _i$223146[esp+204]
	mov	eax, DWORD PTR _iNotifyLoop$223137[esp+204]
	push	edx
	push	eax
	mov	ecx, ebp
	call	?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z ; CvMinorCivAI::IsProxyWarActiveForMajor
	test	al, al
	je	SHORT $LN5@DoTestProx

; 2738 : 			{
; 2739 : 				CvPlayer* pOtherMajor = &GET_PLAYER(eOtherMajor);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [ebx+ecx]

; 2740 : 				CvAssertMsg(pOtherMajor, "Error sending out proxy war notification from a city-state. Please send Anton your save file and version.");
; 2741 : 				if (pOtherMajor)

	test	eax, eax
	je	SHORT $LN5@DoTestProx

; 2742 : 				{
; 2743 : 					TeamTypes eEnemyTeam = pOtherMajor->getTeam();

	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN47@DoTestProx
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN48@DoTestProx
$LN47@DoTestProx:
	or	esi, -1
$LN48@DoTestProx:

; 2744 : 					PlayerTypes eEnemyTeamLeader = GET_TEAM(eEnemyTeam).getLeaderID();

	mov	ecx, esi
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 2745 : 					CvPlayer* pEnemyTeamLeader = &GET_PLAYER(eEnemyTeamLeader);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, eax

; 2746 : 					CvAssert(pEnemyTeamLeader);
; 2747 : 					if (pEnemyTeamLeader && GET_TEAM(GetPlayer()->getTeam()).GetNumTurnsAtWar(eEnemyTeam) == 1)

	je	SHORT $LN5@DoTestProx
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN62@DoTestProx
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN63@DoTestProx
$LN62@DoTestProx:
	or	eax, -1
$LN63@DoTestProx:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetNumTurnsAtWar
	cmp	eax, 1
	je	SHORT $LN91@DoTestProx
$LN5@DoTestProx:

; 2730 : 		{
; 2731 : 			continue;
; 2732 : 		}
; 2733 : 
; 2734 : 		for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	inc	DWORD PTR _i$223146[esp+204]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	$LN6@DoTestProx

; 2746 : 					CvAssert(pEnemyTeamLeader);
; 2747 : 					if (pEnemyTeamLeader && GET_TEAM(GetPlayer()->getTeam()).GetNumTurnsAtWar(eEnemyTeam) == 1)

	jmp	$LN9@DoTestProx
$LN91@DoTestProx:

; 2748 : 					{
; 2749 : 						Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_WAR_UNIT_HELP");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR _strMessage$223159[esp+204]
	push	OFFSET $SG223161
	push	edx
	call	ebx
	add	esp, 8

; 2750 : 						strMessage << GetPlayer()->getCivilizationShortDescriptionKey() << pEnemyTeamLeader->getCivilizationShortDescriptionKey();

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+212], 0
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$223159[esp+208]
	call	edi
	push	esi
	lea	ecx, DWORD PTR _strMessage$223159[esp+208]
	call	edi

; 2751 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_WAR_UNIT_HELP");

	lea	eax, DWORD PTR _strSummary$223164[esp+204]
	push	OFFSET $SG223166
	push	eax
	call	ebx
	add	esp, 8

; 2752 : 						strSummary << GetPlayer()->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+212], 1
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223164[esp+208]
	call	edi

; 2753 : 
; 2754 : 						AddQuestNotification(strMessage.toUTF8(), strSummary.toUTF8(), eNotifyPlayer);

	mov	ecx, DWORD PTR _iNotifyLoop$223137[esp+204]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	0
	push	-1
	push	-1
	push	ecx
	lea	ecx, DWORD PTR _strSummary$223164[esp+220]
	call	esi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T253295[esp+248], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN82@DoTestProx
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN82@DoTestProx:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$223159[esp+248]
	mov	BYTE PTR __$EHRec$[esp+256], 2
	call	esi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T253296[esp+276], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN87@DoTestProx
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN87@DoTestProx:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+284], 1
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification

; 2755 : 
; 2756 : 						break;

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$223164[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$223159[esp+204]
	mov	DWORD PTR __$EHRec$[esp+212], -1
	call	esi
$LN9@DoTestProx:
	mov	eax, DWORD PTR tv520[esp+204]
	inc	DWORD PTR _iNotifyLoop$223137[esp+204]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv520[esp+204], eax
	jl	$LN10@DoTestProx

; 2757 : 					}
; 2758 : 				}
; 2759 : 			}
; 2760 : 		}
; 2761 : 	}
; 2762 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+204]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 188				; 000000bcH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMessage$223159[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$223164[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ$2:
	mov	ecx, DWORD PTR $T253295[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ ENDP	; CvMinorCivAI::DoTestProxyWarAnnouncement
PUBLIC	?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestProxyWarAnnouncementOnFirstContact
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2
__ehfuncinfo$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T253488 = -180						; size = 4
$T253487 = -176						; size = 4
_strMessage$223187 = -172				; size = 80
_strSummary$223192 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_eMajor$ = 8						; size = 4
?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::DoTestProxyWarAnnouncementOnFirstContact, COMDAT
; _this$ = ecx

; 2765 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2766 : 	for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	xor	ebp, ebp
	mov	ebx, ecx
	xor	edi, edi
$LN6@DoTestProx@2:

; 2767 : 	{
; 2768 : 		PlayerTypes eOtherMajor = (PlayerTypes) i;
; 2769 : 		if (IsProxyWarActiveForMajor(eMajor, eOtherMajor))

	mov	eax, DWORD PTR _eMajor$[esp+192]
	push	ebp
	push	eax
	mov	ecx, ebx
	call	?IsProxyWarActiveForMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@0@Z ; CvMinorCivAI::IsProxyWarActiveForMajor
	test	al, al
	je	SHORT $LN5@DoTestProx@2

; 2770 : 		{
; 2771 : 			CvPlayer* pOtherMajor = &GET_PLAYER(eOtherMajor);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edi+ecx]

; 2772 : 			CvAssertMsg(pOtherMajor, "Error sending out proxy war notification from a city-state. Please send Anton your save file and version.");
; 2773 : 			if (pOtherMajor)

	test	eax, eax
	je	SHORT $LN5@DoTestProx@2

; 2774 : 			{
; 2775 : 				TeamTypes eEnemyTeam = pOtherMajor->getTeam();

	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@DoTestProx@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN20@DoTestProx@2
$LN19@DoTestProx@2:
	or	eax, -1
$LN20@DoTestProx@2:

; 2776 : 				PlayerTypes eEnemyTeamLeader = GET_TEAM(eEnemyTeam).getLeaderID();

	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 2777 : 				CvPlayer* pEnemyTeamLeader = &GET_PLAYER(eEnemyTeamLeader);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax

; 2778 : 				CvAssert(pEnemyTeamLeader);
; 2779 : 				if (pEnemyTeamLeader)

	jne	SHORT $LN49@DoTestProx@2
$LN5@DoTestProx@2:

; 2766 : 	for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	add	edi, 63236				; 0000f704H
	inc	ebp
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LN6@DoTestProx@2

; 2778 : 				CvAssert(pEnemyTeamLeader);
; 2779 : 				if (pEnemyTeamLeader)

	jmp	$LN4@DoTestProx@2
$LN49@DoTestProx@2:

; 2780 : 				{
; 2781 : 					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_WAR_UNIT_HELP");

	mov	edi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR _strMessage$223187[esp+196]
	push	OFFSET $SG223189
	push	edx
	call	edi
	add	esp, 8

; 2782 : 					strMessage << GetPlayer()->getCivilizationShortDescriptionKey() << pEnemyTeamLeader->getCivilizationShortDescriptionKey();

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+204], 0
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	ecx, DWORD PTR [ebx]
	mov	ebp, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$223187[esp+200]
	call	esi
	push	ebp
	lea	ecx, DWORD PTR _strMessage$223187[esp+200]
	call	esi

; 2783 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_WAR_UNIT_HELP");

	lea	eax, DWORD PTR _strSummary$223192[esp+196]
	push	OFFSET $SG223194
	push	eax
	call	edi
	add	esp, 8

; 2784 : 					strSummary << GetPlayer()->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [ebx]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223192[esp+200]
	call	esi

; 2785 : 
; 2786 : 					AddQuestNotification(strMessage.toUTF8(), strSummary.toUTF8(), eMajor);

	mov	ecx, DWORD PTR _eMajor$[esp+192]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	0
	push	-1
	push	-1
	push	ecx
	lea	ecx, DWORD PTR _strSummary$223192[esp+212]
	call	esi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T253487[esp+240], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN41@DoTestProx@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN41@DoTestProx@2:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$223187[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 2
	call	esi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T253488[esp+268], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN46@DoTestProx@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@DoTestProx@2:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+276], 1
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification

; 2787 : 
; 2788 : 					break;

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$223192[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$223187[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	call	esi
$LN4@DoTestProx@2:

; 2789 : 				}
; 2790 : 			}
; 2791 : 		}
; 2792 : 	}
; 2793 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 180				; 000000b4H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$223187[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$223192[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2:
	mov	ecx, DWORD PTR $T253487[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::DoTestProxyWarAnnouncementOnFirstContact
PUBLIC	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
EXTRN	?LogMinorCivQuestCancelled@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z:PROC ; CvDiplomacyAI::LogMinorCivQuestCancelled
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z$2
__ehfuncinfo$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_bQuestRevokedFromBullying$ = -183			; size = 1
_bCheckAllQuests$ = -182				; size = 1
_bCancelled$224539 = -181				; size = 1
$T253580 = -180						; size = 4
_iOldFriendshipTimes100$224538 = -180			; size = 4
tv389 = -176						; size = 4
$T253579 = -176						; size = 4
_strSummary$224547 = -172				; size = 80
_strMessage$224544 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eSpecifyQuestType$ = 12				; size = 4
?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::DoObsoleteQuestsForPlayer, COMDAT
; _this$ = ecx

; 3255 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	ebp

; 3256 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3257 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3258 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	ebp, DWORD PTR _ePlayer$[esp+188]
	push	esi
	push	edi
	mov	esi, ecx
	cmp	ebp, 21					; 00000015H
	ja	$LN11@DoObsolete

; 3259 : 
; 3260 : 	bool bCheckAllQuests = true;
; 3261 : 	if (eSpecifyQuestType > NO_MINOR_CIV_QUEST_TYPE && eSpecifyQuestType < NUM_MINOR_CIV_QUEST_TYPES)

	cmp	DWORD PTR _eSpecifyQuestType$[esp+196], 17 ; 00000011H
	mov	BYTE PTR _bCheckAllQuests$[esp+200], 1
	ja	SHORT $LN10@DoObsolete

; 3262 : 		bCheckAllQuests = false;

	mov	BYTE PTR _bCheckAllQuests$[esp+200], 0
$LN10@DoObsolete:

; 3263 : 
; 3264 : 	bool bQuestRevokedFromBullying = false;
; 3265 : 
; 3266 : 	QuestListForPlayer::iterator itr_quest;
; 3267 : 	for(itr_quest = m_QuestsGiven[ePlayer].begin(); itr_quest != m_QuestsGiven[ePlayer].end(); itr_quest++)

	mov	eax, DWORD PTR [esi+3328]
	mov	ebx, ebp
	imul	ebx, 156				; 0000009cH
	mov	ecx, DWORD PTR [eax+ebx+4]
	mov	edi, DWORD PTR [eax+ebx]
	add	eax, ebx
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	eax, edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	BYTE PTR _bQuestRevokedFromBullying$[esp+200], 0
	mov	DWORD PTR tv389[esp+200], ebx
	cmp	edi, ecx
	je	$LN11@DoObsolete
	npad	5
$LL9@DoObsolete:

; 3268 : 	{
; 3269 : 		if(bCheckAllQuests || itr_quest->GetType() == eSpecifyQuestType)

	cmp	BYTE PTR _bCheckAllQuests$[esp+200], 0
	jne	SHORT $LN5@DoObsolete
	mov	edx, DWORD PTR _eSpecifyQuestType$[esp+196]
	cmp	DWORD PTR [edi+8], edx
	jne	$LN8@DoObsolete
$LN5@DoObsolete:

; 3270 : 		{
; 3271 : 			if(itr_quest->IsObsolete())

	mov	ecx, edi
	call	?IsRevoked@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsRevoked
	test	al, al
	jne	SHORT $LN31@DoObsolete
	mov	ecx, edi
	call	?IsExpired@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsExpired
	test	al, al
	je	$LN8@DoObsolete
$LN31@DoObsolete:

; 3272 : 			{
; 3273 : 				int iOldFriendshipTimes100 = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	push	ebp
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN33@DoObsolete
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	jmp	SHORT $LN88@DoObsolete
$LN33@DoObsolete:
	mov	eax, DWORD PTR [esi+ebp*4+2024]
$LN88@DoObsolete:

; 3274 : 				bool bCancelled = itr_quest->DoCancelQuest();

	mov	ecx, edi
	mov	DWORD PTR _iOldFriendshipTimes100$224538[esp+200], eax
	call	?DoCancelQuest@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::DoCancelQuest

; 3275 : 				int iNewFriendshipTimes100 = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR _bCancelled$224539[esp+204], al
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN44@DoObsolete
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ebx, 100				; 00000064H
	jmp	SHORT $LN47@DoObsolete
$LN44@DoObsolete:
	mov	ebx, DWORD PTR [esi+ebp*4+2024]
$LN47@DoObsolete:

; 3276 : 				
; 3277 : 				if (bCancelled)

	cmp	BYTE PTR _bCancelled$224539[esp+200], 0
	je	SHORT $LN86@DoObsolete

; 3278 : 				{
; 3279 : 					if(itr_quest->IsRevoked())

	mov	ecx, edi
	call	?IsRevoked@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsRevoked
	test	al, al
	je	SHORT $LN2@DoObsolete

; 3280 : 						bQuestRevokedFromBullying = true;

	mov	BYTE PTR _bQuestRevokedFromBullying$[esp+200], 1
$LN2@DoObsolete:

; 3281 : 
; 3282 : 					GET_PLAYER(ePlayer).GetDiplomacyAI()->LogMinorCivQuestCancelled(GetPlayer()->GetID(), iOldFriendshipTimes100, iNewFriendshipTimes100, itr_quest->GetType());

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	eax, DWORD PTR _iOldFriendshipTimes100$224538[esp+204]
	push	ebx
	push	eax
	push	edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivQuestCancelled@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z ; CvDiplomacyAI::LogMinorCivQuestCancelled
$LN86@DoObsolete:
	mov	ebx, DWORD PTR tv389[esp+200]
$LN8@DoObsolete:

; 3263 : 
; 3264 : 	bool bQuestRevokedFromBullying = false;
; 3265 : 
; 3266 : 	QuestListForPlayer::iterator itr_quest;
; 3267 : 	for(itr_quest = m_QuestsGiven[ePlayer].begin(); itr_quest != m_QuestsGiven[ePlayer].end(); itr_quest++)

	mov	eax, DWORD PTR [esi+3328]
	mov	ecx, DWORD PTR [eax+ebx+4]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edi, 28					; 0000001cH
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	edi, ecx
	jne	$LL9@DoObsolete

; 3283 : 				}
; 3284 : 			}
; 3285 : 		}
; 3286 : 	}
; 3287 : 
; 3288 : 	// If quest(s) were revoked because of bullying, send out a notification
; 3289 : 	if(bQuestRevokedFromBullying)

	cmp	BYTE PTR _bQuestRevokedFromBullying$[esp+200], 0
	je	$LN11@DoObsolete

; 3290 : 	{
; 3291 : 		Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_ENDED_REVOKED");

	mov	edi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR _strMessage$224544[esp+200]
	push	OFFSET $SG224546
	push	edx
	call	edi

; 3292 : 		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_ENDED_REVOKED");

	lea	eax, DWORD PTR _strSummary$224547[esp+208]
	push	OFFSET $SG224549
	push	eax
	mov	DWORD PTR __$EHRec$[esp+224], 0
	call	edi
	add	esp, 16					; 00000010H

; 3293 : 		strMessage << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+208], 1
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$224544[esp+204]
	call	edi

; 3294 : 		strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$224547[esp+204]
	call	edi

; 3295 : 		AddQuestNotification(strMessage.toUTF8(), strSummary.toUTF8(), ePlayer);

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	0
	push	-1
	push	-1
	push	ebp
	lea	ecx, DWORD PTR _strSummary$224547[esp+216]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T253579[esp+244], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN76@DoObsolete
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN76@DoObsolete:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$224544[esp+244]
	mov	BYTE PTR __$EHRec$[esp+252], 2
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T253580[esp+272], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN81@DoObsolete
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN81@DoObsolete:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+280], 1
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification

; 3296 : 	}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$224547[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$224544[esp+200]
	mov	DWORD PTR __$EHRec$[esp+208], -1
	call	esi
$LN11@DoObsolete:

; 3297 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+200]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 184				; 000000b8H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$224544[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$224547[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z$2:
	mov	ecx, DWORD PTR $T253579[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::DoObsoleteQuestsForPlayer
PUBLIC	?IsContestLeader@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsContestLeader
; Function compile flags: /Ogtpy
;	COMDAT ?IsContestLeader@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
?IsContestLeader@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsContestLeader, COMDAT
; _this$ = ecx

; 4566 : {

	push	esi

; 4567 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4568 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4569 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	esi, DWORD PTR _ePlayer$[esp]
	cmp	esi, 21					; 00000015H
	ja	SHORT $LN5@IsContestL@2

; 4570 : 
; 4571 : 	for (uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[ePlayer].size(); iQuestLoop++)

	mov	ecx, DWORD PTR [ecx+3328]
	mov	edx, esi
	imul	edx, 156				; 0000009cH
	add	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	ebx
	xor	eax, eax
	push	edi
	test	ecx, ecx
	jbe	SHORT $LN2@IsContestL@2
	mov	edi, DWORD PTR [edx]
	mov	ebx, DWORD PTR _eType$[esp+8]
	lea	edx, DWORD PTR [edi+8]
	npad	2
$LL4@IsContestL@2:

; 4572 : 	{
; 4573 : 		if (m_QuestsGiven[ePlayer][iQuestLoop].GetType() == eType)

	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN24@IsContestL@2
	inc	eax
	add	edx, 28					; 0000001cH
	cmp	eax, ecx
	jb	SHORT $LL4@IsContestL@2
$LN2@IsContestL@2:
	pop	edi
	pop	ebx

; 4576 : 		}
; 4577 : 	}
; 4578 : 
; 4579 : 	return false;

	xor	al, al
	pop	esi

; 4580 : }

	ret	8
$LN24@IsContestL@2:

; 4574 : 		{
; 4575 : 			return m_QuestsGiven[ePlayer][iQuestLoop].IsContestLeader(ePlayer);

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	ecx, DWORD PTR [edi+edx*4]
	push	esi
	call	?IsContestLeader@CvMinorCivQuest@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivQuest::IsContestLeader
	pop	edi
	pop	ebx
	pop	esi

; 4580 : }

	ret	8
$LN5@IsContestL@2:

; 4567 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 4568 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 4569 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 4580 : }

	ret	8
?IsContestLeader@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsContestLeader
_TEXT	ENDS
PUBLIC	?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetNearbyResourceForQuest
EXTRN	?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z:PROC ; CvArea::getNumResources
EXTRN	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvResourceInfo::GetRequiredCivilization
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
EXTRN	?getPolicyReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getPolicyReveal
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?getTechReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechReveal
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z$0
__ehfuncinfo$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T253775 = -300						; size = 4
_pPlayerArea$225430 = -296				; size = 4
_eResource$225435 = -292				; size = 4
_this$ = -288						; size = 4
_veValidResources$225432 = -284				; size = 272
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetNearbyResourceForQuest, COMDAT
; _this$ = ecx

; 4726 : {

	push	-1
	push	__ehhandler$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 288				; 00000120H

; 4727 : 	ResourceTypes eBestResource = NO_RESOURCE;
; 4728 : 
; 4729 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp+300]
	imul	ebp, 63236				; 0000f704H
	push	esi
	mov	DWORD PTR _this$[esp+308], ecx
	lea	ecx, DWORD PTR [eax+ebp]
	mov	eax, DWORD PTR [ecx+44]
	push	edi
	or	edi, -1
	mov	esi, edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN24@GetNearbyR
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T253775[esp+312], eax
	jmp	SHORT $LN25@GetNearbyR
$LN24@GetNearbyR:
	mov	DWORD PTR $T253775[esp+312], edi
$LN25@GetNearbyR:

; 4730 : 
; 4731 : 	if(GET_PLAYER(ePlayer).getStartingPlot() != NULL)

	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	je	$LN79@GetNearbyR

; 4732 : 	{
; 4733 : 		CvArea* pPlayerArea = GC.getMap().getArea(GET_PLAYER(ePlayer).getStartingPlot()->getArea());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	add	ecx, ebp
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	eax, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 4734 : 
; 4735 : 		FStaticVector<ResourceTypes, 64, true, c_eCiv5GameplayDLL, 0> veValidResources; // 64 resources should be way more than enough

	xor	ebx, ebx
	lea	edx, DWORD PTR _veValidResources$225432[esp+328]
	mov	DWORD PTR _pPlayerArea$225430[esp+316], eax
	mov	DWORD PTR _veValidResources$225432[esp+320], ebx
	mov	DWORD PTR _veValidResources$225432[esp+324], 64 ; 00000040H
	mov	DWORD PTR _veValidResources$225432[esp+316], edx

; 4736 : 		TechTypes eRevealTech;
; 4737 : 		TechTypes eConnectTech;
; 4738 : 
; 4739 : 		// Loop through all Resources and see if they're useful
; 4740 : 		ResourceTypes eResource;
; 4741 : #ifdef AUI_WARNING_FIXES
; 4742 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 4743 : #else
; 4744 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+324], ebx
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN11@GetNearbyR
	npad	6
$LL95@GetNearbyR:

; 4745 : #endif
; 4746 : 		{
; 4747 : 			eResource = (ResourceTypes) iResourceLoop;
; 4748 : 
; 4749 : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eResource$225435[esp+320], ebx
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	edi, eax

; 4750 : 			// Must not be a plain ol' bonus resource
; 4751 : 			if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_BONUS)

	test	edi, edi
	je	$LN12@GetNearbyR
	mov	ecx, edi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	test	eax, eax
	je	$LN12@GetNearbyR

; 4752 : 			{
; 4753 : 				continue;
; 4754 : 			}
; 4755 : 
; 4756 : 			// Minor can't already have this Resource
; 4757 : 			if(GetPlayer()->getNumResourceTotal(eResource, /*bIncludeImport*/ true) > 0)

	mov	eax, DWORD PTR _this$[esp+316]
	mov	ecx, DWORD PTR [eax]
	push	1
	push	ebx
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jg	$LN12@GetNearbyR

; 4758 : 			{
; 4759 : 				continue;
; 4760 : 			}
; 4761 : 
; 4762 : 			// Player can't already have this Resource
; 4763 : 			if(GET_PLAYER(ePlayer).getNumResourceTotal(eResource, /*bIncludeImport*/ true) > 0)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	add	ecx, ebp
	push	ebx
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jg	$LN12@GetNearbyR

; 4764 : 			{
; 4765 : 				continue;
; 4766 : 			}
; 4767 : 
; 4768 : 			// Player has to be able to see it
; 4769 : 			eRevealTech = (TechTypes) pkResourceInfo->getTechReveal();

	mov	ecx, edi
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal

; 4770 : 			if(!GET_TEAM(eTeam).GetTeamTechs()->HasTech(eRevealTech))

	mov	esi, DWORD PTR $T253775[esp+316]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	esi, 2984				; 00000ba8H
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN12@GetNearbyR

; 4771 : 			{
; 4772 : 				continue;
; 4773 : 			}
; 4774 : 			int iRevealPolicy = pkResourceInfo->getPolicyReveal();

	mov	ecx, edi
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal

; 4775 : 			if (iRevealPolicy != NO_POLICY && !(GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)iRevealPolicy)))

	cmp	eax, -1
	je	SHORT $LN5@GetNearbyR
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	SHORT $LN12@GetNearbyR
$LN5@GetNearbyR:

; 4776 : 			{
; 4777 : 				continue;
; 4778 : 			}
; 4779 : 
; 4780 : 			// Player has to be able to use it
; 4781 : 			eConnectTech = (TechTypes) pkResourceInfo->getTechCityTrade();

	mov	ecx, edi
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade

; 4782 : 			if(!GET_TEAM(eTeam).GetTeamTechs()->HasTech(eConnectTech))

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN12@GetNearbyR

; 4783 : 			{
; 4784 : 				continue;
; 4785 : 			}
; 4786 : 
; 4787 : #ifdef NQ_NO_UNIQUE_LUX_REQUESTS
; 4788 : 			// cannot be a resource unique to a civilization (i.e. Indonesian uniques)
; 4789 : 			if(pkResourceInfo->GetRequiredCivilization() != NULL && pkResourceInfo->GetRequiredCivilization() != NO_CIVILIZATION)

	mov	ecx, edi
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	test	eax, eax
	je	SHORT $LN3@GetNearbyR
	mov	ecx, edi
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	cmp	eax, -1
	jne	SHORT $LN12@GetNearbyR
$LN3@GetNearbyR:

; 4790 : 			{
; 4791 : 				continue;
; 4792 : 			}
; 4793 : #endif
; 4794 : 			// Must be this Resource on the player's area
; 4795 : 			if(pPlayerArea->getNumResources(eResource) == 0)

	mov	ecx, DWORD PTR _pPlayerArea$225430[esp+316]
	push	ebx
	call	?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z ; CvArea::getNumResources
	test	eax, eax
	je	SHORT $LN12@GetNearbyR

; 4796 : 			{
; 4797 : 				continue;
; 4798 : 			}
; 4799 : 
; 4800 : 			veValidResources.push_back(eResource);

	lea	eax, DWORD PTR _eResource$225435[esp+316]
	push	eax
	lea	ecx, DWORD PTR _veValidResources$225432[esp+320]
	call	?push_back@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAEIABW4ResourceTypes@@@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::push_back
$LN12@GetNearbyR:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	ebx, eax
	jl	$LL95@GetNearbyR

; 4736 : 		TechTypes eRevealTech;
; 4737 : 		TechTypes eConnectTech;
; 4738 : 
; 4739 : 		// Loop through all Resources and see if they're useful
; 4740 : 		ResourceTypes eResource;
; 4741 : #ifdef AUI_WARNING_FIXES
; 4742 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 4743 : #else
; 4744 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	or	edi, -1
$LN11@GetNearbyR:

; 4801 : 		}
; 4802 : 
; 4803 : 		// Didn't find any valid Resources
; 4804 : 		if(veValidResources.size() == 0)

	mov	eax, DWORD PTR _veValidResources$225432[esp+320]
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@GetNearbyR

; 4805 : 		{
; 4806 : 			return NO_RESOURCE;

	mov	eax, DWORD PTR _veValidResources$225432[esp+312]
	lea	ecx, DWORD PTR _veValidResources$225432[esp+324]
	mov	DWORD PTR __$EHRec$[esp+320], edi
	cmp	eax, ecx
	je	SHORT $LN59@GetNearbyR
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN59@GetNearbyR:
	mov	eax, edi
	jmp	SHORT $LN15@GetNearbyR
$LN1@GetNearbyR:

; 4807 : 		}
; 4808 : 
; 4809 : 		int iRandIndex = GC.getGame().getJonRandNum(veValidResources.size(), "Finding random Resource for Minor to give out a quest to connect.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225458
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 4810 : 		eBestResource = veValidResources[iRandIndex];

	mov	ecx, DWORD PTR _veValidResources$225432[esp+312]
	mov	esi, DWORD PTR [ecx+eax*4]

; 4811 : 	}

	lea	edx, DWORD PTR _veValidResources$225432[esp+324]
	mov	DWORD PTR __$EHRec$[esp+320], edi
	cmp	ecx, edx
	je	SHORT $LN79@GetNearbyR
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN79@GetNearbyR:

; 4812 : 
; 4813 : 	return eBestResource;

	mov	eax, esi
$LN15@GetNearbyR:

; 4814 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+312]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 300				; 0000012cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _veValidResources$225432[ebp]
	jmp	??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum ResourceTypes,64,1,297,0>::~FStaticVector<enum ResourceTypes,64,1,297,0>
__ehhandler$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetNearbyResourceForQuest
PUBLIC	?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetBestWonderForQuest
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?getProductionNeeded@CvCity@@QBEHW4BuildingTypes@@@Z:PROC ; CvCity::getProductionNeeded
EXTRN	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetBuildingProduction
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?canConstruct@CvPlayer@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvPlayer::canConstruct
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ:PROC ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z$0
__ehfuncinfo$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iCityLoop$ = -236					; size = 4
_iCompletionThreshold$ = -232				; size = 4
_veValidBuildings$ = -228				; size = 216
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetBestWonderForQuest, COMDAT
; _this$ = ecx

; 4818 : {

	push	-1
	push	__ehhandler$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 224				; 000000e0H
	push	ebx

; 4819 : 	BuildingTypes eBestWonder;
; 4820 : 
; 4821 : 	FStaticVector<BuildingTypes, 50, true, c_eCiv5GameplayDLL, 0> veValidBuildings; // 50 wonders should be overkill

	xor	ebx, ebx
	lea	eax, DWORD PTR _veValidBuildings$[esp+252]
	push	esi
	mov	DWORD PTR _veValidBuildings$[esp+248], ebx
	mov	DWORD PTR _veValidBuildings$[esp+252], 50 ; 00000032H
	mov	DWORD PTR _veValidBuildings$[esp+244], eax

; 4822 : 
; 4823 : 	int iWorldPlayerLoop;
; 4824 : 	PlayerTypes eWorldPlayer;
; 4825 : 	CvCity* pLoopCity;
; 4826 : 	int iCityLoop;
; 4827 : 	int iWonderProgress;
; 4828 : 	int iCompletionThreshold = /*25*/ GC.getMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3236
	mov	DWORD PTR _iCompletionThreshold$[esp+244], ecx

; 4829 : 	bool bFoundWonderTooFarAlong;
; 4830 : 
; 4831 : 	// Loop through all Buildings and see if they're useful
; 4832 : #ifdef AUI_WARNING_FIXES
; 4833 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 4834 : #else
; 4835 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+252], ebx
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN14@GetBestWon
	push	ebp
	push	edi
	npad	8
$LL91@GetBestWon:

; 4836 : #endif
; 4837 : 	{
; 4838 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 4839 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 4840 : 
; 4841 : 		//Skip if NULL
; 4842 : 		if(pkBuildingInfo == NULL)

	test	eax, eax
	je	$LN15@GetBestWon

; 4843 : 			continue;
; 4844 : 
; 4845 : 		bFoundWonderTooFarAlong = false;
; 4846 : 
; 4847 : 		// Must be a wonder
; 4848 : 		if(!isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))

	mov	ecx, eax
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	je	$LN15@GetBestWon

; 4849 : 		{
; 4850 : 			continue;
; 4851 : 		}
; 4852 : 
; 4853 : 		// Must be able to build it
; 4854 : 		if(!GET_PLAYER(ePlayer).canConstruct(eBuilding))

	mov	ecx, DWORD PTR _ePlayer$[esp+248]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	0
	push	0
	push	0
	push	ebx
	call	?canConstruct@CvPlayer@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvPlayer::canConstruct
	test	al, al
	je	$LN15@GetBestWon

; 4855 : 		{
; 4856 : 			continue;
; 4857 : 		}
; 4858 : 
; 4859 : 		// Someone CAN be building this wonder right now, but they can't be more than a certain % of the way done (25% by default)
; 4860 : 		for(iWorldPlayerLoop = 0; iWorldPlayerLoop < MAX_MAJOR_CIVS; iWorldPlayerLoop++)

	xor	edi, edi
	npad	10
$LL92@GetBestWon:

; 4861 : 		{
; 4862 : 			eWorldPlayer = (PlayerTypes) iWorldPlayerLoop;
; 4863 : 
; 4864 : 			for(pLoopCity = GET_PLAYER(eWorldPlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eWorldPlayer).nextCity(&iCityLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+256]
	lea	ecx, DWORD PTR [edi+edx]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN5@GetBestWon
	npad	5
$LL7@GetBestWon:

; 4865 : 			{
; 4866 : 				iWonderProgress = pLoopCity->GetCityBuildings()->GetBuildingProduction(eBuilding);

	push	ebx
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProduction

; 4867 : 
; 4868 : 				if(iWonderProgress * 100 / pLoopCity->getProductionNeeded(eBuilding) >= iCompletionThreshold)

	push	ebx
	mov	ecx, esi
	mov	ebp, eax
	call	?getProductionNeeded@CvCity@@QBEHW4BuildingTypes@@@Z ; CvCity::getProductionNeeded
	mov	ecx, eax
	mov	eax, ebp
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	cmp	eax, DWORD PTR _iCompletionThreshold$[esp+252]
	jge	SHORT $LN15@GetBestWon
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+256]
	lea	ecx, DWORD PTR [edi+edx]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL7@GetBestWon
$LN5@GetBestWon:

; 4855 : 		{
; 4856 : 			continue;
; 4857 : 		}
; 4858 : 
; 4859 : 		// Someone CAN be building this wonder right now, but they can't be more than a certain % of the way done (25% by default)
; 4860 : 		for(iWorldPlayerLoop = 0; iWorldPlayerLoop < MAX_MAJOR_CIVS; iWorldPlayerLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL92@GetBestWon

; 4869 : 				{
; 4870 : 					bFoundWonderTooFarAlong = true;
; 4871 : 					break;
; 4872 : 				}
; 4873 : 			}
; 4874 : 			if(bFoundWonderTooFarAlong)
; 4875 : 			{
; 4876 : 				break;
; 4877 : 			}
; 4878 : 		}
; 4879 : 		if(bFoundWonderTooFarAlong)
; 4880 : 		{
; 4881 : 			continue;
; 4882 : 		}
; 4883 : 
; 4884 : 		veValidBuildings.push_back(eBuilding);

	mov	eax, DWORD PTR _veValidBuildings$[esp+260]
	mov	BYTE PTR _veValidBuildings$[esp+464], 0
	cmp	DWORD PTR _veValidBuildings$[esp+256], eax
	jne	SHORT $LN36@GetBestWon
	push	eax
	lea	ecx, DWORD PTR _veValidBuildings$[esp+256]
	call	?GrowSize@?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum BuildingTypes,50,1,297,0>::GrowSize
$LN36@GetBestWon:
	mov	ecx, DWORD PTR _veValidBuildings$[esp+252]
	mov	edx, DWORD PTR _veValidBuildings$[esp+256]
	lea	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN39@GetBestWon
	mov	DWORD PTR [eax], ebx
$LN39@GetBestWon:
	inc	DWORD PTR _veValidBuildings$[esp+256]
$LN15@GetBestWon:

; 4829 : 	bool bFoundWonderTooFarAlong;
; 4830 : 
; 4831 : 	// Loop through all Buildings and see if they're useful
; 4832 : #ifdef AUI_WARNING_FIXES
; 4833 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 4834 : #else
; 4835 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	ebx, eax
	jl	$LL91@GetBestWon
	pop	edi
	pop	ebp
$LN14@GetBestWon:

; 4885 : 	}
; 4886 : 
; 4887 : 	// Didn't find any valid Wonders
; 4888 : 	if(veValidBuildings.size() == 0)

	mov	eax, DWORD PTR _veValidBuildings$[esp+248]
	test	eax, eax
	jne	SHORT $LN1@GetBestWon

; 4889 : 	{
; 4890 : 		return NO_BUILDING;

	mov	eax, DWORD PTR _veValidBuildings$[esp+244]
	lea	ecx, DWORD PTR _veValidBuildings$[esp+256]
	mov	DWORD PTR __$EHRec$[esp+252], -1
	cmp	eax, ecx
	je	SHORT $LN47@GetBestWon
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN47@GetBestWon:
	or	eax, -1
	jmp	SHORT $LN17@GetBestWon
$LN1@GetBestWon:

; 4891 : 	}
; 4892 : 
; 4893 : 	int iRandIndex = GC.getGame().getJonRandNum(veValidBuildings.size(), "Finding random Wonder for Minor to give out a quest to construct.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225565
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 4894 : 	eBestWonder = veValidBuildings[iRandIndex];
; 4895 : 
; 4896 : 	return eBestWonder;

	mov	ecx, DWORD PTR _veValidBuildings$[esp+244]
	mov	esi, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR _veValidBuildings$[esp+256]
	mov	DWORD PTR __$EHRec$[esp+252], -1
	cmp	ecx, edx
	je	SHORT $LN67@GetBestWon
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN67@GetBestWon:
	mov	eax, esi
$LN17@GetBestWon:

; 4897 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+244]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 236				; 000000ecH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _veValidBuildings$[ebp]
	jmp	??1?$FStaticVector@W4BuildingTypes@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,50,1,297,0>::~FStaticVector<enum BuildingTypes,50,1,297,0>
__ehhandler$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetBestWonderForQuest
PUBLIC	?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetBestGreatPersonForQuest
EXTRN	?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ:PROC ; CvUnitEntry::GetBaseBeakersTurnsToCount
EXTRN	?IsFoundReligion@CvUnitEntry@@QBE_NXZ:PROC	; CvUnitEntry::IsFoundReligion
EXTRN	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvPlayer::canTrain
EXTRN	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpecialUnitType
EXTRN	?GetProductionCost@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetProductionCost
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z$0
__ehfuncinfo$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_eSpecialUnitGreatPerson$ = -68				; size = 4
_iLoop$225739 = -64					; size = 4
_veValidUnits$ = -60					; size = 48
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetBestGreatPersonForQuest, COMDAT
; _this$ = ecx

; 4902 : {

	push	-1
	push	__ehhandler$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi

; 4903 : 	UnitTypes eBestUnit = NO_UNIT;
; 4904 : 
; 4905 : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	xor	ebx, ebx
	push	ebx
	push	OFFSET $SG225574
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eSpecialUnitGreatPerson$[esp+80], eax

; 4906 : 
; 4907 : 	FStaticVector<UnitTypes, 8, true, c_eCiv5GameplayDLL, 0> veValidUnits;

	lea	eax, DWORD PTR _veValidUnits$[esp+92]
	mov	DWORD PTR _veValidUnits$[esp+84], ebx
	mov	DWORD PTR _veValidUnits$[esp+88], 8
	mov	DWORD PTR _veValidUnits$[esp+80], eax

; 4908 : 
; 4909 : 	// Loop through all Units and see if they're useful
; 4910 : #ifdef AUI_WARNING_FIXES
; 4911 : 	for (uint iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
; 4912 : #else
; 4913 : 	for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	xor	ebp, ebp
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	test	eax, eax
	jle	$LN15@GetBestGre
	push	edi
	npad	2
$LL90@GetBestGre:

; 4914 : #endif
; 4915 : 	{
; 4916 : 		const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
; 4917 : 		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	edi, eax

; 4918 : 
; 4919 : 		if(pkUnitInfo == NULL)

	cmp	edi, ebx
	je	$LN16@GetBestGre

; 4920 : 			continue;
; 4921 : 
; 4922 : 		// Can't be able to train it
; 4923 : 		if(pkUnitInfo->GetProductionCost() != -1)

	mov	ecx, edi
	call	?GetProductionCost@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetProductionCost
	cmp	eax, -1
	jne	$LN16@GetBestGre

; 4924 : 		{
; 4925 : 			continue;
; 4926 : 		}
; 4927 : 
; 4928 : 		// Must be a Great Person (defined in SpecialUnitType in Unit XML)
; 4929 : 		if(pkUnitInfo->GetSpecialUnitType() != eSpecialUnitGreatPerson)

	mov	ecx, edi
	call	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetSpecialUnitType
	cmp	eax, DWORD PTR _eSpecialUnitGreatPerson$[esp+84]
	jne	$LN16@GetBestGre

; 4930 : 		{
; 4931 : 			continue;
; 4932 : 		}
; 4933 : 
; 4934 : 		// Must be a Great Person for this player's civ
; 4935 : 		if(!GET_PLAYER(ePlayer).canTrain(eUnit, false /*bContinue*/, false /*bTestVisible*/, true /*bIgnoreCost*/))

	mov	esi, DWORD PTR _ePlayer$[esp+80]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	push	ebx
	push	ebx
	push	1
	push	ebx
	push	ebx
	add	ecx, esi
	push	ebp
	call	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvPlayer::canTrain
	test	al, al
	je	$LN16@GetBestGre

; 4936 : 		{
; 4937 : 			continue;
; 4938 : 		}
; 4939 : 
; 4940 : 		// Must be a Great Person that can be spawned in the current game
; 4941 : 		if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	21					; 00000015H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN9@GetBestGre

; 4942 : 		{
; 4943 : 			if(pkUnitInfo->IsFoundReligion())

	mov	ecx, edi
	call	?IsFoundReligion@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsFoundReligion
	test	al, al
	jne	$LN16@GetBestGre
$LN9@GetBestGre:

; 4944 : 			{
; 4945 : 				continue;
; 4946 : 			}
; 4947 : 		}
; 4948 : 		if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	17					; 00000011H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN7@GetBestGre

; 4949 : 		{
; 4950 : 			if(pkUnitInfo->GetBaseBeakersTurnsToCount() > 0)

	mov	ecx, edi
	call	?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetBaseBeakersTurnsToCount
	test	eax, eax
	jg	SHORT $LN16@GetBestGre
$LN7@GetBestGre:

; 4951 : 			{
; 4952 : 				continue;
; 4953 : 			}
; 4954 : 		}
; 4955 : 
; 4956 : 		bool bAlreadyHasUnit = false;
; 4957 : 
; 4958 : 		// Player can't already have this Unit
; 4959 : 		int iLoop;
; 4960 : 		for(CvUnit* pLoopUnit = GET_PLAYER(ePlayer).firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = GET_PLAYER(ePlayer).nextUnit(&iLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	lea	eax, DWORD PTR _iLoop$225739[esp+88]
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	cmp	eax, ebx
	je	SHORT $LN87@GetBestGre
$LL6@GetBestGre:

; 4961 : 		{
; 4962 : 			if(pLoopUnit->getUnitType() == eUnit)

	mov	ecx, eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	eax, ebp
	je	SHORT $LN16@GetBestGre
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	lea	edx, DWORD PTR _iLoop$225739[esp+88]
	add	ecx, esi
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	cmp	eax, ebx
	jne	SHORT $LL6@GetBestGre
$LN87@GetBestGre:

; 4963 : 			{
; 4964 : 				bAlreadyHasUnit = true;
; 4965 : 				break;
; 4966 : 			}
; 4967 : 		}
; 4968 : 		if(bAlreadyHasUnit)
; 4969 : 		{
; 4970 : 			continue;
; 4971 : 		}
; 4972 : 
; 4973 : 		veValidUnits.push_back(eUnit);

	mov	eax, DWORD PTR _veValidUnits$[esp+92]
	mov	BYTE PTR _veValidUnits$[esp+128], bl
	cmp	DWORD PTR _veValidUnits$[esp+88], eax
	jne	SHORT $LN39@GetBestGre
	push	eax
	lea	ecx, DWORD PTR _veValidUnits$[esp+88]
	call	?GrowSize@?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum UnitTypes,8,1,297,0>::GrowSize
$LN39@GetBestGre:
	mov	eax, DWORD PTR _veValidUnits$[esp+84]
	mov	ecx, DWORD PTR _veValidUnits$[esp+88]
	lea	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN42@GetBestGre
	mov	DWORD PTR [eax], ebp
$LN42@GetBestGre:
	inc	DWORD PTR _veValidUnits$[esp+88]
$LN16@GetBestGre:

; 4908 : 
; 4909 : 	// Loop through all Units and see if they're useful
; 4910 : #ifdef AUI_WARNING_FIXES
; 4911 : 	for (uint iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
; 4912 : #else
; 4913 : 	for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	cmp	ebp, eax
	jl	$LL90@GetBestGre
	pop	edi
$LN15@GetBestGre:

; 4974 : 	}
; 4975 : 
; 4976 : 	// Didn't find any valid Units
; 4977 : 	if(veValidUnits.size() == 0)

	mov	eax, DWORD PTR _veValidUnits$[esp+84]
	cmp	eax, ebx
	jne	SHORT $LN1@GetBestGre

; 4978 : 	{
; 4979 : 		return NO_UNIT;

	mov	eax, DWORD PTR _veValidUnits$[esp+80]
	lea	edx, DWORD PTR _veValidUnits$[esp+92]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	cmp	eax, edx
	je	SHORT $LN50@GetBestGre
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN50@GetBestGre:
	pop	esi
	pop	ebp
	or	eax, -1
	pop	ebx

; 4986 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	4
$LN1@GetBestGre:

; 4980 : 	}
; 4981 : 
; 4982 : 	int iRandIndex = GC.getGame().getJonRandNum(veValidUnits.size(), "Finding random Great Person for Minor to give out a quest to spawn.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225749
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 4983 : 	eBestUnit = veValidUnits[iRandIndex];
; 4984 : 
; 4985 : 	return eBestUnit;

	mov	ecx, DWORD PTR _veValidUnits$[esp+80]
	mov	esi, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR _veValidUnits$[esp+92]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	cmp	ecx, eax
	je	SHORT $LN70@GetBestGre
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN70@GetBestGre:

; 4986 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _veValidUnits$[ebp]
	jmp	??1?$FStaticVector@W4UnitTypes@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum UnitTypes,8,1,297,0>::~FStaticVector<enum UnitTypes,8,1,297,0>
__ehhandler$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetBestGreatPersonForQuest
PUBLIC	?DoSeedUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoSeedUnitSpawnCounter
; Function compile flags: /Ogtpy
;	COMDAT ?DoSeedUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bBias$ = 12						; size = 1
?DoSeedUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z PROC ; CvMinorCivAI::DoSeedUnitSpawnCounter, COMDAT
; _this$ = ecx

; 7522 : {

	push	ebx

; 7523 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 7524 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 7525 : 
; 7526 : 	int iNumTurns = GetSpawnBaseTurns(ePlayer);

	mov	ebx, DWORD PTR _ePlayer$[esp]
	push	esi
	push	edi
	push	ebx
	mov	edi, ecx
	call	?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetSpawnBaseTurns

; 7527 : 
; 7528 : 	// Add some randomness
; 7529 : 	int iRand = /*3*/ GC.getFRIENDS_RAND_TURNS_UNIT_SPAWN();
; 7530 : 	iNumTurns += GC.getGame().getJonRandNum(iRand, "Rand turns for Friendly Minor unit spawn");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2916
	push	OFFSET $SG227014
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	esi, eax

; 7531 : 
; 7532 : 	// If we're biasing the result then decrease the number of turns
; 7533 : 	if(bBias)

	cmp	BYTE PTR _bBias$[esp+8], 0
	je	SHORT $LN1@DoSeedUnit

; 7534 : 	{
; 7535 : 		iNumTurns *= /*50*/ GC.getUNIT_SPAWN_BIAS_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2924
	imul	ecx, esi

; 7536 : 		iNumTurns /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN1@DoSeedUnit:

; 7537 : 	}
; 7538 : 
; 7539 : 	SetUnitSpawnCounter(ePlayer, iNumTurns);

	cmp	ebx, 21					; 00000015H
	ja	SHORT $LN10@DoSeedUnit
	mov	DWORD PTR [edi+ebx*4+2552], esi
$LN10@DoSeedUnit:
	pop	edi
	pop	esi
	pop	ebx

; 7540 : }

	ret	8
?DoSeedUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ENDP ; CvMinorCivAI::DoSeedUnitSpawnCounter
_TEXT	ENDS
PUBLIC	?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoSpawnUnit
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?addProductionExperience@CvCity@@QAEXPAVCvUnit@@_N@Z:PROC ; CvCity::addProductionExperience
EXTRN	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ:PROC	; CvUnit::jumpToNearestValidPlot
EXTRN	?changeExperience@CvUnit@@QAEXHH_N00@Z:PROC	; CvUnit::changeExperience
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?GetCompetitiveSpawnUnitType@CvGame@@QAE?AW4UnitTypes@@W4PlayerTypes@@_N1@Z:PROC ; CvGame::GetCompetitiveSpawnUnitType
EXTRN	?GetObsoleteTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetObsoleteTech
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
EXTRN	?GetClosestFriendlyCity@CvPlayer@@QAEPAVCvCity@@AAVCvPlot@@H@Z:PROC ; CvPlayer::GetClosestFriendlyCity
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2
__ehfuncinfo$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eUniqueUnit$227075 = -196				; size = 4
_eUnit$227072 = -196					; size = 4
tv133 = -192						; size = 4
_pkUnitInfo$227077 = -192				; size = 4
_iX$227069 = -188					; size = 4
_iY$227070 = -184					; size = 4
$T254320 = -180						; size = 4
$T254321 = -176						; size = 4
_strSummary$227104 = -172				; size = 80
_strMessage$227100 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_eMajor$ = 8						; size = 4
?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC	; CvMinorCivAI::DoSpawnUnit, COMDAT
; _this$ = ecx

; 7623 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 184				; 000000b8H
	push	ebx

; 7624 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 7625 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 7626 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	ebx, DWORD PTR _eMajor$[esp+196]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	cmp	ebx, 21					; 00000015H
	ja	$LN110@DoSpawnUni

; 7627 : 
; 7628 : 	if(!IsUnitSpawningDisabled(eMajor))

	mov	al, BYTE PTR [ebx+edi+3080]
	test	al, al
	jne	$LN5@DoSpawnUni

; 7629 : 	{
; 7630 : 		// Minor must have Capital
; 7631 : 		CvCity* pMinorCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [edi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	esi, eax

; 7632 : 		if(pMinorCapital == NULL)

	test	esi, esi
	je	$LN110@DoSpawnUni

; 7633 : 		{
; 7634 : 			FAssertMsg(false, "MINOR CIV AI: Trying to spawn a Unit for a major civ but the minor has no capital. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 7635 : 			return;
; 7636 : 		}
; 7637 : 		CvPlot* pMinorCapitalPlot = pMinorCapital->plot();

	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 7638 : 		if(pMinorCapitalPlot == NULL)

	test	eax, eax
	je	$LN110@DoSpawnUni

; 7639 : 		{
; 7640 : 			CvAssertMsg(false, "MINOR CIV AI: Trying to spawn a Unit for a major civ but the minor's capital has no plot. Please send Anton your save file and version.");
; 7641 : 			return;
; 7642 : 		}
; 7643 : 
; 7644 : 		CvCity* pMajorCity = GET_PLAYER(eMajor).GetClosestFriendlyCity(*pMinorCapitalPlot, MAX_INT);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebp, ebx
	imul	ebp, 63236				; 0000f704H
	push	2147483647				; 7fffffffH
	add	ecx, ebp
	push	eax
	call	?GetClosestFriendlyCity@CvPlayer@@QAEPAVCvCity@@AAVCvPlot@@H@Z ; CvPlayer::GetClosestFriendlyCity

; 7645 : 
; 7646 : 		int iX = pMinorCapital->getX();

	mov	edx, DWORD PTR [esi+96]

; 7647 : 		int iY = pMinorCapital->getY();

	mov	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR _iX$227069[esp+212], edx
	mov	DWORD PTR _iY$227070[esp+212], ecx

; 7648 : 		if(pMajorCity != NULL)

	test	eax, eax
	je	SHORT $LN51@DoSpawnUni

; 7649 : 		{
; 7650 : 			iX = pMajorCity->getX();

	mov	edx, DWORD PTR [eax+96]

; 7651 : 			iY = pMajorCity->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR _iX$227069[esp+212], edx
	mov	DWORD PTR _iY$227070[esp+212], eax
$LN51@DoSpawnUni:

; 7652 : 		}
; 7653 : 
; 7654 : 		// Pick Unit type
; 7655 : 		UnitTypes eUnit = NO_UNIT;
; 7656 : 		if (GetAlly() == eMajor)

	mov	eax, DWORD PTR [edi+2012]
	cmp	eax, ebx
	jne	$LN18@DoSpawnUni

; 7657 : 		{	
; 7658 : 			// Should we give our unique unit?
; 7659 : 			bool bUseUniqueUnit = false;
; 7660 : 			UnitTypes eUniqueUnit = GetUniqueUnit();

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR _eUniqueUnit$227075[esp+212], eax

; 7661 : 			if (eUniqueUnit != NO_UNIT)

	cmp	eax, -1
	je	$LN18@DoSpawnUni

; 7662 : 			{
; 7663 : 				CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUniqueUnit);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$227077[esp+212], eax

; 7664 : 				if (pkUnitInfo)

	test	eax, eax
	je	SHORT $LN18@DoSpawnUni

; 7665 : 				{
; 7666 : 					// Ally must have unit's prereq tech
; 7667 : 					TechTypes ePrereqTech = (TechTypes) pkUnitInfo->GetPrereqAndTech();

	mov	ecx, eax
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	mov	esi, eax

; 7668 : 					if (ePrereqTech == NO_TECH || GET_TEAM(GET_PLAYER(eMajor).getTeam()).GetTeamTechs()->HasTech(ePrereqTech))

	cmp	esi, -1
	je	SHORT $LN14@DoSpawnUni
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN18@DoSpawnUni
$LN14@DoSpawnUni:

; 7669 : 					{
; 7670 : 						// Ally must NOT have unit's obsolete tech
; 7671 : 						TechTypes eObsoleteTech = (TechTypes) pkUnitInfo->GetObsoleteTech();

	mov	ecx, DWORD PTR _pkUnitInfo$227077[esp+212]
	call	?GetObsoleteTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetObsoleteTech
	mov	esi, eax

; 7672 : 						if (eObsoleteTech == NO_TECH || !GET_TEAM(GET_PLAYER(eMajor).getTeam()).GetTeamTechs()->HasTech(eObsoleteTech))

	cmp	esi, -1
	je	SHORT $LN12@DoSpawnUni
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN18@DoSpawnUni
$LN12@DoSpawnUni:

; 7673 : 						{
; 7674 : 							bUseUniqueUnit = true;
; 7675 : 						}
; 7676 : 					}
; 7677 : 				}
; 7678 : 			}
; 7679 : 			
; 7680 : 			if (bUseUniqueUnit)
; 7681 : 			{
; 7682 : 				eUnit = eUniqueUnit;

	mov	eax, DWORD PTR _eUniqueUnit$227075[esp+212]

; 7683 : 			}
; 7684 : 			else

	jmp	SHORT $LN121@DoSpawnUni
$LN18@DoSpawnUni:

; 7685 : 			{
; 7686 : 				eUnit = GC.getGame().GetCompetitiveSpawnUnitType(eMajor, /*bIncludeUUs*/ false, /*bIncludeRanged*/true);
; 7687 : 			}
; 7688 : 		}
; 7689 : 		else
; 7690 : 		{
; 7691 : 			eUnit = GC.getGame().GetCompetitiveSpawnUnitType(eMajor, /*bIncludeUUs*/ false, /*bIncludeRanged*/true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	push	0
	push	ebx
	call	?GetCompetitiveSpawnUnitType@CvGame@@QAE?AW4UnitTypes@@W4PlayerTypes@@_N1@Z ; CvGame::GetCompetitiveSpawnUnitType
$LN121@DoSpawnUni:
	mov	DWORD PTR _eUnit$227072[esp+212], eax

; 7692 : 		}
; 7693 : 
; 7694 : 		// Spawn Unit
; 7695 : 		if(eUnit != NO_UNIT)

	cmp	eax, -1
	je	$LN5@DoSpawnUni

; 7696 : 		{
; 7697 : 			// NQMP GJS - Patronage Finisher
; 7698 : 			int iUnitsToGift = 1 + GET_PLAYER(eMajor).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_MINOR_MILITARY_NUM_EXTRA_UNITS_TO_GIFT);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	push	59					; 0000003bH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	inc	eax

; 7699 : 			for (int i = 0; i < iUnitsToGift; ++i)

	test	eax, eax
	jle	$LN5@DoSpawnUni
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	DWORD PTR tv133[esp+212], eax
$LN7@DoSpawnUni:

; 7700 : 			{
; 7701 : 				// NQMP GJS - the code inside this for loop is pre-existing, it was put inside the for loop for the mod
; 7702 : 				CvUnit* pNewUnit = GET_PLAYER(eMajor).initUnit(eUnit, iX, iY);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR _iY$227070[esp+212]
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	eax
	mov	eax, DWORD PTR _eUnit$227072[esp+240]
	lea	ecx, DWORD PTR [edx+ebp]
	mov	edx, DWORD PTR _iX$227069[esp+240]
	push	edx
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit

; 7703 : 
; 7704 : 				// If player trait is to enhance minor bonuses, give this unit some free experience
; 7705 : 				if(GET_PLAYER(eMajor).GetPlayerTraits()->GetCityStateBonusModifier() > 0)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	mov	esi, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+88], 0
	jle	SHORT $LN4@DoSpawnUni

; 7706 : 				{
; 7707 : 					pNewUnit->changeExperience(GC.getMAX_EXPERIENCE_PER_COMBAT()); //NQMP GJS - Patronage Finisher

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7588
	push	0
	push	0
	push	0
	push	-1
	push	edx
	mov	ecx, esi
	call	?changeExperience@CvUnit@@QAEXHH_N00@Z	; CvUnit::changeExperience
$LN4@DoSpawnUni:

; 7708 : 				}
; 7709 : 
; 7710 : 				if (pNewUnit->jumpToNearestValidPlot())

	mov	ecx, esi
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	test	al, al
	je	$LN3@DoSpawnUni

; 7711 : 				{
; 7712 : 					if(GetPlayer()->getCapitalCity())

	mov	ecx, DWORD PTR [edi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN2@DoSpawnUni

; 7713 : 						GetPlayer()->getCapitalCity()->addProductionExperience(pNewUnit);

	mov	ecx, DWORD PTR [edi]
	push	0
	push	esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?addProductionExperience@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::addProductionExperience
$LN2@DoSpawnUni:

; 7714 : 
; 7715 : 					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_STATE_UNIT_SPAWN");

	lea	eax, DWORD PTR _strMessage$227100[esp+212]
	push	OFFSET $SG227102
	push	eax
	call	ebx
	add	esp, 8

; 7716 : 					strMessage << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+220], 0
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$227100[esp+216]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 7717 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_STATE_UNIT_SPAWN");

	lea	ecx, DWORD PTR _strSummary$227104[esp+212]
	push	OFFSET $SG227106
	push	ecx
	call	ebx
	add	esp, 8

; 7718 : 					strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$227104[esp+216]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 7719 : 
; 7720 : 					AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), eMajor, pNewUnit->getX(), pNewUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	mov	edx, DWORD PTR _eMajor$[esp+208]
	push	eax
	push	esi
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	edx
	lea	ecx, DWORD PTR _strSummary$227104[esp+224]
	call	esi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T254320[esp+252], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	ecx, DWORD PTR _strMessage$227100[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 2
	call	esi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T254321[esp+280], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification

; 7721 : 				}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$227104[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$227100[esp+212]
	mov	DWORD PTR __$EHRec$[esp+220], -1
	call	esi

; 7722 : 				else

	jmp	SHORT $LN6@DoSpawnUni
$LN3@DoSpawnUni:

; 7723 : 				{
; 7724 : 					pNewUnit->kill(false);	// Could not find a spot!

	push	-1
	push	0
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN6@DoSpawnUni:

; 7699 : 			for (int i = 0; i < iUnitsToGift; ++i)

	sub	DWORD PTR tv133[esp+212], 1
	jne	$LN7@DoSpawnUni
	mov	ebx, DWORD PTR _eMajor$[esp+208]
$LN5@DoSpawnUni:

; 7725 : 				}
; 7726 : 			} // NQMP GJS - Patronage Finisher end
; 7727 : 		}
; 7728 : 	}
; 7729 : 
; 7730 : 	// Reseed counter
; 7731 : 	DoSeedUnitSpawnCounter(eMajor);

	push	ebx
	mov	ecx, edi
	call	?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetSpawnBaseTurns
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2916
	push	OFFSET $SG227014
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	esi, eax
	mov	DWORD PTR [edi+ebx*4+2552], esi
$LN110@DoSpawnUni:

; 7732 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 196				; 000000c4H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$227100[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$227104[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2:
	mov	ecx, DWORD PTR $T254320[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP	; CvMinorCivAI::DoSpawnUnit
PUBLIC	?DoUnitSpawnTurn@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoUnitSpawnTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoUnitSpawnTurn@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoUnitSpawnTurn@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoUnitSpawnTurn, COMDAT
; _this$ = ecx

; 7736 : {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 7737 : 	// Loop through all players and see if we should give them a Unit
; 7738 : 	PlayerTypes eMajor;
; 7739 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
	lea	edi, DWORD PTR [ebx+2552]
	npad	3
$LL6@DoUnitSpaw:

; 7740 : 	{
; 7741 : 		eMajor = (PlayerTypes) iMajorLoop;
; 7742 : 
; 7743 : 		if(IsUnitSpawningAllowed(eMajor))

	push	esi
	mov	ecx, ebx
	call	?IsUnitSpawningAllowed@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsUnitSpawningAllowed
	test	al, al
	je	SHORT $LN5@DoUnitSpaw

; 7744 : 		{
; 7745 : 			// Tick down
; 7746 : 			if(GetUnitSpawnCounter(eMajor) > 0)

	test	esi, esi
	jl	SHORT $LN5@DoUnitSpaw
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN5@DoUnitSpaw
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jle	SHORT $LN19@DoUnitSpaw

; 7747 : 			{
; 7748 : 				ChangeUnitSpawnCounter(eMajor, -1);

	dec	eax
	mov	DWORD PTR [edi], eax
$LN19@DoUnitSpaw:

; 7749 : 			}
; 7750 : 
; 7751 : 			// Time to spawn!
; 7752 : 			if(GetUnitSpawnCounter(eMajor) == 0)

	cmp	esi, 22					; 00000016H
	jge	SHORT $LN5@DoUnitSpaw
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN5@DoUnitSpaw

; 7753 : 			{
; 7754 : 				DoSpawnUnit(eMajor);

	push	esi
	mov	ecx, ebx
	call	?DoSpawnUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoSpawnUnit
$LN5@DoUnitSpaw:
	inc	esi
	add	edi, 4
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL6@DoUnitSpaw
	pop	edi
	pop	esi
	pop	ebx

; 7755 : 			}
; 7756 : 		}
; 7757 : 	}
; 7758 : }

	ret	0
?DoUnitSpawnTurn@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoUnitSpawnTurn
_TEXT	ENDS
PUBLIC	?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z ; CvMinorCivAI::DoAcquire
EXTRN	?DoUpdateDiploVictory@CvGame@@QAEXXZ:PROC	; CvGame::DoUpdateDiploVictory
EXTRN	?acquireCity@CvPlayer@@QAEXPAVCvCity@@_N1@Z:PROC ; CvPlayer::acquireCity
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?DoDistanceGift@CvPlayer@@QAEXW4PlayerTypes@@PAVCvUnit@@@Z:PROC ; CvPlayer::DoDistanceGift
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z$0
__ehfuncinfo$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z
_TEXT	SEGMENT
_iLoopCity$ = -96					; size = 4
_vpCitiesToAcquire$ = -92				; size = 80
__$EHRec$ = -12						; size = 12
_eMajor$ = 8						; size = 4
_iLoopUnit$ = 12					; size = 4
_iNumUnits$ = 12					; size = 4
_iCapitalX$ = 16					; size = 4
_iCapitalY$ = 20					; size = 4
?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z PROC ; CvMinorCivAI::DoAcquire, COMDAT
; _this$ = ecx

; 7963 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 7964 : 	// Take their units
; 7965 : 	CvUnit* pLoopUnit = NULL;
; 7966 : 	int iLoopUnit;
; 7967 : 	iNumUnits = 0;

	mov	edi, DWORD PTR _iNumUnits$[esp+108]
	xor	ebx, ebx
	mov	esi, ecx

; 7968 : 	for(pLoopUnit = GetPlayer()->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = GetPlayer()->nextUnit(&iLoopUnit))

	push	ebx
	lea	eax, DWORD PTR _iLoopUnit$[esp+112]
	mov	DWORD PTR [edi], ebx
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	cmp	eax, ebx
	je	SHORT $LN9@DoAcquire
	mov	ebp, DWORD PTR _eMajor$[esp+108]
	imul	ebp, 63236				; 0000f704H
$LL11@DoAcquire:

; 7969 : 	{
; 7970 : 		GET_PLAYER(eMajor).DoDistanceGift(GetPlayer()->GetID(), pLoopUnit);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+44]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	call	?DoDistanceGift@CvPlayer@@QAEXW4PlayerTypes@@PAVCvUnit@@@Z ; CvPlayer::DoDistanceGift

; 7971 : 		iNumUnits++;

	inc	DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	push	ebx
	lea	edx, DWORD PTR _iLoopUnit$[esp+112]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	cmp	eax, ebx
	jne	SHORT $LL11@DoAcquire
$LN9@DoAcquire:

; 7972 : 	}
; 7973 : 
; 7974 : 	// Take all their cities, don't show notifications
; 7975 : 	SetDisableNotifications(true);

	cmp	BYTE PTR [esi+6864], 1
	je	SHORT $LN27@DoAcquire
	mov	BYTE PTR [esi+6864], 1
$LN27@DoAcquire:

; 7976 : 	iCapitalX = -1;

	mov	eax, DWORD PTR _iCapitalX$[esp+108]

; 7977 : 	iCapitalY = -1;

	mov	ecx, DWORD PTR _iCapitalY$[esp+108]

; 7978 : 	FStaticVector<CvCity*, 16, false, c_eCiv5GameplayDLL, 0> vpCitiesToAcquire;

	lea	edx, DWORD PTR _vpCitiesToAcquire$[esp+124]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR _vpCitiesToAcquire$[esp+116], ebx
	mov	DWORD PTR _vpCitiesToAcquire$[esp+120], 16 ; 00000010H
	mov	DWORD PTR _vpCitiesToAcquire$[esp+112], edx

; 7979 : 	int iLoopCity;
; 7980 : 	for (CvCity* pLoopCity = GetPlayer()->firstCity(&iLoopCity, true); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoopCity, true))

	mov	ecx, DWORD PTR [esi]
	mov	ebp, 1
	push	ebp
	lea	eax, DWORD PTR _iLoopCity$[esp+116]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	cmp	edi, ebx
	je	SHORT $LN6@DoAcquire
	npad	1
$LL8@DoAcquire:

; 7981 : 	{
; 7982 : 		vpCitiesToAcquire.push_back(pLoopCity);

	mov	eax, DWORD PTR _vpCitiesToAcquire$[esp+120]
	mov	BYTE PTR _vpCitiesToAcquire$[esp+188], bl
	cmp	DWORD PTR _vpCitiesToAcquire$[esp+116], eax
	jne	SHORT $LN42@DoAcquire
	push	eax
	lea	ecx, DWORD PTR _vpCitiesToAcquire$[esp+116]
	call	?GrowSize@?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCity *,16,0,297,0>::GrowSize
$LN42@DoAcquire:
	mov	ecx, DWORD PTR _vpCitiesToAcquire$[esp+112]
	mov	edx, DWORD PTR _vpCitiesToAcquire$[esp+116]
	lea	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, ebx
	je	SHORT $LN45@DoAcquire
	mov	DWORD PTR [eax], edi
$LN45@DoAcquire:
	mov	ecx, DWORD PTR [esi]
	add	DWORD PTR _vpCitiesToAcquire$[esp+116], ebp
	push	ebp
	lea	eax, DWORD PTR _iLoopCity$[esp+116]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	cmp	edi, ebx
	jne	SHORT $LL8@DoAcquire
$LN6@DoAcquire:

; 7983 : 	}
; 7984 : 	for (uint iI = 0; iI < vpCitiesToAcquire.size(); iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _vpCitiesToAcquire$[esp+116], ebx
	jbe	SHORT $LN3@DoAcquire
	npad	8
$LL5@DoAcquire:

; 7985 : 	{
; 7986 : 		CvCity* pCity = vpCitiesToAcquire[iI];

	mov	ecx, DWORD PTR _vpCitiesToAcquire$[esp+112]
	mov	edi, DWORD PTR [ecx+ebp*4]

; 7987 : 		CvAssertMsg(pCity, "pCity should not be NULL. Please send Anton your save file and version.");
; 7988 : 		if (pCity)

	cmp	edi, ebx
	je	SHORT $LN4@DoAcquire

; 7989 : 		{
; 7990 : 			if (pCity->isCapital())

	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN1@DoAcquire

; 7991 : 			{
; 7992 : 				iCapitalX = pCity->getX();

	mov	edx, DWORD PTR [edi+96]
	mov	eax, DWORD PTR _iCapitalX$[esp+108]
	mov	DWORD PTR [eax], edx

; 7993 : 				iCapitalY = pCity->getY();

	mov	ecx, DWORD PTR [edi+108]
	mov	edx, DWORD PTR _iCapitalY$[esp+108]
	mov	DWORD PTR [edx], ecx
$LN1@DoAcquire:

; 7994 : 			}
; 7995 : 			GET_PLAYER(eMajor).acquireCity(pCity, false, true); // deletes pCity, don't reuse the pointer

	mov	ecx, DWORD PTR _eMajor$[esp+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	ebx
	push	edi
	call	?acquireCity@CvPlayer@@QAEXPAVCvCity@@_N1@Z ; CvPlayer::acquireCity
$LN4@DoAcquire:
	inc	ebp
	cmp	ebp, DWORD PTR _vpCitiesToAcquire$[esp+116]
	jb	SHORT $LL5@DoAcquire
$LN3@DoAcquire:

; 7996 : 		}
; 7997 : 	}
; 7998 : 	SetDisableNotifications(false);

	cmp	BYTE PTR [esi+6864], bl
	je	SHORT $LN63@DoAcquire
	mov	BYTE PTR [esi+6864], bl
$LN63@DoAcquire:

; 7999 : 
; 8000 : 	SetMajorBoughtOutBy(eMajor);

	mov	eax, DWORD PTR _eMajor$[esp+108]
	mov	DWORD PTR [esi+2020], eax

; 8001 : 
; 8002 : 	GC.getGame().DoUpdateDiploVictory();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?DoUpdateDiploVictory@CvGame@@QAEXXZ	; CvGame::DoUpdateDiploVictory

; 8003 : 
; 8004 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax

; 8005 : 
; 8006 : }

	mov	eax, DWORD PTR _vpCitiesToAcquire$[esp+112]
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR _vpCitiesToAcquire$[esp+116]
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+108], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN74@DoAcquire
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN74@DoAcquire:
	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z$0:
	lea	ecx, DWORD PTR _vpCitiesToAcquire$[ebp]
	jmp	??1?$FStaticVector@PAVCvCity@@$0BA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,16,0,297,0>::~FStaticVector<CvCity *,16,0,297,0>
__ehhandler$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z ENDP ; CvMinorCivAI::DoAcquire
PUBLIC	?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z ; CvMinorCivAI::DoTileImprovementGiftFromMajor
EXTRN	??3CvDllPlot@@SAXPAX@Z:PROC			; CvDllPlot::operator delete
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:PROC ; CvTreasury::LogExpenditure
EXTRN	??0CvDllPlot@@QAE@PAVCvPlot@@@Z:PROC		; CvDllPlot::CvDllPlot
EXTRN	??2CvDllPlot@@SAPAXI@Z:PROC			; CvDllPlot::operator new
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$3
__ehfuncinfo$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T254730 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_eMajor$ = 8						; size = 4
$T254729 = 12						; size = 4
_iPlotX$ = 12						; size = 4
$T254726 = 16						; size = 4
_pDllPlot$ = 16						; size = 4
_iPlotY$ = 16						; size = 4
?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z PROC ; CvMinorCivAI::DoTileImprovementGiftFromMajor, COMDAT
; _this$ = ecx

; 9292 : {

	push	-1
	push	__ehhandler$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 9293 : 	if(!CanMajorGiftTileImprovementAtPlot(eMajor, iPlotX, iPlotY))

	mov	ebx, DWORD PTR _eMajor$[esp+20]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+36], edi
	cmp	ebx, 21					; 00000015H
	ja	$LN87@DoTileImpr
	push	ebx
	call	?CanMajorGiftTileImprovement@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorGiftTileImprovement
	test	al, al
	je	$LN87@DoTileImpr
	mov	ebp, DWORD PTR _iPlotY$[esp+32]
	mov	esi, DWORD PTR _iPlotX$[esp+32]
	push	ebp
	push	esi
	push	ebx
	mov	ecx, edi
	call	?IsLackingGiftableTileImprovementAtPlot@CvMinorCivAI@@QAE_NW4PlayerTypes@@HH@Z ; CvMinorCivAI::IsLackingGiftableTileImprovementAtPlot
	test	al, al
	je	$LN87@DoTileImpr

; 9294 : 	{
; 9295 : 		return;
; 9296 : 	}
; 9297 : 	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN87@DoTileImpr
	cmp	ebp, -2147483647			; 80000001H
	je	$LN87@DoTileImpr
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN31@DoTileImpr
	test	esi, esi
	jge	SHORT $LN33@DoTileImpr
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN31@DoTileImpr
$LN33@DoTileImpr:
	cmp	esi, ecx
	jl	SHORT $LN31@DoTileImpr
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN31@DoTileImpr:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN41@DoTileImpr
	test	ebp, ebp
	jge	SHORT $LN43@DoTileImpr
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN45@DoTileImpr
$LN43@DoTileImpr:
	cmp	ebp, edi
	jl	SHORT $LN41@DoTileImpr
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN45@DoTileImpr
$LN41@DoTileImpr:
	mov	edx, ebp
$LN45@DoTileImpr:
	test	esi, esi
	jl	$LN87@DoTileImpr
	cmp	esi, ecx
	jge	$LN87@DoTileImpr
	test	edx, edx
	jl	$LN87@DoTileImpr
	cmp	edx, edi
	jge	$LN87@DoTileImpr
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	esi, ecx

; 9298 : 	if(pPlot == NULL)

	je	$LN87@DoTileImpr

; 9299 : 	{
; 9300 : 		CvAssertMsg(false, "pPlot not expected to be NULL, invalid coordinates. Please send Anton your save file and version.");
; 9301 : 		return;
; 9302 : 	}
; 9303 : 	CvPlayer* pPlayer = &GET_PLAYER(eMajor);

	mov	edi, DWORD PTR _eMajor$[esp+32]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebp, edi
	imul	ebp, 63236				; 0000f704H
	add	eax, ebp
	mov	DWORD PTR _pPlayer$[esp+32], eax

; 9304 : 	if(pPlayer == NULL)

	je	$LN87@DoTileImpr

; 9305 : 	{
; 9306 : 		CvAssertMsg(false, "pPlayer not expected to be NULL. Please send Anton your save file and version.");
; 9307 : 		return;
; 9308 : 	}
; 9309 : 
; 9310 : 	ImprovementTypes eImprovement = pPlot->getImprovementTypeNeededToImproveResource(eMajor, /*bTestOwner*/false);

	push	0
	push	edi
	call	?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z ; CvPlot::getImprovementTypeNeededToImproveResource

; 9311 : 	if(eImprovement == NO_IMPROVEMENT)

	cmp	eax, -1
	je	$LN87@DoTileImpr

; 9312 : 	{
; 9313 : 		return;
; 9314 : 	}
; 9315 : 
; 9316 : 	pPlot->setImprovementType(eImprovement, eMajor);

	push	edi
	push	eax
	mov	ecx, esi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 9317 : 
; 9318 : 	// VFX
; 9319 : 	auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pPlot));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T254726[esp+32], eax
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	eax, eax
	je	SHORT $LN7@DoTileImpr
	push	esi
	mov	ecx, eax
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	edi, eax
	jmp	SHORT $LN8@DoTileImpr
$LN7@DoTileImpr:
	xor	edi, edi
$LN8@DoTileImpr:
	mov	DWORD PTR _pDllPlot$[esp+32], edi

; 9320 : 	gDLL->GameplayDoFX(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+708]
	push	-1
	mov	ebx, 1
	push	edi
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	call	eax

; 9321 : 
; 9322 : 	const int iCost = GetGiftTileImprovementCost(eMajor);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7324

; 9323 : 	GET_PLAYER(eMajor).GetTreasury()->LogExpenditure(GetPlayer()->GetMinorCivAI()->GetNamesListAsString(0), iCost,5);

	push	5
	push	esi
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T254729[esp+68], esp
	sub	esp, 272				; 00000110H
	mov	eax, esp
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR $T254730[esp+344], esp
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[esp+344]
	mov	ecx, DWORD PTR [eax]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+356], 2
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+356], bl
	call	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+80], 3
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+80], bl
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 9324 : 	pPlayer->GetTreasury()->ChangeGold(-iCost);

	mov	ecx, DWORD PTR _pPlayer$[esp+32]
	neg	esi
	push	esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 9325 : }

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN87@DoTileImpr
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	edi
	call	eax
$LN87@DoTileImpr:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$0:
	mov	eax, DWORD PTR $T254726[ebp-4]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$[ebp-4]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$2:
	mov	ecx, DWORD PTR $T254730[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$3:
	mov	ecx, DWORD PTR $T254729[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTileImprovementGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z ENDP ; CvMinorCivAI::DoTileImprovementGiftFromMajor
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::~FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::~FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::~FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >
_TEXT	ENDS
PUBLIC	?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z ; CvMinorCivAI::GetStatusChangeNotificationStrings
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z DD 019930522H
	DD	017H
	DD	FLAT:__unwindtable$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$8
	DD	09H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$9
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$10
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$11
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$12
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$13
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$14
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$15
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$16
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$17
	DD	02H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$18
	DD	013H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$19
	DD	014H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$20
	DD	015H
	DD	FLAT:__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$26
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z
_TEXT	SEGMENT
_this$ = -700						; size = 4
_strMinorsNameKey$ = -696				; size = 4
$T254974 = -692						; size = 4
$T254947 = -688						; size = 80
$T254946 = -688						; size = 80
$T254945 = -688						; size = 80
$T254944 = -688						; size = 80
$T254943 = -688						; size = 80
$T254942 = -688						; size = 80
$T254941 = -688						; size = 80
$T254940 = -688						; size = 80
$T254937 = -688						; size = 80
$T254936 = -688						; size = 80
$T254935 = -688						; size = 80
$T254934 = -688						; size = 80
$T254933 = -688						; size = 80
$T254951 = -608						; size = 28
_strResourceNames$229331 = -608				; size = 28
_strMessage$ = -580					; size = 80
_strSummary$ = -500					; size = 80
_strDetailedInfo$ = -420				; size = 28
$T254950 = -392						; size = 28
_strResourceDetails$229326 = -364			; size = 80
_veResources$229312 = -284				; size = 272
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
_bAdd$ = 16						; size = 1
_bFriends$ = 20						; size = 1
_bAllies$ = 24						; size = 1
_eOldAlly$ = 28						; size = 4
_eNewAlly$ = 32						; size = 4
?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z PROC ; CvMinorCivAI::GetStatusChangeNotificationStrings, COMDAT
; _this$ = ecx

; 9979 : {

	push	-1
	push	__ehhandler$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 688				; 000002b0H
	push	ebx
	push	ebp
	push	esi
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T254974[esp+716], eax

; 9980 : 	Localization::String strMessage;

	mov	esi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$[esp+716]
	mov	DWORD PTR _this$[esp+716], edi
	mov	DWORD PTR __$EHRec$[esp+724], eax
	call	esi

; 9981 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+716]
	mov	DWORD PTR __$EHRec$[esp+724], 1
	call	esi

; 9982 : 
; 9983 : 	CvTeam* pTeam = &GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	mov	eax, DWORD PTR _ePlayer$[esp+712]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN58@GetStatusC@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN59@GetStatusC@2
$LN58@GetStatusC@2:
	or	eax, -1
$LN59@GetStatusC@2:

; 9984 : 	CvAssertMsg(pTeam, "pTeam not expected to be NULL. Please send Anton your save file and version.");
; 9985 : 
; 9986 : 	const char* strMinorsNameKey = GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [edi]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 9987 : 
; 9988 : 	// Adding/Increasing bonus
; 9989 : 	if(bAdd)

	cmp	BYTE PTR _bAdd$[esp+712], 0
	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR _strMinorsNameKey$[esp+716], eax
	je	$LN26@GetStatusC@2

; 9990 : 	{
; 9991 : 		// Jumped up to Allies (either from Neutral or from Friends, or passing another player)
; 9992 : 		if(bAllies)

	cmp	BYTE PTR _bAllies$[esp+712], 0
	je	$LN25@GetStatusC@2

; 9993 : 		{
; 9994 : 			// BASE ALLIES MESSAGE
; 9995 : 
; 9996 : 			// No previous Ally (or it was us)
; 9997 : 			if(eOldAlly == NO_PLAYER || eOldAlly == ePlayer)

	mov	esi, DWORD PTR _eOldAlly$[esp+712]
	cmp	esi, -1
	je	$LN23@GetStatusC@2
	cmp	esi, DWORD PTR _ePlayer$[esp+712]
	je	$LN23@GetStatusC@2

; 10000: 			}
; 10001: 			// We're passing someone
; 10002: 			else
; 10003: 			{
; 10004: 				CvAssertMsg(eOldAlly != NO_PLAYER, "eOldAlly not expected to be NO_PLAYER here. Please send Anton your save file and version.");
; 10005: 				const char* strOldBestPlayersNameKey = "TXT_KEY_UNMET_PLAYER";
; 10006: 				TeamTypes eOldAllyTeam = GET_PLAYER(eOldAlly).getTeam();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	mov	eax, DWORD PTR [esi+edx+44]
	mov	ebp, OFFSET $SG229303
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN73@GetStatusC@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN74@GetStatusC@2
$LN73@GetStatusC@2:
	or	eax, -1
$LN74@GetStatusC@2:

; 10007: 				if(pTeam->isHasMet(eOldAllyTeam))

	push	eax
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN21@GetStatusC@2

; 10008: 					strOldBestPlayersNameKey = GET_PLAYER(eOldAlly).getCivilizationShortDescriptionKey();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	ebp, eax
$LN21@GetStatusC@2:

; 10009: 
; 10010: 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_BASE_PASSED");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR $T254934[esp+716]
	push	OFFSET $SG229307
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T254934[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10011: 				strMessage << strOldBestPlayersNameKey;

	push	ebp
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	SHORT $LN80@GetStatusC@2
$LN23@GetStatusC@2:

; 9998 : 			{
; 9999 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_ALLIES_BASE");

	lea	edx, DWORD PTR $T254933[esp+716]
	push	OFFSET $SG229300
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T254933[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z

; 10011: 				strMessage << strOldBestPlayersNameKey;

$LN80@GetStatusC@2:

; 10012: 			}
; 10013: 
; 10014: 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ALLIES_STATUS");

	lea	eax, DWORD PTR $T254935[esp+716]
	push	OFFSET $SG229309
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T254935[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10015: 
; 10016: 			// Build Resource info
; 10017: 			int iNumResourceTypes = 0;

	xor	esi, esi

; 10018: 			FStaticVector<ResourceTypes, 64, true, c_eCiv5GameplayDLL, 0> veResources;

	lea	ecx, DWORD PTR _veResources$229312[esp+728]
	xor	ebp, ebp
	mov	DWORD PTR _veResources$229312[esp+720], esi
	mov	DWORD PTR _veResources$229312[esp+724], 64 ; 00000040H
	mov	DWORD PTR _veResources$229312[esp+716], ecx

; 10019: 			ResourceTypes eResource;
; 10020: 			ResourceUsageTypes eUsage;
; 10021: 			int iResourceQuantity;
; 10022: #ifdef AUI_WARNING_FIXES
; 10023: 			for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 10024: #else
; 10025: 			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+724], 6
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN200@GetStatusC@2
	npad	1
$LL20@GetStatusC@2:

; 10026: #endif
; 10027: 			{
; 10028: 				eResource = (ResourceTypes) iResourceLoop;
; 10029: 				iResourceQuantity = GetPlayer()->getNumResourceTotal(eResource);

	mov	edx, DWORD PTR _this$[esp+716]
	mov	ecx, DWORD PTR [edx]
	push	1
	push	esi
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal

; 10030: 
; 10031: 				if(iResourceQuantity > 0)

	test	eax, eax
	jle	SHORT $LN19@GetStatusC@2

; 10032: 				{
; 10033: 					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);					

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 10034: 					if (pkResourceInfo != NULL)

	test	eax, eax
	je	SHORT $LN19@GetStatusC@2

; 10035: 					{
; 10036: 						eUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 10037: 
; 10038: 						if(eUsage == RESOURCEUSAGE_STRATEGIC || eUsage == RESOURCEUSAGE_LUXURY)

	cmp	eax, 1
	je	SHORT $LN14@GetStatusC@2
	cmp	eax, 2
	jne	SHORT $LN19@GetStatusC@2
$LN14@GetStatusC@2:

; 10039: 						{
; 10040: 							veResources.push_back(eResource);

	mov	eax, DWORD PTR _veResources$229312[esp+724]
	mov	BYTE PTR _veResources$229312[esp+984], 0
	cmp	DWORD PTR _veResources$229312[esp+720], eax
	jne	SHORT $LN92@GetStatusC@2
	push	eax
	lea	ecx, DWORD PTR _veResources$229312[esp+720]
	call	?GrowSize@?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum ResourceTypes,64,1,297,0>::GrowSize
$LN92@GetStatusC@2:
	mov	eax, DWORD PTR _veResources$229312[esp+716]
	mov	ecx, DWORD PTR _veResources$229312[esp+720]
	lea	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN95@GetStatusC@2
	mov	DWORD PTR [eax], esi
$LN95@GetStatusC@2:
	inc	DWORD PTR _veResources$229312[esp+720]

; 10041: 							iNumResourceTypes++;

	inc	ebp
$LN19@GetStatusC@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	$LL20@GetStatusC@2
$LN200@GetStatusC@2:

; 10042: 						}
; 10043: 					}
; 10044: 				}
; 10045: 			}
; 10046: 			// APPEND RESOURCE INFO
; 10047: 			Localization::String strResourceDetails;

	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+716]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+724], 7

; 10048: 			if(iNumResourceTypes == 0)

	test	ebp, ebp
	jne	SHORT $LN13@GetStatusC@2

; 10049: 			{
; 10050: 				strResourceDetails = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_GAINED_BEST_RELATIONS_BONUS_NONE");

	lea	edx, DWORD PTR $T254936[esp+716]
	push	OFFSET $SG229329
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T254936[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 7
	call	edi

; 10051: 				strResourceDetails << strMinorsNameKey;

	mov	eax, DWORD PTR _strMinorsNameKey$[esp+716]
	push	eax
	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+720]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 10052: 			}
; 10053: 			else

	jmp	$LN12@GetStatusC@2
$LN13@GetStatusC@2:

; 10054: 			{
; 10055: 				CvString strResourceNames = GC.getResourceInfo(veResources[0])->GetDescription();

	mov	ecx, DWORD PTR _veResources$229312[esp+716]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN108@GetStatusC@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN108@GetStatusC@2:
	push	eax
	lea	ecx, DWORD PTR _strResourceNames$229331[esp+720]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 10056: 				int i = 1;

	mov	esi, 1

; 10057: 				while(i < iNumResourceTypes)

	cmp	ebp, esi
	mov	bl, 9
	mov	BYTE PTR __$EHRec$[esp+724], bl
	jle	SHORT $LN10@GetStatusC@2
	npad	6
$LL11@GetStatusC@2:

; 10058: 				{
; 10059: 					strResourceNames += ", ";

	push	OFFSET $SG229336
	lea	ecx, DWORD PTR _strResourceNames$229331[esp+720]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 10060: 					strResourceNames += GC.getResourceInfo(veResources[i++])->GetDescription();

	mov	eax, DWORD PTR _veResources$229312[esp+716]
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	lea	ecx, DWORD PTR [eax+36]
	inc	esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strResourceNames$229331[esp+720]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	cmp	esi, ebp
	jl	SHORT $LL11@GetStatusC@2
$LN10@GetStatusC@2:

; 10061: 				}
; 10062: 
; 10063: 				strResourceDetails = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_GAINED_BEST_RELATIONS_BONUS_SOME");

	lea	ecx, DWORD PTR $T254937[esp+716]
	push	OFFSET $SG229338
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 10		; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T254937[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], bl
	call	edi

; 10064: 				strResourceDetails << strResourceNames.c_str();

	lea	ecx, DWORD PTR _strResourceNames$229331[esp+716]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+720]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 10065: 			}

	lea	ecx, DWORD PTR _strResourceNames$229331[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@GetStatusC@2:

; 10066: 			strMessage << strResourceDetails.toUTF8();

	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+716]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 10067: 		}

	lea	ecx, DWORD PTR _strResourceDetails$229326[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 6
	call	edi
	mov	eax, DWORD PTR _veResources$229312[esp+716]
	lea	edx, DWORD PTR _veResources$229312[esp+728]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	cmp	eax, edx
	je	$LN197@GetStatusC@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	jmp	$LN197@GetStatusC@2
$LN25@GetStatusC@2:

; 10068: 		// Went from Neutral to Friends
; 10069: 		else if(bFriends)

	cmp	BYTE PTR _bFriends$[esp+712], 0
	je	$LN197@GetStatusC@2

; 10070: 		{
; 10071: 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_NOW_FRIENDS_BASE");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR $T254940[esp+716]
	push	OFFSET $SG229344
	push	eax
	call	esi
	add	esp, 8
	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 11		; 0000000bH
	call	ebp
	lea	ecx, DWORD PTR $T254940[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10072: 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDS_STATUS");

	lea	ecx, DWORD PTR $T254941[esp+716]
	push	OFFSET $SG229346
	push	ecx
	call	esi
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+724], 12		; 0000000cH

; 10073: 		}
; 10074: 	}
; 10075: 	// Removing/Reducing bonus
; 10076: 	else

	jmp	$LN203@GetStatusC@2
$LN26@GetStatusC@2:

; 10077: 	{
; 10078: 		// Dropped from Allies
; 10079: 		if(bAllies)

	cmp	BYTE PTR _bAllies$[esp+712], 0
	je	$LN6@GetStatusC@2

; 10080: 		{
; 10081: 			// Normal friendship decay
; 10082: 			if(eNewAlly == NO_PLAYER)

	mov	ebp, DWORD PTR _eNewAlly$[esp+712]
	cmp	ebp, -1
	jne	SHORT $LN5@GetStatusC@2

; 10083: 			{
; 10084: 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_ALLIES_LOST");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR $T254942[esp+716]
	push	OFFSET $SG229351
	push	edx
	call	esi
	add	esp, 8
	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 13		; 0000000dH
	call	ebp
	lea	ecx, DWORD PTR $T254942[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10085: 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ALLIES_STATUS_LOST");

	lea	eax, DWORD PTR $T254943[esp+716]
	push	OFFSET $SG229353
	push	eax
	call	esi
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+724], 14		; 0000000eH

; 10086: 			}
; 10087: 			// Someone passed us up
; 10088: 			else

	jmp	$LN203@GetStatusC@2
$LN5@GetStatusC@2:

; 10089: 			{
; 10090: 				CvAssertMsg(eNewAlly != NO_PLAYER, "eNewAlly not expected to be NO_PLAYER here. Please send Anton your save file and version.");
; 10091: 				CvAssertMsg(eNewAlly != ePlayer, "eNewAlly not expected to be same as ePlayer here. Please send Anton your save file and version.");
; 10092: 				const char* strNewBestPlayersNameKey = "TXT_KEY_UNMET_PLAYER";
; 10093: 				TeamTypes eNewAllyTeam = GET_PLAYER(eNewAlly).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebp, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+ebp+44]
	mov	esi, OFFSET $SG229356
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN141@GetStatusC@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN142@GetStatusC@2
$LN141@GetStatusC@2:
	or	eax, -1
$LN142@GetStatusC@2:

; 10094: 				if(pTeam->isHasMet(eNewAllyTeam))

	push	eax
	mov	ecx, ebx
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN3@GetStatusC@2

; 10095: 					strNewBestPlayersNameKey = GET_PLAYER(eNewAlly).getCivilizationShortDescriptionKey();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	esi, eax
$LN3@GetStatusC@2:

; 10096: 
; 10097: 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_ALLIES_PASSED");

	mov	ebp, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR $T254944[esp+716]
	push	OFFSET $SG229360
	push	eax
	call	ebp
	add	esp, 8
	mov	ebx, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 15		; 0000000fH
	call	ebx
	lea	ecx, DWORD PTR $T254944[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10098: 				strMessage << strNewBestPlayersNameKey;

	push	esi
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 10099: 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ALLIES_STATUS_PASSED");

	lea	ecx, DWORD PTR $T254945[esp+716]
	push	OFFSET $SG229362
	push	ecx
	call	ebp
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 16		; 00000010H
	call	ebx
	lea	ecx, DWORD PTR $T254945[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10100: 				strSummary << strNewBestPlayersNameKey;

	push	esi
	lea	ecx, DWORD PTR _strSummary$[esp+720]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 10101: 			}

	jmp	SHORT $LN197@GetStatusC@2
$LN6@GetStatusC@2:

; 10102: 		}
; 10103: 		// Dropped down to Neutral from Friends (case of Allies down to Neutral not handled well... let's hope it doesn't happen often!)
; 10104: 		else if(bFriends)

	cmp	BYTE PTR _bFriends$[esp+712], 0
	je	SHORT $LN197@GetStatusC@2

; 10105: 		{
; 10106: 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDS_LOST_BASE");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR $T254946[esp+716]
	push	OFFSET $SG229366
	push	edx
	call	esi
	add	esp, 8
	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	mov	BYTE PTR __$EHRec$[esp+728], 17		; 00000011H
	call	ebp
	lea	ecx, DWORD PTR $T254946[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi

; 10107: 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDS_STATUS_LOST");

	lea	eax, DWORD PTR $T254947[esp+716]
	push	OFFSET $SG229368
	push	eax
	call	esi
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+724], 18		; 00000012H
$LN203@GetStatusC@2:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+720]
	call	ebp
	lea	ecx, DWORD PTR $T254947[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	edi
$LN197@GetStatusC@2:

; 10108: 		}
; 10109: 	}
; 10110: 
; 10111: 	CvString strDetailedInfo = GetStatusChangeDetails(ePlayer, bAdd, bFriends, bAllies);

	mov	ecx, DWORD PTR _bAllies$[esp+712]
	mov	edx, DWORD PTR _bFriends$[esp+712]
	mov	eax, DWORD PTR _bAdd$[esp+712]
	mov	ebx, DWORD PTR _this$[esp+716]
	push	ecx
	mov	ecx, DWORD PTR _ePlayer$[esp+716]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strDetailedInfo$[esp+732]
	push	edx
	mov	ecx, ebx
	call	?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z ; CvMinorCivAI::GetStatusChangeDetails

; 10112: 	strMessage << GetPlayer()->getNameKey() << strDetailedInfo;

	mov	ecx, DWORD PTR [ebx]
	mov	BYTE PTR __$EHRec$[esp+724], 19		; 00000013H
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	call	esi
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+716]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+720]
	call	esi

; 10113: 	strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [ebx]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+720]
	call	esi

; 10114: 
; 10115: 	pair<CvString, CvString> notifStrings = pair<CvString, CvString>(strMessage.toUTF8(), strSummary.toUTF8());

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strSummary$[esp+716]
	call	esi
	test	eax, eax
	jne	SHORT $LN167@GetStatusC@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN167@GetStatusC@2:
	push	eax
	lea	ecx, DWORD PTR $T254950[esp+720]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	bl, 20					; 00000014H
	lea	ecx, DWORD PTR _strMessage$[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], bl
	call	esi
	test	eax, eax
	jne	SHORT $LN172@GetStatusC@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN172@GetStatusC@2:
	push	eax
	lea	ecx, DWORD PTR $T254951[esp+720]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+712]
	lea	eax, DWORD PTR $T254951[esp+716]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+728], 21		; 00000015H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	edx, DWORD PTR $T254950[esp+716]
	lea	ecx, DWORD PTR [esi+28]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+728], 22		; 00000016H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 10116: 	return notifStrings;

	lea	ecx, DWORD PTR $T254951[esp+716]
	mov	DWORD PTR $T254974[esp+716], 1
	mov	BYTE PTR __$EHRec$[esp+724], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T254950[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 19		; 00000013H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 1
	call	edi
	lea	ecx, DWORD PTR _strMessage$[esp+716]
	mov	BYTE PTR __$EHRec$[esp+724], 0
	call	edi

; 10117: }

	mov	ecx, DWORD PTR __$EHRec$[esp+716]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 700				; 000002bcH
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$3:
	lea	ecx, DWORD PTR $T254934[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$2:
	lea	ecx, DWORD PTR $T254933[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$4:
	lea	ecx, DWORD PTR $T254935[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$5:
	lea	ecx, DWORD PTR _veResources$229312[ebp]
	jmp	??1?$FStaticVector@W4ResourceTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum ResourceTypes,64,1,297,0>::~FStaticVector<enum ResourceTypes,64,1,297,0>
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$6:
	lea	ecx, DWORD PTR _strResourceDetails$229326[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$7:
	lea	ecx, DWORD PTR $T254936[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$8:
	lea	ecx, DWORD PTR _strResourceNames$229331[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$9:
	lea	ecx, DWORD PTR $T254937[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$10:
	lea	ecx, DWORD PTR $T254940[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$11:
	lea	ecx, DWORD PTR $T254941[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$12:
	lea	ecx, DWORD PTR $T254942[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$13:
	lea	ecx, DWORD PTR $T254943[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$14:
	lea	ecx, DWORD PTR $T254944[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$15:
	lea	ecx, DWORD PTR $T254945[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$16:
	lea	ecx, DWORD PTR $T254946[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$17:
	lea	ecx, DWORD PTR $T254947[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$18:
	lea	ecx, DWORD PTR _strDetailedInfo$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$19:
	lea	ecx, DWORD PTR $T254950[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$20:
	lea	ecx, DWORD PTR $T254951[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$26:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z$21:
	mov	eax, DWORD PTR $T254974[ebp]
	and	eax, 1
	je	$LN51@GetStatusC@2
	and	DWORD PTR $T254974[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$pair@VCvString@@V1@@std@@QAE@XZ
$LN51@GetStatusC@2:
	ret	0
__ehhandler$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z ENDP ; CvMinorCivAI::GetStatusChangeNotificationStrings
PUBLIC	?push_back@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEIABVCvMinorCivQuest@@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEIABVCvMinorCivQuest@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEIABVCvMinorCivQuest@@@Z PROC ; FStaticVector<CvMinorCivQuest,5,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebx
	mov	ebx, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	mov	BYTE PTR [ebx+152], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back@13

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::GrowSize
$LN1@push_back@13:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN4@push_back@13
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 7
	rep movsd
	pop	esi
$LN4@push_back@13:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEIABVCvMinorCivQuest@@@Z ENDP ; FStaticVector<CvMinorCivQuest,5,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@2@ABW4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T255305 = 12						; size = 4
$T255303 = 12						; size = 4
__Where$230044 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@2@ABW4MinorCivQuestTypes@@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setl	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$230044[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T255303[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$230044[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jge	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T255305[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@2@ABW4MinorCivQuestTypes@@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::insert
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z ; CvWeightedVector<int,64,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z PROC ; CvWeightedVector<int,64,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@14
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN5@push_back@14:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@14
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@14:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$0EA@$00@@QAEIABHH@Z ENDP ; CvWeightedVector<int,64,1>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEIABW4PlayerTypes@@H@Z ; CvWeightedVector<enum PlayerTypes,22,1>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEIABW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEIABW4PlayerTypes@@H@Z PROC ; CvWeightedVector<enum PlayerTypes,22,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+188], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@15
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::GrowSize
$LN5@push_back@15:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@15
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@15:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEIABW4PlayerTypes@@H@Z ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@H$0GE@$00@@QAEIABHH@Z ; CvWeightedVector<int,100,1>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$CvWeightedVector@H$0GE@$00@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$0GE@$00@@QAEIABHH@Z PROC ; CvWeightedVector<int,100,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+812], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@16
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN5@push_back@16:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@16
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@16:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$0GE@$00@@QAEIABHH@Z ENDP ; CvWeightedVector<int,100,1>::push_back
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	npad	2
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN12@Destroy
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN12@Destroy:
	add	esi, 156				; 0000009cH
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T255628 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@3
	cmp	edx, eax
	jne	SHORT $LN101@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@3:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@3
	npad	2
$LL2@erase@3:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+17], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@3
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN103@erase@3
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN79@erase@3
	npad	5
$LL80@erase@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL80@erase@3
$LN79@erase@3:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@3
$LN103@erase@3:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN63@erase@3
	npad	7
$LL64@erase@3:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@3
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL64@erase@3
$LN63@erase@3:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@3:
	push	edx
	lea	eax, DWORD PTR $T255628[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAE@ABU?$less@W4MinorCivQuestTypes@@@1@V?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree_val<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@1@0PAW42@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ucopy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@1@0PAW42@@Z
_TEXT	SEGMENT
$T256039 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$256043 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@1@0PAW42@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ucopy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$256043[esp]
	mov	BYTE PTR $T256039[esp+4], 0
	mov	eax, DWORD PTR $T256039[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@1@0PAW42@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ucopy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T256050 = -4						; size = 1
__Cat$256055 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T256050[esp+4], 0
	mov	eax, DWORD PTR $T256050[esp+4]
	mov	ecx, DWORD PTR __Cat$256055[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T256122 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$256126 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$256126[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T256122[esp+4], 0
	mov	eax, DWORD PTR $T256122[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap@2
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap@2
$LN24@Sort_heap@2:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap@2:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap@2
$LN1@Sort_heap@2:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap@3
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap@3
$LN24@Sort_heap@3:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap@3:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap@3
$LN1@Sort_heap@3:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap@4
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap@4
$LN24@Sort_heap@4:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap@4:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap@4
$LN1@Sort_heap@4:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@8
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@8:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@8
	pop	esi
$LN13@unchecked_@8:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	?DoTestThreatenedAnnouncement@CvMinorCivAI@@QAEXXZ ; CvMinorCivAI::DoTestThreatenedAnnouncement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?DoTestThreatenedAnnouncement@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoTestThreatenedAnnouncement@CvMinorCivAI@@QAEXXZ PROC	; CvMinorCivAI::DoTestThreatenedAnnouncement, COMDAT
; _this$ = ecx

; 2579 : {

	push	esi
	mov	esi, ecx

; 2580 : 	// Increment counter - this is only used when sending notifications to players
; 2581 : 	if(GetTurnsSinceThreatenedAnnouncement() >= 0)

	mov	eax, DWORD PTR [esi+20]
	or	edx, -1
	test	eax, eax
	jl	SHORT $LN23@DoTestThre@2

; 2582 : 	{
; 2583 : 		ChangeTurnsSinceThreatenedAnnouncement(1);

	lea	ecx, DWORD PTR [eax+1]
	cmp	eax, ecx
	je	SHORT $LN16@DoTestThre@2
	mov	DWORD PTR [esi+20], ecx
$LN16@DoTestThre@2:

; 2584 : 
; 2585 : 		// Long enough to have expired?
; 2586 : 		if(GetTurnsSinceThreatenedAnnouncement() >= 30)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 30					; 0000001eH
	jl	SHORT $LN23@DoTestThre@2

; 2587 : 			SetTurnsSinceThreatenedAnnouncement(-1);

	cmp	eax, edx
	je	SHORT $LN23@DoTestThre@2
	mov	DWORD PTR [esi+20], edx
$LN23@DoTestThre@2:

; 2588 : 	}
; 2589 : 
; 2590 : 	// Not already threatened?
; 2591 : 	if(GetTurnsSinceThreatenedAnnouncement() == -1)

	cmp	DWORD PTR [esi+20], edx
	jne	SHORT $LN1@DoTestThre@2
	push	edi

; 2592 : 	{
; 2593 : 		if(GetNumThreateningBarbarians() >= GC.getMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD())

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3240
	mov	ecx, esi
	call	?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetNumThreateningBarbarians
	cmp	eax, edi
	jl	SHORT $LN39@DoTestThre@2

; 2594 : 		{
; 2595 : 			// Wasn't under attack before, but is now!
; 2596 : 			SetTurnsSinceThreatenedAnnouncement(0);

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN32@DoTestThre@2
	mov	DWORD PTR [esi+20], 0
$LN32@DoTestThre@2:

; 2597 : 
; 2598 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	npad	4
$LL3@DoTestThre@2:

; 2599 : 			{
; 2600 : 				DoTestThreatenedAnnouncementForPlayer((PlayerTypes) iPlayerLoop);

	push	edi
	mov	ecx, esi
	call	?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestThreatenedAnnouncementForPlayer
	inc	edi
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL3@DoTestThre@2
$LN39@DoTestThre@2:
	pop	edi
$LN1@DoTestThre@2:
	pop	esi

; 2601 : 			}
; 2602 : 		}
; 2603 : 	}
; 2604 : }

	ret	0
?DoTestThreatenedAnnouncement@CvMinorCivAI@@QAEXXZ ENDP	; CvMinorCivAI::DoTestThreatenedAnnouncement
_TEXT	ENDS
PUBLIC	?DoObsoleteQuests@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoObsoleteQuests
; Function compile flags: /Ogtpy
;	COMDAT ?DoObsoleteQuests@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoObsoleteQuests@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoObsoleteQuests, COMDAT
; _this$ = ecx

; 3244 : {

	push	esi
	push	edi
	mov	edi, ecx

; 3245 : 	for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
$LL3@DoObsolete@2:

; 3246 : 	{
; 3247 : 		PlayerTypes eMajorLoop = (PlayerTypes) iMajorLoop;
; 3248 : 		DoObsoleteQuestsForPlayer(eMajorLoop);

	push	-1
	push	esi
	mov	ecx, edi
	call	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL3@DoObsolete@2
	pop	edi
	pop	esi

; 3249 : 	}
; 3250 : }

	ret	0
?DoObsoleteQuests@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoObsoleteQuests
_TEXT	ENDS
PUBLIC	?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z ; CvMinorCivAI::DoSetBonus
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$12
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$13
	DD	04H
	DD	FLAT:__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z
_TEXT	SEGMENT
_iNotifyLoop$226370 = -392				; size = 4
_eOldAlly$ = -388					; size = 4
$T256638 = -384						; size = 4
_strOldBestPlayersNameKey$226383 = -384			; size = 4
$T256637 = -380						; size = 4
$T256633 = -380						; size = 4
_pNotifyTeam$226377 = -380				; size = 4
tv1073 = -376						; size = 4
$T256628 = -376						; size = 4
_this$ = -372						; size = 4
_eOldAllyTeam$ = -368					; size = 4
tv830 = -364						; size = 4
$T256627 = -364						; size = 4
$T256635 = -360						; size = 80
$T256632 = -360						; size = 80
$T256631 = -360						; size = 80
$T256630 = -360						; size = 80
$T256629 = -360						; size = 80
_notifStrings$226363 = -360				; size = 56
_strMessageOthers$ = -280				; size = 80
_strSummaryOthers$ = -200				; size = 80
_strDetailedInfo$ = -120				; size = 28
$T256636 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_bAdd$ = 12						; size = 1
_bFriends$ = 16						; size = 1
_bAllies$ = 20						; size = 1
_bSuppressNotifications$ = 24				; size = 1
_bPassedBySomeone$ = 28					; size = 1
_eNewAlly$ = 32						; size = 4
?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z PROC ; CvMinorCivAI::DoSetBonus, COMDAT
; _this$ = ecx

; 6119 : {

	push	-1
	push	__ehhandler$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 380				; 0000017cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 6120 : 	MinorCivTraitTypes eTrait = GetTrait();

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	DWORD PTR _this$[esp+412], edi
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	$LN211@DoSetBonus
	mov	eax, DWORD PTR [eax+272]

; 6121 : 
; 6122 : 	// Cultured
; 6123 : 	if(eTrait == MINOR_CIV_TRAIT_CULTURED)

	test	eax, eax
	je	$LN211@DoSetBonus

; 6124 : 	{
; 6125 : 	}
; 6126 : 	// Militaristic
; 6127 : 	else if(eTrait == MINOR_CIV_TRAIT_MILITARISTIC)

	cmp	eax, 1
	jne	SHORT $LN39@DoSetBonus

; 6128 : 	{
; 6129 : 		if(bAdd)

	cmp	BYTE PTR _bAdd$[esp+404], 0

; 6130 : 		{
; 6131 : 			// Seed Counter if it hasn't been done yet in this game. We don't have to undo this at any point because the counter is not processed if we are no longer Friends
; 6132 : 			if(GetUnitSpawnCounter(ePlayer) == -1)

	mov	esi, DWORD PTR _ePlayer$[esp+404]
	je	$LN30@DoSetBonus
	cmp	esi, 21					; 00000015H
	ja	SHORT $LN206@DoSetBonus
	cmp	DWORD PTR [edi+esi*4+2552], -1
	jne	$LN30@DoSetBonus
$LN206@DoSetBonus:

; 6133 : 				DoSeedUnitSpawnCounter(ePlayer, /*bBias*/ true);

	push	1
	push	esi
	mov	ecx, edi
	call	?DoSeedUnitSpawnCounter@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoSeedUnitSpawnCounter

; 6134 : 		}
; 6135 : 	}

	jmp	$LN30@DoSetBonus
$LN39@DoSetBonus:

; 6136 : 	// Maritime
; 6137 : 	else if(eTrait == MINOR_CIV_TRAIT_MARITIME)

	cmp	eax, 2
	jne	$LN35@DoSetBonus

; 6138 : 	{
; 6139 : 		int iCapitalFoodTimes100 = 0;
; 6140 : 		int iOtherCitiesFoodTimes100 = 0;
; 6141 : 
; 6142 : 		if(bFriends)	// Friends bonus
; 6143 : 		{
; 6144 : 			iCapitalFoodTimes100 += GetFriendsCapitalFoodBonus(ePlayer);

	mov	esi, DWORD PTR _ePlayer$[esp+404]
	xor	ebx, ebx
	xor	ebp, ebp
	cmp	BYTE PTR _bFriends$[esp+404], bl
	je	SHORT $LN34@DoSetBonus
	push	-1
	push	esi
	mov	ecx, edi
	call	?GetFriendsCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsCapitalFoodBonus

; 6145 : 			iOtherCitiesFoodTimes100 += GetFriendsOtherCityFoodBonus(ePlayer);

	push	-1
	push	esi
	mov	ecx, edi
	mov	ebp, eax
	call	?GetFriendsOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::GetFriendsOtherCityFoodBonus
	mov	ebx, eax
$LN34@DoSetBonus:

; 6146 : 		}
; 6147 : 		if(bAllies)		// Allies bonus

	cmp	BYTE PTR _bAllies$[esp+404], 0
	je	SHORT $LN33@DoSetBonus

; 6148 : 		{
; 6149 : 			iCapitalFoodTimes100 += GetAlliesCapitalFoodBonus(ePlayer);

	push	esi
	mov	ecx, edi
	call	?GetAlliesCapitalFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesCapitalFoodBonus

; 6150 : 			iOtherCitiesFoodTimes100 += GetAlliesOtherCityFoodBonus(ePlayer);

	push	esi
	mov	ecx, edi
	add	ebp, eax
	call	?GetAlliesOtherCityFoodBonus@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetAlliesOtherCityFoodBonus
	add	ebx, eax
$LN33@DoSetBonus:

; 6151 : 		}
; 6152 : 
; 6153 : 		if(!bAdd)		// Flip amount of we're taking bonuses away

	cmp	BYTE PTR _bAdd$[esp+404], 0
	jne	SHORT $LN32@DoSetBonus

; 6154 : 		{
; 6155 : 			iCapitalFoodTimes100 = -iCapitalFoodTimes100;

	neg	ebp

; 6156 : 			iOtherCitiesFoodTimes100 = -iOtherCitiesFoodTimes100;

	neg	ebx
$LN32@DoSetBonus:

; 6157 : 		}
; 6158 : 
; 6159 : 		GET_PLAYER(ePlayer).ChangeCapitalYieldChange(YIELD_FOOD, iCapitalFoodTimes100);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	push	ebp
	push	0
	add	ecx, esi
	call	?ChangeCapitalYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z ; CvPlayer::ChangeCapitalYieldChange

; 6160 : 		GET_PLAYER(ePlayer).ChangeCityYieldChange(YIELD_FOOD, iOtherCitiesFoodTimes100);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	0
	lea	ecx, DWORD PTR [esi+edx]
	call	?ChangeCityYieldChange@CvPlayer@@QAEXW4YieldTypes@@H@Z ; CvPlayer::ChangeCityYieldChange
	jmp	SHORT $LN211@DoSetBonus
$LN35@DoSetBonus:

; 6161 : 	}
; 6162 : 	// Mercantile
; 6163 : 	else if(eTrait == MINOR_CIV_TRAIT_MERCANTILE)

	cmp	eax, 3
	jne	SHORT $LN211@DoSetBonus

; 6164 : 	{
; 6165 : 		GET_PLAYER(ePlayer).DoUpdateHappiness();

	mov	ecx, DWORD PTR _ePlayer$[esp+404]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN211@DoSetBonus:

; 6134 : 		}
; 6135 : 	}

	mov	esi, DWORD PTR _ePlayer$[esp+404]
$LN30@DoSetBonus:

; 6166 : 	}
; 6167 : 	// Religious
; 6168 : 	if(eTrait == MINOR_CIV_TRAIT_RELIGIOUS)
; 6169 : 	{
; 6170 : 	}
; 6171 : 
; 6172 : 	if(ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN28@DoSetBonus

; 6173 : 	{
; 6174 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx
$LN28@DoSetBonus:

; 6175 : 	}
; 6176 : 
; 6177 : 	CvString strDetailedInfo = GetStatusChangeDetails(ePlayer, bAdd, bFriends, bAllies);

	mov	ebx, DWORD PTR _bAllies$[esp+404]
	mov	eax, DWORD PTR _bFriends$[esp+404]
	mov	ecx, DWORD PTR _bAdd$[esp+404]
	push	ebx
	push	eax
	push	ecx
	push	esi
	lea	edx, DWORD PTR _strDetailedInfo$[esp+424]
	push	edx
	mov	ecx, edi
	call	?GetStatusChangeDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@_N11@Z ; CvMinorCivAI::GetStatusChangeDetails

; 6178 : 
; 6179 : 	PlayerTypes eOldAlly = GetAlly();

	mov	ebp, DWORD PTR [edi+2012]
	mov	DWORD PTR __$EHRec$[esp+416], 0
	mov	DWORD PTR _eOldAlly$[esp+408], ebp

; 6180 : 	TeamTypes eOldAllyTeam = eOldAlly != NO_PLAYER ? GET_PLAYER(eOldAlly).getTeam() : NO_TEAM;

	cmp	ebp, -1
	je	SHORT $LN44@DoSetBonus
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, ebp
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN97@DoSetBonus
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _eOldAllyTeam$[esp+408], eax
	jmp	SHORT $LN45@DoSetBonus
$LN97@DoSetBonus:
	or	eax, -1
	mov	DWORD PTR _eOldAllyTeam$[esp+408], eax
	jmp	SHORT $LN45@DoSetBonus
$LN44@DoSetBonus:
	mov	DWORD PTR _eOldAllyTeam$[esp+408], -1
$LN45@DoSetBonus:

; 6181 : 
; 6182 : 	// Should we remove the Ally bonus from another player?
; 6183 : 	if(bAdd && bAllies)

	mov	ecx, DWORD PTR _bAdd$[esp+404]
	test	cl, cl
	je	SHORT $LN26@DoSetBonus
	test	bl, bl
	je	SHORT $LN26@DoSetBonus

; 6184 : 	{
; 6185 : 		if(eOldAlly != NO_PLAYER && ePlayer != eOldAlly)

	cmp	ebp, -1
	je	SHORT $LN26@DoSetBonus
	cmp	esi, ebp
	je	SHORT $LN26@DoSetBonus

; 6186 : 		{
; 6187 : 			DoSetBonus(eOldAlly, /*bAdd*/ false, /*bFriends*/ false, /*bAllies*/ true, /*bSuppressNotifications*/ false, /*bPassedBySomeone*/ true, ePlayer);

	push	esi
	push	1
	push	0
	push	1
	push	0
	push	0
	push	ebp
	mov	ecx, edi
	call	?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z ; CvMinorCivAI::DoSetBonus
	mov	ecx, DWORD PTR _bAdd$[esp+404]
$LN26@DoSetBonus:

; 6188 : 		}
; 6189 : 	}
; 6190 : 
; 6191 : 	// *******************************************
; 6192 : 	// NOTIFICATIONS FOR THIS PLAYER
; 6193 : 	// *******************************************
; 6194 : 	// We're not displaying notifications at all
; 6195 : 	if (IsDisableNotifications())

	cmp	BYTE PTR [edi+6864], 0

; 6196 : 	{
; 6197 : 		return;

	jne	$LN218@DoSetBonus

; 6198 : 	}
; 6199 : 
; 6200 : 	if (!bSuppressNotifications)

	cmp	BYTE PTR _bSuppressNotifications$[esp+404], 0
	jne	$LN24@DoSetBonus

; 6201 : 	{
; 6202 : 		pair<CvString, CvString> notifStrings = GetStatusChangeNotificationStrings(ePlayer, bAdd, bFriends, bAllies, eOldAlly, (bAdd && bAllies) ? ePlayer : eNewAlly);

	test	cl, cl
	je	SHORT $LN46@DoSetBonus
	mov	eax, esi
	test	bl, bl
	jne	SHORT $LN47@DoSetBonus
$LN46@DoSetBonus:
	mov	eax, DWORD PTR _eNewAlly$[esp+404]
$LN47@DoSetBonus:
	mov	edx, DWORD PTR _bFriends$[esp+404]
	push	eax
	push	ebp
	push	ebx
	push	edx
	push	ecx
	push	esi
	lea	eax, DWORD PTR _notifStrings$226363[esp+432]
	push	eax
	mov	ecx, edi
	call	?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z ; CvMinorCivAI::GetStatusChangeNotificationStrings

; 6203 : 		AddNotification(notifStrings.first, notifStrings.second, ePlayer);

	push	-1
	push	-1
	push	esi
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _notifStrings$226363[esp+476]
	mov	DWORD PTR $T256627[esp+448], esp
	mov	ecx, esp
	push	edx
	mov	BYTE PTR __$EHRec$[esp+460], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _notifStrings$226363[esp+476]
	mov	DWORD PTR $T256628[esp+476], esp
	mov	ecx, esp
	push	eax
	mov	BYTE PTR __$EHRec$[esp+488], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+484], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification

; 6204 : 	}

	lea	ecx, DWORD PTR _notifStrings$226363[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 0
	call	??1?$pair@VCvString@@V1@@std@@QAE@XZ
$LN24@DoSetBonus:

; 6205 : 
; 6206 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6207 : 	GET_PLAYER(ePlayer).doSelfConsistencyCheckAllCities();
; 6208 : #endif
; 6209 : 
; 6210 : 	// *******************************************
; 6211 : 	// NOTIFICATIONS FOR OTHER PLAYERS IN THE GAME
; 6212 : 	// *******************************************
; 6213 : 	Localization::String strMessageOthers;

	mov	ebp, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessageOthers$[esp+408]
	call	ebp

; 6214 : 	Localization::String strSummaryOthers;

	lea	ecx, DWORD PTR _strSummaryOthers$[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 3
	call	ebp

; 6215 : 
; 6216 : 	// We need to do this because this function is recursive, and if we're UNDOING someone else, we don't yet know who the new guy is because it hasn't been set yet
; 6217 : 	if(bPassedBySomeone)

	cmp	BYTE PTR _bPassedBySomeone$[esp+404], 0
	mov	BYTE PTR __$EHRec$[esp+416], 4
	je	SHORT $LN23@DoSetBonus

; 6218 : 		ePlayer = eNewAlly;

	mov	ecx, DWORD PTR _eNewAlly$[esp+404]
	mov	DWORD PTR _ePlayer$[esp+404], ecx
	mov	esi, ecx
$LN23@DoSetBonus:

; 6219 : 
; 6220 : 	for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	xor	eax, eax
	mov	ebp, esi
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	imul	ebp, 63236				; 0000f704H
	mov	DWORD PTR _iNotifyLoop$226370[esp+408], eax
	mov	DWORD PTR tv830[esp+408], ebp
	mov	DWORD PTR tv1073[esp+408], eax
	jmp	SHORT $LN22@DoSetBonus
	npad	9
$LL214@DoSetBonus:
	mov	edi, DWORD PTR _this$[esp+408]
	mov	ebp, DWORD PTR tv830[esp+408]
$LN22@DoSetBonus:

; 6221 : 		PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;
; 6222 : 		CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 6223 : 		CvTeam* pNotifyTeam = &GET_TEAM(kCurNotifyPlayer.getTeam());

	mov	eax, DWORD PTR tv1073[esp+408]
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN119@DoSetBonus
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN120@DoSetBonus
$LN119@DoSetBonus:
	or	eax, -1
$LN120@DoSetBonus:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax

; 6224 : 		TeamTypes eNewAllyTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR [edx+ebp+44]
	mov	DWORD PTR _pNotifyTeam$226377[esp+408], ecx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN132@DoSetBonus
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN133@DoSetBonus
$LN132@DoSetBonus:
	or	eax, -1
$LN133@DoSetBonus:

; 6225 : 		const char* strNewBestPlayersNameKey;
; 6226 : 
; 6227 : 		// Notify player has met the new Ally
; 6228 : 		if(pNotifyTeam->isHasMet(eNewAllyTeam))

	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN19@DoSetBonus

; 6229 : 			strNewBestPlayersNameKey = GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	ebp, eax

; 6230 : 		// Notify player has NOT met the new Ally
; 6231 : 		else

	jmp	SHORT $LN18@DoSetBonus
$LN19@DoSetBonus:

; 6232 : 			strNewBestPlayersNameKey = "TXT_KEY_UNMET_PLAYER";

	mov	ebp, OFFSET $SG226382
$LN18@DoSetBonus:

; 6233 : 
; 6234 : 		const char* strOldBestPlayersNameKey = "";
; 6235 : 
; 6236 : 		// Someone got passed up
; 6237 : 		if(eOldAlly != NO_PLAYER)

	cmp	DWORD PTR _eOldAlly$[esp+408], -1
	mov	DWORD PTR _strOldBestPlayersNameKey$226383[esp+408], OFFSET $SG226384
	je	SHORT $LN15@DoSetBonus

; 6238 : 		{
; 6239 : 			// Notify player has met the old Ally
; 6240 : 			if(pNotifyTeam->isHasMet(eOldAllyTeam))

	mov	ecx, DWORD PTR _eOldAllyTeam$[esp+408]
	push	ecx
	mov	ecx, DWORD PTR _pNotifyTeam$226377[esp+412]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN16@DoSetBonus

; 6241 : 				strOldBestPlayersNameKey = GET_PLAYER(eOldAlly).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR _eOldAlly$[esp+408]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strOldBestPlayersNameKey$226383[esp+408], eax

; 6242 : 			// Notify player has NOT met the old Ally
; 6243 : 			else

	jmp	SHORT $LN15@DoSetBonus
$LN16@DoSetBonus:

; 6244 : 				strOldBestPlayersNameKey = "TXT_KEY_UNMET_PLAYER";

	mov	DWORD PTR _strOldBestPlayersNameKey$226383[esp+408], OFFSET $SG226388
$LN15@DoSetBonus:

; 6245 : 		}
; 6246 : 
; 6247 : 		const char* strMinorsNameKey = GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [edi]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 6248 : 		TeamTypes eMinorTeam = GetPlayer()->getTeam();

	mov	edx, DWORD PTR _this$[esp+408]
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN149@DoSetBonus
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN150@DoSetBonus
$LN149@DoSetBonus:
	or	eax, -1
$LN150@DoSetBonus:

; 6249 : 
; 6250 : 		// Adding/Increasing bonus
; 6251 : 		if(bAdd)

	cmp	BYTE PTR _bAdd$[esp+404], 0
	je	$LN14@DoSetBonus

; 6252 : 		{
; 6253 : 			// Jumped up to Allies (either from Neutral or from Friends, or passing another player)
; 6254 : 			if(bAllies)

	cmp	BYTE PTR _bAllies$[esp+404], 0
	je	$LN21@DoSetBonus

; 6255 : 			{
; 6256 : 				if(ePlayer != eNotifyPlayer)

	mov	ecx, DWORD PTR _ePlayer$[esp+404]
	cmp	ecx, DWORD PTR _iNotifyLoop$226370[esp+408]
	je	$LN21@DoSetBonus

; 6257 : 				{
; 6258 : 					// Has the notify player met this minor
; 6259 : 					if(pNotifyTeam->isHasMet(eMinorTeam))

	mov	ecx, DWORD PTR _pNotifyTeam$226377[esp+408]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN21@DoSetBonus

; 6260 : 					{
; 6261 : 						// Someone got passed up
; 6262 : 						if(eOldAlly != NO_PLAYER && eOldAlly != ePlayer)

	mov	eax, DWORD PTR _eOldAlly$[esp+408]
	cmp	eax, -1
	je	$LN10@DoSetBonus
	cmp	eax, DWORD PTR _ePlayer$[esp+404]
	je	$LN10@DoSetBonus

; 6263 : 						{
; 6264 : 							strMessageOthers = Localization::Lookup("TXT_KEY_NTFN_MINOR_NEW_BEST_RELATIONS_ALL");

	lea	edx, DWORD PTR $T256629[esp+408]
	push	OFFSET $SG226397
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	mov	BYTE PTR __$EHRec$[esp+420], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256629[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	ebx

; 6265 : 							strMessageOthers << strNewBestPlayersNameKey << strOldBestPlayersNameKey << strMinorsNameKey;

	push	ebp
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi
	mov	eax, DWORD PTR _strOldBestPlayersNameKey$226383[esp+408]
	push	eax
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi
	push	edi
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi

; 6266 : 							strSummaryOthers = Localization::Lookup("TXT_KEY_NTFN_SMMRY_MINOR_BEST_RELATIONS_ALL");

	lea	ecx, DWORD PTR $T256630[esp+408]
	push	OFFSET $SG226399
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	mov	BYTE PTR __$EHRec$[esp+420], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256630[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	ebx

; 6267 : 							strSummaryOthers << strMinorsNameKey;

	push	edi

; 6268 : 						}
; 6269 : 						// No one previously had the bonus
; 6270 : 						else

	jmp	$LN219@DoSetBonus
$LN10@DoSetBonus:

; 6271 : 						{
; 6272 : 							strMessageOthers = Localization::Lookup("TXT_KEY_NTFN_MINOR_NOW_BEST_RELATIONS_ALL");

	lea	edx, DWORD PTR $T256631[esp+408]
	push	OFFSET $SG226402
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	mov	BYTE PTR __$EHRec$[esp+420], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256631[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	ebx

; 6273 : 							strMessageOthers << strNewBestPlayersNameKey << strMinorsNameKey;

	push	ebp
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi
	push	edi
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi

; 6274 : 							strSummaryOthers = Localization::Lookup("TXT_KEY_NTFN_SMMRY_MINOR_NOW_ALLIES_ALL");

	lea	eax, DWORD PTR $T256632[esp+408]
	push	OFFSET $SG226404
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	mov	BYTE PTR __$EHRec$[esp+420], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256632[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	ebx

; 6275 : 							strSummaryOthers << strMinorsNameKey << strNewBestPlayersNameKey;

	push	edi
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	call	esi
	push	ebp
$LN219@DoSetBonus:
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	call	esi

; 6276 : 						}
; 6277 : 
; 6278 : 						// If we're being passed by someone, then don't display this message... we'll roll it into a later one
; 6279 : 						if(eOldAlly != eNotifyPlayer)

	mov	eax, DWORD PTR _iNotifyLoop$226370[esp+408]
	cmp	DWORD PTR _eOldAlly$[esp+408], eax
	je	$LN21@DoSetBonus

; 6280 : 							AddNotification(strMessageOthers.toUTF8(), strSummaryOthers.toUTF8(), eNotifyPlayer);

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+420]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T256633[esp+448], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN173@DoSetBonus
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN173@DoSetBonus:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+456], 9

; 6281 : 					}
; 6282 : 				}
; 6283 : 			}
; 6284 : 		}
; 6285 : 		// Removing/Reducing bonus
; 6286 : 		else

	jmp	$LN221@DoSetBonus
$LN14@DoSetBonus:

; 6287 : 		{
; 6288 : 			// Dropped from Allies
; 6289 : 			if(bAllies)

	cmp	BYTE PTR _bAllies$[esp+404], 0
	je	$LN21@DoSetBonus

; 6290 : 			{
; 6291 : 				if(ePlayer != eNotifyPlayer)

	mov	ecx, DWORD PTR _iNotifyLoop$226370[esp+408]
	cmp	DWORD PTR _ePlayer$[esp+404], ecx
	je	$LN21@DoSetBonus

; 6292 : 				{
; 6293 : 					if(pNotifyTeam->isHasMet(eMinorTeam))

	mov	ebp, DWORD PTR _pNotifyTeam$226377[esp+408]
	push	eax
	mov	ecx, ebp
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN21@DoSetBonus

; 6294 : 					{
; 6295 : 						// Only show this message for normal friendship decay
; 6296 : 						if(!bPassedBySomeone)

	cmp	BYTE PTR _bPassedBySomeone$[esp+404], 0
	jne	$LN21@DoSetBonus

; 6297 : 						{
; 6298 : 							const char* strOldAllyNameKey;
; 6299 : 
; 6300 : 							// Notify player has met the old Ally
; 6301 : 							if(pNotifyTeam->isHasMet(eOldAllyTeam))

	mov	edx, DWORD PTR _eOldAllyTeam$[esp+408]
	push	edx
	mov	ecx, ebp
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN2@DoSetBonus

; 6302 : 								strOldAllyNameKey = GET_PLAYER(eOldAlly).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR _eOldAlly$[esp+408]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	ebp, eax

; 6303 : 							// Notify player has NOT met the old Ally
; 6304 : 							else

	jmp	SHORT $LN1@DoSetBonus
$LN2@DoSetBonus:

; 6305 : 								strOldAllyNameKey = "TXT_KEY_UNMET_PLAYER";

	mov	ebp, OFFSET $SG226416
$LN1@DoSetBonus:

; 6306 : 
; 6307 : 							strMessageOthers = Localization::Lookup("TXT_KEY_NTFN_MINOR_BEST_RELATIONS_LOST_ALL");

	lea	eax, DWORD PTR $T256635[esp+408]
	push	OFFSET $SG226418
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	mov	BYTE PTR __$EHRec$[esp+420], 10		; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256635[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	ebx

; 6308 : 							strMessageOthers << strOldAllyNameKey << strMinorsNameKey;

	push	ebp
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi
	push	edi
	lea	ecx, DWORD PTR _strMessageOthers$[esp+412]
	call	esi

; 6309 : 							strSummaryOthers = Localization::Lookup("TXT_KEY_NTFN_SMMRY_MINOR_BEST_RELATIONS_LOST_ALL");

	lea	ecx, DWORD PTR $T256636[esp+408]
	push	OFFSET $SG226420
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	mov	BYTE PTR __$EHRec$[esp+420], 11		; 0000000bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256636[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	ebx

; 6310 : 							strSummaryOthers << strMinorsNameKey << strOldAllyNameKey;

	push	edi
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	call	esi
	push	ebp
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+412]
	call	esi

; 6311 : 
; 6312 : 							AddNotification(strMessageOthers.toUTF8(), strSummaryOthers.toUTF8(), eNotifyPlayer);

	mov	edx, DWORD PTR _iNotifyLoop$226370[esp+408]
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	edx
	lea	ecx, DWORD PTR _strSummaryOthers$[esp+420]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T256637[esp+448], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN193@DoSetBonus
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN193@DoSetBonus:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+456], 12		; 0000000cH
$LN221@DoSetBonus:
	lea	ecx, DWORD PTR _strMessageOthers$[esp+448]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T256638[esp+476], esp
	test	eax, eax
	jne	SHORT $LN198@DoSetBonus
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN198@DoSetBonus:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR _this$[esp+476]
	mov	BYTE PTR __$EHRec$[esp+484], 4
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification
$LN21@DoSetBonus:
	mov	eax, DWORD PTR tv1073[esp+408]
	inc	DWORD PTR _iNotifyLoop$226370[esp+408]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv1073[esp+408], eax
	jl	$LL214@DoSetBonus

; 6313 : 						}
; 6314 : 					}
; 6315 : 				}
; 6316 : 			}
; 6317 : 		}
; 6318 : 	}
; 6319 : }

	lea	ecx, DWORD PTR _strSummaryOthers$[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 3
	call	ebx
	lea	ecx, DWORD PTR _strMessageOthers$[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 0
	call	ebx
$LN218@DoSetBonus:
	lea	ecx, DWORD PTR _strDetailedInfo$[esp+408]
	mov	DWORD PTR __$EHRec$[esp+416], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+408]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 392				; 00000188H
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$0:
	lea	ecx, DWORD PTR _strDetailedInfo$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$1:
	lea	ecx, DWORD PTR _notifStrings$226363[ebp]
	jmp	??1?$pair@VCvString@@V1@@std@@QAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$2:
	mov	ecx, DWORD PTR $T256627[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$4:
	lea	ecx, DWORD PTR _strMessageOthers$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$5:
	lea	ecx, DWORD PTR _strSummaryOthers$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$6:
	lea	ecx, DWORD PTR $T256629[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$7:
	lea	ecx, DWORD PTR $T256630[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$8:
	lea	ecx, DWORD PTR $T256631[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$9:
	lea	ecx, DWORD PTR $T256632[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$10:
	mov	ecx, DWORD PTR $T256633[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$12:
	lea	ecx, DWORD PTR $T256635[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$13:
	lea	ecx, DWORD PTR $T256636[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z$14:
	mov	ecx, DWORD PTR $T256637[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z ENDP ; CvMinorCivAI::DoSetBonus
PUBLIC	?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z	; CvMinorCivAI::DoBuyout
EXTRN	?BoughtCityState@CvPlayerAchievements@@QAEXH@Z:PROC ; CvPlayerAchievements::BoughtCityState
EXTRN	?LogMinorCivBuyout@CvDiplomacyAI@@QAEXW4PlayerTypes@@H_N@Z:PROC ; CvDiplomacyAI::LogMinorCivBuyout
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
xdata$x	SEGMENT
__ehfuncinfo$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_bUsingXP2Scenario2$ = -273				; size = 1
_iNumUnits$ = -272					; size = 4
$T256968 = -272						; size = 4
_eSokoto$ = -272					; size = 4
_iCapitalX$ = -268					; size = 4
$T256969 = -268						; size = 4
_iCapitalY$ = -264					; size = 4
$T256975 = -260						; size = 4
$T256976 = -256						; size = 4
_strMessage$ = -252					; size = 80
_strSummary$ = -172					; size = 80
$T256970 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_eMajor$ = 8						; size = 4
?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC	; CvMinorCivAI::DoBuyout, COMDAT
; _this$ = ecx

; 7905 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 264				; 00000108H
	push	ebx

; 7906 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 7907 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 7908 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	ebx, DWORD PTR _eMajor$[esp+276]
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	cmp	ebx, 21					; 00000015H
	ja	$LN9@DoBuyout

; 7909 : 
; 7910 : 	if(!CanMajorBuyout(eMajor))

	push	ebx
	call	?CanMajorBuyout@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorBuyout
	test	al, al
	je	$LN9@DoBuyout

; 7911 : 		return;
; 7912 : 	
; 7913 : 
; 7914 : 	//Nigerian Prince Achievement
; 7915 : 	MinorCivTypes eBornu =(MinorCivTypes) GC.getInfoTypeForString("MINOR_CIV_BORNU", true /*bHideAssert*/);

	push	1
	push	OFFSET $SG227191
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7916 : 	MinorCivTypes  eSokoto =(MinorCivTypes) GC.getInfoTypeForString("MINOR_CIV_SOKOTO", true /*bHideAssert*/);

	push	1
	push	OFFSET $SG227194
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7917 : 	bool bUsingXP2Scenario2 = gDLL->IsModActivated(CIV5_XP2_SCENARIO2_MODID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR _eSokoto$[esp+292], eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+44]
	push	OFFSET $SG92498
	call	edx

; 7918 : 
; 7919 : 	if (GET_PLAYER(eMajor).isHuman() && bUsingXP2Scenario2 && (GetPlayer()->GetMinorCivAI()->GetMinorCivType() == eBornu || GetPlayer()->GetMinorCivAI()->GetMinorCivType() == eSokoto ))

	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	mov	BYTE PTR _bUsingXP2Scenario2$[esp+292], al
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN7@DoBuyout
	cmp	BYTE PTR _bUsingXP2Scenario2$[esp+292], 0
	je	SHORT $LN7@DoBuyout
	mov	ecx, DWORD PTR [esi]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN6@DoBuyout
	mov	ecx, DWORD PTR [esi]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	cmp	eax, DWORD PTR _eSokoto$[esp+292]
	jne	SHORT $LN7@DoBuyout
$LN6@DoBuyout:

; 7920 : 		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_54);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	296					; 00000128H
	call	edx
$LN7@DoBuyout:

; 7921 : 
; 7922 : 
; 7923 : 	// Pay the cost
; 7924 : 	const int iBuyoutCost = GetBuyoutCost(eMajor);

	push	ebx
	mov	ecx, esi
	call	?GetBuyoutCost@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBuyoutCost

; 7925 : 	GET_PLAYER(eMajor).GetTreasury()->LogExpenditure(GetPlayer()->GetMinorCivAI()->GetNamesListAsString(0), iBuyoutCost,6);

	push	6
	mov	ebp, eax
	push	ebp
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T256968[esp+328], esp
	sub	esp, 272				; 00000110H
	mov	eax, esp
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR $T256969[esp+600], esp
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+612], 0
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+612], -1
	call	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR __$EHRec$[esp+336], 1
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+336], -1
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 7926 : 	GET_PLAYER(eMajor).GetTreasury()->ChangeGold(-iBuyoutCost);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, ebp
	neg	edx
	add	ecx, edi
	push	edx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 7927 : 
; 7928 : 	int iNumUnits = 0;

	xor	eax, eax
	mov	DWORD PTR _iNumUnits$[esp+292], eax

; 7929 : 	int iCapitalX = 0;

	mov	DWORD PTR _iCapitalX$[esp+292], eax

; 7930 : 	int iCapitalY = 0;

	mov	DWORD PTR _iCapitalY$[esp+292], eax

; 7931 : 	DoAcquire(eMajor, iNumUnits, iCapitalX, iCapitalY);

	lea	eax, DWORD PTR _iCapitalY$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _iCapitalX$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _iNumUnits$[esp+300]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?DoAcquire@CvMinorCivAI@@QAEXW4PlayerTypes@@AAH11@Z ; CvMinorCivAI::DoAcquire

; 7932 : 
; 7933 : 	GET_PLAYER(eMajor).GetDiplomacyAI()->LogMinorCivBuyout(GetPlayer()->GetID(), iBuyoutCost, /*bSaving*/ false);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	ebp
	add	ecx, edi
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivBuyout@CvDiplomacyAI@@QAEXW4PlayerTypes@@H_N@Z ; CvDiplomacyAI::LogMinorCivBuyout

; 7934 : 
; 7935 : 	// Show special notifications
; 7936 : 	int iCoinToss = GC.getGame().getJonRandNum(2, "Coin toss roll to determine flavor message for minor civ buyout notification.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG227206
	push	2
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 7937 : 	Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BUYOUT_TT_1");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR _strMessage$[esp+292]
	push	OFFSET $SG227209
	push	edx
	mov	ebp, eax
	call	ebx
	add	esp, 8
	mov	DWORD PTR __$EHRec$[esp+300], 2

; 7938 : 	if (iCoinToss == 0) // Is it a boy or a girl?

	test	ebp, ebp
	jne	SHORT $LN5@DoBuyout

; 7939 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BUYOUT_TT_2");

	lea	eax, DWORD PTR $T256970[esp+292]
	push	OFFSET $SG227212
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T256970[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN5@DoBuyout:

; 7940 : 	strMessage << GET_PLAYER(eMajor).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+296]
	call	ebp

; 7941 : 	strMessage << GetPlayer()->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [esi]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+296]
	call	ebp

; 7942 : 
; 7943 : 	Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BUYOUT");

	lea	edx, DWORD PTR _strSummary$[esp+292]
	push	OFFSET $SG227217
	push	edx
	call	ebx
	add	esp, 8

; 7944 : 	strSummary << GET_PLAYER(eMajor).getCivilizationShortDescriptionKey();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	mov	BYTE PTR __$EHRec$[esp+300], 4
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+296]
	call	ebp

; 7945 : 	strSummary << GetPlayer()->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [esi]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+296]
	call	ebp

; 7946 : 
; 7947 : 	for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	ebx, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	xor	ebp, ebp
	npad	7
$LL4@DoBuyout:

; 7948 : 	{
; 7949 : 		PlayerTypes eMajorLoop = (PlayerTypes) iMajorLoop;
; 7950 : 		if (IsHasMetPlayer(eMajorLoop))

	push	ebp
	mov	ecx, esi
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	je	SHORT $LN3@DoBuyout

; 7951 : 		{
; 7952 : 			AddBuyoutNotification(strMessage.toUTF8(), strSummary.toUTF8(), eMajorLoop, iCapitalX, iCapitalY);

	mov	ecx, DWORD PTR _iCapitalY$[esp+292]
	mov	edx, DWORD PTR _iCapitalX$[esp+292]
	push	ecx
	push	edx
	push	ebp
	lea	ecx, DWORD PTR _strSummary$[esp+304]
	call	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T256975[esp+332], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN85@DoBuyout
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN85@DoBuyout:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$[esp+332]
	mov	BYTE PTR __$EHRec$[esp+340], 5
	call	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T256976[esp+360], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN90@DoBuyout
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN90@DoBuyout:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+368], 4
	call	?AddBuyoutNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddBuyoutNotification
$LN3@DoBuyout:
	inc	ebp
	cmp	ebp, 22					; 00000016H
	jl	SHORT $LL4@DoBuyout

; 7953 : 		}
; 7954 : 	}
; 7955 : 
; 7956 : 	
; 7957 : 
; 7958 : 	CvPlayerAI& kMajorPlayer = GET_PLAYER(eMajor);
; 7959 : 	kMajorPlayer.GetPlayerAchievements().BoughtCityState(iNumUnits);

	mov	eax, DWORD PTR _iNumUnits$[esp+292]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	lea	ecx, DWORD PTR [edi+ecx+63156]
	call	?BoughtCityState@CvPlayerAchievements@@QAEXH@Z ; CvPlayerAchievements::BoughtCityState

; 7960 : }

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 2
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], -1
	call	esi
$LN9@DoBuyout:
	mov	ecx, DWORD PTR __$EHRec$[esp+292]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 276				; 00000114H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	mov	ecx, DWORD PTR $T256969[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$1:
	mov	ecx, DWORD PTR $T256968[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T256970[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$5:
	mov	ecx, DWORD PTR $T256975[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoBuyout@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP	; CvMinorCivAI::DoBuyout
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ PROC ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	esi
	mov	esi, ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy

; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 123  : 	};

	ret	0
?clear@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ ENDP ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::clear
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T257171 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$257175 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$257175[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T257171[esp+12], 0
	mov	eax, DWORD PTR $T257171[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z PROC ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, DWORD PTR _uiNumElements$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pVal$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy

; 811  : 		if( pVal != (T*)m_aData )

	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN1@Free@13

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free@13:
	pop	edi
	pop	esi

; 813  : 	};

	ret	8
?Free@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ENDP ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@ABU?$less@W4MinorCivQuestTypes@@@1@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@ABU?$less@W4MinorCivQuestTypes@@@1@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@ABU?$less@W4MinorCivQuestTypes@@@1@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+17], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@ABU?$less@W4MinorCivQuestTypes@@@1@ABV?$allocator@W4MinorCivQuestTypes@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T257360 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T257360[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy@2
	npad	2
$LL9@Destroy@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@2
$LN7@Destroy@2:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T257526 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$257530 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$257530[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T257526[esp+4], 0
	mov	eax, DWORD PTR $T257526[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214892 = 16					; size = 4
__Tmp$214882 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214882[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214882[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214882[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214892[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__ehfuncinfo$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z
_TEXT	SEGMENT
$T257856 = -200						; size = 4
_args$226300 = -200					; size = 4
_args$226293 = -200					; size = 4
_args$226286 = -200					; size = 4
_eOldAlly$ = -200					; size = 4
_args$226272 = -200					; size = 4
_args$226260 = -200					; size = 4
_bResult$226301 = -194					; size = 1
_bResult$226294 = -194					; size = 1
_bResult$226287 = -194					; size = 1
_bWasAboveAlliesThreshold$ = -194			; size = 1
_bResult$226273 = -194					; size = 1
_bResult$226261 = -194					; size = 1
_bNowAboveAlliesThreshold$ = -193			; size = 1
$T257915 = -192						; size = 4
_pkScriptSystem$226298 = -192				; size = 4
_pkScriptSystem$226291 = -192				; size = 4
_pkScriptSystem$226284 = -192				; size = 4
_pkScriptSystem$226270 = -192				; size = 4
_pkScriptSystem$226258 = -192				; size = 4
_bAdd$ = -188						; size = 1
_bAllies$ = -184					; size = 1
_bFriends$ = -180					; size = 1
$T257887 = -176						; size = 4
_strSummary$ = -172					; size = 80
_strMessage$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_iOldFriendship$ = 12					; size = 4
_iNewFriendship$ = 16					; size = 4
_bFromQuest$ = 20					; size = 1
_bIgnoreMinorDeath$ = 24				; size = 1
?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z PROC ; CvMinorCivAI::DoFriendshipChangeEffects, COMDAT
; _this$ = ecx

; 5909 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 188				; 000000bcH

; 5910 : 	// Can't give out bonuses if we're dead!
; 5911 : 	if(!bIgnoreMinorDeath && !GetPlayer()->isAlive())

	cmp	BYTE PTR _bIgnoreMinorDeath$[esp+196], 0
	push	esi
	mov	esi, ecx
	jne	SHORT $LN26@DoFriendsh
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+2256], 0
	je	$LN27@DoFriendsh
$LN26@DoFriendsh:
	push	ebx
	push	ebp
	push	edi

; 5912 : 		return;
; 5913 : 
; 5914 : 	Localization::String strMessage;

	mov	edi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$[esp+216]
	call	edi

; 5915 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], 0
	call	edi

; 5916 : 
; 5917 : 	bool bAdd = false;
; 5918 : 	bool bFriends = false;
; 5919 : 	bool bAllies = false;
; 5920 : 
; 5921 : 	bool bWasAboveFriendsThreshold = IsFriendshipAboveFriendsThreshold(iOldFriendship);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	mov	ebp, DWORD PTR _iOldFriendship$[esp+212]

; 5922 : 	bool bNowAboveFriendsThreshold = IsFriendshipAboveFriendsThreshold(iNewFriendship);

	mov	ebx, DWORD PTR _iNewFriendship$[esp+212]
	mov	edi, DWORD PTR _ePlayer$[esp+212]
	cmp	ebp, eax
	setge	cl
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+224], 1
	mov	BYTE PTR _bAdd$[esp+216], 0
	mov	BYTE PTR _bFriends$[esp+216], 0
	mov	BYTE PTR _bAllies$[esp+216], 0
	jl	$LN49@DoFriendsh
	mov	al, 1

; 5926 : 		SetEverFriends(ePlayer, true);

	cmp	edi, 21					; 00000015H
	ja	SHORT $LN56@DoFriendsh
	mov	BYTE PTR [edi+esi+3124], al
$LN56@DoFriendsh:

; 5927 : 
; 5928 : 	// Add Friends Bonus
; 5929 : 	if(!bWasAboveFriendsThreshold && bNowAboveFriendsThreshold)

	test	cl, cl
	jne	$LN212@DoFriendsh
	test	al, al
	je	$LN18@DoFriendsh

; 5930 : 	{
; 5931 : 		bAdd = true;
; 5932 : 		bFriends = true;
; 5933 : 
; 5934 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	mov	BYTE PTR _bAdd$[esp+216], 1
	mov	BYTE PTR _bFriends$[esp+216], 1
	call	edx
	mov	DWORD PTR _pkScriptSystem$226258[esp+216], eax

; 5935 : 		if (pkScriptSystem) 

	test	eax, eax
	je	$LN18@DoFriendsh

; 5936 : 		{
; 5937 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226260[esp+216]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 5938 : 			args->Push(m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _args$226260[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	eax

; 5939 : 			args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226260[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 5940 : 			args->Push(true);

	mov	ecx, DWORD PTR _args$226260[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	1
	call	eax

; 5941 : 			args->Push(iOldFriendship);

	mov	ecx, DWORD PTR _args$226260[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 5942 : 			args->Push(iNewFriendship);

	mov	ecx, DWORD PTR _args$226260[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 5943 : 
; 5944 : 			bool bResult;
; 5945 : 			LuaSupport::CallHook(pkScriptSystem, "MinorFriendsChanged", args.get(), bResult);

	mov	edx, DWORD PTR _args$226260[esp+216]
	lea	ecx, DWORD PTR _bResult$226261[esp+216]
	push	ecx
	push	edx
	push	OFFSET $SG226262

; 5946 : 		}
; 5947 : 	}

	jmp	$LN221@DoFriendsh

; 5922 : 	bool bNowAboveFriendsThreshold = IsFriendshipAboveFriendsThreshold(iNewFriendship);

$LN49@DoFriendsh:
	xor	al, al

; 5923 : 
; 5924 : 	// If we are Friends now, mark that we've been Friends at least once this game
; 5925 : 	if(bNowAboveFriendsThreshold)

	jmp	$LN56@DoFriendsh
$LN212@DoFriendsh:

; 5948 : 	// Remove Friends bonus
; 5949 : 	else if(bWasAboveFriendsThreshold && !bNowAboveFriendsThreshold)

	test	al, al
	jne	$LN18@DoFriendsh

; 5950 : 	{
; 5951 : 		bAdd = false;

	mov	BYTE PTR _bAdd$[esp+216], al

; 5952 : 		bFriends = true;
; 5953 : 
; 5954 : #ifdef NQ_POLICY_TOGGLE_NO_MINOR_DOW_IF_FRIENDS
; 5955 : 		// if we are at war with a city state's ally but it didn't declare on us because we were friends and had a special policy 
; 5956 : 		// preventing that declaration, declare war here
; 5957 : 
; 5958 : 		if (GetAlly() != NO_PLAYER)

	mov	eax, DWORD PTR [esi+2012]
	mov	BYTE PTR _bFriends$[esp+216], 1
	cmp	eax, -1
	je	$LN19@DoFriendsh

; 5959 : 		{
; 5960 : 			TeamTypes ePlayerTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	mov	ecx, DWORD PTR [ecx+edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN86@DoFriendsh
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	DWORD PTR $T257856[esp+216], ecx
	jmp	SHORT $LN87@DoFriendsh
$LN86@DoFriendsh:
	mov	DWORD PTR $T257856[esp+216], -1
$LN87@DoFriendsh:

; 5961 : 			TeamTypes eAllyTeam = GET_PLAYER(GetAlly()).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN99@DoFriendsh
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T257887[esp+216], eax
	jmp	SHORT $LN100@DoFriendsh
$LN99@DoFriendsh:
	mov	DWORD PTR $T257887[esp+216], -1
$LN100@DoFriendsh:

; 5962 : 			TeamTypes eOurTeam = GetPlayer()->getTeam();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN110@DoFriendsh
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T257915[esp+216], edx
	jmp	SHORT $LN111@DoFriendsh
$LN110@DoFriendsh:
	mov	DWORD PTR $T257915[esp+216], -1
$LN111@DoFriendsh:

; 5963 : 			if (GET_TEAM(ePlayerTeam).isAtWar(eAllyTeam))

	mov	ecx, DWORD PTR $T257856[esp+216]
	mov	eax, DWORD PTR $T257887[esp+216]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN19@DoFriendsh

; 5964 : 			{
; 5965 : 				GET_TEAM(eOurTeam).declareWar(ePlayerTeam);

	mov	ecx, DWORD PTR $T257856[esp+216]
	push	0
	push	ecx
	mov	ecx, DWORD PTR $T257915[esp+224]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar
$LN19@DoFriendsh:

; 5966 : 			}
; 5967 : 		}
; 5968 : #endif
; 5969 : 
; 5970 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226270[esp+216], eax

; 5971 : 		if (pkScriptSystem) 

	test	eax, eax
	je	$LN18@DoFriendsh

; 5972 : 		{
; 5973 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226272[esp+216]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 5974 : 			args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$226272[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	eax

; 5975 : 			args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226272[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 5976 : 			args->Push(false);

	mov	ecx, DWORD PTR _args$226272[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	0
	call	eax

; 5977 : 			args->Push(iOldFriendship);

	mov	ecx, DWORD PTR _args$226272[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 5978 : 			args->Push(iNewFriendship);

	mov	ecx, DWORD PTR _args$226272[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 5979 : 
; 5980 : 			bool bResult;
; 5981 : 			LuaSupport::CallHook(pkScriptSystem, "MinorFriendsChanged", args.get(), bResult);

	mov	edx, DWORD PTR _args$226272[esp+216]
	lea	ecx, DWORD PTR _bResult$226273[esp+216]
	push	ecx
	push	edx
	push	OFFSET $SG226274
$LN221@DoFriendsh:
	mov	eax, DWORD PTR _pkScriptSystem$226270[esp+228]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 5982 : 		}

	lea	ecx, DWORD PTR _args$226272[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN18@DoFriendsh:

; 5983 : 	}
; 5984 : 
; 5985 : 	// Resolve Allies status
; 5986 : 	bool bWasAboveAlliesThreshold = IsFriendshipAboveAlliesThreshold(iOldFriendship);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840

; 5987 : 	bool bNowAboveAlliesThreshold = IsFriendshipAboveAlliesThreshold(iNewFriendship);
; 5988 : 
; 5989 : 	PlayerTypes eOldAlly = GetAlly();

	mov	ecx, DWORD PTR [esi+2012]
	cmp	ebp, eax
	setge	BYTE PTR _bWasAboveAlliesThreshold$[esp+216]
	mov	DWORD PTR _eOldAlly$[esp+216], ecx
	cmp	ebx, eax
	setge	BYTE PTR _bNowAboveAlliesThreshold$[esp+216]

; 5990 : #ifdef NO_AI_ALLYING_CS
; 5991 : 	if (GET_PLAYER(ePlayer).isHuman() || !GC.getGame().isOption("GAMEOPTION_AI_TWEAKS"))

	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN16@DoFriendsh
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG226280
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	$LN16@DoFriendsh

; 6035 : 
; 6036 : 	}
; 6037 : #ifdef NO_AI_ALLYING_CS
; 6038 : 	}
; 6039 : 	else
; 6040 : 	{
; 6041 : 	if(eOldAlly == ePlayer && bWasAboveAlliesThreshold && !bNowAboveAlliesThreshold)

	cmp	DWORD PTR _eOldAlly$[esp+216], edi
	jne	$LN215@DoFriendsh
	cmp	BYTE PTR _bWasAboveAlliesThreshold$[esp+216], 0
	je	$LN215@DoFriendsh
	cmp	BYTE PTR _bNowAboveAlliesThreshold$[esp+216], 0
	jne	$LN215@DoFriendsh

; 6042 : 	{
; 6043 : 		bAdd = false;
; 6044 : 		bAllies = true;
; 6045 : 
; 6046 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR _bAdd$[esp+216], 0
	mov	BYTE PTR _bAllies$[esp+216], 1
	call	eax
	mov	DWORD PTR _pkScriptSystem$226298[esp+216], eax

; 6047 : 		if (pkScriptSystem)

	test	eax, eax
	je	$LN215@DoFriendsh

; 6048 : 		{
; 6049 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226300[esp+216]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 6050 : 			args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$226300[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+228], 6
	call	eax

; 6051 : 			args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226300[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 6052 : 			args->Push(false);

	mov	ecx, DWORD PTR _args$226300[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	0
	call	eax

; 6053 : 			args->Push(iOldFriendship);

	mov	ecx, DWORD PTR _args$226300[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 6054 : 			args->Push(iNewFriendship);

	mov	ecx, DWORD PTR _args$226300[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 6055 : 
; 6056 : 			bool bResult;
; 6057 : 			LuaSupport::CallHook(pkScriptSystem, "MinorAlliesChanged", args.get(), bResult);

	mov	edx, DWORD PTR _args$226300[esp+216]
	lea	ecx, DWORD PTR _bResult$226301[esp+216]
	push	ecx
	push	edx
	push	OFFSET $SG226302

; 6058 : 		}

	jmp	$LN222@DoFriendsh
$LN16@DoFriendsh:

; 5992 : 	{
; 5993 : #endif
; 5994 : 
; 5995 : 	// No old ally and our friendship is now above the threshold, OR our friendship is now higher than a previous ally
; 5996 : 	if((eOldAlly == NO_PLAYER && bNowAboveAlliesThreshold)
; 5997 : 	        || (eOldAlly != NO_PLAYER && GetEffectiveFriendshipWithMajor(ePlayer) > GetEffectiveFriendshipWithMajor(eOldAlly)))

	mov	eax, DWORD PTR _eOldAlly$[esp+216]
	cmp	eax, -1
	jne	SHORT $LN211@DoFriendsh
	cmp	BYTE PTR _bNowAboveAlliesThreshold$[esp+216], 0
	jne	SHORT $LN14@DoFriendsh
	jmp	$LN15@DoFriendsh
$LN211@DoFriendsh:
	push	eax
	mov	ecx, esi
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
	push	edi
	mov	ecx, esi
	mov	ebx, eax
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
	cmp	eax, ebx
	mov	ebx, DWORD PTR _iNewFriendship$[esp+212]
	jle	$LN214@DoFriendsh
$LN14@DoFriendsh:

; 5998 : 	{
; 5999 : 		bAdd = true;
; 6000 : 		bAllies = true;
; 6001 : 
; 6002 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR _bAdd$[esp+216], 1
	mov	BYTE PTR _bAllies$[esp+216], 1
	call	eax
	mov	DWORD PTR _pkScriptSystem$226284[esp+216], eax

; 6003 : 		if (pkScriptSystem) 

	test	eax, eax
	je	$LN215@DoFriendsh

; 6004 : 		{
; 6005 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226286[esp+216]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 6006 : 			args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$226286[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+228], 4
	call	eax

; 6007 : 			args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226286[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 6008 : 			args->Push(true);

	mov	ecx, DWORD PTR _args$226286[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	1
	call	eax

; 6009 : 			args->Push(iOldFriendship);

	mov	ecx, DWORD PTR _args$226286[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 6010 : 			args->Push(iNewFriendship);

	mov	ecx, DWORD PTR _args$226286[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 6011 : 
; 6012 : 			bool bResult;
; 6013 : 			LuaSupport::CallHook(pkScriptSystem, "MinorAlliesChanged", args.get(), bResult);

	mov	edx, DWORD PTR _args$226286[esp+216]
	lea	ecx, DWORD PTR _bResult$226287[esp+216]
	push	ecx
	push	edx
	push	OFFSET $SG226288

; 6014 : 		}
; 6015 : 	}

	jmp	$LN222@DoFriendsh
$LN214@DoFriendsh:
	mov	eax, DWORD PTR _eOldAlly$[esp+216]
$LN15@DoFriendsh:

; 6016 : 	// Remove Allies bonus
; 6017 : 	else if(eOldAlly == ePlayer && bWasAboveAlliesThreshold && !bNowAboveAlliesThreshold)

	cmp	eax, edi
	jne	$LN215@DoFriendsh
	cmp	BYTE PTR _bWasAboveAlliesThreshold$[esp+216], 0
	je	$LN215@DoFriendsh
	cmp	BYTE PTR _bNowAboveAlliesThreshold$[esp+216], 0
	jne	$LN215@DoFriendsh

; 6018 : 	{
; 6019 : 		bAdd = false;
; 6020 : 		bAllies = true;
; 6021 : 
; 6022 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR _bAdd$[esp+216], 0
	mov	BYTE PTR _bAllies$[esp+216], 1
	call	eax
	mov	DWORD PTR _pkScriptSystem$226291[esp+216], eax

; 6023 : 		if (pkScriptSystem)

	test	eax, eax
	je	$LN215@DoFriendsh

; 6024 : 		{
; 6025 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226293[esp+216]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 6026 : 			args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$226293[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	eax

; 6027 : 			args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226293[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 6028 : 			args->Push(false);

	mov	ecx, DWORD PTR _args$226293[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	0
	call	eax

; 6029 : 			args->Push(iOldFriendship);

	mov	ecx, DWORD PTR _args$226293[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 6030 : 			args->Push(iNewFriendship);

	mov	ecx, DWORD PTR _args$226293[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 6031 : 
; 6032 : 			bool bResult;
; 6033 : 			LuaSupport::CallHook(pkScriptSystem, "MinorAlliesChanged", args.get(), bResult);

	mov	edx, DWORD PTR _args$226293[esp+216]
	lea	ecx, DWORD PTR _bResult$226294[esp+216]
	push	ecx
	push	edx
	push	OFFSET $SG226295
$LN222@DoFriendsh:
	mov	eax, DWORD PTR _pkScriptSystem$226291[esp+228]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 6034 : 		}

	lea	ecx, DWORD PTR _args$226293[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN215@DoFriendsh:

; 6059 : 	}
; 6060 : 	}
; 6061 : #endif
; 6062 : 
; 6063 : 	// Make changes to bonuses here. Only send notifications if this change is not related to quests (otherwise it is rolled into quest notification)
; 6064 : 	if(bFriends || bAllies)

	cmp	BYTE PTR _bFriends$[esp+216], 0
	jne	SHORT $LN219@DoFriendsh
	cmp	BYTE PTR _bAllies$[esp+216], 0
	je	SHORT $LN1@DoFriendsh
$LN219@DoFriendsh:

; 6065 : 		DoSetBonus(ePlayer, bAdd, bFriends, bAllies, /*bSuppressNotifications*/ bFromQuest);

	mov	ecx, DWORD PTR _bFromQuest$[esp+212]
	mov	edx, DWORD PTR _bAllies$[esp+216]
	mov	eax, DWORD PTR _bFriends$[esp+216]
	push	-1
	push	0
	push	ecx
	mov	ecx, DWORD PTR _bAdd$[esp+228]
	push	edx
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z ; CvMinorCivAI::DoSetBonus

; 6066 : 
; 6067 : 	// Now actually changed Allied status, since we needed the old player in effect to create the notifications in the function above us
; 6068 : 	if(bAllies)

	cmp	BYTE PTR _bAllies$[esp+216], 0
	je	SHORT $LN1@DoFriendsh

; 6069 : 	{
; 6070 : 		if(bAdd)

	cmp	BYTE PTR _bAdd$[esp+216], 0

; 6071 : 			SetAlly(ePlayer);

	mov	ecx, esi
	je	SHORT $LN2@DoFriendsh
	push	edi

; 6072 : 		else

	jmp	SHORT $LN223@DoFriendsh
$LN2@DoFriendsh:

; 6073 : 			SetAlly(NO_PLAYER);	// We KNOW no one else can be higher, so set the Ally to NO_PLAYER

	push	-1
$LN223@DoFriendsh:
	call	?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::SetAlly
$LN1@DoFriendsh:

; 6074 : 	}
; 6075 : }

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	esi
	pop	edi
	pop	ebp
	pop	ebx
$LN27@DoFriendsh:
	mov	ecx, DWORD PTR __$EHRec$[esp+204]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 200				; 000000c8H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$2:
	lea	ecx, DWORD PTR _args$226260[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$3:
	lea	ecx, DWORD PTR _args$226272[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$6:
	lea	ecx, DWORD PTR _args$226300[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$4:
	lea	ecx, DWORD PTR _args$226286[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z$5:
	lea	ecx, DWORD PTR _args$226293[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ENDP ; CvMinorCivAI::DoFriendshipChangeEffects
PUBLIC	?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoNowPeaceWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_iWarFriendship$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z PROC ; CvMinorCivAI::DoNowPeaceWithTeam, COMDAT
; _this$ = ecx

; 9383 : {

	push	ecx

; 9384 : 	int iWarFriendship = /*-60*/ GC.getMINOR_FRIENDSHIP_AT_WAR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 9385 : 	int iNewFriendship;
; 9386 : 
; 9387 : 	PlayerTypes ePlayer;
; 9388 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	mov	DWORD PTR _iWarFriendship$[esp+20], eax
	xor	edi, edi
	lea	ebp, DWORD PTR [ebx+2024]
	npad	6
$LL30@DoNowPeace:

; 9389 : 	{
; 9390 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 9391 : 
; 9392 : 		if(GET_PLAYER(ePlayer).getTeam() == eTeam)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN15@DoNowPeace
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN16@DoNowPeace
$LN15@DoNowPeace:
	or	eax, -1
$LN16@DoNowPeace:
	cmp	eax, DWORD PTR _eTeam$[esp+16]
	jne	SHORT $LN3@DoNowPeace

; 9393 : 		{
; 9394 : 			// Friendship change
; 9395 : 			iNewFriendship = GetBaseFriendshipWithMajor(ePlayer);

	test	esi, esi
	jl	SHORT $LN22@DoNowPeace
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN22@DoNowPeace
	mov	ecx, DWORD PTR [ebp]
	jmp	SHORT $LN24@DoNowPeace
$LN22@DoNowPeace:
	xor	ecx, ecx
$LN24@DoNowPeace:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 9396 : 			DoFriendshipChangeEffects(ePlayer, iWarFriendship, iNewFriendship);

	mov	ecx, DWORD PTR _iWarFriendship$[esp+20]
	sar	edx, 5
	push	0
	mov	eax, edx
	push	0
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects
$LN3@DoNowPeace:
	add	edi, 63236				; 0000f704H
	inc	esi
	add	ebp, 4
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL30@DoNowPeace

; 9397 : 		}
; 9398 : 	}
; 9399 : 
; 9400 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9401 : }

	pop	ecx
	ret	4
?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ENDP ; CvMinorCivAI::DoNowPeaceWithTeam
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >
_TEXT	ENDS
PUBLIC	??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T258292 = 8						; size = 1
__Cat$258295 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@2
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@2
	call	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
$LN54@vector@2:
$LN22@vector@2:
	push	eax
	push	edi
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T258292[ebp], 0
	mov	edx, DWORD PTR $T258292[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$258295[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@PAW4ResourceTypes@@V?$allocator@W4ResourceTypes@@@2@@std@@YAPAW4ResourceTypes@@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@0@0PAW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@2:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@2:
$LN53@vector@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
PUBLIC	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	esi
	mov	esi, ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	push	eax
	push	edi
	call	?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN3@FStaticVec@17
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@FStaticVec@17:
	pop	edi
	pop	esi

; 619  : 	};

	ret	0
??1?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T258415 = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T258415[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::~_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp+4]
	push	edi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ebp, ecx
	mov	DWORD PTR [eax], esi
	cmp	esi, edi
	je	SHORT $LN1@erase@4
	push	ebx

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebx, DWORD PTR [ebp+8]
	cmp	edi, ebx
	je	SHORT $LN26@erase@4
	npad	1
$LL28@erase@4:
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	edi, 28					; 0000001cH
	add	esi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL28@erase@4
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebx, DWORD PTR [ebp+8]
	mov	edi, esi
	cmp	esi, ebx
	je	SHORT $LN39@erase@4
	npad	4
$LL41@erase@4:
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	edi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL41@erase@4
$LN39@erase@4:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [ebp+8], esi
	pop	ebx
$LN1@erase@4:
	pop	edi
	pop	esi
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN25@Tidy@3
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@3
$LL12@Tidy@3:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@3
$LN10@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN25@Tidy@3:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Tidy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::GrowSize
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pTemp$ = -20						; size = 4
$T258743 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T258914 = 8						; size = 4
_i$230359 = 8						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN63@GrowSize@13
	mov	DWORD PTR [esi+8], 1
$LN63@GrowSize@13:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+28]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@13
$LL8@GrowSize@13:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN57@GrowSize@13

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@13

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@13
$LN57@GrowSize@13:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@13:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN16@GrowSize@13
	mov	eax, edi
	imul	eax, 156				; 0000009cH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@GrowSize@13
$LN16@GrowSize@13:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 22			; 00000016H
$LN15@GrowSize@13:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	edi, edi
	push	ebp
	mov	DWORD PTR _pTemp$[esp+36], ebx
	mov	DWORD PTR _i$230359[esp+32], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN1@GrowSize@13
	or	ebp, -1
$LL3@GrowSize@13:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, edi
	imul	eax, 156				; 0000009cH
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR $T258743[esp+36], ecx
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN12@GrowSize@13
	mov	edx, DWORD PTR [esi]
	add	edx, eax
	push	edx
	call	??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
$LN12@GrowSize@13:
	inc	edi
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR _i$230359[esp+32], edi
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@13
$LN1@GrowSize@13:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T258914[esp+32], ecx
	test	eax, eax
	jbe	SHORT $LN25@GrowSize@13
	mov	edi, ecx
	mov	ebp, eax
$LL27@GrowSize@13:
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [edi+12]
	cmp	eax, edx
	je	SHORT $LN36@GrowSize@13
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR $T258914[esp+36]
	add	esp, 4
$LN36@GrowSize@13:
	add	edi, 156				; 0000009cH
	sub	ebp, 1
	jne	SHORT $LL27@GrowSize@13
$LN25@GrowSize@13:
	lea	eax, DWORD PTR [esi+12]
	pop	ebp
	cmp	ecx, eax
	je	SHORT $LN62@GrowSize@13
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN62@GrowSize@13:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;
; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [esi], ebx
	pop	edi
	mov	BYTE PTR [esi+3444], 1
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$230359[ebp-4]
	imul	eax, 156				; 0000009cH
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258743[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::GrowSize
PUBLIC	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z
_TEXT	SEGMENT
$T258982 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$258986 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$258986[esp]
	mov	BYTE PTR $T258982[esp+4], 0
	mov	eax, DWORD PTR $T258982[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z
_TEXT	SEGMENT
__Mid$232184 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$232184[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$232184[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$232184[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$232184[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z
_TEXT	SEGMENT
__Mid$232255 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@2
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort@2:
	test	esi, esi
	jle	SHORT $LN6@Sort@2

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$232255[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$232255[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$232255[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort@2
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort@2
$LN5@Sort@2:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$232255[esp+36]
$LN26@Sort@2:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@2
$LN25@Sort@2:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort@2

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@2:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@2

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort@2
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort@2:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z
_TEXT	SEGMENT
__Mid$232326 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@3
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort@3:
	test	esi, esi
	jle	SHORT $LN6@Sort@3

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$232326[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$232326[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$232326[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort@3
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort@3
$LN5@Sort@3:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$232326[esp+36]
$LN26@Sort@3:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@3
$LN25@Sort@3:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort@3

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@3:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@3

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort@3
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int,CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort@3:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z
_TEXT	SEGMENT
__Mid$232397 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@4
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort@4:
	test	esi, esi
	jle	SHORT $LN6@Sort@4

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$232397[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,100,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$232397[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$232397[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort@4
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort@4
$LN5@Sort@4:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$232397[esp+36]
$LN26@Sort@4:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@4
$LN25@Sort@4:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort@4

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,100,1>::WeightedElement *,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort@4:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@4:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@4

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort@4
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,100,1>::WeightedElement *,int,CvWeightedVector<int,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort@4:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,100,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??0CvMinorCivAI@@QAE@XZ				; CvMinorCivAI::CvMinorCivAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ??0CvMinorCivAI@@QAE@XZ
_TEXT	SEGMENT
??0CvMinorCivAI@@QAE@XZ PROC				; CvMinorCivAI::CvMinorCivAI, COMDAT
; _this$ = ecx

; 1615 : {

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+3340]
	mov	DWORD PTR [eax+3332], 0
	mov	DWORD PTR [eax+3336], 22		; 00000016H
	mov	DWORD PTR [eax+3328], ecx

; 1616 : }

	ret	0
??0CvMinorCivAI@@QAE@XZ ENDP				; CvMinorCivAI::CvMinorCivAI
_TEXT	ENDS
PUBLIC	??1CvMinorCivAI@@QAE@XZ				; CvMinorCivAI::~CvMinorCivAI
; Function compile flags: /Ogtpy
;	COMDAT ??1CvMinorCivAI@@QAE@XZ
_TEXT	SEGMENT
??1CvMinorCivAI@@QAE@XZ PROC				; CvMinorCivAI::~CvMinorCivAI, COMDAT
; _this$ = ecx

; 1620 : 	Uninit();
; 1621 : }

	mov	eax, DWORD PTR [ecx+3332]
	push	esi
	lea	esi, DWORD PTR [ecx+3328]
	push	edi
	mov	edi, DWORD PTR [esi]
	push	eax
	push	edi
	mov	ecx, esi
	call	?Destroy@?$BaseVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN8@CvMinorCiv
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN8@CvMinorCiv:
	pop	edi
	pop	esi
	ret	0
??1CvMinorCivAI@@QAE@XZ ENDP				; CvMinorCivAI::~CvMinorCivAI
_TEXT	ENDS
PUBLIC	??1?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::~set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T259336 = -4						; size = 4
??1?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ PROC ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::~set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T259336[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ ENDP ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::~set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >
_TEXT	ENDS
PUBLIC	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iNum$ = 12						; size = 4
_bFromQuest$ = 16					; size = 1
?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z PROC ; CvMinorCivAI::SetFriendshipWithMajorTimes100, COMDAT
; _this$ = ecx

; 5429 : {

	push	esi

; 5430 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5431 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5432 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	esi, DWORD PTR _ePlayer$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, 21					; 00000015H
	ja	$LN4@SetFriends
	push	ebp

; 5433 : 
; 5434 : 	int iOldEffectiveFriendship = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	push	esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN8@SetFriends
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ebp, 100				; 00000064H
	jmp	SHORT $LN11@SetFriends
$LN8@SetFriends:
	mov	ebp, DWORD PTR [edi+esi*4+2024]
$LN11@SetFriends:

; 5435 : 
; 5436 : 	m_aiFriendshipWithMajorTimes100[ePlayer] = iNum;

	mov	eax, DWORD PTR _iNum$[esp+8]
	push	ebx
	mov	DWORD PTR [edi+esi*4+2024], eax

; 5437 : 
; 5438 : 	int iMinimumFriendship = GC.getMINOR_FRIENDSHIP_AT_WAR();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768

; 5439 : 	if(GetBaseFriendshipWithMajor(ePlayer) < iMinimumFriendship)

	push	esi
	mov	ecx, edi
	call	?GetBaseFriendshipWithMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetBaseFriendshipWithMajor
	cmp	eax, ebx
	jge	SHORT $LN3@SetFriends

; 5440 : 		m_aiFriendshipWithMajorTimes100[ePlayer] = iMinimumFriendship * 100;

	imul	ebx, 100				; 00000064H
	mov	DWORD PTR [edi+esi*4+2024], ebx
$LN3@SetFriends:

; 5441 : 
; 5442 : 	int iNewEffectiveFriendship = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	push	esi
	mov	ecx, edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	pop	ebx
	test	al, al
	je	SHORT $LN21@SetFriends
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN24@SetFriends
$LN21@SetFriends:
	mov	ecx, DWORD PTR [edi+esi*4+2024]
$LN24@SetFriends:

; 5443 : 
; 5444 : 	// Has the friendship in effect changed?
; 5445 : 	if(iOldEffectiveFriendship != iNewEffectiveFriendship)

	cmp	ebp, ecx
	je	SHORT $LN2@SetFriends

; 5446 : 	{
; 5447 : 		DoFriendshipChangeEffects(ePlayer, iOldEffectiveFriendship/100, iNewEffectiveFriendship/100, bFromQuest);

	mov	edx, DWORD PTR _bFromQuest$[esp+8]
	push	0
	push	edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ebp
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	esi
	mov	ecx, edi
	call	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects
$LN2@SetFriends:

; 5448 : 	}
; 5449 : 
; 5450 : 	// Update City banners and game info if this is the active player
; 5451 : 	if(ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	pop	ebp
	cmp	esi, eax
	jne	SHORT $LN4@SetFriends

; 5452 : 	{
; 5453 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax

; 5454 : 		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
$LN4@SetFriends:
	pop	edi
	pop	esi

; 5455 : 	}
; 5456 : }

	ret	12					; 0000000cH
?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ENDP ; CvMinorCivAI::SetFriendshipWithMajorTimes100
_TEXT	ENDS
PUBLIC	?ChangeFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::ChangeFriendshipWithMajorTimes100
EXTRN	?getMinorQuestFriendshipMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getMinorQuestFriendshipMod
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
_bFromQuest$ = 16					; size = 1
?ChangeFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z PROC ; CvMinorCivAI::ChangeFriendshipWithMajorTimes100, COMDAT
; _this$ = ecx

; 5460 : {

	push	ebx
	push	edi

; 5461 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 5462 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5463 : 
; 5464 : 	if(iChange != 0)

	mov	edi, DWORD PTR _iChange$[esp+4]
	mov	ebx, ecx
	test	edi, edi
	je	SHORT $LN3@ChangeFrie@3

; 5465 : 	{
; 5466 : 		// If this friendship was earned from a Quest, then we might apply a modifier to it
; 5467 : 		if(bFromQuest && iChange > 0)

	cmp	BYTE PTR _bFromQuest$[esp+4], 0
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp+8]
	je	SHORT $LN14@ChangeFrie@3
	test	edi, edi
	jle	SHORT $LN14@ChangeFrie@3

; 5468 : 		{
; 5469 : 			if(GET_PLAYER(ePlayer).getMinorQuestFriendshipMod() != 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, ebp
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?getMinorQuestFriendshipMod@CvPlayer@@QBEHXZ ; CvPlayer::getMinorQuestFriendshipMod
	test	eax, eax
	je	SHORT $LN15@ChangeFrie@3

; 5470 : 			{
; 5471 : 				iChange *= (100 + GET_PLAYER(ePlayer).getMinorQuestFriendshipMod());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?getMinorQuestFriendshipMod@CvPlayer@@QBEHXZ ; CvPlayer::getMinorQuestFriendshipMod
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, edi

; 5472 : 				iChange /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
$LN15@ChangeFrie@3:
	pop	esi
$LN14@ChangeFrie@3:

; 5473 : 			}
; 5474 : 		}
; 5475 : 
; 5476 : 		SetFriendshipWithMajorTimes100(ePlayer, GetBaseFriendshipWithMajorTimes100(ePlayer) + iChange, bFromQuest);

	cmp	ebp, 21					; 00000015H
	ja	SHORT $LN10@ChangeFrie@3
	mov	eax, DWORD PTR [ebx+ebp*4+2024]
	jmp	SHORT $LN12@ChangeFrie@3
$LN10@ChangeFrie@3:
	xor	eax, eax
$LN12@ChangeFrie@3:
	mov	ecx, DWORD PTR _bFromQuest$[esp+8]
	push	ecx
	add	eax, edi
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
	pop	ebp
$LN3@ChangeFrie@3:
	pop	edi
	pop	ebx

; 5477 : 	}
; 5478 : }

	ret	12					; 0000000cH
?ChangeFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ENDP ; CvMinorCivAI::ChangeFriendshipWithMajorTimes100
_TEXT	ENDS
PUBLIC	?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajor
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iNum$ = 12						; size = 4
_bFromQuest$ = 16					; size = 1
?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z PROC ; CvMinorCivAI::SetFriendshipWithMajor, COMDAT
; _this$ = ecx

; 5497 : 	SetFriendshipWithMajorTimes100(ePlayer, iNum * 100, bFromQuest);

	mov	edx, DWORD PTR _iNum$[esp-4]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iNum$[esp-4], edx
	jmp	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ENDP ; CvMinorCivAI::SetFriendshipWithMajor
_TEXT	ENDS
PUBLIC	?ChangeFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::ChangeFriendshipWithMajor
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iChange$ = 12						; size = 4
_bFromQuest$ = 16					; size = 1
?ChangeFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z PROC ; CvMinorCivAI::ChangeFriendshipWithMajor, COMDAT
; _this$ = ecx

; 5503 : 	ChangeFriendshipWithMajorTimes100(ePlayer, iChange * 100, bFromQuest);

	mov	edx, DWORD PTR _iChange$[esp-4]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iChange$[esp-4], edx
	jmp	?ChangeFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::ChangeFriendshipWithMajorTimes100
?ChangeFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ENDP ; CvMinorCivAI::ChangeFriendshipWithMajor
_TEXT	ENDS
PUBLIC	?ResetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::ResetFriendshipWithMajor
; Function compile flags: /Ogtpy
;	COMDAT ?ResetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?ResetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::ResetFriendshipWithMajor, COMDAT
; _this$ = ecx

; 5550 : {

	push	esi
	push	edi

; 5551 : 	// If ePlayer isn't a major civ then there is no influence value to reset, so just return
; 5552 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return; // as defined during Reset()

	mov	edi, DWORD PTR _ePlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN3@ResetFrien

; 5553 : 
; 5554 : 	int iOldFriendship = GetEffectiveFriendshipWithMajor(ePlayer);

	push	edi
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor

; 5555 : 	const int iResetFriendship = 0;
; 5556 : 	if(GetPlayer()->isAlive())

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+2256], 0

; 5557 : 	{
; 5558 : 		SetFriendshipWithMajor(ePlayer, iResetFriendship);

	mov	ecx, esi

; 5559 : 	}
; 5560 : 	else

	jne	SHORT $LN17@ResetFrien

; 5561 : 	{
; 5562 : 		// special workaround to allow status changes despite minor already being dead
; 5563 : 		DoFriendshipChangeEffects(ePlayer, iOldFriendship, iResetFriendship, /*bFromQuest*/false, /*bIgnoreMinorDeath*/true);

	push	1
	push	0
	push	0
	push	eax
	push	edi
	call	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects

; 5564 : 		SetFriendshipWithMajor(ePlayer, iResetFriendship);

	mov	ecx, esi
$LN17@ResetFrien:
	push	0
	push	0
	push	edi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN3@ResetFrien:
	pop	edi
	pop	esi

; 5565 : 	}
; 5566 : 
; 5567 : }

	ret	4
?ResetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::ResetFriendshipWithMajor
_TEXT	ENDS
PUBLIC	?DoIntrusion@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoIntrusion
EXTRN	?GetLengthMissionQueue@CvUnit@@QBEHXZ:PROC	; CvUnit::GetLengthMissionQueue
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
EXTRN	?IsAngerFreeUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAngerFreeUnit
EXTRN	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoIntrusion@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?DoIntrusion@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoIntrusion@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoIntrusion@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
tv1019 = -276						; size = 4
_iMajorLoop$ = -276					; size = 4
tv1051 = -272						; size = 4
_pUnitNode$ = -272					; size = 4
_this$ = -268						; size = 4
$T259483 = -264						; size = 4
_pLoopPlot$ = -264					; size = 4
_iPlotLoop$226441 = -260				; size = 4
tv1015 = -256						; size = 4
$T259482 = -256						; size = 4
_strSummary$ = -252					; size = 80
_strMessage$ = -172					; size = 80
$T259480 = -92						; size = 80
$T259478 = -92						; size = 80
__$EHRec$ = -12						; size = 12
?DoIntrusion@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::DoIntrusion, COMDAT
; _this$ = ecx

; 6324 : {

	push	-1
	push	__ehhandler$?DoIntrusion@CvMinorCivAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 6325 : 	PlayerTypes eMajor;
; 6326 : 	int iMajorLoop;
; 6327 : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+292], ebp
	xor	eax, eax
	lea	ecx, DWORD PTR [ebp+2112]
	npad	1
$LL24@DoIntrusio:

; 6328 : 	{
; 6329 : 		eMajor = (PlayerTypes) iMajorLoop;
; 6330 : 
; 6331 : 		if(GetAngerFreeIntrusionCounter(eMajor) > 0)

	cmp	eax, esi
	jl	SHORT $LN23@DoIntrusio
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN23@DoIntrusio
	mov	edx, DWORD PTR [ecx]
	cmp	edx, esi
	jle	SHORT $LN23@DoIntrusio

; 6332 : 		{
; 6333 : 			ChangeAngerFreeIntrusionCounter(eMajor, -1);

	dec	edx
	mov	DWORD PTR [ecx], edx
$LN23@DoIntrusio:
	inc	eax
	add	ecx, 4
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL24@DoIntrusio

; 6334 : 		}
; 6335 : 	}
; 6336 : 
; 6337 : 	// If there are barbs nearby then don't worry about other players
; 6338 : 	if(GetNumThreateningBarbarians() > 0)

	mov	ecx, ebp
	call	?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetNumThreateningBarbarians
	test	eax, eax
	jg	$LN25@DoIntrusio

; 6339 : 		return;
; 6340 : 
; 6341 : 	CvPlot* pLoopPlot;
; 6342 : 	const IDInfo* pUnitNode;
; 6343 : 	const CvUnit* pLoopUnit;
; 6344 : 
; 6345 : 	// Set up scratch pad so that we can use it to send out Notifications
; 6346 : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	lea	edi, DWORD PTR [ebp+6776]
	xor	eax, eax
	mov	DWORD PTR tv1015[esp+292], edi
	mov	ecx, edi
$LL19@DoIntrusio:

; 6347 : 	{
; 6348 : 		eMajor = (PlayerTypes) iMajorLoop;
; 6349 : 		SetMajorScratchPad(eMajor, 0);

	cmp	eax, esi
	jl	SHORT $LN18@DoIntrusio
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN18@DoIntrusio
	mov	DWORD PTR [ecx], esi
$LN18@DoIntrusio:

; 6339 : 		return;
; 6340 : 
; 6341 : 	CvPlot* pLoopPlot;
; 6342 : 	const IDInfo* pUnitNode;
; 6343 : 	const CvUnit* pLoopUnit;
; 6344 : 
; 6345 : 	// Set up scratch pad so that we can use it to send out Notifications
; 6346 : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	inc	eax
	add	ecx, 4
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL19@DoIntrusio

; 6350 : 	}
; 6351 : 
; 6352 : 	// Look at how many Units each Major Civ has in the Minor's Territory
; 6353 : #ifdef AUI_WARNING_FIXES
; 6354 : 	for (uint iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
; 6355 : #else
; 6356 : 	for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [ecx+4028]
	cmp	eax, esi
	mov	DWORD PTR _iPlotLoop$226441[esp+292], esi
	jle	$LN14@DoIntrusio
	mov	DWORD PTR tv1019[esp+292], esi
$LN16@DoIntrusio:

; 6357 : #endif
; 6358 : 	{
; 6359 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	edi, DWORD PTR [ecx+4068]
	add	edi, DWORD PTR tv1019[esp+292]

; 6360 : 
; 6361 : 		// Plot owned by this Minor?
; 6362 : 		if(pLoopPlot->getOwner() == GetPlayer()->GetID())

	mov	eax, DWORD PTR [ebp]
	movsx	ecx, BYTE PTR [edi+4]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR _pLoopPlot$[esp+292], edi
	cmp	ecx, eax
	jne	$LN15@DoIntrusio

; 6363 : 		{
; 6364 : 			pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, edi
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	esi, eax

; 6365 : 
; 6366 : 			while(pUnitNode != NULL)

	test	esi, esi
	je	$LN15@DoIntrusio
	jmp	SHORT $LN12@DoIntrusio
	npad	5
$LL247@DoIntrusio:
	mov	esi, DWORD PTR _pUnitNode$[esp+292]
	mov	edi, DWORD PTR _pLoopPlot$[esp+292]
$LN12@DoIntrusio:

; 6367 : 			{
; 6368 : 				pLoopUnit = ::getUnit(*pUnitNode);

	push	esi
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4

; 6369 : 				pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	push	esi
	mov	ecx, edi
	mov	ebx, eax
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[esp+292], eax

; 6370 : 
; 6371 : 				// Does this unit not cause anger?
; 6372 : 				if(pLoopUnit && pLoopUnit->IsAngerFreeUnit())

	test	ebx, ebx
	je	$LN204@DoIntrusio
	mov	ecx, ebx
	call	?IsAngerFreeUnit@CvUnit@@QBE_NXZ	; CvUnit::IsAngerFreeUnit
	test	al, al
	jne	$LN204@DoIntrusio

; 6373 : 					continue;
; 6374 : 
; 6375 : 				//// Don't look at Unit's this Minor wants for a Quest!
; 6376 : 				//if (!IsPeaceQuestCompletedByMajor((PlayerTypes) pLoopUnit->getOwner()))
; 6377 : 				//{
; 6378 : 				//	if (GetPeaceQuestWidget() == MINORCIVQUESTWIDGET_UNITCLASS || GetWarQuestWidget() == MINORCIVQUESTWIDGET_UNITCLASS)
; 6379 : 				//	{
; 6380 : 				//		if (GetPeaceQuestWidgetID() == pLoopUnit->getUnitClassType() || GetWarQuestWidgetID() == pLoopUnit->getUnitClassType())
; 6381 : 				//		{
; 6382 : 				//			continue;
; 6383 : 				//		}
; 6384 : 				//	}
; 6385 : 				//}
; 6386 : 
; 6387 : 				// Does this Unit belong to a Major?
; 6388 : 				if(pLoopUnit && pLoopUnit->getOwner() < MAX_MAJOR_CIVS)

	mov	edi, DWORD PTR [ebx+40]
	cmp	edi, 22					; 00000016H
	jge	$LN204@DoIntrusio

; 6389 : 				{
; 6390 : 					// If player has been granted Open Borders or has a friendship with minors bonus, then the Minor doesn't care about intrusion
; 6391 : 					if(!IsPlayerHasOpenBorders(pLoopUnit->getOwner()) && GetAngerFreeIntrusionCounter(pLoopUnit->getOwner()) == 0)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	DWORD PTR [eax+92], 0
	jg	$LN204@DoIntrusio
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN90@DoIntrusio
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN102@DoIntrusio
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN103@DoIntrusio
$LN102@DoIntrusio:
	or	ecx, -1
$LN103@DoIntrusio:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, DWORD PTR [esi+eax+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN113@DoIntrusio
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN114@DoIntrusio
$LN113@DoIntrusio:
	or	eax, -1
$LN114@DoIntrusio:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN89@DoIntrusio
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN92@DoIntrusio
$LN89@DoIntrusio:
	mov	ecx, DWORD PTR [ebp+edi*4+2024]
	jmp	SHORT $LN92@DoIntrusio
$LN90@DoIntrusio:
	xor	ecx, ecx
$LN92@DoIntrusio:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	jge	$LN204@DoIntrusio
	mov	eax, DWORD PTR [ebx+40]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN241@DoIntrusio
	cmp	DWORD PTR [ebp+eax*4+2112], 0
	jne	$LN204@DoIntrusio
$LN241@DoIntrusio:

; 6392 : 					{
; 6393 : 						// If the player is at war with the Minor then don't bother
; 6394 : 						if(!IsAtWarWithPlayersTeam(pLoopUnit->getOwner()))

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN153@DoIntrusio
	mov	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+ecx*4]
	jmp	SHORT $LN154@DoIntrusio
$LN153@DoIntrusio:
	or	ecx, -1
$LN154@DoIntrusio:
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN164@DoIntrusio
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN165@DoIntrusio
$LN164@DoIntrusio:
	or	eax, -1
$LN165@DoIntrusio:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN204@DoIntrusio

; 6395 : 						{
; 6396 : 							// Ignore if the player trait allows us to intrude without angering
; 6397 : 							if(!GET_PLAYER(pLoopUnit->getOwner()).GetPlayerTraits()->IsAngerFreeIntrusionOfCityStates())

	mov	eax, DWORD PTR [ebx+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+355], 0
	jne	SHORT $LN204@DoIntrusio

; 6398 : 							{
; 6399 : 								ChangeFriendshipWithMajor(pLoopUnit->getOwner(), /*-6*/ GC.getFRIENDSHIP_PER_UNIT_INTRUDING());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3160
	mov	ecx, DWORD PTR [ebx+40]
	imul	eax, 100				; 00000064H
	test	eax, eax
	je	SHORT $LN189@DoIntrusio
	cmp	ecx, 21					; 00000015H
	ja	SHORT $LN196@DoIntrusio
	mov	edx, DWORD PTR [ebp+ecx*4+2024]
	jmp	SHORT $LN198@DoIntrusio
$LN196@DoIntrusio:
	xor	edx, edx
$LN198@DoIntrusio:
	push	0
	add	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN189@DoIntrusio:

; 6400 : 
; 6401 : 								// only modify if the unit isn't automated nor having a pending order
; 6402 : 								if(!pLoopUnit->IsAutomated() && pLoopUnit->GetLengthMissionQueue() == 0)

	mov	ecx, ebx
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	jne	SHORT $LN204@DoIntrusio
	mov	ecx, ebx
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	jne	SHORT $LN204@DoIntrusio

; 6403 : 								{
; 6404 : 									SetMajorScratchPad(pLoopUnit->getOwner(), 1);

	mov	eax, DWORD PTR [ebx+40]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN204@DoIntrusio
	mov	DWORD PTR [ebp+eax*4+6776], 1
$LN204@DoIntrusio:

; 6365 : 
; 6366 : 			while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[esp+292], 0
	jne	$LL247@DoIntrusio
$LN15@DoIntrusio:

; 6350 : 	}
; 6351 : 
; 6352 : 	// Look at how many Units each Major Civ has in the Minor's Territory
; 6353 : #ifdef AUI_WARNING_FIXES
; 6354 : 	for (uint iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
; 6355 : #else
; 6356 : 	for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR _iPlotLoop$226441[esp+292]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv1019[esp+292], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iPlotLoop$226441[esp+292], eax
	jl	$LN16@DoIntrusio
	mov	edi, DWORD PTR tv1015[esp+292]
$LN14@DoIntrusio:

; 6405 : 								}
; 6406 : 
; 6407 : 								//if (!IsMajorIntruding((PlayerTypes) pLoopUnit->getOwner()))
; 6408 : 								//{
; 6409 : 								//	SetMajorIntruding((PlayerTypes) pLoopUnit->getOwner(), true);
; 6410 : 								//	ChangeNumTurnsMajorHasIntruded((PlayerTypes) pLoopUnit->getOwner(), 1);
; 6411 : 								//}
; 6412 : 							}
; 6413 : 						}
; 6414 : 					}
; 6415 : 				}
; 6416 : 			}
; 6417 : 		}
; 6418 : 	}
; 6419 : 
; 6420 : 	// Now send out Notifications (if necessary)
; 6421 : 	Localization::String strMessage;

	mov	esi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$[esp+292]
	call	esi

; 6422 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], 0
	call	esi
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	ebx, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 6423 : 
; 6424 : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	eax, eax
	mov	DWORD PTR tv1051[esp+292], edi
	mov	edi, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[esp+300], 1
	mov	DWORD PTR _iMajorLoop$[esp+292], eax
	npad	3
$LL4@DoIntrusio:

; 6425 : 	{
; 6426 : 		eMajor = (PlayerTypes) iMajorLoop;
; 6427 : 
; 6428 : 		if(GetMajorScratchPad(eMajor) > 0)

	test	eax, eax
	jl	$LN3@DoIntrusio
	cmp	eax, 22					; 00000016H
	jge	$LN3@DoIntrusio
	mov	ecx, DWORD PTR tv1051[esp+292]
	cmp	DWORD PTR [ecx], 0
	jle	$LN3@DoIntrusio

; 6429 : 		{
; 6430 : 			strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_INTRUSION");

	lea	edx, DWORD PTR $T259478[esp+292]
	push	OFFSET $SG226463
	push	edx
	call	ebp
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 2
	call	edi
	lea	ecx, DWORD PTR $T259478[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 1
	call	esi

; 6431 : 			strMessage << GetPlayer()->getNameKey();

	mov	eax, DWORD PTR _this$[esp+292]
	mov	ecx, DWORD PTR [eax]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+296]
	call	ebx

; 6432 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_INTRUSION");

	lea	ecx, DWORD PTR $T259480[esp+292]
	push	OFFSET $SG226466
	push	ecx
	call	ebp
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	edi
	lea	ecx, DWORD PTR $T259480[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 1
	call	esi

; 6433 : 			strSummary << GetPlayer()->getNameKey();

	mov	edx, DWORD PTR _this$[esp+292]
	mov	ecx, DWORD PTR [edx]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+296]
	call	ebx

; 6434 : 
; 6435 : 			AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), eMajor);

	mov	eax, DWORD PTR _iMajorLoop$[esp+292]
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+304]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T259482[esp+332], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN223@DoIntrusio
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN223@DoIntrusio:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$[esp+332]
	mov	BYTE PTR __$EHRec$[esp+340], 4
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T259483[esp+360], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN228@DoIntrusio
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN228@DoIntrusio:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR _this$[esp+360]
	mov	BYTE PTR __$EHRec$[esp+368], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification
	mov	eax, DWORD PTR _iMajorLoop$[esp+292]
$LN3@DoIntrusio:
	add	DWORD PTR tv1051[esp+292], 4
	inc	eax
	cmp	eax, 22					; 00000016H
	mov	DWORD PTR _iMajorLoop$[esp+292], eax
	jl	$LL4@DoIntrusio

; 6436 : 		}
; 6437 : 	}
; 6438 : }

	lea	ecx, DWORD PTR _strSummary$[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], -1
	call	esi
$LN25@DoIntrusio:
	mov	ecx, DWORD PTR __$EHRec$[esp+292]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 276				; 00000114H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T259478[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T259480[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoIntrusion@CvMinorCivAI@@QAEXXZ$4:
	mov	ecx, DWORD PTR $T259482[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoIntrusion@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoIntrusion@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoIntrusion@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::DoIntrusion
PUBLIC	?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvMinorCivAI::DoLiberationByMajor
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
$T260178 = -264						; size = 4
$T260172 = -264						; size = 4
_iNewInfluence$ = -264					; size = 4
_iHighestOtherMajorInfluence$ = -264			; size = 4
tv673 = -260						; size = 4
$T260179 = -260						; size = 4
$T260173 = -260						; size = 4
$T260171 = -260						; size = 4
_iI$226510 = -256					; size = 4
_strMessage$ = -252					; size = 80
_strSummary$ = -172					; size = 80
$T260176 = -92						; size = 80
$T260174 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_eLiberator$ = 8					; size = 4
_eConquerorTeam$ = 12					; size = 4
?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvMinorCivAI::DoLiberationByMajor, COMDAT
; _this$ = ecx

; 6487 : {

	push	-1
	push	__ehhandler$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	ebp

; 6488 : 	Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LIBERATION");

	mov	ebp, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	push	esi
	push	edi
	lea	eax, DWORD PTR _strMessage$[esp+280]
	push	OFFSET $SG226501
	push	eax
	mov	esi, ecx
	call	ebp
	add	esp, 8

; 6489 : 	strMessage << GetPlayer()->getNameKey() << GET_PLAYER(eLiberator).getNameKey();

	mov	ecx, DWORD PTR _eLiberator$[esp+276]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+288], 0
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ebx, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+284]
	call	ebx
	push	edi
	lea	ecx, DWORD PTR _strMessage$[esp+284]
	call	ebx

; 6490 : 	Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_LIBERATION");

	lea	ecx, DWORD PTR _strSummary$[esp+280]
	push	OFFSET $SG226506
	push	ecx
	call	ebp
	add	esp, 8

; 6491 : 	strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+284]
	call	ebx

; 6492 : 
; 6493 : 	int iHighestOtherMajorInfluence = GC.getMINOR_FRIENDSHIP_AT_WAR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768

; 6494 : 
; 6495 : 	PlayerTypes ePlayer;
; 6496 : 	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	xor	edi, edi
	lea	eax, DWORD PTR [esi+2024]
	mov	DWORD PTR _iHighestOtherMajorInfluence$[esp+280], edx
	mov	DWORD PTR _iI$226510[esp+280], edi
	xor	ebp, ebp
	mov	DWORD PTR tv673[esp+280], eax
	npad	9
$LL9@DoLiberati:

; 6497 : 	{
; 6498 : 		ePlayer = (PlayerTypes) iI;
; 6499 : 
; 6500 : 		if(ePlayer != eLiberator)

	cmp	edi, DWORD PTR _eLiberator$[esp+276]
	je	$LN8@DoLiberati

; 6501 : 		{
; 6502 : 			int iInfluence = GetBaseFriendshipWithMajor(ePlayer);

	test	edi, edi
	jl	SHORT $LN34@DoLiberati
	cmp	edi, 22					; 00000016H
	jge	SHORT $LN34@DoLiberati
	mov	ecx, DWORD PTR tv673[esp+280]
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN36@DoLiberati
$LN34@DoLiberati:
	xor	ecx, ecx
$LN36@DoLiberati:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 6503 : 			if(iInfluence > iHighestOtherMajorInfluence)

	cmp	eax, DWORD PTR _iHighestOtherMajorInfluence$[esp+280]
	jle	SHORT $LN5@DoLiberati

; 6504 : 				iHighestOtherMajorInfluence = iInfluence;

	mov	DWORD PTR _iHighestOtherMajorInfluence$[esp+280], eax
$LN5@DoLiberati:

; 6505 : 
; 6506 : 			if(GET_PLAYER(ePlayer).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edx+ebp+2256], 0
	je	$LN8@DoLiberati

; 6507 : 			{
; 6508 : 				if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GetPlayer()->getTeam()))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN50@DoLiberati
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN51@DoLiberati
$LN50@DoLiberati:
	or	ecx, -1
$LN51@DoLiberati:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN61@DoLiberati
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN62@DoLiberati
$LN61@DoLiberati:
	or	eax, -1
$LN62@DoLiberati:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN8@DoLiberati

; 6509 : 				{
; 6510 : 					// Influence for other players - Were you the one that conquered us before?
; 6511 : 					if(GET_PLAYER(ePlayer).getTeam() == eConquerorTeam)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@DoLiberati
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN75@DoLiberati
$LN74@DoLiberati:
	or	eax, -1
$LN75@DoLiberati:
	cmp	eax, DWORD PTR _eConquerorTeam$[esp+276]
	jne	SHORT $LN81@DoLiberati

; 6512 : 					{
; 6513 : 						SetFriendshipWithMajor(ePlayer, GC.getMINOR_FRIENDSHIP_AT_WAR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	push	0
	push	eax
	push	edi
	mov	ecx, esi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN81@DoLiberati:

; 6514 : 					}
; 6515 : 
; 6516 : 					// Notification for other players
; 6517 : 					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 6518 : 					if(pNotifications)

	test	edi, edi
	je	SHORT $LN130@DoLiberati

; 6519 : 					{
; 6520 : 						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$[esp+296]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+300]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	1319111517				; 4ea00b5dH
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN130@DoLiberati:
	mov	edi, DWORD PTR _iI$226510[esp+280]
$LN8@DoLiberati:

; 6494 : 
; 6495 : 	PlayerTypes ePlayer;
; 6496 : 	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	add	DWORD PTR tv673[esp+280], 4
	inc	edi
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	mov	DWORD PTR _iI$226510[esp+280], edi
	jl	$LL9@DoLiberati

; 6521 : 					}
; 6522 : 				}
; 6523 : 			}
; 6524 : 		}
; 6525 : 	}
; 6526 : 
; 6527 : 	// Influence for liberator - raise to ally status
; 6528 : 	int iNewInfluence = max(iHighestOtherMajorInfluence + GC.getMINOR_LIBERATION_FRIENDSHIP(), GetBaseFriendshipWithMajor(eLiberator) + GC.getMINOR_LIBERATION_FRIENDSHIP());

	mov	eax, DWORD PTR _eLiberator$[esp+276]
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN87@DoLiberati
	mov	ecx, DWORD PTR [esi+eax*4+2024]
	jmp	SHORT $LN89@DoLiberati
$LN87@DoLiberati:
	xor	ecx, ecx
$LN89@DoLiberati:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3176
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR _iHighestOtherMajorInfluence$[esp+280]
	add	eax, ecx
	add	ecx, edx
	mov	DWORD PTR $T260171[esp+280], eax
	cmp	ecx, eax
	mov	DWORD PTR $T260172[esp+280], ecx
	lea	eax, DWORD PTR $T260171[esp+280]
	jl	SHORT $LN98@DoLiberati
	lea	eax, DWORD PTR $T260172[esp+280]
$LN98@DoLiberati:
	mov	eax, DWORD PTR [eax]

; 6529 : 	iNewInfluence = max(GetAlliesThreshold(), iNewInfluence); // Must be at least enough to make us allies

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840
	mov	DWORD PTR _iNewInfluence$[esp+280], eax
	cmp	ecx, eax
	mov	DWORD PTR $T260173[esp+280], ecx
	lea	eax, DWORD PTR _iNewInfluence$[esp+280]
	jl	SHORT $LN106@DoLiberati
	lea	eax, DWORD PTR $T260173[esp+280]
$LN106@DoLiberati:

; 6530 : 	SetFriendshipWithMajor(eLiberator, iNewInfluence);

	mov	eax, DWORD PTR [eax]
	imul	eax, 100				; 00000064H
	push	0
	push	eax
	mov	eax, DWORD PTR _eLiberator$[esp+284]
	push	eax
	mov	ecx, esi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100

; 6531 : 
; 6532 : 	// Notification for liberator
; 6533 : 	strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_LIBERATION_YOU");

	lea	ecx, DWORD PTR $T260174[esp+280]
	push	OFFSET $SG226528
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 2
	call	ebp
	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T260174[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	edi

; 6534 : 	strMessage << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+284]
	call	ebx

; 6535 : 	strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_LIBERATION");

	lea	edx, DWORD PTR $T260176[esp+280]
	push	OFFSET $SG226531
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 3
	call	ebp
	lea	ecx, DWORD PTR $T260176[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	edi

; 6536 : 	strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+284]
	call	ebx

; 6537 : 	AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), eLiberator);

	mov	eax, DWORD PTR _eLiberator$[esp+276]
	mov	ebx, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+292]
	call	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T260178[esp+320], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN120@DoLiberati
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN120@DoLiberati:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 4
	call	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T260179[esp+348], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN125@DoLiberati
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN125@DoLiberati:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+356], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification

; 6538 : }

	lea	ecx, DWORD PTR _strSummary$[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 0
	call	edi
	lea	ecx, DWORD PTR _strMessage$[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], -1
	call	edi
	mov	ecx, DWORD PTR __$EHRec$[esp+280]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 264				; 00000108H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$2:
	lea	ecx, DWORD PTR $T260174[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$3:
	lea	ecx, DWORD PTR $T260176[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$4:
	mov	ecx, DWORD PTR $T260178[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoLiberationByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvMinorCivAI::DoLiberationByMajor
PUBLIC	?DoElection@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoElection
EXTRN	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z:PROC	; CvCivilizationInfo::getSpyNames
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z:PROC ; CvPlayerEspionage::GetSpyRankName
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?SetLastProgress@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z:PROC ; CvCityEspionage::SetLastProgress
EXTRN	?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z:PROC ; CvCityEspionage::SetActivity
EXTRN	?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z:PROC ; CvPlayerEspionage::CalcRequired
EXTRN	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z:PROC ; CvPlayerEspionage::CalcPerTurn
EXTRN	?ResetProgress@CvCityEspionage@@QAEXW4PlayerTypes@@@Z:PROC ; CvCityEspionage::ResetProgress
EXTRN	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ:PROC ; CvCity::GetCityEspionage
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
EXTRN	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ:PROC ; CvGame::GetTurnsUntilMinorCivElection
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?DoElection@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?DoElection@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoElection@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoElection@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
_ui$228378 = -508					; size = 4
_ui$228201 = -508					; size = 4
tv1838 = -504						; size = 4
_pCity$228211 = -504					; size = 4
_this$ = -500						; size = 4
$T260445 = -496						; size = 4
_pNotifications$228405 = -496				; size = 4
_iRelationshipAnchor$228401 = -496			; size = 4
_pNotifications$228385 = -496				; size = 4
_iLoop$228209 = -496					; size = 4
$T260988 = -489						; size = 1
tv1690 = -488						; size = 4
$T260446 = -488						; size = 4
_iFriendship$228400 = -488				; size = 4
_iVotes$228208 = -484					; size = 4
tv1649 = -480						; size = 4
tv1688 = -476						; size = 4
_elem$260779 = -476					; size = 8
tv1676 = -468						; size = 4
_iSpyID$228216 = -464					; size = 4
_iRate$228219 = -460					; size = 4
tv1687 = -456						; size = 4
_strSummary$228423 = -452				; size = 80
_strNotification$228411 = -452				; size = 80
_strNotification$228391 = -452				; size = 80
_strNotification$228427 = -372				; size = 80
_strSummary$228407 = -372				; size = 80
_strSummary$228387 = -372				; size = 80
_wvVotes$ = -292					; size = 192
_apSpy$ = -100						; size = 88
__$EHRec$ = -12						; size = 12
?DoElection@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::DoElection, COMDAT
; _this$ = ecx

; 8776 : {

	push	-1
	push	__ehhandler$?DoElection@CvMinorCivAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 496				; 000001f0H
	push	edi
	mov	edi, ecx

; 8777 : 	// if it is not an election turn, don't process!
; 8778 : 	if(GC.getGame().GetTurnsUntilMinorCivElection() != 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _this$[esp+512], edi
	call	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ ; CvGame::GetTurnsUntilMinorCivElection
	test	eax, eax
	jne	$LN363@DoElection
	push	ebp
	push	esi

; 8779 : 	{
; 8780 : 		return;
; 8781 : 	}
; 8782 : 
; 8783 : 	CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> wvVotes;

	xor	esi, esi
	lea	eax, DWORD PTR _wvVotes$[esp+532]
	mov	DWORD PTR _wvVotes$[esp+524], esi
	mov	DWORD PTR _wvVotes$[esp+528], 22	; 00000016H
	mov	DWORD PTR _wvVotes$[esp+520], eax

; 8784 : 	Firaxis::Array<CvEspionageSpy*, MAX_MAJOR_CIVS> apSpy;
; 8785 : 	CvCity* pCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+528], esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ebp, eax

; 8786 : 	if(!pCapital)

	cmp	ebp, esi

; 8787 : 	{
; 8788 : 		return;

	je	$LN396@DoElection

; 8789 : 	}
; 8790 : 
; 8791 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	lea	edi, DWORD PTR _apSpy$[esp+520]

; 8792 : 	{
; 8793 : 		PlayerTypes eEspionagePlayer = (PlayerTypes)ui;
; 8794 : 		CvPlayerEspionage* pPlayerEspionage = GET_PLAYER(eEspionagePlayer).GetEspionage();
; 8795 : 		int iVotes = 0;
; 8796 : 		int iLoop;
; 8797 : 		apSpy[ui] = NULL;

	mov	eax, 4
	mov	edx, edi
	sub	eax, edx
	mov	DWORD PTR tv1687[esp+520], eax
	mov	eax, 92					; 0000005cH
	mov	ecx, edi
	sub	eax, ecx
	push	ebx
	mov	DWORD PTR _ui$228201[esp+524], esi
	mov	DWORD PTR tv1649[esp+524], esi
	mov	DWORD PTR tv1676[esp+524], edi
	mov	DWORD PTR tv1690[esp+524], eax
	npad	1
$LL25@DoElection:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ebx, eax

; 8798 : 
; 8799 : 		if (!GET_PLAYER(eEspionagePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	mov	DWORD PTR _iVotes$228208[esp+524], 0
	mov	DWORD PTR [edi], 0
	je	$LN24@DoElection

; 8800 : 		{
; 8801 : 			continue;
; 8802 : 		}
; 8803 : 
; 8804 : 		for(CvCity* pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	edx, DWORD PTR _this$[esp+524]
	push	0
	lea	ecx, DWORD PTR _iLoop$228209[esp+528]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$228211[esp+524], eax
	test	eax, eax
	je	$LN24@DoElection

; 8824 : 
; 8825 : 			iVotes += (pCityEspionage->m_aiAmount[eEspionagePlayer] * (100 + m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_RIGGING_ELECTION_MODIFIER))) / 100;

	mov	ecx, DWORD PTR tv1687[esp+524]
	add	ecx, edi
	mov	DWORD PTR tv1688[esp+524], ecx
	jmp	SHORT $LN21@DoElection
	npad	5
$LL386@DoElection:
	mov	eax, DWORD PTR _pCity$228211[esp+524]
$LN21@DoElection:

; 8805 : 		{
; 8806 : 			CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 8807 : 			int iSpyID = pCityEspionage->m_aiSpyAssignment[eEspionagePlayer];

	mov	edx, DWORD PTR tv1688[esp+524]
	mov	esi, eax
	mov	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR _iSpyID$228216[esp+524], ecx

; 8808 : 			// if no spies are assigned here, continue
; 8809 : 			if(iSpyID == -1)

	cmp	ecx, -1
	je	$LN20@DoElection

; 8810 : 			{
; 8811 : 				continue;
; 8812 : 			}
; 8813 : 
; 8814 : 			// on election day, evaluate spy to be reassigned
; 8815 : 			pPlayerEspionage->m_aSpyList[iSpyID].m_bEvaluateReassignment = true;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR [ebx+4]
	add	eax, eax
	add	eax, eax
	mov	BYTE PTR [ecx+eax+25], 1

; 8816 : 
; 8817 : 			// if the spy assigned here is not rigging the election yet, continue
; 8818 : 			if(pPlayerEspionage->m_aSpyList[iSpyID].m_eSpyState != SPY_STATE_RIG_ELECTION)

	mov	edx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [edx+eax+16], 4
	jne	$LN20@DoElection

; 8819 : 			{
; 8820 : 				continue;
; 8821 : 			}
; 8822 : 
; 8823 : 			apSpy[ui] = &(pPlayerEspionage->m_aSpyList[iSpyID]);

	mov	ecx, edx

; 8824 : 
; 8825 : 			iVotes += (pCityEspionage->m_aiAmount[eEspionagePlayer] * (100 + m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_RIGGING_ELECTION_MODIFIER))) / 100;

	mov	edx, DWORD PTR tv1690[esp+524]
	add	ecx, eax
	mov	eax, DWORD PTR _this$[esp+524]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR [eax]
	add	edi, edx
	push	35					; 00000023H
	add	edi, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, DWORD PTR [edi]

; 8826 : 
; 8827 : 			// now that votes are counted, remove the progress from the spy
; 8828 : 			pCityEspionage->ResetProgress(eEspionagePlayer);

	mov	edi, DWORD PTR _ui$228201[esp+524]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR _iVotes$228208[esp+524], ecx
	push	edi
	mov	ecx, esi
	call	?ResetProgress@CvCityEspionage@@QAEXW4PlayerTypes@@@Z ; CvCityEspionage::ResetProgress

; 8829 : 
; 8830 : 			int iRate = pPlayerEspionage->CalcPerTurn(SPY_STATE_RIG_ELECTION, pCity, iSpyID);

	mov	edx, DWORD PTR _iSpyID$228216[esp+524]
	mov	eax, DWORD PTR _pCity$228211[esp+524]
	push	edx
	push	eax
	push	4
	mov	ecx, ebx
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn

; 8831 : 			int iGoal = pPlayerEspionage->CalcRequired(SPY_STATE_RIG_ELECTION, pCity, iSpyID);

	mov	ecx, DWORD PTR _iSpyID$228216[esp+524]
	mov	edx, DWORD PTR _pCity$228211[esp+524]
	push	ecx
	push	edx
	push	4
	mov	ecx, ebx
	mov	DWORD PTR _iRate$228219[esp+536], eax
	call	?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcRequired

; 8832 : 			pCityEspionage->SetActivity(eEspionagePlayer, 0, iRate, iGoal);

	push	eax
	mov	eax, DWORD PTR _iRate$228219[esp+528]
	push	eax
	push	0
	push	edi
	mov	ecx, esi
	call	?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z ; CvCityEspionage::SetActivity

; 8833 : 			pCityEspionage->SetLastProgress(eEspionagePlayer, iRate);

	mov	ecx, DWORD PTR _iRate$228219[esp+524]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?SetLastProgress@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ; CvCityEspionage::SetLastProgress
	mov	edi, DWORD PTR tv1676[esp+524]
$LN20@DoElection:
	mov	eax, DWORD PTR _this$[esp+524]
	mov	ecx, DWORD PTR [eax]
	push	0
	lea	edx, DWORD PTR _iLoop$228209[esp+528]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$228211[esp+524], eax
	test	eax, eax
	jne	$LL386@DoElection

; 8834 : 		}
; 8835 : 
; 8836 : 		if(iVotes > 0)

	mov	esi, DWORD PTR _iVotes$228208[esp+524]
	test	esi, esi
	jle	SHORT $LN387@DoElection

; 8837 : 		{
; 8838 : 			wvVotes.push_back(eEspionagePlayer, iVotes);

	mov	BYTE PTR _wvVotes$[esp+712], al
	mov	eax, DWORD PTR _wvVotes$[esp+532]
	cmp	DWORD PTR _wvVotes$[esp+528], eax
	jne	SHORT $LN95@DoElection
	push	eax
	lea	ecx, DWORD PTR _wvVotes$[esp+528]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@$0BG@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement,22,1,0,0>::GrowSize
$LN95@DoElection:
	mov	ecx, DWORD PTR _wvVotes$[esp+524]
	mov	edx, DWORD PTR _wvVotes$[esp+528]
	lea	eax, DWORD PTR [ecx+edx*8]
	test	eax, eax
	je	SHORT $LN98@DoElection
	mov	ecx, DWORD PTR _ui$228201[esp+524]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi
$LN98@DoElection:
	inc	DWORD PTR _wvVotes$[esp+528]
$LN387@DoElection:
	mov	esi, DWORD PTR tv1649[esp+524]
$LN24@DoElection:

; 8789 : 	}
; 8790 : 
; 8791 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	inc	DWORD PTR _ui$228201[esp+524]
	add	esi, 63236				; 0000f704H
	add	edi, 4
	mov	DWORD PTR tv1649[esp+524], esi
	mov	DWORD PTR tv1676[esp+524], edi
	cmp	esi, 1391192				; 00153a58H
	jb	$LL25@DoElection

; 8839 : 		}
; 8840 : 	}
; 8841 : 
; 8842 : 	if(wvVotes.size() > 0)

	xor	edi, edi
	cmp	DWORD PTR _wvVotes$[esp+528], edi
	jle	$LN12@DoElection

; 8843 : 	{
; 8844 : 		RandomNumberDelegate fcn;
; 8845 : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48

; 8846 : 		PlayerTypes eElectionWinner = wvVotes.ChooseByWeight(&fcn, "Choosing CS election winner by weight");

	lea	ecx, DWORD PTR _wvVotes$[esp+524]
	mov	DWORD PTR _elem$260779[esp+524], edi
	call	?GetTotalWeight@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEHXZ ; CvWeightedVector<enum PlayerTypes,22,1>::GetTotalWeight
	push	OFFSET $SG228377
	push	eax
	mov	ecx, esi
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	esi, DWORD PTR _wvVotes$[esp+528]
	xor	edx, edx
	cmp	esi, edi
	jbe	SHORT $LN389@DoElection

; 8843 : 	{
; 8844 : 		RandomNumberDelegate fcn;
; 8845 : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	ecx, DWORD PTR _wvVotes$[esp+524]

; 8846 : 		PlayerTypes eElectionWinner = wvVotes.ChooseByWeight(&fcn, "Choosing CS election winner by weight");

$LL144@DoElection:
	sub	eax, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _elem$260779[esp+524], ebx
	js	SHORT $LN389@DoElection
	inc	edx
	add	ecx, 8
	cmp	edx, esi
	jb	SHORT $LL144@DoElection
$LN389@DoElection:

; 8847 : 
; 8848 : 		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	edx, DWORD PTR _this$[esp+524]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	xor	ebx, ebx
	add	edx, 2024				; 000007e8H
	mov	DWORD PTR _ui$228378[esp+524], ebx
	mov	DWORD PTR tv1838[esp+524], edx
$LL14@DoElection:

; 8849 : 		{
; 8850 : 			PlayerTypes ePlayer = (PlayerTypes)ui;
; 8851 : 
; 8852 : 			if(ePlayer == eElectionWinner)

	cmp	ebx, DWORD PTR _elem$260779[esp+524]
	jne	$LN11@DoElection

; 8853 : 			{
; 8854 : 				CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$228385[esp+524], eax

; 8855 : 				if(pNotifications)

	test	eax, eax
	je	$LN10@DoElection

; 8856 : 				{
; 8857 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_SUCCESS_S");

	lea	ecx, DWORD PTR _strSummary$228387[esp+524]
	push	OFFSET $SG228389
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8858 : 					strSummary << pCapital->getNameKey();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+532], 1
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$228387[esp+528]
	call	esi

; 8859 : 					Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_SUCCESS");

	lea	edx, DWORD PTR _strNotification$228391[esp+524]
	push	OFFSET $SG228393
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8860 : 					strNotification << GET_PLAYER(ePlayer).GetEspionage()->GetSpyRankName(apSpy[ui]->m_eRank);

	mov	ebx, DWORD PTR _apSpy$[esp+ebx*4+524]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+536], 2
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$228391[esp+528]
	call	esi

; 8861 : 					strNotification << GET_PLAYER(ePlayer).getCivilizationInfo().getSpyNames(apSpy[ui]->m_iName);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$228391[esp+528]
	call	esi

; 8862 : 					strNotification << pCapital->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$228391[esp+528]
	call	esi

; 8863 : 					pNotifications->Add(NOTIFICATION_SPY_RIG_ELECTION_SUCCESS, strNotification.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), -1);

	mov	eax, DWORD PTR [ebp+108]
	mov	ecx, DWORD PTR [ebp+96]
	mov	ebx, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$228387[esp+540]
	call	ebx
	push	eax
	lea	ecx, DWORD PTR _strNotification$228391[esp+544]
	call	ebx
	mov	ecx, DWORD PTR _pNotifications$228385[esp+544]
	push	eax
	push	-1502528765				; a6713b03H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 8864 : 				}

	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$228391[esp+524]
	mov	BYTE PTR __$EHRec$[esp+532], 1
	call	ebx
	lea	ecx, DWORD PTR _strSummary$228387[esp+524]
	mov	BYTE PTR __$EHRec$[esp+532], 0
	call	ebx
	mov	ebx, DWORD PTR _ui$228378[esp+524]
$LN10@DoElection:

; 8865 : 
; 8866 : 				int iInfluenceModifier = GET_PLAYER(ePlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_RIGGING_ELECTION_MODIFIER); // NQMP GJS - new Covert Action

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	push	35					; 00000023H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 8867 : 				ChangeFriendshipWithMajor(ePlayer, GC.getESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION() * (100 + iInfluenceModifier) / 100, false); // NQMP GJS - new Covert Action

	lea	ecx, DWORD PTR [eax+100]
	imul	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7940
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, ecx
	imul	eax, 100				; 00000064H
	test	eax, eax
	je	SHORT $LN193@DoElection
	test	ebx, ebx
	jl	SHORT $LN200@DoElection
	cmp	ebx, 22					; 00000016H
	jge	SHORT $LN200@DoElection
	mov	edx, DWORD PTR tv1838[esp+524]
	mov	ecx, DWORD PTR [edx]
	jmp	SHORT $LN202@DoElection
$LN200@DoElection:
	xor	ecx, ecx
$LN202@DoElection:
	push	0
	add	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+532]
	push	ebx
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN193@DoElection:

; 8868 : 
; 8869 : 				//Achievements!
; 8870 : 				if(ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	$LN13@DoElection

; 8871 : 				{
; 8872 : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_14);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	204					; 000000ccH
	call	edx

; 8873 : 				}
; 8874 : 			}
; 8875 : 			else

	jmp	$LN13@DoElection
$LN11@DoElection:

; 8876 : 			{
; 8877 : 				int iFriendship = GetEffectiveFriendshipWithMajor(ePlayer);

	test	ebx, ebx
	jl	SHORT $LN388@DoElection
	cmp	ebx, 22					; 00000016H
	jge	SHORT $LN388@DoElection
	mov	ecx, DWORD PTR _this$[esp+524]
	push	ebx
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN210@DoElection
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN213@DoElection
$LN210@DoElection:
	mov	eax, DWORD PTR tv1838[esp+524]
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN213@DoElection
$LN388@DoElection:
	xor	ecx, ecx
$LN213@DoElection:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 8878 : 				int iRelationshipAnchor = GetFriendshipAnchorWithMajor(ePlayer);

	mov	ecx, DWORD PTR _this$[esp+524]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	ebx
	mov	DWORD PTR _iFriendship$228400[esp+528], eax
	call	?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipAnchorWithMajor
	mov	DWORD PTR _iRelationshipAnchor$228401[esp+524], eax

; 8879 : 				bool bFriends = IsFriends(ePlayer);

	test	ebx, ebx
	jl	SHORT $LN226@DoElection
	cmp	ebx, 22					; 00000016H
	jge	SHORT $LN226@DoElection
	mov	ecx, DWORD PTR _this$[esp+524]
	push	ebx
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN225@DoElection
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN228@DoElection
$LN225@DoElection:
	mov	ecx, DWORD PTR tv1838[esp+524]
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN228@DoElection
$LN226@DoElection:
	xor	ecx, ecx
$LN228@DoElection:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 8880 : 				bool bMet = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(m_pPlayer->getTeam());

	mov	ecx, DWORD PTR _this$[esp+524]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	setge	BYTE PTR $T260988[esp+524]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN247@DoElection
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN248@DoElection
$LN247@DoElection:
	or	ecx, -1
$LN248@DoElection:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN258@DoElection
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN259@DoElection
$LN258@DoElection:
	or	eax, -1
$LN259@DoElection:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet

; 8881 : 
; 8882 : 				// if they have a spy in the city
; 8883 : 				if(apSpy[ui] != NULL)

	mov	ebx, DWORD PTR _apSpy$[esp+ebx*4+524]
	test	ebx, ebx
	je	$LN7@DoElection

; 8884 : 				{
; 8885 : 					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$228405[esp+524], eax

; 8886 : 					if(pNotifications)

	test	eax, eax
	je	$LN390@DoElection

; 8887 : 					{
; 8888 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_FAILURE_S");

	lea	ecx, DWORD PTR _strSummary$228407[esp+524]
	push	OFFSET $SG228409
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8889 : 						strSummary << pCapital->getNameKey();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+532], 3
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$228407[esp+528]
	call	esi

; 8890 : 						Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_FAILURE");

	lea	edx, DWORD PTR _strNotification$228411[esp+524]
	push	OFFSET $SG228413
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8891 : 						strNotification << GET_PLAYER(ePlayer).GetEspionage()->GetSpyRankName(apSpy[ui]->m_eRank);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+536], 4
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$228411[esp+528]
	call	esi

; 8892 : 						strNotification << GET_PLAYER(ePlayer).getCivilizationInfo().getSpyNames(apSpy[ui]->m_iName);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$228411[esp+528]
	call	esi

; 8893 : 						strNotification << pCapital->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$228411[esp+528]
	call	esi

; 8894 : 						strNotification << GET_PLAYER(eElectionWinner).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR _elem$260779[esp+524]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$228411[esp+528]
	call	esi

; 8895 : 						pNotifications->Add(NOTIFICATION_SPY_RIG_ELECTION_FAILURE, strNotification.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), -1);

	mov	eax, DWORD PTR [ebp+108]
	mov	ecx, DWORD PTR [ebp+96]
	mov	ebx, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$228407[esp+540]
	call	ebx
	push	eax
	lea	ecx, DWORD PTR _strNotification$228411[esp+544]
	call	ebx
	mov	ecx, DWORD PTR _pNotifications$228405[esp+544]
	push	eax
	push	-387258512				; e8eae770H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 8896 : 					}

	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$228411[esp+524]
	mov	BYTE PTR __$EHRec$[esp+532], 3
	call	ebx
	lea	ecx, DWORD PTR _strSummary$228407[esp+524]

; 8897 : 				}

	jmp	$LN397@DoElection
$LN7@DoElection:

; 8898 : 				else if (bMet && (bFriends || iFriendship > iRelationshipAnchor))

	test	al, al
	je	$LN390@DoElection
	cmp	BYTE PTR $T260988[esp+524], 0
	jne	SHORT $LN3@DoElection
	mov	eax, DWORD PTR _iRelationshipAnchor$228401[esp+524]
	cmp	DWORD PTR _iFriendship$228400[esp+524], eax
	jle	$LN390@DoElection
$LN3@DoElection:

; 8899 : 				{
; 8900 : 					// no spy in the city, so just give them an alert that scenanigans are going on
; 8901 : 					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 8902 : 					if(pNotifications)

	test	ebx, ebx
	je	$LN390@DoElection

; 8903 : 					{
; 8904 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_ALERT_S");

	lea	edx, DWORD PTR _strSummary$228423[esp+524]
	push	OFFSET $SG228425
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8905 : 						strSummary << pCapital->getNameKey();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+532], 5
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$228423[esp+528]
	call	esi

; 8906 : 						Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_RIG_ELECTION_ALERT");

	lea	eax, DWORD PTR _strNotification$228427[esp+524]
	push	OFFSET $SG228429
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8907 : 						strNotification << pCapital->getNameKey();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+532], 6
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$228427[esp+528]
	call	esi

; 8908 : 						pNotifications->Add(NOTIFICATION_SPY_RIG_ELECTION_ALERT, strNotification.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), -1);

	mov	eax, DWORD PTR [ebp+108]
	mov	ecx, DWORD PTR [ebp+96]
	push	-1
	push	-1
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$228423[esp+540]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$228427[esp+544]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-1313356287				; b1b7c601H
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 8909 : 					}

	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$228427[esp+524]
	mov	BYTE PTR __$EHRec$[esp+532], 5
	call	ebx
	lea	ecx, DWORD PTR _strSummary$228423[esp+524]
$LN397@DoElection:
	mov	BYTE PTR __$EHRec$[esp+532], 0
	call	ebx
$LN390@DoElection:

; 8910 : 				}
; 8911 : 
; 8912 : 				if (GetEffectiveFriendshipWithMajorTimes100(ePlayer) > 0)

	cmp	DWORD PTR _ui$228378[esp+524], 0
	jl	$LN391@DoElection
	cmp	DWORD PTR _ui$228378[esp+524], 22	; 00000016H
	jge	$LN391@DoElection
	mov	ecx, DWORD PTR _ui$228378[esp+524]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+528]
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN311@DoElection
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	jmp	SHORT $LN314@DoElection
$LN311@DoElection:
	mov	edx, DWORD PTR tv1838[esp+524]
	mov	eax, DWORD PTR [edx]
$LN314@DoElection:
	test	eax, eax
	jle	$LN391@DoElection

; 8913 : 				{
; 8914 : 					int iInfluenceModifier = GET_PLAYER(eElectionWinner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_RIGGING_ELECTION_MODIFIER); // NQMP GJS - new Covert Action

	mov	ecx, DWORD PTR _elem$260779[esp+524]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	35					; 00000023H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 8915 : 					int iDiminishAmount = min(GC.getESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION() * (100 + iInfluenceModifier), GetEffectiveFriendshipWithMajorTimes100(ePlayer)); // NQMP GJS - new Covert Action

	mov	ecx, DWORD PTR _this$[esp+524]
	mov	ebx, eax
	mov	eax, DWORD PTR _ui$228378[esp+524]
	push	eax
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN324@DoElection
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN327@DoElection
$LN324@DoElection:
	mov	ecx, DWORD PTR tv1838[esp+524]
	mov	ecx, DWORD PTR [ecx]
$LN327@DoElection:
	lea	eax, DWORD PTR [ebx+100]
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7944
	mov	DWORD PTR $T260446[esp+524], eax
	cmp	ecx, eax
	mov	DWORD PTR $T260445[esp+524], ecx
	lea	eax, DWORD PTR $T260445[esp+524]
	jl	SHORT $LN340@DoElection
	lea	eax, DWORD PTR $T260446[esp+524]
$LN340@DoElection:
	mov	eax, DWORD PTR [eax]

; 8916 : 					ChangeFriendshipWithMajorTimes100(ePlayer, -iDiminishAmount, false);

	neg	eax
	mov	ecx, eax
	je	SHORT $LN391@DoElection
	mov	edx, DWORD PTR tv1838[esp+524]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[esp+524]
	push	0
	push	eax
	mov	eax, DWORD PTR _ui$228378[esp+532]
	push	eax
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN391@DoElection:
	mov	ebx, DWORD PTR _ui$228378[esp+524]
$LN13@DoElection:

; 8847 : 
; 8848 : 		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	add	DWORD PTR tv1838[esp+524], 4
	inc	ebx
	add	edi, 63236				; 0000f704H
	mov	DWORD PTR _ui$228378[esp+524], ebx
	cmp	edi, 1391192				; 00153a58H
	jb	$LL14@DoElection
$LN12@DoElection:

; 8917 : 				}
; 8918 : 			}
; 8919 : 		}
; 8920 : 	}
; 8921 : 
; 8922 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax

; 8923 : 	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
	pop	ebx
$LN396@DoElection:

; 8924 : }

	mov	eax, DWORD PTR _wvVotes$[esp+520]
	lea	ecx, DWORD PTR _wvVotes$[esp+532]
	mov	DWORD PTR __$EHRec$[esp+528], -1
	cmp	eax, ecx
	je	SHORT $LN393@DoElection
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN393@DoElection:
	pop	esi
	pop	ebp
$LN363@DoElection:
	mov	ecx, DWORD PTR __$EHRec$[esp+512]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 508				; 000001fcH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _wvVotes$[ebp]
	jmp	??1?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,22,1>::~CvWeightedVector<enum PlayerTypes,22,1>
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$228387[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strNotification$228391[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strSummary$228407[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR _strNotification$228411[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR _strSummary$228423[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoElection@CvMinorCivAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _strNotification$228427[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?DoElection@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoElection@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoElection@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::DoElection
PUBLIC	?DoUnitGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvUnit@@_N@Z ; CvMinorCivAI::DoUnitGiftFromMajor
EXTRN	?IsGreatPerson@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatPerson
; Function compile flags: /Ogtpy
;	COMDAT ?DoUnitGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
_pGiftUnit$ = 12					; size = 4
_bDistanceGift$ = 16					; size = 1
?DoUnitGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvUnit@@_N@Z PROC ; CvMinorCivAI::DoUnitGiftFromMajor, COMDAT
; _this$ = ecx

; 8962 : {

	push	esi
	push	edi

; 8963 : 	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
; 8964 : 	CvAssertMsg(eFromPlayer < MAX_MAJOR_CIVS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
; 8965 : 	if (eFromPlayer < 0 || eFromPlayer >= MAX_MAJOR_CIVS) return;

	mov	edi, DWORD PTR _eFromPlayer$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN3@DoUnitGift
	push	ebx

; 8966 : 
; 8967 : 	CvAssertMsg(pGiftUnit != NULL, "pGiftUnit is NULL");
; 8968 : 	if (pGiftUnit == NULL) return;

	mov	ebx, DWORD PTR _pGiftUnit$[esp+8]
	test	ebx, ebx
	je	SHORT $LN32@DoUnitGift

; 8969 : 
; 8970 : 	ChangeNumUnitsGifted(eFromPlayer, 1);

	mov	eax, DWORD PTR [esi+edi*4+2640]
	inc	eax
	mov	DWORD PTR [esi+edi*4+2640], eax

; 8971 : 
; 8972 : 	// Influence
; 8973 : 	int iInfluence = GetFriendshipFromUnitGift(eFromPlayer, pGiftUnit->IsGreatPerson(), bDistanceGift);

	mov	eax, DWORD PTR _bDistanceGift$[esp+8]
	push	eax
	mov	ecx, ebx
	call	?IsGreatPerson@CvUnit@@QBE_NXZ		; CvUnit::IsGreatPerson
	movzx	ecx, al
	push	ecx
	push	edi
	mov	ecx, esi
	call	?GetFriendshipFromUnitGift@CvMinorCivAI@@QAEHW4PlayerTypes@@_N1@Z ; CvMinorCivAI::GetFriendshipFromUnitGift

; 8974 : 	ChangeFriendshipWithMajor(eFromPlayer, iInfluence);

	imul	eax, 100				; 00000064H
	test	eax, eax
	je	SHORT $LN21@DoUnitGift
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	push	0
	add	ecx, eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN21@DoUnitGift:

; 8975 : 
; 8976 : 	// We can't keep Great Person units
; 8977 : 	if(pGiftUnit->IsGreatPerson())

	mov	ecx, ebx
	call	?IsGreatPerson@CvUnit@@QBE_NXZ		; CvUnit::IsGreatPerson
	test	al, al
	je	SHORT $LN32@DoUnitGift

; 8978 : 	{
; 8979 : 		pGiftUnit->kill(false);

	push	-1
	push	0
	mov	ecx, ebx
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN32@DoUnitGift:
	pop	ebx
$LN3@DoUnitGift:
	pop	edi
	pop	esi

; 8980 : 	}
; 8981 : }

	ret	12					; 0000000cH
?DoUnitGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvUnit@@_N@Z ENDP ; CvMinorCivAI::DoUnitGiftFromMajor
_TEXT	ENDS
PUBLIC	?DoFaithGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::DoFaithGiftFromMajor
EXTRN	?ChangeFaith@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::ChangeFaith
EXTRN	?GetFaith@CvPlayer@@QBEHXZ:PROC			; CvPlayer::GetFaith
EXTRN	?CanFaithGiftMinors@CvPlayer@@QAE_NXZ:PROC	; CvPlayer::CanFaithGiftMinors
; Function compile flags: /Ogtpy
;	COMDAT ?DoFaithGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_iFaith$ = 12						; size = 4
?DoFaithGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::DoFaithGiftFromMajor, COMDAT
; _this$ = ecx

; 9137 : {

	push	ecx

; 9138 : 	if(GET_PLAYER(ePlayer).CanFaithGiftMinors() && GET_PLAYER(ePlayer).GetFaith() >= iFaith)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp+8]
	mov	ebx, ebp
	imul	ebx, 63236				; 0000f704H
	push	edi
	mov	edi, ecx
	lea	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR _this$[esp+16], edi
	call	?CanFaithGiftMinors@CvPlayer@@QAE_NXZ	; CvPlayer::CanFaithGiftMinors
	test	al, al
	je	SHORT $LN14@DoFaithGif
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	add	ecx, ebx
	call	?GetFaith@CvPlayer@@QBEHXZ		; CvPlayer::GetFaith
	mov	esi, DWORD PTR _iFaith$[esp+16]
	cmp	eax, esi
	jl	SHORT $LN27@DoFaithGif

; 9139 : 	{
; 9140 : 		int iFriendshipChange = GetFriendshipFromFaithGift(ePlayer, iFaith);

	push	esi
	push	ebp
	mov	ecx, edi
	call	?GetFriendshipFromFaithGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z ; CvMinorCivAI::GetFriendshipFromFaithGift

; 9141 : 
; 9142 : 		// GJS: not sure what this part here does, but I am going to skip it for now.
; 9143 : 		//if(iFriendshipChange > 0)
; 9144 : 			//GET_PLAYER(ePlayer).GetTreasury()->LogExpenditure(GetPlayer()->GetMinorCivAI()->GetNamesListAsString(0), iGold,4);
; 9145 : 
; 9146 : 		GET_PLAYER(ePlayer).ChangeFaith(-iFaith);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	neg	esi
	push	esi
	lea	ecx, DWORD PTR [ebx+edx]
	mov	edi, eax
	call	?ChangeFaith@CvPlayer@@QAEXH@Z		; CvPlayer::ChangeFaith

; 9147 : 		
; 9148 : 		// GJS: we're not gifting gold, so it's fine to skip this.
; 9149 : 		//ChangeNumGoldGifted(ePlayer, iGold);
; 9150 : 		
; 9151 : 		ChangeFriendshipWithMajor(ePlayer, iFriendshipChange);

	imul	edi, 100				; 00000064H
	test	edi, edi
	je	SHORT $LN27@DoFaithGif
	cmp	ebp, 21					; 00000015H
	ja	SHORT $LN21@DoFaithGif
	mov	eax, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [eax+ebp*4+2024]
	jmp	SHORT $LN23@DoFaithGif
$LN21@DoFaithGif:
	xor	eax, eax
$LN23@DoFaithGif:
	mov	ecx, DWORD PTR _this$[esp+20]
	push	0
	add	eax, edi
	push	eax
	push	ebp
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN27@DoFaithGif:
	pop	esi
$LN14@DoFaithGif:

; 9152 : 
; 9153 : 		// GJS: this is no longer applicable, but might want to do somethign with this in the future: 
; 9154 : 		// In case we had a Gold Gift quest active, complete it now
; 9155 : 		//DoTestActiveQuestsForPlayer(ePlayer, /*bTestComplete*/ true, /*bTestObsolete*/ false, MINOR_CIV_QUEST_GIVE_GOLD);
; 9156 : 	}
; 9157 : 
; 9158 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	pop	edi
	pop	ebp
	pop	ebx

; 9159 : }

	add	esp, 4

; 9152 : 
; 9153 : 		// GJS: this is no longer applicable, but might want to do somethign with this in the future: 
; 9154 : 		// In case we had a Gold Gift quest active, complete it now
; 9155 : 		//DoTestActiveQuestsForPlayer(ePlayer, /*bTestComplete*/ true, /*bTestObsolete*/ false, MINOR_CIV_QUEST_GIVE_GOLD);
; 9156 : 	}
; 9157 : 
; 9158 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	DWORD PTR _iFaith$[esp-4], 1
	mov	DWORD PTR _ePlayer$[esp-4], 11		; 0000000bH
	mov	eax, DWORD PTR [edx+260]
	jmp	eax
?DoFaithGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::DoFaithGiftFromMajor
_TEXT	ENDS
PUBLIC	?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoTeamDeclaredWarOnMe
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$9
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv1474 = -572						; size = 4
$T261489 = -572						; size = 4
$T261488 = -568						; size = 4
$T261485 = -568						; size = 4
_pEnemyTeam$ = -568					; size = 4
_this$ = -564						; size = 4
_iMinorCivLoop$228772 = -560				; size = 4
_strMessage$228817 = -556				; size = 28
_veMinorsNowWary$ = -528				; size = 272
_strSummary$228814 = -256				; size = 28
_strTemp$228811 = -228					; size = 80
$T261487 = -148						; size = 28
$T261486 = -120						; size = 28
$T261484 = -92						; size = 80
$T261483 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_eEnemyTeam$ = 8					; size = 4
?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z PROC ; CvMinorCivAI::DoTeamDeclaredWarOnMe, COMDAT
; _this$ = ecx

; 9443 : {

	push	-1
	push	__ehhandler$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 560				; 00000230H
	push	ebx
	push	ebp

; 9444 : 	CvTeam* pEnemyTeam = &GET_TEAM(eEnemyTeam);

	mov	ebp, DWORD PTR _eEnemyTeam$[esp+576]
	mov	eax, ebp
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	DWORD PTR _pEnemyTeam$[esp+584], eax
	mov	ebx, ecx

; 9445 : 	CivsList veMinorsNowWary;

	xor	esi, esi
	lea	eax, DWORD PTR _veMinorsNowWary$[esp+596]
	push	edi
	mov	DWORD PTR _this$[esp+588], ebx
	mov	DWORD PTR _veMinorsNowWary$[esp+592], esi
	mov	DWORD PTR _veMinorsNowWary$[esp+596], 64 ; 00000040H
	mov	DWORD PTR _veMinorsNowWary$[esp+588], eax
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+596], esi

; 9446 : 	int iRand;
; 9447 : 
; 9448 : 	// Since eEnemyTeam was the aggressor, drop the base influence to the minimum
; 9449 : 	for(int iEnemyMajorLoop = 0; iEnemyMajorLoop < MAX_MAJOR_CIVS; iEnemyMajorLoop++)

	xor	edi, edi
$LL53@DoTeamDecl:

; 9450 : 	{
; 9451 : 		PlayerTypes eEnemyMajorLoop = (PlayerTypes) iEnemyMajorLoop;
; 9452 : 		if(!GET_PLAYER(eEnemyMajorLoop).isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN52@DoTeamDecl

; 9453 : 			continue;
; 9454 : 		if(GET_PLAYER(eEnemyMajorLoop).getTeam() != eEnemyTeam)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN89@DoTeamDecl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN90@DoTeamDecl
$LN89@DoTeamDecl:
	or	eax, -1
$LN90@DoTeamDecl:
	cmp	eax, ebp
	jne	SHORT $LN52@DoTeamDecl

; 9455 : 			continue;		
; 9456 : 
; 9457 : 		//antonjs: consider: forcibly revoke PtP here instead, and have negative INF / broken PtP fallout
; 9458 : 		
; 9459 : 		SetFriendshipWithMajor(eEnemyMajorLoop, GC.getMINOR_FRIENDSHIP_AT_WAR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	push	0
	push	eax
	push	edi
	mov	ecx, ebx
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN52@DoTeamDecl:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL53@DoTeamDecl

; 9460 : 	}
; 9461 : 
; 9462 : 	//antonjs: todo: xml, rename xml to indicate it is for WaryOf, not Permanent War
; 9463 : 	// Minor Civ Warmonger
; 9464 : 	if(pEnemyTeam->IsMinorCivWarmonger())

	mov	edi, DWORD PTR _pEnemyTeam$[esp+588]
	mov	ecx, edi
	call	?IsMinorCivWarmonger@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivWarmonger
	test	al, al
	je	SHORT $LN48@DoTeamDecl

; 9465 : 	{
; 9466 : 		if(!IsWaryOfTeam(eEnemyTeam))

	cmp	ebp, 63					; 0000003fH
	ja	SHORT $LN103@DoTeamDecl
	cmp	BYTE PTR [ebx+ebp+3248], 0
	jne	$LN153@DoTeamDecl

; 9467 : 		{
; 9468 : 			SetWaryOfTeam(eEnemyTeam, true);

	cmp	ebp, 63					; 0000003fH
	ja	SHORT $LN103@DoTeamDecl
	cmp	BYTE PTR [ebx+ebp+3248], 1
	je	SHORT $LN103@DoTeamDecl
	mov	BYTE PTR [ebx+ebp+3248], 1
$LN103@DoTeamDecl:

; 9469 : 			veMinorsNowWary.push_back(GetPlayer()->GetID());

	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _veMinorsNowWary$[esp+596]
	mov	BYTE PTR _veMinorsNowWary$[esp+856], 0
	cmp	DWORD PTR _veMinorsNowWary$[esp+592], eax
	jne	SHORT $LN117@DoTeamDecl
	push	eax
	lea	ecx, DWORD PTR _veMinorsNowWary$[esp+592]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
$LN117@DoTeamDecl:
	mov	ecx, DWORD PTR _veMinorsNowWary$[esp+588]
	mov	edx, DWORD PTR _veMinorsNowWary$[esp+592]
	lea	eax, DWORD PTR [ecx+edx*4]

; 9470 : 		}
; 9471 : 		if(ENABLE_PERMANENT_WAR)
; 9472 : 			SetPermanentWar(eEnemyTeam, true);
; 9473 : 	}

	jmp	SHORT $LN347@DoTeamDecl
$LN48@DoTeamDecl:

; 9474 : 	// Minor Civ Aggressor - chance of permanent war
; 9475 : 	else if(pEnemyTeam->IsMinorCivAggressor())

	mov	ecx, edi
	call	?IsMinorCivAggressor@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivAggressor
	test	al, al
	je	SHORT $LN153@DoTeamDecl

; 9476 : 	{
; 9477 : 		iRand = GC.getGame().getJonRandNum(100, "MINOR CIV AI: Become Wary Of aggressor roll.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228759
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 9478 : 
; 9479 : 		if(iRand < /*50*/ GC.getPERMANENT_WAR_AGGRESSOR_CHANCE())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2780
	jge	SHORT $LN153@DoTeamDecl

; 9480 : 		{
; 9481 : 			if(!IsWaryOfTeam(eEnemyTeam))

	cmp	ebp, 63					; 0000003fH
	ja	SHORT $LN138@DoTeamDecl
	cmp	BYTE PTR [ebx+ebp+3248], 0
	jne	SHORT $LN153@DoTeamDecl

; 9482 : 			{
; 9483 : 				SetWaryOfTeam(eEnemyTeam, true);

	cmp	ebp, 63					; 0000003fH
	ja	SHORT $LN138@DoTeamDecl
	cmp	BYTE PTR [ebx+ebp+3248], 1
	je	SHORT $LN138@DoTeamDecl
	mov	BYTE PTR [ebx+ebp+3248], 1
$LN138@DoTeamDecl:

; 9484 : 				veMinorsNowWary.push_back(GetPlayer()->GetID());

	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _veMinorsNowWary$[esp+596]
	mov	BYTE PTR _veMinorsNowWary$[esp+856], 0
	cmp	DWORD PTR _veMinorsNowWary$[esp+592], eax
	jne	SHORT $LN152@DoTeamDecl
	push	eax
	lea	ecx, DWORD PTR _veMinorsNowWary$[esp+592]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
$LN152@DoTeamDecl:
	mov	eax, DWORD PTR _veMinorsNowWary$[esp+588]
	mov	ecx, DWORD PTR _veMinorsNowWary$[esp+592]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN347@DoTeamDecl:
	test	eax, eax
	je	SHORT $LN155@DoTeamDecl
	mov	DWORD PTR [eax], esi
$LN155@DoTeamDecl:
	inc	DWORD PTR _veMinorsNowWary$[esp+592]
$LN153@DoTeamDecl:

; 9485 : 			}
; 9486 : 			if(ENABLE_PERMANENT_WAR)
; 9487 : 				SetPermanentWar(eEnemyTeam, true);
; 9488 : 		}
; 9489 : 	}
; 9490 : 
; 9491 : 	// See if other minors will declare war
; 9492 : 	if(pEnemyTeam->IsMinorCivAggressor())

	mov	ecx, edi
	call	?IsMinorCivAggressor@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivAggressor
	test	al, al
	je	$LN37@DoTeamDecl

; 9493 : 	{
; 9494 : 		int iChance;
; 9495 : 
; 9496 : 		PlayerProximityTypes eProximity;
; 9497 : 
; 9498 : 		int iAttackingMajorPlayer;
; 9499 : 		PlayerTypes eAttackingMajorPlayer;
; 9500 : 		bool bAttackerIsAlly;
; 9501 : 
; 9502 : 		CvPlayer* pOtherMinorCiv;
; 9503 : 		PlayerTypes eOtherMinorCiv;
; 9504 : 		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$228772[esp+588], 22 ; 00000016H
	mov	DWORD PTR tv1474[esp+588], 1391192	; 00153a58H
	npad	6
$LL39@DoTeamDecl:

; 9505 : 		{
; 9506 : 			eOtherMinorCiv = (PlayerTypes) iMinorCivLoop;
; 9507 : 			pOtherMinorCiv = &GET_PLAYER((eOtherMinorCiv));

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1474[esp+588]
	lea	ebx, DWORD PTR [eax+edx]

; 9508 : 
; 9509 : 			iChance = 0;

	xor	ebp, ebp

; 9510 : 
; 9511 : 			// Must be alive
; 9512 : 			if(!pOtherMinorCiv->isAlive())

	cmp	BYTE PTR [ebx+2256], 0
	je	$LN38@DoTeamDecl

; 9513 : 				continue;
; 9514 : 
; 9515 : 			// Must be a different minor
; 9516 : 			if(eOtherMinorCiv == GetPlayer()->GetID())

	mov	ecx, DWORD PTR _this$[esp+588]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iMinorCivLoop$228772[esp+588]
	cmp	edx, DWORD PTR [eax+44]
	je	$LN38@DoTeamDecl

; 9517 : 				continue;
; 9518 : 
; 9519 : 			// Ignore minors that want THIS minor dead
; 9520 : 			if(pOtherMinorCiv->GetMinorCivAI()->IsWantsMinorDead(GetPlayer()->GetID()))

	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsWantsMinorDead@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsWantsMinorDead
	test	al, al
	jne	$LN38@DoTeamDecl

; 9521 : 				continue;
; 9522 : 
; 9523 : 			bAttackerIsAlly = false;
; 9524 : 
; 9525 : 			// Ignore minors that are allied to the attacker
; 9526 : 			for(iAttackingMajorPlayer = 0; iAttackingMajorPlayer < MAX_MAJOR_CIVS; iAttackingMajorPlayer++)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	edi, edi
	xor	esi, esi
$LL33@DoTeamDecl:

; 9527 : 			{
; 9528 : 				eAttackingMajorPlayer = (PlayerTypes) iAttackingMajorPlayer;
; 9529 : 
; 9530 : 				// Not on this team
; 9531 : 				if(GET_PLAYER(eAttackingMajorPlayer).getTeam() != eEnemyTeam)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN188@DoTeamDecl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN189@DoTeamDecl
$LN188@DoTeamDecl:
	or	eax, -1
$LN189@DoTeamDecl:
	cmp	eax, DWORD PTR _eEnemyTeam$[esp+584]
	jne	SHORT $LN32@DoTeamDecl

; 9532 : 					continue;
; 9533 : 
; 9534 : 				// Not alive
; 9535 : 				if(!GET_PLAYER(eAttackingMajorPlayer).isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN32@DoTeamDecl

; 9536 : 					continue;
; 9537 : 
; 9538 : 				if(pOtherMinorCiv->GetMinorCivAI()->GetAlly() == eAttackingMajorPlayer)

	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	cmp	DWORD PTR [eax+2012], edi
	je	$LN38@DoTeamDecl
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN32@DoTeamDecl:

; 9521 : 				continue;
; 9522 : 
; 9523 : 			bAttackerIsAlly = false;
; 9524 : 
; 9525 : 			// Ignore minors that are allied to the attacker
; 9526 : 			for(iAttackingMajorPlayer = 0; iAttackingMajorPlayer < MAX_MAJOR_CIVS; iAttackingMajorPlayer++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL33@DoTeamDecl

; 9539 : 				{
; 9540 : 					bAttackerIsAlly = true;
; 9541 : 					break;
; 9542 : 				}
; 9543 : 			}
; 9544 : 
; 9545 : 			if(bAttackerIsAlly)
; 9546 : 				continue;
; 9547 : 
; 9548 : 			// Closer to the minor the more likely war is
; 9549 : 			eProximity = pOtherMinorCiv->GetProximityToPlayer(GetPlayer()->GetID());

	mov	eax, DWORD PTR _this$[esp+588]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebx
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer

; 9550 : 
; 9551 : 			// Warmonger
; 9552 : 			if(pEnemyTeam->IsMinorCivWarmonger())

	mov	ecx, DWORD PTR _pEnemyTeam$[esp+588]
	mov	esi, eax
	call	?IsMinorCivWarmonger@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivWarmonger
	test	al, al
	je	SHORT $LN26@DoTeamDecl

; 9553 : 			{
; 9554 : 				if(eProximity == PLAYER_PROXIMITY_DISTANT)

	test	esi, esi
	jne	SHORT $LN25@DoTeamDecl

; 9555 : 					iChance += /*25*/ GC.getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2784
	jmp	SHORT $LN11@DoTeamDecl
$LN25@DoTeamDecl:

; 9556 : 				else if(eProximity == PLAYER_PROXIMITY_FAR)

	cmp	esi, 1
	jne	SHORT $LN23@DoTeamDecl

; 9557 : 					iChance += /*50*/ GC.getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2788
	jmp	SHORT $LN11@DoTeamDecl
$LN23@DoTeamDecl:

; 9558 : 				else if(eProximity == PLAYER_PROXIMITY_CLOSE)

	cmp	esi, 2
	jne	SHORT $LN21@DoTeamDecl

; 9559 : 					iChance += /*75*/ GC.getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2792
	jmp	SHORT $LN11@DoTeamDecl
$LN21@DoTeamDecl:

; 9560 : 				else if(eProximity == PLAYER_PROXIMITY_NEIGHBORS)

	cmp	esi, 3
	jne	SHORT $LN11@DoTeamDecl

; 9561 : 					iChance += /*100*/ GC.getPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2796

; 9562 : 			}
; 9563 : 			// Aggressor
; 9564 : 			else

	jmp	SHORT $LN11@DoTeamDecl
$LN26@DoTeamDecl:

; 9565 : 			{
; 9566 : 				if(eProximity == PLAYER_PROXIMITY_DISTANT)

	test	esi, esi
	jne	SHORT $LN17@DoTeamDecl

; 9567 : 					iChance += /*0*/ GC.getPERMANENT_WAR_OTHER_CHANCE_DISTANT();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2800
	jmp	SHORT $LN11@DoTeamDecl
$LN17@DoTeamDecl:

; 9568 : 				else if(eProximity == PLAYER_PROXIMITY_FAR)

	cmp	esi, 1
	jne	SHORT $LN15@DoTeamDecl

; 9569 : 					iChance += /*0*/ GC.getPERMANENT_WAR_OTHER_CHANCE_FAR();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2804
	jmp	SHORT $LN11@DoTeamDecl
$LN15@DoTeamDecl:

; 9570 : 				else if(eProximity == PLAYER_PROXIMITY_CLOSE)

	cmp	esi, 2
	jne	SHORT $LN13@DoTeamDecl

; 9571 : 					iChance += /*20*/ GC.getPERMANENT_WAR_OTHER_CHANCE_CLOSE();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2808
	jmp	SHORT $LN11@DoTeamDecl
$LN13@DoTeamDecl:

; 9572 : 				else if(eProximity == PLAYER_PROXIMITY_NEIGHBORS)

	cmp	esi, 3
	jne	SHORT $LN11@DoTeamDecl

; 9573 : 					iChance += /*50*/ GC.getPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2812
$LN11@DoTeamDecl:

; 9574 : 			}
; 9575 : 
; 9576 : 			// If the minor is already at war, then there's a chance of it turning into permanent war
; 9577 : 			if(GET_TEAM(pOtherMinorCiv->getTeam()).isAtWar(eEnemyTeam))

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN227@DoTeamDecl
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN228@DoTeamDecl
$LN227@DoTeamDecl:
	or	eax, -1
$LN228@DoTeamDecl:
	mov	esi, DWORD PTR _eEnemyTeam$[esp+584]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN10@DoTeamDecl

; 9578 : 				iChance += /*50*/ GC.getPERMANENT_WAR_OTHER_AT_WAR();

	add	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2816
$LN10@DoTeamDecl:

; 9579 : 
; 9580 : 			iRand = GC.getGame().getJonRandNum(100, "MINOR CIV AI: Third party minor to become Wary Of aggressor roll.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228805
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 9581 : 			if(iRand < iChance)

	cmp	eax, ebp
	jge	SHORT $LN38@DoTeamDecl

; 9582 : 			{
; 9583 : 				if(!pOtherMinorCiv->GetMinorCivAI()->IsWaryOfTeam(eEnemyTeam))

	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN339@DoTeamDecl
	cmp	BYTE PTR [eax+esi+3248], 0
	jne	SHORT $LN38@DoTeamDecl
$LN339@DoTeamDecl:

; 9584 : 				{
; 9585 : 					pOtherMinorCiv->GetMinorCivAI()->SetWaryOfTeam(eEnemyTeam, true);

	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN243@DoTeamDecl
	cmp	BYTE PTR [eax+esi+3248], 1
	je	SHORT $LN243@DoTeamDecl
	mov	BYTE PTR [eax+esi+3248], 1
$LN243@DoTeamDecl:

; 9586 : 					veMinorsNowWary.push_back(eOtherMinorCiv);

	mov	eax, DWORD PTR _veMinorsNowWary$[esp+596]
	mov	BYTE PTR _veMinorsNowWary$[esp+856], 0
	cmp	DWORD PTR _veMinorsNowWary$[esp+592], eax
	jne	SHORT $LN251@DoTeamDecl
	push	eax
	lea	ecx, DWORD PTR _veMinorsNowWary$[esp+592]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::GrowSize
$LN251@DoTeamDecl:
	mov	eax, DWORD PTR _veMinorsNowWary$[esp+588]
	mov	ecx, DWORD PTR _veMinorsNowWary$[esp+592]
	lea	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN254@DoTeamDecl
	mov	edx, DWORD PTR _iMinorCivLoop$228772[esp+588]
	mov	DWORD PTR [eax], edx
$LN254@DoTeamDecl:
	inc	DWORD PTR _veMinorsNowWary$[esp+592]
$LN38@DoTeamDecl:

; 9493 : 	{
; 9494 : 		int iChance;
; 9495 : 
; 9496 : 		PlayerProximityTypes eProximity;
; 9497 : 
; 9498 : 		int iAttackingMajorPlayer;
; 9499 : 		PlayerTypes eAttackingMajorPlayer;
; 9500 : 		bool bAttackerIsAlly;
; 9501 : 
; 9502 : 		CvPlayer* pOtherMinorCiv;
; 9503 : 		PlayerTypes eOtherMinorCiv;
; 9504 : 		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	eax, DWORD PTR tv1474[esp+588]
	inc	DWORD PTR _iMinorCivLoop$228772[esp+588]
	add	eax, 63236				; 0000f704H
	cmp	eax, 3983868				; 003cc9fcH
	mov	DWORD PTR tv1474[esp+588], eax
	jl	$LL39@DoTeamDecl
$LN37@DoTeamDecl:

; 9587 : 				}
; 9588 : 				if(ENABLE_PERMANENT_WAR)
; 9589 : 					pOtherMinorCiv->GetMinorCivAI()->SetPermanentWar(eEnemyTeam, true);
; 9590 : 			}
; 9591 : 		}
; 9592 : 	}
; 9593 : 
; 9594 : 	if(veMinorsNowWary.size() > 0)

	cmp	DWORD PTR _veMinorsNowWary$[esp+592], 0
	jbe	$LN6@DoTeamDecl

; 9595 : 	{
; 9596 : 		int iMinimumFriendshipMod = 20; //antonjs: todo: xml
; 9597 : 		Localization::String strTemp;

	lea	ecx, DWORD PTR _strTemp$228811[esp+588]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 9598 : 
; 9599 : 		strTemp = Localization::Lookup("TXT_KEY_NOTIFICATION_MINORS_NOW_WARY");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR $T261483[esp+588]
	push	OFFSET $SG228813
	push	eax
	mov	BYTE PTR __$EHRec$[esp+604], 1
	call	esi
	add	esp, 8
	mov	edi, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strTemp$228811[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 2
	call	edi
	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T261483[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 1
	call	ebx

; 9600 : 		CvString strSummary = strTemp.toUTF8();

	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228811[esp+588]
	call	ebp
	test	eax, eax
	jne	SHORT $LN268@DoTeamDecl
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN268@DoTeamDecl:
	push	eax
	lea	ecx, DWORD PTR _strSummary$228814[esp+592]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 9601 : 		strTemp = Localization::Lookup("TXT_KEY_NOTIFICATION_MINORS_NOW_WARY_TT");

	lea	ecx, DWORD PTR $T261484[esp+588]
	push	OFFSET $SG228816
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+604], 3
	call	esi
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTemp$228811[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 4
	call	edi
	lea	ecx, DWORD PTR $T261484[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 3
	call	ebx

; 9602 : 		strTemp << iMinimumFriendshipMod;

	push	20					; 00000014H
	lea	ecx, DWORD PTR _strTemp$228811[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 9603 : 		CvString strMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$228811[esp+588]
	call	ebp
	test	eax, eax
	jne	SHORT $LN275@DoTeamDecl
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN275@DoTeamDecl:
	push	eax
	lea	ecx, DWORD PTR _strMessage$228817[esp+592]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 9604 : 
; 9605 : 		for(int iEnemyMajorLoop = 0; iEnemyMajorLoop < MAX_MAJOR_CIVS; iEnemyMajorLoop++)

	xor	esi, esi
	mov	BYTE PTR __$EHRec$[esp+596], 5
	xor	edi, edi
	mov	bl, 6
	npad	11
$LL5@DoTeamDecl:

; 9606 : 		{
; 9607 : 			PlayerTypes eEnemyMajorLoop = (PlayerTypes) iEnemyMajorLoop;
; 9608 : 			if(!GET_PLAYER(eEnemyMajorLoop).isAlive())

	cmp	BYTE PTR [edi+ecx+2256], 0
	je	$LN4@DoTeamDecl

; 9609 : 				continue;
; 9610 : 			if(GET_PLAYER(eEnemyMajorLoop).getTeam() != eEnemyTeam)

	mov	eax, DWORD PTR [edi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN289@DoTeamDecl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN290@DoTeamDecl
$LN289@DoTeamDecl:
	or	eax, -1
$LN290@DoTeamDecl:
	cmp	eax, DWORD PTR _eEnemyTeam$[esp+584]
	jne	$LN4@DoTeamDecl

; 9611 : 				continue;
; 9612 : 
; 9613 : 			strMessage = strMessage + GetNamesListAsString(veMinorsNowWary);

	sub	esp, 272				; 00000110H
	lea	eax, DWORD PTR _veMinorsNowWary$[esp+860]
	mov	ecx, esp
	mov	DWORD PTR $T261485[esp+860], esp
	push	eax
	call	??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
	lea	ecx, DWORD PTR $T261486[esp+860]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+864]
	call	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
	push	eax
	lea	edx, DWORD PTR _strMessage$228817[esp+592]
	push	edx
	lea	eax, DWORD PTR $T261487[esp+596]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+608], bl
	call	ebp
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+596], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$228817[esp+592]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T261487[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T261486[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9614 : 			AddNotification(strMessage, strSummary, eEnemyMajorLoop);

	push	-1
	push	-1
	push	esi
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strSummary$228814[esp+628]
	mov	DWORD PTR $T261488[esp+628], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _strMessage$228817[esp+656]
	mov	DWORD PTR $T261489[esp+656], esp
	mov	ecx, esp
	push	eax
	mov	BYTE PTR __$EHRec$[esp+668], 8
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[esp+656]
	mov	BYTE PTR __$EHRec$[esp+664], 5
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN4@DoTeamDecl:
	add	edi, 63236				; 0000f704H
	inc	esi
	cmp	edi, 1391192				; 00153a58H
	jl	$LL5@DoTeamDecl

; 9615 : 		}
; 9616 : 	}

	lea	ecx, DWORD PTR _strMessage$228817[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strSummary$228814[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228811[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN6@DoTeamDecl:

; 9617 : 
; 9618 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax

; 9619 : }

	mov	eax, DWORD PTR _veMinorsNowWary$[esp+588]
	lea	ecx, DWORD PTR _veMinorsNowWary$[esp+600]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	cmp	eax, ecx
	je	SHORT $LN315@DoTeamDecl
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN315@DoTeamDecl:
	mov	ecx, DWORD PTR __$EHRec$[esp+588]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 572				; 0000023cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _veMinorsNowWary$[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$228811[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$2:
	lea	ecx, DWORD PTR $T261483[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$3:
	lea	ecx, DWORD PTR _strSummary$228814[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$4:
	lea	ecx, DWORD PTR $T261484[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$5:
	lea	ecx, DWORD PTR _strMessage$228817[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$7:
	lea	ecx, DWORD PTR $T261486[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$8:
	lea	ecx, DWORD PTR $T261487[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z$9:
	mov	ecx, DWORD PTR $T261488[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ENDP ; CvMinorCivAI::DoTeamDeclaredWarOnMe
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ ; std::vector<CvString,std::allocator<CvString> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T262075 = -4						; size = 4
?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T262075[esp+12]
	push	eax
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::push_back
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T262112 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z PROC ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+24], esi
	mov	BYTE PTR [esi+3444], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@17

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::GrowSize
$LN1@push_back@17:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 156				; 0000009cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T262112[esp+24], ecx
	mov	DWORD PTR __$EHRec$[esp+32], 0
	je	SHORT $LN4@push_back@17
	mov	eax, DWORD PTR _element$[esp+20]
	push	eax
	call	??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
$LN4@push_back@17:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], ecx

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T262112[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@@Z ENDP ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::push_back
PUBLIC	??0?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ??0?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ PROC ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >, COMDAT
; _this$ = ecx

; 80   : 		{	// construct empty set from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+17], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 81   : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ ENDP ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11
__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
_TEXT	SEGMENT
__Tmp$231025 = -92					; size = 28
__Tmp$231015 = -64					; size = 28
__Whereoff$231001 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$231002 = -28					; size = 4
__Newvec$231000 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$262553 = 8					; size = 1
__Cat$262481 = 8					; size = 1
__Where$ = 8						; size = 4
tv525 = 12						; size = 4
__Count$ = 12						; size = 4
$T262549 = 16						; size = 1
$T262477 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@2
$LN31@Insert_n@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 153391689				; 09249249H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN103@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 153391689				; 09249249H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	add	esp, 8
	mov	DWORD PTR __Ncopied$231002[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	lea	eax, DWORD PTR [ebx*8]
	mov	DWORD PTR __Newvec$231000[ebp], ecx
	sub	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$231001[ebp], ebx
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$262481[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T262477[ebp], 0
	mov	edx, DWORD PTR $T262477[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$231000[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$231002[ebp], 1
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$231000[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T262549[ebp], 0
	mov	edx, DWORD PTR $T262549[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$262553[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$231002[ebp], 2
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN83@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Newvec$231000[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$231002[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$231001[ebp]
	mov	edi, DWORD PTR __Newvec$231000[ebp]
	jle	SHORT $LN7@Insert_n@2
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edx, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN104@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$231015[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$231015[ebp]
	push	edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$231015[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$231015[ebp]

; 1233 : 		else

	jmp	$LN102@Insert_n@2
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN105@Insert_n@2:
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$231025[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$231025[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$231025[ebp]
$LN102@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n@2:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN101@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$231015[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$231025[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ; std::sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z PROC ; std::sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0@Z ENDP ; std::sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::sort<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::sort<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::sort<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ; std::sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z PROC ; std::sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0@Z ENDP ; std::sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ; std::sort<CvWeightedVector<int,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z PROC ; std::sort<CvWeightedVector<int,100,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0@Z ENDP ; std::sort<CvWeightedVector<int,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@18
	xor	eax, eax
	jmp	SHORT $LN10@push_back@18
$LN9@push_back@18:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@18:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@18
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@18:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ		; CvMinorCivQuest::DoFinishQuest
EXTRN	?GetName@CvReligion@@QBE?AVCvString@@XZ:PROC	; CvReligion::GetName
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ DD 019930522H
	DD	036H
	DD	FLAT:__unwindtable$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$7
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$8
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$9
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$10
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$11
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$12
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$13
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$14
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$15
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$16
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$17
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$18
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$19
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$20
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$21
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$22
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$23
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$24
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$25
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$26
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$27
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$28
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$29
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$30
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$31
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$32
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$33
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$34
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$35
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$36
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$37
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$38
	DD	026H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$39
	DD	026H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$40
	DD	026H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$41
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$42
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$43
	DD	02H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$44
	DD	02cH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$45
	DD	02dH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$46
	DD	02dH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$47
	DD	02fH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$48
	DD	02dH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$49
	DD	031H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$50
	DD	032H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$51
	DD	02dH
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$52
	DD	034H
	DD	FLAT:__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$53
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ
_TEXT	SEGMENT
$T263032 = -1016					; size = 4
_eReligion$222127 = -1016				; size = 4
_strCivKey$222118 = -1016				; size = 4
_strCivKey$222107 = -1016				; size = 4
_strCivKey$222069 = -1016				; size = 4
_strCivKey$222058 = -1016				; size = 4
_strCivKey$222043 = -1016				; size = 4
_strTargetNameKey$222034 = -1016			; size = 4
_strUnitName$222025 = -1016				; size = 4
_strBuildingName$222016 = -1016				; size = 4
_strResourceName$222007 = -1016				; size = 4
_bWasAllies$ = -1010					; size = 1
_bWasFriends$ = -1009					; size = 1
_bNowFriends$ = -1008					; size = 1
$T262994 = -1008					; size = 4
_statusChangeStrings$222190 = -1004			; size = 56
$T262906 = -1004					; size = 80
$T262903 = -1004					; size = 80
$T262898 = -1004					; size = 80
$T262897 = -1004					; size = 80
$T262896 = -1004					; size = 80
$T262895 = -1004					; size = 80
$T262894 = -1004					; size = 80
$T262892 = -1004					; size = 80
$T262891 = -1004					; size = 80
$T262889 = -1004					; size = 80
$T262888 = -1004					; size = 80
$T262886 = -1004					; size = 80
$T262885 = -1004					; size = 80
$T262884 = -1004					; size = 80
$T262883 = -1004					; size = 80
$T262882 = -1004					; size = 80
$T262881 = -1004					; size = 80
$T262880 = -1004					; size = 80
$T262879 = -1004					; size = 80
$T262878 = -1004					; size = 80
$T262877 = -1004					; size = 80
$T262876 = -1004					; size = 80
$T262875 = -1004					; size = 80
$T262874 = -1004					; size = 80
$T262873 = -1004					; size = 80
$T262872 = -1004					; size = 80
$T262871 = -1004					; size = 80
$T262870 = -1004					; size = 80
$T262869 = -1004					; size = 80
$T262868 = -1004					; size = 80
$T262867 = -1004					; size = 80
$T262866 = -1004					; size = 80
$T262865 = -1004					; size = 80
$T262909 = -924						; size = 4
_iInfChange$ = -924					; size = 4
_bNowAllies$ = -920					; size = 1
$T262915 = -916						; size = 4
_eNewAlly$ = -916					; size = 4
$T262914 = -912						; size = 4
_eOldAlly$ = -912					; size = 4
_strMessage$ = -908					; size = 80
_strSummary$ = -828					; size = 80
$T262912 = -748						; size = 28
$T262910 = -748						; size = 28
_strReligionKey$222129 = -748				; size = 28
_sMessage$ = -720					; size = 28
$T262913 = -692						; size = 28
$T262911 = -692						; size = 28
$T262900 = -692						; size = 28
_sSummary$ = -664					; size = 28
$T262905 = -636						; size = 80
$T262901 = -636						; size = 80
$T262899 = -636						; size = 80
_veNamesToShow$ = -556					; size = 272
$T262893 = -284						; size = 272
$T262890 = -284						; size = 272
$T262887 = -284						; size = 272
__$EHRec$ = -12						; size = 12
?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ PROC		; CvMinorCivQuest::DoFinishQuest, COMDAT
; _this$ = ecx

; 1208 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1004				; 000003ecH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 1209 : 	if (!IsComplete())

	call	?IsComplete@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsComplete
	test	al, al
	jne	SHORT $LN47@DoFinishQu
$LN320@DoFinishQu:

; 1210 : 		return false;

	xor	al, al
	jmp	$LN48@DoFinishQu
$LN47@DoFinishQu:

; 1211 : 
; 1212 : 	if (IsHandled())

	mov	al, BYTE PTR [esi+24]
	test	al, al

; 1213 : 		return false;

	jne	SHORT $LN320@DoFinishQu

; 1214 : 
; 1215 : 	SetHandled(true); // We are handling the end of the quest, and this should only happen once
; 1216 : 
; 1217 : 	CvPlayer* pMinor = &GET_PLAYER(m_eMinor);

	mov	edi, DWORD PTR [esi]

; 1218 : 
; 1219 : 	bool bWasFriends = pMinor->GetMinorCivAI()->IsFriends(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	imul	edi, 63236				; 0000f704H
	mov	BYTE PTR [esi+24], 1
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends

; 1220 : 	bool bWasAllies = pMinor->GetMinorCivAI()->IsAllies(m_eAssignedPlayer);

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, edi
	mov	BYTE PTR _bWasFriends$[esp+1032], al
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	cmp	DWORD PTR [eax+2012], ebx

; 1221 : 	PlayerTypes eOldAlly = pMinor->GetMinorCivAI()->GetAlly();

	mov	ecx, edi
	sete	BYTE PTR _bWasAllies$[esp+1032]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, DWORD PTR [eax+2012]

; 1222 : 	int iOldInf = pMinor->GetMinorCivAI()->GetEffectiveFriendshipWithMajor(m_eAssignedPlayer);

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _eOldAlly$[esp+1032], ecx
	push	edx
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor

; 1223 : 
; 1224 : 	pMinor->GetMinorCivAI()->ChangeFriendshipWithMajor(m_eAssignedPlayer, GetInfluenceReward(), /*bFromQuest*/ true);

	mov	ecx, esi
	mov	ebp, eax
	call	?GetInfluenceReward@CvMinorCivQuest@@QBEHXZ ; CvMinorCivQuest::GetInfluenceReward
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edi
	mov	DWORD PTR $T262994[esp+1032], eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	imul	ebx, 100				; 00000064H
	mov	ecx, DWORD PTR $T262994[esp+1032]
	push	1
	push	ebx
	push	ecx
	mov	ecx, eax
	call	?ChangeFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::ChangeFriendshipWithMajorTimes100

; 1225 : 	
; 1226 : 	bool bNowFriends = pMinor->GetMinorCivAI()->IsFriends(m_eAssignedPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends

; 1227 : 	bool bNowAllies = pMinor->GetMinorCivAI()->IsAllies(m_eAssignedPlayer);

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, edi
	mov	BYTE PTR _bNowFriends$[esp+1032], al
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	cmp	DWORD PTR [eax+2012], ebx

; 1228 : 	PlayerTypes eNewAlly = pMinor->GetMinorCivAI()->GetAlly();

	mov	ecx, edi
	sete	BYTE PTR _bNowAllies$[esp+1032]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI

; 1229 : 	int iNewInf = pMinor->GetMinorCivAI()->GetEffectiveFriendshipWithMajor(m_eAssignedPlayer);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+2012]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _eNewAlly$[esp+1036], eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor

; 1230 : 	int iInfChange = iNewInf - iOldInf;
; 1231 : 
; 1232 : 	Localization::String strMessage;

	mov	ebx, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	sub	eax, ebp
	lea	ecx, DWORD PTR _strMessage$[esp+1032]
	mov	DWORD PTR _iInfChange$[esp+1032], eax
	call	ebx
	xor	ebp, ebp

; 1233 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+1032]
	mov	DWORD PTR __$EHRec$[esp+1040], ebp
	call	ebx

; 1234 : 	CivsList veNamesToShow;

	lea	edx, DWORD PTR _veNamesToShow$[esp+1044]
	mov	DWORD PTR _veNamesToShow$[esp+1036], ebp
	mov	DWORD PTR _veNamesToShow$[esp+1040], 64	; 00000040H
	mov	DWORD PTR _veNamesToShow$[esp+1032], edx

; 1235 : 
; 1236 : 	// BUILD A ROUTE
; 1237 : 	if(m_eType == MINOR_CIV_QUEST_ROUTE)

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	cmp	eax, ebp
	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	jne	$LN45@DoFinishQu

; 1238 : 	{
; 1239 : 		// Route exists!
; 1240 : 		pMinor->GetMinorCivAI()->SetRouteConnectionEstablished(m_eAssignedPlayer, true);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edi
	mov	DWORD PTR $T263032[esp+1032], eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, DWORD PTR $T263032[esp+1032]
	cmp	ecx, 21					; 00000015H
	ja	SHORT $LN129@DoFinishQu
	cmp	BYTE PTR [ecx+eax+1988], 1
	je	SHORT $LN129@DoFinishQu
	mov	BYTE PTR [ecx+eax+1988], 1
$LN129@DoFinishQu:

; 1241 : 
; 1242 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_ROUTE_CONNECTION");

	lea	ecx, DWORD PTR $T262865[esp+1032]
	push	OFFSET $SG221994
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 3
	call	ebp
	lea	ecx, DWORD PTR $T262865[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1243 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_ROUTE_CONNECTION");

	lea	edx, DWORD PTR $T262866[esp+1032]
	push	OFFSET $SG221996
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 4
	call	ebp
	lea	ecx, DWORD PTR $T262866[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN9@DoFinishQu
$LN45@DoFinishQu:

; 1244 : 	}
; 1245 : 
; 1246 : 	// KILL A CAMP
; 1247 : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	eax, 1
	jne	SHORT $LN43@DoFinishQu

; 1248 : 	{
; 1249 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_KILL_CAMP");

	lea	eax, DWORD PTR $T262867[esp+1032]
	push	OFFSET $SG222000
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 5
	call	ebp
	lea	ecx, DWORD PTR $T262867[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1250 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_KILL_CAMP");

	lea	ecx, DWORD PTR $T262868[esp+1032]
	push	OFFSET $SG222002
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 6
	call	ebp
	lea	ecx, DWORD PTR $T262868[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN9@DoFinishQu
$LN43@DoFinishQu:

; 1251 : 	}
; 1252 : 
; 1253 : 	// CONNECT A RESOURCE
; 1254 : 	else if(m_eType == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	eax, 2
	jne	$LN41@DoFinishQu

; 1255 : 	{
; 1256 : 		ResourceTypes eResource = (ResourceTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1257 : 		const char* strResourceName = GC.getResourceInfo(eResource)->GetDescriptionKey();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 1258 : 
; 1259 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONNECT_RESOURCE");

	lea	edx, DWORD PTR $T262869[esp+1032]
	push	OFFSET $SG222009
	push	edx
	mov	DWORD PTR _strResourceName$222007[esp+1040], eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 7
	call	ebp
	lea	ecx, DWORD PTR $T262869[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1260 : 		strMessage << strResourceName;

	mov	eax, DWORD PTR _strResourceName$222007[esp+1032]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1261 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONNECT_RESOURCE");

	lea	ecx, DWORD PTR $T262870[esp+1032]
	push	OFFSET $SG222011
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 8
	call	ebp
	lea	ecx, DWORD PTR $T262870[esp+1032]

; 1262 : 		strSummary << strResourceName;

	jmp	$LN321@DoFinishQu
$LN41@DoFinishQu:

; 1263 : 	}
; 1264 : 
; 1265 : 	// CONSTRUCT A WONDER
; 1266 : 	else if(m_eType == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	$LN39@DoFinishQu

; 1267 : 	{
; 1268 : 		BuildingTypes eWonder = (BuildingTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1269 : 		const char* strBuildingName = GC.getBuildingInfo(eWonder)->GetDescriptionKey();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _strBuildingName$222016[esp+1032], eax

; 1270 : 
; 1271 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONSTRUCT_WONDER");

	lea	eax, DWORD PTR $T262871[esp+1032]
	push	OFFSET $SG222018
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 9
	call	ebp
	lea	ecx, DWORD PTR $T262871[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1272 : 		strMessage << strBuildingName;

	mov	ecx, DWORD PTR _strBuildingName$222016[esp+1032]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1273 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONSTRUCT_WONDER");

	lea	edx, DWORD PTR $T262872[esp+1032]
	push	OFFSET $SG222020
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 10	; 0000000aH
	call	ebp
	lea	ecx, DWORD PTR $T262872[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1274 : 		strSummary << strBuildingName;

	mov	eax, DWORD PTR _strBuildingName$222016[esp+1032]
	push	eax

; 1402 : 		strSummary << strCivKey;

	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN9@DoFinishQu
$LN39@DoFinishQu:

; 1275 : 	}
; 1276 : 
; 1277 : 	// GREAT PERSON
; 1278 : 	else if(m_eType == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4
	jne	$LN37@DoFinishQu

; 1279 : 	{
; 1280 : 		UnitTypes eUnit = (UnitTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1281 : 		const char* strUnitName = GC.getUnitInfo(eUnit)->GetDescriptionKey();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 1282 : 
; 1283 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_GREAT_PERSON");

	lea	ecx, DWORD PTR $T262873[esp+1032]
	push	OFFSET $SG222027
	push	ecx
	mov	DWORD PTR _strUnitName$222025[esp+1040], eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 11	; 0000000bH
	call	ebp
	lea	ecx, DWORD PTR $T262873[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1284 : 		strMessage << strUnitName;

	mov	edx, DWORD PTR _strUnitName$222025[esp+1032]
	push	edx
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1285 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_GREAT_PERSON");

	lea	eax, DWORD PTR $T262874[esp+1032]
	push	OFFSET $SG222029
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 12	; 0000000cH
	call	ebp
	lea	ecx, DWORD PTR $T262874[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1286 : 		strSummary << strUnitName;

	mov	ecx, DWORD PTR _strUnitName$222025[esp+1032]
	push	ecx

; 1402 : 		strSummary << strCivKey;

	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN9@DoFinishQu
$LN37@DoFinishQu:

; 1287 : 	}
; 1288 : 
; 1289 : 	// KILL ANOTHER CITY STATE
; 1290 : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	$LN35@DoFinishQu

; 1291 : 	{
; 1292 : 		PlayerTypes eTargetCityState = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1293 : 		const char* strTargetNameKey = GET_PLAYER(eTargetCityState).getNameKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 1294 : 
; 1295 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_KILL_CITY_STATE");

	lea	edx, DWORD PTR $T262875[esp+1032]
	push	OFFSET $SG222036
	push	edx
	mov	DWORD PTR _strTargetNameKey$222034[esp+1040], eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 13	; 0000000dH
	call	ebp
	lea	ecx, DWORD PTR $T262875[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1296 : 		strMessage << strTargetNameKey;

	mov	eax, DWORD PTR _strTargetNameKey$222034[esp+1032]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1297 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_KILL_CITY_STATE");

	lea	ecx, DWORD PTR $T262876[esp+1032]
	push	OFFSET $SG222038
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 14	; 0000000eH
	call	ebp
	lea	ecx, DWORD PTR $T262876[esp+1032]

; 1298 : 		strSummary << strTargetNameKey;

	jmp	$LN321@DoFinishQu
$LN35@DoFinishQu:

; 1299 : 	}
; 1300 : 
; 1301 : 	// FIND ANOTHER PLAYER
; 1302 : 	else if(m_eType == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6
	jne	$LN33@DoFinishQu

; 1303 : 	{
; 1304 : 		PlayerTypes ePlayerFound = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1305 : 		const char* strCivKey = GET_PLAYER(ePlayerFound).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strCivKey$222043[esp+1032], eax

; 1306 : 
; 1307 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_FIND_PLAYER");

	lea	eax, DWORD PTR $T262877[esp+1032]
	push	OFFSET $SG222045
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 15	; 0000000fH
	call	ebp
	lea	ecx, DWORD PTR $T262877[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1308 : 		strMessage << strCivKey;

	mov	ecx, DWORD PTR _strCivKey$222043[esp+1032]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1309 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_FIND_PLAYER");

	lea	edx, DWORD PTR $T262878[esp+1032]
	push	OFFSET $SG222047
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 16	; 00000010H
	call	ebp
	lea	ecx, DWORD PTR $T262878[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1310 : 		strSummary << strCivKey;

	mov	eax, DWORD PTR _strCivKey$222043[esp+1032]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN9@DoFinishQu
$LN33@DoFinishQu:

; 1311 : 	}
; 1312 : 
; 1313 : 	// FIND NATURAL WONDER
; 1314 : 	else if(m_eType == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7
	jne	SHORT $LN31@DoFinishQu

; 1315 : 	{
; 1316 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_FIND_NATURAL_WONDER");

	lea	ecx, DWORD PTR $T262879[esp+1032]
	push	OFFSET $SG222051
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 17	; 00000011H
	call	ebp
	lea	ecx, DWORD PTR $T262879[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1317 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_FIND_NATURAL_WONDER");

	lea	edx, DWORD PTR $T262880[esp+1032]
	push	OFFSET $SG222053
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 18	; 00000012H
	call	ebp
	lea	ecx, DWORD PTR $T262880[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN9@DoFinishQu
$LN31@DoFinishQu:

; 1318 : 	}
; 1319 : 
; 1320 : 	// Give gold
; 1321 : 	else if(m_eType == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8
	jne	$LN29@DoFinishQu

; 1322 : 	{
; 1323 : 		PlayerTypes eMostRecentBully = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1324 : 		const char* strCivKey = "Nobody";

	mov	DWORD PTR _strCivKey$222058[esp+1032], OFFSET $SG222059

; 1325 : 		if(eMostRecentBully != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN28@DoFinishQu

; 1326 : 			strCivKey = GET_PLAYER(eMostRecentBully).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strCivKey$222058[esp+1032], eax
$LN28@DoFinishQu:

; 1327 : 
; 1328 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_GIVE_GOLD");

	lea	eax, DWORD PTR $T262881[esp+1032]
	push	OFFSET $SG222062
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 19	; 00000013H
	call	ebp
	lea	ecx, DWORD PTR $T262881[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1329 : 		strMessage << strCivKey;

	mov	ecx, DWORD PTR _strCivKey$222058[esp+1032]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1330 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_GIVE_GOLD");

	lea	edx, DWORD PTR $T262882[esp+1032]
	push	OFFSET $SG222064
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 20	; 00000014H
	call	ebp
	lea	ecx, DWORD PTR $T262882[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN9@DoFinishQu
$LN29@DoFinishQu:

; 1331 : 	}
; 1332 : 
; 1333 : 	// Pledge to protect
; 1334 : 	else if(m_eType == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9
	jne	$LN26@DoFinishQu

; 1335 : 	{
; 1336 : 		PlayerTypes eMostRecentBully = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1337 : 		const char* strCivKey = "Nobody";

	mov	DWORD PTR _strCivKey$222069[esp+1032], OFFSET $SG222070

; 1338 : 		if(eMostRecentBully != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN25@DoFinishQu

; 1339 : 			strCivKey = GET_PLAYER(eMostRecentBully).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strCivKey$222069[esp+1032], eax
$LN25@DoFinishQu:

; 1340 : 
; 1341 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_PLEDGE_TO_PROTECT");

	lea	eax, DWORD PTR $T262883[esp+1032]
	push	OFFSET $SG222073
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 21	; 00000015H
	call	ebp
	lea	ecx, DWORD PTR $T262883[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1342 : 		strMessage << strCivKey;

	mov	ecx, DWORD PTR _strCivKey$222069[esp+1032]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1343 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_PLEDGE_TO_PROTECT");

	lea	edx, DWORD PTR $T262884[esp+1032]
	push	OFFSET $SG222075
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 22	; 00000016H
	call	ebp
	lea	ecx, DWORD PTR $T262884[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN9@DoFinishQu
$LN26@DoFinishQu:

; 1344 : 	}
; 1345 : 
; 1346 : 	// Culture contest
; 1347 : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH
	jne	$LN23@DoFinishQu

; 1348 : 	{
; 1349 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONTEST_CULTURE");

	lea	eax, DWORD PTR $T262885[esp+1032]
	push	OFFSET $SG222079
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 23	; 00000017H
	call	ebp
	lea	ecx, DWORD PTR $T262885[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1350 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONTEST_CULTURE");

	lea	ecx, DWORD PTR $T262886[esp+1032]
	push	OFFSET $SG222081
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 24	; 00000018H
	call	ebp
	lea	ecx, DWORD PTR $T262886[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1351 : 		veNamesToShow = GetContestLeaders();

	lea	edx, DWORD PTR $T262887[esp+1032]
	push	edx
	mov	ecx, esi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
	mov	BYTE PTR __$EHRec$[esp+1040], 25	; 00000019H
	jmp	$LN319@DoFinishQu
$LN23@DoFinishQu:

; 1352 : 	}
; 1353 : 
; 1354 : 	// Faith contest
; 1355 : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH
	jne	$LN21@DoFinishQu

; 1356 : 	{
; 1357 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONTEST_FAITH");

	lea	edx, DWORD PTR $T262888[esp+1032]
	push	OFFSET $SG222086
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 26	; 0000001aH
	call	ebp
	lea	ecx, DWORD PTR $T262888[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1358 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONTEST_FAITH");

	lea	eax, DWORD PTR $T262889[esp+1032]
	push	OFFSET $SG222088
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 27	; 0000001bH
	call	ebp
	lea	ecx, DWORD PTR $T262889[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1359 : 		veNamesToShow = GetContestLeaders();

	lea	ecx, DWORD PTR $T262890[esp+1032]
	push	ecx
	mov	ecx, esi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
	push	eax
	lea	ecx, DWORD PTR _veNamesToShow$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 28	; 0000001cH
	call	??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
	mov	eax, DWORD PTR $T262890[esp+1032]
	lea	edx, DWORD PTR $T262890[esp+1044]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	cmp	eax, edx
	je	$LN9@DoFinishQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	jmp	$LN9@DoFinishQu
$LN21@DoFinishQu:

; 1360 : 	}
; 1361 : 
; 1362 : 	// Techs contest
; 1363 : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	$LN19@DoFinishQu

; 1364 : 	{
; 1365 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_CONTEST_TECHS");

	lea	eax, DWORD PTR $T262891[esp+1032]
	push	OFFSET $SG222093
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 29	; 0000001dH
	call	ebp
	lea	ecx, DWORD PTR $T262891[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1366 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_CONTEST_TECHS");

	lea	ecx, DWORD PTR $T262892[esp+1032]
	push	OFFSET $SG222095
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 30	; 0000001eH
	call	ebp
	lea	ecx, DWORD PTR $T262892[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1367 : 		veNamesToShow = GetContestLeaders();

	lea	edx, DWORD PTR $T262893[esp+1032]
	push	edx
	mov	ecx, esi
	call	?GetContestLeaders@CvMinorCivQuest@@QAE?AV?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@XZ ; CvMinorCivQuest::GetContestLeaders
	mov	BYTE PTR __$EHRec$[esp+1040], 31	; 0000001fH
$LN319@DoFinishQu:
	push	eax
	lea	ecx, DWORD PTR _veNamesToShow$[esp+1036]
	call	??4?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::operator=
	mov	eax, DWORD PTR $T262893[esp+1032]
	lea	ecx, DWORD PTR $T262893[esp+1044]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	cmp	eax, ecx
	je	$LN9@DoFinishQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	jmp	$LN9@DoFinishQu
$LN19@DoFinishQu:

; 1368 : 	}
; 1369 : 
; 1370 : 	// Invest
; 1371 : 	else if(m_eType == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN17@DoFinishQu

; 1372 : 	{
; 1373 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_INVEST");

	lea	edx, DWORD PTR $T262894[esp+1032]
	push	OFFSET $SG222100
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 32	; 00000020H
	call	ebp
	lea	ecx, DWORD PTR $T262894[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1374 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_INVEST");

	lea	eax, DWORD PTR $T262895[esp+1032]
	push	OFFSET $SG222102
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 33	; 00000021H
	call	ebp
	lea	ecx, DWORD PTR $T262895[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN9@DoFinishQu
$LN17@DoFinishQu:

; 1375 : 	}
; 1376 : 
; 1377 : 	// Bully target City-State
; 1378 : 	else if(m_eType == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH
	jne	$LN15@DoFinishQu

; 1379 : 	{
; 1380 : 		PlayerTypes eTargetMinor = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1381 : 		const char* strCivKey = "Nobody";

	mov	DWORD PTR _strCivKey$222107[esp+1032], OFFSET $SG222108

; 1382 : 		if(eTargetMinor != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN14@DoFinishQu

; 1383 : 			strCivKey = GET_PLAYER(eTargetMinor).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strCivKey$222107[esp+1032], eax
$LN14@DoFinishQu:

; 1384 : 
; 1385 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_BULLY_CITY_STATE");

	lea	ecx, DWORD PTR $T262896[esp+1032]
	push	OFFSET $SG222111
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 34	; 00000022H
	call	ebp
	lea	ecx, DWORD PTR $T262896[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1386 : 		strMessage << strCivKey;

	mov	edx, DWORD PTR _strCivKey$222107[esp+1032]
	push	edx
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1387 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_BULLY_CITY_STATE");

	lea	eax, DWORD PTR $T262897[esp+1032]
	push	OFFSET $SG222113
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 35	; 00000023H
	call	ebp
	lea	ecx, DWORD PTR $T262897[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1388 : 		strSummary << strCivKey;

	mov	ecx, DWORD PTR _strCivKey$222107[esp+1032]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN9@DoFinishQu
$LN15@DoFinishQu:

; 1389 : 	}
; 1390 : 
; 1391 : 	// Denounce target Major
; 1392 : 	else if(m_eType == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	$LN12@DoFinishQu

; 1393 : 	{
; 1394 : 		PlayerTypes eTargetMajor = (PlayerTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1395 : 		const char* strCivKey = "Nobody";

	mov	DWORD PTR _strCivKey$222118[esp+1032], OFFSET $SG222119

; 1396 : 		if(eTargetMajor != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN11@DoFinishQu

; 1397 : 			strCivKey = GET_PLAYER(eTargetMajor).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strCivKey$222118[esp+1032], eax
$LN11@DoFinishQu:

; 1398 : 
; 1399 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_DENOUNCE_MAJOR");

	lea	edx, DWORD PTR $T262898[esp+1032]
	push	OFFSET $SG222122
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 36	; 00000024H
	call	ebp
	lea	ecx, DWORD PTR $T262898[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1400 : 		strMessage << strCivKey;

	mov	eax, DWORD PTR _strCivKey$222118[esp+1032]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1401 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_DENOUNCE_MAJOR");

	lea	ecx, DWORD PTR $T262899[esp+1032]
	push	OFFSET $SG222124
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 37	; 00000025H
	call	ebp
	lea	ecx, DWORD PTR $T262899[esp+1032]
$LN321@DoFinishQu:
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1402 : 		strSummary << strCivKey;

	mov	edx, DWORD PTR _strCivKey$222118[esp+1032]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN9@DoFinishQu
$LN12@DoFinishQu:

; 1403 : 	}
; 1404 : 
; 1405 : 	// Spread your religion to us
; 1406 : 	else if(m_eType == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	eax, 16					; 00000010H
	jne	$LN9@DoFinishQu

; 1407 : 	{
; 1408 : 		ReligionTypes eReligion = (ReligionTypes) GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1409 : 		CvString strReligionKey = "Atheism";

	push	OFFSET $SG222130
	lea	ecx, DWORD PTR _strReligionKey$222129[esp+1036]
	mov	DWORD PTR _eReligion$222127[esp+1036], eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString

; 1410 : 		if(eReligion != NO_RELIGION)

	mov	eax, DWORD PTR _eReligion$222127[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 38	; 00000026H
	cmp	eax, -1
	je	SHORT $LN7@DoFinishQu

; 1411 : 		{
; 1412 : 			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	-1
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 1413 : 			if(pReligion != NULL)

	test	eax, eax
	je	SHORT $LN7@DoFinishQu

; 1414 : 			{
; 1415 : 				strReligionKey = pReligion->GetName();

	lea	ecx, DWORD PTR $T262900[esp+1032]
	push	ecx
	mov	ecx, eax
	call	?GetName@CvReligion@@QBE?AVCvString@@XZ	; CvReligion::GetName
	push	eax
	lea	ecx, DWORD PTR _strReligionKey$222129[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 39	; 00000027H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T262900[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 38	; 00000026H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@DoFinishQu:

; 1416 : 			}	
; 1417 : 		}
; 1418 : 
; 1419 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_SPREAD_RELIGION");

	lea	edx, DWORD PTR $T262901[esp+1032]
	push	OFFSET $SG222136
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 40	; 00000028H
	call	ebp
	lea	ecx, DWORD PTR $T262901[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 38	; 00000026H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1420 : 		strMessage << strReligionKey.c_str();

	lea	ecx, DWORD PTR _strReligionKey$222129[esp+1032]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1421 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_SPREAD_RELIGION");

	lea	eax, DWORD PTR $T262903[esp+1032]
	push	OFFSET $SG222139
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 41	; 00000029H
	call	ebp
	lea	ecx, DWORD PTR $T262903[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 38	; 00000026H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1422 : 		strSummary << strReligionKey.c_str();

	lea	ecx, DWORD PTR _strReligionKey$222129[esp+1032]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1423 : 	}

	lea	ecx, DWORD PTR _strReligionKey$222129[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@DoFinishQu:

; 1424 : 
; 1425 : 	// Connect A Trade Route
; 1426 : 	if(m_eType == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	DWORD PTR [esi+8], 17			; 00000011H
	jne	SHORT $LN6@DoFinishQu

; 1427 : 	{
; 1428 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_COMPLETE_TRADE_ROUTE");

	lea	ecx, DWORD PTR $T262905[esp+1032]
	push	OFFSET $SG222143
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 42	; 0000002aH
	call	ebp
	lea	ecx, DWORD PTR $T262905[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1429 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_COMPLETE_TRADE_ROUTE");

	lea	edx, DWORD PTR $T262906[esp+1032]
	push	OFFSET $SG222145
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	mov	BYTE PTR __$EHRec$[esp+1044], 43	; 0000002bH
	call	ebp
	lea	ecx, DWORD PTR $T262906[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN6@DoFinishQu:

; 1430 : 	}
; 1431 : 
; 1432 : 	// Update the UI with the changed data, in case it is open
; 1433 : 	if(m_eAssignedPlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@DoFinishQu

; 1434 : 	{
; 1435 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx
$LN5@DoFinishQu:

; 1436 : 	}
; 1437 : 
; 1438 : 	strMessage << pMinor->getNameKey();

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ebx, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	ebx

; 1439 : 	strMessage << iInfChange;

	mov	eax, DWORD PTR _iInfChange$[esp+1032]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+1036]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 1440 : 	strSummary << pMinor->getNameKey();

	mov	ecx, edi
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+1036]
	call	ebx

; 1441 : 
; 1442 : 	CvString sMessage = strMessage.toUTF8();

	mov	ebx, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strMessage$[esp+1032]
	call	ebx
	test	eax, eax
	jne	SHORT $LN272@DoFinishQu
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN272@DoFinishQu:
	push	eax
	lea	ecx, DWORD PTR _sMessage$[esp+1036]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1443 : 	CvString sSummary = strSummary.toUTF8();

	lea	ecx, DWORD PTR _strSummary$[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 44	; 0000002cH
	call	ebx
	test	eax, eax
	jne	SHORT $LN277@DoFinishQu
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN277@DoFinishQu:
	push	eax
	lea	ecx, DWORD PTR _sSummary$[esp+1036]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1444 : 
; 1445 : 	// This quest involved multiple minors, so grab their names for the notification
; 1446 : 	if(veNamesToShow.size() > 0)

	cmp	DWORD PTR _veNamesToShow$[esp+1036], 0
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	bl, 45					; 0000002dH
	mov	BYTE PTR __$EHRec$[esp+1040], bl
	jbe	$LN4@DoFinishQu

; 1447 : 	{
; 1448 : 		sMessage = sMessage + pMinor->GetMinorCivAI()->GetNamesListAsString(veNamesToShow);

	sub	esp, 272				; 00000110H
	lea	edx, DWORD PTR _veNamesToShow$[esp+1304]
	mov	ecx, esp
	mov	DWORD PTR $T262909[esp+1304], esp
	push	edx
	call	??0?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum PlayerTypes,64,1,297,0>::FStaticVector<enum PlayerTypes,64,1,297,0>
	lea	eax, DWORD PTR $T262910[esp+1304]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+1316], 46	; 0000002eH
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+1316], bl
	call	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
	push	eax
	lea	ecx, DWORD PTR _sMessage$[esp+1036]
	push	ecx
	lea	edx, DWORD PTR $T262911[esp+1040]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+1052], 47	; 0000002fH
	call	ebp
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+1040], 48	; 00000030H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sMessage$[esp+1036]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T262911[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 47	; 0000002fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T262910[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@DoFinishQu:

; 1449 : 	}
; 1450 : 
; 1451 : 	// This quest reward changed our status, so grab that info for the notification
; 1452 : 	if ((!bWasFriends && bNowFriends) || (!bWasAllies && bNowAllies))

	cmp	BYTE PTR _bWasFriends$[esp+1032], 0
	jne	SHORT $LN1@DoFinishQu
	cmp	BYTE PTR _bNowFriends$[esp+1032], 0
	jne	SHORT $LN2@DoFinishQu
$LN1@DoFinishQu:
	cmp	BYTE PTR _bWasAllies$[esp+1032], 0
	jne	$LN3@DoFinishQu
	cmp	BYTE PTR _bNowAllies$[esp+1032], 0
	je	$LN3@DoFinishQu
$LN2@DoFinishQu:

; 1453 : 	{
; 1454 : 		pair<CvString, CvString> statusChangeStrings = pMinor->GetMinorCivAI()->GetStatusChangeNotificationStrings(m_eAssignedPlayer, /*bAdd*/true, bNowFriends, bNowAllies, eOldAlly, eNewAlly);

	mov	eax, DWORD PTR _eNewAlly$[esp+1032]
	mov	ecx, DWORD PTR _eOldAlly$[esp+1032]
	mov	edx, DWORD PTR _bNowAllies$[esp+1032]
	push	eax
	mov	eax, DWORD PTR _bNowFriends$[esp+1036]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	push	eax
	push	1
	push	ecx
	lea	edx, DWORD PTR _statusChangeStrings$222190[esp+1056]
	push	edx
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetStatusChangeNotificationStrings@CvMinorCivAI@@QAE?AU?$pair@VCvString@@V1@@std@@W4PlayerTypes@@_N1100@Z ; CvMinorCivAI::GetStatusChangeNotificationStrings

; 1455 : 		sMessage = sMessage + "[NEWLINE][NEWLINE]" + statusChangeStrings.first;

	push	OFFSET $SG222202
	lea	eax, DWORD PTR _sMessage$[esp+1036]
	push	eax
	lea	ecx, DWORD PTR $T262912[esp+1040]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+1052], 49	; 00000031H
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	lea	edx, DWORD PTR _statusChangeStrings$222190[esp+1044]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T262913[esp+1052]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1064], 50	; 00000032H
	call	ebp
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+1040], 51	; 00000033H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sMessage$[esp+1036]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T262913[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 50	; 00000032H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T262912[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 49	; 00000031H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1456 : 	}

	lea	ecx, DWORD PTR _statusChangeStrings$222190[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], bl
	call	??1?$pair@VCvString@@V1@@std@@QAE@XZ
$LN3@DoFinishQu:

; 1457 : 
; 1458 : 	pMinor->GetMinorCivAI()->AddQuestNotification(sMessage, sSummary, m_eAssignedPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	0
	push	-1
	push	-1
	push	ecx
	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _sSummary$[esp+1076]
	mov	DWORD PTR $T262914[esp+1076], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _sMessage$[esp+1104]
	mov	DWORD PTR $T262915[esp+1104], esp
	mov	ecx, esp
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1116], 52	; 00000034H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+1112], 53	; 00000035H
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+1112], bl
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification

; 1459 : 
; 1460 : 	return true;

	lea	ecx, DWORD PTR _sSummary$[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 44	; 0000002cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _sMessage$[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _veNamesToShow$[esp+1032]
	lea	ecx, DWORD PTR _veNamesToShow$[esp+1044]
	mov	BYTE PTR __$EHRec$[esp+1040], 1
	cmp	eax, ecx
	je	SHORT $LN302@DoFinishQu
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN302@DoFinishQu:
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+1032]
	mov	BYTE PTR __$EHRec$[esp+1040], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+1032]
	mov	DWORD PTR __$EHRec$[esp+1040], -1
	call	esi
	mov	al, 1
$LN48@DoFinishQu:

; 1461 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1032]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 1016				; 000003f8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$2:
	lea	ecx, DWORD PTR _veNamesToShow$[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$3:
	lea	ecx, DWORD PTR $T262865[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$4:
	lea	ecx, DWORD PTR $T262866[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$5:
	lea	ecx, DWORD PTR $T262867[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$6:
	lea	ecx, DWORD PTR $T262868[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$7:
	lea	ecx, DWORD PTR $T262869[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$8:
	lea	ecx, DWORD PTR $T262870[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$9:
	lea	ecx, DWORD PTR $T262871[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$10:
	lea	ecx, DWORD PTR $T262872[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$11:
	lea	ecx, DWORD PTR $T262873[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$12:
	lea	ecx, DWORD PTR $T262874[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$13:
	lea	ecx, DWORD PTR $T262875[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$14:
	lea	ecx, DWORD PTR $T262876[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$15:
	lea	ecx, DWORD PTR $T262877[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$16:
	lea	ecx, DWORD PTR $T262878[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$17:
	lea	ecx, DWORD PTR $T262879[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$18:
	lea	ecx, DWORD PTR $T262880[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$19:
	lea	ecx, DWORD PTR $T262881[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$20:
	lea	ecx, DWORD PTR $T262882[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$21:
	lea	ecx, DWORD PTR $T262883[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$22:
	lea	ecx, DWORD PTR $T262884[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$23:
	lea	ecx, DWORD PTR $T262885[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$24:
	lea	ecx, DWORD PTR $T262886[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$25:
	lea	ecx, DWORD PTR $T262887[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$26:
	lea	ecx, DWORD PTR $T262888[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$27:
	lea	ecx, DWORD PTR $T262889[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$28:
	lea	ecx, DWORD PTR $T262890[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$29:
	lea	ecx, DWORD PTR $T262891[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$30:
	lea	ecx, DWORD PTR $T262892[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$31:
	lea	ecx, DWORD PTR $T262893[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$32:
	lea	ecx, DWORD PTR $T262894[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$33:
	lea	ecx, DWORD PTR $T262895[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$34:
	lea	ecx, DWORD PTR $T262896[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$35:
	lea	ecx, DWORD PTR $T262897[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$36:
	lea	ecx, DWORD PTR $T262898[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$37:
	lea	ecx, DWORD PTR $T262899[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$38:
	lea	ecx, DWORD PTR _strReligionKey$222129[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$39:
	lea	ecx, DWORD PTR $T262900[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$40:
	lea	ecx, DWORD PTR $T262901[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$41:
	lea	ecx, DWORD PTR $T262903[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$42:
	lea	ecx, DWORD PTR $T262905[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$43:
	lea	ecx, DWORD PTR $T262906[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$44:
	lea	ecx, DWORD PTR _sMessage$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$45:
	lea	ecx, DWORD PTR _sSummary$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$46:
	mov	ecx, DWORD PTR $T262909[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$47:
	lea	ecx, DWORD PTR $T262910[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$48:
	lea	ecx, DWORD PTR $T262911[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$49:
	lea	ecx, DWORD PTR _statusChangeStrings$222190[ebp]
	jmp	??1?$pair@VCvString@@V1@@std@@QAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$50:
	lea	ecx, DWORD PTR $T262912[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$51:
	lea	ecx, DWORD PTR $T262913[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$52:
	mov	ecx, DWORD PTR $T262914[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ$53:
	mov	ecx, DWORD PTR $T262915[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ ENDP		; CvMinorCivQuest::DoFinishQuest
PUBLIC	?ResetQuestList@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::ResetQuestList
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?ResetQuestList@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResetQuestList@CvMinorCivAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ResetQuestList@CvMinorCivAI@@QAEXXZ$1
__ehfuncinfo$?ResetQuestList@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ResetQuestList@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?ResetQuestList@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
$T263656 = -176						; size = 4
$T263663 = -172						; size = 4
_vQuestList$222355 = -168				; size = 156
__$EHRec$ = -12						; size = 12
?ResetQuestList@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::ResetQuestList, COMDAT
; _this$ = ecx

; 1708 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ResetQuestList@CvMinorCivAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 1709 : 	//antonjs: todo: this is called when PlayerTypes is -1, why? does it cause inefficiency or unused memory?
; 1710 : 
; 1711 : 	for(uint iPlayerEntry = 0; iPlayerEntry < m_QuestsGiven.size(); iPlayerEntry++)

	mov	eax, DWORD PTR [ecx+3332]
	sub	esp, 164				; 000000a4H
	push	ebx
	push	ebp
	xor	ebx, ebx
	push	esi
	xor	edx, edx
	push	edi
	cmp	eax, ebx
	jbe	SHORT $LN4@ResetQuest
	xor	esi, esi
	npad	1
$LL6@ResetQuest:

; 1712 : 	{
; 1713 : 		m_QuestsGiven[iPlayerEntry].clear();

	mov	eax, DWORD PTR [ecx+3328]
	add	eax, esi
	inc	edx
	mov	DWORD PTR [eax+4], ebx
	add	esi, 156				; 0000009cH
	cmp	edx, DWORD PTR [ecx+3332]
	jb	SHORT $LL6@ResetQuest
$LN4@ResetQuest:

; 1714 : 	}
; 1715 : 
; 1716 : 	m_QuestsGiven.clear();

	mov	eax, DWORD PTR [ecx+3332]
	mov	edi, DWORD PTR [ecx+3328]
	lea	esi, DWORD PTR [ecx+3328]
	cmp	eax, ebx
	jbe	SHORT $LN29@ResetQuest
	mov	ebp, eax
$LL31@ResetQuest:
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	je	SHORT $LN40@ResetQuest
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN40@ResetQuest:
	add	edi, 156				; 0000009cH
	sub	ebp, 1
	jne	SHORT $LL31@ResetQuest
$LN29@ResetQuest:
	mov	DWORD PTR [esi+4], ebx

; 1719 : 	{
; 1720 : 		QuestListForPlayer vQuestList;
; 1721 : 		m_QuestsGiven.push_back(vQuestList);

	mov	DWORD PTR $T263663[esp+192], esi
	mov	ebp, 22					; 00000016H
	mov	edi, 5
$LL3@ResetQuest:
	lea	edx, DWORD PTR _vQuestList$222355[esp+204]
	mov	DWORD PTR _vQuestList$222355[esp+196], ebx
	mov	DWORD PTR _vQuestList$222355[esp+200], edi
	mov	DWORD PTR _vQuestList$222355[esp+192], edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+200], ebx
	mov	BYTE PTR [esi+3444], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN65@ResetQuest
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@V?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<CvMinorCivQuest,5,0,297,0>,22,0,297,0>::GrowSize
$LN65@ResetQuest:
	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 156				; 0000009cH
	add	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T263656[esp+192], ecx
	mov	BYTE PTR __$EHRec$[esp+200], 1
	je	SHORT $LN68@ResetQuest
	lea	eax, DWORD PTR _vQuestList$222355[esp+192]
	push	eax
	call	??0?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::FStaticVector<CvMinorCivQuest,5,0,297,0>
$LN68@ResetQuest:

; 1722 : 	}

	mov	eax, DWORD PTR _vQuestList$222355[esp+192]
	inc	DWORD PTR [esi+4]
	lea	ecx, DWORD PTR _vQuestList$222355[esp+204]
	mov	DWORD PTR __$EHRec$[esp+200], -1
	cmp	eax, ecx
	je	SHORT $LN2@ResetQuest
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN2@ResetQuest:

; 1717 : 
; 1718 : 	for(int iNewEntry = 0; iNewEntry < MAX_MAJOR_CIVS; iNewEntry++)

	sub	ebp, 1
	jne	SHORT $LL3@ResetQuest

; 1723 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+192]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 176				; 000000b0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResetQuestList@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _vQuestList$222355[ebp]
	jmp	??1?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvMinorCivQuest,5,0,297,0>::~FStaticVector<CvMinorCivQuest,5,0,297,0>
__unwindfunclet$?ResetQuestList@CvMinorCivAI@@QAEXXZ$1:
	mov	eax, DWORD PTR $T263663[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR $T263663[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T263656[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?ResetQuestList@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ResetQuestList@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResetQuestList@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::ResetQuestList
PUBLIC	?Read@CvMinorCivAI@@QAEXAAVFDataStream@@@Z	; CvMinorCivAI::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvMinorCivAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iQuestLoop$222410 = -60				; size = 4
_iQuestEntriesToRead$222408 = -56			; size = 4
tv1260 = -52						; size = 4
_v$264060 = -48						; size = 4
_uiVersion$264053 = -44					; size = 4
_this$ = -40						; size = 4
_uiVersion$ = -36					; size = 4
tv612 = -32						; size = 4
_tempQuest$222409 = -28					; size = 28
_v$263768 = 8						; size = 4
_v$263759 = 8						; size = 4
_iPlayerLoop$222404 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvMinorCivAI@@QAEXAAVFDataStream@@@Z PROC		; CvMinorCivAI::Read, COMDAT
; _this$ = ecx

; 1727 : {

	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp

; 1728 : 	// Version number to maintain backwards compatibility
; 1729 : 	uint uiVersion;
; 1730 : 	kStream >> uiVersion;

	mov	ebp, DWORD PTR _kStream$[esp+64]
	push	esi
	push	edi
	mov	esi, ecx
	lea	eax, DWORD PTR _uiVersion$[esp+76]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _this$[esp+80], esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1731 : 
; 1732 : 	kStream >> m_ePersonality;

	lea	ecx, DWORD PTR _v$263759[esp+72]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	edx, DWORD PTR _v$263759[esp+72]

; 1733 : 	kStream >> m_eStatus;

	lea	eax, DWORD PTR _v$263768[esp+72]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR [esi+8], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	ecx, DWORD PTR _v$263768[esp+72]

; 1734 : 	kStream >> m_eUniqueUnit;

	lea	edx, DWORD PTR [esi+16]
	push	edx
	push	ebp
	mov	DWORD PTR [esi+12], ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 1735 : 
; 1736 : 	kStream >> m_iTurnsSinceThreatenedByBarbarians;

	lea	eax, DWORD PTR [esi+20]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1737 : 
; 1738 : 	kStream >> m_iGlobalQuestCountdown;

	lea	ecx, DWORD PTR [esi+24]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1739 : 
; 1740 : 	kStream >> m_eAlly;

	lea	edx, DWORD PTR [esi+2012]
	push	edx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 1741 : 
; 1742 : 	kStream >> m_iTurnAllied;

	lea	eax, DWORD PTR [esi+2016]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1743 : 
; 1744 : 	kStream >> m_eMajorBoughtOutBy;

	lea	ecx, DWORD PTR [esi+2020]
	push	ecx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 1745 : 
; 1746 : 	kStream >> m_abWarQuestAgainstMajor;

	xor	edi, edi
$LL27@Read:
	lea	edx, DWORD PTR [esi+edi+28]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL27@Read

; 1747 : 
; 1748 : 	kStream >> m_aaiNumEnemyUnitsLeftToKillByMajor;

	lea	eax, DWORD PTR [esi+52]
	push	eax
	push	ebp
	call	??$?5$$BY0BG@H$0BG@@@YAAAVFDataStream@@AAV0@AAY1BG@BG@H@Z ; operator>><int [22],22>
	add	esp, 8

; 1749 : 
; 1750 : 	kStream >> m_abRouteConnectionEstablished;

	xor	edi, edi
	npad	9
$LL34@Read:
	lea	ecx, DWORD PTR [esi+edi+1988]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL34@Read

; 1751 : 
; 1752 : 	kStream >> m_aiFriendshipWithMajorTimes100;

	lea	edi, DWORD PTR [esi+2024]
	mov	ebx, 22					; 00000016H
$LL41@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL41@Read

; 1753 : 
; 1754 : 	kStream >> m_aiAngerFreeIntrusionCounter;

	lea	edi, DWORD PTR [esi+2112]
	mov	ebx, 22					; 00000016H
	npad	5
$LL48@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL48@Read

; 1755 : 
; 1756 : 	kStream >> m_aiPlayerQuests;

	lea	edi, DWORD PTR [esi+2200]
	mov	ebx, 22					; 00000016H
	npad	5
$LL55@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL55@Read

; 1757 : 	kStream >> m_aiQuestData1;

	lea	edi, DWORD PTR [esi+2288]
	mov	ebx, 22					; 00000016H
	npad	5
$LL62@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL62@Read

; 1758 : 	kStream >> m_aiQuestData2;

	lea	edi, DWORD PTR [esi+2376]
	mov	ebx, 22					; 00000016H
	npad	5
$LL69@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL69@Read

; 1759 : 	kStream >> m_aiQuestCountdown;

	lea	edi, DWORD PTR [esi+2464]
	mov	ebx, 22					; 00000016H
	npad	5
$LL76@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL76@Read

; 1760 : 	kStream >> m_aiUnitSpawnCounter;

	lea	edi, DWORD PTR [esi+2552]
	mov	ebx, 22					; 00000016H
	npad	5
$LL83@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL83@Read

; 1761 : 
; 1762 : 	kStream >> m_aiNumUnitsGifted;

	lea	edi, DWORD PTR [esi+2640]
	mov	ebx, 22					; 00000016H
	npad	5
$LL90@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL90@Read

; 1763 : 
; 1764 : 	kStream >> m_aiNumGoldGifted;

	lea	edi, DWORD PTR [esi+2728]
	mov	ebx, 22					; 00000016H
	npad	5
$LL97@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL97@Read

; 1765 : 
; 1766 : 	kStream >> m_aiTurnLastBullied;

	lea	edi, DWORD PTR [esi+2816]
	mov	ebx, 22					; 00000016H
	npad	5
$LL104@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL104@Read

; 1767 : 
; 1768 : 	kStream >> m_aiTurnLastPledged;

	lea	edi, DWORD PTR [esi+2904]
	mov	ebx, 22					; 00000016H
	npad	5
$LL111@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL111@Read

; 1769 : 	kStream >> m_aiTurnLastBrokePledge;

	lea	edi, DWORD PTR [esi+2992]
	mov	ebx, 22					; 00000016H
	npad	5
$LL118@Read:
	push	edi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL118@Read

; 1770 : 
; 1771 : 	kStream >> m_abUnitSpawningDisabled;

	xor	edi, edi
$LL125@Read:
	lea	edx, DWORD PTR [esi+edi+3080]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL125@Read

; 1772 : 	kStream >> m_abMajorIntruding;

	xor	edi, edi
	npad	7
$LL132@Read:
	lea	eax, DWORD PTR [esi+edi+3102]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL132@Read

; 1773 : 	kStream >> m_abEverFriends;

	xor	edi, edi
	npad	9
$LL139@Read:
	lea	ecx, DWORD PTR [esi+edi+3124]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL139@Read

; 1774 : 
; 1775 : 	kStream >> m_abPledgeToProtect;

	xor	edi, edi
	npad	9
$LL146@Read:
	lea	edx, DWORD PTR [esi+edi+3146]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 22					; 00000016H
	jb	SHORT $LL146@Read

; 1776 : 
; 1777 : 	kStream >> m_abPermanentWar;

	xor	edi, edi
	npad	9
$LL153@Read:
	lea	eax, DWORD PTR [esi+edi+3168]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 80					; 00000050H
	jb	SHORT $LL153@Read

; 1778 : 
; 1779 : 	kStream >> m_abWaryOfTeam;

	xor	edi, edi
	npad	9
$LL160@Read:
	lea	ecx, DWORD PTR [esi+edi+3248]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	edi
	cmp	edi, 80					; 00000050H
	jb	SHORT $LL160@Read

; 1780 : 
; 1781 : 	// List of quests given
; 1782 : 	ResetQuestList();

	mov	ecx, esi
	call	?ResetQuestList@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::ResetQuestList
	xor	edi, edi

; 1783 : 
; 1784 : 	int iPlayerEntriesToRead;
; 1785 : 	//antonjs: consider: change this; always read in iPlayerEntriesToRead
; 1786 : 	iPlayerEntriesToRead = MAX_MAJOR_CIVS;
; 1787 : 
; 1788 : 	for(int iPlayerLoop = 0; iPlayerLoop < iPlayerEntriesToRead; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$222404[esp+72], 0
	mov	DWORD PTR tv1260[esp+76], edi
	npad	6
$LL251@Read:

; 1789 : 	{
; 1790 : 		int iQuestEntriesToRead;
; 1791 : 		kStream >> iQuestEntriesToRead;

	lea	edx, DWORD PTR _iQuestEntriesToRead$222408[esp+76]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1792 : 		CvMinorCivQuest tempQuest;

	or	eax, -1

; 1793 : 		for(int iQuestLoop = 0; iQuestLoop < iQuestEntriesToRead; iQuestLoop++)

	cmp	DWORD PTR _iQuestEntriesToRead$222408[esp+76], 0
	mov	DWORD PTR _tempQuest$222409[esp+76], eax
	mov	DWORD PTR _tempQuest$222409[esp+80], eax
	mov	DWORD PTR _tempQuest$222409[esp+84], eax
	mov	DWORD PTR _tempQuest$222409[esp+88], eax
	mov	DWORD PTR _tempQuest$222409[esp+92], eax
	mov	DWORD PTR _tempQuest$222409[esp+96], eax
	mov	BYTE PTR _tempQuest$222409[esp+100], 0
	mov	DWORD PTR _iQuestLoop$222410[esp+76], 0
	jle	$LN5@Read
	npad	1
$LL250@Read:

; 1794 : 		{
; 1795 : 			kStream >> tempQuest;

	lea	eax, DWORD PTR _uiVersion$264053[esp+76]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _v$264060[esp+76]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	edx, DWORD PTR _v$264060[esp+76]
	lea	eax, DWORD PTR _tempQuest$222409[esp+88]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _tempQuest$222409[esp+88], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _tempQuest$222409[esp+92]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	edx, DWORD PTR _tempQuest$222409[esp+96]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	cmp	DWORD PTR _uiVersion$264053[esp+76], 2
	jb	SHORT $LN170@Read
	lea	eax, DWORD PTR _tempQuest$222409[esp+100]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	jmp	SHORT $LN169@Read
$LN170@Read:
	mov	BYTE PTR _tempQuest$222409[esp+100], 0
$LN169@Read:

; 1796 : 
; 1797 : 			tempQuest.m_eMinor = GetPlayer()->GetID();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+44]

; 1798 : 			tempQuest.m_eAssignedPlayer = (PlayerTypes) iPlayerLoop;
; 1799 : 
; 1800 : 			m_QuestsGiven[iPlayerLoop].push_back(tempQuest);

	mov	ebx, DWORD PTR [esi+3328]
	mov	eax, DWORD PTR _iPlayerLoop$222404[esp+72]
	add	ebx, edi
	mov	DWORD PTR _tempQuest$222409[esp+76], edx
	mov	DWORD PTR _tempQuest$222409[esp+80], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	BYTE PTR [ebx+152], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN195@Read
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::GrowSize
$LN195@Read:
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN198@Read
	mov	ecx, 7
	lea	esi, DWORD PTR _tempQuest$222409[esp+76]
	mov	edi, eax
	rep movsd
	mov	esi, DWORD PTR _this$[esp+76]
	mov	edi, DWORD PTR tv1260[esp+76]
$LN198@Read:
	mov	eax, DWORD PTR _iQuestLoop$222410[esp+76]
	inc	DWORD PTR [ebx+4]
	inc	eax
	cmp	eax, DWORD PTR _iQuestEntriesToRead$222408[esp+76]
	mov	DWORD PTR _iQuestLoop$222410[esp+76], eax
	jl	$LL250@Read
$LN5@Read:

; 1783 : 
; 1784 : 	int iPlayerEntriesToRead;
; 1785 : 	//antonjs: consider: change this; always read in iPlayerEntriesToRead
; 1786 : 	iPlayerEntriesToRead = MAX_MAJOR_CIVS;
; 1787 : 
; 1788 : 	for(int iPlayerLoop = 0; iPlayerLoop < iPlayerEntriesToRead; iPlayerLoop++)

	inc	DWORD PTR _iPlayerLoop$222404[esp+72]
	add	edi, 156				; 0000009cH
	cmp	edi, 3432				; 00000d68H
	mov	DWORD PTR tv1260[esp+76], edi
	jl	$LL251@Read

; 1801 : 		}
; 1802 : 	}
; 1803 : 	CvAssertMsg(m_QuestsGiven.size() == MAX_MAJOR_CIVS, "Number of entries in minor's quest list does not match MAX_MAJOR_CIVS when read from memory!");
; 1804 : 
; 1805 : 	kStream >> m_bDisableNotifications;

	add	esi, 6864				; 00001ad0H
	push	esi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1806 : }

	add	esp, 60					; 0000003cH
	ret	4
?Read@CvMinorCivAI@@QAEXAAVFDataStream@@@Z ENDP		; CvMinorCivAI::Read
_TEXT	ENDS
PUBLIC	?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z ; CvMinorCivAI::DoThreateningBarbKilled
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$2
__ehfuncinfo$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
$T264162 = -180						; size = 4
$T264161 = -176						; size = 4
_strSummary$223128 = -172				; size = 80
_strMessage$223124 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_eKillingPlayer$ = 8					; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z PROC ; CvMinorCivAI::DoThreateningBarbKilled, COMDAT
; _this$ = ecx

; 2698 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2699 : 	CvAssertMsg(eKillingPlayer >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 2700 : 	CvAssertMsg(eKillingPlayer < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 2701 : 
; 2702 : 	if (IsThreateningBarbariansEventActiveForPlayer(eKillingPlayer))

	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [eax+2256]
	push	edi
	test	al, al
	je	$LN1@DoThreaten
	mov	edi, DWORD PTR _eKillingPlayer$[esp+192]
	push	edi
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	je	$LN1@DoThreaten
	push	edi
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	jne	$LN1@DoThreaten
	mov	ecx, esi
	call	?GetNumThreateningBarbarians@CvMinorCivAI@@QAEHXZ ; CvMinorCivAI::GetNumThreateningBarbarians
	test	eax, eax
	jle	$LN1@DoThreaten

; 2703 : 	{
; 2704 : 		ChangeFriendshipWithMajor(eKillingPlayer, /*12*/ GC.getFRIENDSHIP_PER_BARB_KILLED());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3164
	imul	eax, 100				; 00000064H
	test	eax, eax
	je	SHORT $LN25@DoThreaten
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN32@DoThreaten
	mov	ecx, DWORD PTR [esi+edi*4+2024]
	jmp	SHORT $LN34@DoThreaten
$LN32@DoThreaten:
	xor	ecx, ecx
$LN34@DoThreaten:
	push	0
	add	ecx, eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN25@DoThreaten:

; 2705 : 
; 2706 : 		ChangeAngerFreeIntrusionCounter(eKillingPlayer, 5);

	cmp	edi, 21					; 00000015H
	ja	SHORT $LN38@DoThreaten
	mov	eax, DWORD PTR [esi+edi*4+2112]
	jmp	SHORT $LN40@DoThreaten
$LN38@DoThreaten:
	xor	eax, eax
$LN40@DoThreaten:
	cmp	edi, 21					; 00000015H
	ja	SHORT $LN42@DoThreaten
	add	eax, 5
	mov	DWORD PTR [esi+edi*4+2112], eax
$LN42@DoThreaten:

; 2707 : 
; 2708 : 		Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BARB_KILLED");

	mov	ebp, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR _strMessage$223124[esp+196]
	push	OFFSET $SG223126
	push	eax
	call	ebp
	add	esp, 8

; 2709 : 		strMessage << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+204], 0
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	ebx, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$223124[esp+200]
	call	ebx

; 2710 : 		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SM_MINOR_BARB_KILLED");

	lea	ecx, DWORD PTR _strSummary$223128[esp+196]
	push	OFFSET $SG223130
	push	ecx
	call	ebp
	add	esp, 8

; 2711 : 		strSummary << GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223128[esp+200]
	call	ebx

; 2712 : 
; 2713 : 		AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), eKillingPlayer, iX, iY);

	mov	edx, DWORD PTR _iY$[esp+192]
	mov	eax, DWORD PTR _iX$[esp+192]
	push	edx
	push	eax
	push	edi
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strSummary$223128[esp+208]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T264161[esp+236], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN57@DoThreaten
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN57@DoThreaten:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$223124[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 2
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T264162[esp+264], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN62@DoThreaten
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN62@DoThreaten:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+272], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification

; 2714 : 	}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$223128[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$223124[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	call	esi
$LN1@DoThreaten:

; 2715 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 180				; 000000b4H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _strMessage$223124[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$1:
	lea	ecx, DWORD PTR _strSummary$223128[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z$2:
	mov	ecx, DWORD PTR $T264161[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoThreateningBarbKilled@CvMinorCivAI@@QAEXW4PlayerTypes@@HH@Z ENDP ; CvMinorCivAI::DoThreateningBarbKilled
PUBLIC	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
EXTRN	?LogMinorCivQuestFinished@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z:PROC ; CvDiplomacyAI::LogMinorCivQuestFinished
; Function compile flags: /Ogtpy
;	COMDAT ?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_bCompleted$224509 = -9					; size = 1
_iOldFriendshipTimes100$224508 = -8			; size = 4
tv261 = -4						; size = 4
_bCheckAllQuests$ = 8					; size = 1
_ePlayer$ = 8						; size = 4
_eSpecifyQuestType$ = 12				; size = 4
?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::DoCompletedQuestsForPlayer, COMDAT
; _this$ = ecx

; 3213 : {

	sub	esp, 12					; 0000000cH
	push	ebp

; 3214 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3215 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3216 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	ebp, DWORD PTR _ePlayer$[esp+12]
	push	edi
	mov	edi, ecx
	cmp	ebp, 21					; 00000015H
	ja	$LN9@DoComplete

; 3217 : 
; 3218 : 	bool bCheckAllQuests = true;
; 3219 : 	if (eSpecifyQuestType > NO_MINOR_CIV_QUEST_TYPE && eSpecifyQuestType < NUM_MINOR_CIV_QUEST_TYPES)

	cmp	DWORD PTR _eSpecifyQuestType$[esp+16], 17 ; 00000011H
	mov	BYTE PTR _bCheckAllQuests$[esp+16], 1
	ja	SHORT $LN8@DoComplete

; 3220 : 		bCheckAllQuests = false;

	mov	BYTE PTR _bCheckAllQuests$[esp+16], 0
$LN8@DoComplete:

; 3221 : 
; 3222 : 	QuestListForPlayer::iterator itr_quest;
; 3223 : 	for (itr_quest = m_QuestsGiven[ePlayer].begin(); itr_quest != m_QuestsGiven[ePlayer].end(); itr_quest++)

	mov	eax, DWORD PTR [edi+3328]
	push	ebx
	mov	ebx, ebp
	imul	ebx, 156				; 0000009cH
	mov	ecx, DWORD PTR [eax+ebx+4]
	add	eax, ebx
	push	esi
	mov	esi, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	eax, esi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv261[esp+28], ebx
	cmp	esi, ecx
	je	$LN59@DoComplete
$LL58@DoComplete:

; 3224 : 	{
; 3225 : 		if (bCheckAllQuests || itr_quest->GetType() == eSpecifyQuestType)

	cmp	BYTE PTR _bCheckAllQuests$[esp+24], 0
	jne	SHORT $LN3@DoComplete
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, DWORD PTR _eSpecifyQuestType$[esp+24]
	jne	$LN6@DoComplete
$LN3@DoComplete:

; 3226 : 		{
; 3227 : 			if (itr_quest->IsComplete())

	mov	ecx, esi
	call	?IsComplete@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsComplete
	test	al, al
	je	$LN6@DoComplete

; 3228 : 			{
; 3229 : 				int iOldFriendshipTimes100 = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	push	ebp
	mov	ecx, edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN23@DoComplete
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	jmp	SHORT $LN61@DoComplete
$LN23@DoComplete:
	mov	eax, DWORD PTR [edi+ebp*4+2024]
$LN61@DoComplete:

; 3230 : 				bool bCompleted = itr_quest->DoFinishQuest();

	mov	ecx, esi
	mov	DWORD PTR _iOldFriendshipTimes100$224508[esp+28], eax
	call	?DoFinishQuest@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::DoFinishQuest

; 3231 : 				int iNewFriendshipTimes100 = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	push	ebp
	mov	ecx, edi
	mov	BYTE PTR _bCompleted$224509[esp+32], al
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN34@DoComplete
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ebx, 100				; 00000064H
	jmp	SHORT $LN37@DoComplete
$LN34@DoComplete:
	mov	ebx, DWORD PTR [edi+ebp*4+2024]
$LN37@DoComplete:

; 3232 : 				
; 3233 : 				if (bCompleted)

	cmp	BYTE PTR _bCompleted$224509[esp+28], 0
	je	SHORT $LN57@DoComplete

; 3234 : 				{
; 3235 : 					GET_PLAYER(ePlayer).GetDiplomacyAI()->LogMinorCivQuestFinished(GetPlayer()->GetID(), iOldFriendshipTimes100, iNewFriendshipTimes100, itr_quest->GetType());

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	eax, DWORD PTR _iOldFriendshipTimes100$224508[esp+32]
	push	ebx
	push	eax
	push	edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivQuestFinished@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z ; CvDiplomacyAI::LogMinorCivQuestFinished
$LN57@DoComplete:
	mov	ebx, DWORD PTR tv261[esp+28]
$LN6@DoComplete:

; 3221 : 
; 3222 : 	QuestListForPlayer::iterator itr_quest;
; 3223 : 	for (itr_quest = m_QuestsGiven[ePlayer].begin(); itr_quest != m_QuestsGiven[ePlayer].end(); itr_quest++)

	mov	eax, DWORD PTR [edi+3328]
	mov	ecx, DWORD PTR [eax+ebx+4]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	esi, 28					; 0000001cH
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	esi, ecx
	jne	$LL58@DoComplete
$LN59@DoComplete:
	pop	esi
	pop	ebx
$LN9@DoComplete:
	pop	edi
	pop	ebp

; 3236 : 				}
; 3237 : 			}
; 3238 : 		}
; 3239 : 	}
; 3240 : }

	add	esp, 12					; 0000000cH
	ret	8
?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::DoCompletedQuestsForPlayer
_TEXT	ENDS
PUBLIC	?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ	; CvMinorCivAI::GetNumActiveGlobalQuests
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ$0
__ehfuncinfo$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ
_TEXT	SEGMENT
_iPlayerLoop$224918 = -44				; size = 4
$T264861 = -40						; size = 4
$T264400 = -40						; size = 4
$T264401 = -36						; size = 8
_setGlobalQuests$ = -28					; size = 12
__$EHRec$ = -12						; size = 12
?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ PROC	; CvMinorCivAI::GetNumActiveGlobalQuests, COMDAT
; _this$ = ecx

; 4195 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 4196 : 	//antonjs: todo: reevaluate this for efficiency and for use of std::set
; 4197 : 
; 4198 : 	std::set<MinorCivQuestTypes> setGlobalQuests;

	lea	ecx, DWORD PTR _setGlobalQuests$[esp+64]
	call	?_Buynode@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::_Buynode
	mov	DWORD PTR _setGlobalQuests$[esp+68], eax
	mov	BYTE PTR [eax+17], 1
	mov	eax, DWORD PTR _setGlobalQuests$[esp+68]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _setGlobalQuests$[esp+68]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _setGlobalQuests$[esp+68]
	xor	esi, esi
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR _setGlobalQuests$[esp+72], esi
	mov	DWORD PTR __$EHRec$[esp+72], esi

; 4199 : 
; 4200 : 	for(uint iPlayerLoop = 0; iPlayerLoop < m_QuestsGiven.size(); iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$224918[esp+64], esi
	cmp	DWORD PTR [ebx+3332], esi
	jbe	SHORT $LN5@GetNumActi@3
$LN7@GetNumActi@3:

; 4201 : 	{
; 4202 : 		for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[iPlayerLoop].size(); iQuestLoop++)

	mov	eax, DWORD PTR [ebx+3328]
	xor	edi, edi
	cmp	DWORD PTR [esi+eax+4], edi
	jbe	SHORT $LN6@GetNumActi@3
	xor	ebp, ebp
	npad	1
$LL4@GetNumActi@3:

; 4203 : 		{
; 4204 : 			if(IsGlobalQuest(m_QuestsGiven[iPlayerLoop][iQuestLoop].GetType()))

	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+ebp+8]
	cmp	eax, 1
	je	SHORT $LN122@GetNumActi@3
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN122@GetNumActi@3
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN122@GetNumActi@3
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN122@GetNumActi@3
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN3@GetNumActi@3
$LN122@GetNumActi@3:

; 4205 : 			{
; 4206 : 				setGlobalQuests.insert(m_QuestsGiven[iPlayerLoop][iQuestLoop].GetType());

	lea	ecx, DWORD PTR $T264400[esp+64]
	push	ecx
	lea	edx, DWORD PTR $T264401[esp+68]
	push	edx
	lea	ecx, DWORD PTR _setGlobalQuests$[esp+72]
	mov	DWORD PTR $T264400[esp+72], eax
	call	?insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::insert
$LN3@GetNumActi@3:
	mov	eax, DWORD PTR [ebx+3328]
	inc	edi
	add	ebp, 28					; 0000001cH
	cmp	edi, DWORD PTR [esi+eax+4]
	jb	SHORT $LL4@GetNumActi@3
$LN6@GetNumActi@3:

; 4199 : 
; 4200 : 	for(uint iPlayerLoop = 0; iPlayerLoop < m_QuestsGiven.size(); iPlayerLoop++)

	mov	eax, DWORD PTR _iPlayerLoop$224918[esp+64]
	inc	eax
	add	esi, 156				; 0000009cH
	mov	DWORD PTR _iPlayerLoop$224918[esp+64], eax
	cmp	eax, DWORD PTR [ebx+3332]
	jb	SHORT $LN7@GetNumActi@3
$LN5@GetNumActi@3:

; 4207 : 			}
; 4208 : 		}
; 4209 : 	}
; 4210 : 
; 4211 : 	return setGlobalQuests.size();

	mov	eax, DWORD PTR _setGlobalQuests$[esp+68]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _setGlobalQuests$[esp+72]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T264861[esp+72]
	push	eax
	lea	ecx, DWORD PTR _setGlobalQuests$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
	mov	ecx, DWORD PTR _setGlobalQuests$[esp+68]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete

; 4212 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	add	esp, 4
	pop	edi
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ$0:
	lea	ecx, DWORD PTR _setGlobalQuests$[ebp]
	jmp	??1?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ
__ehhandler$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ:
	mov	eax, OFFSET __ehfuncinfo$?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ ENDP	; CvMinorCivAI::GetNumActiveGlobalQuests
PUBLIC	?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z ; CvMinorCivAI::DoTestSeedGlobalQuestCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z
_TEXT	SEGMENT
_bForceSeed$ = 8					; size = 1
?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z PROC ; CvMinorCivAI::DoTestSeedGlobalQuestCountdown, COMDAT
; _this$ = ecx

; 4319 : 	if(!bForceSeed)

	cmp	BYTE PTR _bForceSeed$[esp-4], 0
	push	edi
	mov	edi, ecx
	jne	SHORT $LN4@DoTestSeed@2

; 4320 : 	{
; 4321 : 		// Only seed if there is a potential spot for a global quest
; 4322 : 		if(GetNumActiveGlobalQuests() >= GetMaxActiveGlobalQuests())

	call	?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetNumActiveGlobalQuests
	cmp	eax, 1
	jge	$LN35@DoTestSeed@2

; 4323 : 		{
; 4324 : 			return;
; 4325 : 		}
; 4326 : 
; 4327 : 		// Only seed if the countdown is not already active
; 4328 : 		if(GetGlobalQuestCountdown() > 0)

	cmp	DWORD PTR [edi+24], 0
	jg	$LN35@DoTestSeed@2
$LN4@DoTestSeed@2:

; 4329 : 		{
; 4330 : 			return;
; 4331 : 		}
; 4332 : 	}
; 4333 : 
; 4334 : 	int iNumTurns = 0;
; 4335 : 
; 4336 : 	// Quests are now available for the first time?
; 4337 : 	if(GC.getGame().getElapsedGameTurns() == GetFirstPossibleTurnForGlobalQuests())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3192
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jne	SHORT $LN3@DoTestSeed@2

; 4338 : 	{
; 4339 : 		int iRand = /*20*/ GC.getMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3196

; 4340 : 		iNumTurns += GC.getGame().getJonRandNum(iRand, "Random # of turns for Minor Civ global quest counter - first time.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225006
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	esi, eax

; 4341 : 	}
; 4342 : 	else

	jmp	SHORT $LN2@DoTestSeed@2
$LN3@DoTestSeed@2:

; 4343 : 	{
; 4344 : 		iNumTurns += /*40*/ GC.getMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN();
; 4345 : 
; 4346 : 		int iRand = /*25*/ GC.getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN();
; 4347 : 		if(GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)

	cmp	DWORD PTR [edi+8], 2
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3200
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3204
	jne	SHORT $LN1@DoTestSeed@2

; 4348 : 		{
; 4349 : 			iRand *= /*200*/ GC.getMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3208
	imul	ecx, eax

; 4350 : 			iRand /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN1@DoTestSeed@2:

; 4351 : 		}
; 4352 : 		iNumTurns += GC.getGame().getJonRandNum(iRand, "Random # of turns for Minor Civ global quest counter.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225010
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	esi, eax
$LN2@DoTestSeed@2:

; 4353 : 	}
; 4354 : 
; 4355 : 	// Modify for Game Speed
; 4356 : 	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getGreatPeoplePercent
	mov	ecx, eax
	imul	ecx, esi

; 4357 : 	iNumTurns /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 4358 : 
; 4359 : 	SetGlobalQuestCountdown(iNumTurns);

	mov	DWORD PTR [edi+24], ecx
	pop	esi
$LN35@DoTestSeed@2:
	pop	edi

; 4360 : }

	ret	4
?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z ENDP ; CvMinorCivAI::DoTestSeedGlobalQuestCountdown
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >
_TEXT	ENDS
PUBLIC	??_7CvMinorCivInfo@@6B@				; CvMinorCivInfo::`vftable'
PUBLIC	??0CvMinorCivInfo@@QAE@XZ			; CvMinorCivInfo::CvMinorCivInfo
PUBLIC	??_R4CvMinorCivInfo@@6B@			; CvMinorCivInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvMinorCivInfo@@@8			; CvMinorCivInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvMinorCivInfo@@8				; CvMinorCivInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvMinorCivInfo@@8				; CvMinorCivInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvMinorCivInfo@@8			; CvMinorCivInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMinorCivInfo::CacheResults
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvMinorCivInfo@@UAEPAXI@Z:PROC		; CvMinorCivInfo::`vector deleting destructor'
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvMinorCivInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvMinorCivInfo@@8 DD FLAT:??_R0?AVCvMinorCivInfo@@@8 ; CvMinorCivInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvMinorCivInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvMinorCivInfo@@8
rdata$r	SEGMENT
??_R2CvMinorCivInfo@@8 DD FLAT:??_R1A@?0A@EA@CvMinorCivInfo@@8 ; CvMinorCivInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvMinorCivInfo@@8
rdata$r	SEGMENT
??_R3CvMinorCivInfo@@8 DD 00H				; CvMinorCivInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvMinorCivInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvMinorCivInfo@@@8
_DATA	SEGMENT
??_R0?AVCvMinorCivInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvMinorCivInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvMinorCivInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvMinorCivInfo@@6B@
rdata$r	SEGMENT
??_R4CvMinorCivInfo@@6B@ DD 00H				; CvMinorCivInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvMinorCivInfo@@@8
	DD	FLAT:??_R3CvMinorCivInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvMinorCivInfo@@6B@
CONST	SEGMENT
??_7CvMinorCivInfo@@6B@ DD FLAT:??_R4CvMinorCivInfo@@6B@ ; CvMinorCivInfo::`vftable'
	DD	FLAT:?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvMinorCivInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvMinorCivInfo@@QAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0CvMinorCivInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvMinorCivInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$9
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ??0CvMinorCivInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvMinorCivInfo@@QAE@XZ PROC				; CvMinorCivInfo::CvMinorCivInfo, COMDAT
; _this$ = ecx

; 10186: {

	push	-1
	push	__ehhandler$??0CvMinorCivInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	or	eax, -1
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+280]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi], OFFSET ??_7CvMinorCivInfo@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+308]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+336]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+364]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+392]
	mov	BYTE PTR __$EHRec$[esp+32], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+420]
	mov	BYTE PTR __$EHRec$[esp+32], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+448]
	mov	BYTE PTR __$EHRec$[esp+32], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+476]
	mov	BYTE PTR __$EHRec$[esp+32], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+504]
	mov	BYTE PTR __$EHRec$[esp+32], 8
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10187: }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+532], edi
	mov	DWORD PTR [esi+540], edi
	mov	DWORD PTR [esi+544], edi
	mov	DWORD PTR [esi+548], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 364				; 0000016cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 420				; 000001a4H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 448				; 000001c0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476				; 000001dcH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvMinorCivInfo@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 504				; 000001f8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvMinorCivInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvMinorCivInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMinorCivInfo@@QAE@XZ ENDP				; CvMinorCivInfo::CvMinorCivInfo
PUBLIC	??1CvMinorCivInfo@@UAE@XZ			; CvMinorCivInfo::~CvMinorCivInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvMinorCivInfo@@UAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??1CvMinorCivInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvMinorCivInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$9
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ??1CvMinorCivInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMinorCivInfo@@UAE@XZ PROC				; CvMinorCivInfo::~CvMinorCivInfo, COMDAT
; _this$ = ecx

; 10190: {

	push	-1
	push	__ehhandler$??1CvMinorCivInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvMinorCivInfo@@6B@

; 10191: 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+532]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 9
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 10192: }

	lea	ecx, DWORD PTR [esi+536]
	mov	DWORD PTR [esi+532], 0
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	lea	ecx, DWORD PTR [esi+504]
	mov	BYTE PTR __$EHRec$[esp+28], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+476]
	mov	BYTE PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+448]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+420]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+392]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+364]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+336]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+308]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+280]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 364				; 0000016cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 420				; 000001a4H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 448				; 000001c0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476				; 000001dcH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvMinorCivInfo@@UAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 504				; 000001f8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvMinorCivInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvMinorCivInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMinorCivInfo@@UAE@XZ ENDP				; CvMinorCivInfo::~CvMinorCivInfo
PUBLIC	?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEXXZ ; CvWeightedVector<enum PlayerTypes,64,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEXXZ PROC ; CvWeightedVector<enum PlayerTypes,64,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAEXXZ ENDP ; CvWeightedVector<enum PlayerTypes,64,1>::SortItems
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ	; CvWeightedVector<int,64,1>::SortItems
; Function compile flags: /Ogtpy
;	COMDAT ?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ PROC	; CvWeightedVector<int,64,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$0EA@$00@@QAEXXZ ENDP	; CvWeightedVector<int,64,1>::SortItems
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEXXZ ; CvWeightedVector<enum PlayerTypes,22,1>::SortItems
; Function compile flags: /Ogtpy
;	COMDAT ?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEXXZ PROC ; CvWeightedVector<enum PlayerTypes,22,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEXXZ ENDP ; CvWeightedVector<enum PlayerTypes,22,1>::SortItems
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$0GE@$00@@QAEXXZ	; CvWeightedVector<int,100,1>::SortItems
; Function compile flags: /Ogtpy
;	COMDAT ?SortItems@?$CvWeightedVector@H$0GE@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$0GE@$00@@QAEXXZ PROC	; CvWeightedVector<int,100,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$0GE@$00@@QAEXXZ ENDP	; CvWeightedVector<int,100,1>::SortItems
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::insert
_TEXT	ENDS
PUBLIC	?Reset@CvMinorCivAI@@QAEXXZ			; CvMinorCivAI::Reset
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
;	COMDAT ?Reset@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
tv1237 = -4						; size = 4
tv1140 = -4						; size = 4
?Reset@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::Reset, COMDAT
; _this$ = ecx

; 1639 : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi

; 1640 : 	m_ePersonality = NO_MINOR_CIV_PERSONALITY_TYPE;

	or	edi, -1

; 1641 : 	m_eStatus = NO_MINOR_CIV_STATUS_TYPE;
; 1642 : 	m_eUniqueUnit = NO_UNIT;
; 1643 : 
; 1644 : 	m_iTurnsSinceThreatenedByBarbarians = -1;
; 1645 : 	m_iGlobalQuestCountdown = -1;
; 1646 : 
; 1647 : 	m_eAlly = NO_PLAYER;
; 1648 : 	m_iTurnAllied = -1;
; 1649 : 	m_eMajorBoughtOutBy = NO_PLAYER;
; 1650 : 	m_bDisableNotifications = false;

	xor	ebx, ebx
	mov	DWORD PTR [ebp+8], edi
	mov	DWORD PTR [ebp+12], edi
	mov	DWORD PTR [ebp+16], edi
	mov	DWORD PTR [ebp+20], edi
	mov	DWORD PTR [ebp+24], edi
	mov	DWORD PTR [ebp+2012], edi
	mov	DWORD PTR [ebp+2016], edi
	mov	DWORD PTR [ebp+2020], edi
	mov	BYTE PTR [ebp+6864], bl
	lea	esi, DWORD PTR [ebp+1988]
	lea	edx, DWORD PTR [ebp+2112]
	lea	eax, DWORD PTR [ebp+52]
	mov	DWORD PTR tv1140[esp+20], 22		; 00000016H
	npad	6
$LL14@Reset:

; 1651 : 
; 1652 : 	int iI, iJ;
; 1653 : 
; 1654 : 	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
; 1655 : 	{
; 1656 : 		m_abWarQuestAgainstMajor[iI] = false;

	mov	BYTE PTR [esi-1960], bl

; 1657 : 
; 1658 : 		for(iJ = 0; iJ < MAX_MAJOR_CIVS; iJ++)
; 1659 : 		{
; 1660 : 			m_aaiNumEnemyUnitsLeftToKillByMajor[iI][iJ] = -1;

	mov	ecx, edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ecx

; 1661 : 		}
; 1662 : 
; 1663 : 		m_abRouteConnectionEstablished[iI] = false;

	mov	BYTE PTR [esi], bl

; 1664 : 
; 1665 : 		m_aiFriendshipWithMajorTimes100[iI] = 0;

	mov	DWORD PTR [edx-88], ebx

; 1666 : 		m_aiAngerFreeIntrusionCounter[iI] = 0;

	mov	DWORD PTR [edx], ebx

; 1667 : 		m_aiPlayerQuests[iI] = NO_MINOR_CIV_QUEST_TYPE;

	mov	DWORD PTR [edx+88], edi

; 1668 : 		m_aiQuestData1[iI] = -1;

	mov	DWORD PTR [edx+176], edi

; 1669 : 		m_aiQuestData2[iI] = -1;

	mov	DWORD PTR [edx+264], edi

; 1670 : 		m_aiQuestCountdown[iI] = -1;

	mov	DWORD PTR [edx+352], edi

; 1671 : 		m_aiUnitSpawnCounter[iI] = -1;

	mov	DWORD PTR [edx+440], edi

; 1672 : 		m_aiNumUnitsGifted[iI] = 0;

	mov	DWORD PTR [edx+528], ebx

; 1673 : 		m_aiNumGoldGifted[iI] = 0;

	mov	DWORD PTR [edx+616], ebx

; 1674 : 		m_aiTurnLastBullied[iI] = -1;

	mov	DWORD PTR [edx+704], edi

; 1675 : 		m_aiTurnLastPledged[iI] = -1;

	mov	DWORD PTR [edx+792], edi

; 1676 : 		m_aiTurnLastBrokePledge[iI] = -1;

	mov	DWORD PTR [edx+880], edi

; 1677 : 		m_abUnitSpawningDisabled[iI] = false;

	mov	BYTE PTR [esi+1092], bl

; 1678 : 		m_abMajorIntruding[iI] = false;

	mov	BYTE PTR [esi+1114], bl

; 1679 : 		m_abEverFriends[iI] = false;

	mov	BYTE PTR [esi+1136], bl

; 1680 : 		m_abPledgeToProtect[iI] = false;

	mov	BYTE PTR [esi+1158], bl

; 1681 : 		m_aiMajorScratchPad[iI] = 0;

	mov	DWORD PTR [edx+4664], ebx
	add	edx, 4
	add	eax, 88					; 00000058H
	inc	esi
	sub	DWORD PTR tv1140[esp+20], 1
	jne	$LL14@Reset

; 1682 : 	}
; 1683 : 
; 1684 : 	for(iI = 0; iI < REALLY_MAX_TEAMS; iI++)

	lea	eax, DWORD PTR [ebp+3248]
	mov	ecx, 80					; 00000050H
$LL8@Reset:

; 1685 : 	{
; 1686 : 		m_abPermanentWar[iI] = false;

	mov	BYTE PTR [eax-80], bl

; 1687 : 		m_abWaryOfTeam[iI] = false;

	mov	BYTE PTR [eax], bl
	inc	eax
	sub	ecx, 1
	jne	SHORT $LL8@Reset

; 1688 : 	}
; 1689 : 
; 1690 : 	ResetQuestList();

	mov	ecx, ebp
	call	?ResetQuestList@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::ResetQuestList

; 1691 : 
; 1692 : 	if(GetPlayer()->isMinorCiv())

	mov	ecx, DWORD PTR [ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN2@Reset

; 1693 : 	{
; 1694 : 		CvPlot* pLoopPlot;
; 1695 : 		TeamTypes eTeam = GetPlayer()->getTeam();

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN25@Reset
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@Reset
$LN25@Reset:
	mov	ebp, edi
$LN26@Reset:

; 1696 : 		int iNumPlotsInEntireWorld = GC.getMap().numPlots();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [eax+4028]

; 1697 : 		for(int iLoopPlot = 0; iLoopPlot < iNumPlotsInEntireWorld; iLoopPlot++)

	cmp	eax, ebx
	jle	SHORT $LN2@Reset
	xor	esi, esi
	mov	DWORD PTR tv1237[esp+20], eax
$LL47@Reset:

; 1698 : 		{
; 1699 : 			pLoopPlot = GC.getMap().plotByIndexUnchecked(iLoopPlot);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ecx+4068]
	add	ecx, esi

; 1700 : 			if(pLoopPlot)

	je	SHORT $LN3@Reset

; 1701 : 				pLoopPlot->setRevealed(eTeam, true);

	push	edi
	push	ebx
	push	1
	push	ebp
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
$LN3@Reset:
	add	esi, 484				; 000001e4H
	sub	DWORD PTR tv1237[esp+20], 1
	jne	SHORT $LL47@Reset
$LN2@Reset:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1702 : 		}
; 1703 : 	}
; 1704 : 
; 1705 : }

	pop	ecx
	ret	0
?Reset@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::Reset
_TEXT	ENDS
PUBLIC	?DoTestActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoTestActiveQuestsForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?DoTestActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bTestComplete$ = 12					; size = 1
_bTestObsolete$ = 16					; size = 1
_eQuest$ = 20						; size = 4
?DoTestActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::DoTestActiveQuestsForPlayer, COMDAT
; _this$ = ecx

; 3162 : 	if (bTestComplete)

	cmp	BYTE PTR _bTestComplete$[esp-4], 0
	push	ebx
	mov	ebx, DWORD PTR _ePlayer$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eQuest$[esp+8]
	mov	esi, ecx
	je	SHORT $LN2@DoTestActi

; 3163 : 		DoCompletedQuestsForPlayer(ePlayer, eQuest);

	push	edi
	push	ebx
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
$LN2@DoTestActi:

; 3164 : 	
; 3165 : 	if (bTestObsolete)

	cmp	BYTE PTR _bTestObsolete$[esp+8], 0
	je	SHORT $LN1@DoTestActi

; 3166 : 		DoObsoleteQuestsForPlayer(ePlayer, eQuest);

	push	edi
	push	ebx
	mov	ecx, esi
	call	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
$LN1@DoTestActi:
	pop	edi
	pop	esi
	pop	ebx

; 3167 : }

	ret	16					; 00000010H
?DoTestActiveQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::DoTestActiveQuestsForPlayer
_TEXT	ENDS
PUBLIC	?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ; CvMinorCivAI::CalculateFriendshipFromQuests
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	SEGMENT
__unwindtable$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ$0
__ehfuncinfo$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ
_TEXT	SEGMENT
_iInfTimes100$224481 = -32				; size = 4
_iMajorLoop$224475 = -28				; size = 4
tv767 = -24						; size = 4
tv728 = -20						; size = 4
$T265421 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ PROC ; CvMinorCivAI::CalculateFriendshipFromQuests, COMDAT
; _this$ = ecx

; 3185 : {

	push	-1
	push	__ehhandler$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, ecx
	xor	ecx, ecx
	mov	DWORD PTR $T265421[esp+40], ecx
	push	esi
	push	edi

; 3186 : 	WeightedCivsList vePlayerInfluences;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+44]
	lea	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], 64			; 00000040H
	mov	DWORD PTR [edi], eax

; 3207 : 	return vePlayerInfluences;

	xor	eax, eax
	xor	ebx, ebx
	xor	esi, esi
	lea	edx, DWORD PTR [ebp+2024]
	mov	DWORD PTR __$EHRec$[esp+56], ecx
	mov	DWORD PTR $T265421[esp+48], 1
	mov	DWORD PTR _iMajorLoop$224475[esp+48], eax
	mov	DWORD PTR tv728[esp+48], esi
	mov	DWORD PTR tv767[esp+48], edx
	jmp	SHORT $LN8@CalculateF
	npad	3
$LL123@CalculateF:

; 3187 : 	for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
; 3188 : 	{
; 3189 : 		PlayerTypes eMajorLoop = (PlayerTypes) iMajorLoop;
; 3190 : 		int iInfTimes100 = GetEffectiveFriendshipWithMajorTimes100(eMajorLoop);

	mov	esi, DWORD PTR tv728[esp+48]
	mov	eax, DWORD PTR _iMajorLoop$224475[esp+48]
	xor	ecx, ecx
$LN8@CalculateF:
	cmp	eax, ecx
	jl	SHORT $LN25@CalculateF
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN25@CalculateF
	push	eax
	mov	ecx, ebp
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN24@CalculateF
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iInfTimes100$224481[esp+48], eax
	jmp	SHORT $LN27@CalculateF
$LN24@CalculateF:
	mov	eax, DWORD PTR tv767[esp+48]
	mov	ecx, DWORD PTR [eax]
$LN25@CalculateF:
	mov	DWORD PTR _iInfTimes100$224481[esp+48], ecx
$LN27@CalculateF:

; 3191 : 		if (IsHasMetPlayer(eMajorLoop) && !IsAtWarWithPlayersTeam(eMajorLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN43@CalculateF
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN44@CalculateF
$LN43@CalculateF:
	or	ecx, -1
$LN44@CalculateF:
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@CalculateF
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN55@CalculateF
$LN54@CalculateF:
	or	eax, -1
$LN55@CalculateF:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN2@CalculateF
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN69@CalculateF
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN70@CalculateF
$LN69@CalculateF:
	or	ecx, -1
$LN70@CalculateF:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN80@CalculateF
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN81@CalculateF
$LN80@CalculateF:
	or	eax, -1
$LN81@CalculateF:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN2@CalculateF

; 3192 : 		{
; 3193 : 			QuestListForPlayer::iterator itr_quest;
; 3194 : 			for (itr_quest = m_QuestsGiven[eMajorLoop].begin(); itr_quest != m_QuestsGiven[eMajorLoop].end(); itr_quest++)

	mov	eax, DWORD PTR [ebp+3328]
	mov	ecx, DWORD PTR [eax+ebx+4]
	mov	esi, DWORD PTR [eax+ebx]
	add	eax, ebx
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	eax, esi
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	esi, ecx
	je	SHORT $LN2@CalculateF
$LL4@CalculateF:

; 3195 : 			{
; 3196 : 				if (itr_quest->IsComplete())

	mov	ecx, esi
	call	?IsComplete@CvMinorCivQuest@@QAE_NXZ	; CvMinorCivQuest::IsComplete
	test	al, al
	je	SHORT $LN3@CalculateF

; 3197 : 				{
; 3198 : 					iInfTimes100 += (itr_quest->GetInfluenceReward() * 100);

	mov	ecx, esi
	call	?GetInfluenceReward@CvMinorCivQuest@@QBEHXZ ; CvMinorCivQuest::GetInfluenceReward
	imul	eax, 100				; 00000064H
	add	DWORD PTR _iInfTimes100$224481[esp+48], eax
$LN3@CalculateF:
	mov	eax, DWORD PTR [ebp+3328]
	mov	ecx, DWORD PTR [eax+ebx+4]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	esi, 28					; 0000001cH
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	esi, ecx
	jne	SHORT $LL4@CalculateF
$LN2@CalculateF:

; 3199 : 				}
; 3200 : 			}
; 3201 : 		}
; 3202 : 		int iWeight = iInfTimes100 + abs(GC.getMINOR_FRIENDSHIP_AT_WAR() * 100); // Weights cannot be negative, so shift all values up by minimum influence amount

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	cdq
	mov	esi, eax

; 3203 : 		vePlayerInfluences.push_back(eMajorLoop, iWeight);

	mov	eax, DWORD PTR [edi+8]
	xor	esi, edx
	sub	esi, edx
	add	esi, DWORD PTR _iInfTimes100$224481[esp+48]
	mov	BYTE PTR [edi+524], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN101@CalculateF
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN101@CalculateF:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*8]
	test	eax, eax
	je	SHORT $LN124@CalculateF
	mov	ecx, DWORD PTR _iMajorLoop$224475[esp+48]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi
$LN124@CalculateF:
	add	DWORD PTR tv767[esp+48], 4
	mov	ecx, 1
	add	DWORD PTR [edi+4], ecx
	add	DWORD PTR _iMajorLoop$224475[esp+48], ecx
	mov	ecx, DWORD PTR tv728[esp+48]
	mov	eax, DWORD PTR [edi+4]
	add	ecx, 63236				; 0000f704H
	add	ebx, 156				; 0000009cH
	cmp	ecx, 1391192				; 00153a58H
	mov	DWORD PTR tv728[esp+48], ecx
	jl	$LL123@CalculateF

; 3204 : 	}
; 3205 : 
; 3206 : 	vePlayerInfluences.SortItems();

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,64,1>::WeightedElement *,int>

; 3208 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	add	esp, 12					; 0000000cH
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ$0:
	mov	eax, DWORD PTR $T265421[ebp]
	and	eax, 1
	je	$LN12@CalculateF
	and	DWORD PTR $T265421[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,64,1>::~CvWeightedVector<enum PlayerTypes,64,1>
$LN12@CalculateF:
	ret	0
__ehhandler$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ENDP ; CvMinorCivAI::CalculateFriendshipFromQuests
PUBLIC	?DoQuestsCleanupForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoQuestsCleanupForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?DoQuestsCleanupForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_bGlobalQuestDone$ = -1					; size = 1
_ePlayer$ = 8						; size = 4
?DoQuestsCleanupForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::DoQuestsCleanupForPlayer, COMDAT
; _this$ = ecx

; 3310 : {

	push	ecx
	push	ebp
	push	edi

; 3311 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3312 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3313 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	edi, DWORD PTR _ePlayer$[esp+8]
	mov	ebp, ecx
	cmp	edi, 21					; 00000015H
	ja	$LN9@DoQuestsCl

; 3314 : 
; 3315 : 	bool bPersonalQuestDone = false;
; 3316 : 	bool bGlobalQuestDone = false;
; 3317 : 
; 3318 : 	QuestListForPlayer::iterator itr_quest;
; 3319 : 	for (itr_quest = m_QuestsGiven[ePlayer].begin(); itr_quest != m_QuestsGiven[ePlayer].end(); itr_quest++)

	mov	eax, DWORD PTR [ebp+3328]
	imul	edi, 156				; 0000009cH
	lea	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx+4]
	push	ebx
	lea	edx, DWORD PTR [eax*8]
	push	esi
	mov	esi, DWORD PTR [ecx]
	sub	edx, eax
	mov	eax, esi
	xor	bl, bl
	lea	edx, DWORD PTR [eax+edx*4]
	mov	BYTE PTR _bGlobalQuestDone$[esp+20], bl
	cmp	esi, edx
	je	SHORT $LN54@DoQuestsCl
$LL8@DoQuestsCl:

; 3320 : 	{
; 3321 : 		if (itr_quest->IsHandled())

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN7@DoQuestsCl

; 3322 : 		{
; 3323 : 			MinorCivQuestTypes eQuestType = itr_quest->GetType();

	mov	eax, DWORD PTR [esi+8]

; 3324 : 			if (IsPersonalQuest(eQuestType))

	cmp	eax, 1
	je	SHORT $LN51@DoQuestsCl
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN51@DoQuestsCl
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN51@DoQuestsCl
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN51@DoQuestsCl
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN51@DoQuestsCl

; 3325 : 				bPersonalQuestDone = true;

	mov	bl, 1

; 3326 : 			if (IsGlobalQuest(eQuestType))

	jmp	SHORT $LN3@DoQuestsCl
$LN51@DoQuestsCl:

; 3327 : 				bGlobalQuestDone = true;

	mov	BYTE PTR _bGlobalQuestDone$[esp+20], 1
$LN3@DoQuestsCl:

; 3328 : 
; 3329 : 			m_QuestsGiven[ePlayer].erase(itr_quest);

	push	esi
	call	?erase@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEXPAVCvMinorCivQuest@@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::erase

; 3330 : 			itr_quest--;

	sub	esi, 28					; 0000001cH
$LN7@DoQuestsCl:
	mov	eax, DWORD PTR [ebp+3328]
	lea	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	add	esi, 28					; 0000001cH
	lea	edx, DWORD PTR [eax+edx*4]
	cmp	esi, edx
	jne	SHORT $LL8@DoQuestsCl

; 3331 : 		}
; 3332 : 	}
; 3333 : 
; 3334 : 	// Check if we need to seed the countdown timers
; 3335 : 	if (bPersonalQuestDone)

	test	bl, bl
	je	SHORT $LN53@DoQuestsCl

; 3336 : 		DoTestSeedQuestCountdownForPlayer(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[esp+16]
	push	0
	push	eax
	mov	ecx, ebp
	call	?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer
$LN53@DoQuestsCl:

; 3337 : 	if (bGlobalQuestDone)

	cmp	BYTE PTR _bGlobalQuestDone$[esp+20], 0
	je	SHORT $LN54@DoQuestsCl

; 3338 : 		DoTestSeedGlobalQuestCountdown();

	push	0
	mov	ecx, ebp
	call	?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z ; CvMinorCivAI::DoTestSeedGlobalQuestCountdown
$LN54@DoQuestsCl:
	pop	esi
	pop	ebx
$LN9@DoQuestsCl:
	pop	edi
	pop	ebp

; 3339 : }

	pop	ecx
	ret	4
?DoQuestsCleanupForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::DoQuestsCleanupForPlayer
_TEXT	ENDS
PUBLIC	?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ ; CvMinorCivAI::GetBestNearbyCampToKill
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ$0
__ehfuncinfo$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ
_TEXT	SEGMENT
$T265913 = -560						; size = 4
$T265882 = -560						; size = 4
_iDX$ = -556						; size = 4
_iDY$ = -552						; size = 4
_iRange$ = -548						; size = 4
tv453 = -544						; size = 4
_viPlotIndexes$ = -540					; size = 528
__$EHRec$ = -12						; size = 12
?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ PROC ; CvMinorCivAI::GetBestNearbyCampToKill, COMDAT
; _this$ = ecx

; 4647 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 4648 : 	CvCity* pCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [ecx]
	sub	esp, 548				; 00000224H
	push	ebx
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ebx, eax

; 4649 : 
; 4650 : 	// Minor must have Capital
; 4651 : 	if(pCapital == NULL)

	xor	ecx, ecx
	cmp	ebx, ecx
	jne	SHORT $LN13@GetBestNea

; 4652 : 	{
; 4653 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 4722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+560]
	mov	DWORD PTR fs:0, ecx
	add	esp, 560				; 00000230H
	ret	0
$LN13@GetBestNea:
	push	ebp
	push	esi

; 4654 : 	}
; 4655 : 
; 4656 : 	CvWeightedVector<int, 64, true> viPlotIndexes; // 64 camps in 12 hex radius should be enough

	lea	eax, DWORD PTR _viPlotIndexes$[esp+584]
	push	edi
	mov	DWORD PTR _viPlotIndexes$[esp+580], ecx
	mov	DWORD PTR _viPlotIndexes$[esp+584], 64	; 00000040H
	mov	DWORD PTR _viPlotIndexes$[esp+576], eax

; 4657 : 
; 4658 : 	int iRange = /*12*/ GC.getMINOR_CIV_QUEST_KILL_CAMP_RANGE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3232

; 4659 : 
; 4660 : 	CvPlot* pLoopPlot;
; 4661 : 
; 4662 : 	// Loop in all plots in range
; 4663 : 	int iDX, iDY;
; 4664 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4665 : 	int iMaxDX;
; 4666 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 4667 : 	{
; 4668 : 		iMaxDX = iRange - MAX(0, iDY);
; 4669 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 4670 : #else
; 4671 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ebp, edi
	neg	ebp
	mov	edx, ebp
	cmp	edx, edi
	mov	DWORD PTR __$EHRec$[esp+584], ecx
	mov	DWORD PTR _iRange$[esp+576], edi
	mov	DWORD PTR tv453[esp+576], ebp
	mov	DWORD PTR _iDX$[esp+576], ebp
	jg	$LN134@GetBestNea
$LL12@GetBestNea:

; 4672 : 	{
; 4673 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	cmp	ebp, edi
	mov	DWORD PTR _iDY$[esp+576], ebp
	jg	$LN11@GetBestNea
	npad	3
$LL9@GetBestNea:

; 4674 : #endif
; 4675 : 		{
; 4676 : 			pLoopPlot = plotXY(pCapital->getX(), pCapital->getY(), iDX, iDY);

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	ebp
	push	edx
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 4677 : 
; 4678 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	$LN8@GetBestNea

; 4679 : 			{
; 4680 : 				// Camp must be in the same Area as us
; 4681 : 				if(pLoopPlot->getArea() != pCapital->getArea())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, ebx
	mov	DWORD PTR $T265882[esp+576], eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	DWORD PTR $T265882[esp+576], eax
	jne	$LN8@GetBestNea

; 4682 : 				{
; 4683 : 					continue;
; 4684 : 				}
; 4685 : 
; 4686 : #ifndef AUI_HEXSPACE_DX_LOOPS
; 4687 : 				int iDistance = plotDistance(pCapital->getX(), pCapital->getY(), pLoopPlot->getX(), pLoopPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 4688 : 
; 4689 : 				if(iDistance <= iRange)

	cmp	ebp, edi
	jg	SHORT $LN137@GetBestNea

; 4690 : #endif
; 4691 : 				{
; 4692 : 					// Can't be owned by anyone
; 4693 : 					if(pLoopPlot->getOwner() == NO_PLAYER)

	cmp	BYTE PTR [esi+4], -1
	jne	SHORT $LN137@GetBestNea

; 4694 : 					{
; 4695 : 						// Camp here?
; 4696 : 						if(pLoopPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, esi
	mov	DWORD PTR $T265913[esp+576], eax
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T265913[esp+576]
	jne	SHORT $LN137@GetBestNea

; 4697 : 						{
; 4698 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4699 : 							int iWeight = 1 + (iRange - hexDistance(iDX, iDY)); // Closer camps have higher weight
; 4700 : #else
; 4701 : 							int iWeight = 1 + (iRange - iDistance); // Closer camps have higher weight

	sub	edi, ebp

; 4702 : #endif
; 4703 : 							viPlotIndexes.push_back(pLoopPlot->GetPlotIndex(), iWeight);

	mov	ecx, esi
	inc	edi
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	esi, eax
	mov	eax, DWORD PTR _viPlotIndexes$[esp+584]
	mov	BYTE PTR _viPlotIndexes$[esp+1100], 0
	cmp	DWORD PTR _viPlotIndexes$[esp+580], eax
	jne	SHORT $LN62@GetBestNea
	push	eax
	lea	ecx, DWORD PTR _viPlotIndexes$[esp+580]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN62@GetBestNea:
	mov	ecx, DWORD PTR _viPlotIndexes$[esp+576]
	mov	edx, DWORD PTR _viPlotIndexes$[esp+580]
	lea	eax, DWORD PTR [ecx+edx*8]
	test	eax, eax
	je	SHORT $LN65@GetBestNea
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN65@GetBestNea:
	inc	DWORD PTR _viPlotIndexes$[esp+580]
	mov	edi, DWORD PTR _iRange$[esp+576]
$LN137@GetBestNea:
	mov	ebp, DWORD PTR _iDY$[esp+576]
$LN8@GetBestNea:

; 4672 : 	{
; 4673 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	edx, DWORD PTR _iDX$[esp+576]
	inc	ebp
	cmp	ebp, edi
	mov	DWORD PTR _iDY$[esp+576], ebp
	jle	$LL9@GetBestNea
	mov	eax, DWORD PTR _viPlotIndexes$[esp+576]
	mov	ebp, DWORD PTR tv453[esp+576]
$LN11@GetBestNea:
	inc	edx
	cmp	edx, edi
	mov	DWORD PTR _iDX$[esp+576], edx
	jle	$LL12@GetBestNea

; 4704 : 						}
; 4705 : 					}
; 4706 : 				}
; 4707 : 			}
; 4708 : 		}
; 4709 : 	}
; 4710 : 
; 4711 : 	// Didn't find any nearby
; 4712 : 	if(viPlotIndexes.size() == 0)

	mov	ecx, DWORD PTR _viPlotIndexes$[esp+580]
	test	ecx, ecx
	jne	SHORT $LN1@GetBestNea
$LN134@GetBestNea:

; 4713 : 	{
; 4714 : 		return NULL;

	lea	ecx, DWORD PTR _viPlotIndexes$[esp+588]
	mov	DWORD PTR __$EHRec$[esp+584], -1
	cmp	eax, ecx
	je	SHORT $LN81@GetBestNea
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN81@GetBestNea:
	xor	eax, eax
	jmp	SHORT $LN140@GetBestNea
$LN1@GetBestNea:

; 4715 : 	}
; 4716 : 
; 4717 : 	// Choose the best plot
; 4718 : 	viPlotIndexes.SortItems();

	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>

; 4719 : 	CvPlot* pBestPlot = GC.getMap().plotByIndex(viPlotIndexes.GetElement(0));

	mov	edx, DWORD PTR _viPlotIndexes$[esp+588]
	mov	eax, DWORD PTR [edx]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jl	SHORT $LN109@GetBestNea
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN109@GetBestNea
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax
	jmp	SHORT $LN110@GetBestNea
$LN109@GetBestNea:
	xor	esi, esi
$LN110@GetBestNea:

; 4720 : 
; 4721 : 	return pBestPlot;

	lea	eax, DWORD PTR _viPlotIndexes$[esp+588]
	mov	DWORD PTR __$EHRec$[esp+584], -1
	cmp	edx, eax
	je	SHORT $LN118@GetBestNea
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN118@GetBestNea:
	mov	eax, esi
$LN140@GetBestNea:

; 4722 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+576]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 560				; 00000230H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ$0:
	lea	ecx, DWORD PTR _viPlotIndexes$[ebp]
	jmp	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ	; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
__ehhandler$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ ENDP ; CvMinorCivAI::GetBestNearbyCampToKill
PUBLIC	?DoChangeProtectionFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1@Z ; CvMinorCivAI::DoChangeProtectionFromMajor
; Function compile flags: /Ogtpy
;	COMDAT ?DoChangeProtectionFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_bProtect$ = 12						; size = 1
_bPledgeNowBroken$ = 16					; size = 1
?DoChangeProtectionFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1@Z PROC ; CvMinorCivAI::DoChangeProtectionFromMajor, COMDAT
; _this$ = ecx

; 6541 : {

	push	esi
	push	edi

; 6542 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 6543 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 6544 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	mov	edi, DWORD PTR _eMajor$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	$LN6@DoChangePr

; 6545 : 
; 6546 : 	if(bProtect == IsProtectedByMajor(eMajor)) return;

	mov	al, BYTE PTR [edi+esi+3146]
	push	ebx
	mov	bl, BYTE PTR _bProtect$[esp+8]
	cmp	bl, al
	je	$LN41@DoChangePr

; 6547 : 
; 6548 : 	if(bProtect)

	test	bl, bl
	je	SHORT $LN4@DoChangePr

; 6549 : 	{
; 6550 : 		if(!CanMajorProtect(eMajor))

	push	edi
	call	?CanMajorProtect@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorProtect
	test	al, al
	je	$LN41@DoChangePr

; 6551 : 		{
; 6552 : 			return;
; 6553 : 		}
; 6554 : 		SetTurnLastPledgedProtectionByMajor(eMajor, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	edi
	mov	ecx, esi
	call	?SetTurnLastPledgedProtectionByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetTurnLastPledgedProtectionByMajor

; 6555 : 	}
; 6556 : 	else

	jmp	SHORT $LN22@DoChangePr
$LN4@DoChangePr:

; 6557 : 	{
; 6558 : 		if(bPledgeNowBroken)

	cmp	BYTE PTR _bPledgeNowBroken$[esp+8], 0
	je	SHORT $LN22@DoChangePr

; 6559 : 		{
; 6560 : 			SetTurnLastPledgeBrokenByMajor(eMajor, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	edi
	mov	ecx, esi
	call	?SetTurnLastPledgeBrokenByMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::SetTurnLastPledgeBrokenByMajor

; 6561 : 			ChangeFriendshipWithMajorTimes100(eMajor, GC.getMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2744
	test	ecx, ecx
	je	SHORT $LN22@DoChangePr
	mov	eax, DWORD PTR [esi+edi*4+2024]
	push	0
	add	ecx, eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN22@DoChangePr:

; 6562 : 		}
; 6563 : 	}
; 6564 : 
; 6565 : 	m_abPledgeToProtect[eMajor] = bProtect;
; 6566 : 
; 6567 : 	// In case we had a Pledge to Protect quest active, complete it now
; 6568 : 	DoTestActiveQuestsForPlayer(eMajor, /*bTestComplete*/ true, /*bTestObsolete*/ false, MINOR_CIV_QUEST_PLEDGE_TO_PROTECT);

	push	9
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [edi+esi+3146], bl
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer

; 6569 : 
; 6570 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx

; 6571 : 	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	18					; 00000012H
	call	edx
$LN41@DoChangePr:
	pop	ebx
$LN6@DoChangePr:
	pop	edi
	pop	esi

; 6572 : }

	ret	12					; 0000000cH
?DoChangeProtectionFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@_N1@Z ENDP ; CvMinorCivAI::DoChangeProtectionFromMajor
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@42480000
PUBLIC	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?GetPower@CvCity@@QBEHXZ:PROC			; CvCity::GetPower
EXTRN	?GetMilitaryMight@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetMilitaryMight
;	COMDAT __real@3fe0000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z
_TEXT	SEGMENT
_iScore$ = -364						; size = 4
_this$ = -360						; size = 4
_iMinorLocalPower$ = -356				; size = 4
$T266220 = -356						; size = 4
_eMajorLoop$ = -356					; size = 4
_iDX$227701 = -352					; size = 4
tv1557 = -348						; size = 4
_fRankRatio$227660 = -348				; size = 4
_iGlobalMilitaryScore$ = -348				; size = 4
_iBullyLocalPower$ = -344				; size = 4
$T266221 = -344						; size = 4
tv1590 = -340						; size = 4
_iComparisonRadius$ = -336				; size = 4
tv1575 = -332						; size = 4
_fLocalPowerRatio$ = -328				; size = 4
_iMinorCapitalX$ = -328					; size = 4
_strNegativeFactor$227948 = -324			; size = 80
_strNegativeFactor$227925 = -324			; size = 80
_strNegativeFactor$227902 = -324			; size = 80
_strNegativeFactor$227874 = -324			; size = 80
_strNegativeFactor$227851 = -324			; size = 80
_strNegativeFactor$227842 = -324			; size = 80
_strNegativeFactor$227819 = -324			; size = 80
_strNegativeFactor$227795 = -324			; size = 80
_strNegativeFactor$227770 = -324			; size = 80
_strNegativeFactor$227762 = -324			; size = 80
_strPositiveFactor$227756 = -324			; size = 80
_strPositiveFactor$227732 = -324			; size = 80
_strPositiveFactor$227665 = -324			; size = 80
_sFactors$ = -244					; size = 28
tv1123 = -216						; size = 4
tv1127 = -212						; size = 4
_iMinorCapitalY$ = -208					; size = 4
_veMilitaryRankings$ = -204				; size = 192
__$EHRec$ = -12						; size = 12
_eBullyPlayer$ = 8					; size = 4
_bForUnit$ = 12						; size = 1
_sTooltipSink$ = 16					; size = 4
?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z PROC ; CvMinorCivAI::CalculateBullyMetric, COMDAT
; _this$ = ecx

; 8043 : {

	push	-1
	push	__ehhandler$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 352				; 00000160H
	push	ebp
	push	esi
	mov	esi, ecx

; 8044 : 	CvString sFactors = "";

	push	OFFSET $SG227421
	lea	ecx, DWORD PTR _sFactors$[esp+376]
	mov	DWORD PTR _this$[esp+376], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 8045 : 
; 8046 : 	int iScore = 0;
; 8047 : 	const int iFailScore = -300;
; 8048 : 
; 8049 : 	CvAssertMsg(GetPlayer()->GetID() != eBullyPlayer, "Minor civ and bully civ not expected to have the same ID!");
; 8050 : 	if(GetPlayer()->GetID() == eBullyPlayer)

	mov	ebp, DWORD PTR _eBullyPlayer$[esp+368]
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+380], eax
	mov	DWORD PTR _iScore$[esp+372], eax
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+44]
	cmp	ecx, ebp
	jne	SHORT $LN68@CalculateB
$LN409@CalculateB:

; 8051 : 		return iFailScore;

	lea	ecx, DWORD PTR _sFactors$[esp+372]
	mov	DWORD PTR __$EHRec$[esp+380], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, -300				; fffffed4H
	jmp	$LN69@CalculateB
$LN68@CalculateB:

; 8052 : 
; 8053 : 	CvAssertMsg(eBullyPlayer >= 0, "eBullyPlayer is expected to be non-negative (invalid Index)");
; 8054 : 	CvAssertMsg(eBullyPlayer < MAX_MAJOR_CIVS, "eBullyPlayer is expected to be within maximum bounds (invalid Index)");
; 8055 : 	if(eBullyPlayer < 0 || eBullyPlayer >= MAX_MAJOR_CIVS)

	cmp	ebp, 21					; 00000015H
	ja	SHORT $LN409@CalculateB

; 8056 : 		return iFailScore;
; 8057 : 
; 8058 : 	// Can't bully the dead
; 8059 : 	if(!GetPlayer()->isAlive())

	cmp	BYTE PTR [eax+2256], 0

; 8060 : 		return iFailScore;

	je	SHORT $LN409@CalculateB
	push	ebx

; 8061 : 
; 8062 : 	// **************************
; 8063 : 	// Global military power ranking of major
; 8064 : 	//
; 8065 : 	// +0 ~ +75
; 8066 : 	// **************************
; 8067 : 	CvWeightedVector<PlayerTypes, MAX_MAJOR_CIVS, true> veMilitaryRankings;

	xor	esi, esi
	lea	eax, DWORD PTR _veMilitaryRankings$[esp+388]
	push	edi
	mov	DWORD PTR _veMilitaryRankings$[esp+384], esi
	mov	DWORD PTR _veMilitaryRankings$[esp+388], 22 ; 00000016H
	mov	DWORD PTR _veMilitaryRankings$[esp+380], eax

; 8068 : 	PlayerTypes eMajorLoop;
; 8069 : 	int iGlobalMilitaryScore = 0;

	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+388], 1
	mov	DWORD PTR _iGlobalMilitaryScore$[esp+380], ebx

; 8070 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	edi, edi
	npad	10
$LL64@CalculateB:

; 8071 : 	{
; 8072 : 		eMajorLoop = (PlayerTypes) iMajorLoop;
; 8073 : 		if(GET_PLAYER(eMajorLoop).isAlive() && !GET_PLAYER(eMajorLoop).isMinorCiv())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	mov	DWORD PTR _eMajorLoop$[esp+380], edi
	cmp	BYTE PTR [ecx+2256], bl
	je	SHORT $LN63@CalculateB
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN63@CalculateB

; 8074 : 		{
; 8075 : 			veMilitaryRankings.push_back(eMajorLoop, GET_PLAYER(eMajorLoop).GetMilitaryMight()); // Don't recalculate within a turn, can cause inconsistency

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	push	eax
	lea	eax, DWORD PTR _eMajorLoop$[esp+384]
	push	eax
	lea	ecx, DWORD PTR _veMilitaryRankings$[esp+388]
	call	?push_back@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAEIABW4PlayerTypes@@H@Z ; CvWeightedVector<enum PlayerTypes,22,1>::push_back
$LN63@CalculateB:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL64@CalculateB

; 8076 : 		}
; 8077 : 	}
; 8078 : 	CvAssertMsg(veMilitaryRankings.size() > 0, "WeightedVector of military might rankings not expected to be size 0");
; 8079 : 	veMilitaryRankings.SortItems();

	mov	eax, DWORD PTR _veMilitaryRankings$[esp+380]
	mov	ecx, DWORD PTR _veMilitaryRankings$[esp+384]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum PlayerTypes,22,1>::WeightedElement *,int>

; 8080 : 	for(int iRanking = 0; iRanking < veMilitaryRankings.size(); iRanking++)

	mov	ecx, DWORD PTR _veMilitaryRankings$[esp+396]
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN58@CalculateB
	mov	edx, DWORD PTR _veMilitaryRankings$[esp+380]
$LL60@CalculateB:

; 8081 : 	{
; 8082 : 		if(veMilitaryRankings.GetElement(iRanking) == eBullyPlayer)

	cmp	DWORD PTR [edx+eax*8], ebp
	je	SHORT $LN372@CalculateB
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL60@CalculateB

; 8385 : 	{
; 8386 : 		int iProtectionScore = 0;
; 8387 : 		eMajorLoop = (PlayerTypes) iMajorLoop;
; 8388 : 		if(eMajorLoop != eBullyPlayer && IsProtectedByMajor(eMajorLoop))

	jmp	SHORT $LN58@CalculateB
$LN372@CalculateB:

; 8083 : 		{
; 8084 : 			float fRankRatio = (float)(veMilitaryRankings.size() - iRanking) / (float)(veMilitaryRankings.size());

	sub	ecx, eax
	mov	DWORD PTR tv1557[esp+380], ecx
	fild	DWORD PTR tv1557[esp+380]
	fidiv	DWORD PTR _veMilitaryRankings$[esp+384]
	fstp	DWORD PTR _fRankRatio$227660[esp+380]

; 8085 : #ifdef NQ_TRIBUTE_EASIER_WITH_LOCAL_POWER
; 8086 : 			iGlobalMilitaryScore = (int)(fRankRatio * 50); // A score between 50*(1 / num majors alive) and 50, with the highest rank major getting 50

	fld	DWORD PTR _fRankRatio$227660[esp+380]
	fmul	DWORD PTR __real@42480000
	call	__ftol2_sse_excpt
	mov	ebx, eax
	mov	DWORD PTR _iGlobalMilitaryScore$[esp+380], ebx

; 8087 : #else
; 8088 : 			iGlobalMilitaryScore = (int)(fRankRatio * 75); // A score between 75*(1 / num majors alive) and 75, with the highest rank major getting 75
; 8089 : #endif
; 8090 : 			iScore += iGlobalMilitaryScore;

	mov	DWORD PTR _iScore$[esp+380], ebx
$LN58@CalculateB:

; 8091 : 			break;
; 8092 : 		}
; 8093 : 	}
; 8094 : 	
; 8095 : 	if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN56@CalculateB

; 8096 : 	{
; 8097 : 		Localization::String strPositiveFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_POSITIVE");

	lea	eax, DWORD PTR _strPositiveFactor$227665[esp+380]
	push	OFFSET $SG227667
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 8098 : 		strPositiveFactor << iGlobalMilitaryScore;

	push	ebx
	lea	ecx, DWORD PTR _strPositiveFactor$227665[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 2
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8099 : 		strPositiveFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_GLOBAL_MILITARY";

	push	47					; 0000002fH
	push	OFFSET $SG227684
	lea	ecx, DWORD PTR _strPositiveFactor$227665[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8100 : 		sFactors += strPositiveFactor.toUTF8();

	lea	ecx, DWORD PTR _strPositiveFactor$227665[esp+380]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8101 : 	}

	lea	ecx, DWORD PTR _strPositiveFactor$227665[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN56@CalculateB:

; 8102 : 
; 8103 : 	// **************************
; 8104 : 	// Local military power comparison
; 8105 : 	//
; 8106 : 	// +0 ~ +125
; 8107 : 	// **************************
; 8108 : #ifdef AUI_WARNING_FIXES
; 8109 : 	int iComparisonRadius = MAX(GC.getMap().getGridWidth() / 10, uint(5));
; 8110 : #else
; 8111 : 	int iComparisonRadius = std::max(GC.getMap().getGridWidth() / 10, 5);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ecx+4020]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T266221[esp+380], eax
	cmp	eax, 5
	mov	DWORD PTR $T266220[esp+380], 5
	lea	eax, DWORD PTR $T266220[esp+380]
	jl	SHORT $LN168@CalculateB
	lea	eax, DWORD PTR $T266221[esp+380]
$LN168@CalculateB:

; 8112 : #endif
; 8113 : 	CvCity* pMinorCapital = GetPlayer()->getCapitalCity();

	mov	edx, DWORD PTR _this$[esp+380]
	mov	edi, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _iComparisonRadius$[esp+380], edi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	esi, eax

; 8114 : 	if(pMinorCapital == NULL)

	test	esi, esi
	jne	SHORT $LN55@CalculateB

; 8115 : 		return iFailScore;

	mov	BYTE PTR __$EHRec$[esp+388], al
	mov	eax, DWORD PTR _veMilitaryRankings$[esp+380]
	lea	ecx, DWORD PTR _veMilitaryRankings$[esp+392]
	cmp	eax, ecx
$LN410@CalculateB:
	je	SHORT $LN176@CalculateB
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN176@CalculateB:
	lea	ecx, DWORD PTR _sFactors$[esp+380]
	mov	DWORD PTR __$EHRec$[esp+388], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, -300				; fffffed4H
$LN393@CalculateB:
	pop	edi
	pop	ebx
$LN69@CalculateB:

; 8439 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+372]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 364				; 0000016cH
	ret	12					; 0000000cH
$LN55@CalculateB:

; 8116 : 	CvPlot* pMinorCapitalPlot = pMinorCapital->plot();

	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 8117 : 	if(pMinorCapitalPlot == NULL)

	test	eax, eax
	jne	SHORT $LN54@CalculateB

; 8118 : 		return iFailScore;

	mov	BYTE PTR __$EHRec$[esp+388], al
	mov	eax, DWORD PTR _veMilitaryRankings$[esp+380]
	lea	edx, DWORD PTR _veMilitaryRankings$[esp+392]
	cmp	eax, edx
	jmp	SHORT $LN410@CalculateB
$LN54@CalculateB:

; 8119 : 	int iMinorCapitalX = pMinorCapitalPlot->getX();

	movsx	ecx, WORD PTR [eax]

; 8120 : 	int iMinorCapitalY = pMinorCapitalPlot->getY();

	movsx	edx, WORD PTR [eax+2]
	mov	DWORD PTR _iMinorCapitalX$[esp+380], ecx

; 8121 : 	int iMinorLocalPower = 0;
; 8122 : 	int iBullyLocalPower = 0;
; 8123 : 	CvPlot* pLoopPlot;
; 8124 : 	IDInfo* pUnitNode;
; 8125 : 	CvUnit* pLoopUnit;
; 8126 : 
; 8127 : 	// Include the minor's city power
; 8128 : 	iMinorLocalPower += pMinorCapital->GetPower();

	mov	ecx, esi
	mov	DWORD PTR _iMinorCapitalY$[esp+380], edx
	mov	DWORD PTR _iBullyLocalPower$[esp+380], 0
	call	?GetPower@CvCity@@QBEHXZ		; CvCity::GetPower
	mov	DWORD PTR _iMinorLocalPower$[esp+380], eax

; 8129 : 
; 8130 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 8131 : 	int iMaxDX, iDX;
; 8132 : 	for (int iDY = -iComparisonRadius; iDY <= iComparisonRadius; iDY++)
; 8133 : 	{
; 8134 : 		iMaxDX = iComparisonRadius - MAX(0, iDY);
; 8135 : 		for (iDX = -iComparisonRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 8136 : 		{
; 8137 : 			// No need for range check because loops are set up properly
; 8138 : 			pLoopPlot = plotXY(iMinorCapitalX, iMinorCapitalY, iDX, iDY);
; 8139 : #else
; 8140 : 	for(int iDX = -iComparisonRadius; iDX <= iComparisonRadius; iDX++)

	mov	eax, edi
	neg	eax
	cmp	eax, edi
	mov	DWORD PTR tv1123[esp+380], eax
	mov	DWORD PTR _iDX$227701[esp+380], eax
	jg	$LN51@CalculateB
	neg	eax
	mov	DWORD PTR tv1590[esp+380], eax
$LL53@CalculateB:

; 8141 : 	{
; 8142 : 		for(int iDY = -iComparisonRadius; iDY <= iComparisonRadius; iDY++)

	mov	ebx, DWORD PTR tv1123[esp+380]
	cmp	ebx, DWORD PTR _iComparisonRadius$[esp+380]
	jg	$LN52@CalculateB

; 8143 : 		{
; 8144 : 			pLoopPlot = ::plotXYWithRangeCheck(iMinorCapitalX, iMinorCapitalY, iDX, iDY, iComparisonRadius);

	xor	eax, eax
	cmp	DWORD PTR _iDX$227701[esp+380], eax
	setge	al
	mov	DWORD PTR tv1127[esp+380], eax
	mov	eax, ebx
	neg	eax
	mov	DWORD PTR tv1575[esp+380], eax
	npad	2
$LL50@CalculateB:
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	cmp	DWORD PTR tv1127[esp+380], ecx
	mov	ecx, DWORD PTR _iDX$227701[esp+380]
	jne	SHORT $LN217@CalculateB
	test	ecx, ecx
	jge	SHORT $LN221@CalculateB
	mov	ecx, DWORD PTR tv1590[esp+380]
$LN221@CalculateB:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN223@CalculateB
	mov	eax, DWORD PTR tv1575[esp+380]
$LN223@CalculateB:
	add	eax, ecx
	jmp	SHORT $LN228@CalculateB
$LN217@CalculateB:
	test	ecx, ecx
	jge	SHORT $LN225@CalculateB
	mov	ecx, DWORD PTR tv1590[esp+380]
$LN225@CalculateB:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN227@CalculateB
	mov	eax, DWORD PTR tv1575[esp+380]
$LN227@CalculateB:
	cmp	ecx, eax
	jl	SHORT $LN228@CalculateB
	mov	eax, ecx
$LN228@CalculateB:
	cmp	eax, DWORD PTR _iComparisonRadius$[esp+380]
	jg	$LN49@CalculateB
	mov	edx, DWORD PTR _iDX$227701[esp+380]
	mov	eax, DWORD PTR _iMinorCapitalY$[esp+380]
	mov	ecx, DWORD PTR _iMinorCapitalX$[esp+380]
	push	ebx
	push	edx
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 8145 : #endif
; 8146 : 
; 8147 : 			if(pLoopPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN49@CalculateB

; 8148 : 			{
; 8149 : 				// If there are Units here, loop through them
; 8150 : 				if(pLoopPlot->getNumUnits() > 0)

	mov	ecx, ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN49@CalculateB

; 8151 : 				{
; 8152 : 					pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, ebp
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	edi, eax

; 8153 : 
; 8154 : 					while(pUnitNode != NULL)

	test	edi, edi
	je	SHORT $LN49@CalculateB
$LL45@CalculateB:

; 8155 : 					{
; 8156 : 						pLoopUnit = ::getUnit(*pUnitNode);

	push	edi
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4

; 8157 : 						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	push	edi
	mov	ecx, ebp
	mov	esi, eax
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	edi, eax

; 8158 : 
; 8159 : 						// Is a combat unit
; 8160 : 						if(pLoopUnit && pLoopUnit->IsCombatUnit())

	test	esi, esi
	je	SHORT $LN380@CalculateB
	cmp	DWORD PTR [esi+1044], 0
	jle	SHORT $LN380@CalculateB

; 8161 : 						{
; 8162 : 							if(pLoopUnit->getOwner() == eBullyPlayer)

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, DWORD PTR _eBullyPlayer$[esp+376]
	jne	SHORT $LN42@CalculateB

; 8163 : 							{
; 8164 : 								iBullyLocalPower += pLoopUnit->GetPower();

	mov	ecx, esi
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	DWORD PTR _iBullyLocalPower$[esp+380], eax
	jmp	SHORT $LN380@CalculateB
$LN42@CalculateB:

; 8165 : 							}
; 8166 : 							else if(pLoopUnit->getOwner() == GetPlayer()->GetID())

	mov	edx, DWORD PTR _this$[esp+380]
	mov	ecx, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+44]
	jne	SHORT $LN380@CalculateB

; 8167 : 							{
; 8168 : 								iMinorLocalPower += pLoopUnit->GetPower();

	mov	ecx, esi
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	DWORD PTR _iMinorLocalPower$[esp+380], eax
$LN380@CalculateB:

; 8153 : 
; 8154 : 					while(pUnitNode != NULL)

	test	edi, edi
	jne	SHORT $LL45@CalculateB
$LN49@CalculateB:

; 8141 : 	{
; 8142 : 		for(int iDY = -iComparisonRadius; iDY <= iComparisonRadius; iDY++)

	dec	DWORD PTR tv1575[esp+380]
	inc	ebx
	cmp	ebx, DWORD PTR _iComparisonRadius$[esp+380]
	jle	$LL50@CalculateB
$LN52@CalculateB:

; 8129 : 
; 8130 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 8131 : 	int iMaxDX, iDX;
; 8132 : 	for (int iDY = -iComparisonRadius; iDY <= iComparisonRadius; iDY++)
; 8133 : 	{
; 8134 : 		iMaxDX = iComparisonRadius - MAX(0, iDY);
; 8135 : 		for (iDX = -iComparisonRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 8136 : 		{
; 8137 : 			// No need for range check because loops are set up properly
; 8138 : 			pLoopPlot = plotXY(iMinorCapitalX, iMinorCapitalY, iDX, iDY);
; 8139 : #else
; 8140 : 	for(int iDX = -iComparisonRadius; iDX <= iComparisonRadius; iDX++)

	mov	eax, DWORD PTR _iDX$227701[esp+380]
	dec	DWORD PTR tv1590[esp+380]
	inc	eax
	cmp	eax, DWORD PTR _iComparisonRadius$[esp+380]
	mov	DWORD PTR _iDX$227701[esp+380], eax
	jle	$LL53@CalculateB
$LN51@CalculateB:

; 8169 : 							}
; 8170 : 						}
; 8171 : 					}
; 8172 : 				}
; 8173 : 
; 8174 : 			}
; 8175 : 		}
; 8176 : 	}
; 8177 : 	float fLocalPowerRatio = (float)iBullyLocalPower / (float)iMinorLocalPower;

	fild	DWORD PTR _iBullyLocalPower$[esp+380]

; 8178 : 	int iLocalPowerScore = 0;

	xor	edi, edi
	fidiv	DWORD PTR _iMinorLocalPower$[esp+380]
	fstp	DWORD PTR _fLocalPowerRatio$[esp+380]

; 8179 : 	if(fLocalPowerRatio >= 3.0)

	fld	DWORD PTR _fLocalPowerRatio$[esp+380]
	fcom	QWORD PTR __real@4008000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN39@CalculateB
	fstp	ST(0)

; 8180 : 	{
; 8181 : #ifdef NQ_TRIBUTE_EASIER_WITH_LOCAL_POWER
; 8182 : 		iLocalPowerScore += 150;

	mov	edi, 150				; 00000096H
	jmp	SHORT $LN31@CalculateB
$LN39@CalculateB:

; 8183 : #else
; 8184 : 		iLocalPowerScore += 125;
; 8185 : #endif
; 8186 : 	}
; 8187 : 	else if(fLocalPowerRatio >= 2.0)

	fcom	QWORD PTR __real@4000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN37@CalculateB
	fstp	ST(0)

; 8188 : 	{
; 8189 : #ifdef NQ_TRIBUTE_EASIER_WITH_LOCAL_POWER
; 8190 : 		iLocalPowerScore += 120;

	mov	edi, 120				; 00000078H
	jmp	SHORT $LN31@CalculateB
$LN37@CalculateB:

; 8191 : #else
; 8192 : 		iLocalPowerScore += 100;
; 8193 : #endif
; 8194 : 	}
; 8195 : 	else if(fLocalPowerRatio >= 1.5)

	fcom	QWORD PTR __real@3ff8000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN35@CalculateB
	fstp	ST(0)

; 8196 : 	{
; 8197 : #ifdef NQ_TRIBUTE_EASIER_WITH_LOCAL_POWER
; 8198 : 		iLocalPowerScore += 90;

	mov	edi, 90					; 0000005aH
	jmp	SHORT $LN31@CalculateB
$LN35@CalculateB:

; 8199 : #else
; 8200 : 		iLocalPowerScore += 75;
; 8201 : #endif
; 8202 : 	}
; 8203 : 	else if(fLocalPowerRatio >= 1.0)

	fcom	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN33@CalculateB
	fstp	ST(0)

; 8204 : 	{
; 8205 : #ifdef NQ_TRIBUTE_EASIER_WITH_LOCAL_POWER
; 8206 : 		iLocalPowerScore += 60;

	mov	edi, 60					; 0000003cH
	jmp	SHORT $LN31@CalculateB
$LN33@CalculateB:

; 8207 : #else
; 8208 : 		iLocalPowerScore += 50;
; 8209 : #endif
; 8210 : 	}
; 8211 : 	else if(fLocalPowerRatio >= 0.5)

	fcomp	QWORD PTR __real@3fe0000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN31@CalculateB

; 8212 : 	{
; 8213 : #ifdef NQ_TRIBUTE_EASIER_WITH_LOCAL_POWER
; 8214 : 		iLocalPowerScore += 30;

	mov	edi, 30					; 0000001eH
$LN31@CalculateB:

; 8215 : #else
; 8216 : 		iLocalPowerScore += 25;
; 8217 : #endif
; 8218 : 	}
; 8219 : 	iScore += iLocalPowerScore;

	add	DWORD PTR _iScore$[esp+380], edi

; 8220 : 	
; 8221 : 	if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0

; 8222 : 	{
; 8223 : 		Localization::String strPositiveFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_POSITIVE");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	je	SHORT $LN381@CalculateB
	lea	eax, DWORD PTR _strPositiveFactor$227732[esp+380]
	push	OFFSET $SG227734
	push	eax
	call	ebx
	add	esp, 8

; 8224 : 		strPositiveFactor << iLocalPowerScore;

	push	edi
	lea	ecx, DWORD PTR _strPositiveFactor$227732[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 3
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8225 : 		strPositiveFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_MILITARY_PRESENCE";

	push	49					; 00000031H
	push	OFFSET $SG227751
	lea	ecx, DWORD PTR _strPositiveFactor$227732[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8226 : 		sFactors += strPositiveFactor.toUTF8();

	lea	ecx, DWORD PTR _strPositiveFactor$227732[esp+380]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8227 : 	}

	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strPositiveFactor$227732[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
	jmp	SHORT $LN30@CalculateB
$LN381@CalculateB:
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN30@CalculateB:

; 8228 : 
; 8229 : 	// **************************
; 8230 : 	// Social Policies
; 8231 : 	//
; 8232 : 	// Modifier to positive scores
; 8233 : 	// **************************
; 8234 : 	int iPoliciesScore = 0;
; 8235 : 	int iPoliciesMod = GET_PLAYER(eBullyPlayer).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_MINOR_BULLY_SCORE_MODIFIER);

	mov	ecx, DWORD PTR _eBullyPlayer$[esp+376]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	39					; 00000027H
	xor	esi, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 8236 : 	if (iPoliciesMod != 0)

	test	eax, eax
	je	SHORT $LN29@CalculateB
	mov	ecx, DWORD PTR _iGlobalMilitaryScore$[esp+380]
	add	ecx, edi

; 8237 : 	{
; 8238 : 		iPoliciesScore += iGlobalMilitaryScore;
; 8239 : 		iPoliciesScore += iLocalPowerScore;
; 8240 : 
; 8241 : 		iPoliciesScore *= iPoliciesMod;

	imul	ecx, eax

; 8242 : 		iPoliciesScore /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN29@CalculateB:

; 8243 : 	}
; 8244 : 	if (sTooltipSink && iPoliciesScore != 0)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN384@CalculateB
	test	esi, esi
	je	SHORT $LN384@CalculateB

; 8245 : 	{
; 8246 : 		Localization::String strPositiveFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_POSITIVE");

	lea	edx, DWORD PTR _strPositiveFactor$227756[esp+380]
	push	OFFSET $SG227758
	push	edx
	call	ebx
	add	esp, 8

; 8247 : 		strPositiveFactor << iPoliciesScore;

	push	esi
	lea	ecx, DWORD PTR _strPositiveFactor$227756[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 4
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8248 : 		strPositiveFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_GUNBOAT_DIPLOMACY";

	push	49					; 00000031H
	push	OFFSET $SG227759
	lea	ecx, DWORD PTR _strPositiveFactor$227756[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8249 : 		sFactors += strPositiveFactor.toUTF8();

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strPositiveFactor$227756[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8250 : 	}

	lea	ecx, DWORD PTR _strPositiveFactor$227756[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
	jmp	SHORT $LN28@CalculateB
$LN384@CalculateB:
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
$LN28@CalculateB:

; 8251 : 	iScore += iPoliciesScore;

	add	DWORD PTR _iScore$[esp+380], esi

; 8252 : 
; 8253 : 	// **************************
; 8254 : 	// Base Reluctance
; 8255 : 	//
; 8256 : 	// -110
; 8257 : 	// **************************
; 8258 : 	const int iBaseReluctanceScore = -110;
; 8259 : 	
; 8260 : 	if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN382@CalculateB

; 8261 : 	{
; 8262 : 		Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	eax, DWORD PTR _strNegativeFactor$227762[esp+380]
	push	OFFSET $SG227764
	push	eax
	call	ebx
	add	esp, 8

; 8263 : 		strNegativeFactor << iBaseReluctanceScore;

	push	-110					; ffffff92H
	lea	ecx, DWORD PTR _strNegativeFactor$227762[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 5
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8264 : 		strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_BASE_RELUCTANCE";

	push	47					; 0000002fH
	push	OFFSET $SG227766
	lea	ecx, DWORD PTR _strNegativeFactor$227762[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8265 : 		sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227762[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8266 : 	}

	lea	ecx, DWORD PTR _strNegativeFactor$227762[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN382@CalculateB:

; 8267 : 
; 8268 : 	iScore += iBaseReluctanceScore;
; 8269 : 
; 8270 : 	// **************************
; 8271 : 	// Current influence of major
; 8272 : 	//
; 8273 : 	// -999 ~ -0
; 8274 : 	// **************************
; 8275 : 	if(GetEffectiveFriendshipWithMajor(eBullyPlayer) < GC.getFRIENDSHIP_THRESHOLD_CAN_BULLY())

	mov	ecx, DWORD PTR _eBullyPlayer$[esp+376]
	mov	esi, DWORD PTR _this$[esp+380]
	sub	DWORD PTR _iScore$[esp+380], 110	; 0000006eH
	push	ecx
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN264@CalculateB
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN267@CalculateB
$LN264@CalculateB:
	mov	edx, DWORD PTR _eBullyPlayer$[esp+376]
	mov	ecx, DWORD PTR [esi+edx*4+2024]
$LN267@CalculateB:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2848
	jge	SHORT $LN25@CalculateB

; 8276 : 	{
; 8277 : 		int iInfluenceScore = iFailScore;
; 8278 : 		iScore += iInfluenceScore;

	sub	DWORD PTR _iScore$[esp+380], 300	; 0000012cH

; 8279 : 		if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN25@CalculateB

; 8280 : 		{
; 8281 : 			Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	ecx, DWORD PTR _strNegativeFactor$227770[esp+380]
	push	OFFSET $SG227772
	push	ecx
	call	ebx
	add	esp, 8

; 8282 : 			strNegativeFactor << iInfluenceScore;

	push	-300					; fffffed4H
	lea	ecx, DWORD PTR _strNegativeFactor$227770[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 6
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8283 : 			strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_LOW_INFLUENCE";

	push	45					; 0000002dH
	push	OFFSET $SG227789
	lea	ecx, DWORD PTR _strNegativeFactor$227770[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8284 : 			sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227770[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8285 : 		}

	lea	ecx, DWORD PTR _strNegativeFactor$227770[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN25@CalculateB:

; 8286 : 	}
; 8287 : 
; 8288 : 	// **************************
; 8289 : 	// Previous bully attempts
; 8290 : 	//
; 8291 : 	// -300 ~ -0
; 8292 : 	// **************************
; 8293 : 	int iLastBullyTurn = GetTurnLastBulliedByMajor(eBullyPlayer);

	mov	edx, DWORD PTR _this$[esp+380]
	mov	eax, DWORD PTR _eBullyPlayer$[esp+376]
	mov	esi, DWORD PTR [edx+eax*4+2816]

; 8294 : 	if(iLastBullyTurn >= 0)

	test	esi, esi
	jl	$LN19@CalculateB

; 8295 : 	{
; 8296 : 		if(iLastBullyTurn + 10 >= GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	lea	ecx, DWORD PTR [esi+10]
	cmp	ecx, eax
	jl	SHORT $LN23@CalculateB

; 8297 : 		{
; 8298 : 			int iBulliedVeryRecentlyScore = iFailScore;
; 8299 : 			iScore += iBulliedVeryRecentlyScore;

	sub	DWORD PTR _iScore$[esp+380], 300	; 0000012cH

; 8300 : 			if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	$LN19@CalculateB

; 8301 : 			{
; 8302 : 				Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	edx, DWORD PTR _strNegativeFactor$227795[esp+380]
	push	OFFSET $SG227797
	push	edx
	call	ebx
	add	esp, 8

; 8303 : 				strNegativeFactor << iBulliedVeryRecentlyScore;

	push	-300					; fffffed4H
	lea	ecx, DWORD PTR _strNegativeFactor$227795[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 7
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8304 : 				strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_BULLIED_VERY_RECENTLY";

	push	53					; 00000035H
	push	OFFSET $SG227814

; 8305 : 				sFactors += strNegativeFactor.toUTF8();
; 8306 : 			}
; 8307 : 		}

	jmp	SHORT $LN407@CalculateB
$LN23@CalculateB:

; 8308 : 		else if(iLastBullyTurn + 20 >= GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	esi, 20					; 00000014H
	cmp	esi, eax
	jl	SHORT $LN19@CalculateB

; 8309 : 		{
; 8310 : 			int iBulliedRecentlyScore = -40;
; 8311 : 			iScore += iBulliedRecentlyScore;

	sub	DWORD PTR _iScore$[esp+380], 40		; 00000028H

; 8312 : 			if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN19@CalculateB

; 8313 : 			{
; 8314 : 				Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	eax, DWORD PTR _strNegativeFactor$227819[esp+380]
	push	OFFSET $SG227821
	push	eax
	call	ebx
	add	esp, 8

; 8315 : 				strNegativeFactor << iBulliedRecentlyScore;

	push	-40					; ffffffd8H
	lea	ecx, DWORD PTR _strNegativeFactor$227819[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 8
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8316 : 				strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_BULLIED_RECENTLY";

	push	48					; 00000030H
	push	OFFSET $SG227838
$LN407@CalculateB:
	lea	ecx, DWORD PTR _strNegativeFactor$227819[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8317 : 				sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227819[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8318 : 			}

	lea	ecx, DWORD PTR _strNegativeFactor$227819[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN19@CalculateB:

; 8319 : 		}
; 8320 : 	}
; 8321 : 
; 8322 : 	// **************************
; 8323 : 	// Tribute type
; 8324 : 	//
; 8325 : 	// -30 ~ -0
; 8326 : 	// **************************
; 8327 : 	if (bForUnit)

	cmp	BYTE PTR _bForUnit$[esp+376], 0
	je	$LN386@CalculateB

; 8328 : 	{
; 8329 : 		int iUnitScore = -30;
; 8330 : 		iScore += iUnitScore;

	sub	DWORD PTR _iScore$[esp+380], 30		; 0000001eH

; 8331 : 		if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN385@CalculateB

; 8332 : 		{
; 8333 : 			Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	ecx, DWORD PTR _strNegativeFactor$227842[esp+380]
	push	OFFSET $SG227844
	push	ecx
	call	ebx
	add	esp, 8

; 8334 : 			strNegativeFactor << iUnitScore;

	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	-30					; ffffffe2H
	lea	ecx, DWORD PTR _strNegativeFactor$227842[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 9
	call	esi

; 8335 : 			strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_UNIT_RELUCTANCE";

	push	47					; 0000002fH
	push	OFFSET $SG227845
	lea	ecx, DWORD PTR _strNegativeFactor$227842[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8336 : 			sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227842[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8337 : 		}

	lea	ecx, DWORD PTR _strNegativeFactor$227842[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
	jmp	SHORT $LN17@CalculateB
$LN385@CalculateB:
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
$LN17@CalculateB:

; 8338 : 	}
; 8339 : 
; 8340 : 	// **************************
; 8341 : 	// City-State population
; 8342 : 	//
; 8343 : 	// -300 ~ -0
; 8344 : 	// **************************
; 8345 : 	if (bForUnit)
; 8346 : 	{
; 8347 : 		if (GetPlayer()->getCapitalCity() == NULL || GetPlayer()->getCapitalCity()->getPopulation() < 4)

	mov	edx, DWORD PTR _this$[esp+380]
	mov	ecx, DWORD PTR [edx]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN14@CalculateB
	mov	eax, DWORD PTR _this$[esp+380]
	mov	ecx, DWORD PTR [eax]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 4
	jge	SHORT $LN388@CalculateB
$LN14@CalculateB:

; 8348 : 		{
; 8349 : 			int iPopulationScore = iFailScore;
; 8350 : 			iScore += iPopulationScore;

	sub	DWORD PTR _iScore$[esp+380], 300	; 0000012cH

; 8351 : 			if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN388@CalculateB

; 8352 : 			{
; 8353 : 				Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	ecx, DWORD PTR _strNegativeFactor$227851[esp+380]
	push	OFFSET $SG227853
	push	ecx
	call	ebx
	add	esp, 8

; 8354 : 				strNegativeFactor << iPopulationScore;

	push	-300					; fffffed4H
	lea	ecx, DWORD PTR _strNegativeFactor$227851[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 10		; 0000000aH
	call	esi

; 8355 : 				strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_LOW_POPULATION";

	push	46					; 0000002eH
	push	OFFSET $SG227870
	lea	ecx, DWORD PTR _strNegativeFactor$227851[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8356 : 				sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227851[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8357 : 			}

	lea	ecx, DWORD PTR _strNegativeFactor$227851[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
	jmp	SHORT $LN388@CalculateB
$LN386@CalculateB:
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
$LN388@CalculateB:

; 8358 : 		}
; 8359 : 	}
; 8360 : 
; 8361 : 	// **************************
; 8362 : 	// Passive Support from other majors
; 8363 : 	//
; 8364 : 	// -10 ~ -0
; 8365 : 	// **************************
; 8366 : 	if(GetAlly() != NO_PLAYER && GetAlly() != eBullyPlayer)

	mov	edx, DWORD PTR _this$[esp+380]
	mov	eax, DWORD PTR [edx+2012]
	cmp	eax, -1
	je	SHORT $LN387@CalculateB
	cmp	eax, DWORD PTR _eBullyPlayer$[esp+376]
	je	SHORT $LN387@CalculateB

; 8367 : 	{
; 8368 : 		int iAllyScore = -10;
; 8369 : 		iScore += iAllyScore;

	sub	DWORD PTR _iScore$[esp+380], 10		; 0000000aH

; 8370 : 		if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN387@CalculateB

; 8371 : 		{
; 8372 : 			Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	eax, DWORD PTR _strNegativeFactor$227874[esp+380]
	push	OFFSET $SG227876
	push	eax
	call	ebx
	add	esp, 8

; 8373 : 			strNegativeFactor << iAllyScore;

	push	-10					; fffffff6H
	lea	ecx, DWORD PTR _strNegativeFactor$227874[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 11		; 0000000bH
	call	esi

; 8374 : 			strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_ALLIES";

	push	38					; 00000026H
	push	OFFSET $SG227893
	lea	ecx, DWORD PTR _strNegativeFactor$227874[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8375 : 			sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227874[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8376 : 		}

	lea	ecx, DWORD PTR _strNegativeFactor$227874[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN387@CalculateB:

; 8377 : 	}
; 8378 : 
; 8379 : 	// **************************
; 8380 : 	// Pledges of Protection from other majors
; 8381 : 	//
; 8382 : 	// -20 ~ -0
; 8383 : 	// **************************
; 8384 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	ecx, DWORD PTR _this$[esp+380]
	mov	edx, DWORD PTR _eBullyPlayer$[esp+376]
	xor	eax, eax
$LL10@CalculateB:

; 8385 : 	{
; 8386 : 		int iProtectionScore = 0;
; 8387 : 		eMajorLoop = (PlayerTypes) iMajorLoop;
; 8388 : 		if(eMajorLoop != eBullyPlayer && IsProtectedByMajor(eMajorLoop))

	cmp	eax, edx
	je	SHORT $LN9@CalculateB
	test	eax, eax
	jl	SHORT $LN9@CalculateB
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN9@CalculateB
	cmp	BYTE PTR [eax+ecx+3146], 0
	jne	SHORT $LN373@CalculateB
$LN9@CalculateB:

; 8377 : 	}
; 8378 : 
; 8379 : 	// **************************
; 8380 : 	// Pledges of Protection from other majors
; 8381 : 	//
; 8382 : 	// -20 ~ -0
; 8383 : 	// **************************
; 8384 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	inc	eax
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL10@CalculateB

; 8385 : 	{
; 8386 : 		int iProtectionScore = 0;
; 8387 : 		eMajorLoop = (PlayerTypes) iMajorLoop;
; 8388 : 		if(eMajorLoop != eBullyPlayer && IsProtectedByMajor(eMajorLoop))

	jmp	SHORT $LN391@CalculateB
$LN373@CalculateB:

; 8389 : 		{
; 8390 : 			iProtectionScore += -20;
; 8391 : 			iScore += iProtectionScore;

	sub	DWORD PTR _iScore$[esp+380], 20		; 00000014H

; 8392 : 			if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN391@CalculateB

; 8393 : 			{
; 8394 : 				Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	ecx, DWORD PTR _strNegativeFactor$227902[esp+380]
	push	OFFSET $SG227904
	push	ecx
	call	ebx
	add	esp, 8

; 8395 : 				strNegativeFactor << iProtectionScore;

	push	-20					; ffffffecH
	lea	ecx, DWORD PTR _strNegativeFactor$227902[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 12		; 0000000cH
	call	esi

; 8396 : 				strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_PLEDGES_TO_PROTECT";

	push	50					; 00000032H
	push	OFFSET $SG227921
	lea	ecx, DWORD PTR _strNegativeFactor$227902[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8397 : 				sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227902[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8398 : 			}

	lea	ecx, DWORD PTR _strNegativeFactor$227902[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN391@CalculateB:

; 8399 : 			break;
; 8400 : 		}
; 8401 : 	}
; 8402 : 
; 8403 : 	// **************************
; 8404 : 	// Minor Civ Type
; 8405 : 	//
; 8406 : 	// -20 ~ -0
; 8407 : 	// **************************
; 8408 : 	if(GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)

	mov	edx, DWORD PTR _this$[esp+380]
	cmp	DWORD PTR [edx+8], 2
	jne	SHORT $LN4@CalculateB

; 8409 : 	{
; 8410 : 		int iHostileScore = -10;
; 8411 : 		iScore += iHostileScore;

	sub	DWORD PTR _iScore$[esp+380], 10		; 0000000aH

; 8412 : 		if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN4@CalculateB

; 8413 : 		{
; 8414 : 			Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	eax, DWORD PTR _strNegativeFactor$227925[esp+380]
	push	OFFSET $SG227927
	push	eax
	call	ebx
	add	esp, 8

; 8415 : 			strNegativeFactor << iHostileScore;

	push	-10					; fffffff6H
	lea	ecx, DWORD PTR _strNegativeFactor$227925[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 13		; 0000000dH
	call	esi

; 8416 : 			strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_HOSTILE";

	push	39					; 00000027H
	push	OFFSET $SG227944
	lea	ecx, DWORD PTR _strNegativeFactor$227925[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8417 : 			sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227925[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8418 : 		}

	lea	ecx, DWORD PTR _strNegativeFactor$227925[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN4@CalculateB:

; 8419 : 	}
; 8420 : 	if(GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)

	mov	ecx, DWORD PTR _this$[esp+380]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN2@CalculateB
	cmp	DWORD PTR [eax+272], 1
	jne	SHORT $LN2@CalculateB

; 8421 : 	{
; 8422 : 		int iMilitaristicScore = -10;
; 8423 : 		iScore += iMilitaristicScore;

	sub	DWORD PTR _iScore$[esp+380], 10		; 0000000aH

; 8424 : 		if (sTooltipSink)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	$LN1@CalculateB

; 8425 : 		{
; 8426 : 			Localization::String strNegativeFactor = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_FACTOR_NEGATIVE");

	lea	eax, DWORD PTR _strNegativeFactor$227948[esp+380]
	push	OFFSET $SG227950
	push	eax
	call	ebx
	add	esp, 8

; 8427 : 			strNegativeFactor << iMilitaristicScore;

	push	-10					; fffffff6H
	lea	ecx, DWORD PTR _strNegativeFactor$227948[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 14		; 0000000eH
	call	esi

; 8428 : 			strNegativeFactor << "TXT_KEY_POP_CSTATE_BULLY_FACTOR_MILITARISTIC";

	push	44					; 0000002cH
	push	OFFSET $SG227967
	lea	ecx, DWORD PTR _strNegativeFactor$227948[esp+388]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 8429 : 			sFactors += strNegativeFactor.toUTF8();

	lea	ecx, DWORD PTR _strNegativeFactor$227948[esp+380]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _sFactors$[esp+384]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 8430 : 		}

	lea	ecx, DWORD PTR _strNegativeFactor$227948[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 1
	call	ebp
$LN2@CalculateB:

; 8431 : 	}
; 8432 : 
; 8433 : 	if (sTooltipSink != NULL)

	cmp	DWORD PTR _sTooltipSink$[esp+376], 0
	je	SHORT $LN1@CalculateB

; 8434 : 	{
; 8435 : 		(*sTooltipSink) += sFactors;

	lea	ecx, DWORD PTR _sFactors$[esp+380]
	push	ecx
	mov	ecx, DWORD PTR _sTooltipSink$[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN1@CalculateB:

; 8436 : 	}
; 8437 : 
; 8438 : 	return iScore;

	mov	eax, DWORD PTR _veMilitaryRankings$[esp+380]
	lea	edx, DWORD PTR _veMilitaryRankings$[esp+392]
	mov	BYTE PTR __$EHRec$[esp+388], 0
	cmp	eax, edx
	je	SHORT $LN351@CalculateB
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN351@CalculateB:
	lea	ecx, DWORD PTR _sFactors$[esp+380]
	mov	DWORD PTR __$EHRec$[esp+388], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _iScore$[esp+380]
	jmp	$LN393@CalculateB
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _sFactors$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _veMilitaryRankings$[ebp]
	jmp	??1?$CvWeightedVector@W4PlayerTypes@@$0BG@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,22,1>::~CvWeightedVector<enum PlayerTypes,22,1>
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strPositiveFactor$227665[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$3:
	lea	ecx, DWORD PTR _strPositiveFactor$227732[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$4:
	lea	ecx, DWORD PTR _strPositiveFactor$227756[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$5:
	lea	ecx, DWORD PTR _strNegativeFactor$227762[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$6:
	lea	ecx, DWORD PTR _strNegativeFactor$227770[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$7:
	lea	ecx, DWORD PTR _strNegativeFactor$227795[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$8:
	lea	ecx, DWORD PTR _strNegativeFactor$227819[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$9:
	lea	ecx, DWORD PTR _strNegativeFactor$227842[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$10:
	lea	ecx, DWORD PTR _strNegativeFactor$227851[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$11:
	lea	ecx, DWORD PTR _strNegativeFactor$227874[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$12:
	lea	ecx, DWORD PTR _strNegativeFactor$227902[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$13:
	lea	ecx, DWORD PTR _strNegativeFactor$227925[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z$14:
	lea	ecx, DWORD PTR _strNegativeFactor$227948[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ENDP ; CvMinorCivAI::CalculateBullyMetric
PUBLIC	?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorBullyGold
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorBullyGold, COMDAT
; _this$ = ecx

; 8443 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8444 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8445 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN2@CanMajorBu@4

; 8446 : 
; 8447 : 	// Can't bully us if we're dead!
; 8448 : 	if(!GetPlayer()->isAlive())

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+2256], 0

; 8449 : 		return false;

	je	SHORT $LN2@CanMajorBu@4

; 8450 : 
; 8451 : 	int iScore = CalculateBullyMetric(ePlayer, /*bForUnit*/false);

	push	0
	push	0
	push	eax
	mov	ecx, esi
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric

; 8452 : 	return CanMajorBullyGold(ePlayer, iScore);

	mov	edx, DWORD PTR [esi]
	cmp	BYTE PTR [edx+2256], 0
	je	SHORT $LN2@CanMajorBu@4
	test	eax, eax
	setge	al
	pop	esi

; 8453 : }

	ret	4
$LN2@CanMajorBu@4:

; 8443 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8444 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8445 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 8453 : }

	ret	4
?CanMajorBullyGold@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorBullyGold
_TEXT	ENDS
PUBLIC	?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetMajorBullyGoldDetails
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T266989 = -284						; size = 4
_sFactors$ = -280					; size = 28
_sResult$ = -252					; size = 80
_sFear$ = -172						; size = 80
$T266986 = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetMajorBullyGoldDetails, COMDAT
; _this$ = ecx

; 8470 : {

	push	-1
	push	__ehhandler$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 272				; 00000110H
	push	esi
	push	edi

; 8471 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8472 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8473 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return "";

	mov	edi, DWORD PTR _ePlayer$[esp+288]
	mov	esi, ecx
	mov	DWORD PTR $T266989[esp+292], 0
	cmp	edi, 21					; 00000015H
	ja	$LN2@GetMajorBu
	push	ebx
	push	ebp

; 8474 : 	
; 8475 : 	CvString sFactors = "";

	push	OFFSET $SG227995
	lea	ecx, DWORD PTR _sFactors$[esp+304]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 8476 : 	int iScore = CalculateBullyMetric(ePlayer, /*bForUnit*/false, &sFactors);

	lea	eax, DWORD PTR _sFactors$[esp+300]
	push	eax
	push	0
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+320], 1
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric

; 8477 : 	bool bCanBully = CanMajorBullyGold(ePlayer, iScore);

	mov	esi, DWORD PTR [esi]
	cmp	BYTE PTR [esi+2256], 0
	mov	edi, eax
	jne	SHORT $LN22@GetMajorBu
	xor	bl, bl
	jmp	SHORT $LN25@GetMajorBu
$LN22@GetMajorBu:
	test	edi, edi
	setge	bl
$LN25@GetMajorBu:

; 8478 : 
; 8479 : 	Localization::String sFear = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_AFRAID");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _sFear$[esp+300]
	push	OFFSET $SG228000
	push	ecx
	call	esi
	add	esp, 8

; 8480 : 	if (!bCanBully)

	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+308], 2
	test	bl, bl
	jne	SHORT $LN1@GetMajorBu

; 8481 : 	{
; 8482 : 		sFear = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_RESILIENT");

	lea	edx, DWORD PTR $T266986[esp+300]
	push	OFFSET $SG228003
	push	edx
	call	esi
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _sFear$[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T266986[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	ebp
$LN1@GetMajorBu:

; 8483 : 	}
; 8484 : 	sFear << iScore;

	push	edi
	lea	ecx, DWORD PTR _sFear$[esp+304]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8485 : 
; 8486 : 	Localization::String sResult = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_GOLD_TT");

	lea	eax, DWORD PTR _sResult$[esp+300]
	push	OFFSET $SG228006
	push	eax
	call	esi
	add	esp, 8

; 8487 : 	sResult << sFear.toUTF8() << sFactors;

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _sFear$[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 4
	call	esi
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _sResult$[esp+304]
	call	edi
	lea	ecx, DWORD PTR _sFactors$[esp+300]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sResult$[esp+304]
	call	edi

; 8488 : 
; 8489 : 	return sResult.toUTF8();

	lea	ecx, DWORD PTR _sResult$[esp+300]
	call	esi
	test	eax, eax
	jne	SHORT $LN44@GetMajorBu
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN44@GetMajorBu:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+296]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _sResult$[esp+300]
	mov	DWORD PTR $T266989[esp+300], 1
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	ebp
	lea	ecx, DWORD PTR _sFear$[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 1
	call	ebp
	lea	ecx, DWORD PTR _sFactors$[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebp
	pop	ebx
	jmp	SHORT $LN50@GetMajorBu
$LN2@GetMajorBu:

; 8471 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8472 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8473 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+288]
	push	OFFSET $SG227993
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
$LN50@GetMajorBu:

; 8490 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+292]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 284				; 0000011cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _sFactors$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _sFear$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T266986[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _sResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$0:
	mov	eax, DWORD PTR $T266989[ebp]
	and	eax, 1
	je	$LN7@GetMajorBu
	and	DWORD PTR $T266989[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN7@GetMajorBu:
	ret	0
__ehhandler$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMajorBullyGoldDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetMajorBullyGoldDetails
PUBLIC	?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorBullyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMinorCivAI::CanMajorBullyUnit, COMDAT
; _this$ = ecx

; 8494 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8495 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8496 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	eax, 21					; 00000015H
	ja	SHORT $LN2@CanMajorBu@5

; 8497 : 
; 8498 : 	// Can't bully us if we're dead!
; 8499 : 	if(!GetPlayer()->isAlive())

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+2256], 0

; 8500 : 		return false;

	je	SHORT $LN2@CanMajorBu@5

; 8501 : 
; 8502 : 	int iScore = CalculateBullyMetric(ePlayer, /*bForUnit*/true);

	push	0
	push	1
	push	eax
	mov	ecx, esi
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric

; 8503 : 	return CanMajorBullyUnit(ePlayer, iScore);

	mov	edx, DWORD PTR [esi]
	cmp	BYTE PTR [edx+2256], 0
	je	SHORT $LN2@CanMajorBu@5
	test	eax, eax
	setge	al
	pop	esi

; 8504 : }

	ret	4
$LN2@CanMajorBu@5:

; 8494 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8495 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8496 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 8504 : }

	ret	4
?CanMajorBullyUnit@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::CanMajorBullyUnit
_TEXT	ENDS
PUBLIC	?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetMajorBullyUnitDetails
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T267119 = -284						; size = 4
_sFactors$ = -280					; size = 28
_sResult$ = -252					; size = 80
_sFear$ = -172						; size = 80
$T267115 = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetMajorBullyUnitDetails, COMDAT
; _this$ = ecx

; 8521 : {

	push	-1
	push	__ehhandler$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 272				; 00000110H
	push	esi
	push	edi

; 8522 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8523 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8524 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return "";

	mov	edi, DWORD PTR _ePlayer$[esp+288]
	mov	esi, ecx
	mov	DWORD PTR $T267119[esp+292], 0
	cmp	edi, 21					; 00000015H
	ja	$LN3@GetMajorBu@2
	push	ebx
	push	ebp

; 8525 : 
; 8526 : 	CvString sFactors = "";

	push	OFFSET $SG228033
	lea	ecx, DWORD PTR _sFactors$[esp+304]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 8527 : 	int iScore = CalculateBullyMetric(ePlayer, /*bForUnit*/true, &sFactors);

	lea	eax, DWORD PTR _sFactors$[esp+300]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+320], 1
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric

; 8528 : 	bool bCanBully = CanMajorBullyUnit(ePlayer, iScore);

	mov	esi, DWORD PTR [esi]
	cmp	BYTE PTR [esi+2256], 0
	mov	ebp, eax
	jne	SHORT $LN23@GetMajorBu@2
	xor	bl, bl
	jmp	SHORT $LN26@GetMajorBu@2
$LN23@GetMajorBu@2:
	test	ebp, ebp
	setge	bl
$LN26@GetMajorBu@2:

; 8529 : 	UnitTypes eUnitType = (UnitTypes) GC.getInfoTypeForString("UNIT_WORKER"); //antonjs: todo: XML/function

	push	0
	push	OFFSET $SG228038
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 8530 : 	CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnitType);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	edi, eax

; 8531 : 	CvAssert(pUnitInfo);
; 8532 : 	if (!pUnitInfo)

	test	edi, edi
	jne	SHORT $LN2@GetMajorBu@2

; 8533 : 		return "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+296]
	push	OFFSET $SG228041
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR $T267119[esp+300], 1
	jmp	$LN65@GetMajorBu@2
$LN2@GetMajorBu@2:

; 8534 : 
; 8535 : 	Localization::String sFear = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_AFRAID");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _sFear$[esp+300]
	push	OFFSET $SG228044
	push	ecx
	call	esi
	add	esp, 8

; 8536 : 	if (!bCanBully)

	test	bl, bl
	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+308], 2
	jne	SHORT $LN1@GetMajorBu@2

; 8537 : 	{
; 8538 : 		sFear = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_RESILIENT");

	lea	edx, DWORD PTR $T267115[esp+300]
	push	OFFSET $SG228047
	push	edx
	call	esi
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _sFear$[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267115[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	ebx
$LN1@GetMajorBu@2:

; 8539 : 	}
; 8540 : 	sFear << iScore;

	push	ebp
	lea	ecx, DWORD PTR _sFear$[esp+304]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8541 : 
; 8542 : 	Localization::String sResult = Localization::Lookup("TXT_KEY_POP_CSTATE_BULLY_UNIT_TT");

	lea	eax, DWORD PTR _sResult$[esp+300]
	push	OFFSET $SG228050
	push	eax
	call	esi
	add	esp, 8

; 8543 : 	sResult << sFear.toUTF8() << sFactors << pUnitInfo->GetDescriptionKey();

	lea	ecx, DWORD PTR [edi+64]
	mov	BYTE PTR __$EHRec$[esp+308], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _sFear$[esp+300]
	mov	edi, eax
	call	ebp
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _sResult$[esp+304]
	call	esi
	lea	ecx, DWORD PTR _sFactors$[esp+300]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _sResult$[esp+304]
	call	esi
	push	edi
	lea	ecx, DWORD PTR _sResult$[esp+304]
	call	esi

; 8544 : 
; 8545 : 	return sResult.toUTF8();

	lea	ecx, DWORD PTR _sResult$[esp+300]
	call	ebp
	test	eax, eax
	jne	SHORT $LN57@GetMajorBu@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN57@GetMajorBu@2:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+296]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _sResult$[esp+300]
	mov	DWORD PTR $T267119[esp+300], 1
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	ebx
	lea	ecx, DWORD PTR _sFear$[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 1
	call	ebx
$LN65@GetMajorBu@2:
	lea	ecx, DWORD PTR _sFactors$[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebp
	mov	eax, esi
	pop	ebx
$LN5@GetMajorBu@2:

; 8546 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+292]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 284				; 0000011cH
	ret	8
$LN3@GetMajorBu@2:

; 8522 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 8523 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 8524 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+288]
	push	OFFSET $SG228031
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	jmp	SHORT $LN5@GetMajorBu@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _sFactors$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _sFear$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T267115[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _sResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z$0:
	mov	eax, DWORD PTR $T267119[ebp]
	and	eax, 1
	je	$LN8@GetMajorBu@2
	and	DWORD PTR $T267119[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN8@GetMajorBu@2:
	ret	0
__ehhandler$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMajorBullyUnitDetails@CvMinorCivAI@@QAE?AVCvString@@W4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetMajorBullyUnitDetails
PUBLIC	?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::DoGoldGiftFromMajor
EXTRN	?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetNumTurnsBeforeMinorAlliesRefuseBribes
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z$1
__ehfuncinfo$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
$T267224 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iFriendshipChange$228512 = 8				; size = 4
_ePlayer$ = 8						; size = 4
$T267223 = 12						; size = 4
_iGold$ = 12						; size = 4
?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::DoGoldGiftFromMajor, COMDAT
; _this$ = ecx

; 9050 : {

	push	-1
	push	__ehhandler$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	ebp

; 9051 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 9052 : 	PlayerTypes iAlly = GetAlly();
; 9053 : 	if (iAlly != NO_PLAYER && iAlly != ePlayer)

	mov	ebp, DWORD PTR _ePlayer$[esp+20]
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+2012]
	cmp	eax, -1
	je	SHORT $LN3@DoGoldGift
	cmp	eax, ebp
	je	SHORT $LN3@DoGoldGift

; 9054 : 	{
; 9055 : 		int iNumTurns = GET_PLAYER(iAlly).GetNumTurnsBeforeMinorAlliesRefuseBribes();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvPlayer@@QBEHXZ ; CvPlayer::GetNumTurnsBeforeMinorAlliesRefuseBribes
	mov	esi, eax

; 9056 : 		if (iNumTurns > 0 && GetAlliedTurns() >= iNumTurns)

	test	esi, esi
	jle	SHORT $LN3@DoGoldGift
	or	eax, -1
	cmp	DWORD PTR [edi+2012], eax
	je	SHORT $LN13@DoGoldGift
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR [edi+2016]
$LN13@DoGoldGift:
	cmp	eax, esi
	jge	$LN5@DoGoldGift
$LN3@DoGoldGift:

; 9057 : 		{
; 9058 : 			return;
; 9059 : 		}
; 9060 : 	}
; 9061 : #endif
; 9062 : 	if(GET_PLAYER(ePlayer).GetTreasury()->GetGold() >= iGold)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, ebp
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ebx, DWORD PTR _iGold$[esp+28]
	cmp	eax, ebx
	jl	$LN61@DoGoldGift

; 9063 : 	{
; 9064 : 		int iFriendshipChange = GetFriendshipFromGoldGift(ePlayer, iGold);

	push	ebx
	push	ebp
	mov	ecx, edi
	call	?GetFriendshipFromGoldGift@CvMinorCivAI@@QAEHW4PlayerTypes@@H@Z ; CvMinorCivAI::GetFriendshipFromGoldGift
	mov	DWORD PTR _iFriendshipChange$228512[esp+28], eax

; 9065 : 		if(iFriendshipChange > 0)

	test	eax, eax
	jle	SHORT $LN1@DoGoldGift

; 9066 : 			GET_PLAYER(ePlayer).GetTreasury()->LogExpenditure(GetPlayer()->GetMinorCivAI()->GetNamesListAsString(0), iGold,4);

	push	4
	push	ebx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T267223[esp+64], esp
	sub	esp, 272				; 00000110H
	mov	eax, esp
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR $T267224[esp+340], esp
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+352], 0
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+352], -1
	call	?GetNamesListAsString@CvMinorCivAI@@QAE?AVCvString@@V?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@@Z ; CvMinorCivAI::GetNamesListAsString
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR __$EHRec$[esp+76], 1
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure
$LN1@DoGoldGift:

; 9067 : 
; 9068 : 		GET_PLAYER(ePlayer).GetTreasury()->ChangeGold(-iGold);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, ebx
	neg	edx
	add	ecx, esi
	push	edx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 9069 : 		
; 9070 : 		ChangeNumGoldGifted(ePlayer, iGold);

	cmp	ebp, 21					; 00000015H
	ja	SHORT $LN42@DoGoldGift
	mov	eax, DWORD PTR [edi+ebp*4+2728]
	add	eax, ebx
	mov	DWORD PTR [edi+ebp*4+2728], eax
$LN42@DoGoldGift:

; 9071 : 		
; 9072 : 		ChangeFriendshipWithMajor(ePlayer, iFriendshipChange);

	mov	eax, DWORD PTR _iFriendshipChange$228512[esp+28]
	imul	eax, 100				; 00000064H
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN50@DoGoldGift
	cmp	ebp, 21					; 00000015H
	ja	SHORT $LN57@DoGoldGift
	mov	eax, DWORD PTR [edi+ebp*4+2024]
	jmp	SHORT $LN59@DoGoldGift
$LN57@DoGoldGift:
	xor	eax, eax
$LN59@DoGoldGift:
	push	0
	add	eax, ecx
	push	eax
	push	ebp
	mov	ecx, edi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN50@DoGoldGift:

; 9073 : 
; 9074 : 		// In case we had a Gold Gift quest active, complete it now
; 9075 : 		DoTestActiveQuestsForPlayer(ePlayer, /*bTestComplete*/ true, /*bTestObsolete*/ false, MINOR_CIV_QUEST_GIVE_GOLD);

	push	8
	push	ebp
	mov	ecx, edi
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
$LN61@DoGoldGift:

; 9076 : 	}
; 9077 : 
; 9078 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx
$LN5@DoGoldGift:

; 9079 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z$0:
	mov	ecx, DWORD PTR $T267224[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,64,1,297,0>::~FStaticVector<enum PlayerTypes,64,1,297,0>
__unwindfunclet$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z$1:
	mov	ecx, DWORD PTR $T267223[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoGoldGiftFromMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::DoGoldGiftFromMajor
PUBLIC	?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoNowAtWarWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv852 = -20						; size = 4
tv781 = -16						; size = 4
_iWarFriendship$ = -12					; size = 4
$T267369 = -8						; size = 4
_iBaseSpawnTurns$228704 = -4				; size = 4
_eTeam$ = 8						; size = 4
?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z PROC ; CvMinorCivAI::DoNowAtWarWithTeam, COMDAT
; _this$ = ecx

; 9329 : {

	sub	esp, 20					; 00000014H

; 9330 : 	int iOldFriendship;
; 9331 : 	int iWarFriendship = /*-60*/ GC.getMINOR_FRIENDSHIP_AT_WAR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 9332 : 
; 9333 : 	PlayerTypes ePlayer;
; 9334 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebp, ebp
	lea	ecx, DWORD PTR [edi+2552]
	mov	DWORD PTR _iWarFriendship$[esp+36], eax
	xor	esi, esi
	mov	DWORD PTR tv781[esp+36], ebp
	mov	DWORD PTR tv852[esp+36], ecx
	npad	12
$LL199@DoNowAtWar:

; 9335 : 	{
; 9336 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 9337 : 
; 9338 : 		if(GET_PLAYER(ePlayer).getTeam() == eTeam)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv781[esp+36]
	mov	eax, DWORD PTR [eax+edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@DoNowAtWar
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN22@DoNowAtWar
$LN21@DoNowAtWar:
	or	ecx, -1
$LN22@DoNowAtWar:
	cmp	ecx, DWORD PTR _eTeam$[esp+32]
	jne	$LN7@DoNowAtWar

; 9339 : 		{
; 9340 : 			// Friendship change
; 9341 : 			iOldFriendship = GetBaseFriendshipWithMajor(ePlayer);

	xor	ebx, ebx
	cmp	esi, ebx
	jl	SHORT $LN188@DoNowAtWar
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN188@DoNowAtWar
	mov	edx, DWORD PTR tv852[esp+36]
	mov	ecx, DWORD PTR [edx-528]
	jmp	SHORT $LN30@DoNowAtWar
$LN188@DoNowAtWar:
	xor	ecx, ecx
$LN30@DoNowAtWar:

; 9342 : 			DoFriendshipChangeEffects(ePlayer, iOldFriendship, iWarFriendship);

	mov	eax, DWORD PTR _iWarFriendship$[esp+36]
	push	ebx
	push	ebx
	push	eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	esi
	mov	ecx, edi
	call	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects

; 9343 : 
; 9344 : 			// Revoke PtP is there was one
; 9345 : 			if(IsProtectedByMajor(ePlayer))

	cmp	esi, ebx
	jl	$LN9@DoNowAtWar
	cmp	esi, 22					; 00000016H
	jge	$LN9@DoNowAtWar
	mov	al, BYTE PTR [esi+edi+3146]
	cmp	al, bl
	je	SHORT $LN189@DoNowAtWar

; 9346 : 			{
; 9347 : 				DoChangeProtectionFromMajor(ePlayer, false);

	push	9
	push	esi
	mov	ecx, edi
	mov	BYTE PTR [esi+edi+3146], bl
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
$LN189@DoNowAtWar:

; 9348 : 			}
; 9349 : 
; 9350 : 			// Revoke quests if there were any
; 9351 : 			if(GetNumActiveQuestsForPlayer(ePlayer) > 0)

	cmp	esi, 22					; 00000016H
	jge	$LN9@DoNowAtWar
	mov	ecx, DWORD PTR [edi+3328]
	mov	eax, DWORD PTR [ecx+ebp+4]
	add	ecx, ebp
	cmp	eax, ebx
	jle	$LN9@DoNowAtWar

; 9352 : 			{
; 9353 : 				EndAllActiveQuestsForPlayer(ePlayer);

	mov	DWORD PTR [ecx+4], ebx

; 9354 : 			}
; 9355 : 
; 9356 : 			// Nullify Quests - Deprecated?
; 9357 : 			//GET_PLAYER((PlayerTypes) iMinorCivLoop).GetMinorCivAI()->SetPeaceQuestCompletedByMajor((PlayerTypes) iMajorCivLoop, true);
; 9358 : 			//GET_PLAYER((PlayerTypes) iMinorCivLoop).GetMinorCivAI()->SetWarQuestCompletedByMajor((PlayerTypes) iMajorCivLoop, true);
; 9359 : 
; 9360 : 			//// Is this player declaring war also already a Bully?  If so, he's gonna regret it
; 9361 : 			//GET_PLAYER((PlayerTypes) iMinorCivLoop).GetMinorCivAI()->DoBullyDeclareWar((PlayerTypes) iMajorCivLoop);
; 9362 : 		}

	jmp	$LN9@DoNowAtWar
$LN7@DoNowAtWar:

; 9363 : 		else if (!IsAtWarWithPlayersTeam(ePlayer) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(eTeam))

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN128@DoNowAtWar
	mov	ebx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ebx+ecx*4]
	jmp	SHORT $LN129@DoNowAtWar
$LN128@DoNowAtWar:
	or	ecx, -1
$LN129@DoNowAtWar:
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN139@DoNowAtWar
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN140@DoNowAtWar
$LN139@DoNowAtWar:
	or	eax, -1
$LN140@DoNowAtWar:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN9@DoNowAtWar
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv781[esp+36]
	mov	eax, DWORD PTR [ecx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN152@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN153@DoNowAtWar
$LN152@DoNowAtWar:
	or	eax, -1
$LN153@DoNowAtWar:
	mov	edx, DWORD PTR _eTeam$[esp+32]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN9@DoNowAtWar

; 9364 : 		{
; 9365 : 			// If ePlayer is also at war with eTeam, we might shorten the unit spawn timer
; 9366 : 			if (IsFriends(ePlayer) && GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)

	push	esi
	mov	ecx, edi
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN9@DoNowAtWar
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	test	eax, eax
	je	SHORT $LN9@DoNowAtWar
	mov	ebx, 1
	cmp	DWORD PTR [eax+272], ebx
	jne	SHORT $LN9@DoNowAtWar

; 9367 : 			{
; 9368 : 				int iBaseSpawnTurns = GetSpawnBaseTurns(ePlayer); // May be significantly less now with common enemy due to social policy

	push	esi
	mov	ecx, edi
	call	?GetSpawnBaseTurns@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetSpawnBaseTurns
	mov	DWORD PTR _iBaseSpawnTurns$228704[esp+36], eax

; 9369 : 				iBaseSpawnTurns = MAX(iBaseSpawnTurns, 1);

	cmp	eax, ebx
	mov	DWORD PTR $T267369[esp+36], ebx
	lea	eax, DWORD PTR $T267369[esp+36]
	jl	SHORT $LN173@DoNowAtWar
	lea	eax, DWORD PTR _iBaseSpawnTurns$228704[esp+36]
$LN173@DoNowAtWar:
	mov	ecx, DWORD PTR [eax]

; 9370 : 				if (iBaseSpawnTurns < GetUnitSpawnCounter(ePlayer))

	test	esi, esi
	jl	SHORT $LN190@DoNowAtWar
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN190@DoNowAtWar
	mov	edx, DWORD PTR tv852[esp+36]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN176@DoNowAtWar
$LN190@DoNowAtWar:
	or	eax, -1
$LN176@DoNowAtWar:
	cmp	ecx, eax
	jge	SHORT $LN9@DoNowAtWar

; 9371 : 				{
; 9372 : 					SetUnitSpawnCounter(ePlayer, iBaseSpawnTurns);

	test	esi, esi
	jl	SHORT $LN9@DoNowAtWar
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN9@DoNowAtWar
	mov	eax, DWORD PTR tv852[esp+36]
	mov	DWORD PTR [eax], ecx
$LN9@DoNowAtWar:
	add	DWORD PTR tv852[esp+36], 4
	add	DWORD PTR tv781[esp+36], 63236		; 0000f704H
	add	ebp, 156				; 0000009cH
	inc	esi
	cmp	ebp, 3432				; 00000d68H
	jl	$LL199@DoNowAtWar

; 9373 : 				}
; 9374 : 			}
; 9375 : 		}
; 9376 : 	}
; 9377 : 
; 9378 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9379 : }

	add	esp, 20					; 00000014H
	ret	4
?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ENDP ; CvMinorCivAI::DoNowAtWarWithTeam
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvMinorCivInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMinorCivInfo@@UAEPAXI@Z PROC			; CvMinorCivInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvMinorCivInfo@@UAE@XZ		; CvMinorCivInfo::~CvMinorCivInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMinorCivInfo@@UAEPAXI@Z ENDP			; CvMinorCivInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
$T267886 = -4						; size = 1
__Cat$267890 = 8					; size = 1
$T267856 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 810  : 		if (size() < capacity())

	mov	ebp, DWORD PTR [edi+4]
	test	ebp, ebp
	jne	SHORT $LN9@push_back@19
	xor	esi, esi
	jmp	SHORT $LN10@push_back@19
$LN9@push_back@19:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@push_back@19:
	mov	ebx, DWORD PTR [edi+8]
	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@push_back@19

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$267890[esp+16]
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	BYTE PTR $T267886[esp+20], 0
	mov	ecx, DWORD PTR $T267886[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR [edi+8], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@19:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	ebx
	lea	edx, DWORD PTR $T267856[esp+24]
	push	edx
	mov	ecx, edi
	call	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::push_back
_TEXT	ENDS
PUBLIC	?DoStartQuest@CvMinorCivQuest@@QAEXH@Z		; CvMinorCivQuest::DoStartQuest
EXTRN	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z:PROC ; CvPlot::setRevealedImprovementType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z DD 019930522H
	DD	029H
	DD	FLAT:__unwindtable$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$14
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$16
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$17
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$18
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$19
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$22
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$23
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$24
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$25
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$26
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$27
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$28
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$29
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$30
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$31
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$32
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$33
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$34
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$35
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$36
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$37
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$38
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$39
	DD	027H
	DD	FLAT:__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$40
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoStartQuest@CvMinorCivQuest@@QAEXH@Z
_TEXT	SEGMENT
_eReligion$221923 = -376				; size = 4
_eMostRecentBully$221911 = -376				; size = 4
_strCivKey$221905 = -376				; size = 4
_eTargetMinor$221898 = -376				; size = 4
_eMostRecentBully$221850 = -376				; size = 4
_eMostRecentBully$221837 = -376				; size = 4
_strCivKey$221823 = -376				; size = 4
_strTargetNameKey$221815 = -376				; size = 4
_strUnitName$221807 = -376				; size = 4
_strBuildingName$221799 = -376				; size = 4
_strResourceName$221786 = -376				; size = 4
_pPlot$221778 = -376					; size = 4
_pMinor$ = -376						; size = 4
tv1237 = -372						; size = 4
tv1235 = -372						; size = 4
tv1234 = -372						; size = 4
tv1232 = -372						; size = 4
tv1230 = -372						; size = 4
$T268172 = -372						; size = 4
$T268154 = -372						; size = 4
$T268140 = -372						; size = 4
$T268043 = -372						; size = 4
_iTurnsDuration$221882 = -372				; size = 4
_iTurnsDuration$221873 = -372				; size = 4
_iTurnsDuration$221864 = -372				; size = 4
_pAssignedPlayer$ = -372				; size = 4
$T267950 = -368						; size = 4
_iNotificationX$ = -368					; size = 4
$T267951 = -364						; size = 4
_iNotificationY$ = -364					; size = 4
$T267947 = -360						; size = 80
$T267945 = -360						; size = 80
$T267942 = -360						; size = 80
$T267941 = -360						; size = 80
$T267940 = -360						; size = 80
$T267939 = -360						; size = 80
$T267938 = -360						; size = 80
$T267937 = -360						; size = 80
$T267936 = -360						; size = 80
$T267935 = -360						; size = 80
$T267934 = -360						; size = 80
$T267933 = -360						; size = 80
$T267932 = -360						; size = 80
$T267931 = -360						; size = 80
$T267930 = -360						; size = 80
$T267929 = -360						; size = 80
$T267928 = -360						; size = 80
$T267927 = -360						; size = 80
$T267926 = -360						; size = 80
$T267925 = -360						; size = 80
$T267924 = -360						; size = 80
$T267923 = -360						; size = 80
$T267922 = -360						; size = 80
$T267921 = -360						; size = 80
$T267920 = -360						; size = 80
$T267919 = -360						; size = 80
$T267918 = -360						; size = 80
$T267917 = -360						; size = 80
$T267916 = -360						; size = 80
$T267915 = -360						; size = 80
$T267914 = -360						; size = 80
$T267913 = -360						; size = 80
$T267912 = -360						; size = 80
_strMessage$ = -280					; size = 80
_strSummary$ = -200					; size = 80
_strReligion$221930 = -120				; size = 28
$T267946 = -92						; size = 80
$T267944 = -92						; size = 80
$T267943 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_iStartTurn$ = 8					; size = 4
?DoStartQuest@CvMinorCivQuest@@QAEXH@Z PROC		; CvMinorCivQuest::DoStartQuest, COMDAT
; _this$ = ecx

; 801  : {

	push	-1
	push	__ehhandler$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 364				; 0000016cH

; 802  : 	m_iStartTurn = iStartTurn;

	mov	eax, DWORD PTR _iStartTurn$[esp+372]
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 803  : 
; 804  : 	CvPlayer* pMinor = &GET_PLAYER(m_eMinor);

	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR [esi+12], eax
	imul	ebp, 63236				; 0000f704H

; 805  : 	CvPlayer* pAssignedPlayer = &GET_PLAYER(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	add	ebp, ecx
	add	eax, ecx
	push	edi

; 806  : 
; 807  : 	Localization::String strMessage;

	mov	edi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$[esp+392]
	mov	DWORD PTR _pMinor$[esp+392], ebp
	mov	DWORD PTR _pAssignedPlayer$[esp+392], eax
	call	edi

; 808  : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+392]
	mov	DWORD PTR __$EHRec$[esp+400], 0
	call	edi

; 809  : 	int iNotificationX = -1;
; 810  : 	int iNotificationY = -1;
; 811  : 
; 812  : 	// Build a Route
; 813  : 	if(m_eType == MINOR_CIV_QUEST_ROUTE)

	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	or	eax, -1
	mov	DWORD PTR _iNotificationX$[esp+392], eax
	mov	DWORD PTR _iNotificationY$[esp+392], eax
	mov	eax, DWORD PTR [esi+8]
	mov	ebx, 1
	mov	BYTE PTR __$EHRec$[esp+400], bl
	test	eax, eax
	jne	SHORT $LN45@DoStartQue

; 814  : 	{
; 815  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_START_ROUTE");

	lea	ecx, DWORD PTR $T267912[esp+392]
	push	OFFSET $SG221773
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 2
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267912[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 816  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_START_ROUTE");

	lea	edx, DWORD PTR $T267913[esp+392]
	push	OFFSET $SG221775
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 3
	jmp	$LN243@DoStartQue
$LN45@DoStartQue:

; 817  : 	}
; 818  : 	// Kill a Camp
; 819  : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	eax, ebx
	jne	$LN43@DoStartQue

; 820  : 	{
; 821  : 		CvPlot* pPlot = pMinor->GetMinorCivAI()->GetBestNearbyCampToKill();

	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ ; CvMinorCivAI::GetBestNearbyCampToKill

; 822  : 
; 823  : 		FAssertMsg(pPlot != NULL, "MINOR CIV AI: Somehow we're starting a quest to kill a barb camp but we can't find one nearby. Please send Jon this with your last 5 autosaves and what changelist # you're playing. Oh, and you're about to crash.");
; 824  : 
; 825  : 		m_iData1 = pPlot->getX();

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+16], ecx

; 826  : 		m_iData2 = pPlot->getY();

	movsx	edx, WORD PTR [eax+2]

; 827  : 
; 828  : 		pPlot->setRevealed(pAssignedPlayer->getTeam(), true);

	mov	ecx, DWORD PTR _pAssignedPlayer$[esp+392]
	mov	DWORD PTR [esi+20], edx
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR _pPlot$221778[esp+392], eax
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN101@DoStartQue
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN102@DoStartQue
$LN101@DoStartQue:
	or	ecx, -1
$LN102@DoStartQue:
	push	-1
	push	0
	push	ebx
	push	ecx
	mov	ecx, eax
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 829  : 		pPlot->setRevealedImprovementType(pAssignedPlayer->getTeam(), pPlot->getImprovementType());

	mov	eax, DWORD PTR _pAssignedPlayer$[esp+392]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN110@DoStartQue
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T268043[esp+392], eax
	jmp	SHORT $LN111@DoStartQue
$LN110@DoStartQue:
	mov	DWORD PTR $T268043[esp+392], -1
$LN111@DoStartQue:
	mov	ecx, DWORD PTR _pPlot$221778[esp+392]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	ecx, DWORD PTR $T268043[esp+392]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pPlot$221778[esp+400]
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType

; 830  : 
; 831  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_KILL_CAMP");

	lea	edx, DWORD PTR $T267914[esp+392]
	push	OFFSET $SG221780
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267914[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 832  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_KILL_CAMP");

	lea	eax, DWORD PTR $T267915[esp+392]
	push	OFFSET $SG221782
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267915[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 833  : 		iNotificationX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$221778[esp+392]
	movsx	ecx, WORD PTR [eax]

; 834  : 		iNotificationY = pPlot->getY();

	movsx	edx, WORD PTR [eax+2]
	mov	DWORD PTR _iNotificationX$[esp+392], ecx
	mov	DWORD PTR _iNotificationY$[esp+392], edx
	jmp	$LN1@DoStartQue
$LN43@DoStartQue:

; 835  : 	}
; 836  : 	// Connect a Resource
; 837  : 	else if(m_eType == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	eax, 2
	jne	$LN41@DoStartQue

; 838  : 	{
; 839  : 		ResourceTypes eResource = pMinor->GetMinorCivAI()->GetNearbyResourceForQuest(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetNearbyResourceForQuest

; 840  : 
; 841  : 		FAssertMsg(eResource != NO_RESOURCE, "MINOR CIV AI: For some reason we got NO_RESOURCE when starting a quest for a major to find a Resource. Please send Jon this with your last 5 autosaves and what changelist # you're playing. Bad things are probably going to happen.");
; 842  : 
; 843  : 		m_iData1 = eResource;
; 844  : 
; 845  : 		const char* strResourceName = GC.getResourceInfo(eResource)->GetDescriptionKey();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+16], eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 846  : 
; 847  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_CONNECT_RESOURCE");

	lea	ecx, DWORD PTR $T267916[esp+392]
	push	OFFSET $SG221788
	push	ecx
	mov	DWORD PTR _strResourceName$221786[esp+400], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267916[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 848  : 		strMessage << strResourceName;

	mov	edx, DWORD PTR _strResourceName$221786[esp+392]
	push	edx
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 849  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONNECT_RESOURCE");

	lea	eax, DWORD PTR $T267917[esp+392]
	push	OFFSET $SG221795
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267917[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 850  : 		strSummary << strResourceName;

	mov	ecx, DWORD PTR _strResourceName$221786[esp+392]
	push	ecx

; 928  : 		strSummary << strCivKey;

	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN41@DoStartQue:

; 851  : 	}
; 852  : 	// Construct a Wonder
; 853  : 	else if(m_eType == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	eax, 3
	jne	$LN39@DoStartQue

; 854  : 	{
; 855  : 		BuildingTypes eWonder = pMinor->GetMinorCivAI()->GetBestWonderForQuest(m_eAssignedPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetBestWonderForQuest

; 856  : 
; 857  : 		FAssertMsg(eWonder != NO_BUILDING, "MINOR CIV AI: For some reason we got NO_BUILDING when starting a quest for a major to find a Wonder. Please send Jon this with your last 5 autosaves and what changelist # you're playing. Bad things are probably going to happen.");
; 858  : 
; 859  : 		m_iData1 = eWonder;
; 860  : 
; 861  : #ifdef AUI_WARNING_FIXES
; 862  : 		const char* strBuildingName;
; 863  : 		CvBuildingEntry* pWonderInfo = GC.getBuildingInfo(eWonder);
; 864  : 		if (pWonderInfo)
; 865  : 			strBuildingName = pWonderInfo->GetDescriptionKey();
; 866  : #else
; 867  : 		const char* strBuildingName = GC.getBuildingInfo(eWonder)->GetDescriptionKey();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+16], eax
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _strBuildingName$221799[esp+392], eax

; 868  : #endif
; 869  : 
; 870  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_CONSTRUCT_WONDER");

	lea	eax, DWORD PTR $T267918[esp+392]
	push	OFFSET $SG221801
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267918[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 871  : 		strMessage << strBuildingName;

	mov	ecx, DWORD PTR _strBuildingName$221799[esp+392]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 872  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONSTRUCT_WONDER");

	lea	edx, DWORD PTR $T267919[esp+392]
	push	OFFSET $SG221803
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 9

; 873  : 		strSummary << strBuildingName;

	jmp	$LN245@DoStartQue
$LN39@DoStartQue:

; 874  : 	}
; 875  : 	// Great Person
; 876  : 	else if(m_eType == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	eax, 4
	jne	$LN37@DoStartQue

; 877  : 	{
; 878  : 		UnitTypes eUnit = pMinor->GetMinorCivAI()->GetBestGreatPersonForQuest(m_eAssignedPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetBestGreatPersonForQuest

; 879  : 
; 880  : 		FAssertMsg(eUnit != NO_UNIT, "MINOR CIV AI: For some reason we got NO_UNIT when starting a quest for a major to find a Great Person. Please send Jon this with your last 5 autosaves and what changelist # you're playing. Bad things are probably going to happen.");
; 881  : 
; 882  : 		m_iData1 = eUnit;
; 883  : 
; 884  : #ifdef AUI_WARNING_FIXES
; 885  : 		const char* strUnitName;
; 886  : 		CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);
; 887  : 		if (pUnitInfo)
; 888  : 			strUnitName = pUnitInfo->GetDescriptionKey();
; 889  : #else
; 890  : 		const char* strUnitName = GC.getUnitInfo(eUnit)->GetDescriptionKey();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+16], eax
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 891  : #endif
; 892  : 
; 893  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_GREAT_PERSON");

	lea	edx, DWORD PTR $T267920[esp+392]
	push	OFFSET $SG221809
	push	edx
	mov	DWORD PTR _strUnitName$221807[esp+400], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 10		; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267920[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 894  : 		strMessage << strUnitName;

	mov	eax, DWORD PTR _strUnitName$221807[esp+392]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 895  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_GREAT_PERSON");

	lea	ecx, DWORD PTR $T267921[esp+392]
	push	OFFSET $SG221811
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 11		; 0000000bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267921[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 896  : 		strSummary << strUnitName;

	mov	edx, DWORD PTR _strUnitName$221807[esp+392]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN37@DoStartQue:

; 897  : 	}
; 898  : 	// Kill another City State
; 899  : 	else if(m_eType == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	eax, 5
	jne	$LN35@DoStartQue

; 900  : 	{
; 901  : 		PlayerTypes eTargetCityState = pMinor->GetMinorCivAI()->GetBestCityStateTarget(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestCityStateTarget

; 902  : 
; 903  : 		FAssertMsg(eTargetCityState != NO_PLAYER, "MINOR CIV AI: For some reason we got NO_PLAYER when starting a quest for a major to kill a City State. Please send Jon this with your last 5 autosaves and what changelist # you're playing. Bad things are probably going to happen.");
; 904  : 
; 905  : 		m_iData1 = eTargetCityState;

	mov	DWORD PTR [esi+16], eax

; 906  : 
; 907  : 		const char* strTargetNameKey = GET_PLAYER(eTargetCityState).getNameKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 908  : 
; 909  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_KILL_CITY_STATE");

	lea	ecx, DWORD PTR $T267922[esp+392]
	push	OFFSET $SG221817
	push	ecx
	mov	DWORD PTR _strTargetNameKey$221815[esp+400], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 12		; 0000000cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267922[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 910  : 		strMessage << strTargetNameKey;

	mov	edx, DWORD PTR _strTargetNameKey$221815[esp+392]
	push	edx
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 911  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_KILL_CITY_STATE");

	lea	eax, DWORD PTR $T267923[esp+392]
	push	OFFSET $SG221819
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 13		; 0000000dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267923[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 912  : 		strSummary << strTargetNameKey;

	mov	ecx, DWORD PTR _strTargetNameKey$221815[esp+392]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN35@DoStartQue:

; 913  : 	}
; 914  : 	// Find another player's territory
; 915  : 	else if(m_eType == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	eax, 6
	jne	$LN33@DoStartQue

; 916  : 	{
; 917  : 		PlayerTypes ePlayerToFind = pMinor->GetMinorCivAI()->GetBestPlayerToFind(m_eAssignedPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestPlayerToFind

; 918  : 
; 919  : 		FAssertMsg(ePlayerToFind != NO_PLAYER, "MINOR CIV AI: For some reason we got NO_PLAYER when starting a quest for a major to find a player. Please send Jon this with your last 5 autosaves and what changelist # you're playing. Bad things are probably going to happen.");
; 920  : 
; 921  : 		m_iData1 = ePlayerToFind;

	mov	DWORD PTR [esi+16], eax

; 922  : 
; 923  : 		const char* strCivKey = GET_PLAYER(ePlayerToFind).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strCivKey$221823[esp+392], eax

; 924  : 
; 925  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_FIND_PLAYER");

	lea	eax, DWORD PTR $T267924[esp+392]
	push	OFFSET $SG221825
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 14		; 0000000eH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267924[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 926  : 		strMessage << strCivKey;

	mov	ecx, DWORD PTR _strCivKey$221823[esp+392]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 927  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_FIND_PLAYER");

	lea	edx, DWORD PTR $T267925[esp+392]
	push	OFFSET $SG221827
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 15		; 0000000fH
$LN245@DoStartQue:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267925[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 928  : 		strSummary << strCivKey;

	mov	eax, DWORD PTR _strCivKey$221823[esp+392]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN33@DoStartQue:

; 929  : 	}
; 930  : 	// Find a Natural Wonder
; 931  : 	else if(m_eType == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	eax, 7
	jne	SHORT $LN31@DoStartQue

; 932  : 	{
; 933  : 		int iNumWondersAlreadyFound = GET_TEAM(pAssignedPlayer->getTeam()).GetNumNaturalWondersDiscovered();

	mov	ecx, DWORD PTR _pAssignedPlayer$[esp+392]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ; CvTeam::GetNumNaturalWondersDiscovered

; 934  : 
; 935  : 		m_iData1 = iNumWondersAlreadyFound;
; 936  : 
; 937  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_FIND_NATURAL_WONDER");

	lea	ecx, DWORD PTR $T267926[esp+392]
	push	OFFSET $SG221832
	push	ecx
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 16		; 00000010H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267926[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 938  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_FIND_NATURAL_WONDER");

	lea	edx, DWORD PTR $T267927[esp+392]
	push	OFFSET $SG221834
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 17		; 00000011H
	jmp	$LN243@DoStartQue
$LN31@DoStartQue:

; 939  : 	}
; 940  : 	// Give a gift of gold
; 941  : 	else if(m_eType == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	eax, 8
	jne	$LN29@DoStartQue

; 942  : 	{
; 943  : 		PlayerTypes eMostRecentBully = pMinor->GetMinorCivAI()->GetMostRecentBullyForQuest();

	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest
	mov	DWORD PTR _eMostRecentBully$221837[esp+392], eax

; 944  : 		int iGoldAlreadyGiven = pMinor->GetMinorCivAI()->GetNumGoldGifted(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumGoldGifted

; 945  : 
; 946  : 		CvAssertMsg(eMostRecentBully != NO_PLAYER, "MINOR CIV AI: eMostRecentBully should not be NO_PLAYER when giving a Give Gold quest! Please send Anton your save file and version.");
; 947  : 
; 948  : 		m_iData1 = eMostRecentBully;

	mov	ecx, DWORD PTR _eMostRecentBully$221837[esp+392]

; 949  : 		m_iData2 = iGoldAlreadyGiven;
; 950  : 
; 951  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_GIVE_GOLD");

	lea	edx, DWORD PTR $T267928[esp+392]
	push	OFFSET $SG221840
	push	edx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 18		; 00000012H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267928[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 952  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_GIVE_GOLD");

	lea	eax, DWORD PTR $T267929[esp+392]
	push	OFFSET $SG221842
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 19		; 00000013H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267929[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 953  : 
; 954  : 		if(eMostRecentBully != NO_PLAYER)

	mov	eax, DWORD PTR _eMostRecentBully$221837[esp+392]
	cmp	eax, -1
	je	SHORT $LN28@DoStartQue

; 955  : 		{
; 956  : 			const char* strCivKey = GET_PLAYER(eMostRecentBully).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey

; 957  : 			strMessage << strCivKey;

	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN28@DoStartQue:

; 958  : 		}
; 959  : 		else
; 960  : 		{
; 961  : 			const char* strCivKey = "Nobody";
; 962  : 			strMessage << strCivKey;

	push	OFFSET $SG221847
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 963  : 		}

	jmp	$LN1@DoStartQue
$LN29@DoStartQue:

; 964  : 	}
; 965  : 	// Pledge to protect them
; 966  : 	else if(m_eType == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	eax, 9
	jne	$LN25@DoStartQue

; 967  : 	{
; 968  : 		PlayerTypes eMostRecentBully = pMinor->GetMinorCivAI()->GetMostRecentBullyForQuest();

	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest

; 969  : 
; 970  : 		CvAssertMsg(eMostRecentBully != NO_PLAYER, "MINOR CIV AI: eMostRecentBully should not be NO_PLAYER when giving a Pledge to Protect quest! Please send Anton your save file and version.");
; 971  : 
; 972  : 		m_iData1 = eMostRecentBully;
; 973  : 
; 974  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_PLEDGE_TO_PROTECT");

	lea	ecx, DWORD PTR $T267930[esp+392]
	push	OFFSET $SG221852
	push	ecx
	mov	DWORD PTR _eMostRecentBully$221850[esp+400], eax
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 20		; 00000014H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267930[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 975  : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_PLEDGE_TO_PROTECT");

	lea	edx, DWORD PTR $T267931[esp+392]
	push	OFFSET $SG221854
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 21		; 00000015H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267931[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 976  : 
; 977  : 		if(eMostRecentBully != NO_PLAYER)

	mov	eax, DWORD PTR _eMostRecentBully$221850[esp+392]
	cmp	eax, -1
	je	SHORT $LN24@DoStartQue

; 978  : 		{
; 979  : 			const char* strCivKey = GET_PLAYER(eMostRecentBully).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey

; 980  : 			strMessage << strCivKey;

	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN24@DoStartQue:

; 981  : 		}
; 982  : 		else
; 983  : 		{
; 984  : 			const char* strCivKey = "Nobody";
; 985  : 			strMessage << strCivKey;

	push	OFFSET $SG221859
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 986  : 		}

	jmp	$LN1@DoStartQue
$LN25@DoStartQue:

; 987  : 	}
; 988  : 	// Culture contest
; 989  : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	eax, 10					; 0000000aH
	jne	$LN21@DoStartQue

; 990  : 	{
; 991  : 		int iStartingCulture = pAssignedPlayer->GetJONSCultureEverGenerated();

	mov	ecx, DWORD PTR _pAssignedPlayer$[esp+392]
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated

; 992  : 
; 993  : 		m_iData1 = iStartingCulture;

	mov	DWORD PTR [esi+16], eax

; 994  : 
; 995  : 		int iTurnsRemaining = GetEndTurn() - GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	DWORD PTR tv1237[esp+392], eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	mov	ebp, eax
	mov	eax, DWORD PTR tv1237[esp+392]
	sub	ebp, eax

; 996  : 		int iTurnsDuration = GetEndTurn() - GetStartTurn();

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, esi
	mov	DWORD PTR $T268140[esp+392], eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	sub	eax, DWORD PTR $T268140[esp+392]

; 997  : 
; 998  : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_CONTEST_CULTURE");

	lea	ecx, DWORD PTR $T267932[esp+392]
	push	OFFSET $SG221866
	push	ecx
	mov	DWORD PTR _iTurnsDuration$221864[esp+400], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 22		; 00000016H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267932[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 999  : 		strMessage << iTurnsRemaining;

	push	ebp
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1000 : 		strMessage << iTurnsDuration;

	mov	edx, DWORD PTR _iTurnsDuration$221864[esp+392]
	push	edx
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1001 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONTEST_CULTURE");

	lea	eax, DWORD PTR $T267933[esp+392]
	push	OFFSET $SG221868
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 23		; 00000017H
	jmp	$LN244@DoStartQue
$LN21@DoStartQue:

; 1002 : 	}
; 1003 : 	// Faith contest
; 1004 : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	eax, 11					; 0000000bH
	jne	$LN19@DoStartQue

; 1005 : 	{
; 1006 : 		int iStartingFaith = pAssignedPlayer->GetFaithEverGenerated();

	mov	ecx, DWORD PTR _pAssignedPlayer$[esp+392]
	call	?GetFaithEverGenerated@CvPlayer@@QBEHXZ	; CvPlayer::GetFaithEverGenerated

; 1007 : 
; 1008 : 		m_iData1 = iStartingFaith;

	mov	DWORD PTR [esi+16], eax

; 1009 : 
; 1010 : 		int iTurnsRemaining = GetEndTurn() - GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	DWORD PTR tv1234[esp+392], eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn

; 1011 : 		int iTurnsDuration = GetEndTurn() - GetStartTurn();

	mov	ecx, DWORD PTR [esi+12]
	mov	ebp, eax
	mov	eax, DWORD PTR tv1234[esp+392]
	mov	DWORD PTR $T268154[esp+392], ecx
	mov	ecx, esi
	sub	ebp, eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	sub	eax, DWORD PTR $T268154[esp+392]

; 1012 : 
; 1013 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_CONTEST_FAITH");

	lea	edx, DWORD PTR $T267934[esp+392]
	push	OFFSET $SG221875
	push	edx
	mov	DWORD PTR _iTurnsDuration$221873[esp+400], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 24		; 00000018H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267934[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1014 : 		strMessage << iTurnsRemaining;

	push	ebp
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1015 : 		strMessage << iTurnsDuration;

	mov	eax, DWORD PTR _iTurnsDuration$221873[esp+392]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1016 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONTEST_FAITH");

	lea	ecx, DWORD PTR $T267935[esp+392]
	push	OFFSET $SG221877
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 25		; 00000019H
	jmp	$LN244@DoStartQue
$LN19@DoStartQue:

; 1017 : 	}
; 1018 : 	// Techs contest
; 1019 : 	else if(m_eType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	eax, 12					; 0000000cH
	jne	$LN17@DoStartQue

; 1020 : 	{
; 1021 : 		int iStartingTechs = GET_TEAM(pAssignedPlayer->getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	ecx, DWORD PTR _pAssignedPlayer$[esp+392]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown

; 1022 : 
; 1023 : 		m_iData1 = iStartingTechs;

	mov	DWORD PTR [esi+16], eax

; 1024 : 
; 1025 : 		int iTurnsRemaining = GetEndTurn() - GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	DWORD PTR tv1232[esp+392], eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn

; 1026 : 		int iTurnsDuration = GetEndTurn() - GetStartTurn();

	mov	edx, DWORD PTR [esi+12]
	mov	ebp, eax
	mov	eax, DWORD PTR tv1232[esp+392]
	mov	ecx, esi
	sub	ebp, eax
	mov	DWORD PTR $T268172[esp+392], edx
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	sub	eax, DWORD PTR $T268172[esp+392]

; 1027 : 
; 1028 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_CONTEST_TECHS");

	push	OFFSET $SG221884
	mov	DWORD PTR _iTurnsDuration$221882[esp+396], eax
	lea	eax, DWORD PTR $T267936[esp+396]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 26		; 0000001aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267936[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1029 : 		strMessage << iTurnsRemaining;

	push	ebp
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1030 : 		strMessage << iTurnsDuration;

	mov	ecx, DWORD PTR _iTurnsDuration$221882[esp+392]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1031 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_CONTEST_TECHS");

	lea	edx, DWORD PTR $T267937[esp+392]
	push	OFFSET $SG221886
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 27		; 0000001bH
	jmp	$LN244@DoStartQue
$LN17@DoStartQue:

; 1032 : 	}
; 1033 : 	// Invest
; 1034 : 	else if(m_eType == MINOR_CIV_QUEST_INVEST)

	cmp	eax, 13					; 0000000dH
	jne	$LN15@DoStartQue

; 1035 : 	{
; 1036 : 		int iGoldAlreadyGiven = pMinor->GetMinorCivAI()->GetNumGoldGifted(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetNumGoldGifted@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumGoldGifted

; 1037 : 
; 1038 : 		m_iData1 = iGoldAlreadyGiven;

	mov	DWORD PTR [esi+16], eax

; 1039 : 
; 1040 : 		int iTurnsRemaining = GetEndTurn() - GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	DWORD PTR tv1230[esp+392], eax
	call	?GetEndTurn@CvMinorCivQuest@@QBEHXZ	; CvMinorCivQuest::GetEndTurn
	mov	ebp, eax
	mov	eax, DWORD PTR tv1230[esp+392]

; 1041 : 		int iBoostPercentage = 50;//antonjs: todo: XML
; 1042 : 
; 1043 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_INVEST");

	lea	ecx, DWORD PTR $T267938[esp+392]
	push	OFFSET $SG221893
	push	ecx
	sub	ebp, eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 28		; 0000001cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267938[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1044 : 		strMessage << iTurnsRemaining;

	push	ebp
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1045 : 		strMessage << iBoostPercentage;

	push	50					; 00000032H
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	ebp

; 1046 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_INVEST");

	lea	edx, DWORD PTR $T267939[esp+392]
	push	OFFSET $SG221895
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 29		; 0000001dH
$LN244@DoStartQue:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267939[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi
	mov	ebp, DWORD PTR _pMinor$[esp+392]
	jmp	$LN1@DoStartQue
$LN15@DoStartQue:

; 1047 : 	}
; 1048 : 	// Bully target City-State
; 1049 : 	else if(m_eType == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	eax, 14					; 0000000eH
	jne	$LN13@DoStartQue

; 1050 : 	{
; 1051 : 		PlayerTypes eTargetMinor = pMinor->GetMinorCivAI()->GetBestCityStateTarget(m_eAssignedPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestCityStateTarget

; 1052 : 		CvAssertMsg(eTargetMinor != NO_PLAYER, "MINOR CIV AI: eTargetMinor should not be NO_PLAYER when giving a Bully CS quest! Please send Anton your save file and version.");
; 1053 : 		int iLastBullyTurn = GET_PLAYER(eTargetMinor).GetMinorCivAI()->GetTurnLastBulliedByMajor(m_eAssignedPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _eTargetMinor$221898[esp+392], eax
	imul	eax, 63236				; 0000f704H
	add	ecx, eax
	push	edx
	mov	DWORD PTR tv1235[esp+396], eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetTurnLastBulliedByMajor@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetTurnLastBulliedByMajor

; 1054 : 
; 1055 : 		m_iData1 = eTargetMinor;

	mov	ecx, DWORD PTR _eTargetMinor$221898[esp+392]

; 1056 : 		m_iData2 = iLastBullyTurn;
; 1057 : 
; 1058 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_BULLY_CITY_STATE");

	lea	edx, DWORD PTR $T267940[esp+392]
	push	OFFSET $SG221901
	push	edx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 30		; 0000001eH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267940[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1059 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_BULLY_CITY_STATE");

	lea	eax, DWORD PTR $T267941[esp+392]
	push	OFFSET $SG221903
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 31		; 0000001fH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267941[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1060 : 
; 1061 : 		if(eTargetMinor != NO_PLAYER)

	cmp	DWORD PTR _eTargetMinor$221898[esp+392], -1
	je	SHORT $LN12@DoStartQue

; 1062 : 		{
; 1063 : 			const char* strCivKey = GET_PLAYER(eTargetMinor).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv1235[esp+392]
	add	ecx, edx
$LN249@DoStartQue:
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey

; 1064 : 			strMessage << strCivKey;

	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	DWORD PTR _strCivKey$221905[esp+396], eax
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	eax, DWORD PTR _strCivKey$221823[esp+392]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jmp	$LN1@DoStartQue
$LN12@DoStartQue:

; 1065 : 			strSummary << strCivKey;
; 1066 : 		}
; 1067 : 		else
; 1068 : 		{
; 1069 : 			const char* strCivKey = "Nobody";
; 1070 : 			strMessage << strCivKey;

	push	OFFSET $SG221908
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1071 : 			strSummary << strCivKey;

	push	OFFSET $SG221908
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1072 : 		}

	jmp	$LN1@DoStartQue
$LN13@DoStartQue:

; 1073 : 	}
; 1074 : 	// Denounce target Major
; 1075 : 	else if(m_eType == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	eax, 15					; 0000000fH
	jne	$LN9@DoStartQue

; 1076 : 	{
; 1077 : 		PlayerTypes eMostRecentBully = pMinor->GetMinorCivAI()->GetMostRecentBullyForQuest();

	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest

; 1078 : 
; 1079 : 		CvAssertMsg(eMostRecentBully != NO_PLAYER, "MINOR CIV AI: eMostRecentBully should not be NO_PLAYER when giving a Denounce Major quest! Please send Anton your save file and version.");
; 1080 : 
; 1081 : 		m_iData1 = eMostRecentBully;
; 1082 : 
; 1083 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_DENOUNCE_MAJOR");

	lea	ecx, DWORD PTR $T267942[esp+392]
	push	OFFSET $SG221913
	push	ecx
	mov	DWORD PTR _eMostRecentBully$221911[esp+400], eax
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 32		; 00000020H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267942[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1084 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_DENOUNCE_MAJOR");

	lea	edx, DWORD PTR $T267943[esp+392]
	push	OFFSET $SG221915
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 33		; 00000021H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267943[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1085 : 
; 1086 : 		if(eMostRecentBully != NO_PLAYER)

	mov	eax, DWORD PTR _eMostRecentBully$221911[esp+392]
	cmp	eax, -1
	je	SHORT $LN8@DoStartQue

; 1087 : 		{
; 1088 : 			const char* strCivKey = GET_PLAYER(eMostRecentBully).getCivilizationShortDescriptionKey();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax

; 1089 : 			strMessage << strCivKey;
; 1090 : 			strSummary << strCivKey;
; 1091 : 		}
; 1092 : 		else

	jmp	$LN249@DoStartQue
$LN8@DoStartQue:

; 1093 : 		{
; 1094 : 			const char* strCivKey = "Nobody";
; 1095 : 			strMessage << strCivKey;

	push	OFFSET $SG221920
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1096 : 			strSummary << strCivKey;

	push	OFFSET $SG221920
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1097 : 		}

	jmp	$LN1@DoStartQue
$LN9@DoStartQue:

; 1098 : 	}
; 1099 : 	// Spread your religion to us
; 1100 : 	else if(m_eType == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	eax, 16					; 00000010H
	jne	$LN5@DoStartQue

; 1101 : 	{
; 1102 : 		ReligionTypes eReligion = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(m_eAssignedPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer

; 1103 : 
; 1104 : 		CvAssertMsg(eReligion != NO_RELIGION, "MINOR CIV AI: eReligion should not be NO_RELIGION when giving a Spread Religion quest! Please send Anton your save file and version.");
; 1105 : 
; 1106 : 		m_iData1 = eReligion;
; 1107 : 
; 1108 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_SPREAD_RELIGION");

	lea	edx, DWORD PTR $T267944[esp+392]
	push	OFFSET $SG221925
	push	edx
	mov	DWORD PTR _eReligion$221923[esp+400], eax
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 34		; 00000022H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267944[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1109 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_SPREAD_RELIGION");

	lea	eax, DWORD PTR $T267945[esp+392]
	push	OFFSET $SG221927
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 35		; 00000023H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267945[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1110 : 
; 1111 : 		if(eReligion != NO_RELIGION)

	mov	eax, DWORD PTR _eReligion$221923[esp+392]
	cmp	eax, -1
	je	SHORT $LN4@DoStartQue

; 1112 : 		{
; 1113 : 			const CvReligion* pkReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	-1
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 1114 : 			CvString strReligion = pkReligion->GetName(); // Not a key, already localized (may be custom name)

	lea	ecx, DWORD PTR _strReligion$221930[esp+392]
	push	ecx
	mov	ecx, eax
	call	?GetName@CvReligion@@QBE?AVCvString@@XZ	; CvReligion::GetName

; 1115 : 			strMessage << strReligion;

	lea	edx, DWORD PTR _strReligion$221930[esp+392]
	push	edx
	lea	eax, DWORD PTR _strMessage$[esp+396]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+408], 36		; 00000024H
	call	??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z ; operator<<<CvString>

; 1116 : 			strSummary << strReligion;

	lea	ecx, DWORD PTR _strReligion$221930[esp+400]
	push	ecx
	lea	edx, DWORD PTR _strSummary$[esp+404]
	push	edx
	call	??$?6VCvString@@@@YAAAVString@Localization@@AAV01@ABVCvString@@@Z ; operator<<<CvString>
	add	esp, 16					; 00000010H

; 1117 : 		}

	lea	ecx, DWORD PTR _strReligion$221930[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1118 : 		else

	jmp	$LN1@DoStartQue
$LN4@DoStartQue:

; 1119 : 		{
; 1120 : 			const char* strReligion = "No Religion";
; 1121 : 			strMessage << strReligion;

	push	OFFSET $SG221934
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1122 : 			strSummary << strReligion;

	push	OFFSET $SG221934
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1123 : 		}

	jmp	SHORT $LN1@DoStartQue
$LN5@DoStartQue:

; 1124 : 	}
; 1125 : 	// Connect a trade Route
; 1126 : 	else if(m_eType == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN1@DoStartQue

; 1127 : 	{
; 1128 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_START_TRADE_ROUTE");

	lea	eax, DWORD PTR $T267946[esp+392]
	push	OFFSET $SG221938
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	mov	BYTE PTR __$EHRec$[esp+404], 37		; 00000025H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267946[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi

; 1129 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_START_TRADE_ROUTE");

	lea	ecx, DWORD PTR $T267947[esp+392]
	push	OFFSET $SG221940
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+400], 38		; 00000026H
$LN243@DoStartQue:
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267947[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], bl
	call	edi
$LN1@DoStartQue:

; 1130 : 	}
; 1131 : 
; 1132 : 	strMessage << pMinor->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1133 : 	strSummary << pMinor->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+396]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1134 : 	pMinor->GetMinorCivAI()->AddQuestNotification(strMessage.toUTF8(), strSummary.toUTF8(), m_eAssignedPlayer, iNotificationX, iNotificationY);

	mov	edx, DWORD PTR _iNotificationY$[esp+392]
	mov	eax, DWORD PTR _iNotificationX$[esp+392]
	mov	ecx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	0
	push	edx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[esp+408]
	call	esi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T267950[esp+436], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN235@DoStartQue
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN235@DoStartQue:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$[esp+436]
	mov	BYTE PTR __$EHRec$[esp+444], 39		; 00000027H
	call	esi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T267951[esp+464], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN240@DoStartQue
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN240@DoStartQue:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+472], 40		; 00000028H
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+472], bl
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification

; 1135 : }

	lea	ecx, DWORD PTR _strSummary$[esp+392]
	mov	BYTE PTR __$EHRec$[esp+400], 0
	call	edi
	lea	ecx, DWORD PTR _strMessage$[esp+392]
	mov	DWORD PTR __$EHRec$[esp+400], -1
	call	edi
	mov	ecx, DWORD PTR __$EHRec$[esp+392]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 376				; 00000178H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$2:
	lea	ecx, DWORD PTR $T267912[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$3:
	lea	ecx, DWORD PTR $T267913[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$4:
	lea	ecx, DWORD PTR $T267914[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$5:
	lea	ecx, DWORD PTR $T267915[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$6:
	lea	ecx, DWORD PTR $T267916[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$7:
	lea	ecx, DWORD PTR $T267917[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$8:
	lea	ecx, DWORD PTR $T267918[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$9:
	lea	ecx, DWORD PTR $T267919[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$10:
	lea	ecx, DWORD PTR $T267920[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$11:
	lea	ecx, DWORD PTR $T267921[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$12:
	lea	ecx, DWORD PTR $T267922[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$13:
	lea	ecx, DWORD PTR $T267923[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$14:
	lea	ecx, DWORD PTR $T267924[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$15:
	lea	ecx, DWORD PTR $T267925[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$16:
	lea	ecx, DWORD PTR $T267926[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$17:
	lea	ecx, DWORD PTR $T267927[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$18:
	lea	ecx, DWORD PTR $T267928[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$19:
	lea	ecx, DWORD PTR $T267929[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$20:
	lea	ecx, DWORD PTR $T267930[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$21:
	lea	ecx, DWORD PTR $T267931[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$22:
	lea	ecx, DWORD PTR $T267932[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$23:
	lea	ecx, DWORD PTR $T267933[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$24:
	lea	ecx, DWORD PTR $T267934[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$25:
	lea	ecx, DWORD PTR $T267935[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$26:
	lea	ecx, DWORD PTR $T267936[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$27:
	lea	ecx, DWORD PTR $T267937[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$28:
	lea	ecx, DWORD PTR $T267938[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$29:
	lea	ecx, DWORD PTR $T267939[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$30:
	lea	ecx, DWORD PTR $T267940[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$31:
	lea	ecx, DWORD PTR $T267941[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$32:
	lea	ecx, DWORD PTR $T267942[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$33:
	lea	ecx, DWORD PTR $T267943[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$34:
	lea	ecx, DWORD PTR $T267944[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$35:
	lea	ecx, DWORD PTR $T267945[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$36:
	lea	ecx, DWORD PTR _strReligion$221930[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$37:
	lea	ecx, DWORD PTR $T267946[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$38:
	lea	ecx, DWORD PTR $T267947[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$39:
	mov	ecx, DWORD PTR $T267950[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z$40:
	mov	ecx, DWORD PTR $T267951[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoStartQuest@CvMinorCivQuest@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoStartQuest@CvMinorCivQuest@@QAEXH@Z ENDP		; CvMinorCivQuest::DoStartQuest
PUBLIC	?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z ; CvMinorCivQuest::DoStartQuestUsingExistingData
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$5
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z
_TEXT	SEGMENT
$T268338 = -269						; size = 1
tv517 = -268						; size = 4
$T268421 = -268						; size = 4
_iMapX$268416 = -264					; size = 4
$T268290 = -260						; size = 4
_iCampX$221958 = -260					; size = 4
$T268289 = -256						; size = 4
_iCampY$221959 = -256					; size = 4
_strSummary$ = -252					; size = 80
_strMessage$ = -172					; size = 80
$T268286 = -92						; size = 80
$T268285 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_pExistingQuest$ = 8					; size = 4
?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z PROC ; CvMinorCivQuest::DoStartQuestUsingExistingData, COMDAT
; _this$ = ecx

; 1140 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 1141 : 	CvPlayer* pMinor = &GET_PLAYER(m_eMinor);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	esp, 260				; 00000104H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ebp, DWORD PTR [edi]

; 1142 : 	CvPlayer* pAssignedPlayer = &GET_PLAYER(m_eAssignedPlayer);

	mov	ebx, DWORD PTR [edi+4]
	imul	ebp, 63236				; 0000f704H
	imul	ebx, 63236				; 0000f704H
	add	ebp, eax
	add	ebx, eax

; 1143 : 
; 1144 : 	CvAssertMsg(pMinor != NULL, "pMinor should not be NULL. Please send Anton your save file and version.");
; 1145 : 	CvAssertMsg(pAssignedPlayer != NULL, "pAssignedPlayer should not be NULL. Please send Anton your save file and version.");
; 1146 : 	CvAssertMsg(pExistingQuest != NULL, "pExistingQuest should not be NULL. Please send Anton your save file and version.");
; 1147 : 	if(pMinor == NULL || pAssignedPlayer == NULL || pExistingQuest == NULL) return;

	test	ebp, ebp
	je	$LN7@DoStartQue@2
	test	ebx, ebx
	je	$LN7@DoStartQue@2
	mov	esi, DWORD PTR _pExistingQuest$[esp+284]
	test	esi, esi
	je	$LN7@DoStartQue@2

; 1148 : 
; 1149 : 	Localization::String strMessage;

	lea	ecx, DWORD PTR _strMessage$[esp+288]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 1150 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+288]
	mov	DWORD PTR __$EHRec$[esp+296], 0
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 1151 : 	int iNotificationX = -1;
; 1152 : 	int iNotificationY = -1;
; 1153 : 
; 1154 : 	// Kill a Camp - This quest needs to have the data for the same camp as the existing quest
; 1155 : 	if(m_eType == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	DWORD PTR [edi+8], 1
	mov	BYTE PTR __$EHRec$[esp+296], 1
	jne	$LN6@DoStartQue@2

; 1156 : 	{
; 1157 : 		m_iStartTurn = pExistingQuest->GetStartTurn();

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax

; 1158 : 
; 1159 : 		int iCampX = pExistingQuest->GetPrimaryData();

	mov	eax, DWORD PTR [esi+16]

; 1160 : 		int iCampY = pExistingQuest->GetSecondaryData();

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR _iCampX$221958[esp+288], eax
	mov	DWORD PTR _iCampY$221959[esp+288], ecx

; 1161 : 
; 1162 : 		CvPlot* pPlot = GC.getMap().plot(iCampX, iCampY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN1@DoStartQue@2
	cmp	ecx, -2147483647			; 80000001H
	je	$LN1@DoStartQue@2
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edx+4056]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [esi+4020]
	test	dl, dl
	je	SHORT $LN39@DoStartQue@2
	test	eax, eax
	jge	SHORT $LN41@DoStartQue@2
	cdq
	idiv	esi
	mov	eax, edx
	add	eax, esi
$LN39@DoStartQue@2:
	mov	DWORD PTR _iMapX$268416[esp+288], eax
$LN43@DoStartQue@2:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edx+4057]
	mov	BYTE PTR $T268338[esp+288], dl
	cmp	BYTE PTR $T268338[esp+288], 0
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [edx+4024]
	mov	DWORD PTR tv517[esp+288], edx
	je	SHORT $LN49@DoStartQue@2
	test	ecx, ecx
	jge	SHORT $LN51@DoStartQue@2
	mov	eax, ecx
	mov	ecx, DWORD PTR tv517[esp+288]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _iMapX$268416[esp+288]
	add	edx, ecx
	jmp	SHORT $LN53@DoStartQue@2
$LN41@DoStartQue@2:
	cmp	eax, esi
	jl	SHORT $LN39@DoStartQue@2
	cdq
	idiv	esi
	mov	eax, edx
	mov	DWORD PTR _iMapX$268416[esp+288], edx
	jmp	SHORT $LN43@DoStartQue@2
$LN51@DoStartQue@2:
	cmp	ecx, edx
	jl	SHORT $LN49@DoStartQue@2
	mov	eax, ecx
	cdq
	idiv	DWORD PTR tv517[esp+288]
	mov	eax, DWORD PTR _iMapX$268416[esp+288]
	jmp	SHORT $LN53@DoStartQue@2
$LN49@DoStartQue@2:
	mov	edx, ecx
$LN53@DoStartQue@2:
	test	eax, eax
	jl	$LN1@DoStartQue@2
	cmp	eax, esi
	jge	$LN1@DoStartQue@2
	test	edx, edx
	jl	$LN1@DoStartQue@2
	cmp	edx, DWORD PTR tv517[esp+288]
	jge	$LN1@DoStartQue@2
	imul	esi, edx
	add	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]

; 1163 : 
; 1164 : 		if(!pPlot)

	test	esi, esi

; 1165 : 		{
; 1166 : 			CvAssertMsg(false, "We're starting a quest to kill a barb camp using an existing quest's barb camp data, but the data is bad. Please send Anton your save file and version.");
; 1167 : 			return;

	je	$LN1@DoStartQue@2

; 1168 : 		}
; 1169 : 		if(pPlot->getImprovementType() != GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T268421[esp+288], ecx
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T268421[esp+288]

; 1170 : 		{
; 1171 : 			CvAssertMsg(false, "We're starting a quest to kill a barb camp using an existing quest's barb camp data, but there's no camp there anymore. Please send Anton your save file and version.");
; 1172 : 			return;

	jne	$LN1@DoStartQue@2

; 1173 : 		}
; 1174 : 
; 1175 : 		m_iData1 = iCampX;

	mov	edx, DWORD PTR _iCampX$221958[esp+288]

; 1176 : 		m_iData2 = iCampY;

	mov	eax, DWORD PTR _iCampY$221959[esp+288]

; 1177 : 
; 1178 : 		pPlot->setRevealed(pAssignedPlayer->getTeam(), true);

	push	-1
	push	0
	push	1
	mov	ecx, ebx
	mov	DWORD PTR [edi+16], edx
	mov	DWORD PTR [edi+20], eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 1179 : 		pPlot->setRevealedImprovementType(pAssignedPlayer->getTeam(), pPlot->getImprovementType());

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType

; 1180 : 
; 1181 : 		strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_QUEST_KILL_CAMP");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR $T268285[esp+288]
	push	OFFSET $SG221964
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 2
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T268285[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1182 : 		strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_QUEST_KILL_CAMP");

	lea	edx, DWORD PTR $T268286[esp+288]
	push	OFFSET $SG221966
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T268286[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1183 : 		iNotificationX = pPlot->getX();

	movsx	ebx, WORD PTR [esi]

; 1184 : 		iNotificationY = pPlot->getY();

	movsx	esi, WORD PTR [esi+2]

; 1185 : 
; 1186 : 		strMessage << pMinor->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+292]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1187 : 		strSummary << pMinor->getNameKey();

	mov	ecx, ebp
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+292]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 1188 : 		pMinor->GetMinorCivAI()->AddQuestNotification(strMessage.toUTF8(), strSummary.toUTF8(), m_eAssignedPlayer, iNotificationX, iNotificationY);

	mov	eax, DWORD PTR [edi+4]
	push	0
	push	esi
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+304]
	call	esi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T268289[esp+332], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	ecx, DWORD PTR _strMessage$[esp+332]
	mov	BYTE PTR __$EHRec$[esp+340], 4
	call	esi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T268290[esp+360], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+368], 5
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+368], 1
	call	?AddQuestNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH_N@Z ; CvMinorCivAI::AddQuestNotification
	jmp	SHORT $LN1@DoStartQue@2
$LN6@DoStartQue@2:

; 1189 : 	}
; 1190 : 
; 1191 : 	// Other global quests (ie. contests) - Quest data is initialized as normal except for the start turn, which was in the past
; 1192 : 	else if(pMinor->GetMinorCivAI()->IsGlobalQuest(pExistingQuest->GetType()))

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsGlobalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsGlobalQuest

; 1193 : 	{
; 1194 : 		DoStartQuest(pExistingQuest->GetStartTurn());

	mov	esi, DWORD PTR [esi+12]
	mov	ecx, edi
	push	esi

; 1195 : 	}
; 1196 : 
; 1197 : 	// Personal quests - Should not be started from an existing quest's data!!
; 1198 : 	else
; 1199 : 	{
; 1200 : 		CvAssertMsg(false, "Trying to start a personal quest using existing quest data.  This should not be done.  Please send Anton your save file and version.");
; 1201 : 		DoStartQuest(pExistingQuest->GetStartTurn());

	call	?DoStartQuest@CvMinorCivQuest@@QAEXH@Z	; CvMinorCivQuest::DoStartQuest
$LN1@DoStartQue@2:

; 1202 : 	}
; 1203 : }

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+288]
	mov	DWORD PTR __$EHRec$[esp+296], -1
	call	esi
$LN7@DoStartQue@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+288]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 272				; 00000110H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$2:
	lea	ecx, DWORD PTR $T268285[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$3:
	lea	ecx, DWORD PTR $T268286[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$4:
	mov	ecx, DWORD PTR $T268289[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z$5:
	mov	ecx, DWORD PTR $T268290[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z ENDP ; CvMinorCivQuest::DoStartQuestUsingExistingData
PUBLIC	?Init@CvMinorCivAI@@QAEXPAVCvPlayer@@@Z		; CvMinorCivAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvMinorCivAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvMinorCivAI@@QAEXPAVCvPlayer@@@Z PROC		; CvMinorCivAI::Init, COMDAT
; _this$ = ecx

; 1626 : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 1627 : 	m_minorCivType = CvPreGame::minorCivType(m_pPlayer->GetID());

	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4

; 1628 : 
; 1629 : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR [esi+4], eax
	call	?Reset@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::Reset
	pop	esi

; 1630 : }

	ret	4
?Init@CvMinorCivAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvMinorCivAI::Init
_TEXT	ENDS
PUBLIC	?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ; CvMinorCivAI::AddQuestForPlayer
EXTRN	?LogMinorCivQuestReceived@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z:PROC ; CvDiplomacyAI::LogMinorCivQuestReceived
; Function compile flags: /Ogtpy
;	COMDAT ?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z
_TEXT	SEGMENT
_newQuest$ = -28					; size = 28
$T268499 = 8						; size = 4
_ePlayer$ = 8						; size = 4
_eType$ = 12						; size = 4
_iStartTurn$ = 16					; size = 4
?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z PROC ; CvMinorCivAI::AddQuestForPlayer, COMDAT
; _this$ = ecx

; 3059 : {

	sub	esp, 28					; 0000001cH
	push	ebx

; 3060 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3061 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3062 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	ebx, DWORD PTR _ePlayer$[esp+28]
	push	edi
	mov	edi, ecx
	cmp	ebx, 21					; 00000015H
	ja	$LN2@AddQuestFo
	push	ebp

; 3063 : 
; 3064 : 	CvAssertMsg(eType >= NO_MINOR_CIV_QUEST_TYPE, "eType is expected to be non-negative (invalid Index)");
; 3065 : 	CvAssertMsg(eType < NUM_MINOR_CIV_QUEST_TYPES, "eType is expected to be within maximum bounds (invalid Index)");
; 3066 : 	if(eType < NO_MINOR_CIV_QUEST_TYPE || eType >= NUM_MINOR_CIV_QUEST_TYPES) return;

	mov	ebp, DWORD PTR _eType$[esp+36]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, 18					; 00000012H
	ja	$LN26@AddQuestFo

; 3067 : 
; 3068 : 	// ePlayer can only have at most one quest of each type
; 3069 : 	CvAssertMsg(!IsActiveQuestForPlayer(ePlayer, eType), "ePlayer already has a quest of this type!");
; 3070 : 	if(IsActiveQuestForPlayer(ePlayer, eType)) return;

	push	ebp
	push	ebx
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al
	jne	SHORT $LN26@AddQuestFo

; 3071 : 
; 3072 : 	CvMinorCivQuest newQuest(GetPlayer()->GetID(), ePlayer, eType);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+44]
	push	esi
	push	ebp
	push	ebx
	push	edx
	lea	ecx, DWORD PTR _newQuest$[esp+56]
	call	??0CvMinorCivQuest@@QAE@W4PlayerTypes@@0W4MinorCivQuestTypes@@@Z ; CvMinorCivQuest::CvMinorCivQuest

; 3073 : 	newQuest.DoStartQuest(iStartTurn);

	mov	eax, DWORD PTR _iStartTurn$[esp+40]
	push	eax
	lea	ecx, DWORD PTR _newQuest$[esp+48]
	call	?DoStartQuest@CvMinorCivQuest@@QAEXH@Z	; CvMinorCivQuest::DoStartQuest

; 3074 : 	m_QuestsGiven[ePlayer].push_back(newQuest);

	lea	ecx, DWORD PTR _newQuest$[esp+44]
	push	ecx
	mov	ecx, ebx
	imul	ecx, 156				; 0000009cH
	add	ecx, DWORD PTR [edi+3328]
	call	?push_back@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEIABVCvMinorCivQuest@@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::push_back

; 3075 : 
; 3076 : 	// Log quest received
; 3077 : 	GET_PLAYER(ePlayer).GetDiplomacyAI()->LogMinorCivQuestReceived(GetPlayer()->GetID(), GetEffectiveFriendshipWithMajorTimes100(ePlayer), GetEffectiveFriendshipWithMajorTimes100(ePlayer), eType);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	esi, ebx
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR $T268499[esp+48], eax
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
	push	eax
	push	ebx
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
	mov	ecx, DWORD PTR $T268499[esp+48]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivQuestReceived@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z ; CvDiplomacyAI::LogMinorCivQuestReceived
	pop	esi
$LN26@AddQuestFo:
	pop	ebp
$LN2@AddQuestFo:
	pop	edi
	pop	ebx

; 3078 : }

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ENDP ; CvMinorCivAI::AddQuestForPlayer
_TEXT	ENDS
PUBLIC	?AddQuestCopyForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvMinorCivQuest@@@Z ; CvMinorCivAI::AddQuestCopyForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?AddQuestCopyForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvMinorCivQuest@@@Z
_TEXT	SEGMENT
_newQuest$ = -28					; size = 28
_ePlayer$ = 8						; size = 4
_pQuest$ = 12						; size = 4
?AddQuestCopyForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvMinorCivQuest@@@Z PROC ; CvMinorCivAI::AddQuestCopyForPlayer, COMDAT
; _this$ = ecx

; 3082 : {

	sub	esp, 28					; 0000001cH
	push	ebx

; 3083 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3084 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3085 : 	if(ePlayer < 0 || ePlayer >= MAX_MAJOR_CIVS) return;

	mov	ebx, DWORD PTR _ePlayer$[esp+28]
	push	edi
	mov	edi, ecx
	cmp	ebx, 21					; 00000015H
	ja	$LN3@AddQuestCo
	push	esi

; 3086 : 
; 3087 : 	CvAssertMsg(pQuest != NULL, "pQuest should not be NULL. Please send Anton your save file and version.");
; 3088 : 	if(pQuest == NULL) return;

	mov	esi, DWORD PTR _pQuest$[esp+36]
	test	esi, esi
	je	$LN33@AddQuestCo
	push	ebp

; 3089 : 
; 3090 : 	// ePlayer can only have at most one quest of each type
; 3091 : 	CvAssertMsg(!IsActiveQuestForPlayer(ePlayer, pQuest->GetType()), "ePlayer already has a quest of this type!");
; 3092 : 	if(IsActiveQuestForPlayer(ePlayer, pQuest->GetType())) return;

	mov	ebp, DWORD PTR [esi+8]
	push	ebp
	push	ebx
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al
	jne	SHORT $LN34@AddQuestCo

; 3093 : 
; 3094 : 	CvMinorCivQuest newQuest(GetPlayer()->GetID(), ePlayer, pQuest->GetType());

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+44]
	or	eax, -1
	mov	DWORD PTR _newQuest$[esp+44], ecx

; 3095 : 	newQuest.DoStartQuestUsingExistingData(pQuest);

	push	esi
	lea	ecx, DWORD PTR _newQuest$[esp+48]
	mov	DWORD PTR _newQuest$[esp+52], ebx
	mov	DWORD PTR _newQuest$[esp+56], ebp
	mov	DWORD PTR _newQuest$[esp+60], eax
	mov	DWORD PTR _newQuest$[esp+64], eax
	mov	DWORD PTR _newQuest$[esp+68], eax
	mov	BYTE PTR _newQuest$[esp+72], 0
	call	?DoStartQuestUsingExistingData@CvMinorCivQuest@@QAEXPAV1@@Z ; CvMinorCivQuest::DoStartQuestUsingExistingData

; 3096 : 	m_QuestsGiven[ePlayer].push_back(newQuest);

	mov	ecx, ebx
	imul	ecx, 156				; 0000009cH
	add	ecx, DWORD PTR [edi+3328]
	lea	edx, DWORD PTR _newQuest$[esp+44]
	push	edx
	call	?push_back@?$FStaticVector@VCvMinorCivQuest@@$04$0A@$0BCJ@$0A@@@QAEIABVCvMinorCivQuest@@@Z ; FStaticVector<CvMinorCivQuest,5,0,297,0>::push_back

; 3097 : 
; 3098 : 	// Log quest received
; 3099 : 	GET_PLAYER(ePlayer).GetDiplomacyAI()->LogMinorCivQuestReceived(GetPlayer()->GetID(), GetEffectiveFriendshipWithMajorTimes100(ePlayer), GetEffectiveFriendshipWithMajorTimes100(ePlayer), pQuest->GetType());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi]
	mov	ebp, DWORD PTR [ecx+44]
	mov	esi, ebx
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	push	ebx
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
	push	eax
	push	ebx
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
	push	eax
	push	ebp
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivQuestReceived@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4MinorCivQuestTypes@@@Z ; CvDiplomacyAI::LogMinorCivQuestReceived
$LN34@AddQuestCo:
	pop	ebp
$LN33@AddQuestCo:
	pop	esi
$LN3@AddQuestCo:
	pop	edi
	pop	ebx

; 3100 : }

	add	esp, 28					; 0000001cH
	ret	8
?AddQuestCopyForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvMinorCivQuest@@@Z ENDP ; CvMinorCivAI::AddQuestCopyForPlayer
_TEXT	ENDS
PUBLIC	?DoCompletedQuests@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoCompletedQuests
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ$0
__ehfuncinfo$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoCompletedQuests@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
_vePlayers$ = -540					; size = 528
__$EHRec$ = -12						; size = 12
?DoCompletedQuests@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoCompletedQuests, COMDAT
; _this$ = ecx

; 3171 : {

	push	-1
	push	__ehhandler$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 528				; 00000210H
	push	esi
	push	edi

; 3172 : 	WeightedCivsList vePlayers = CalculateFriendshipFromQuests();

	lea	eax, DWORD PTR _vePlayers$[esp+548]
	push	eax
	mov	edi, ecx
	call	?CalculateFriendshipFromQuests@CvMinorCivAI@@QAE?AV?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@XZ ; CvMinorCivAI::CalculateFriendshipFromQuests
	xor	esi, esi

; 3173 : 
; 3174 : 	// Resolve quests starting with player that will end up with most influence, to avoid multiple ally swaps and awkward war declarations
; 3175 : 	for (int iMajorIndex = 0; iMajorIndex < vePlayers.size(); iMajorIndex++)

	cmp	DWORD PTR _vePlayers$[esp+552], esi
	mov	DWORD PTR __$EHRec$[esp+556], esi
	jle	SHORT $LN1@DoComplete@2
	npad	8
$LL3@DoComplete@2:

; 3176 : 	{
; 3177 : 		PlayerTypes eMajor = vePlayers.GetElement(iMajorIndex);

	mov	ecx, DWORD PTR _vePlayers$[esp+548]
	mov	eax, DWORD PTR [ecx+esi*8]

; 3178 : 		DoCompletedQuestsForPlayer(eMajor);

	push	-1
	push	eax
	mov	ecx, edi
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
	inc	esi
	cmp	esi, DWORD PTR _vePlayers$[esp+552]
	jl	SHORT $LL3@DoComplete@2
$LN1@DoComplete@2:

; 3179 : 	}
; 3180 : }

	mov	eax, DWORD PTR _vePlayers$[esp+548]
	lea	edx, DWORD PTR _vePlayers$[esp+560]
	pop	edi
	mov	DWORD PTR __$EHRec$[esp+552], -1
	pop	esi
	cmp	eax, edx
	je	SHORT $LN20@DoComplete@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@DoComplete@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+540]
	mov	DWORD PTR fs:0, ecx
	add	esp, 540				; 0000021cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _vePlayers$[ebp]
	jmp	??1?$CvWeightedVector@W4PlayerTypes@@$0EA@$00@@QAE@XZ ; CvWeightedVector<enum PlayerTypes,64,1>::~CvWeightedVector<enum PlayerTypes,64,1>
__ehhandler$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoCompletedQuests@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoCompletedQuests@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoCompletedQuests
PUBLIC	?DoQuestsCleanup@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoQuestsCleanup
; Function compile flags: /Ogtpy
;	COMDAT ?DoQuestsCleanup@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoQuestsCleanup@CvMinorCivAI@@QAEXXZ PROC		; CvMinorCivAI::DoQuestsCleanup, COMDAT
; _this$ = ecx

; 3300 : {

	push	esi
	push	edi
	mov	edi, ecx

; 3301 : 	for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
$LL3@DoQuestsCl@2:

; 3302 : 	{
; 3303 : 		PlayerTypes eMajorLoop = (PlayerTypes) iMajorLoop;
; 3304 : 		DoQuestsCleanupForPlayer(eMajorLoop);

	push	esi
	mov	ecx, edi
	call	?DoQuestsCleanupForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoQuestsCleanupForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL3@DoQuestsCl@2
	pop	edi
	pop	esi

; 3305 : 	}
; 3306 : }

	ret	0
?DoQuestsCleanup@CvMinorCivAI@@QAEXXZ ENDP		; CvMinorCivAI::DoQuestsCleanup
_TEXT	ENDS
PUBLIC	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
EXTRN	?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z:PROC ; CvGameTrade::CanCreateTradeRoute
EXTRN	?HasCreatedReligion@CvGameReligions@@QBE_NW4PlayerTypes@@@Z:PROC ; CvGameReligions::HasCreatedReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
tv741 = -4						; size = 4
tv642 = 8						; size = 4
_iLoop$224665 = 8					; size = 4
_ePlayer$ = 8						; size = 4
tv699 = 12						; size = 4
$T268791 = 12						; size = 4
_bInRange$224667 = 12					; size = 1
_pMinorsCapital$ = 12					; size = 4
_eQuest$ = 12						; size = 4
?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::IsValidQuestForPlayer, COMDAT
; _this$ = ecx

; 3470 : {

	push	ecx
	push	ebx

; 3471 : 	// The quest type must be enabled
; 3472 : 	if(!IsEnabledQuest(eQuest))

	mov	ebx, DWORD PTR _eQuest$[esp+4]
	push	esi
	push	ebx
	mov	esi, ecx
	call	?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsEnabledQuest
	test	al, al
	jne	SHORT $LN96@IsValidQue
	pop	esi
	pop	ebx

; 3765 : }

	pop	ecx
	ret	8
$LN96@IsValidQue:

; 3473 : 		return false;
; 3474 : 
; 3475 : 	// Somebody's dead, that's no good
; 3476 : 	if(!GET_PLAYER(ePlayer).isAlive() || !GetPlayer()->isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+16]
	mov	ebp, edi
	imul	ebp, 63236				; 0000f704H
	cmp	BYTE PTR [eax+ebp+2256], 0
	je	$LN94@IsValidQue
	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+2256], 0
	je	$LN94@IsValidQue

; 3478 : 
; 3479 : 	// No quests are valid if we are at war
; 3480 : 	if(IsAtWarWithPlayersTeam(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al

; 3481 : 		return false;

	jne	$LN94@IsValidQue

; 3482 : 
; 3483 : 	// No quests are valid if we don't know you yet
; 3484 : 	if(!IsHasMetPlayer(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al

; 3485 : 		return false;

	je	$LN94@IsValidQue

; 3486 : 
; 3487 : 	// This player cannot already have an active quest of the same type
; 3488 : 	if(IsActiveQuestForPlayer(ePlayer, eQuest))

	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al

; 3489 : 		return false;

	jne	$LN94@IsValidQue

; 3490 : 
; 3491 : 	// Both players must have a capital
; 3492 : 	CvCity* pMinorsCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [esi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 3493 : 	CvCity* pMajorsCapital = GET_PLAYER(ePlayer).getCapitalCity();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	mov	DWORD PTR _pMinorsCapital$[esp+16], eax
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 3494 : 	if(pMinorsCapital == NULL || pMajorsCapital == NULL)

	cmp	DWORD PTR _pMinorsCapital$[esp+16], 0
	je	$LN94@IsValidQue
	test	eax, eax
	je	$LN94@IsValidQue

; 3495 : 		return false;
; 3496 : 
; 3497 : 	// BUILD A ROUTE
; 3498 : 	if(eQuest == MINOR_CIV_QUEST_ROUTE)

	test	ebx, ebx
	jne	$LN88@IsValidQue

; 3499 : 	{
; 3500 : 		// This player must not have bullied us recently
; 3501 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3502 : 			return false;

	jne	$LN94@IsValidQue

; 3503 : 
; 3504 : 		// Must have been friends at some point
; 3505 : 		if(!IsEverFriends(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsEverFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsEverFriends
	test	al, al

; 3506 : 			return false;

	je	$LN94@IsValidQue

; 3507 : 
; 3508 : 		// Cannot already have a route
; 3509 : 		if (GET_PLAYER(ePlayer).IsCapitalConnectedToPlayer(GetPlayer()->GetID()))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	add	ecx, ebp
	push	eax
	call	?IsCapitalConnectedToPlayer@CvPlayer@@QAE_NW4PlayerTypes@@W4RouteTypes@@@Z ; CvPlayer::IsCapitalConnectedToPlayer
	test	al, al

; 3510 : 			return false;

	jne	$LN94@IsValidQue

; 3511 : 
; 3512 : 		// Can't have completed this Quest already
; 3513 : 		if(IsRouteConnectionEstablished(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRouteConnectionEstablished@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRouteConnectionEstablished
	test	al, al

; 3514 : 			return false;

	jne	$LN94@IsValidQue

; 3515 : 
; 3516 : 		// Must have a city close to the minor in the same Area
; 3517 : 		const int iMaxRouteDistance = 8; //antonjs: todo: xml
; 3518 : 		CvPlot* pMinorsPlot = pMinorsCapital->plot();

	mov	ecx, DWORD PTR _pMinorsCapital$[esp+16]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edi, eax

; 3519 : 		if(pMinorsPlot == NULL)

	test	edi, edi

; 3520 : 			return false;

	je	$LN94@IsValidQue

; 3521 : 
; 3522 : 		int iLoop;
; 3523 : 		CvCity* pLoopCity;
; 3524 : 		bool bInRange = false;
; 3525 : 		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	lea	eax, DWORD PTR _iLoop$224665[esp+20]
	lea	ecx, DWORD PTR [edx+ebp]
	push	eax
	mov	BYTE PTR _bInRange$224667[esp+24], bl
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN94@IsValidQue
$LL82@IsValidQue:

; 3526 : 		{
; 3527 : 			if(pMinorsPlot->getArea() != pLoopCity->getArea())

	mov	ebx, DWORD PTR [edi+356]
	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	ebx, eax
	jne	SHORT $LN81@IsValidQue

; 3528 : 				continue;
; 3529 : 			int iDistance = plotDistance(pMinorsPlot->getX(), pMinorsPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+96]

; 3530 : 			if(iDistance < iMaxRouteDistance)

	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 8
	jge	SHORT $LN81@IsValidQue

; 3531 : 				bInRange = true;

	mov	BYTE PTR _bInRange$224667[esp+16], 1
$LN81@IsValidQue:

; 3521 : 
; 3522 : 		int iLoop;
; 3523 : 		CvCity* pLoopCity;
; 3524 : 		bool bInRange = false;
; 3525 : 		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$224665[esp+20]
	lea	ecx, DWORD PTR [edx+ebp]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL82@IsValidQue

; 3532 : 		}
; 3533 : 
; 3534 : 		if(!bInRange)

	cmp	BYTE PTR _bInRange$224667[esp+16], al

; 3535 : 			return false;

	jmp	SHORT $LN212@IsValidQue
$LN88@IsValidQue:

; 3536 : 	}
; 3537 : 	// KILL A CAMP
; 3538 : 	else if(eQuest == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	ebx, 1
	jne	SHORT $LN75@IsValidQue

; 3539 : 	{
; 3540 : 		// Any nearby camps?
; 3541 : 		if(GetBestNearbyCampToKill() == NULL)

	mov	ecx, esi
	call	?GetBestNearbyCampToKill@CvMinorCivAI@@QAEPAVCvPlot@@XZ ; CvMinorCivAI::GetBestNearbyCampToKill
	test	eax, eax

; 3542 : 			return false;

	jmp	SHORT $LN212@IsValidQue
$LN75@IsValidQue:

; 3543 : 	}
; 3544 : 	// CONNECT A RESOURCE
; 3545 : 	else if(eQuest == MINOR_CIV_QUEST_CONNECT_RESOURCE)

	cmp	ebx, 2
	jne	SHORT $LN72@IsValidQue

; 3546 : 	{
; 3547 : 		// This player must not have bullied us recently
; 3548 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3549 : 			return false;

	jne	SHORT $LN94@IsValidQue

; 3550 : 
; 3551 : 		ResourceTypes eResource = GetNearbyResourceForQuest(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetNearbyResourceForQuest@CvMinorCivAI@@QAE?AW4ResourceTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetNearbyResourceForQuest
$LN213@IsValidQue:

; 3564 : 
; 3565 : 		if(eWonder == NO_BUILDING)

	cmp	eax, -1
$LN212@IsValidQue:

; 3539 : 	{
; 3540 : 		// Any nearby camps?
; 3541 : 		if(GetBestNearbyCampToKill() == NULL)

	jne	$LN1@IsValidQue
$LN94@IsValidQue:
	pop	edi
	pop	ebp
	pop	esi

; 3477 : 		return false;

	xor	al, al
	pop	ebx

; 3765 : }

	pop	ecx
	ret	8
$LN72@IsValidQue:

; 3552 : 
; 3553 : 		if(eResource == NO_RESOURCE)
; 3554 : 			return false;
; 3555 : 	}
; 3556 : 	// CONSTRUCT A WONDER
; 3557 : 	else if(eQuest == MINOR_CIV_QUEST_CONSTRUCT_WONDER)

	cmp	ebx, 3
	jne	SHORT $LN68@IsValidQue

; 3558 : 	{
; 3559 : 		// This player must not have bullied us recently
; 3560 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3561 : 			return false;

	jne	SHORT $LN94@IsValidQue

; 3562 : 
; 3563 : 		BuildingTypes eWonder = GetBestWonderForQuest(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetBestWonderForQuest@CvMinorCivAI@@QAE?AW4BuildingTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetBestWonderForQuest

; 3566 : 			return false;

	jmp	SHORT $LN213@IsValidQue
$LN68@IsValidQue:

; 3567 : 	}
; 3568 : 	// GREAT PERSON
; 3569 : 	else if(eQuest == MINOR_CIV_QUEST_GREAT_PERSON)

	cmp	ebx, 4
	jne	SHORT $LN64@IsValidQue

; 3570 : 	{
; 3571 : 		// This player must not have bullied us recently
; 3572 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3573 : 			return false;

	jne	SHORT $LN94@IsValidQue

; 3574 : 
; 3575 : 		UnitTypes eUnit = GetBestGreatPersonForQuest(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetBestGreatPersonForQuest@CvMinorCivAI@@QAE?AW4UnitTypes@@W4PlayerTypes@@@Z ; CvMinorCivAI::GetBestGreatPersonForQuest

; 3576 : 
; 3577 : 		if(eUnit == NO_UNIT)
; 3578 : 			return false;

	jmp	SHORT $LN213@IsValidQue
$LN64@IsValidQue:

; 3579 : 	}
; 3580 : 	// KILL ANOTHER CITY STATE
; 3581 : 	else if(eQuest == MINOR_CIV_QUEST_KILL_CITY_STATE)

	cmp	ebx, 5
	jne	SHORT $LN60@IsValidQue

; 3582 : 	{
; 3583 : 		// Friendly City States don't give out this quest
; 3584 : 		if(GetPersonality() == MINOR_CIV_PERSONALITY_FRIENDLY)

	cmp	DWORD PTR [esi+8], 0

; 3585 : 			return false;

	je	SHORT $LN94@IsValidQue

; 3586 : 
; 3587 : 		PlayerTypes eTargetCityState = GetBestCityStateTarget(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestCityStateTarget

; 3588 : 
; 3589 : 		if(eTargetCityState == NO_PLAYER)
; 3590 : 			return false;

	jmp	SHORT $LN213@IsValidQue
$LN60@IsValidQue:

; 3591 : 	}
; 3592 : 	// FIND ANOTHER PLAYER
; 3593 : 	else if(eQuest == MINOR_CIV_QUEST_FIND_PLAYER)

	cmp	ebx, 6
	jne	SHORT $LN56@IsValidQue

; 3594 : 	{
; 3595 : 		// This player must not have bullied us recently
; 3596 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3597 : 			return false;

	jne	SHORT $LN94@IsValidQue

; 3598 : 
; 3599 : 		PlayerTypes eTarget = GetBestPlayerToFind(ePlayer);

	push	edi
	mov	ecx, esi
	call	?GetBestPlayerToFind@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestPlayerToFind

; 3600 : 
; 3601 : 		if(eTarget == NO_PLAYER)
; 3602 : 			return false;

	jmp	SHORT $LN213@IsValidQue
$LN56@IsValidQue:

; 3603 : 	}
; 3604 : 	// FIND NATURAL WONDER
; 3605 : 	else if(eQuest == MINOR_CIV_QUEST_FIND_NATURAL_WONDER)

	cmp	ebx, 7
	jne	SHORT $LN52@IsValidQue

; 3606 : 	{
; 3607 : 		// This player must not have bullied us recently
; 3608 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3609 : 			return false;

	jne	$LN94@IsValidQue

; 3610 : 
; 3611 : 		if(!IsGoodTimeForNaturalWonderQuest(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsGoodTimeForNaturalWonderQuest@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsGoodTimeForNaturalWonderQuest
	test	al, al

; 3612 : 			return false;

	jmp	$LN212@IsValidQue
$LN52@IsValidQue:

; 3613 : 	}
; 3614 : 	// GOLD GIFT
; 3615 : 	else if(eQuest == MINOR_CIV_QUEST_GIVE_GOLD)

	cmp	ebx, 8
	jne	SHORT $LN48@IsValidQue

; 3616 : 	{
; 3617 : 		// We don't need help if we've never been bullied
; 3618 : 		if(!IsEverBulliedByAnyMajor())

	mov	ecx, esi
	call	?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsEverBulliedByAnyMajor
	test	al, al

; 3619 : 			return false;

	je	$LN94@IsValidQue

; 3620 : 
; 3621 : 		// This player must not have bullied us recently
; 3622 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3623 : 			return false;

	jne	$LN94@IsValidQue

; 3624 : 
; 3625 : 		// This player must not be the most recent bully
; 3626 : 		if(GetMostRecentBullyForQuest() == ePlayer)

	mov	ecx, esi
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest
	cmp	eax, edi
$LN211@IsValidQue:

; 3627 : 			return false;

	je	$LN94@IsValidQue

; 3628 : 
; 3629 : 		if(!IsGoodTimeForGiveGoldQuest())

	mov	ecx, esi
	call	?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
	test	al, al

; 3630 : 			return false;

	jmp	$LN212@IsValidQue
$LN48@IsValidQue:

; 3631 : 	}
; 3632 : 	// PLEDGE TO PROTECT
; 3633 : 	else if(eQuest == MINOR_CIV_QUEST_PLEDGE_TO_PROTECT)

	cmp	ebx, 9
	jne	SHORT $LN42@IsValidQue

; 3634 : 	{
; 3635 : 		// We don't need help if we've never been bullied
; 3636 : 		if(!IsEverBulliedByAnyMajor())

	mov	ecx, esi
	call	?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsEverBulliedByAnyMajor
	test	al, al

; 3637 : 			return false;

	je	$LN94@IsValidQue

; 3638 : 
; 3639 : 		// This player must not have bullied us recently
; 3640 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3641 : 			return false;

	jne	$LN94@IsValidQue

; 3642 : 
; 3643 : 		// This player must not be the most recent bully
; 3644 : 		if(GetMostRecentBullyForQuest() == ePlayer)

	mov	ecx, esi
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest
	cmp	eax, edi

; 3645 : 			return false;

	je	$LN94@IsValidQue

; 3646 : 
; 3647 : 		// Only if we aren't already protected by this major, and the major is allowed to start
; 3648 : 		if(!CanMajorStartProtection(ePlayer))

	push	edi
	mov	ecx, esi
	call	?CanMajorStartProtection@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::CanMajorStartProtection
	test	al, al

; 3649 : 			return false;
; 3650 : 
; 3651 : 		if(!IsGoodTimeForPledgeToProtectQuest())
; 3652 : 			return false;

	jmp	SHORT $LN211@IsValidQue
$LN42@IsValidQue:

; 3653 : 	}
; 3654 : 	// CONTEST CULTURE
; 3655 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	ebx, 10					; 0000000aH
	je	$LN1@IsValidQue

; 3656 : 	{
; 3657 : 	}
; 3658 : 	// CONTEST FAITH
; 3659 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	ebx, 11					; 0000000bH
	je	$LN1@IsValidQue

; 3660 : 	{
; 3661 : 	}
; 3662 : 	// CONTEST TECHS
; 3663 : 	else if(eQuest == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	ebx, 12					; 0000000cH
	je	$LN1@IsValidQue

; 3664 : 	{
; 3665 : 	}
; 3666 : 	// Invest
; 3667 : 	else if(eQuest == MINOR_CIV_QUEST_INVEST)

	cmp	ebx, 13					; 0000000dH
	jne	SHORT $LN29@IsValidQue

; 3668 : 	{
; 3669 : 		// This player must not have bullied us recently
; 3670 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al
	je	$LN1@IsValidQue
	pop	edi
	pop	ebp
	pop	esi
	xor	al, al
	pop	ebx

; 3765 : }

	pop	ecx
	ret	8
$LN29@IsValidQue:

; 3671 : 			return false;
; 3672 : 	}
; 3673 : 	// Bully target City-State
; 3674 : 	else if(eQuest == MINOR_CIV_QUEST_BULLY_CITY_STATE)

	cmp	ebx, 14					; 0000000eH
	jne	SHORT $LN26@IsValidQue

; 3675 : 	{
; 3676 : 		// This player must not have bullied us recently
; 3677 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3678 : 			return false;

	jne	$LN94@IsValidQue
	push	edi
	mov	ecx, esi
	call	?GetBestCityStateTarget@CvMinorCivAI@@QAE?AW4PlayerTypes@@W42@@Z ; CvMinorCivAI::GetBestCityStateTarget
	jmp	$LN213@IsValidQue
$LN26@IsValidQue:

; 3679 : 
; 3680 : 		PlayerTypes eTargetCityState = GetBestCityStateTarget(ePlayer);
; 3681 : 
; 3682 : 		if(eTargetCityState == NO_PLAYER)
; 3683 : 			return false;
; 3684 : 	}
; 3685 : 	// Denounce target Major
; 3686 : 	else if(eQuest == MINOR_CIV_QUEST_DENOUNCE_MAJOR)

	cmp	ebx, 15					; 0000000fH
	jne	$LN22@IsValidQue

; 3687 : 	{
; 3688 : 		// We don't need help if we've never been bullied
; 3689 : 		if(!IsEverBulliedByAnyMajor())

	mov	ecx, esi
	call	?IsEverBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsEverBulliedByAnyMajor
	test	al, al

; 3690 : 			return false;

	je	$LN94@IsValidQue

; 3691 : 
; 3692 : 		// This player must not have bullied us recently
; 3693 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3694 : 			return false;

	jne	$LN94@IsValidQue

; 3695 : 
; 3696 : 		// Is there a recent bully?
; 3697 : 		if(!IsGoodTimeForDenounceMajorQuest())

	mov	ecx, esi
	call	?IsRecentlyBulliedByAnyMajor@CvMinorCivAI@@QBE_NXZ ; CvMinorCivAI::IsRecentlyBulliedByAnyMajor
	test	al, al

; 3698 : 			return false;

	je	$LN94@IsValidQue

; 3699 : 
; 3700 : 		// Don't ask in always war games
; 3701 : 		if(GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	3
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 3702 : 			return false;

	jne	$LN94@IsValidQue

; 3703 : 		
; 3704 : 		PlayerTypes eMostRecentBully = GetMostRecentBullyForQuest();

	mov	ecx, esi
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest

; 3705 : 
; 3706 : 		if(eMostRecentBully == NO_PLAYER)

	cmp	eax, -1

; 3707 : 			return false;

	je	$LN94@IsValidQue

; 3708 : 
; 3709 : 		// This player must not be the most recent bully
; 3710 : 		if(eMostRecentBully == ePlayer)

	cmp	eax, edi

; 3711 : 			return false;

	je	$LN94@IsValidQue

; 3712 : 
; 3713 : 		// This player must not be teammates with the most recent bully (cannot denounce)
; 3714 : 		if(GET_PLAYER(ePlayer).getTeam() == GET_PLAYER(eMostRecentBully).getTeam())

	mov	ebx, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebx, 63236				; 0000f704H
	lea	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR tv741[esp+20], ecx
	lea	edi, DWORD PTR [eax+ebp]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, edi
	mov	DWORD PTR tv699[esp+16], eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, DWORD PTR tv699[esp+16]
	cmp	eax, ecx

; 3715 : 			return false;

	je	$LN94@IsValidQue

; 3716 : 
; 3717 : 		// This player must have met the most recent bully
; 3718 : 		if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GET_PLAYER(eMostRecentBully).getTeam()))

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, DWORD PTR tv741[esp+20]
	mov	edi, eax
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 3719 : 			return false;

	je	$LN94@IsValidQue

; 3720 : 
; 3721 : 		// This player must not be at war with the most recent bully (cannot denounce)
; 3722 : 		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(GET_PLAYER(eMostRecentBully).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR $T268791[esp+16], ecx
	lea	ecx, DWORD PTR [eax+ebp]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, DWORD PTR $T268791[esp+16]
	mov	edi, eax
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 3723 : 			return false;

	jne	$LN94@IsValidQue

; 3724 : 
; 3725 : 		// Humans are unable to denounce each other
; 3726 : 		if(GET_PLAYER(ePlayer).isHuman() && GET_PLAYER(eMostRecentBully).isHuman())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN12@IsValidQue
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al

; 3727 : 			return false;

	jne	$LN94@IsValidQue
$LN12@IsValidQue:

; 3728 : 
; 3729 : 		// This player must not have already denounced the most recent bully
; 3730 : 		if(GET_PLAYER(ePlayer).GetDiplomacyAI()->IsDenouncedPlayer(GetMostRecentBullyForQuest()))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edi, DWORD PTR [ecx+ebp]
	mov	ecx, esi
	call	?GetMostRecentBullyForQuest@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetMostRecentBullyForQuest
	push	eax
	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDenouncedPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDenouncedPlayer
	test	al, al
	je	$LN1@IsValidQue
	pop	edi
	pop	ebp
	pop	esi
	xor	al, al
	pop	ebx

; 3765 : }

	pop	ecx
	ret	8
$LN22@IsValidQue:

; 3731 : 			return false;
; 3732 : 	}
; 3733 : 	// Spread your religion to us
; 3734 : 	else if(eQuest == MINOR_CIV_QUEST_SPREAD_RELIGION)

	cmp	ebx, 16					; 00000010H
	jne	SHORT $LN9@IsValidQue

; 3735 : 	{
; 3736 : 		// This player must not have bullied us recently
; 3737 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3738 : 			return false;

	jne	$LN94@IsValidQue

; 3739 : 
; 3740 : 		// Player must have founded a religion
; 3741 : 		if(!GC.getGame().GetGameReligions()->HasCreatedReligion(ePlayer))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?HasCreatedReligion@CvGameReligions@@QBE_NW4PlayerTypes@@@Z ; CvGameReligions::HasCreatedReligion
	test	al, al

; 3742 : 			return false;

	je	$LN94@IsValidQue

; 3743 : 
; 3744 : 		// Minor must not already share player's religion
; 3745 : 		if(IsSameReligionAsMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsSameReligionAsMajor
	test	al, al
	je	$LN1@IsValidQue
	pop	edi
	pop	ebp
	pop	esi
	xor	al, al
	pop	ebx

; 3765 : }

	pop	ecx
	ret	8
$LN9@IsValidQue:

; 3746 : 			return false;
; 3747 : 	}
; 3748 : 	// Trade route
; 3749 : 	else if(eQuest == MINOR_CIV_QUEST_TRADE_ROUTE)

	cmp	ebx, 17					; 00000011H
	jne	SHORT $LN1@IsValidQue

; 3750 : 	{
; 3751 : 		// This player must not have bullied us recently
; 3752 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	push	edi
	mov	ecx, esi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3753 : 			return false;

	jne	$LN94@IsValidQue

; 3754 : 
; 3755 : 		// This player must not already be connected
; 3756 : 		if(GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(ePlayer, GetPlayer()->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al

; 3757 : 			return false;

	jne	$LN94@IsValidQue

; 3758 : 
; 3759 : 		// This player must be able to build a trade route either by land or sea
; 3760 : 		if(!GC.getGame().GetGameTrade()->CanCreateTradeRoute(ePlayer,GetPlayer()->GetID(), DOMAIN_LAND) &&
; 3761 : 			!GC.getGame().GetGameTrade()->CanCreateTradeRoute(ePlayer,GetPlayer()->GetID(), DOMAIN_SEA))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	2
	push	eax
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z ; CvGameTrade::CanCreateTradeRoute
	test	al, al
	jne	SHORT $LN1@IsValidQue
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	push	eax
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z ; CvGameTrade::CanCreateTradeRoute
	test	al, al

; 3762 : 			return false;

	je	$LN94@IsValidQue
$LN1@IsValidQue:
	pop	edi
	pop	ebp
	pop	esi

; 3763 : 	}
; 3764 : 	return true;

	mov	al, 1
	pop	ebx

; 3765 : }

	pop	ecx
	ret	8
?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::IsValidQuestForPlayer
_TEXT	ENDS
PUBLIC	?IsValidQuestCopyForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@PAVCvMinorCivQuest@@@Z ; CvMinorCivAI::IsValidQuestCopyForPlayer
EXTRN	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC	; CvTeam::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?IsValidQuestCopyForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@PAVCvMinorCivQuest@@@Z
_TEXT	SEGMENT
_eQuestType$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
_pQuest$ = 12						; size = 4
?IsValidQuestCopyForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@PAVCvMinorCivQuest@@@Z PROC ; CvMinorCivAI::IsValidQuestCopyForPlayer, COMDAT
; _this$ = ecx

; 3769 : {

	push	ecx

; 3770 : 	if(!pQuest)

	mov	eax, DWORD PTR _pQuest$[esp]
	push	ebx
	mov	ebx, ecx
	test	eax, eax
	jne	SHORT $LN22@IsValidQue@2

; 3771 : 	{
; 3772 : 		CvAssertMsg(false, "Checking validity of copying an existing quest, but pQuest is NULL. Please send Anton your save file and version.");
; 3773 : 		return false;

	xor	al, al
	pop	ebx

; 3842 : }

	pop	ecx
	ret	8
$LN22@IsValidQue@2:
	push	edi

; 3774 : 	}
; 3775 : 
; 3776 : 	MinorCivQuestTypes eQuestType = pQuest->GetType();

	mov	edi, DWORD PTR [eax+8]

; 3777 : 
; 3778 : 	// The quest type must be enabled
; 3779 : 	if(!IsEnabledQuest(eQuestType))

	push	edi
	mov	DWORD PTR _eQuestType$[esp+16], edi
	call	?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsEnabledQuest
	test	al, al
	jne	SHORT $LN21@IsValidQue@2
	pop	edi
	pop	ebx

; 3842 : }

	pop	ecx
	ret	8
$LN21@IsValidQue@2:

; 3780 : 		return false;
; 3781 : 
; 3782 : 	// Somebody's dead, that's no good
; 3783 : 	if(!GET_PLAYER(ePlayer).isAlive() || !GetPlayer()->isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp+16]
	mov	ebp, esi
	imul	ebp, 63236				; 0000f704H
	cmp	BYTE PTR [eax+ebp+2256], 0
	je	$LN19@IsValidQue@2
	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+2256], 0
	je	$LN19@IsValidQue@2

; 3785 : 
; 3786 : 	// No quests are valid if we are at war
; 3787 : 	if(IsAtWarWithPlayersTeam(ePlayer))

	push	esi
	mov	ecx, ebx
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al

; 3788 : 		return false;

	jne	$LN19@IsValidQue@2

; 3789 : 
; 3790 : 	// antonjs: todo: dehackify
; 3791 : 	if(!IsHasMetPlayer(ePlayer) && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GET_TEAM(GetPlayer()->getTeam()).GetID()))

	push	esi
	mov	ecx, ebx
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	jne	SHORT $LN17@IsValidQue@2
	mov	ecx, DWORD PTR [ebx]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	imul	esi, 2984				; 00000ba8H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [edx+ebp]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edi, eax
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, esi
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, edi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al

; 3792 : 		return false;

	je	$LN19@IsValidQue@2
	mov	edi, DWORD PTR _eQuestType$[esp+20]
	mov	esi, DWORD PTR _ePlayer$[esp+16]
$LN17@IsValidQue@2:

; 3793 : 
; 3794 : 	// This player cannot already have an active quest of the same type
; 3795 : 	if(IsActiveQuestForPlayer(ePlayer, eQuestType))

	push	edi
	push	esi
	mov	ecx, ebx
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al

; 3796 : 		return false;

	jne	$LN19@IsValidQue@2

; 3797 : 
; 3798 : 	// Both players must have a capital
; 3799 : 	CvCity* pMinorsCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [ebx]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	esi, eax

; 3800 : 	CvCity* pMajorsCapital = GET_PLAYER(ePlayer).getCapitalCity();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 3801 : 	if(pMinorsCapital == NULL || pMajorsCapital == NULL)

	test	esi, esi
	je	$LN19@IsValidQue@2
	test	eax, eax
	je	$LN19@IsValidQue@2

; 3802 : 		return false;
; 3803 : 
; 3804 : 	// KILL A CAMP - Is the camp in the existing quest still around?
; 3805 : 	if(eQuestType == MINOR_CIV_QUEST_KILL_CAMP)

	cmp	edi, 1
	jne	$LN13@IsValidQue@2

; 3806 : 	{
; 3807 : 		int iCampX = pQuest->GetPrimaryData();

	mov	ecx, DWORD PTR _pQuest$[esp+16]
	mov	eax, DWORD PTR [ecx+16]

; 3808 : 		int iCampY = pQuest->GetSecondaryData();

	mov	ebx, DWORD PTR [ecx+20]

; 3809 : 		CvPlot* pPlot = GC.getMap().plot(iCampX, iCampY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN19@IsValidQue@2
	cmp	ebx, -2147483647			; 80000001H
	je	$LN19@IsValidQue@2
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN67@IsValidQue@2
	test	eax, eax
	jge	SHORT $LN69@IsValidQue@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN71@IsValidQue@2
$LN69@IsValidQue@2:
	cmp	eax, ecx
	jl	SHORT $LN67@IsValidQue@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN71@IsValidQue@2
$LN67@IsValidQue@2:
	mov	esi, eax
$LN71@IsValidQue@2:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN100@IsValidQue@2
	test	ebx, ebx
	jge	SHORT $LN79@IsValidQue@2
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN81@IsValidQue@2
$LN79@IsValidQue@2:
	cmp	ebx, edi
	jl	SHORT $LN100@IsValidQue@2
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN81@IsValidQue@2
$LN100@IsValidQue@2:
	mov	edx, ebx
$LN81@IsValidQue@2:
	test	esi, esi
	jl	SHORT $LN19@IsValidQue@2
	cmp	esi, ecx
	jge	SHORT $LN19@IsValidQue@2
	test	edx, edx
	jl	SHORT $LN19@IsValidQue@2
	cmp	edx, edi
	jge	SHORT $LN19@IsValidQue@2
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 3810 : 		if(!pPlot)

	test	ecx, ecx

; 3811 : 			return false;

	je	SHORT $LN19@IsValidQue@2

; 3812 : 		if(pPlot->getImprovementType() != GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, esi
	je	SHORT $LN2@IsValidQue@2
$LN19@IsValidQue@2:
	pop	esi
	pop	ebp
	pop	edi

; 3784 : 		return false;

	xor	al, al
	pop	ebx

; 3842 : }

	pop	ecx
	ret	8
$LN13@IsValidQue@2:

; 3813 : 			return false;
; 3814 : 	}
; 3815 : 	// CONTEST CULTURE
; 3816 : 	else if(eQuestType == MINOR_CIV_QUEST_CONTEST_CULTURE)

	cmp	edi, 10					; 0000000aH
	je	SHORT $LN2@IsValidQue@2

; 3817 : 	{
; 3818 : 	}
; 3819 : 	// CONTEST FAITH
; 3820 : 	else if(eQuestType == MINOR_CIV_QUEST_CONTEST_FAITH)

	cmp	edi, 11					; 0000000bH
	je	SHORT $LN2@IsValidQue@2

; 3821 : 	{
; 3822 : 	}
; 3823 : 	// CONTEST TECHS
; 3824 : 	else if(eQuestType == MINOR_CIV_QUEST_CONTEST_TECHS)

	cmp	edi, 12					; 0000000cH
	je	SHORT $LN2@IsValidQue@2

; 3825 : 	{
; 3826 : 	}
; 3827 : 	// Invest
; 3828 : 	else if(eQuestType == MINOR_CIV_QUEST_INVEST)

	cmp	edi, 13					; 0000000dH
	jne	SHORT $LN3@IsValidQue@2

; 3829 : 	{
; 3830 : 		// This player must not have bullied us recently
; 3831 : 		if(IsRecentlyBulliedByMajor(ePlayer))

	mov	ecx, DWORD PTR _ePlayer$[esp+16]
	push	ecx
	mov	ecx, ebx
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al

; 3832 : 			return false;

	jne	SHORT $LN19@IsValidQue@2
$LN2@IsValidQue@2:
	pop	esi
	pop	ebp
	pop	edi

; 3839 : 	}
; 3840 : 
; 3841 : 	return true;

	mov	al, 1
	pop	ebx

; 3842 : }

	pop	ecx
	ret	8
$LN3@IsValidQue@2:

; 3833 : 	}
; 3834 : 	// Personal quests - This should not be done, just create a new quest from scratch!!
; 3835 : 	else
; 3836 : 	{
; 3837 : 		CvAssertMsg(false, "Checking validity of copying a personal quest using existing quest data.  This should not be done.  Please send Anton your save file and version.");
; 3838 : 		return IsValidQuestForPlayer(ePlayer, eQuestType);

	mov	edx, DWORD PTR _ePlayer$[esp+16]
	push	edi
	push	edx
	mov	ecx, ebx
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx

; 3842 : }

	pop	ecx
	ret	8
?IsValidQuestCopyForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@PAVCvMinorCivQuest@@@Z ENDP ; CvMinorCivAI::IsValidQuestCopyForPlayer
_TEXT	ENDS
PUBLIC	?AddQuestIfAble@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::AddQuestIfAble
; Function compile flags: /Ogtpy
;	COMDAT ?AddQuestIfAble@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_eQuest$ = 12						; size = 4
?AddQuestIfAble@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z PROC ; CvMinorCivAI::AddQuestIfAble, COMDAT
; _this$ = ecx

; 4451 : {

	push	esi
	push	edi

; 4452 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 4453 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 4454 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	mov	edi, DWORD PTR _eMajor$[esp+4]
	mov	esi, ecx
	cmp	edi, 21					; 00000015H
	ja	$LN21@AddQuestIf
	push	ebx

; 4455 : 
; 4456 : 	CvAssertMsg(eQuest >= NO_MINOR_CIV_QUEST_TYPE, "eQuest is expected to be non-negative (invalid Index)");
; 4457 : 	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eQuest is expected to be within maximum bounds (invalid Index)");
; 4458 : 	if(eQuest < NO_MINOR_CIV_QUEST_TYPE || eQuest >= NUM_MINOR_CIV_QUEST_TYPES) return false;

	mov	ebx, DWORD PTR _eQuest$[esp+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, 18					; 00000012H
	ja	$LN39@AddQuestIf

; 4459 : 
; 4460 : 	if(!IsHasMetPlayer(eMajor))

	push	edi
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al

; 4461 : 		return false;

	je	$LN39@AddQuestIf

; 4462 : 
; 4463 : 	if(IsAtWarWithPlayersTeam(eMajor))

	push	edi
	mov	ecx, esi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al

; 4464 : 		return false;

	jne	$LN39@AddQuestIf

; 4465 : 
; 4466 : 	if (!IsValidQuestForPlayer(eMajor, eQuest))

	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	test	al, al

; 4467 : 		return false;

	je	$LN39@AddQuestIf

; 4468 : 
; 4469 : 	if (IsActiveQuestForPlayer(eMajor, eQuest))

	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al

; 4470 : 		return false;

	jne	SHORT $LN39@AddQuestIf

; 4471 : 
; 4472 : 	CvAssert(IsPersonalQuest(eQuest) || IsGlobalQuest(eQuest));
; 4473 : 	if (IsPersonalQuest(eQuest))

	push	ebx
	mov	ecx, esi
	call	?IsPersonalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsPersonalQuest

; 4474 : 	{
; 4475 : 		if(GetNumActivePersonalQuestsForPlayer(eMajor) >= GetMaxActivePersonalQuestsForPlayer())

	mov	ecx, esi
	test	al, al
	je	SHORT $LN14@AddQuestIf
	push	edi
	call	?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumActivePersonalQuestsForPlayer
	cmp	eax, 2

; 4476 : 		{
; 4477 : 			return false;

	jge	SHORT $LN39@AddQuestIf

; 4478 : 		}
; 4479 : 
; 4480 : 		AddQuestForPlayer(eMajor, eQuest, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	ebx
	push	edi
	mov	ecx, esi
	call	?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ; CvMinorCivAI::AddQuestForPlayer
	pop	ebx
	pop	edi

; 4481 : 		return true;

	mov	al, 1
	pop	esi

; 4505 : 		}
; 4506 : 		return true;
; 4507 : 	}
; 4508 : 
; 4509 : 	return false;
; 4510 : }

	ret	8
$LN14@AddQuestIf:

; 4482 : 	}
; 4483 : 	else if (IsGlobalQuest(eQuest))

	push	ebx
	call	?IsGlobalQuest@CvMinorCivAI@@QBE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsGlobalQuest
	test	al, al
	je	SHORT $LN39@AddQuestIf

; 4484 : 	{
; 4485 : 		if(GetNumActiveGlobalQuests() >= GetMaxActiveGlobalQuests())

	call	?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetNumActiveGlobalQuests
	cmp	eax, 1

; 4486 : 		{
; 4487 : 			return false;

	jge	SHORT $LN39@AddQuestIf
	push	ebp

; 4488 : 		}
; 4489 : 
; 4490 : 		int iNumValidPlayers = 0;

	xor	ebp, ebp

; 4491 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	npad	3
$LL9@AddQuestIf:

; 4492 : 		{
; 4493 : 			PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
; 4494 : 			if(IsValidQuestForPlayer(ePlayerLoop, eQuest))

	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	test	al, al
	je	SHORT $LN8@AddQuestIf

; 4495 : 				iNumValidPlayers++;

	inc	ebp
$LN8@AddQuestIf:

; 4491 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	edi
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL9@AddQuestIf

; 4496 : 		}
; 4497 : 		if(iNumValidPlayers < GetMinPlayersNeededForQuest(eQuest))

	push	ebx
	mov	ecx, esi
	call	?GetMinPlayersNeededForQuest@CvMinorCivAI@@QBEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetMinPlayersNeededForQuest
	cmp	ebp, eax
	pop	ebp
	jge	SHORT $LN5@AddQuestIf
$LN39@AddQuestIf:
	pop	ebx
	pop	edi

; 4498 : 			return false;

	xor	al, al
	pop	esi

; 4505 : 		}
; 4506 : 		return true;
; 4507 : 	}
; 4508 : 
; 4509 : 	return false;
; 4510 : }

	ret	8
$LN5@AddQuestIf:

; 4499 : 
; 4500 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	npad	5
$LL4@AddQuestIf:

; 4501 : 		{
; 4502 : 			PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
; 4503 : 			if(IsValidQuestForPlayer(ePlayerLoop, eQuest))

	push	ebx
	push	edi
	mov	ecx, esi
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	test	al, al
	je	SHORT $LN3@AddQuestIf

; 4504 : 				AddQuestForPlayer(ePlayerLoop, eQuest, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	ebx
	push	edi
	mov	ecx, esi
	call	?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ; CvMinorCivAI::AddQuestForPlayer
$LN3@AddQuestIf:
	inc	edi
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL4@AddQuestIf
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi

; 4505 : 		}
; 4506 : 		return true;
; 4507 : 	}
; 4508 : 
; 4509 : 	return false;
; 4510 : }

	ret	8
$LN21@AddQuestIf:
	pop	edi

; 4452 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 4453 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 4454 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return false;

	xor	al, al
	pop	esi

; 4505 : 		}
; 4506 : 		return true;
; 4507 : 	}
; 4508 : 
; 4509 : 	return false;
; 4510 : }

	ret	8
?AddQuestIfAble@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ENDP ; CvMinorCivAI::AddQuestIfAble
_TEXT	ENDS
PUBLIC	?GetFriendshipChangePerTurnTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipChangePerTurnTimes100
EXTRN	?GetMinorFriendshipDecayMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetMinorFriendshipDecayMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendshipChangePerTurnTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_kPlayer$ = -12						; size = 4
_iReligionMod$ = -8					; size = 4
_iTraitMod$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?GetFriendshipChangePerTurnTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z PROC ; CvMinorCivAI::GetFriendshipChangePerTurnTimes100, COMDAT
; _this$ = ecx

; 5312 : {

	sub	esp, 12					; 0000000cH

; 5313 : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp+20]
	mov	ebx, esi
	imul	ebx, 63236				; 0000f704H
	mov	ebp, ecx
	lea	ecx, DWORD PTR [ebx+eax]
	push	edi
	mov	DWORD PTR _kPlayer$[esp+28], ecx

; 5314 : 	int iChangeThisTurn = 0;

	xor	edi, edi

; 5315 : 
; 5316 : 	// Modifier to rate based on traits and religion
; 5317 : 	int iTraitMod = kPlayer.GetPlayerTraits()->GetCityStateFriendshipModifier();

	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR _iTraitMod$[esp+28], ecx

; 5318 : 	int iReligionMod = 0;
; 5319 : 	if (IsSameReligionAsMajor(ePlayer))

	push	esi
	mov	ecx, ebp
	mov	DWORD PTR _iReligionMod$[esp+32], edi
	call	?IsSameReligionAsMajor@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsSameReligionAsMajor
	test	al, al
	je	SHORT $LN16@GetFriends@9

; 5320 : 		iReligionMod += /*50*/ GC.getMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2728
	mov	DWORD PTR _iReligionMod$[esp+28], edx
$LN16@GetFriends@9:

; 5321 : 
; 5322 : 	// Relation to anchor point?
; 5323 : 	int iBaseFriendship = GetBaseFriendshipWithMajor(ePlayer);

	cmp	esi, 21					; 00000015H
	ja	SHORT $LN27@GetFriends@9
	mov	ecx, DWORD PTR [ebp+esi*4+2024]
	jmp	SHORT $LN29@GetFriends@9
$LN27@GetFriends@9:
	xor	ecx, ecx
$LN29@GetFriends@9:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 5324 : 	int iFriendshipAnchor = GetFriendshipAnchorWithMajor(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[esp+24]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	push	eax
	mov	ecx, ebp
	add	esi, edx
	call	?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipAnchorWithMajor

; 5325 : 	if (iBaseFriendship == iFriendshipAnchor)

	cmp	esi, eax
	je	$LN110@GetFriends@9

; 5326 : 	{
; 5327 : 		// Change rate is 0
; 5328 : 	}
; 5329 : 	else if (iBaseFriendship > iFriendshipAnchor)

	jle	$LN13@GetFriends@9

; 5330 : 	{
; 5331 : 		// Hostile Minors have Friendship decay quicker
; 5332 : 		if(GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)

	cmp	DWORD PTR [ebp+8], 2
	jne	SHORT $LN12@GetFriends@9

; 5333 : 			iChangeThisTurn += /*-150*/ GC.getMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2736
	jmp	SHORT $LN9@GetFriends@9
$LN12@GetFriends@9:

; 5334 : 		// Aggressor!
; 5335 : 		else if(GET_TEAM(kPlayer.getTeam()).IsMinorCivAggressor())

	mov	ecx, DWORD PTR _kPlayer$[esp+28]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@GetFriends@9
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN40@GetFriends@9
$LN39@GetFriends@9:
	or	eax, -1
$LN40@GetFriends@9:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?IsMinorCivAggressor@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivAggressor

; 5336 : 			iChangeThisTurn += /*-200*/ GC.getMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2740
	test	al, al
	jne	SHORT $LN9@GetFriends@9

; 5337 : 		// Normal decay
; 5338 : 		else
; 5339 : 			iChangeThisTurn += /*-100*/ GC.getMINOR_FRIENDSHIP_DROP_PER_TURN();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2732
$LN9@GetFriends@9:

; 5340 : 
; 5341 : 		// Decay modified (Trait, policies, shared religion, etc.)
; 5342 : 		int iDecayMod = 100;
; 5343 : 		iDecayMod += GET_PLAYER(ePlayer).GetMinorFriendshipDecayMod();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	call	?GetMinorFriendshipDecayMod@CvPlayer@@QBEHXZ ; CvPlayer::GetMinorFriendshipDecayMod
	mov	ecx, eax

; 5344 : 		iDecayMod += (-1) * (iTraitMod / 2);
; 5345 : 		iDecayMod += (-1) * (iReligionMod / 2);

	mov	eax, DWORD PTR _iReligionMod$[esp+28]
	cdq
	sub	eax, edx
	mov	edi, eax
	mov	eax, DWORD PTR _iTraitMod$[esp+28]
	cdq
	sub	eax, edx
	sar	eax, 1
	neg	eax
	sar	edi, 1
	sub	eax, edi
	lea	eax, DWORD PTR [ecx+eax+100]

; 5346 : 		
; 5347 : 		if (iDecayMod < 0)

	test	eax, eax
	jge	SHORT $LN8@GetFriends@9

; 5348 : 			iDecayMod = 0;

	xor	eax, eax
$LN8@GetFriends@9:

; 5349 : 
; 5350 : 		iChangeThisTurn *= iDecayMod;

	imul	eax, esi

; 5351 : 		iChangeThisTurn /= 100;
; 5352 : 	}
; 5353 : 	else

	jmp	SHORT $LN114@GetFriends@9
$LN13@GetFriends@9:

; 5354 : 	{
; 5355 : 		iChangeThisTurn += /*100*/ GC.getMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN();
; 5356 : 
; 5357 : 		// Recovery modified (Trait, policies, shared religion, etc.)
; 5358 : 		int iRecoveryMod = 100;
; 5359 : 		iRecoveryMod += iTraitMod;
; 5360 : 		iRecoveryMod += iReligionMod;

	mov	edx, DWORD PTR _iReligionMod$[esp+28]
	mov	eax, DWORD PTR _iTraitMod$[esp+28]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2764
	lea	eax, DWORD PTR [edx+eax+100]

; 5361 : 		
; 5362 : 		if (iRecoveryMod < 0)

	test	eax, eax
	jge	SHORT $LN6@GetFriends@9

; 5363 : 			iRecoveryMod = 0;

	xor	eax, eax
$LN6@GetFriends@9:

; 5364 : 
; 5365 : 		iChangeThisTurn *= iRecoveryMod;

	imul	eax, ecx
$LN114@GetFriends@9:

; 5366 : 		iChangeThisTurn /= 100;

	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
$LN110@GetFriends@9:

; 5367 : 	}
; 5368 : 
; 5369 : 	// Shift on top of base rate
; 5370 : 	if (GET_TEAM(kPlayer.getTeam()).isHasMet(GetPlayer()->getTeam()))

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN60@GetFriends@9
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN61@GetFriends@9
$LN60@GetFriends@9:
	or	ecx, -1
$LN61@GetFriends@9:
	mov	esi, DWORD PTR _kPlayer$[esp+28]
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN69@GetFriends@9
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN70@GetFriends@9
$LN69@GetFriends@9:
	or	eax, -1
$LN70@GetFriends@9:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN113@GetFriends@9

; 5371 : 	{
; 5372 : 		int iShift = 0;
; 5373 : 
; 5374 : 		if (kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_PROTECTED_MINOR_INFLUENCE) != 0)

	push	37					; 00000025H
	mov	ecx, esi
	xor	ebx, ebx
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 5375 : 		{
; 5376 : 			if (GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(ePlayer, GetPlayer()->GetID()))

	mov	esi, DWORD PTR _ePlayer$[esp+24]
	test	eax, eax
	je	SHORT $LN3@GetFriends@9
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	test	al, al
	je	SHORT $LN3@GetFriends@9

; 5377 : 			{
; 5378 : 				iShift += kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_PROTECTED_MINOR_INFLUENCE);

	mov	ecx, DWORD PTR _kPlayer$[esp+28]
	push	37					; 00000025H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ebx, eax
$LN3@GetFriends@9:

; 5379 : 			}
; 5380 : 		}
; 5381 : 
; 5382 : 		if (CanMajorBullyGold(ePlayer))

	cmp	esi, 21					; 00000015H
	ja	SHORT $LN112@GetFriends@9
	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN112@GetFriends@9
	push	0
	push	0
	push	esi
	mov	ecx, ebp
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric
	mov	edx, DWORD PTR [ebp]
	cmp	BYTE PTR [edx+2256], 0
	je	SHORT $LN112@GetFriends@9
	test	eax, eax
	setge	al
	test	al, al
	je	SHORT $LN112@GetFriends@9

; 5383 : 		{
; 5384 : 			iShift += kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_AFRAID_INFLUENCE);

	mov	esi, DWORD PTR _kPlayer$[esp+28]
	push	38					; 00000026H
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 5385 : 			iShift += kPlayer.GetPlayerTraits()->GetAfraidMinorPerTurnInfluence();

	mov	ecx, esi
	add	ebx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	ebx, DWORD PTR [eax+316]
$LN112@GetFriends@9:

; 5386 : 		}
; 5387 : 		
; 5388 : 		if (iShift != 0)

	test	ebx, ebx
	je	SHORT $LN113@GetFriends@9

; 5389 : 		{
; 5390 : 			iChangeThisTurn += iShift;

	add	edi, ebx
$LN113@GetFriends@9:

; 5391 : 		}
; 5392 : 	}
; 5393 : 
; 5394 : 	// Mod everything by game speed
; 5395 : 	iChangeThisTurn *= GC.getGame().getGameSpeedInfo().getGoldGiftMod();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGoldGiftMod
	mov	ecx, eax
	imul	ecx, edi

; 5396 : 	iChangeThisTurn /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebp
	add	eax, edx
	pop	ebx

; 5397 : 
; 5398 : 	return iChangeThisTurn;
; 5399 : }

	add	esp, 12					; 0000000cH
	ret	4
?GetFriendshipChangePerTurnTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::GetFriendshipChangePerTurnTimes100
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >
_TEXT	ENDS
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$229531 = -68					; size = 28
$T269317 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
$T269405 = 12						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvMinorCivInfo::CacheResults, COMDAT
; _this$ = ecx

; 10306: {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx

; 10307: 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebx, DWORD PTR _kUtility$[esp+68]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+76]
	push	ebx
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul
	pop	edi
	pop	esi
	pop	ebx

; 10362: 
; 10363: 	return true;
; 10364: }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
$LN4@CacheResul:
	push	ebp

; 10308: 		return false;
; 10309: 
; 10310: 	//Basic Properties
; 10311: 	const char* szTextVal = NULL;
; 10312: 
; 10313: 	szTextVal = kResults.GetText("ShortDescription");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG229520
	mov	ecx, edi
	call	ebp

; 10314: 	setShortDescriptionKey(szTextVal);

	push	eax
	mov	ecx, esi
	call	?setShortDescriptionKey@CvMinorCivInfo@@QAEXPBD@Z ; CvMinorCivInfo::setShortDescriptionKey

; 10315: 
; 10316: 	szTextVal = kResults.GetText("Adjective");

	push	OFFSET $SG229521
	mov	ecx, edi
	call	ebp

; 10317: 	setAdjectiveKey(szTextVal);

	push	eax
	mov	ecx, esi
	call	?setAdjectiveKey@CvMinorCivInfo@@QAEXPBD@Z ; CvMinorCivInfo::setAdjectiveKey

; 10318: 
; 10319: 	szTextVal = kResults.GetText("ArtDefineTag");

	push	OFFSET $SG229522
	mov	ecx, edi
	call	ebp

; 10320: 	setArtDefineTag(szTextVal);

	lea	ecx, DWORD PTR [esi+280]
	test	eax, eax
	je	SHORT $LN12@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN11@CacheResul
$LN12@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN11@CacheResul:

; 10321: 
; 10322: 	//References
; 10323: 	szTextVal = kResults.GetText("DefaultPlayerColor");

	push	OFFSET $SG229523
	mov	ecx, edi
	call	ebp

; 10324: 	m_iDefaultPlayerColor = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 10325: 
; 10326: 	szTextVal = kResults.GetText("ArtStyleType");

	push	OFFSET $SG229524
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebp

; 10327: 	m_iArtStyleType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 10328: 
; 10329: 	szTextVal = kResults.GetText("ArtStylePrefix");

	push	OFFSET $SG229525
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebp

; 10330: 	setArtStylePrefix(szTextVal);

	lea	ecx, DWORD PTR [esi+308]
	test	eax, eax
	je	SHORT $LN18@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN17@CacheResul
$LN18@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN17@CacheResul:

; 10331: 
; 10332: 	szTextVal = kResults.GetText("ArtStyleSuffix");

	push	OFFSET $SG229526
	mov	ecx, edi
	call	ebp

; 10333: 	setArtStyleSuffix(szTextVal);

	lea	ecx, DWORD PTR [esi+336]
	test	eax, eax
	je	SHORT $LN24@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@CacheResul
$LN24@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@CacheResul:

; 10334: 
; 10335: 	szTextVal = kResults.GetText("MinorCivTrait");

	push	OFFSET $SG229527
	mov	ecx, edi
	call	ebp

; 10336: 	m_iMinorCivTrait = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 10337: 
; 10338: 	//Arrays
; 10339: 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 10340: 	kUtility.SetFlavors(m_piFlavorValue, "MinorCivilization_Flavors", "MinorCivType", szType, -1);

	push	-1
	mov	ebp, eax
	push	ebp
	push	OFFSET $SG229529
	push	OFFSET $SG229530
	lea	eax, DWORD PTR [esi+532]
	push	eax
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 10341: 
; 10342: 	//City Names
; 10343: 	{
; 10344: 		m_vCityNames.clear();

	mov	eax, DWORD PTR [esi+544]
	mov	ecx, DWORD PTR [esi+540]
	lea	edi, DWORD PTR [esi+536]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T269405[esp+88]
	push	ecx
	mov	ecx, edi
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase

; 10345: 
; 10346: 		std::string strKey = "MinorCiv - CityName";

	push	OFFSET $SG229532
	lea	ecx, DWORD PTR _strKey$229531[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 10347: 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$229531[esp+84]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	esi, eax

; 10348: 		if(pResults == NULL)

	test	esi, esi
	jne	SHORT $LN3@CacheResul

; 10349: 		{
; 10350: 			pResults = kUtility.PrepareResults(strKey, "select CityName from MinorCivilization_CityNames where MinorCivType = ?");

	push	OFFSET $SG229535
	lea	eax, DWORD PTR _strKey$229531[esp+88]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	esi, eax
$LN3@CacheResul:

; 10351: 		}
; 10352: 
; 10353: 		pResults->Bind(1, szType, -1, false);

	push	0
	push	-1
	push	ebp
	push	1
	mov	ecx, esi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 10354: 
; 10355: 		while(pResults->Step())

	mov	ebx, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, esi
	call	ebx
	test	al, al
	je	SHORT $LN1@CacheResul
	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	npad	1
$LL2@CacheResul:

; 10356: 		{
; 10357: 			m_vCityNames.push_back(pResults->GetText(0));

	push	0
	mov	ecx, esi
	call	ebp
	test	eax, eax
	jne	SHORT $LN46@CacheResul
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@CacheResul:
	push	eax
	lea	ecx, DWORD PTR $T269317[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T269317[esp+84]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	lea	ecx, DWORD PTR $T269317[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	ebx
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 10358: 		}
; 10359: 
; 10360: 		pResults->Reset();

	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 10361: 	}

	lea	ecx, DWORD PTR _strKey$229531[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10362: 
; 10363: 	return true;
; 10364: }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	ebp
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$229531[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR $T269317[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvMinorCivInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvMinorCivInfo::CacheResults
PUBLIC	?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoTestStartGlobalQuest
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ$0
__ehfuncinfo$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
_veValidQuests$ = -100					; size = 88
__$EHRec$ = -12						; size = 12
?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ PROC	; CvMinorCivAI::DoTestStartGlobalQuest, COMDAT
; _this$ = ecx

; 2935 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx
	mov	ebx, ecx

; 2936 : 	if(GetGlobalQuestCountdown() > 0)

	mov	eax, DWORD PTR [ebx+24]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	jg	$LN76@DoTestStar

; 2937 : 	{
; 2938 : 		return;
; 2939 : 	}
; 2940 : 
; 2941 : 	if(GetNumActiveGlobalQuests() >= GetMaxActiveGlobalQuests())

	call	?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetNumActiveGlobalQuests
	cmp	eax, 1
	jge	$LN76@DoTestStar

; 2942 : 	{
; 2943 : 		return;
; 2944 : 	}
; 2945 : 
; 2946 : 	// Pick a valid quest
; 2947 : 	FStaticVector<MinorCivQuestTypes, NUM_MINOR_CIV_QUEST_TYPES, true, c_eCiv5GameplayDLL, 0> veValidQuests;

	lea	eax, DWORD PTR _veValidQuests$[esp+120]
	mov	DWORD PTR _veValidQuests$[esp+112], edi
	mov	DWORD PTR _veValidQuests$[esp+116], 18	; 00000012H
	mov	DWORD PTR _veValidQuests$[esp+108], eax
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+120], edi
	push	esi
$LL100@DoTestStar:

; 2951 : 	{
; 2952 : 		eQuest = (MinorCivQuestTypes) iQuestLoop;
; 2953 : 		if(IsEnabledQuest(eQuest))

	push	edi
	mov	ecx, ebx
	call	?IsEnabledQuest@CvMinorCivAI@@QAE_NW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsEnabledQuest
	test	al, al
	je	$LN17@DoTestStar

; 2954 : 		{
; 2955 : 			if(IsGlobalQuest(eQuest))

	cmp	edi, 1
	je	SHORT $LN96@DoTestStar
	cmp	edi, 10					; 0000000aH
	je	SHORT $LN96@DoTestStar
	cmp	edi, 11					; 0000000bH
	je	SHORT $LN96@DoTestStar
	cmp	edi, 12					; 0000000cH
	je	SHORT $LN96@DoTestStar
	cmp	edi, 13					; 0000000dH
	jne	SHORT $LN17@DoTestStar
$LN96@DoTestStar:

; 2956 : 			{
; 2957 : 				// Are there enough players for this quest to be given out?
; 2958 : 				int iNumValidPlayers = 0;

	xor	ebp, ebp

; 2959 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	npad	2
$LL13@DoTestStar:

; 2960 : 				{
; 2961 : 					ePlayer = (PlayerTypes) iPlayerLoop;
; 2962 : 					if(IsValidQuestForPlayer(ePlayer, eQuest))

	push	edi
	push	esi
	mov	ecx, ebx
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	test	al, al
	je	SHORT $LN12@DoTestStar

; 2963 : 						iNumValidPlayers++;

	inc	ebp
$LN12@DoTestStar:

; 2959 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL13@DoTestStar

; 2964 : 				}
; 2965 : 				if(iNumValidPlayers < GetMinPlayersNeededForQuest(eQuest))

	push	edi
	mov	ecx, ebx
	call	?GetMinPlayersNeededForQuest@CvMinorCivAI@@QBEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetMinPlayersNeededForQuest
	cmp	ebp, eax
	jl	SHORT $LN17@DoTestStar

; 2966 : 					continue;
; 2967 : 
; 2968 : 				// What is the bias for this minor favoring this particular quest? Queue up multiple copies (default is 10)
; 2969 : 				int iCount = GetPersonalityQuestBias(eQuest);

	push	edi
	mov	ecx, ebx
	call	?GetPersonalityQuestBias@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetPersonalityQuestBias

; 2970 : 				for(int iCountLoop = 0; iCountLoop < iCount; iCountLoop++)

	test	eax, eax
	jle	SHORT $LN17@DoTestStar

; 2966 : 					continue;
; 2967 : 
; 2968 : 				// What is the bias for this minor favoring this particular quest? Queue up multiple copies (default is 10)
; 2969 : 				int iCount = GetPersonalityQuestBias(eQuest);

	mov	esi, eax
	npad	2
$LL8@DoTestStar:

; 2971 : 				{
; 2972 : 					veValidQuests.push_back(eQuest);

	mov	eax, DWORD PTR _veValidQuests$[esp+124]
	mov	BYTE PTR _veValidQuests$[esp+200], 0
	cmp	DWORD PTR _veValidQuests$[esp+120], eax
	jne	SHORT $LN43@DoTestStar
	push	eax
	lea	ecx, DWORD PTR _veValidQuests$[esp+120]
	call	?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::GrowSize
$LN43@DoTestStar:
	mov	ecx, DWORD PTR _veValidQuests$[esp+116]
	mov	edx, DWORD PTR _veValidQuests$[esp+120]
	lea	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN46@DoTestStar
	mov	DWORD PTR [eax], edi
$LN46@DoTestStar:
	inc	DWORD PTR _veValidQuests$[esp+120]
	sub	esi, 1
	jne	SHORT $LL8@DoTestStar
$LN17@DoTestStar:

; 2948 : 	MinorCivQuestTypes eQuest;
; 2949 : 	PlayerTypes ePlayer;
; 2950 : 	for(int iQuestLoop = 0; iQuestLoop < NUM_MINOR_CIV_QUEST_TYPES; iQuestLoop++)

	inc	edi
	cmp	edi, 18					; 00000012H
	jl	$LL100@DoTestStar

; 2973 : 				}
; 2974 : 			}
; 2975 : 		}
; 2976 : 	}
; 2977 : 
; 2978 : 	// No valid quests
; 2979 : 	if(veValidQuests.size() == 0)

	mov	eax, DWORD PTR _veValidQuests$[esp+120]
	test	eax, eax

; 2980 : 	{
; 2981 : 		return;

	je	SHORT $LN104@DoTestStar

; 2982 : 	}
; 2983 : 
; 2984 : 	// There are valid quests, so pick one at random
; 2985 : 	int iRandIndex = GC.getGame().getJonRandNum(veValidQuests.size(), "Picking random global quest for Minor to give to players.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG223432
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2986 : 	eQuest = veValidQuests[iRandIndex];

	mov	edx, DWORD PTR _veValidQuests$[esp+116]
	mov	edi, DWORD PTR [edx+eax*4]

; 2987 : 
; 2988 : 	// Give out the quest
; 2989 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	npad	1
$LL4@DoTestStar:

; 2990 : 	{
; 2991 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 2992 : 		if(IsValidQuestForPlayer(ePlayer, eQuest))

	push	edi
	push	esi
	mov	ecx, ebx
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	test	al, al
	je	SHORT $LN3@DoTestStar

; 2993 : 		{
; 2994 : 			// Since we are adding each instance of the quest separately, global quests should not rely on random choice of data
; 2995 : 			AddQuestForPlayer(ePlayer, eQuest, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	edi
	push	esi
	mov	ecx, ebx
	call	?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ; CvMinorCivAI::AddQuestForPlayer
$LN3@DoTestStar:
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL4@DoTestStar

; 2996 : 		}
; 2997 : 	}
; 2998 : 
; 2999 : 	// Check if we need to seed the countdown timer to allow for another quest
; 3000 : 	DoTestSeedGlobalQuestCountdown();

	push	0
	mov	ecx, ebx
	call	?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z ; CvMinorCivAI::DoTestSeedGlobalQuestCountdown
$LN104@DoTestStar:

; 3001 : }

	mov	eax, DWORD PTR _veValidQuests$[esp+116]
	lea	ecx, DWORD PTR _veValidQuests$[esp+128]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	cmp	eax, ecx
	je	SHORT $LN102@DoTestStar
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN102@DoTestStar:
	pop	esi
	pop	ebp
$LN76@DoTestStar:
	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _veValidQuests$[ebp]
	jmp	??1?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::~FStaticVector<enum MinorCivQuestTypes,18,1,297,0>
__ehhandler$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ ENDP	; CvMinorCivAI::DoTestStartGlobalQuest
PUBLIC	?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestStartPersonalQuest
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
__ehfuncinfo$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_veValidQuests$ = -100					; size = 88
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::DoTestStartPersonalQuest, COMDAT
; _this$ = ecx

; 3005 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx

; 3006 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3007 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3008 : 
; 3009 : 	// Can't start a new quest too quickly after an old one has ended
; 3010 : 	if(GetQuestCountdownForPlayer(ePlayer) > 0)

	mov	ebx, DWORD PTR _ePlayer$[esp+100]
	push	ebp
	mov	ebp, ecx
	cmp	ebx, 21					; 00000015H
	ja	SHORT $LN89@DoTestStar@2
	cmp	DWORD PTR [ebp+ebx*4+2464], 0
	jg	$LN70@DoTestStar@2
$LN89@DoTestStar@2:

; 3011 : 	{
; 3012 : 		return;
; 3013 : 	}
; 3014 : 
; 3015 : 	// Can't start a new quest if we already have several active ones
; 3016 : 	if(GetNumActivePersonalQuestsForPlayer(ePlayer) >= GetMaxActivePersonalQuestsForPlayer())

	push	ebx
	call	?GetNumActivePersonalQuestsForPlayer@CvMinorCivAI@@QBEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumActivePersonalQuestsForPlayer
	cmp	eax, 2
	jge	$LN70@DoTestStar@2
	push	esi

; 3017 : 	{
; 3018 : 		return;
; 3019 : 	}
; 3020 : 
; 3021 : 	FStaticVector<MinorCivQuestTypes, NUM_MINOR_CIV_QUEST_TYPES, true, c_eCiv5GameplayDLL, 0> veValidQuests;

	xor	esi, esi
	lea	eax, DWORD PTR _veValidQuests$[esp+124]
	mov	DWORD PTR _veValidQuests$[esp+116], esi
	mov	DWORD PTR _veValidQuests$[esp+120], 18	; 00000012H
	mov	DWORD PTR _veValidQuests$[esp+112], eax
	mov	DWORD PTR __$EHRec$[esp+120], esi
	push	edi
	npad	2
$LL91@DoTestStar@2:

; 3027 : 	{
; 3028 : 		eQuest = (MinorCivQuestTypes) iQuestLoop;
; 3029 : 
; 3030 : 		if(IsValidQuestForPlayer(ePlayer, eQuest) && IsPersonalQuest(eQuest))

	push	esi
	push	ebx
	mov	ecx, ebp
	call	?IsValidQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsValidQuestForPlayer
	test	al, al
	je	SHORT $LN7@DoTestStar@2
	cmp	esi, 1
	je	SHORT $LN7@DoTestStar@2
	cmp	esi, 10					; 0000000aH
	je	SHORT $LN7@DoTestStar@2
	cmp	esi, 11					; 0000000bH
	je	SHORT $LN7@DoTestStar@2
	cmp	esi, 12					; 0000000cH
	je	SHORT $LN7@DoTestStar@2
	cmp	esi, 13					; 0000000dH
	je	SHORT $LN7@DoTestStar@2

; 3031 : 		{
; 3032 : 			// What is the bias for this player wanting this particular quest? Queue up multiple copies (default is 10)
; 3033 : 			iCount = GetPersonalityQuestBias(eQuest);

	push	esi
	mov	ecx, ebp
	call	?GetPersonalityQuestBias@CvMinorCivAI@@QAEHW4MinorCivQuestTypes@@@Z ; CvMinorCivAI::GetPersonalityQuestBias

; 3034 : 
; 3035 : 			for(iCountLoop = 0; iCountLoop < iCount; iCountLoop++)

	test	eax, eax
	jle	SHORT $LN7@DoTestStar@2

; 3031 : 		{
; 3032 : 			// What is the bias for this player wanting this particular quest? Queue up multiple copies (default is 10)
; 3033 : 			iCount = GetPersonalityQuestBias(eQuest);

	mov	edi, eax
	npad	12
$LL4@DoTestStar@2:

; 3036 : 			{
; 3037 : 				veValidQuests.push_back(eQuest);

	mov	eax, DWORD PTR _veValidQuests$[esp+124]
	mov	BYTE PTR _veValidQuests$[esp+200], 0
	cmp	DWORD PTR _veValidQuests$[esp+120], eax
	jne	SHORT $LN37@DoTestStar@2
	push	eax
	lea	ecx, DWORD PTR _veValidQuests$[esp+120]
	call	?GrowSize@?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::GrowSize
$LN37@DoTestStar@2:
	mov	ecx, DWORD PTR _veValidQuests$[esp+116]
	mov	edx, DWORD PTR _veValidQuests$[esp+120]
	lea	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN40@DoTestStar@2
	mov	DWORD PTR [eax], esi
$LN40@DoTestStar@2:
	inc	DWORD PTR _veValidQuests$[esp+120]
	sub	edi, 1
	jne	SHORT $LL4@DoTestStar@2
$LN7@DoTestStar@2:

; 3022 : 
; 3023 : 	int iCount, iCountLoop;
; 3024 : 
; 3025 : 	MinorCivQuestTypes eQuest;
; 3026 : 	for(int iQuestLoop = 0; iQuestLoop < NUM_MINOR_CIV_QUEST_TYPES; iQuestLoop++)

	inc	esi
	cmp	esi, 18					; 00000012H
	jl	SHORT $LL91@DoTestStar@2

; 3038 : 			}
; 3039 : 		}
; 3040 : 	}
; 3041 : 
; 3042 : 	// No valid Quests
; 3043 : 	if(veValidQuests.size() == 0)

	mov	eax, DWORD PTR _veValidQuests$[esp+120]
	pop	edi
	test	eax, eax

; 3044 : 	{
; 3045 : 		return;

	je	SHORT $LN95@DoTestStar@2

; 3046 : 	}
; 3047 : 
; 3048 : 	int iRandIndex = GC.getGame().getJonRandNum(veValidQuests.size(), "Picking random quest for Minor to give to a player.");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG223461
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 3049 : 	eQuest = veValidQuests[iRandIndex];

	mov	edx, DWORD PTR _veValidQuests$[esp+112]

; 3050 : 
; 3051 : 	AddQuestForPlayer(ePlayer, eQuest, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edx+eax*4]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	esi
	push	ebx
	mov	ecx, ebp
	call	?AddQuestForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@H@Z ; CvMinorCivAI::AddQuestForPlayer

; 3052 : 
; 3053 : 	// Check if we need to seed the countdown timer to allow for another quest
; 3054 : 	DoTestSeedQuestCountdownForPlayer(ePlayer);

	push	0
	push	ebx
	mov	ecx, ebp
	call	?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer
$LN95@DoTestStar@2:

; 3055 : }

	mov	eax, DWORD PTR _veValidQuests$[esp+112]
	lea	ecx, DWORD PTR _veValidQuests$[esp+124]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	cmp	eax, ecx
	je	SHORT $LN93@DoTestStar@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN93@DoTestStar@2:
	pop	esi
$LN70@DoTestStar@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _veValidQuests$[ebp]
	jmp	??1?$FStaticVector@W4MinorCivQuestTypes@@$0BC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum MinorCivQuestTypes,18,1,297,0>::~FStaticVector<enum MinorCivQuestTypes,18,1,297,0>
__ehhandler$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::DoTestStartPersonalQuest
PUBLIC	?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestQuestsOnFirstContact
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0
__ehfuncinfo$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv464 = -80						; size = 4
_eQuestType$224091 = -76				; size = 4
_iQuestLoop$224096 = -72				; size = 4
_iPlayerLoop$224092 = -68				; size = 4
$T269809 = -64						; size = 4
$T269811 = -60						; size = 8
_setGlobalQuests$224090 = -52				; size = 12
_quest$224100 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T270009 = 8						; size = 4
_eMajor$ = 8						; size = 4
?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMinorCivAI::DoTestQuestsOnFirstContact, COMDAT
; _this$ = ecx

; 3107 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 3108 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 3109 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 3110 : 	if(eMajor < 0 || eMajor >= MAX_MAJOR_CIVS) return;

	cmp	DWORD PTR _eMajor$[esp+76], 21		; 00000015H
	push	ebp
	mov	ebp, ecx
	ja	$LN12@DoTestQues

; 3111 : 
; 3112 : 	//antonjs: consider: make this less hacky
; 3113 : 	if(GetNumActiveGlobalQuests() > 0)

	call	?GetNumActiveGlobalQuests@CvMinorCivAI@@QBEHXZ ; CvMinorCivAI::GetNumActiveGlobalQuests
	test	eax, eax
	jle	$LN12@DoTestQues

; 3114 : 	{
; 3115 : 		std::set<MinorCivQuestTypes> setGlobalQuests;

	lea	ecx, DWORD PTR _setGlobalQuests$224090[esp+84]
	call	??0?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ ; std::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >::set<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes> >
	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[esp+92], ecx

; 3116 : 
; 3117 : 		MinorCivQuestTypes eQuestType;
; 3118 : 		for(uint iPlayerLoop = 0; iPlayerLoop < m_QuestsGiven.size(); iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$224092[esp+84], ecx
	cmp	DWORD PTR [ebp+3332], ecx
	jbe	$LN85@DoTestQues
	push	ebx
	push	esi
	push	edi
	xor	ebx, ebx
	npad	9
$LL10@DoTestQues:

; 3119 : 		{
; 3120 : 			for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[iPlayerLoop].size(); iQuestLoop++)

	mov	eax, DWORD PTR [ebp+3328]
	mov	DWORD PTR _iQuestLoop$224096[esp+96], ecx
	cmp	DWORD PTR [ebx+eax+4], ecx
	jbe	$LN9@DoTestQues
	mov	DWORD PTR tv464[esp+96], ecx
	npad	8
$LL7@DoTestQues:

; 3121 : 			{
; 3122 : 				CvMinorCivQuest quest = m_QuestsGiven[iPlayerLoop][iQuestLoop];

	mov	esi, DWORD PTR [ebx+eax]
	add	esi, DWORD PTR tv464[esp+96]
	mov	ecx, 7
	lea	edi, DWORD PTR _quest$224100[esp+96]
	rep movsd

; 3123 : 				CvMinorCivQuest* pQuest = &quest;
; 3124 : 				if(!pQuest)
; 3125 : 				{
; 3126 : 					CvAssertMsg(false, "pQuest should not be NULL. Please send Anton your save file and version.");
; 3127 : 					continue;
; 3128 : 				}
; 3129 : 				eQuestType = pQuest->GetType();

	mov	eax, DWORD PTR _quest$224100[esp+104]
	mov	DWORD PTR _eQuestType$224091[esp+96], eax

; 3130 : 				if(IsGlobalQuest(eQuestType))

	cmp	eax, 1
	je	SHORT $LN83@DoTestQues
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN83@DoTestQues
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN83@DoTestQues
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN83@DoTestQues
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN6@DoTestQues
$LN83@DoTestQues:

; 3131 : 				{
; 3132 : 					// Haven't addressed this quest type yet?
; 3133 : 					if(setGlobalQuests.find(eQuestType) == setGlobalQuests.end())

	lea	eax, DWORD PTR _eQuestType$224091[esp+96]
	push	eax
	lea	ecx, DWORD PTR $T269809[esp+100]
	push	ecx
	lea	ecx, DWORD PTR _setGlobalQuests$224090[esp+104]
	call	?find@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::find
	mov	edx, DWORD PTR _setGlobalQuests$224090[esp+100]
	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN6@DoTestQues

; 3134 : 					{
; 3135 : 						// Can we give a copy of this quest to this player?
; 3136 : 						if(IsValidQuestCopyForPlayer(eMajor, pQuest))

	mov	esi, DWORD PTR _eMajor$[esp+92]
	lea	eax, DWORD PTR _quest$224100[esp+96]
	push	eax
	push	esi
	mov	ecx, ebp
	call	?IsValidQuestCopyForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@PAVCvMinorCivQuest@@@Z ; CvMinorCivAI::IsValidQuestCopyForPlayer
	test	al, al
	je	SHORT $LN6@DoTestQues

; 3137 : 						{
; 3138 : 							AddQuestCopyForPlayer(eMajor, pQuest);

	lea	ecx, DWORD PTR _quest$224100[esp+96]
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?AddQuestCopyForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@PAVCvMinorCivQuest@@@Z ; CvMinorCivAI::AddQuestCopyForPlayer

; 3139 : 							setGlobalQuests.insert(eQuestType);

	lea	edx, DWORD PTR _eQuestType$224091[esp+96]
	push	edx
	lea	eax, DWORD PTR $T269811[esp+100]
	push	eax
	lea	ecx, DWORD PTR _setGlobalQuests$224090[esp+104]
	call	?insert@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@_N@2@ABW4MinorCivQuestTypes@@@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::insert
$LN6@DoTestQues:
	mov	ecx, DWORD PTR _iQuestLoop$224096[esp+96]
	mov	eax, DWORD PTR [ebp+3328]
	add	DWORD PTR tv464[esp+96], 28		; 0000001cH
	inc	ecx
	mov	DWORD PTR _iQuestLoop$224096[esp+96], ecx
	cmp	ecx, DWORD PTR [ebx+eax+4]
	jb	$LL7@DoTestQues

; 3119 : 		{
; 3120 : 			for(uint iQuestLoop = 0; iQuestLoop < m_QuestsGiven[iPlayerLoop].size(); iQuestLoop++)

	xor	ecx, ecx
$LN9@DoTestQues:

; 3116 : 
; 3117 : 		MinorCivQuestTypes eQuestType;
; 3118 : 		for(uint iPlayerLoop = 0; iPlayerLoop < m_QuestsGiven.size(); iPlayerLoop++)

	mov	eax, DWORD PTR _iPlayerLoop$224092[esp+96]
	inc	eax
	add	ebx, 156				; 0000009cH
	mov	DWORD PTR _iPlayerLoop$224092[esp+96], eax
	cmp	eax, DWORD PTR [ebp+3332]
	jb	$LL10@DoTestQues
	pop	edi
	pop	esi
	pop	ebx
$LN85@DoTestQues:

; 3140 : 						}
; 3141 : 					}
; 3142 : 				}
; 3143 : 			}
; 3144 : 		}
; 3145 : 	}

	mov	ecx, DWORD PTR _setGlobalQuests$224090[esp+88]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T270009[esp+88]
	push	ecx
	lea	ecx, DWORD PTR _setGlobalQuests$224090[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	?erase@?$_Tree@V?$_Tset_traits@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<enum MinorCivQuestTypes,std::less<enum MinorCivQuestTypes>,std::allocator<enum MinorCivQuestTypes>,0> >::erase
	mov	edx, DWORD PTR _setGlobalQuests$224090[esp+88]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@DoTestQues:

; 3146 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _setGlobalQuests$224090[ebp]
	jmp	??1?$set@W4MinorCivQuestTypes@@U?$less@W4MinorCivQuestTypes@@@std@@V?$allocator@W4MinorCivQuestTypes@@@3@@std@@QAE@XZ
__ehhandler$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMinorCivAI::DoTestQuestsOnFirstContact
PUBLIC	?DoTestActiveQuests@CvMinorCivAI@@QAEX_N0@Z	; CvMinorCivAI::DoTestActiveQuests
; Function compile flags: /Ogtpy
;	COMDAT ?DoTestActiveQuests@CvMinorCivAI@@QAEX_N0@Z
_TEXT	SEGMENT
_bTestComplete$ = 8					; size = 1
_bTestObsolete$ = 12					; size = 1
?DoTestActiveQuests@CvMinorCivAI@@QAEX_N0@Z PROC	; CvMinorCivAI::DoTestActiveQuests, COMDAT
; _this$ = ecx

; 3151 : 	if (bTestComplete)

	cmp	BYTE PTR _bTestComplete$[esp-4], 0
	push	edi
	mov	edi, ecx
	je	SHORT $LN2@DoTestActi@2

; 3152 : 		DoCompletedQuests();

	call	?DoCompletedQuests@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoCompletedQuests
$LN2@DoTestActi@2:

; 3153 : 	
; 3154 : 	if (bTestObsolete)

	cmp	BYTE PTR _bTestObsolete$[esp], 0
	je	SHORT $LN5@DoTestActi@2
	push	esi

; 3155 : 		DoObsoleteQuests();

	xor	esi, esi
	npad	7
$LL7@DoTestActi@2:
	push	-1
	push	esi
	mov	ecx, edi
	call	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL7@DoTestActi@2
	pop	esi
$LN5@DoTestActi@2:
	pop	edi

; 3156 : }

	ret	8
?DoTestActiveQuests@CvMinorCivAI@@QAEX_N0@Z ENDP	; CvMinorCivAI::DoTestActiveQuests
_TEXT	ENDS
PUBLIC	?DoFriendship@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoFriendship
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
xdata$x	SEGMENT
__ehfuncinfo$?DoFriendship@CvMinorCivAI@@QAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?DoFriendship@CvMinorCivAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoFriendship@CvMinorCivAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoFriendship@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
tv683 = -352						; size = 4
_strMinorsNameKey$ = -348				; size = 4
$T270074 = -344						; size = 4
$T270070 = -344						; size = 4
_iAlliesThreshold$225946 = -344				; size = 4
$T270073 = -340						; size = 4
$T270069 = -340						; size = 4
_iFriendsThreshold$225947 = -340			; size = 4
tv638 = -336						; size = 4
_strMessage$ = -332					; size = 80
_strSummary$ = -252					; size = 80
$T270071 = -172						; size = 80
$T270068 = -172						; size = 80
$T270067 = -172						; size = 80
$T270072 = -92						; size = 80
__$EHRec$ = -12						; size = 12
?DoFriendship@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::DoFriendship, COMDAT
; _this$ = ecx

; 5231 : {

	push	-1
	push	__ehhandler$?DoFriendship@CvMinorCivAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	ebp
	push	esi

; 5232 : 	Localization::String strMessage;

	mov	esi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	ebp, ecx
	push	edi
	lea	ecx, DWORD PTR _strMessage$[esp+368]
	call	esi

; 5233 : 	Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$[esp+368]
	mov	DWORD PTR __$EHRec$[esp+376], 0
	call	esi

; 5234 : 	const char* strMinorsNameKey = GetPlayer()->getNameKey();

	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+376], 1
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR _strMinorsNameKey$[esp+368], eax

; 5235 : 
; 5236 : 	PlayerTypes ePlayer;
; 5237 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	xor	eax, eax
	lea	ecx, DWORD PTR [ebp+2024]
	mov	DWORD PTR tv638[esp+368], eax
	mov	DWORD PTR tv683[esp+368], ecx
$LN15@DoFriendsh@2:

; 5238 : 	{
; 5239 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 5240 : 
; 5241 : 		if(GET_PLAYER(ePlayer).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [eax+edx+2256], 0
	je	$LN14@DoFriendsh@2

; 5242 : 		{
; 5243 : 			// Update friendship even if the player hasn't met us yet, since we may have heard things through the grapevine (Wary Of, SP, etc.)
; 5244 : 
; 5245 : 			// Look at the base friendship (not counting war status etc.) and change it
; 5246 : 			int iOldFriendship = GetBaseFriendshipWithMajor(ePlayer);

	test	esi, esi
	jl	SHORT $LN38@DoFriendsh@2
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN38@DoFriendsh@2
	mov	eax, DWORD PTR tv683[esp+368]
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN40@DoFriendsh@2
$LN38@DoFriendsh@2:
	xor	ecx, ecx
$LN40@DoFriendsh@2:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH

; 5247 : 			int iChangeThisTurn = GetFriendshipChangePerTurnTimes100(ePlayer);

	push	esi
	mov	ecx, ebp
	add	edi, edx
	call	?GetFriendshipChangePerTurnTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipChangePerTurnTimes100

; 5248 : 			int iFriendshipAnchor = GetFriendshipAnchorWithMajor(ePlayer);

	push	esi
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipAnchorWithMajor
	mov	ecx, eax

; 5249 : 			int iNewFriendship = iOldFriendship + (iChangeThisTurn / 100);

	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	eax, edi

; 5250 : 			if(iOldFriendship >= iFriendshipAnchor && iNewFriendship < iFriendshipAnchor)

	cmp	edi, ecx
	jl	SHORT $LN11@DoFriendsh@2
	cmp	eax, ecx
	jge	SHORT $LN11@DoFriendsh@2

; 5251 : 			{
; 5252 : 				// If we are at or above anchor, don't let the decay dip us below it
; 5253 : 				SetFriendshipWithMajor(ePlayer, iFriendshipAnchor);

	imul	ecx, 100				; 00000064H
	push	0
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
	jmp	SHORT $LN8@DoFriendsh@2
$LN11@DoFriendsh@2:

; 5254 : 			}
; 5255 : 			else if (iChangeThisTurn != 0)

	test	ebx, ebx
	je	SHORT $LN9@DoFriendsh@2

; 5256 : 			{
; 5257 : 				ChangeFriendshipWithMajorTimes100(ePlayer, iChangeThisTurn);

	test	esi, esi
	jl	SHORT $LN53@DoFriendsh@2
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN53@DoFriendsh@2
	mov	ecx, DWORD PTR tv683[esp+368]
	mov	eax, DWORD PTR [ecx]
	push	0
	add	eax, ebx
	push	eax
	push	esi
	mov	ecx, ebp
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100

; 5258 : 			}
; 5259 : 			else

	jmp	SHORT $LN8@DoFriendsh@2

; 5256 : 			{
; 5257 : 				ChangeFriendshipWithMajorTimes100(ePlayer, iChangeThisTurn);

$LN53@DoFriendsh@2:
	xor	eax, eax
	push	eax
	mov	eax, ebx
	push	eax
	push	esi
	mov	ecx, ebp
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100

; 5258 : 			}
; 5259 : 			else

	jmp	SHORT $LN8@DoFriendsh@2
$LN9@DoFriendsh@2:

; 5260 : 			{
; 5261 : 				// Friendship amount doesn't change, but ally state could have (ex. current ally decays below our level)
; 5262 : 				DoFriendshipChangeEffects(ePlayer, iOldFriendship, iNewFriendship);

	push	0
	push	0
	push	eax
	push	edi
	push	esi
	mov	ecx, ebp
	call	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects
$LN8@DoFriendsh@2:

; 5263 : 			}
; 5264 : 
; 5265 : 			// Notification for status changes
; 5266 : 			if(GetPlayer()->isAlive() && IsHasMetPlayer(ePlayer))

	mov	eax, DWORD PTR [ebp]
	cmp	BYTE PTR [eax+2256], 0
	je	$LN14@DoFriendsh@2
	push	esi
	mov	ecx, ebp
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	je	$LN14@DoFriendsh@2

; 5267 : 			{
; 5268 : 				const int iTurnsWarning = 2;
; 5269 : 				const int iAlliesThreshold = GetAlliesThreshold() * 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840

; 5270 : 				const int iFriendsThreshold = GetFriendsThreshold() * 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	imul	eax, 100				; 00000064H
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _iAlliesThreshold$225946[esp+368], eax
	mov	DWORD PTR _iFriendsThreshold$225947[esp+368], ecx

; 5271 : 				int iEffectiveFriendship = GetEffectiveFriendshipWithMajorTimes100(ePlayer);

	test	esi, esi
	jl	SHORT $LN72@DoFriendsh@2
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN72@DoFriendsh@2
	push	esi
	mov	ecx, ebp
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	mov	eax, DWORD PTR _iAlliesThreshold$225946[esp+368]
	je	SHORT $LN71@DoFriendsh@2
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	edi, 100				; 00000064H
	jmp	SHORT $LN74@DoFriendsh@2
$LN71@DoFriendsh@2:
	mov	edx, DWORD PTR tv683[esp+368]
	mov	edi, DWORD PTR [edx]
	jmp	SHORT $LN74@DoFriendsh@2
$LN72@DoFriendsh@2:
	xor	edi, edi
$LN74@DoFriendsh@2:

; 5272 : 				if(IsAllies(ePlayer))

	cmp	DWORD PTR [ebp+2012], esi
	jne	$LN6@DoFriendsh@2

; 5273 : 				{
; 5274 : 					if(iEffectiveFriendship + (iTurnsWarning * iChangeThisTurn) < iAlliesThreshold &&
; 5275 : 						iEffectiveFriendship + ((iTurnsWarning-1) * iChangeThisTurn) >= iAlliesThreshold)

	lea	ecx, DWORD PTR [edi+ebx*2]
	cmp	ecx, eax
	jge	$LN5@DoFriendsh@2
	add	edi, ebx
	cmp	edi, eax
	jl	$LN5@DoFriendsh@2

; 5276 : 					{
; 5277 : 						strMessage = Localization::Lookup("TXT_KEY_NTFN_CITY_STATE_ALMOST_NOT_ALLIES");

	lea	edx, DWORD PTR $T270067[esp+368]
	push	OFFSET $SG225952
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	ebx, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+372]
	mov	BYTE PTR __$EHRec$[esp+380], 2
	call	ebx
	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T270067[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 1
	call	edi

; 5278 : 						strMessage << strMinorsNameKey;

	mov	eax, DWORD PTR _strMinorsNameKey$[esp+368]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+372]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 5279 : 						strSummary = Localization::Lookup("TXT_KEY_NTFN_CITY_STATE_ALMOST_SM");

	lea	ecx, DWORD PTR $T270068[esp+368]
	push	OFFSET $SG225954
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+372]
	mov	BYTE PTR __$EHRec$[esp+380], 3
	call	ebx
	lea	ecx, DWORD PTR $T270068[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 1
	call	edi

; 5280 : 						strSummary << strMinorsNameKey;

	mov	edx, DWORD PTR _strMinorsNameKey$[esp+368]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[esp+372]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 5281 : 
; 5282 : 						AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), ePlayer);

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	esi
	lea	ecx, DWORD PTR _strSummary$[esp+380]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T270069[esp+408], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN91@DoFriendsh@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN91@DoFriendsh@2:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strMessage$[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 4
	call	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T270070[esp+436], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN96@DoFriendsh@2
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN96@DoFriendsh@2:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification
$LN5@DoFriendsh@2:

; 5283 : 					}
; 5284 : 					if(!GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN14@DoFriendsh@2
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv638[esp+368]
	add	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN14@DoFriendsh@2

; 5285 : 					{
; 5286 : 						gDLL->UnlockAchievement(ACHIEVEMENT_CITYSTATE_ALLY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	42					; 0000002aH
	call	eax

; 5287 : 					}
; 5288 : 
; 5289 : 				}

	jmp	$LN14@DoFriendsh@2
$LN6@DoFriendsh@2:

; 5290 : 				else if(IsFriends(ePlayer))

	push	esi
	mov	ecx, ebp
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	$LN14@DoFriendsh@2

; 5291 : 				{
; 5292 : 					if(iEffectiveFriendship + (iTurnsWarning * iChangeThisTurn) < iFriendsThreshold &&
; 5293 : 						iEffectiveFriendship + ((iTurnsWarning-1) * iChangeThisTurn) >= iFriendsThreshold)

	mov	eax, DWORD PTR _iFriendsThreshold$225947[esp+368]
	lea	ecx, DWORD PTR [edi+ebx*2]
	cmp	ecx, eax
	jge	$LN14@DoFriendsh@2
	add	edi, ebx
	cmp	edi, eax
	jl	$LN14@DoFriendsh@2

; 5294 : 					{
; 5295 : 						strMessage = Localization::Lookup("TXT_KEY_NTFN_CITY_STATE_ALMOST_NOT_FRIENDS");

	lea	edx, DWORD PTR $T270071[esp+368]
	push	OFFSET $SG225962
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	ebx, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+372]
	mov	BYTE PTR __$EHRec$[esp+380], 5
	call	ebx
	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T270071[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 1
	call	edi

; 5296 : 						strMessage << strMinorsNameKey;

	mov	eax, DWORD PTR _strMinorsNameKey$[esp+368]
	push	eax
	lea	ecx, DWORD PTR _strMessage$[esp+372]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 5297 : 						strSummary = Localization::Lookup("TXT_KEY_NTFN_CITY_STATE_ALMOST_SM");

	lea	ecx, DWORD PTR $T270072[esp+368]
	push	OFFSET $SG225964
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$[esp+372]
	mov	BYTE PTR __$EHRec$[esp+380], 6
	call	ebx
	lea	ecx, DWORD PTR $T270072[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 1
	call	edi

; 5298 : 						strSummary << strMinorsNameKey;

	mov	edx, DWORD PTR _strMinorsNameKey$[esp+368]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[esp+372]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 5299 : 
; 5300 : 						AddNotification(strMessage.toUTF8(), strSummary.toUTF8(), ePlayer);

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	esi
	lea	ecx, DWORD PTR _strSummary$[esp+380]
	call	edi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T270073[esp+408], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	lea	ecx, DWORD PTR _strMessage$[esp+408]
	mov	BYTE PTR __$EHRec$[esp+416], 7
	call	edi
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T270074[esp+436], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+444], 1
	call	?AddNotification@CvMinorCivAI@@QAEXVCvString@@0W4PlayerTypes@@HH@Z ; CvMinorCivAI::AddNotification
$LN14@DoFriendsh@2:
	mov	eax, DWORD PTR tv638[esp+368]
	add	DWORD PTR tv683[esp+368], 4
	add	eax, 63236				; 0000f704H
	inc	esi
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv638[esp+368], eax
	jl	$LN15@DoFriendsh@2

; 5301 : 					}
; 5302 : 				}
; 5303 : 			}
; 5304 : 		}
; 5305 : 	}
; 5306 : }

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$[esp+368]
	mov	BYTE PTR __$EHRec$[esp+376], 0
	call	esi
	lea	ecx, DWORD PTR _strMessage$[esp+368]
	mov	DWORD PTR __$EHRec$[esp+376], -1
	call	esi
	mov	ecx, DWORD PTR __$EHRec$[esp+368]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 352				; 00000160H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMessage$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T270067[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T270068[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$4:
	mov	ecx, DWORD PTR $T270069[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T270071[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T270072[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoFriendship@CvMinorCivAI@@QAEXXZ$8:
	mov	ecx, DWORD PTR $T270073[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoFriendship@CvMinorCivAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoFriendship@CvMinorCivAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoFriendship@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::DoFriendship
PUBLIC	?DoBulliedByMajorReaction@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::DoBulliedByMajorReaction
EXTRN	?DoPlayerBulliedSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@0@Z:PROC ; CvDiplomacyAI::DoPlayerBulliedSomeone
; Function compile flags: /Ogtpy
;	COMDAT ?DoBulliedByMajorReaction@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pBully$ = 8						; size = 4
_eBully$ = 8						; size = 4
_iInfluenceChangeTimes100$ = 12				; size = 4
_bShouldRemoveQuests$ = 16				; size = 1
?DoBulliedByMajorReaction@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z PROC ; CvMinorCivAI::DoBulliedByMajorReaction, COMDAT
; _this$ = ecx

; 8659 : {

	push	ecx
	push	ebp

; 8660 : 	CvAssertMsg(eBully >= 0, "eBully is expected to be non-negative (invalid Index)");
; 8661 : 	CvAssertMsg(eBully < MAX_MAJOR_CIVS, "eBully is expected to be within maximum bounds (invalid Index)");
; 8662 : 	if(eBully < 0 || eBully >= MAX_MAJOR_CIVS) return;

	mov	ebp, DWORD PTR _eBully$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+12], edi
	cmp	ebp, 21					; 00000015H
	ja	$LN15@DoBulliedB

; 8663 : 
; 8664 : 	CvPlayer* pBully = &GET_PLAYER(eBully);

	mov	eax, ebp
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pBully$[esp+8], eax

; 8665 : 	CvAssertMsg(pBully, "pBully not expected to be NULL. Please send Anton your save file and version.");
; 8666 : 	if (!pBully) return;

	je	$LN15@DoBulliedB

; 8667 : 
; 8668 : 	SetTurnLastBulliedByMajor(eBully, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 8669 : 	ChangeFriendshipWithMajorTimes100(eBully, iInfluenceChangeTimes100);

	mov	ecx, DWORD PTR _iInfluenceChangeTimes100$[esp+8]
	mov	DWORD PTR [edi+ebp*4+2816], eax
	test	ecx, ecx
	je	SHORT $LN29@DoBulliedB
	mov	eax, DWORD PTR [edi+ebp*4+2024]
	push	0
	add	eax, ecx
	push	eax
	push	ebp
	mov	ecx, edi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
$LN29@DoBulliedB:

; 8670 : 
; 8671 : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 8672 : 	if (bShouldRemoveQuests)

	cmp	BYTE PTR _bShouldRemoveQuests$[esp+8], 0
	push	ebx
	push	esi
	je	SHORT $LN44@DoBulliedB

; 8673 : #endif
; 8674 : 	// In case we have quests that bullying makes obsolete, check now
; 8675 : 	DoTestActiveQuests(/*bTestComplete*/ false, /*bTestObsolete*/ true);

	xor	esi, esi
$LL46@DoBulliedB:
	push	-1
	push	esi
	mov	ecx, edi
	call	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL46@DoBulliedB
$LN44@DoBulliedB:

; 8676 : 
; 8677 : 	// Inform alive majors who have met the bully
; 8678 : 	for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	ebx, ebx
	npad	7
$LL12@DoBulliedB:

; 8679 : 	{
; 8680 : 		PlayerTypes eMajorLoop = (PlayerTypes) iMajorLoop;
; 8681 : 		CvPlayer* pMajorLoop = &GET_PLAYER(eMajorLoop);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	esi, DWORD PTR [ebx+eax]

; 8682 : 		if (!pMajorLoop) continue;

	test	esi, esi
	je	SHORT $LN11@DoBulliedB

; 8683 : 
; 8684 : 		if(pMajorLoop->isAlive())

	cmp	BYTE PTR [esi+2256], 0
	je	SHORT $LN11@DoBulliedB

; 8685 : 		{
; 8686 : 			if(GET_TEAM(pMajorLoop->getTeam()).isHasMet(pBully->getTeam()))

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN59@DoBulliedB
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN60@DoBulliedB
$LN59@DoBulliedB:
	or	eax, -1
$LN60@DoBulliedB:
	mov	ecx, DWORD PTR _pBully$[esp+16]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN11@DoBulliedB

; 8687 : 			{
; 8688 : 				pMajorLoop->GetDiplomacyAI()->DoPlayerBulliedSomeone(eBully, GetPlayer()->GetID());

	mov	eax, DWORD PTR _this$[esp+20]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	push	ebp
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPlayerBulliedSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@0@Z ; CvDiplomacyAI::DoPlayerBulliedSomeone
$LN11@DoBulliedB:
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	SHORT $LL12@DoBulliedB

; 8689 : 			}
; 8690 : 		}
; 8691 : 	}
; 8692 : 
; 8693 : 	// Inform other alive minors, in case they had a quest that this fulfills
; 8694 : 	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	mov	ebx, 22					; 00000016H
	mov	edi, 1391192				; 00153a58H
$LL6@DoBulliedB:

; 8695 : 	{
; 8696 : 		PlayerTypes eMinorLoop = (PlayerTypes) iMinorLoop;
; 8697 : 		if (eMinorLoop == GetPlayer()->GetID()) continue;

	mov	edx, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [edx]
	cmp	ebx, DWORD PTR [eax+44]
	je	SHORT $LN5@DoBulliedB

; 8698 : 
; 8699 : 		CvPlayer* pMinorLoop = &GET_PLAYER(eMinorLoop);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	esi, DWORD PTR [edi+ecx]

; 8700 : 		if (!pMinorLoop) continue;

	test	esi, esi
	je	SHORT $LN5@DoBulliedB

; 8701 : 
; 8702 : 		if (pMinorLoop->isAlive() && pMinorLoop->GetMinorCivAI()->IsHasMetPlayer(eBully))

	cmp	BYTE PTR [esi+2256], 0
	je	SHORT $LN5@DoBulliedB
	push	ebp
	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsHasMetPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsHasMetPlayer
	test	al, al
	je	SHORT $LN5@DoBulliedB

; 8703 : 		{
; 8704 : 			pMinorLoop->GetMinorCivAI()->DoTestActiveQuestsForPlayer(eBully, /*bTestComplete*/ true, /*bTestObsolete*/ false, MINOR_CIV_QUEST_BULLY_CITY_STATE);

	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	push	14					; 0000000eH
	push	ebp
	mov	ecx, eax
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
$LN5@DoBulliedB:
	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL6@DoBulliedB
	pop	esi
	pop	ebx
$LN15@DoBulliedB:
	pop	edi
	pop	ebp

; 8705 : 		}
; 8706 : 	}
; 8707 : }

	pop	ecx
	ret	12					; 0000000cH
?DoBulliedByMajorReaction@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ENDP ; CvMinorCivAI::DoBulliedByMajorReaction
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z	; CvMinorCivAI::DoChangeAliveStatus
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z$0
__ehfuncinfo$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z
_TEXT	SEGMENT
tv1496 = -40						; size = 4
_iNewInfluence$222603 = -40				; size = 4
tv1444 = -36						; size = 4
tv1382 = -36						; size = 4
_bAllies$222622 = -36					; size = 1
_bFriends$222621 = -32					; size = 1
_vNewInfluence$222595 = -28				; size = 16
__$EHRec$ = -12						; size = 12
_bAlive$ = 8						; size = 1
?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z PROC	; CvMinorCivAI::DoChangeAliveStatus, COMDAT
; _this$ = ecx

; 2024 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 2025 : 	if (!bAlive)

	cmp	BYTE PTR _bAlive$[esp+36], 0
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	jne	$LN407@DoChangeAl

; 2026 : 	{
; 2027 : 		// Final check for quests
; 2028 : 		DoTestActiveQuests(/*bTestComplete*/ true, /*bTestObsolete*/ true);

	call	?DoCompletedQuests@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoCompletedQuests
	xor	ebx, ebx
	xor	esi, esi
$LL31@DoChangeAl:
	push	-1
	push	esi
	mov	ecx, edi
	call	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL31@DoChangeAl

; 2029 : 
; 2030 : 		std::vector<int> vNewInfluence;

	mov	DWORD PTR _vNewInfluence$222595[esp+60], ebx
	mov	DWORD PTR _vNewInfluence$222595[esp+64], ebx
	mov	DWORD PTR _vNewInfluence$222595[esp+68], ebx
	lea	eax, DWORD PTR [edi+2024]

; 2031 : 		for (int i = 0; i < MAX_MAJOR_CIVS; ++i)

	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	xor	ebp, ebp
	mov	DWORD PTR tv1382[esp+56], eax
$LL408@DoChangeAl:

; 2032 : 		{
; 2033 : 			PlayerTypes e = (PlayerTypes)i;
; 2034 : 
; 2035 : 			// Cancel quests and PtPs
; 2036 : 			DoChangeProtectionFromMajor(e, false);

	test	esi, esi
	jl	SHORT $LN149@DoChangeAl
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN149@DoChangeAl
	cmp	BYTE PTR [esi+edi+3146], 0
	je	SHORT $LN406@DoChangeAl
	push	9
	push	esi
	mov	ecx, edi
	mov	BYTE PTR [esi+edi+3146], 0
	call	?DoCompletedQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoCompletedQuestsForPlayer
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	18					; 00000012H
	call	edx
$LN406@DoChangeAl:

; 2037 : 			EndAllActiveQuestsForPlayer(e);

	mov	eax, DWORD PTR [edi+3328]
	add	eax, ebp
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN120@DoChangeAl
	mov	DWORD PTR [eax+4], 0
$LN120@DoChangeAl:

; 2038 : 
; 2039 : 			// Calculate new influence levels (don't set here, since that could create a false temporary ally)
; 2040 : 			int iOldInfluence = GetBaseFriendshipWithMajor(e);

	mov	ecx, DWORD PTR tv1382[esp+56]
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN151@DoChangeAl
$LN149@DoChangeAl:
	xor	ecx, ecx
$LN151@DoChangeAl:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 2041 : 			int iNewInfluence = iOldInfluence;
; 2042 : 			if (IsFriendshipAboveAlliesThreshold(iOldInfluence))

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2840
	mov	ecx, eax
	mov	DWORD PTR _iNewInfluence$222603[esp+56], ecx
	jl	SHORT $LN17@DoChangeAl

; 2043 : 			{
; 2044 : 				iNewInfluence = GC.getFRIENDSHIP_ALLIES_ON_DEATH();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2836
	jmp	SHORT $LN414@DoChangeAl
$LN17@DoChangeAl:

; 2045 : 			}
; 2046 : 			else if (IsFriendshipAboveFriendsThreshold(iOldInfluence))

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	jl	SHORT $LN15@DoChangeAl

; 2047 : 			{
; 2048 : 				iNewInfluence = GC.getFRIENDSHIP_FRIENDS_ON_DEATH();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2828
	jmp	SHORT $LN414@DoChangeAl
$LN15@DoChangeAl:

; 2049 : 			}
; 2050 : 			else if (iOldInfluence > GC.getFRIENDSHIP_THRESHOLD_NEUTRAL())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2824
	jle	SHORT $LN13@DoChangeAl

; 2051 : 			{
; 2052 : 				iNewInfluence = GC.getFRIENDSHIP_NEUTRAL_ON_DEATH();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2820
$LN414@DoChangeAl:
	mov	DWORD PTR _iNewInfluence$222603[esp+56], ecx
$LN13@DoChangeAl:

; 2053 : 			}
; 2054 : 			vNewInfluence.push_back(iNewInfluence);

	mov	edx, DWORD PTR _vNewInfluence$222595[esp+60]
	test	edx, edx
	jne	SHORT $LN183@DoChangeAl
	xor	eax, eax
	jmp	SHORT $LN184@DoChangeAl
$LN183@DoChangeAl:
	mov	eax, DWORD PTR _vNewInfluence$222595[esp+68]
	sub	eax, edx
	sar	eax, 2
$LN184@DoChangeAl:
	mov	edx, ebx
	sub	edx, DWORD PTR _vNewInfluence$222595[esp+60]
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN176@DoChangeAl
	mov	DWORD PTR [ebx], ecx
	add	ebx, 4
	mov	DWORD PTR _vNewInfluence$222595[esp+64], ebx
	jmp	SHORT $LN19@DoChangeAl
$LN176@DoChangeAl:
	lea	eax, DWORD PTR _iNewInfluence$222603[esp+56]
	push	eax
	push	1
	push	ebx
	lea	ecx, DWORD PTR _vNewInfluence$222595[esp+68]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebx, DWORD PTR _vNewInfluence$222595[esp+64]
$LN19@DoChangeAl:
	add	DWORD PTR tv1382[esp+56], 4
	add	ebp, 156				; 0000009cH
	inc	esi
	cmp	ebp, 3432				; 00000d68H
	jl	$LL408@DoChangeAl

; 2055 : 		}
; 2056 : 
; 2057 : 		// Set new influence values
; 2058 : 		SetDisableNotifications(true);

	cmp	BYTE PTR [edi+6864], 1
	je	SHORT $LN236@DoChangeAl
	mov	BYTE PTR [edi+6864], 1
$LN236@DoChangeAl:

; 2059 : 		for (unsigned int i = 0; i < vNewInfluence.size(); ++i)

	mov	eax, DWORD PTR _vNewInfluence$222595[esp+60]
	sub	ebx, eax
	mov	ebp, ebx
	sar	ebp, 2
	xor	esi, esi
	test	ebp, ebp
	jbe	$LN10@DoChangeAl
	xor	ebx, ebx
	lea	eax, DWORD PTR [edi+2024]
	mov	DWORD PTR tv1444[esp+56], eax

; 2060 : 		{
; 2061 : 			PlayerTypes e = (PlayerTypes)i;
; 2062 : 			// special workaround to allow status changes despite minor already being dead
; 2063 : 			DoFriendshipChangeEffects(e, GetEffectiveFriendshipWithMajor(e), vNewInfluence.at(i), /*bFromQuest*/false, /*bIgnoreMinorDeath*/true);

	cmp	ebp, esi
	jbe	$LN395@DoChangeAl
$LN416@DoChangeAl:
	test	esi, esi
	jl	SHORT $LN265@DoChangeAl
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN265@DoChangeAl
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN277@DoChangeAl
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN278@DoChangeAl
$LN277@DoChangeAl:
	or	ecx, -1
$LN278@DoChangeAl:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ebx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN288@DoChangeAl
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN289@DoChangeAl
$LN288@DoChangeAl:
	or	eax, -1
$LN289@DoChangeAl:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN264@DoChangeAl
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN267@DoChangeAl
$LN264@DoChangeAl:
	mov	eax, DWORD PTR tv1444[esp+56]
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN267@DoChangeAl
$LN265@DoChangeAl:
	xor	ecx, ecx
$LN267@DoChangeAl:
	mov	edx, DWORD PTR _vNewInfluence$222595[esp+60]
	mov	eax, DWORD PTR [edx+esi*4]
	push	1
	push	0
	push	eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	esi
	mov	ecx, edi
	call	?DoFriendshipChangeEffects@CvMinorCivAI@@QAEXW4PlayerTypes@@HH_N1@Z ; CvMinorCivAI::DoFriendshipChangeEffects

; 2064 : 			SetFriendshipWithMajor(e, vNewInfluence.at(i));

	mov	edx, DWORD PTR _vNewInfluence$222595[esp+60]
	mov	eax, DWORD PTR [edx+esi*4]
	imul	eax, 100				; 00000064H
	push	0
	push	eax
	push	esi
	mov	ecx, edi
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100
	add	DWORD PTR tv1444[esp+56], 4
	inc	esi
	add	ebx, 63236				; 0000f704H
	cmp	ebp, esi
	ja	$LN416@DoChangeAl
	mov	eax, DWORD PTR _vNewInfluence$222595[esp+60]
$LN10@DoChangeAl:

; 2065 : 		}
; 2066 : 		SetDisableNotifications(false);

	cmp	BYTE PTR [edi+6864], 0
	je	SHORT $LN324@DoChangeAl
	mov	BYTE PTR [edi+6864], 0
$LN324@DoChangeAl:

; 2067 : 	}

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	eax, eax
	je	SHORT $LN407@DoChangeAl
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN407@DoChangeAl:

; 2068 : 
; 2069 : 	// Apply or Remove any active bonuses
; 2070 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	lea	eax, DWORD PTR [edi+2024]
	xor	esi, esi
	xor	ebp, ebp
	mov	DWORD PTR tv1496[esp+56], eax
	npad	8
$LL410@DoChangeAl:

; 2071 : 	{
; 2072 : 		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
; 2073 : 
; 2074 : 		bool bFriends = false;

	xor	bl, bl
	mov	BYTE PTR _bFriends$222621[esp+56], bl

; 2075 : 		bool bAllies = false;

	mov	BYTE PTR _bAllies$222622[esp+56], bl

; 2076 : 		if(IsFriendshipAboveFriendsThreshold(GetEffectiveFriendshipWithMajor(ePlayer)))

	test	esi, esi
	jl	SHORT $LN337@DoChangeAl
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN337@DoChangeAl
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN349@DoChangeAl
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN350@DoChangeAl
$LN395@DoChangeAl:

; 2060 : 		{
; 2061 : 			PlayerTypes e = (PlayerTypes)i;
; 2062 : 			// special workaround to allow status changes despite minor already being dead
; 2063 : 			DoFriendshipChangeEffects(e, GetEffectiveFriendshipWithMajor(e), vNewInfluence.at(i), /*bFromQuest*/false, /*bIgnoreMinorDeath*/true);

	call	?_Xran@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xran
$LN417@DoChangeAl:

; 2076 : 		if(IsFriendshipAboveFriendsThreshold(GetEffectiveFriendshipWithMajor(ePlayer)))

$LN349@DoChangeAl:
	or	ecx, -1
$LN350@DoChangeAl:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN360@DoChangeAl
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN361@DoChangeAl
$LN360@DoChangeAl:
	or	eax, -1
$LN361@DoChangeAl:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN336@DoChangeAl
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	ecx, 100				; 00000064H
	jmp	SHORT $LN339@DoChangeAl
$LN336@DoChangeAl:
	mov	eax, DWORD PTR tv1496[esp+56]
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN339@DoChangeAl
$LN337@DoChangeAl:
	xor	ecx, ecx
$LN339@DoChangeAl:
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2832
	jl	SHORT $LN6@DoChangeAl

; 2077 : 		{
; 2078 : 			bFriends = true;

	mov	bl, 1
	mov	BYTE PTR _bFriends$222621[esp+56], bl
$LN6@DoChangeAl:

; 2079 : 		}
; 2080 : 		if(GetAlly() == ePlayer)

	cmp	DWORD PTR [edi+2012], esi
	jne	SHORT $LN411@DoChangeAl

; 2081 : 		{
; 2082 : 			CvAssertMsg(bAlive, "A Minor about to die still has an Ally, when it should have none.");
; 2083 : 			bAllies = true;

	mov	BYTE PTR _bAllies$222622[esp+56], 1
$LN411@DoChangeAl:

; 2084 : 		}
; 2085 : 		if(bFriends || bAllies)

	test	bl, bl
	jne	SHORT $LN3@DoChangeAl
	cmp	BYTE PTR _bAllies$222622[esp+56], bl
	je	SHORT $LN8@DoChangeAl
$LN3@DoChangeAl:

; 2086 : 		{
; 2087 : 			DoSetBonus(ePlayer, bAlive, bFriends, bAllies);

	mov	edx, DWORD PTR _bAllies$222622[esp+56]
	mov	eax, DWORD PTR _bFriends$222621[esp+56]
	mov	ecx, DWORD PTR _bAlive$[esp+52]
	push	-1
	push	0
	push	0
	push	edx
	push	eax
	push	ecx
	push	esi
	mov	ecx, edi
	call	?DoSetBonus@CvMinorCivAI@@QAEXW4PlayerTypes@@_N11110@Z ; CvMinorCivAI::DoSetBonus
$LN8@DoChangeAl:
	add	DWORD PTR tv1496[esp+56], 4
	add	ebp, 63236				; 0000f704H
	inc	esi
	cmp	ebp, 1391192				; 00153a58H
	jl	$LL410@DoChangeAl

; 2088 : 		}
; 2089 : 	}
; 2090 : 
; 2091 : 	// Death - Reset the cached ally and barbarian threat counter
; 2092 : 	if (!bAlive)

	cmp	BYTE PTR _bAlive$[esp+52], 0
	jne	SHORT $LN384@DoChangeAl

; 2093 : 	{
; 2094 : 		bool bHasAlly = GetAlly() != NO_PLAYER;

	or	esi, -1
	cmp	DWORD PTR [edi+2012], esi

; 2095 : 		CvAssertMsg(!bHasAlly, "A Minor about to die still has an Ally, when it should have none.");
; 2096 : 		if(bHasAlly)

	je	SHORT $LN1@DoChangeAl

; 2097 : 		{
; 2098 : 			SetAlly(NO_PLAYER);

	push	esi
	mov	ecx, edi
	call	?SetAlly@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::SetAlly
$LN1@DoChangeAl:

; 2099 : 		}
; 2100 : 
; 2101 : 		SetTurnsSinceThreatenedAnnouncement(-1);

	cmp	DWORD PTR [edi+20], esi
	je	SHORT $LN384@DoChangeAl
	mov	DWORD PTR [edi+20], esi
$LN384@DoChangeAl:

; 2102 : 	}
; 2103 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
$LN413@DoChangeAl:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z$0:
	lea	ecx, DWORD PTR _vNewInfluence$222595[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoChangeAliveStatus@CvMinorCivAI@@QAEX_N@Z ENDP	; CvMinorCivAI::DoChangeAliveStatus
PUBLIC	?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ; CvMinorCivAI::DoFirstContactWithMajor
EXTRN	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z:PROC ; CvGlobals::WrapCityPointer
EXTRN	?CancelActivePlayerEndTurn@@YA_NXZ:PROC		; CancelActivePlayerEndTurn
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?getHasMetCivCount@CvTeam@@QBEH_N@Z:PROC	; CvTeam::getHasMetCivCount
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z$1
__ehfuncinfo$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_bFirstMajorCiv$222648 = -573				; size = 1
_iGoldGift$222646 = -572				; size = 4
$T271780 = -568						; size = 4
_iPlayerLoop$222655 = -564				; size = 4
_iLoop$222667 = -560					; size = 4
tv857 = -556						; size = 4
_pDllLoopCity$222720 = -552				; size = 4
_kPopupInfo$222666 = -548				; size = 536
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bSuppressMessages$ = 12				; size = 1
?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z PROC ; CvMinorCivAI::DoFirstContactWithMajor, COMDAT
; _this$ = ecx

; 2108 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 564				; 00000234H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2109 : 	// Set intrusion flag (used for unit movement)
; 2110 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebx, ebx
	xor	esi, esi
	mov	ebp, ecx
	xor	edi, edi
	npad	9
$LL26@DoFirstCon:

; 2111 : 	{
; 2112 : 		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
; 2113 : 		if(GET_PLAYER(ePlayer).getTeam() == eTeam)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN37@DoFirstCon
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN38@DoFirstCon
$LN37@DoFirstCon:
	or	eax, -1
$LN38@DoFirstCon:
	cmp	eax, DWORD PTR _eTeam$[esp+588]
	jne	SHORT $LN25@DoFirstCon

; 2114 : 		{
; 2115 : 			if(GET_PLAYER(ePlayer).isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN22@DoFirstCon

; 2116 : 			{
; 2117 : 				// Humans intrude automatically upon meeting (allowing them to enter our territory if they choose)
; 2118 : 				SetMajorIntruding(ePlayer, true);

	cmp	esi, ebx
	jl	SHORT $LN25@DoFirstCon
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN25@DoFirstCon
	cmp	BYTE PTR [esi+ebp+3102], 1
	je	SHORT $LN25@DoFirstCon
	mov	BYTE PTR [esi+ebp+3102], 1

; 2119 : 			}
; 2120 : 			else

	jmp	SHORT $LN25@DoFirstCon
$LN22@DoFirstCon:

; 2121 : 			{
; 2122 : 				SetMajorIntruding(ePlayer, false);

	cmp	esi, ebx
	jl	SHORT $LN25@DoFirstCon
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN25@DoFirstCon
	cmp	BYTE PTR [esi+ebp+3102], bl
	je	SHORT $LN25@DoFirstCon
	mov	BYTE PTR [esi+ebp+3102], bl
$LN25@DoFirstCon:

; 2109 : 	// Set intrusion flag (used for unit movement)
; 2110 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	inc	esi
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL26@DoFirstCon

; 2123 : 			}
; 2124 : 		}
; 2125 : 	}
; 2126 : 
; 2127 : 	// This guy's a warmonger or at war with our ally, so we DoW him
; 2128 : 	if(IsPeaceBlocked(eTeam))

	mov	esi, DWORD PTR _eTeam$[esp+588]
	push	esi
	mov	ecx, ebp
	call	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPeaceBlocked
	test	al, al
	je	SHORT $LN20@DoFirstCon

; 2129 : 	{
; 2130 : 		GET_TEAM(GetPlayer()->getTeam()).declareWar(eTeam);

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN68@DoFirstCon
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN69@DoFirstCon
$LN68@DoFirstCon:
	or	eax, -1
$LN69@DoFirstCon:
	mov	ecx, eax
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	push	esi
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar

; 2131 : 	}
; 2132 : 	// Normal diplo
; 2133 : 	else

	jmp	$LN11@DoFirstCon
$LN20@DoFirstCon:

; 2134 : 	{
; 2135 : 		int iGoldGift = 0;
; 2136 : 		int iFaithGift = 0;
; 2137 : 		bool bFirstMajorCiv = false;
; 2138 : 
; 2139 : 		// If this guy has been mean then no Gold gifts
; 2140 : 		if(!GET_TEAM(eTeam).IsMinorCivAggressor())

	mov	ecx, esi
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _iGoldGift$222646[esp+592], ebx
	mov	BYTE PTR _bFirstMajorCiv$222648[esp+592], bl
	call	?IsMinorCivAggressor@CvTeam@@QBE_NXZ	; CvTeam::IsMinorCivAggressor
	test	al, al
	jne	$LN187@DoFirstCon

; 2141 : 		{
; 2142 : 			// Hasn't met anyone yet?
; 2143 : 			if(GET_TEAM(GetPlayer()->getTeam()).getHasMetCivCount(true) == 0)

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN83@DoFirstCon
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN84@DoFirstCon
$LN83@DoFirstCon:
	or	eax, -1
$LN84@DoFirstCon:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	mov	ecx, eax
	call	?getHasMetCivCount@CvTeam@@QBEH_N@Z	; CvTeam::getHasMetCivCount
	test	eax, eax
	jne	SHORT $LN17@DoFirstCon

; 2144 : 			{
; 2145 : 				iGoldGift = /*60*/ GC.getMINOR_CIV_CONTACT_GOLD_FIRST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7280

; 2146 : 				if(GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _iGoldGift$222646[esp+592], eax
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo

; 2154 : 					iFaithGift = 0; // GJS - lowered from 4; //antonjs: todo: XML
; 2155 : 			}
; 2156 : 		}
; 2157 : 
; 2158 : 		PlayerTypes ePlayer;
; 2159 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	mov	BYTE PTR _bFirstMajorCiv$222648[esp+592], 1
	mov	DWORD PTR _iPlayerLoop$222655[esp+592], edi
	mov	DWORD PTR tv857[esp+592], ebx
	jmp	SHORT $LN13@DoFirstCon
$LN17@DoFirstCon:

; 2147 : 					iFaithGift = 0; // GJS - lowered from 8; //antonjs: todo: XML
; 2148 : 				bFirstMajorCiv = true;
; 2149 : 			}
; 2150 : 			else
; 2151 : 			{
; 2152 : 				iGoldGift = /*30*/ GC.getMINOR_CIV_CONTACT_GOLD_OTHER();
; 2153 : 				if(GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7284
	push	eax
	mov	DWORD PTR _iGoldGift$222646[esp+596], edx
	call	?minorCivType@CvPreGame@@YA?AW4MinorCivTypes@@W4PlayerTypes@@@Z ; CvPreGame::minorCivType
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
$LN187@DoFirstCon:

; 2154 : 					iFaithGift = 0; // GJS - lowered from 4; //antonjs: todo: XML
; 2155 : 			}
; 2156 : 		}
; 2157 : 
; 2158 : 		PlayerTypes ePlayer;
; 2159 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	mov	DWORD PTR _iPlayerLoop$222655[esp+592], edi
	mov	DWORD PTR tv857[esp+592], ebx
	jmp	SHORT $LN13@DoFirstCon
	npad	3
$LL190@DoFirstCon:
	mov	esi, DWORD PTR _eTeam$[esp+588]
$LN13@DoFirstCon:

; 2160 : 		{
; 2161 : 			ePlayer = (PlayerTypes) iPlayerLoop;
; 2162 : 
; 2163 : 			if(GET_PLAYER(ePlayer).getTeam() == eTeam)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebx+44]
	add	ecx, ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN122@DoFirstCon
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN123@DoFirstCon
$LN122@DoFirstCon:
	or	eax, -1
$LN123@DoFirstCon:
	cmp	eax, esi
	jne	$LN12@DoFirstCon

; 2164 : 			{
; 2165 : 				// Gold gift
; 2166 : 				GET_PLAYER(ePlayer).GetTreasury()->ChangeGold(iGoldGift);

	mov	eax, DWORD PTR _iGoldGift$222646[esp+592]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2167 : 
; 2168 : 				// Faith gift
; 2169 : 				if(iFaithGift > 0)
; 2170 : 					GET_PLAYER(ePlayer).ChangeFaith(iFaithGift);
; 2171 : 
; 2172 : 				// Need to seed quest counter?
; 2173 : 				if(GC.getGame().getElapsedGameTurns() > GetFirstPossibleTurnForPersonalQuests())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3212
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jle	SHORT $LN189@DoFirstCon

; 2174 : 				{
; 2175 : 					DoTestSeedQuestCountdownForPlayer(ePlayer);

	xor	esi, esi
	push	esi
	push	edi
	mov	ecx, ebp
	call	?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer
	jmp	SHORT $LN8@DoFirstCon
$LN189@DoFirstCon:
	xor	esi, esi
$LN8@DoFirstCon:

; 2176 : 				}
; 2177 : 
; 2178 : 				// See if Threatening Barbarians event is active
; 2179 : 				if(GetTurnsSinceThreatenedAnnouncement() >= 0 && GetTurnsSinceThreatenedAnnouncement() < 10)

	mov	eax, DWORD PTR [ebp+20]
	cmp	eax, esi
	jl	SHORT $LN7@DoFirstCon
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN7@DoFirstCon

; 2180 : 				{
; 2181 : 					DoTestThreatenedAnnouncementForPlayer(ePlayer);

	push	edi
	mov	ecx, ebp
	call	?DoTestThreatenedAnnouncementForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestThreatenedAnnouncementForPlayer
$LN7@DoFirstCon:

; 2182 : 				}
; 2183 : 
; 2184 : 				// See if Proxy War event is active
; 2185 : 				DoTestProxyWarAnnouncementOnFirstContact(ePlayer);

	push	edi
	mov	ecx, ebp
	call	?DoTestProxyWarAnnouncementOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestProxyWarAnnouncementOnFirstContact

; 2186 : 
; 2187 : 				// See if there are any quests you can join now
; 2188 : 				DoTestQuestsOnFirstContact(ePlayer);

	push	edi
	mov	ecx, ebp
	call	?DoTestQuestsOnFirstContact@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestQuestsOnFirstContact

; 2189 : 
; 2190 : 				// Greeting for active human player
; 2191 : 				if(ePlayer == GC.getGame().getActivePlayer() && !bSuppressMessages)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	$LN12@DoFirstCon
	cmp	BYTE PTR _bSuppressMessages$[esp+588], 0
	jne	$LN12@DoFirstCon

; 2192 : 				{
; 2193 : 					if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Should this be !GC.getGame().isMPOption(MPOPTION_SIMULTANEOUS_TURNS)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	SHORT $LN5@DoFirstCon

; 2194 : 					{
; 2195 : 						CvPopupInfo kPopupInfo(BUTTONPOPUP_CITY_STATE_GREETING, GetPlayer()->GetID(), iGoldGift, iFaithGift, 0, bFirstMajorCiv);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iGoldGift$222646[esp+592]
	mov	al, BYTE PTR _bFirstMajorCiv$222648[esp+592]
	mov	DWORD PTR _kPopupInfo$222666[esp+592], ecx

; 2196 : 						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR _kPopupInfo$222666[esp+596], edx
	mov	BYTE PTR _kPopupInfo$222666[esp+608], al
	mov	DWORD PTR _kPopupInfo$222666[esp+600], esi
	mov	DWORD PTR _kPopupInfo$222666[esp+604], esi
	mov	BYTE PTR _kPopupInfo$222666[esp+609], 0
	mov	DWORD PTR _kPopupInfo$222666[esp+612], 61 ; 0000003dH
	mov	BYTE PTR _kPopupInfo$222666[esp+616], 0
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+180]
	lea	eax, DWORD PTR _kPopupInfo$222666[esp+592]
	push	eax
	call	edx

; 2197 : 						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
; 2198 : 						CancelActivePlayerEndTurn();

	call	?CancelActivePlayerEndTurn@@YA_NXZ	; CancelActivePlayerEndTurn
$LN5@DoFirstCon:

; 2199 : 					}
; 2200 : 
; 2201 : 					// update the mouseover text for the city-state's city banners
; 2202 : 					int iLoop = 0;
; 2203 : 					CvCity* pLoopCity = NULL;
; 2204 : 					for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebp]
	push	esi
	lea	eax, DWORD PTR _iLoop$222667[esp+596]
	push	eax
	mov	DWORD PTR _iLoop$222667[esp+600], esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN12@DoFirstCon
	mov	ecx, DWORD PTR _eTeam$[esp+588]
	mov	edi, ecx
	shr	edi, 5

; 2205 : 					{
; 2206 : 						if(pLoopCity->plot()->isRevealed(eTeam))

	mov	edx, edi
	shl	edx, 5
	sub	ecx, edx
	mov	ebx, 1
	shl	ebx, cl
	npad	2
$LL4@DoFirstCon:
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	test	DWORD PTR [eax+edi*4+8], ebx
	je	SHORT $LN3@DoFirstCon

; 2207 : 						{
; 2208 : 							auto_ptr<ICvCity1> pDllLoopCity = GC.WrapCityPointer(pLoopCity);

	push	esi
	lea	eax, DWORD PTR $T271780[esp+596]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllLoopCity$222720[esp+592], esi
	mov	eax, DWORD PTR $T271780[esp+592]
	mov	DWORD PTR __$EHRec$[esp+600], 0
	test	eax, eax
	je	SHORT $LN167@DoFirstCon
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN167@DoFirstCon:

; 2209 : 							GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pDllLoopCity.get(), CITY_UPDATE_TYPE_BANNER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+440]
	push	0
	push	esi
	call	edx

; 2210 : 						}

	mov	DWORD PTR __$EHRec$[esp+600], -1
	test	esi, esi
	je	SHORT $LN3@DoFirstCon
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN3@DoFirstCon:
	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	edx, DWORD PTR _iLoop$222667[esp+596]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL4@DoFirstCon
	mov	ebx, DWORD PTR tv857[esp+592]
	mov	edi, DWORD PTR _iPlayerLoop$222655[esp+592]
$LN12@DoFirstCon:
	add	ebx, 63236				; 0000f704H
	inc	edi
	cmp	ebx, 1391192				; 00153a58H
	mov	DWORD PTR _iPlayerLoop$222655[esp+592], edi
	mov	DWORD PTR tv857[esp+592], ebx
	jl	$LL190@DoFirstCon
$LN11@DoFirstCon:

; 2211 : 					}
; 2212 : 				}
; 2213 : 			}
; 2214 : 		}
; 2215 : 	}
; 2216 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+592]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 576				; 00000240H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _pDllLoopCity$222720[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ENDP ; CvMinorCivAI::DoFirstContactWithMajor
PUBLIC	?DoTurnQuests@CvMinorCivAI@@QAEXXZ		; CvMinorCivAI::DoTurnQuests
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurnQuests@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
_iFirstTurnForPersonalQuests$ = -4			; size = 4
?DoTurnQuests@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::DoTurnQuests, COMDAT
; _this$ = ecx

; 2845 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2846 : 	// ********************
; 2847 : 	// Check Current Quests
; 2848 : 	// ********************
; 2849 : 	DoTestActiveQuests(/*bTestComplete*/ true, /*bTestObsolete*/ true);

	call	?DoCompletedQuests@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoCompletedQuests
	xor	esi, esi
	npad	2
$LL23@DoTurnQues:
	push	-1
	push	esi
	mov	ecx, edi
	call	?DoObsoleteQuestsForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::DoObsoleteQuestsForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL23@DoTurnQues

; 2850 : 	DoQuestsCleanup();

	xor	esi, esi
$LL28@DoTurnQues:
	push	esi
	mov	ecx, edi
	call	?DoQuestsCleanupForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoQuestsCleanupForPlayer
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL28@DoTurnQues

; 2851 : 
; 2852 : 	// ********************
; 2853 : 	// Give Global Quests
; 2854 : 	// ********************
; 2855 : 	int iFirstTurnForGlobalQuests = GetFirstPossibleTurnForGlobalQuests();
; 2856 : 
; 2857 : 	// Increment turns since last quest
; 2858 : 	if(GetGlobalQuestCountdown() > 0)

	mov	eax, DWORD PTR [edi+24]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3192
	test	eax, eax
	jle	SHORT $LN41@DoTurnQues

; 2859 : 	{
; 2860 : 		ChangeGlobalQuestCountdown(-1);

	dec	eax
	mov	DWORD PTR [edi+24], eax
$LN41@DoTurnQues:

; 2861 : 	}
; 2862 : 
; 2863 : 	// Unlock turn - seed the counter
; 2864 : 	if(GC.getGame().getElapsedGameTurns() == iFirstTurnForGlobalQuests)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jne	SHORT $LN13@DoTurnQues

; 2865 : 	{
; 2866 : 		DoTestSeedGlobalQuestCountdown();

	push	0
	mov	ecx, edi
	call	?DoTestSeedGlobalQuestCountdown@CvMinorCivAI@@QAEX_N@Z ; CvMinorCivAI::DoTestSeedGlobalQuestCountdown
$LN13@DoTurnQues:

; 2867 : 	}
; 2868 : 
; 2869 : 	if(GC.getGame().getElapsedGameTurns() > iFirstTurnForGlobalQuests || ENABLE_QUESTS_AT_START)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jle	SHORT $LN12@DoTurnQues

; 2870 : 	{
; 2871 : 		DoTestStartGlobalQuest();

	mov	ecx, edi
	call	?DoTestStartGlobalQuest@CvMinorCivAI@@QAEXXZ ; CvMinorCivAI::DoTestStartGlobalQuest
$LN12@DoTurnQues:

; 2872 : 	}
; 2873 : 
; 2874 : 	// ********************
; 2875 : 	// Give Personal Quests
; 2876 : 	// ********************
; 2877 : 	int iFirstTurnForPersonalQuests = GetFirstPossibleTurnForPersonalQuests();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3212

; 2878 : 
; 2879 : 	PlayerTypes ePlayer;
; 2880 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	mov	DWORD PTR _iFirstTurnForPersonalQuests$[esp+20], eax
	xor	ebx, ebx
	lea	ebp, DWORD PTR [edi+2464]
	npad	14
$LL10@DoTurnQues:

; 2881 : 	{
; 2882 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 2883 : 
; 2884 : 		if(IsHasMetPlayer(ePlayer))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ebx+ecx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN59@DoTurnQues
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN60@DoTurnQues
$LN59@DoTurnQues:
	or	ecx, -1
$LN60@DoTurnQues:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN70@DoTurnQues
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN71@DoTurnQues
$LN70@DoTurnQues:
	or	eax, -1
$LN71@DoTurnQues:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN9@DoTurnQues

; 2885 : 		{
; 2886 : 			// Increment turns since last quest
; 2887 : 			if(GetQuestCountdownForPlayer(ePlayer) > 0)

	test	esi, esi
	jl	SHORT $LN87@DoTurnQues
	cmp	esi, 22					; 00000016H
	jge	SHORT $LN87@DoTurnQues
	mov	eax, DWORD PTR [ebp]
	test	eax, eax
	jle	SHORT $LN87@DoTurnQues

; 2888 : 			{
; 2889 : 				ChangeQuestCountdownForPlayer(ePlayer, -1);

	dec	eax
	mov	DWORD PTR [ebp], eax
$LN87@DoTurnQues:

; 2890 : 			}
; 2891 : 
; 2892 : 			// Unlock turn - seed the counter
; 2893 : 			if(GC.getGame().getElapsedGameTurns() == iFirstTurnForPersonalQuests)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, DWORD PTR _iFirstTurnForPersonalQuests$[esp+20]
	jne	SHORT $LN5@DoTurnQues

; 2894 : 			{
; 2895 : 				DoTestSeedQuestCountdownForPlayer(ePlayer);

	push	0
	push	esi
	mov	ecx, edi
	call	?DoTestSeedQuestCountdownForPlayer@CvMinorCivAI@@QAEXW4PlayerTypes@@_N@Z ; CvMinorCivAI::DoTestSeedQuestCountdownForPlayer
	jmp	SHORT $LN9@DoTurnQues
$LN5@DoTurnQues:

; 2896 : 			}
; 2897 : 			// Can't start a quest too early
; 2898 : 			else if(GC.getGame().getElapsedGameTurns() > iFirstTurnForPersonalQuests || ENABLE_QUESTS_AT_START)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, DWORD PTR _iFirstTurnForPersonalQuests$[esp+20]
	jle	SHORT $LN9@DoTurnQues

; 2899 : 			{
; 2900 : 				if(!IsAtWarWithPlayersTeam(ePlayer))

	push	esi
	mov	ecx, edi
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	jne	SHORT $LN9@DoTurnQues

; 2901 : 				{
; 2902 : 					DoTestStartPersonalQuest(ePlayer);

	push	esi
	mov	ecx, edi
	call	?DoTestStartPersonalQuest@CvMinorCivAI@@QAEXW4PlayerTypes@@@Z ; CvMinorCivAI::DoTestStartPersonalQuest
$LN9@DoTurnQues:
	add	ebx, 63236				; 0000f704H
	inc	esi
	add	ebp, 4
	cmp	ebx, 1391192				; 00153a58H
	jl	$LL10@DoTurnQues
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2903 : 				}
; 2904 : 			}
; 2905 : 		}
; 2906 : 	}
; 2907 : }

	pop	ecx
	ret	0
?DoTurnQuests@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::DoTurnQuests
_TEXT	ENDS
PUBLIC	?DoMajorBullyGold@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ; CvMinorCivAI::DoMajorBullyGold
EXTRN	?LogMinorCivBullyGold@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHH_NH@Z:PROC ; CvDiplomacyAI::LogMinorCivBullyGold
; Function compile flags: /Ogtpy
;	COMDAT ?DoMajorBullyGold@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_bSuccess$ = -12					; size = 1
_iOldFriendshipTimes100$ = -8				; size = 4
_iBullyMetric$ = -4					; size = 4
_bShouldRemoveQuests$228068 = 8				; size = 1
_iBullyGold$228065 = 8					; size = 4
_eBully$ = 8						; size = 4
_iGold$ = 12						; size = 4
?DoMajorBullyGold@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z PROC ; CvMinorCivAI::DoMajorBullyGold, COMDAT
; _this$ = ecx

; 8549 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 8550 : 	CvAssertMsg(eBully >= 0, "eBully is expected to be non-negative (invalid Index)");
; 8551 : 	CvAssertMsg(eBully < MAX_MAJOR_CIVS, "eBully is expected to be within maximum bounds (invalid Index)");
; 8552 : 	if(eBully < 0 || eBully >= MAX_MAJOR_CIVS) return;

	mov	esi, DWORD PTR _eBully$[esp+16]
	mov	ebx, ecx
	cmp	esi, 21					; 00000015H
	ja	$LN5@DoMajorBul
	push	ebp
	push	edi

; 8553 : 
; 8554 : 	int iBullyMetric = CalculateBullyMetric(eBully, /*bForUnit*/false);

	push	0
	push	0
	push	esi
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric
	mov	edi, eax

; 8555 : 	bool bSuccess = CanMajorBullyGold(eBully, iBullyMetric);

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+2256], 0
	mov	DWORD PTR _iBullyMetric$[esp+28], edi
	jne	SHORT $LN9@DoMajorBul
	mov	BYTE PTR _bSuccess$[esp+28], 0
	jmp	SHORT $LN12@DoMajorBul
$LN9@DoMajorBul:
	test	edi, edi
	setge	BYTE PTR _bSuccess$[esp+28]
$LN12@DoMajorBul:

; 8556 : 	int iOldFriendshipTimes100 = GetEffectiveFriendshipWithMajorTimes100(eBully);

	push	esi
	mov	ecx, ebx
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN20@DoMajorBul
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iOldFriendshipTimes100$[esp+28], eax
	jmp	SHORT $LN23@DoMajorBul
$LN20@DoMajorBul:
	mov	ecx, DWORD PTR [ebx+esi*4+2024]
	mov	DWORD PTR _iOldFriendshipTimes100$[esp+28], ecx
$LN23@DoMajorBul:

; 8557 : 
; 8558 : 	if(bSuccess)

	cmp	BYTE PTR _bSuccess$[esp+28], 0
	mov	ebp, DWORD PTR _iGold$[esp+24]
	je	$LN4@DoMajorBul

; 8559 : 	{
; 8560 : 		CvAssertMsg(iGold >= 0, "iGold is expected to be non-negative. Please send Anton your save file and version.");
; 8561 : 	
; 8562 : 		if(GC.getGame().getActivePlayer() == eBully)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, esi
	jne	SHORT $LN3@DoMajorBul

; 8563 : 		{
; 8564 : 			int iBullyGold = 0;
; 8565 : 			gDLL->GetSteamStat(ESTEAMSTAT_BULLIEDGOLD, &iBullyGold);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	lea	eax, DWORD PTR _iBullyGold$228065[esp+24]
	mov	DWORD PTR _iBullyGold$228065[esp+24], 0
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+836]
	push	eax
	push	136					; 00000088H
	call	edx

; 8566 : 
; 8567 : 			iBullyGold += iGold;

	mov	eax, DWORD PTR _iBullyGold$228065[esp+24]

; 8568 : 
; 8569 : 			gDLL->SetSteamStat(ESTEAMSTAT_BULLIEDGOLD, iBullyGold);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	add	eax, ebp
	mov	DWORD PTR _iBullyGold$228065[esp+24], eax
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+840]
	push	136					; 00000088H
	call	eax
$LN3@DoMajorBul:

; 8570 : 		}
; 8571 : 
; 8572 : 		GET_PLAYER(eBully).GetTreasury()->ChangeGold(iGold);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, esi
	imul	edi, 63236				; 0000f704H
	add	ecx, edi
	push	ebp
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 8573 : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 8574 : 		int iInfluenceChange = 0;
; 8575 : 		int iBullyInfluenceGain = GET_PLAYER(eBully).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	push	53					; 00000035H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 8576 : 		bool bShouldRemoveQuests;
; 8577 : 		if (iBullyInfluenceGain > 0)

	test	eax, eax
	jle	SHORT $LN2@DoMajorBul

; 8578 : 		{
; 8579 : 			iInfluenceChange = iBullyInfluenceGain;
; 8580 : 			bShouldRemoveQuests = false;

	mov	BYTE PTR _bShouldRemoveQuests$228068[esp+24], 0

; 8581 : 		}
; 8582 : 		else

	jmp	SHORT $LN1@DoMajorBul
$LN2@DoMajorBul:

; 8583 : 		{
; 8584 : 			iInfluenceChange = GC.getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2748

; 8585 : 			bShouldRemoveQuests = true;

	mov	BYTE PTR _bShouldRemoveQuests$228068[esp+24], 1
$LN1@DoMajorBul:

; 8586 : 		}
; 8587 : 		DoBulliedByMajorReaction(eBully, iInfluenceChange, bShouldRemoveQuests);

	mov	ecx, DWORD PTR _bShouldRemoveQuests$228068[esp+24]
	push	ecx
	push	eax
	push	esi
	mov	ecx, ebx
	call	?DoBulliedByMajorReaction@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::DoBulliedByMajorReaction
	mov	edi, DWORD PTR _iBullyMetric$[esp+28]
$LN4@DoMajorBul:

; 8588 : #else
; 8589 : 		DoBulliedByMajorReaction(eBully, GC.getMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS());
; 8590 : #endif
; 8591 : 	}
; 8592 : 
; 8593 : 	// Logging
; 8594 : 	GET_PLAYER(eBully).GetDiplomacyAI()->LogMinorCivBullyGold(GetPlayer()->GetID(), iOldFriendshipTimes100, GetEffectiveFriendshipWithMajorTimes100(eBully), iGold, bSuccess, iBullyMetric);

	push	esi
	mov	ecx, ebx
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN43@DoMajorBul
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	edx, 100				; 00000064H
	jmp	SHORT $LN46@DoMajorBul
$LN43@DoMajorBul:
	mov	edx, DWORD PTR [ebx+esi*4+2024]
$LN46@DoMajorBul:
	mov	eax, DWORD PTR [ebx]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	push	edi
	mov	ecx, esi
	mov	esi, DWORD PTR _bSuccess$[esp+32]
	push	esi
	push	ebp
	push	edx
	mov	edx, DWORD PTR _iOldFriendshipTimes100$[esp+44]
	push	edx
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivBullyGold@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHH_NH@Z ; CvDiplomacyAI::LogMinorCivBullyGold

; 8595 : 
; 8596 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 8597 : }

	add	esp, 12					; 0000000cH

; 8595 : 
; 8596 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	DWORD PTR _iGold$[esp-4], 1
	mov	DWORD PTR _eBully$[esp-4], 11		; 0000000bH
	mov	edx, DWORD PTR [eax+260]
	jmp	edx
$LN5@DoMajorBul:
	pop	esi
	pop	ebx

; 8597 : }

	add	esp, 12					; 0000000cH
	ret	8
?DoMajorBullyGold@CvMinorCivAI@@QAEXW4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::DoMajorBullyGold
_TEXT	ENDS
PUBLIC	?DoMajorBullyUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@W4UnitTypes@@@Z ; CvMinorCivAI::DoMajorBullyUnit
EXTRN	?LogMinorCivBullyUnit@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4UnitTypes@@_NH@Z:PROC ; CvDiplomacyAI::LogMinorCivBullyUnit
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
; Function compile flags: /Ogtpy
;	COMDAT ?DoMajorBullyUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_iOldFriendshipTimes100$ = -8				; size = 4
_iBullyMetric$ = -4					; size = 4
_bSuccess$ = 8						; size = 1
_eBully$ = 8						; size = 4
_eUnitType$ = 12					; size = 4
?DoMajorBullyUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@W4UnitTypes@@@Z PROC ; CvMinorCivAI::DoMajorBullyUnit, COMDAT
; _this$ = ecx

; 8600 : {

	sub	esp, 8
	push	ebp

; 8601 : 	CvAssertMsg(eBully >= 0, "eBully is expected to be non-negative (invalid Index)");
; 8602 : 	CvAssertMsg(eBully < MAX_MAJOR_CIVS, "eBully is expected to be within maximum bounds (invalid Index)");
; 8603 : 	if(eBully < 0 || eBully >= MAX_MAJOR_CIVS) return;

	mov	ebp, DWORD PTR _eBully$[esp+8]
	push	edi
	mov	edi, ecx
	cmp	ebp, 21					; 00000015H
	ja	$LN7@DoMajorBul@2
	push	ebx

; 8604 : 
; 8605 : 	int iBullyMetric = CalculateBullyMetric(eBully, /*bForUnit*/true);

	push	0
	push	1
	push	ebp
	call	?CalculateBullyMetric@CvMinorCivAI@@QAEHW4PlayerTypes@@_NPAVCvString@@@Z ; CvMinorCivAI::CalculateBullyMetric

; 8606 : 	bool bSuccess = CanMajorBullyUnit(eBully, iBullyMetric);

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+2256], 0
	mov	DWORD PTR _iBullyMetric$[esp+20], eax
	jne	SHORT $LN11@DoMajorBul@2
	xor	bl, bl
	jmp	SHORT $LN64@DoMajorBul@2
$LN11@DoMajorBul@2:
	test	eax, eax
	setge	bl
$LN64@DoMajorBul@2:

; 8607 : 	int iOldFriendshipTimes100 = GetEffectiveFriendshipWithMajorTimes100(eBully);

	push	ebp
	mov	ecx, edi
	mov	BYTE PTR _bSuccess$[esp+20], bl
	call	?IsAtWarWithPlayersTeam@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAtWarWithPlayersTeam
	test	al, al
	je	SHORT $LN22@DoMajorBul@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2768
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iOldFriendshipTimes100$[esp+20], eax
	jmp	SHORT $LN25@DoMajorBul@2
$LN22@DoMajorBul@2:
	mov	edx, DWORD PTR [edi+ebp*4+2024]
	mov	DWORD PTR _iOldFriendshipTimes100$[esp+20], edx
$LN25@DoMajorBul@2:
	push	esi

; 8608 : 
; 8609 : 	if(bSuccess)

	test	bl, bl
	je	$LN1@DoMajorBul@2

; 8610 : 	{
; 8611 : 		if(eUnitType == NO_UNIT)

	mov	esi, DWORD PTR _eUnitType$[esp+20]
	cmp	esi, -1
	je	$LN62@DoMajorBul@2

; 8612 : 		{
; 8613 : 			CvAssertMsg(false, "eUnitType is not expected to be NO_UNIT. Please send Anton your save file and version.");
; 8614 : 			return;
; 8615 : 		}
; 8616 : 
; 8617 : 		// Minor must have Capital
; 8618 : 		CvCity* pCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [edi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 8619 : 		if(pCapital == NULL)

	test	eax, eax
	je	$LN62@DoMajorBul@2

; 8620 : 		{
; 8621 : 			CvAssertMsg(false, "Trying to spawn a Unit for a major civ but the minor has no capital. Please send Anton your save file and version.");
; 8622 : 			return;
; 8623 : 		}
; 8624 : 
; 8625 : 		int iX = pCapital->getX();

	mov	edx, DWORD PTR [eax+96]

; 8626 : 		int iY = pCapital->getY();

	mov	eax, DWORD PTR [eax+108]

; 8627 : 
; 8628 : 		CvUnit* pNewUnit = GET_PLAYER(eBully).initUnit(eUnitType, iX, iY);

	push	0
	push	0
	push	1
	push	0
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	push	-1
	push	eax
	push	edx
	push	esi
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	esi, eax

; 8629 : 		if (pNewUnit->jumpToNearestValidPlot())

	mov	ecx, esi
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot

; 8630 : 		{
; 8631 : 			pNewUnit->finishMoves(); // The given unit cannot move this turn

	mov	ecx, esi
	test	al, al
	je	SHORT $LN3@DoMajorBul@2
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 8632 : 
; 8633 : 			if(GetPlayer()->getCapitalCity())

	mov	ecx, DWORD PTR [edi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN2@DoMajorBul@2

; 8634 : 				GetPlayer()->getCapitalCity()->addProductionExperience(pNewUnit);

	mov	ecx, DWORD PTR [edi]
	push	0
	push	esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?addProductionExperience@CvCity@@QAEXPAVCvUnit@@_N@Z ; CvCity::addProductionExperience
$LN2@DoMajorBul@2:

; 8635 : 
; 8636 : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 8637 : 			DoBulliedByMajorReaction(eBully, GC.getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS(), true);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2756
	push	1
	push	eax
	push	ebp
	mov	ecx, edi
	call	?DoBulliedByMajorReaction@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::DoBulliedByMajorReaction

; 8638 : #else
; 8639 : 			DoBulliedByMajorReaction(eBully, GC.getMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS());
; 8640 : #endif
; 8641 : 		}
; 8642 : 		else

	jmp	SHORT $LN1@DoMajorBul@2
$LN3@DoMajorBul@2:

; 8643 : 			pNewUnit->kill(false);	// Could not find a spot for the unit!

	push	-1
	push	0
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN1@DoMajorBul@2:

; 8644 : 	}
; 8645 : 
; 8646 : 	// Logging
; 8647 : 	GET_PLAYER(eBully).GetDiplomacyAI()->LogMinorCivBullyUnit(GetPlayer()->GetID(), iOldFriendshipTimes100, GetEffectiveFriendshipWithMajorTimes100(eBully), eUnitType, bSuccess, iBullyMetric);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iBullyMetric$[esp+24]
	mov	ebx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _bSuccess$[esp+20]
	mov	ecx, DWORD PTR _eUnitType$[esp+20]
	mov	esi, ebp
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	push	ecx
	push	ebp
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
	mov	edx, DWORD PTR _iOldFriendshipTimes100$[esp+36]
	push	eax
	push	edx
	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogMinorCivBullyUnit@CvDiplomacyAI@@QAEXW4PlayerTypes@@HHW4UnitTypes@@_NH@Z ; CvDiplomacyAI::LogMinorCivBullyUnit

; 8648 : 
; 8649 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 8650 : }

	add	esp, 8

; 8648 : 
; 8649 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	DWORD PTR _eUnitType$[esp-4], 1
	mov	DWORD PTR _eBully$[esp-4], 11		; 0000000bH
	mov	edx, DWORD PTR [eax+260]
	jmp	edx
$LN62@DoMajorBul@2:
	pop	esi
	pop	ebx
$LN7@DoMajorBul@2:
	pop	edi
	pop	ebp

; 8650 : }

	add	esp, 8
	ret	8
?DoMajorBullyUnit@CvMinorCivAI@@QAEXW4PlayerTypes@@W4UnitTypes@@@Z ENDP ; CvMinorCivAI::DoMajorBullyUnit
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?DoTurn@CvMinorCivAI@@QAEXXZ			; CvMinorCivAI::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvMinorCivAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvMinorCivAI@@QAEXXZ PROC			; CvMinorCivAI::DoTurn, COMDAT
; _this$ = ecx

; 2001 : {

	push	esi
	mov	esi, ecx

; 2002 : 	AI_PERF_FORMAT("AI-perf.csv", ("CvMinorCivAI::DoTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), GetPlayer()->getCivilizationShortDescription()) );
; 2003 : 	if(GetPlayer()->isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN1@DoTurn

; 2004 : 	{
; 2005 : 		DoTurnStatus();

	mov	ecx, esi
	call	?DoTurnStatus@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoTurnStatus

; 2006 : 
; 2007 : 		DoElection();

	mov	ecx, esi
	call	?DoElection@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoElection

; 2008 : 		DoFriendship();

	mov	ecx, esi
	call	?DoFriendship@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoFriendship

; 2009 : 
; 2010 : 		DoTestThreatenedAnnouncement();

	mov	ecx, esi
	call	?DoTestThreatenedAnnouncement@CvMinorCivAI@@QAEXXZ ; CvMinorCivAI::DoTestThreatenedAnnouncement

; 2011 : 		DoTestProxyWarAnnouncement();

	mov	ecx, esi
	call	?DoTestProxyWarAnnouncement@CvMinorCivAI@@QAEXXZ ; CvMinorCivAI::DoTestProxyWarAnnouncement

; 2012 : 
; 2013 : 		DoTurnQuests();

	mov	ecx, esi
	call	?DoTurnQuests@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoTurnQuests

; 2014 : 
; 2015 : 		DoUnitSpawnTurn();

	mov	ecx, esi
	call	?DoUnitSpawnTurn@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoUnitSpawnTurn

; 2016 : 
; 2017 : 		DoIntrusion();

	mov	ecx, esi
	pop	esi
	jmp	?DoIntrusion@CvMinorCivAI@@QAEXXZ	; CvMinorCivAI::DoIntrusion
$LN1@DoTurn:
	pop	esi

; 2018 : 	}
; 2019 : }

	ret	0
?DoTurn@CvMinorCivAI@@QAEXXZ ENDP			; CvMinorCivAI::DoTurn
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??_7CvTeam@@6B@					; CvTeam::`vftable'
PUBLIC	??0CvTeam@@QAE@ABV0@@Z				; CvTeam::CvTeam
PUBLIC	??_R4CvTeam@@6B@				; CvTeam::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTeam@@@8				; CvTeam `RTTI Type Descriptor'
PUBLIC	??_R3CvTeam@@8					; CvTeam::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTeam@@8					; CvTeam::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTeam@@8				; CvTeam::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	?Read@CvTeam@@UAEXAAVFDataStream@@@Z:PROC	; CvTeam::Read
EXTRN	?Write@CvTeam@@UBEXAAVFDataStream@@@Z:PROC	; CvTeam::Write
;	COMDAT ??_R1A@?0A@EA@CvTeam@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTeam@@8 DD FLAT:??_R0?AVCvTeam@@@8	; CvTeam::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTeam@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTeam@@8
rdata$r	SEGMENT
??_R2CvTeam@@8 DD FLAT:??_R1A@?0A@EA@CvTeam@@8		; CvTeam::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvTeam@@8
rdata$r	SEGMENT
??_R3CvTeam@@8 DD 00H					; CvTeam::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvTeam@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTeam@@@8
_DATA	SEGMENT
??_R0?AVCvTeam@@@8 DD FLAT:??_7type_info@@6B@		; CvTeam `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTeam@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTeam@@6B@
rdata$r	SEGMENT
??_R4CvTeam@@6B@ DD 00H					; CvTeam::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTeam@@@8
	DD	FLAT:??_R3CvTeam@@8
rdata$r	ENDS
;	COMDAT ??_7CvTeam@@6B@
CONST	SEGMENT
??_7CvTeam@@6B@ DD FLAT:??_R4CvTeam@@6B@		; CvTeam::`vftable'
	DD	FLAT:?Read@CvTeam@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvTeam@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvTeam@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvTeam@@QAE@ABV0@@Z PROC				; CvTeam::CvTeam, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR [ebx], OFFSET ??_7CvTeam@@6B@
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], eax
	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], ecx
	mov	edx, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], edx
	mov	eax, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], eax
	mov	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], ecx
	mov	edx, DWORD PTR [ebp+24]
	mov	DWORD PTR [ebx+24], edx
	mov	eax, DWORD PTR [ebp+28]
	mov	DWORD PTR [ebx+28], eax
	mov	ecx, DWORD PTR [ebp+32]
	mov	DWORD PTR [ebx+32], ecx
	mov	edx, DWORD PTR [ebp+36]
	mov	DWORD PTR [ebx+36], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [ebx+40], eax
	mov	ecx, DWORD PTR [ebp+44]
	mov	DWORD PTR [ebx+44], ecx
	mov	edx, DWORD PTR [ebp+48]
	mov	DWORD PTR [ebx+48], edx
	mov	eax, DWORD PTR [ebp+52]
	mov	DWORD PTR [ebx+52], eax
	mov	ecx, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], ecx
	mov	edx, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], edx
	mov	eax, DWORD PTR [ebp+64]
	mov	DWORD PTR [ebx+64], eax
	mov	ecx, DWORD PTR [ebp+68]
	mov	DWORD PTR [ebx+68], ecx
	mov	edx, DWORD PTR [ebp+72]
	mov	DWORD PTR [ebx+72], edx
	mov	eax, DWORD PTR [ebp+76]
	mov	DWORD PTR [ebx+76], eax
	mov	ecx, DWORD PTR [ebp+80]
	mov	DWORD PTR [ebx+80], ecx
	mov	edx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ebx+84], edx
	mov	eax, DWORD PTR [ebp+88]
	mov	DWORD PTR [ebx+88], eax
	mov	ecx, DWORD PTR [ebp+92]
	mov	DWORD PTR [ebx+92], ecx
	mov	edx, DWORD PTR [ebp+96]
	mov	DWORD PTR [ebx+96], edx
	mov	eax, DWORD PTR [ebp+100]
	mov	DWORD PTR [ebx+100], eax
	mov	ecx, DWORD PTR [ebp+104]
	mov	DWORD PTR [ebx+104], ecx
	mov	edx, DWORD PTR [ebp+108]
	mov	DWORD PTR [ebx+108], edx
	mov	eax, DWORD PTR [ebp+112]
	mov	DWORD PTR [ebx+112], eax
	mov	ecx, DWORD PTR [ebp+116]
	mov	DWORD PTR [ebx+116], ecx
	mov	edx, DWORD PTR [ebp+120]
	mov	DWORD PTR [ebx+120], edx
	mov	eax, DWORD PTR [ebp+124]
	mov	DWORD PTR [ebx+124], eax
	movzx	ecx, BYTE PTR [ebp+128]
	mov	BYTE PTR [ebx+128], cl
	movzx	edx, BYTE PTR [ebp+129]
	mov	BYTE PTR [ebx+129], dl
	movzx	eax, BYTE PTR [ebp+130]
	mov	BYTE PTR [ebx+130], al
	movzx	ecx, BYTE PTR [ebp+131]
	mov	BYTE PTR [ebx+131], cl
	movzx	edx, BYTE PTR [ebp+132]
	mov	BYTE PTR [ebx+132], dl
	movzx	eax, BYTE PTR [ebp+133]
	push	esi
	push	edi
	mov	BYTE PTR [ebx+133], al
	movzx	ecx, BYTE PTR [ebp+134]
	mov	BYTE PTR [ebx+134], cl
	movzx	edx, BYTE PTR [ebp+135]
	mov	BYTE PTR [ebx+135], dl
	mov	eax, DWORD PTR [ebp+136]
	mov	DWORD PTR [ebx+136], eax
	mov	ecx, DWORD PTR [ebp+140]
	mov	DWORD PTR [ebx+140], ecx
	mov	edx, DWORD PTR [ebp+144]
	mov	DWORD PTR [ebx+144], edx
	lea	esi, DWORD PTR [ebp+148]
	lea	edi, DWORD PTR [ebx+148]
	mov	ecx, 80					; 00000050H
	rep movsd
	lea	esi, DWORD PTR [ebp+468]
	lea	edi, DWORD PTR [ebx+468]
	mov	ecx, 80					; 00000050H
	rep movsd
	lea	esi, DWORD PTR [ebp+788]
	lea	edi, DWORD PTR [ebx+788]
	mov	ecx, 80					; 00000050H
	rep movsd
	mov	eax, DWORD PTR [ebp+1108]
	mov	DWORD PTR [ebx+1108], eax
	mov	ecx, DWORD PTR [ebp+1112]
	mov	DWORD PTR [ebx+1112], ecx
	mov	edx, DWORD PTR [ebp+1116]
	mov	DWORD PTR [ebx+1116], edx
	mov	eax, DWORD PTR [ebp+1120]
	mov	DWORD PTR [ebx+1120], eax
	mov	ecx, DWORD PTR [ebp+1124]
	mov	DWORD PTR [ebx+1124], ecx
	lea	esi, DWORD PTR [ebp+1128]
	lea	edi, DWORD PTR [ebx+1128]
	mov	ecx, 80					; 00000050H
	rep movsd
	lea	esi, DWORD PTR [ebp+1448]
	lea	edi, DWORD PTR [ebx+1448]
	mov	ecx, 80					; 00000050H
	rep movsd
	lea	esi, DWORD PTR [ebp+1768]
	lea	edi, DWORD PTR [ebx+1768]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+1848]
	lea	edi, DWORD PTR [ebx+1848]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+1928]
	lea	edi, DWORD PTR [ebx+1928]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2008]
	lea	edi, DWORD PTR [ebx+2008]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2088]
	lea	edi, DWORD PTR [ebx+2088]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2168]
	lea	edi, DWORD PTR [ebx+2168]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2248]
	lea	edi, DWORD PTR [ebx+2248]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2328]
	lea	edi, DWORD PTR [ebx+2328]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2408]
	lea	edi, DWORD PTR [ebx+2408]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2488]
	lea	edi, DWORD PTR [ebx+2488]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebp+2568]
	lea	edi, DWORD PTR [ebx+2568]
	mov	ecx, 80					; 00000050H
	rep movsd
	mov	edx, DWORD PTR [ebp+2888]
	mov	DWORD PTR [ebx+2888], edx
	mov	eax, DWORD PTR [ebp+2892]
	mov	DWORD PTR [ebx+2892], eax
	mov	ecx, DWORD PTR [ebp+2896]
	mov	DWORD PTR [ebx+2896], ecx
	mov	edx, DWORD PTR [ebp+2900]
	mov	DWORD PTR [ebx+2900], edx
	mov	eax, DWORD PTR [ebp+2904]
	mov	DWORD PTR [ebx+2904], eax
	mov	ecx, DWORD PTR [ebp+2908]
	mov	DWORD PTR [ebx+2908], ecx
	mov	edx, DWORD PTR [ebp+2912]
	mov	DWORD PTR [ebx+2912], edx
	mov	eax, DWORD PTR [ebp+2916]
	mov	DWORD PTR [ebx+2916], eax
	mov	ecx, DWORD PTR [ebp+2920]
	mov	DWORD PTR [ebx+2920], ecx
	mov	edx, DWORD PTR [ebp+2924]
	mov	DWORD PTR [ebx+2924], edx
	mov	eax, DWORD PTR [ebp+2928]
	mov	DWORD PTR [ebx+2928], eax
	mov	ecx, DWORD PTR [ebp+2932]
	mov	DWORD PTR [ebx+2932], ecx
	mov	edx, DWORD PTR [ebp+2936]
	mov	DWORD PTR [ebx+2936], edx
	mov	eax, DWORD PTR [ebp+2940]
	mov	DWORD PTR [ebx+2940], eax
	mov	ecx, DWORD PTR [ebp+2944]
	mov	DWORD PTR [ebx+2944], ecx
	mov	edx, DWORD PTR [ebp+2948]
	mov	DWORD PTR [ebx+2948], edx
	mov	eax, DWORD PTR [ebp+2952]
	mov	DWORD PTR [ebx+2952], eax
	mov	ecx, DWORD PTR [ebp+2956]
	mov	DWORD PTR [ebx+2956], ecx
	mov	edx, DWORD PTR [ebp+2960]
	lea	eax, DWORD PTR [ebp+2964]
	push	eax
	lea	ecx, DWORD PTR [ebx+2964]
	mov	DWORD PTR [ebx+2960], edx
	call	??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
	mov	ecx, DWORD PTR [ebp+2980]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+2980], ecx
	mov	eax, ebx
	pop	ebx
	ret	4
??0CvTeam@@QAE@ABV0@@Z ENDP				; CvTeam::CvTeam
_TEXT	ENDS
PUBLIC	?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z ; CvMinorCivAI::GetGoodTechPlayerDoesntHave
EXTRN	??1CvTeam@@QAE@XZ:PROC				; CvTeam::~CvTeam
EXTRN	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z:PROC ; CvTeamTechs::GetResearchProgress
EXTRN	?GetResearchCost@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetResearchCost
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z$1
__ehfuncinfo$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvminorcivai.cpp
xdata$x	ENDS
;	COMDAT ?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z
_TEXT	SEGMENT
_TechVector$ = -3812					; size = 816
_kTeam$ = -2996						; size = 2984
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_iRoughTechValue$ = 12					; size = 4
?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z PROC ; CvMinorCivAI::GetGoodTechPlayerDoesntHave, COMDAT
; _this$ = ecx

; 9722 : {

	push	-1
	push	__ehhandler$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 3800				; 00000ed8H
	push	ebx
	push	ebp

; 9723 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 9724 : 	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 9725 : 
; 9726 : 	CvWeightedVector<int, SAFE_ESTIMATE_NUM_XML_WIDGETS, true> TechVector;

	xor	ebx, ebx
	lea	eax, DWORD PTR _TechVector$[esp+3832]
	push	esi
	mov	DWORD PTR _TechVector$[esp+3828], ebx
	mov	DWORD PTR _TechVector$[esp+3832], 100	; 00000064H
	mov	DWORD PTR _TechVector$[esp+3824], eax

; 9727 : 	int iValue, iProgress;
; 9728 : 
; 9729 : 
; 9730 : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ebp, DWORD PTR _ePlayer$[esp+3820]
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+3832], ebx

; 9731 : 	CvTeam kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR [ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN33@GetGoodTec
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN34@GetGoodTec
$LN33@GetGoodTec:
	or	eax, -1
$LN34@GetGoodTec:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	push	eax
	lea	ecx, DWORD PTR _kTeam$[esp+3832]
	call	??0CvTeam@@QAE@ABV0@@Z

; 9732 : 
; 9733 : #ifdef AUI_WARNING_FIXES
; 9734 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 9735 : #else
; 9736 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+3836], 1
	xor	edi, edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	$LN9@GetGoodTec
	npad	3
$LL138@GetGoodTec:

; 9737 : #endif
; 9738 : 	{
; 9739 : 		const TechTypes eTech = static_cast<TechTypes>(iTechLoop);
; 9740 : 		CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	esi, eax

; 9741 : 		if(pkTechInfo == NULL)

	cmp	esi, ebx
	je	$LN10@GetGoodTec

; 9742 : 			continue;
; 9743 : 
; 9744 : 		// Player doesn't already have Tech
; 9745 : 		if(!kTeam.GetTeamTechs()->HasTech(eTech))

	push	edi
	lea	ecx, DWORD PTR _kTeam$[esp+3832]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	$LN10@GetGoodTec

; 9746 : 		{
; 9747 : 			// Player can research this Tech
; 9748 : 			if(kPlayer.GetPlayerTechs()->CanResearch(eTech))

	push	ebx
	push	edi
	mov	ecx, ebp
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN10@GetGoodTec

; 9749 : 			{
; 9750 : 				iValue = pkTechInfo->GetResearchCost();

	mov	ecx, esi
	call	?GetResearchCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetResearchCost

; 9751 : 
; 9752 : 				// Reduce value of a Tech if it's already in progress
; 9753 : 				iProgress = kTeam.GetTeamTechs()->GetResearchProgress(eTech);

	push	edi
	lea	ecx, DWORD PTR _kTeam$[esp+3832]
	mov	esi, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress

; 9754 : 
; 9755 : 				if(iProgress > 0)

	cmp	eax, ebx
	jle	SHORT $LN5@GetGoodTec

; 9756 : 				{
; 9757 : 					iValue -= iProgress;

	sub	esi, eax
$LN5@GetGoodTec:

; 9758 : 				}
; 9759 : 
; 9760 : 				// Random factor so that the same thing isn't always picked
; 9761 : 				iValue += GC.getGame().getJonRandNum(iValue / 4, "Minor Civ Quest Reward: Tech - Adding random weight to Tech Reward");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	push	OFFSET $SG229119
	sar	eax, 2
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	esi, eax

; 9762 : 
; 9763 : 				TechVector.push_back(iTechLoop, iValue);

	mov	eax, DWORD PTR _TechVector$[esp+3836]
	mov	BYTE PTR _TechVector$[esp+4640], bl
	cmp	DWORD PTR _TechVector$[esp+3832], eax
	jne	SHORT $LN46@GetGoodTec
	push	eax
	lea	ecx, DWORD PTR _TechVector$[esp+3832]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN46@GetGoodTec:
	mov	eax, DWORD PTR _TechVector$[esp+3828]
	mov	ecx, DWORD PTR _TechVector$[esp+3832]
	lea	eax, DWORD PTR [eax+ecx*8]
	cmp	eax, ebx
	je	SHORT $LN49@GetGoodTec
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
$LN49@GetGoodTec:
	inc	DWORD PTR _TechVector$[esp+3832]
$LN10@GetGoodTec:

; 9732 : 
; 9733 : #ifdef AUI_WARNING_FIXES
; 9734 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 9735 : #else
; 9736 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	$LL138@GetGoodTec
$LN9@GetGoodTec:

; 9764 : 			}
; 9765 : 		}
; 9766 : 	}
; 9767 : 
; 9768 : 	// If there's only one option return it... this will help prevent divide by zero stuff later
; 9769 : 	if(TechVector.size() == 1)

	mov	ecx, DWORD PTR _TechVector$[esp+3832]
	pop	edi
	cmp	ecx, 1
	jne	SHORT $LN4@GetGoodTec

; 9770 : 	{
; 9771 : 		return (TechTypes) TechVector.GetElement(0);

	mov	edx, DWORD PTR _TechVector$[esp+3824]
	mov	esi, DWORD PTR [edx]
	lea	ecx, DWORD PTR _kTeam$[esp+3824]
	mov	BYTE PTR __$EHRec$[esp+3832], bl
	call	??1CvTeam@@QAE@XZ			; CvTeam::~CvTeam
	mov	eax, DWORD PTR _TechVector$[esp+3824]
	lea	ecx, DWORD PTR _TechVector$[esp+3836]
	cmp	eax, ecx
	jmp	$LN142@GetGoodTec
$LN4@GetGoodTec:

; 9772 : 	}
; 9773 : 	else if(TechVector.size() == 0)

	cmp	ecx, ebx
	jne	SHORT $LN2@GetGoodTec

; 9774 : 	{
; 9775 : 		return NO_TECH;

	lea	ecx, DWORD PTR _kTeam$[esp+3824]
	mov	BYTE PTR __$EHRec$[esp+3832], bl
	call	??1CvTeam@@QAE@XZ			; CvTeam::~CvTeam
	mov	eax, DWORD PTR _TechVector$[esp+3824]
	lea	edx, DWORD PTR _TechVector$[esp+3836]
	mov	DWORD PTR __$EHRec$[esp+3832], -1
	cmp	eax, edx
	je	SHORT $LN90@GetGoodTec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN90@GetGoodTec:
	or	eax, -1
	jmp	$LN12@GetGoodTec
$LN2@GetGoodTec:

; 9776 : 	}
; 9777 : 
; 9778 : 	TechVector.SortItems();

	mov	eax, DWORD PTR _TechVector$[esp+3824]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,100,1>::WeightedElement *,int>

; 9779 : 
; 9780 : 	// Our rough estimate is that 20 is a good ceiling for the max Tech value
; 9781 : 	if(iRoughTechValue > 20)

	mov	eax, DWORD PTR _iRoughTechValue$[esp+3832]
	add	esp, 12					; 0000000cH
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN1@GetGoodTec

; 9782 : 	{
; 9783 : 		iRoughTechValue = 20;

	mov	eax, 20					; 00000014H
$LN1@GetGoodTec:

; 9784 : 	}
; 9785 : 
; 9786 : 	int iIndex = (TechVector.size() - 1) * iRoughTechValue / 20;

	mov	ecx, DWORD PTR _TechVector$[esp+3828]
	dec	ecx
	imul	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx

; 9787 : 
; 9788 : 	return (TechTypes) TechVector.GetElement(iIndex);

	mov	ecx, DWORD PTR _TechVector$[esp+3824]
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, DWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR _kTeam$[esp+3824]
	mov	BYTE PTR __$EHRec$[esp+3832], bl
	call	??1CvTeam@@QAE@XZ			; CvTeam::~CvTeam
	mov	eax, DWORD PTR _TechVector$[esp+3824]
	lea	edx, DWORD PTR _TechVector$[esp+3836]
	cmp	eax, edx
$LN142@GetGoodTec:
	mov	DWORD PTR __$EHRec$[esp+3832], -1
	je	SHORT $LN123@GetGoodTec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN123@GetGoodTec:
	mov	eax, esi
$LN12@GetGoodTec:

; 9789 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+3824]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 3812				; 00000ee4H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z$0:
	lea	ecx, DWORD PTR _TechVector$[ebp]
	jmp	??1?$CvWeightedVector@H$0GE@$00@@QAE@XZ	; CvWeightedVector<int,100,1>::~CvWeightedVector<int,100,1>
__unwindfunclet$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z$1:
	lea	ecx, DWORD PTR _kTeam$[ebp]
	jmp	??1CvTeam@@QAE@XZ			; CvTeam::~CvTeam
__ehhandler$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGoodTechPlayerDoesntHave@CvMinorCivAI@@QBE?AW4TechTypes@@W4PlayerTypes@@H@Z ENDP ; CvMinorCivAI::GetGoodTechPlayerDoesntHave
END
